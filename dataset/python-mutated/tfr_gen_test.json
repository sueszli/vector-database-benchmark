[
    {
        "func_name": "_tfr_loc_test",
        "original": "@Composite('TestInputNOp')\ndef _tfr_loc_test(x):\n    n = 10\n    x_sum = x[0]\n    for i in range(1, n):\n        x_sum = math_ops.Add(x_sum, x[i])\n    return x_sum",
        "mutated": [
            "@Composite('TestInputNOp')\ndef _tfr_loc_test(x):\n    if False:\n        i = 10\n    n = 10\n    x_sum = x[0]\n    for i in range(1, n):\n        x_sum = math_ops.Add(x_sum, x[i])\n    return x_sum",
            "@Composite('TestInputNOp')\ndef _tfr_loc_test(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    n = 10\n    x_sum = x[0]\n    for i in range(1, n):\n        x_sum = math_ops.Add(x_sum, x[i])\n    return x_sum",
            "@Composite('TestInputNOp')\ndef _tfr_loc_test(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    n = 10\n    x_sum = x[0]\n    for i in range(1, n):\n        x_sum = math_ops.Add(x_sum, x[i])\n    return x_sum",
            "@Composite('TestInputNOp')\ndef _tfr_loc_test(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    n = 10\n    x_sum = x[0]\n    for i in range(1, n):\n        x_sum = math_ops.Add(x_sum, x[i])\n    return x_sum",
            "@Composite('TestInputNOp')\ndef _tfr_loc_test(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    n = 10\n    x_sum = x[0]\n    for i in range(1, n):\n        x_sum = math_ops.Add(x_sum, x[i])\n    return x_sum"
        ]
    },
    {
        "func_name": "_tfr_tensor_empty_arg",
        "original": "@composite.Composite('TestNoOp')\ndef _tfr_tensor_empty_arg():\n    pass",
        "mutated": [
            "@composite.Composite('TestNoOp')\ndef _tfr_tensor_empty_arg():\n    if False:\n        i = 10\n    pass",
            "@composite.Composite('TestNoOp')\ndef _tfr_tensor_empty_arg():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pass",
            "@composite.Composite('TestNoOp')\ndef _tfr_tensor_empty_arg():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pass",
            "@composite.Composite('TestNoOp')\ndef _tfr_tensor_empty_arg():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pass",
            "@composite.Composite('TestNoOp')\ndef _tfr_tensor_empty_arg():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pass"
        ]
    },
    {
        "func_name": "_tfr_tensor_tensor",
        "original": "@composite.Composite('TestIdentityOp')\ndef _tfr_tensor_tensor(x):\n    return x",
        "mutated": [
            "@composite.Composite('TestIdentityOp')\ndef _tfr_tensor_tensor(x):\n    if False:\n        i = 10\n    return x",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_tensor_tensor(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return x",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_tensor_tensor(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return x",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_tensor_tensor(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return x",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_tensor_tensor(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return x"
        ]
    },
    {
        "func_name": "_tfr_tensor_tensor_list",
        "original": "@composite.Composite('TestIdentityNOp')\ndef _tfr_tensor_tensor_list(x):\n    return x",
        "mutated": [
            "@composite.Composite('TestIdentityNOp')\ndef _tfr_tensor_tensor_list(x):\n    if False:\n        i = 10\n    return x",
            "@composite.Composite('TestIdentityNOp')\ndef _tfr_tensor_tensor_list(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return x",
            "@composite.Composite('TestIdentityNOp')\ndef _tfr_tensor_tensor_list(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return x",
            "@composite.Composite('TestIdentityNOp')\ndef _tfr_tensor_tensor_list(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return x",
            "@composite.Composite('TestIdentityNOp')\ndef _tfr_tensor_tensor_list(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return x"
        ]
    },
    {
        "func_name": "_tfr_tensor_tensor_list_get_elt",
        "original": "@composite.Composite('TestInputNOp')\ndef _tfr_tensor_tensor_list_get_elt(x):\n    return x[1]",
        "mutated": [
            "@composite.Composite('TestInputNOp')\ndef _tfr_tensor_tensor_list_get_elt(x):\n    if False:\n        i = 10\n    return x[1]",
            "@composite.Composite('TestInputNOp')\ndef _tfr_tensor_tensor_list_get_elt(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return x[1]",
            "@composite.Composite('TestInputNOp')\ndef _tfr_tensor_tensor_list_get_elt(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return x[1]",
            "@composite.Composite('TestInputNOp')\ndef _tfr_tensor_tensor_list_get_elt(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return x[1]",
            "@composite.Composite('TestInputNOp')\ndef _tfr_tensor_tensor_list_get_elt(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return x[1]"
        ]
    },
    {
        "func_name": "_tfr_tensor_tensor_list_output",
        "original": "@composite.Composite('TestOutputNOp')\ndef _tfr_tensor_tensor_list_output(x):\n    return [x, x]",
        "mutated": [
            "@composite.Composite('TestOutputNOp')\ndef _tfr_tensor_tensor_list_output(x):\n    if False:\n        i = 10\n    return [x, x]",
            "@composite.Composite('TestOutputNOp')\ndef _tfr_tensor_tensor_list_output(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return [x, x]",
            "@composite.Composite('TestOutputNOp')\ndef _tfr_tensor_tensor_list_output(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return [x, x]",
            "@composite.Composite('TestOutputNOp')\ndef _tfr_tensor_tensor_list_output(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return [x, x]",
            "@composite.Composite('TestOutputNOp')\ndef _tfr_tensor_tensor_list_output(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return [x, x]"
        ]
    },
    {
        "func_name": "_tfr_tensor_tensor_list_split",
        "original": "@composite.Composite('TestTwoInputsOp')\ndef _tfr_tensor_tensor_list_split(x, y, pred):\n    (z, _) = array_ops.Split(axis=0, value=x, num_split=2)\n    (y, pred)\n    return z",
        "mutated": [
            "@composite.Composite('TestTwoInputsOp')\ndef _tfr_tensor_tensor_list_split(x, y, pred):\n    if False:\n        i = 10\n    (z, _) = array_ops.Split(axis=0, value=x, num_split=2)\n    (y, pred)\n    return z",
            "@composite.Composite('TestTwoInputsOp')\ndef _tfr_tensor_tensor_list_split(x, y, pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (z, _) = array_ops.Split(axis=0, value=x, num_split=2)\n    (y, pred)\n    return z",
            "@composite.Composite('TestTwoInputsOp')\ndef _tfr_tensor_tensor_list_split(x, y, pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (z, _) = array_ops.Split(axis=0, value=x, num_split=2)\n    (y, pred)\n    return z",
            "@composite.Composite('TestTwoInputsOp')\ndef _tfr_tensor_tensor_list_split(x, y, pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (z, _) = array_ops.Split(axis=0, value=x, num_split=2)\n    (y, pred)\n    return z",
            "@composite.Composite('TestTwoInputsOp')\ndef _tfr_tensor_tensor_list_split(x, y, pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (z, _) = array_ops.Split(axis=0, value=x, num_split=2)\n    (y, pred)\n    return z"
        ]
    },
    {
        "func_name": "_tfr_tensor_two_output",
        "original": "@composite.Composite('TestTwoOutputsOp')\ndef _tfr_tensor_two_output(x):\n    z = array_ops.Split(axis=0, value=x, num_split=2)\n    return (z[0], z[1])",
        "mutated": [
            "@composite.Composite('TestTwoOutputsOp')\ndef _tfr_tensor_two_output(x):\n    if False:\n        i = 10\n    z = array_ops.Split(axis=0, value=x, num_split=2)\n    return (z[0], z[1])",
            "@composite.Composite('TestTwoOutputsOp')\ndef _tfr_tensor_two_output(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    z = array_ops.Split(axis=0, value=x, num_split=2)\n    return (z[0], z[1])",
            "@composite.Composite('TestTwoOutputsOp')\ndef _tfr_tensor_two_output(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    z = array_ops.Split(axis=0, value=x, num_split=2)\n    return (z[0], z[1])",
            "@composite.Composite('TestTwoOutputsOp')\ndef _tfr_tensor_two_output(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    z = array_ops.Split(axis=0, value=x, num_split=2)\n    return (z[0], z[1])",
            "@composite.Composite('TestTwoOutputsOp')\ndef _tfr_tensor_two_output(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    z = array_ops.Split(axis=0, value=x, num_split=2)\n    return (z[0], z[1])"
        ]
    },
    {
        "func_name": "_tfr_tensor_tensor_with_cst",
        "original": "@composite.Composite('TestNumAttrsOp')\ndef _tfr_tensor_tensor_with_cst(x1, y1, x2, y2):\n    x = array_ops.OneHot(indices=[0, 2, -1, x1], depth=y1, on_value=True, off_value=False)\n    (x, x2, y2)\n    return",
        "mutated": [
            "@composite.Composite('TestNumAttrsOp')\ndef _tfr_tensor_tensor_with_cst(x1, y1, x2, y2):\n    if False:\n        i = 10\n    x = array_ops.OneHot(indices=[0, 2, -1, x1], depth=y1, on_value=True, off_value=False)\n    (x, x2, y2)\n    return",
            "@composite.Composite('TestNumAttrsOp')\ndef _tfr_tensor_tensor_with_cst(x1, y1, x2, y2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = array_ops.OneHot(indices=[0, 2, -1, x1], depth=y1, on_value=True, off_value=False)\n    (x, x2, y2)\n    return",
            "@composite.Composite('TestNumAttrsOp')\ndef _tfr_tensor_tensor_with_cst(x1, y1, x2, y2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = array_ops.OneHot(indices=[0, 2, -1, x1], depth=y1, on_value=True, off_value=False)\n    (x, x2, y2)\n    return",
            "@composite.Composite('TestNumAttrsOp')\ndef _tfr_tensor_tensor_with_cst(x1, y1, x2, y2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = array_ops.OneHot(indices=[0, 2, -1, x1], depth=y1, on_value=True, off_value=False)\n    (x, x2, y2)\n    return",
            "@composite.Composite('TestNumAttrsOp')\ndef _tfr_tensor_tensor_with_cst(x1, y1, x2, y2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = array_ops.OneHot(indices=[0, 2, -1, x1], depth=y1, on_value=True, off_value=False)\n    (x, x2, y2)\n    return"
        ]
    },
    {
        "func_name": "_tfr_control_flow_if",
        "original": "@composite.Composite('TestTwoInputsOp')\ndef _tfr_control_flow_if(x, y, pred):\n    if pred:\n        return x\n    else:\n        return y",
        "mutated": [
            "@composite.Composite('TestTwoInputsOp')\ndef _tfr_control_flow_if(x, y, pred):\n    if False:\n        i = 10\n    if pred:\n        return x\n    else:\n        return y",
            "@composite.Composite('TestTwoInputsOp')\ndef _tfr_control_flow_if(x, y, pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if pred:\n        return x\n    else:\n        return y",
            "@composite.Composite('TestTwoInputsOp')\ndef _tfr_control_flow_if(x, y, pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if pred:\n        return x\n    else:\n        return y",
            "@composite.Composite('TestTwoInputsOp')\ndef _tfr_control_flow_if(x, y, pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if pred:\n        return x\n    else:\n        return y",
            "@composite.Composite('TestTwoInputsOp')\ndef _tfr_control_flow_if(x, y, pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if pred:\n        return x\n    else:\n        return y"
        ]
    },
    {
        "func_name": "_tfr_control_flow_nested_if",
        "original": "@composite.Composite('TestThreeInputsOp')\ndef _tfr_control_flow_nested_if(x, y, z, select):\n    if select == 'x':\n        return x\n    elif select == 'y':\n        return y\n    else:\n        return z",
        "mutated": [
            "@composite.Composite('TestThreeInputsOp')\ndef _tfr_control_flow_nested_if(x, y, z, select):\n    if False:\n        i = 10\n    if select == 'x':\n        return x\n    elif select == 'y':\n        return y\n    else:\n        return z",
            "@composite.Composite('TestThreeInputsOp')\ndef _tfr_control_flow_nested_if(x, y, z, select):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if select == 'x':\n        return x\n    elif select == 'y':\n        return y\n    else:\n        return z",
            "@composite.Composite('TestThreeInputsOp')\ndef _tfr_control_flow_nested_if(x, y, z, select):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if select == 'x':\n        return x\n    elif select == 'y':\n        return y\n    else:\n        return z",
            "@composite.Composite('TestThreeInputsOp')\ndef _tfr_control_flow_nested_if(x, y, z, select):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if select == 'x':\n        return x\n    elif select == 'y':\n        return y\n    else:\n        return z",
            "@composite.Composite('TestThreeInputsOp')\ndef _tfr_control_flow_nested_if(x, y, z, select):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if select == 'x':\n        return x\n    elif select == 'y':\n        return y\n    else:\n        return z"
        ]
    },
    {
        "func_name": "_tfr_control_flow_range_for",
        "original": "@composite.Composite('TestInputNOp')\ndef _tfr_control_flow_range_for(x):\n    n = 10\n    x_sum = x[0]\n    for i in range(1, n):\n        x_sum = math_ops.Add(x_sum, x[i])\n    return x_sum",
        "mutated": [
            "@composite.Composite('TestInputNOp')\ndef _tfr_control_flow_range_for(x):\n    if False:\n        i = 10\n    n = 10\n    x_sum = x[0]\n    for i in range(1, n):\n        x_sum = math_ops.Add(x_sum, x[i])\n    return x_sum",
            "@composite.Composite('TestInputNOp')\ndef _tfr_control_flow_range_for(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    n = 10\n    x_sum = x[0]\n    for i in range(1, n):\n        x_sum = math_ops.Add(x_sum, x[i])\n    return x_sum",
            "@composite.Composite('TestInputNOp')\ndef _tfr_control_flow_range_for(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    n = 10\n    x_sum = x[0]\n    for i in range(1, n):\n        x_sum = math_ops.Add(x_sum, x[i])\n    return x_sum",
            "@composite.Composite('TestInputNOp')\ndef _tfr_control_flow_range_for(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    n = 10\n    x_sum = x[0]\n    for i in range(1, n):\n        x_sum = math_ops.Add(x_sum, x[i])\n    return x_sum",
            "@composite.Composite('TestInputNOp')\ndef _tfr_control_flow_range_for(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    n = 10\n    x_sum = x[0]\n    for i in range(1, n):\n        x_sum = math_ops.Add(x_sum, x[i])\n    return x_sum"
        ]
    },
    {
        "func_name": "_tfr_control_flow_tensor_list_size",
        "original": "@composite.Composite('TestInputNOp')\ndef _tfr_control_flow_tensor_list_size(ins):\n    n = len(ins)\n    if n == 0:\n        return array_ops.Const(value=[[0, 1], [2, 3]], dtype=dtypes.int64)\n    else:\n        return math_ops.AddN(ins)",
        "mutated": [
            "@composite.Composite('TestInputNOp')\ndef _tfr_control_flow_tensor_list_size(ins):\n    if False:\n        i = 10\n    n = len(ins)\n    if n == 0:\n        return array_ops.Const(value=[[0, 1], [2, 3]], dtype=dtypes.int64)\n    else:\n        return math_ops.AddN(ins)",
            "@composite.Composite('TestInputNOp')\ndef _tfr_control_flow_tensor_list_size(ins):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    n = len(ins)\n    if n == 0:\n        return array_ops.Const(value=[[0, 1], [2, 3]], dtype=dtypes.int64)\n    else:\n        return math_ops.AddN(ins)",
            "@composite.Composite('TestInputNOp')\ndef _tfr_control_flow_tensor_list_size(ins):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    n = len(ins)\n    if n == 0:\n        return array_ops.Const(value=[[0, 1], [2, 3]], dtype=dtypes.int64)\n    else:\n        return math_ops.AddN(ins)",
            "@composite.Composite('TestInputNOp')\ndef _tfr_control_flow_tensor_list_size(ins):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    n = len(ins)\n    if n == 0:\n        return array_ops.Const(value=[[0, 1], [2, 3]], dtype=dtypes.int64)\n    else:\n        return math_ops.AddN(ins)",
            "@composite.Composite('TestInputNOp')\ndef _tfr_control_flow_tensor_list_size(ins):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    n = len(ins)\n    if n == 0:\n        return array_ops.Const(value=[[0, 1], [2, 3]], dtype=dtypes.int64)\n    else:\n        return math_ops.AddN(ins)"
        ]
    },
    {
        "func_name": "_tfr_tf_ops_complex",
        "original": "@composite.Composite('TestComplexTFOp')\ndef _tfr_tf_ops_complex(lhs, rhs):\n    (left_padding, _) = array_ops.SplitV(value=lhs, size_splits=[rhs, -1], axis=0, num_split=2)\n    (_, right_padding) = array_ops.SplitV(value=lhs, size_splits=[rhs, rhs], axis=1, num_split=2)\n    return [left_padding, right_padding]",
        "mutated": [
            "@composite.Composite('TestComplexTFOp')\ndef _tfr_tf_ops_complex(lhs, rhs):\n    if False:\n        i = 10\n    (left_padding, _) = array_ops.SplitV(value=lhs, size_splits=[rhs, -1], axis=0, num_split=2)\n    (_, right_padding) = array_ops.SplitV(value=lhs, size_splits=[rhs, rhs], axis=1, num_split=2)\n    return [left_padding, right_padding]",
            "@composite.Composite('TestComplexTFOp')\ndef _tfr_tf_ops_complex(lhs, rhs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (left_padding, _) = array_ops.SplitV(value=lhs, size_splits=[rhs, -1], axis=0, num_split=2)\n    (_, right_padding) = array_ops.SplitV(value=lhs, size_splits=[rhs, rhs], axis=1, num_split=2)\n    return [left_padding, right_padding]",
            "@composite.Composite('TestComplexTFOp')\ndef _tfr_tf_ops_complex(lhs, rhs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (left_padding, _) = array_ops.SplitV(value=lhs, size_splits=[rhs, -1], axis=0, num_split=2)\n    (_, right_padding) = array_ops.SplitV(value=lhs, size_splits=[rhs, rhs], axis=1, num_split=2)\n    return [left_padding, right_padding]",
            "@composite.Composite('TestComplexTFOp')\ndef _tfr_tf_ops_complex(lhs, rhs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (left_padding, _) = array_ops.SplitV(value=lhs, size_splits=[rhs, -1], axis=0, num_split=2)\n    (_, right_padding) = array_ops.SplitV(value=lhs, size_splits=[rhs, rhs], axis=1, num_split=2)\n    return [left_padding, right_padding]",
            "@composite.Composite('TestComplexTFOp')\ndef _tfr_tf_ops_complex(lhs, rhs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (left_padding, _) = array_ops.SplitV(value=lhs, size_splits=[rhs, -1], axis=0, num_split=2)\n    (_, right_padding) = array_ops.SplitV(value=lhs, size_splits=[rhs, rhs], axis=1, num_split=2)\n    return [left_padding, right_padding]"
        ]
    },
    {
        "func_name": "_tfr_tf_ops_tensor",
        "original": "@composite.Composite('TestIdentityOp')\ndef _tfr_tf_ops_tensor(x):\n    return array_ops.Identity(x)",
        "mutated": [
            "@composite.Composite('TestIdentityOp')\ndef _tfr_tf_ops_tensor(x):\n    if False:\n        i = 10\n    return array_ops.Identity(x)",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_tf_ops_tensor(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return array_ops.Identity(x)",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_tf_ops_tensor(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return array_ops.Identity(x)",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_tf_ops_tensor(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return array_ops.Identity(x)",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_tf_ops_tensor(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return array_ops.Identity(x)"
        ]
    },
    {
        "func_name": "_tfr_tf_ops_tensors",
        "original": "@composite.Composite('TestTwoInputsOp')\ndef _tfr_tf_ops_tensors(x, y, pred):\n    if pred:\n        return math_ops.Add(x, y)\n    else:\n        return array_ops.Concat(0, [x, y])",
        "mutated": [
            "@composite.Composite('TestTwoInputsOp')\ndef _tfr_tf_ops_tensors(x, y, pred):\n    if False:\n        i = 10\n    if pred:\n        return math_ops.Add(x, y)\n    else:\n        return array_ops.Concat(0, [x, y])",
            "@composite.Composite('TestTwoInputsOp')\ndef _tfr_tf_ops_tensors(x, y, pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if pred:\n        return math_ops.Add(x, y)\n    else:\n        return array_ops.Concat(0, [x, y])",
            "@composite.Composite('TestTwoInputsOp')\ndef _tfr_tf_ops_tensors(x, y, pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if pred:\n        return math_ops.Add(x, y)\n    else:\n        return array_ops.Concat(0, [x, y])",
            "@composite.Composite('TestTwoInputsOp')\ndef _tfr_tf_ops_tensors(x, y, pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if pred:\n        return math_ops.Add(x, y)\n    else:\n        return array_ops.Concat(0, [x, y])",
            "@composite.Composite('TestTwoInputsOp')\ndef _tfr_tf_ops_tensors(x, y, pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if pred:\n        return math_ops.Add(x, y)\n    else:\n        return array_ops.Concat(0, [x, y])"
        ]
    },
    {
        "func_name": "_tfr_tf_ops_with_defaults",
        "original": "@composite.Composite('TestInputNOp')\ndef _tfr_tf_ops_with_defaults(ins):\n    return test_ops.TestTwoInputsOp(ins[0], ins[1])",
        "mutated": [
            "@composite.Composite('TestInputNOp')\ndef _tfr_tf_ops_with_defaults(ins):\n    if False:\n        i = 10\n    return test_ops.TestTwoInputsOp(ins[0], ins[1])",
            "@composite.Composite('TestInputNOp')\ndef _tfr_tf_ops_with_defaults(ins):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return test_ops.TestTwoInputsOp(ins[0], ins[1])",
            "@composite.Composite('TestInputNOp')\ndef _tfr_tf_ops_with_defaults(ins):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return test_ops.TestTwoInputsOp(ins[0], ins[1])",
            "@composite.Composite('TestInputNOp')\ndef _tfr_tf_ops_with_defaults(ins):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return test_ops.TestTwoInputsOp(ins[0], ins[1])",
            "@composite.Composite('TestInputNOp')\ndef _tfr_tf_ops_with_defaults(ins):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return test_ops.TestTwoInputsOp(ins[0], ins[1])"
        ]
    },
    {
        "func_name": "_tfr_attrs_num_type",
        "original": "@composite.Composite('TestNumAttrsOp')\ndef _tfr_attrs_num_type(x, y, x1, y1):\n    z0 = [x, y]\n    z1 = x == y\n    z2 = x < y\n    z3 = x <= y\n    z4 = x > y\n    z5 = x >= y\n    z6 = x != y\n    z7 = x + y\n    z8 = x - y\n    z8 += x\n    z8 += 1\n    (z0, z1, z2, z3, z4, z5, z6, z7, z8)\n    z9 = x1 > y1\n    z10 = x1 + y1\n    z11 = [x1, y1]\n    (z9, z10, z11)\n    return",
        "mutated": [
            "@composite.Composite('TestNumAttrsOp')\ndef _tfr_attrs_num_type(x, y, x1, y1):\n    if False:\n        i = 10\n    z0 = [x, y]\n    z1 = x == y\n    z2 = x < y\n    z3 = x <= y\n    z4 = x > y\n    z5 = x >= y\n    z6 = x != y\n    z7 = x + y\n    z8 = x - y\n    z8 += x\n    z8 += 1\n    (z0, z1, z2, z3, z4, z5, z6, z7, z8)\n    z9 = x1 > y1\n    z10 = x1 + y1\n    z11 = [x1, y1]\n    (z9, z10, z11)\n    return",
            "@composite.Composite('TestNumAttrsOp')\ndef _tfr_attrs_num_type(x, y, x1, y1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    z0 = [x, y]\n    z1 = x == y\n    z2 = x < y\n    z3 = x <= y\n    z4 = x > y\n    z5 = x >= y\n    z6 = x != y\n    z7 = x + y\n    z8 = x - y\n    z8 += x\n    z8 += 1\n    (z0, z1, z2, z3, z4, z5, z6, z7, z8)\n    z9 = x1 > y1\n    z10 = x1 + y1\n    z11 = [x1, y1]\n    (z9, z10, z11)\n    return",
            "@composite.Composite('TestNumAttrsOp')\ndef _tfr_attrs_num_type(x, y, x1, y1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    z0 = [x, y]\n    z1 = x == y\n    z2 = x < y\n    z3 = x <= y\n    z4 = x > y\n    z5 = x >= y\n    z6 = x != y\n    z7 = x + y\n    z8 = x - y\n    z8 += x\n    z8 += 1\n    (z0, z1, z2, z3, z4, z5, z6, z7, z8)\n    z9 = x1 > y1\n    z10 = x1 + y1\n    z11 = [x1, y1]\n    (z9, z10, z11)\n    return",
            "@composite.Composite('TestNumAttrsOp')\ndef _tfr_attrs_num_type(x, y, x1, y1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    z0 = [x, y]\n    z1 = x == y\n    z2 = x < y\n    z3 = x <= y\n    z4 = x > y\n    z5 = x >= y\n    z6 = x != y\n    z7 = x + y\n    z8 = x - y\n    z8 += x\n    z8 += 1\n    (z0, z1, z2, z3, z4, z5, z6, z7, z8)\n    z9 = x1 > y1\n    z10 = x1 + y1\n    z11 = [x1, y1]\n    (z9, z10, z11)\n    return",
            "@composite.Composite('TestNumAttrsOp')\ndef _tfr_attrs_num_type(x, y, x1, y1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    z0 = [x, y]\n    z1 = x == y\n    z2 = x < y\n    z3 = x <= y\n    z4 = x > y\n    z5 = x >= y\n    z6 = x != y\n    z7 = x + y\n    z8 = x - y\n    z8 += x\n    z8 += 1\n    (z0, z1, z2, z3, z4, z5, z6, z7, z8)\n    z9 = x1 > y1\n    z10 = x1 + y1\n    z11 = [x1, y1]\n    (z9, z10, z11)\n    return"
        ]
    },
    {
        "func_name": "_tfr_attrs_tfr_type",
        "original": "@composite.Composite('TestNonNumAttrsOp')\ndef _tfr_attrs_tfr_type(x, y, z):\n    z1 = x == y\n    z2 = x == 'test'\n    z3 = y == z\n    (z1, z2, z3)\n    return",
        "mutated": [
            "@composite.Composite('TestNonNumAttrsOp')\ndef _tfr_attrs_tfr_type(x, y, z):\n    if False:\n        i = 10\n    z1 = x == y\n    z2 = x == 'test'\n    z3 = y == z\n    (z1, z2, z3)\n    return",
            "@composite.Composite('TestNonNumAttrsOp')\ndef _tfr_attrs_tfr_type(x, y, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    z1 = x == y\n    z2 = x == 'test'\n    z3 = y == z\n    (z1, z2, z3)\n    return",
            "@composite.Composite('TestNonNumAttrsOp')\ndef _tfr_attrs_tfr_type(x, y, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    z1 = x == y\n    z2 = x == 'test'\n    z3 = y == z\n    (z1, z2, z3)\n    return",
            "@composite.Composite('TestNonNumAttrsOp')\ndef _tfr_attrs_tfr_type(x, y, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    z1 = x == y\n    z2 = x == 'test'\n    z3 = y == z\n    (z1, z2, z3)\n    return",
            "@composite.Composite('TestNonNumAttrsOp')\ndef _tfr_attrs_tfr_type(x, y, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    z1 = x == y\n    z2 = x == 'test'\n    z3 = y == z\n    (z1, z2, z3)\n    return"
        ]
    },
    {
        "func_name": "_tfr_shapes",
        "original": "@composite.Composite('TestIdentityOp')\ndef _tfr_shapes(x):\n    s1 = x.shape\n    s3 = x.shape.as_list()\n    for i in range(len(s3)):\n        s3[i]\n    for i in range(1, len(s3), 2):\n        s3[i]\n    s5 = array_ops.Shape(x)\n    (s1, s3, s5)\n    return x",
        "mutated": [
            "@composite.Composite('TestIdentityOp')\ndef _tfr_shapes(x):\n    if False:\n        i = 10\n    s1 = x.shape\n    s3 = x.shape.as_list()\n    for i in range(len(s3)):\n        s3[i]\n    for i in range(1, len(s3), 2):\n        s3[i]\n    s5 = array_ops.Shape(x)\n    (s1, s3, s5)\n    return x",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_shapes(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s1 = x.shape\n    s3 = x.shape.as_list()\n    for i in range(len(s3)):\n        s3[i]\n    for i in range(1, len(s3), 2):\n        s3[i]\n    s5 = array_ops.Shape(x)\n    (s1, s3, s5)\n    return x",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_shapes(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s1 = x.shape\n    s3 = x.shape.as_list()\n    for i in range(len(s3)):\n        s3[i]\n    for i in range(1, len(s3), 2):\n        s3[i]\n    s5 = array_ops.Shape(x)\n    (s1, s3, s5)\n    return x",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_shapes(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s1 = x.shape\n    s3 = x.shape.as_list()\n    for i in range(len(s3)):\n        s3[i]\n    for i in range(1, len(s3), 2):\n        s3[i]\n    s5 = array_ops.Shape(x)\n    (s1, s3, s5)\n    return x",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_shapes(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s1 = x.shape\n    s3 = x.shape.as_list()\n    for i in range(len(s3)):\n        s3[i]\n    for i in range(1, len(s3), 2):\n        s3[i]\n    s5 = array_ops.Shape(x)\n    (s1, s3, s5)\n    return x"
        ]
    },
    {
        "func_name": "_tfr_temp_op",
        "original": "@composite.Composite('TestIdentityNOp')\ndef _tfr_temp_op(x):\n    return x",
        "mutated": [
            "@composite.Composite('TestIdentityNOp')\ndef _tfr_temp_op(x):\n    if False:\n        i = 10\n    return x",
            "@composite.Composite('TestIdentityNOp')\ndef _tfr_temp_op(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return x",
            "@composite.Composite('TestIdentityNOp')\ndef _tfr_temp_op(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return x",
            "@composite.Composite('TestIdentityNOp')\ndef _tfr_temp_op(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return x",
            "@composite.Composite('TestIdentityNOp')\ndef _tfr_temp_op(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return x"
        ]
    },
    {
        "func_name": "_tfr_temp_use_op",
        "original": "@composite.Composite('TestIdentityOp')\ndef _tfr_temp_use_op(x):\n    y = _tfr_temp_op([x])\n    return y[0]",
        "mutated": [
            "@composite.Composite('TestIdentityOp')\ndef _tfr_temp_use_op(x):\n    if False:\n        i = 10\n    y = _tfr_temp_op([x])\n    return y[0]",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_temp_use_op(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    y = _tfr_temp_op([x])\n    return y[0]",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_temp_use_op(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    y = _tfr_temp_op([x])\n    return y[0]",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_temp_use_op(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    y = _tfr_temp_op([x])\n    return y[0]",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_temp_use_op(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    y = _tfr_temp_op([x])\n    return y[0]"
        ]
    },
    {
        "func_name": "_tfr_quant_test",
        "original": "@composite.Composite('TestIdentityOp')\ndef _tfr_quant_test(x):\n    y = _tfr_quant_raw_data(x)\n    (s, z) = _tfr_quant_qparam(x)\n    s = _tfr_quant_scale_factor(1.0, [s, s])\n    s = _tfr_quant_scale_factor(1.0, [s])\n    y = math_ops.Sub(y, z)\n    (qmin, qmax) = _tfr_quant_act_range('RELU', 1.0, 0)\n    (qmin, qmax)\n    d = _tfr_quant_rescale(y, s, 0)\n    e = math_ops.Cast(x=d, DstT=dtypes.int16)\n    f = math_ops.Cast(x=e, DstT=dtypes.int8)\n    return f",
        "mutated": [
            "@composite.Composite('TestIdentityOp')\ndef _tfr_quant_test(x):\n    if False:\n        i = 10\n    y = _tfr_quant_raw_data(x)\n    (s, z) = _tfr_quant_qparam(x)\n    s = _tfr_quant_scale_factor(1.0, [s, s])\n    s = _tfr_quant_scale_factor(1.0, [s])\n    y = math_ops.Sub(y, z)\n    (qmin, qmax) = _tfr_quant_act_range('RELU', 1.0, 0)\n    (qmin, qmax)\n    d = _tfr_quant_rescale(y, s, 0)\n    e = math_ops.Cast(x=d, DstT=dtypes.int16)\n    f = math_ops.Cast(x=e, DstT=dtypes.int8)\n    return f",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_quant_test(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    y = _tfr_quant_raw_data(x)\n    (s, z) = _tfr_quant_qparam(x)\n    s = _tfr_quant_scale_factor(1.0, [s, s])\n    s = _tfr_quant_scale_factor(1.0, [s])\n    y = math_ops.Sub(y, z)\n    (qmin, qmax) = _tfr_quant_act_range('RELU', 1.0, 0)\n    (qmin, qmax)\n    d = _tfr_quant_rescale(y, s, 0)\n    e = math_ops.Cast(x=d, DstT=dtypes.int16)\n    f = math_ops.Cast(x=e, DstT=dtypes.int8)\n    return f",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_quant_test(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    y = _tfr_quant_raw_data(x)\n    (s, z) = _tfr_quant_qparam(x)\n    s = _tfr_quant_scale_factor(1.0, [s, s])\n    s = _tfr_quant_scale_factor(1.0, [s])\n    y = math_ops.Sub(y, z)\n    (qmin, qmax) = _tfr_quant_act_range('RELU', 1.0, 0)\n    (qmin, qmax)\n    d = _tfr_quant_rescale(y, s, 0)\n    e = math_ops.Cast(x=d, DstT=dtypes.int16)\n    f = math_ops.Cast(x=e, DstT=dtypes.int8)\n    return f",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_quant_test(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    y = _tfr_quant_raw_data(x)\n    (s, z) = _tfr_quant_qparam(x)\n    s = _tfr_quant_scale_factor(1.0, [s, s])\n    s = _tfr_quant_scale_factor(1.0, [s])\n    y = math_ops.Sub(y, z)\n    (qmin, qmax) = _tfr_quant_act_range('RELU', 1.0, 0)\n    (qmin, qmax)\n    d = _tfr_quant_rescale(y, s, 0)\n    e = math_ops.Cast(x=d, DstT=dtypes.int16)\n    f = math_ops.Cast(x=e, DstT=dtypes.int8)\n    return f",
            "@composite.Composite('TestIdentityOp')\ndef _tfr_quant_test(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    y = _tfr_quant_raw_data(x)\n    (s, z) = _tfr_quant_qparam(x)\n    s = _tfr_quant_scale_factor(1.0, [s, s])\n    s = _tfr_quant_scale_factor(1.0, [s])\n    y = math_ops.Sub(y, z)\n    (qmin, qmax) = _tfr_quant_act_range('RELU', 1.0, 0)\n    (qmin, qmax)\n    d = _tfr_quant_rescale(y, s, 0)\n    e = math_ops.Cast(x=d, DstT=dtypes.int16)\n    f = math_ops.Cast(x=e, DstT=dtypes.int8)\n    return f"
        ]
    },
    {
        "func_name": "_tfr_quant_test_n",
        "original": "@composite.Composite('TestIdentityNOp')\ndef _tfr_quant_test_n(x):\n    y = _tfr_quant_raw_data(x)\n    return y",
        "mutated": [
            "@composite.Composite('TestIdentityNOp')\ndef _tfr_quant_test_n(x):\n    if False:\n        i = 10\n    y = _tfr_quant_raw_data(x)\n    return y",
            "@composite.Composite('TestIdentityNOp')\ndef _tfr_quant_test_n(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    y = _tfr_quant_raw_data(x)\n    return y",
            "@composite.Composite('TestIdentityNOp')\ndef _tfr_quant_test_n(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    y = _tfr_quant_raw_data(x)\n    return y",
            "@composite.Composite('TestIdentityNOp')\ndef _tfr_quant_test_n(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    y = _tfr_quant_raw_data(x)\n    return y",
            "@composite.Composite('TestIdentityNOp')\ndef _tfr_quant_test_n(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    y = _tfr_quant_raw_data(x)\n    return y"
        ]
    },
    {
        "func_name": "_check_code",
        "original": "def _check_code(self, tfr_code, exp_tfr_code):\n    return self.assertTrue(fw.check(str(tfr_code), exp_tfr_code), str(tfr_code))",
        "mutated": [
            "def _check_code(self, tfr_code, exp_tfr_code):\n    if False:\n        i = 10\n    return self.assertTrue(fw.check(str(tfr_code), exp_tfr_code), str(tfr_code))",
            "def _check_code(self, tfr_code, exp_tfr_code):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.assertTrue(fw.check(str(tfr_code), exp_tfr_code), str(tfr_code))",
            "def _check_code(self, tfr_code, exp_tfr_code):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.assertTrue(fw.check(str(tfr_code), exp_tfr_code), str(tfr_code))",
            "def _check_code(self, tfr_code, exp_tfr_code):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.assertTrue(fw.check(str(tfr_code), exp_tfr_code), str(tfr_code))",
            "def _check_code(self, tfr_code, exp_tfr_code):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.assertTrue(fw.check(str(tfr_code), exp_tfr_code), str(tfr_code))"
        ]
    },
    {
        "func_name": "test_tfr_loc",
        "original": "def test_tfr_loc(self):\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_loc', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[n:.*]] = arith.constant 10 : i64\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%{{.*}}:6)\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 0 : index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[sum_line:.*]]:10)\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %x[%[[cst]]] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[sum_line]]:10)\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 1 : i64\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line:.*]]:2)\\n      CHECK-NEXT:   %[[begin:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[end:.*]] = arith.index_cast %[[n]] : i64 to index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[for_stmt:.*]] = scf.for %[[itr_1:.*]] = %[[begin]] to %[[end]] step %[[step]]\\n      CHECK-SAME:       iter_args(%[[it_arg:.*]] = %[[elt]]) -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[elt_1:.*]] = tfr.get_element %x[%itr_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[add_line:.*]]:34)\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%[[it_arg]], %[[elt_1]]) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[add_line]]:12)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT:   }\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT:   tfr.return %[[for_stmt]] : !tfr.tensor\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT: }\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%{{def_line:.*}}:0)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
        "mutated": [
            "def test_tfr_loc(self):\n    if False:\n        i = 10\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_loc', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[n:.*]] = arith.constant 10 : i64\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%{{.*}}:6)\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 0 : index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[sum_line:.*]]:10)\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %x[%[[cst]]] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[sum_line]]:10)\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 1 : i64\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line:.*]]:2)\\n      CHECK-NEXT:   %[[begin:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[end:.*]] = arith.index_cast %[[n]] : i64 to index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[for_stmt:.*]] = scf.for %[[itr_1:.*]] = %[[begin]] to %[[end]] step %[[step]]\\n      CHECK-SAME:       iter_args(%[[it_arg:.*]] = %[[elt]]) -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[elt_1:.*]] = tfr.get_element %x[%itr_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[add_line:.*]]:34)\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%[[it_arg]], %[[elt_1]]) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[add_line]]:12)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT:   }\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT:   tfr.return %[[for_stmt]] : !tfr.tensor\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT: }\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%{{def_line:.*}}:0)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_loc(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_loc', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[n:.*]] = arith.constant 10 : i64\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%{{.*}}:6)\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 0 : index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[sum_line:.*]]:10)\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %x[%[[cst]]] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[sum_line]]:10)\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 1 : i64\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line:.*]]:2)\\n      CHECK-NEXT:   %[[begin:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[end:.*]] = arith.index_cast %[[n]] : i64 to index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[for_stmt:.*]] = scf.for %[[itr_1:.*]] = %[[begin]] to %[[end]] step %[[step]]\\n      CHECK-SAME:       iter_args(%[[it_arg:.*]] = %[[elt]]) -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[elt_1:.*]] = tfr.get_element %x[%itr_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[add_line:.*]]:34)\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%[[it_arg]], %[[elt_1]]) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[add_line]]:12)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT:   }\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT:   tfr.return %[[for_stmt]] : !tfr.tensor\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT: }\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%{{def_line:.*}}:0)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_loc(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_loc', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[n:.*]] = arith.constant 10 : i64\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%{{.*}}:6)\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 0 : index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[sum_line:.*]]:10)\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %x[%[[cst]]] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[sum_line]]:10)\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 1 : i64\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line:.*]]:2)\\n      CHECK-NEXT:   %[[begin:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[end:.*]] = arith.index_cast %[[n]] : i64 to index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[for_stmt:.*]] = scf.for %[[itr_1:.*]] = %[[begin]] to %[[end]] step %[[step]]\\n      CHECK-SAME:       iter_args(%[[it_arg:.*]] = %[[elt]]) -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[elt_1:.*]] = tfr.get_element %x[%itr_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[add_line:.*]]:34)\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%[[it_arg]], %[[elt_1]]) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[add_line]]:12)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT:   }\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT:   tfr.return %[[for_stmt]] : !tfr.tensor\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT: }\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%{{def_line:.*}}:0)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_loc(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_loc', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[n:.*]] = arith.constant 10 : i64\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%{{.*}}:6)\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 0 : index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[sum_line:.*]]:10)\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %x[%[[cst]]] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[sum_line]]:10)\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 1 : i64\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line:.*]]:2)\\n      CHECK-NEXT:   %[[begin:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[end:.*]] = arith.index_cast %[[n]] : i64 to index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[for_stmt:.*]] = scf.for %[[itr_1:.*]] = %[[begin]] to %[[end]] step %[[step]]\\n      CHECK-SAME:       iter_args(%[[it_arg:.*]] = %[[elt]]) -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[elt_1:.*]] = tfr.get_element %x[%itr_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[add_line:.*]]:34)\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%[[it_arg]], %[[elt_1]]) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[add_line]]:12)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT:   }\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT:   tfr.return %[[for_stmt]] : !tfr.tensor\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT: }\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%{{def_line:.*}}:0)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_loc(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_loc', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[n:.*]] = arith.constant 10 : i64\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%{{.*}}:6)\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 0 : index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[sum_line:.*]]:10)\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %x[%[[cst]]] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[sum_line]]:10)\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 1 : i64\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line:.*]]:2)\\n      CHECK-NEXT:   %[[begin:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[end:.*]] = arith.index_cast %[[n]] : i64 to index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %[[for_stmt:.*]] = scf.for %[[itr_1:.*]] = %[[begin]] to %[[end]] step %[[step]]\\n      CHECK-SAME:       iter_args(%[[it_arg:.*]] = %[[elt]]) -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[elt_1:.*]] = tfr.get_element %x[%itr_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[add_line:.*]]:34)\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%[[it_arg]], %[[elt_1]]) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[add_line]]:12)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT:   }\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%[[for_line]]:2)\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT:   tfr.return %[[for_stmt]] : !tfr.tensor\\n      CHECK-SAME        loc(unknown)\\n      CHECK-NEXT: }\\n      CHECK-SAME        loc(\"tfr_gen_test.py\":%{{def_line:.*}}:0)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)"
        ]
    },
    {
        "func_name": "test_tfr_tensors",
        "original": "def test_tfr_tensors(self):\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_tensor', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_no_op() -> () {\\n      CHECK-NEXT:    tfr.return\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT:    tfr.return %x : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT:    tfr.return %x : !tfr.tensor_list\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[index:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[sub:.*]] = tfr.get_element %x[%cst_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: tfr.return %[[sub]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_output_n_op(%x: !tfr.tensor) -> (!tfr.tensor_list) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[list:.*]] = \"tfr.build_list\"(%x, %x) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT: tfr.return %[[list]] : !tfr.tensor_list\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor, %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[Split:.*]] = tfr.call @tf__split(%[[cst_2]], %x, %[[cst_1]]) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor_list)\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant 0 : index\\n      CHECK-NEXT: %[[elt:.*]] = tfr.get_element %[[Split]][%idx] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[elt_1:.*]] = tfr.get_element %[[Split]][%idx_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: tfr.return %[[elt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_outputs_op(%x: !tfr.tensor) -> (!tfr.tensor, !tfr.tensor) {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[Split:.*]] = tfr.call @tf__split(%[[cst_2]], %x, %[[cst_1]]) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor_list)\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant 0 : index\\n      CHECK-NEXT: %[[elt:.*]] = tfr.get_element %[[Split]][%cst_4] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[elt_1:.*]] = tfr.get_element %[[Split]][%cst_5] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: tfr.return %[[elt]], %[[elt_1]] : !tfr.tensor, !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_num_attrs_op(%x1: i64{tfr.name=\"x1\",tfr.default=-10}, %y1: i64{tfr.name=\"y1\",tfr.default=1}, %x2: f32{tfr.name=\"x2\",tfr.default=0.0}, %y2: f32{tfr.name=\"y2\",tfr.default=-3.0}) -> () {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT: %[[zero:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_3:.*]] = arith.subi %zero, %cst_2 : i64\\n      CHECK-NEXT: %[[list:.*]] = \"tfr.build_list\"(%[[cst]], %[[cst_1]], %[[cst_3]], %x1) : (i64, i64, i64, i64) -> !tfr.attr\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant true\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant false\\n      CHECK-NEXT: %[[cst_6:.*]] = \"tfr.constant_tensor\"(%[[list]]) : (!tfr.attr) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_7:.*]] = \"tfr.constant_tensor\"(%y1) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_8:.*]] = \"tfr.constant_tensor\"(%[[cst_4]]) : (i1) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_9:.*]] = \"tfr.constant_tensor\"(%[[cst_5]]) : (i1) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_10:.*]] = arith.constant -1 : i64\\n      CHECK-NEXT: %[[OneHot:.*]] = tfr.call @tf__one_hot(%[[cst_6]], %[[cst_7]], %[[cst_8]], %[[cst_9]], %[[cst_10]])\\n      CHECK-SAME:   (!tfr.tensor, !tfr.tensor, !tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor)\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
        "mutated": [
            "def test_tfr_tensors(self):\n    if False:\n        i = 10\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_tensor', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_no_op() -> () {\\n      CHECK-NEXT:    tfr.return\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT:    tfr.return %x : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT:    tfr.return %x : !tfr.tensor_list\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[index:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[sub:.*]] = tfr.get_element %x[%cst_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: tfr.return %[[sub]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_output_n_op(%x: !tfr.tensor) -> (!tfr.tensor_list) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[list:.*]] = \"tfr.build_list\"(%x, %x) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT: tfr.return %[[list]] : !tfr.tensor_list\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor, %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[Split:.*]] = tfr.call @tf__split(%[[cst_2]], %x, %[[cst_1]]) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor_list)\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant 0 : index\\n      CHECK-NEXT: %[[elt:.*]] = tfr.get_element %[[Split]][%idx] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[elt_1:.*]] = tfr.get_element %[[Split]][%idx_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: tfr.return %[[elt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_outputs_op(%x: !tfr.tensor) -> (!tfr.tensor, !tfr.tensor) {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[Split:.*]] = tfr.call @tf__split(%[[cst_2]], %x, %[[cst_1]]) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor_list)\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant 0 : index\\n      CHECK-NEXT: %[[elt:.*]] = tfr.get_element %[[Split]][%cst_4] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[elt_1:.*]] = tfr.get_element %[[Split]][%cst_5] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: tfr.return %[[elt]], %[[elt_1]] : !tfr.tensor, !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_num_attrs_op(%x1: i64{tfr.name=\"x1\",tfr.default=-10}, %y1: i64{tfr.name=\"y1\",tfr.default=1}, %x2: f32{tfr.name=\"x2\",tfr.default=0.0}, %y2: f32{tfr.name=\"y2\",tfr.default=-3.0}) -> () {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT: %[[zero:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_3:.*]] = arith.subi %zero, %cst_2 : i64\\n      CHECK-NEXT: %[[list:.*]] = \"tfr.build_list\"(%[[cst]], %[[cst_1]], %[[cst_3]], %x1) : (i64, i64, i64, i64) -> !tfr.attr\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant true\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant false\\n      CHECK-NEXT: %[[cst_6:.*]] = \"tfr.constant_tensor\"(%[[list]]) : (!tfr.attr) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_7:.*]] = \"tfr.constant_tensor\"(%y1) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_8:.*]] = \"tfr.constant_tensor\"(%[[cst_4]]) : (i1) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_9:.*]] = \"tfr.constant_tensor\"(%[[cst_5]]) : (i1) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_10:.*]] = arith.constant -1 : i64\\n      CHECK-NEXT: %[[OneHot:.*]] = tfr.call @tf__one_hot(%[[cst_6]], %[[cst_7]], %[[cst_8]], %[[cst_9]], %[[cst_10]])\\n      CHECK-SAME:   (!tfr.tensor, !tfr.tensor, !tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor)\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_tensors(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_tensor', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_no_op() -> () {\\n      CHECK-NEXT:    tfr.return\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT:    tfr.return %x : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT:    tfr.return %x : !tfr.tensor_list\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[index:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[sub:.*]] = tfr.get_element %x[%cst_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: tfr.return %[[sub]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_output_n_op(%x: !tfr.tensor) -> (!tfr.tensor_list) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[list:.*]] = \"tfr.build_list\"(%x, %x) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT: tfr.return %[[list]] : !tfr.tensor_list\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor, %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[Split:.*]] = tfr.call @tf__split(%[[cst_2]], %x, %[[cst_1]]) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor_list)\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant 0 : index\\n      CHECK-NEXT: %[[elt:.*]] = tfr.get_element %[[Split]][%idx] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[elt_1:.*]] = tfr.get_element %[[Split]][%idx_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: tfr.return %[[elt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_outputs_op(%x: !tfr.tensor) -> (!tfr.tensor, !tfr.tensor) {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[Split:.*]] = tfr.call @tf__split(%[[cst_2]], %x, %[[cst_1]]) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor_list)\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant 0 : index\\n      CHECK-NEXT: %[[elt:.*]] = tfr.get_element %[[Split]][%cst_4] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[elt_1:.*]] = tfr.get_element %[[Split]][%cst_5] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: tfr.return %[[elt]], %[[elt_1]] : !tfr.tensor, !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_num_attrs_op(%x1: i64{tfr.name=\"x1\",tfr.default=-10}, %y1: i64{tfr.name=\"y1\",tfr.default=1}, %x2: f32{tfr.name=\"x2\",tfr.default=0.0}, %y2: f32{tfr.name=\"y2\",tfr.default=-3.0}) -> () {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT: %[[zero:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_3:.*]] = arith.subi %zero, %cst_2 : i64\\n      CHECK-NEXT: %[[list:.*]] = \"tfr.build_list\"(%[[cst]], %[[cst_1]], %[[cst_3]], %x1) : (i64, i64, i64, i64) -> !tfr.attr\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant true\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant false\\n      CHECK-NEXT: %[[cst_6:.*]] = \"tfr.constant_tensor\"(%[[list]]) : (!tfr.attr) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_7:.*]] = \"tfr.constant_tensor\"(%y1) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_8:.*]] = \"tfr.constant_tensor\"(%[[cst_4]]) : (i1) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_9:.*]] = \"tfr.constant_tensor\"(%[[cst_5]]) : (i1) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_10:.*]] = arith.constant -1 : i64\\n      CHECK-NEXT: %[[OneHot:.*]] = tfr.call @tf__one_hot(%[[cst_6]], %[[cst_7]], %[[cst_8]], %[[cst_9]], %[[cst_10]])\\n      CHECK-SAME:   (!tfr.tensor, !tfr.tensor, !tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor)\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_tensors(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_tensor', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_no_op() -> () {\\n      CHECK-NEXT:    tfr.return\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT:    tfr.return %x : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT:    tfr.return %x : !tfr.tensor_list\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[index:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[sub:.*]] = tfr.get_element %x[%cst_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: tfr.return %[[sub]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_output_n_op(%x: !tfr.tensor) -> (!tfr.tensor_list) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[list:.*]] = \"tfr.build_list\"(%x, %x) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT: tfr.return %[[list]] : !tfr.tensor_list\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor, %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[Split:.*]] = tfr.call @tf__split(%[[cst_2]], %x, %[[cst_1]]) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor_list)\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant 0 : index\\n      CHECK-NEXT: %[[elt:.*]] = tfr.get_element %[[Split]][%idx] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[elt_1:.*]] = tfr.get_element %[[Split]][%idx_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: tfr.return %[[elt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_outputs_op(%x: !tfr.tensor) -> (!tfr.tensor, !tfr.tensor) {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[Split:.*]] = tfr.call @tf__split(%[[cst_2]], %x, %[[cst_1]]) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor_list)\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant 0 : index\\n      CHECK-NEXT: %[[elt:.*]] = tfr.get_element %[[Split]][%cst_4] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[elt_1:.*]] = tfr.get_element %[[Split]][%cst_5] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: tfr.return %[[elt]], %[[elt_1]] : !tfr.tensor, !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_num_attrs_op(%x1: i64{tfr.name=\"x1\",tfr.default=-10}, %y1: i64{tfr.name=\"y1\",tfr.default=1}, %x2: f32{tfr.name=\"x2\",tfr.default=0.0}, %y2: f32{tfr.name=\"y2\",tfr.default=-3.0}) -> () {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT: %[[zero:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_3:.*]] = arith.subi %zero, %cst_2 : i64\\n      CHECK-NEXT: %[[list:.*]] = \"tfr.build_list\"(%[[cst]], %[[cst_1]], %[[cst_3]], %x1) : (i64, i64, i64, i64) -> !tfr.attr\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant true\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant false\\n      CHECK-NEXT: %[[cst_6:.*]] = \"tfr.constant_tensor\"(%[[list]]) : (!tfr.attr) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_7:.*]] = \"tfr.constant_tensor\"(%y1) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_8:.*]] = \"tfr.constant_tensor\"(%[[cst_4]]) : (i1) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_9:.*]] = \"tfr.constant_tensor\"(%[[cst_5]]) : (i1) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_10:.*]] = arith.constant -1 : i64\\n      CHECK-NEXT: %[[OneHot:.*]] = tfr.call @tf__one_hot(%[[cst_6]], %[[cst_7]], %[[cst_8]], %[[cst_9]], %[[cst_10]])\\n      CHECK-SAME:   (!tfr.tensor, !tfr.tensor, !tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor)\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_tensors(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_tensor', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_no_op() -> () {\\n      CHECK-NEXT:    tfr.return\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT:    tfr.return %x : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT:    tfr.return %x : !tfr.tensor_list\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[index:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[sub:.*]] = tfr.get_element %x[%cst_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: tfr.return %[[sub]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_output_n_op(%x: !tfr.tensor) -> (!tfr.tensor_list) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[list:.*]] = \"tfr.build_list\"(%x, %x) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT: tfr.return %[[list]] : !tfr.tensor_list\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor, %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[Split:.*]] = tfr.call @tf__split(%[[cst_2]], %x, %[[cst_1]]) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor_list)\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant 0 : index\\n      CHECK-NEXT: %[[elt:.*]] = tfr.get_element %[[Split]][%idx] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[elt_1:.*]] = tfr.get_element %[[Split]][%idx_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: tfr.return %[[elt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_outputs_op(%x: !tfr.tensor) -> (!tfr.tensor, !tfr.tensor) {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[Split:.*]] = tfr.call @tf__split(%[[cst_2]], %x, %[[cst_1]]) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor_list)\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant 0 : index\\n      CHECK-NEXT: %[[elt:.*]] = tfr.get_element %[[Split]][%cst_4] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[elt_1:.*]] = tfr.get_element %[[Split]][%cst_5] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: tfr.return %[[elt]], %[[elt_1]] : !tfr.tensor, !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_num_attrs_op(%x1: i64{tfr.name=\"x1\",tfr.default=-10}, %y1: i64{tfr.name=\"y1\",tfr.default=1}, %x2: f32{tfr.name=\"x2\",tfr.default=0.0}, %y2: f32{tfr.name=\"y2\",tfr.default=-3.0}) -> () {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT: %[[zero:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_3:.*]] = arith.subi %zero, %cst_2 : i64\\n      CHECK-NEXT: %[[list:.*]] = \"tfr.build_list\"(%[[cst]], %[[cst_1]], %[[cst_3]], %x1) : (i64, i64, i64, i64) -> !tfr.attr\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant true\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant false\\n      CHECK-NEXT: %[[cst_6:.*]] = \"tfr.constant_tensor\"(%[[list]]) : (!tfr.attr) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_7:.*]] = \"tfr.constant_tensor\"(%y1) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_8:.*]] = \"tfr.constant_tensor\"(%[[cst_4]]) : (i1) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_9:.*]] = \"tfr.constant_tensor\"(%[[cst_5]]) : (i1) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_10:.*]] = arith.constant -1 : i64\\n      CHECK-NEXT: %[[OneHot:.*]] = tfr.call @tf__one_hot(%[[cst_6]], %[[cst_7]], %[[cst_8]], %[[cst_9]], %[[cst_10]])\\n      CHECK-SAME:   (!tfr.tensor, !tfr.tensor, !tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor)\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_tensors(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_tensor', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_no_op() -> () {\\n      CHECK-NEXT:    tfr.return\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT:    tfr.return %x : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT:    tfr.return %x : !tfr.tensor_list\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[index:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[sub:.*]] = tfr.get_element %x[%cst_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: tfr.return %[[sub]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_output_n_op(%x: !tfr.tensor) -> (!tfr.tensor_list) {\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[list:.*]] = \"tfr.build_list\"(%x, %x) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT: tfr.return %[[list]] : !tfr.tensor_list\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor, %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[Split:.*]] = tfr.call @tf__split(%[[cst_2]], %x, %[[cst_1]]) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor_list)\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant 0 : index\\n      CHECK-NEXT: %[[elt:.*]] = tfr.get_element %[[Split]][%idx] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[elt_1:.*]] = tfr.get_element %[[Split]][%idx_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: tfr.return %[[elt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_outputs_op(%x: !tfr.tensor) -> (!tfr.tensor, !tfr.tensor) {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[Split:.*]] = tfr.call @tf__split(%[[cst_2]], %x, %[[cst_1]]) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor_list)\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant 0 : index\\n      CHECK-NEXT: %[[elt:.*]] = tfr.get_element %[[Split]][%cst_4] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant 1 : index\\n      CHECK-NEXT: %[[elt_1:.*]] = tfr.get_element %[[Split]][%cst_5] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT: tfr.return %[[elt]], %[[elt_1]] : !tfr.tensor, !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_num_attrs_op(%x1: i64{tfr.name=\"x1\",tfr.default=-10}, %y1: i64{tfr.name=\"y1\",tfr.default=1}, %x2: f32{tfr.name=\"x2\",tfr.default=0.0}, %y2: f32{tfr.name=\"y2\",tfr.default=-3.0}) -> () {\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT: %[[cst_2:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT: %[[zero:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT: %[[cst_3:.*]] = arith.subi %zero, %cst_2 : i64\\n      CHECK-NEXT: %[[list:.*]] = \"tfr.build_list\"(%[[cst]], %[[cst_1]], %[[cst_3]], %x1) : (i64, i64, i64, i64) -> !tfr.attr\\n      CHECK-NEXT: %[[cst_4:.*]] = arith.constant true\\n      CHECK-NEXT: %[[cst_5:.*]] = arith.constant false\\n      CHECK-NEXT: %[[cst_6:.*]] = \"tfr.constant_tensor\"(%[[list]]) : (!tfr.attr) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_7:.*]] = \"tfr.constant_tensor\"(%y1) : (i64) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_8:.*]] = \"tfr.constant_tensor\"(%[[cst_4]]) : (i1) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_9:.*]] = \"tfr.constant_tensor\"(%[[cst_5]]) : (i1) -> !tfr.tensor\\n      CHECK-NEXT: %[[cst_10:.*]] = arith.constant -1 : i64\\n      CHECK-NEXT: %[[OneHot:.*]] = tfr.call @tf__one_hot(%[[cst_6]], %[[cst_7]], %[[cst_8]], %[[cst_9]], %[[cst_10]])\\n      CHECK-SAME:   (!tfr.tensor, !tfr.tensor, !tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor)\\n      CHECK-NEXT: constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)"
        ]
    },
    {
        "func_name": "test_tfr_control_flow",
        "original": "def test_tfr_control_flow(self):\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_control_flow', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor,\\n      CHECK-SAME:     %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT: %[[if:.*]] = scf.if %pred -> (!tfr.tensor) {\\n      CHECK-NEXT:   arith.constant true\\n      CHECK-NEXT:   scf.yield %x : !tfr.tensor\\n      CHECK-NEXT: } else {\\n      CHECK-NEXT:   arith.constant true\\n      CHECK-NEXT:   scf.yield %y : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %if_stmt : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_three_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor, %z: !tfr.tensor,\\n      CHECK-SAME:     %select: !tfr.attr{tfr.name=\"act\",tfr.default=\"z\"}) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[cst:.*]] = tfr.constant \"x\" -> !tfr.attr\\n      CHECK-NEXT:   %[[eq:.*]] = tfr.equal %select, %[[cst]] -> i1\\n      CHECK-NEXT:   %[[if_stmt:.*]] = scf.if %[[eq]] -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[cst_1:.*]] = arith.constant true\\n      CHECK-NEXT:     scf.yield %x : !tfr.tensor\\n      CHECK-NEXT:   } else {\\n      CHECK-NEXT:     %[[cst_2:.*]] = tfr.constant \"y\" -> !tfr.attr\\n      CHECK-NEXT:     %[[eq_1:.*]] = tfr.equal %select, %[[cst_2]] -> i1\\n      CHECK-NEXT:     %[[if_stmt1:.*]] = scf.if %[[eq_1]] -> (!tfr.tensor) {\\n      CHECK-NEXT:       %[[cst_3:.*]] = arith.constant true\\n      CHECK-NEXT:       scf.yield %y : !tfr.tensor\\n      CHECK-NEXT:     } else {\\n      CHECK-NEXT:       %[[cst_4:.*]] = arith.constant true\\n      CHECK-NEXT:       scf.yield %z : !tfr.tensor\\n      CHECK-NEXT:     }\\n      CHECK-NEXT:     scf.yield %[[if_stmt1]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %[[if_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[n:.*]] = arith.constant 10 : i64\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %x[%[[cst]]] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[begin:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-NEXT:   %[[end:.*]] = arith.index_cast %[[n]] : i64 to index\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[for_stmt:.*]] = scf.for %[[itr_1:.*]] = %[[begin]] to %[[end]] step %[[step]]\\n      CHECK-SAME:       iter_args(%[[it_arg:.*]] = %[[elt]]) -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[elt_1:.*]] = tfr.get_element %x[%itr_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%[[it_arg]], %[[elt_1]]) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-NEXT:   tfr.return %[[for_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%ins: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK: %[[attr:.*]] = tfr.constant i64 -> !tfr.attr\\n      CHECK: %Const = tfr.call @tf__const(%{{.*}}, %[[attr]]) : (!tfr.attr, !tfr.attr) -> (!tfr.tensor)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
        "mutated": [
            "def test_tfr_control_flow(self):\n    if False:\n        i = 10\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_control_flow', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor,\\n      CHECK-SAME:     %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT: %[[if:.*]] = scf.if %pred -> (!tfr.tensor) {\\n      CHECK-NEXT:   arith.constant true\\n      CHECK-NEXT:   scf.yield %x : !tfr.tensor\\n      CHECK-NEXT: } else {\\n      CHECK-NEXT:   arith.constant true\\n      CHECK-NEXT:   scf.yield %y : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %if_stmt : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_three_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor, %z: !tfr.tensor,\\n      CHECK-SAME:     %select: !tfr.attr{tfr.name=\"act\",tfr.default=\"z\"}) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[cst:.*]] = tfr.constant \"x\" -> !tfr.attr\\n      CHECK-NEXT:   %[[eq:.*]] = tfr.equal %select, %[[cst]] -> i1\\n      CHECK-NEXT:   %[[if_stmt:.*]] = scf.if %[[eq]] -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[cst_1:.*]] = arith.constant true\\n      CHECK-NEXT:     scf.yield %x : !tfr.tensor\\n      CHECK-NEXT:   } else {\\n      CHECK-NEXT:     %[[cst_2:.*]] = tfr.constant \"y\" -> !tfr.attr\\n      CHECK-NEXT:     %[[eq_1:.*]] = tfr.equal %select, %[[cst_2]] -> i1\\n      CHECK-NEXT:     %[[if_stmt1:.*]] = scf.if %[[eq_1]] -> (!tfr.tensor) {\\n      CHECK-NEXT:       %[[cst_3:.*]] = arith.constant true\\n      CHECK-NEXT:       scf.yield %y : !tfr.tensor\\n      CHECK-NEXT:     } else {\\n      CHECK-NEXT:       %[[cst_4:.*]] = arith.constant true\\n      CHECK-NEXT:       scf.yield %z : !tfr.tensor\\n      CHECK-NEXT:     }\\n      CHECK-NEXT:     scf.yield %[[if_stmt1]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %[[if_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[n:.*]] = arith.constant 10 : i64\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %x[%[[cst]]] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[begin:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-NEXT:   %[[end:.*]] = arith.index_cast %[[n]] : i64 to index\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[for_stmt:.*]] = scf.for %[[itr_1:.*]] = %[[begin]] to %[[end]] step %[[step]]\\n      CHECK-SAME:       iter_args(%[[it_arg:.*]] = %[[elt]]) -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[elt_1:.*]] = tfr.get_element %x[%itr_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%[[it_arg]], %[[elt_1]]) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-NEXT:   tfr.return %[[for_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%ins: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK: %[[attr:.*]] = tfr.constant i64 -> !tfr.attr\\n      CHECK: %Const = tfr.call @tf__const(%{{.*}}, %[[attr]]) : (!tfr.attr, !tfr.attr) -> (!tfr.tensor)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_control_flow(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_control_flow', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor,\\n      CHECK-SAME:     %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT: %[[if:.*]] = scf.if %pred -> (!tfr.tensor) {\\n      CHECK-NEXT:   arith.constant true\\n      CHECK-NEXT:   scf.yield %x : !tfr.tensor\\n      CHECK-NEXT: } else {\\n      CHECK-NEXT:   arith.constant true\\n      CHECK-NEXT:   scf.yield %y : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %if_stmt : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_three_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor, %z: !tfr.tensor,\\n      CHECK-SAME:     %select: !tfr.attr{tfr.name=\"act\",tfr.default=\"z\"}) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[cst:.*]] = tfr.constant \"x\" -> !tfr.attr\\n      CHECK-NEXT:   %[[eq:.*]] = tfr.equal %select, %[[cst]] -> i1\\n      CHECK-NEXT:   %[[if_stmt:.*]] = scf.if %[[eq]] -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[cst_1:.*]] = arith.constant true\\n      CHECK-NEXT:     scf.yield %x : !tfr.tensor\\n      CHECK-NEXT:   } else {\\n      CHECK-NEXT:     %[[cst_2:.*]] = tfr.constant \"y\" -> !tfr.attr\\n      CHECK-NEXT:     %[[eq_1:.*]] = tfr.equal %select, %[[cst_2]] -> i1\\n      CHECK-NEXT:     %[[if_stmt1:.*]] = scf.if %[[eq_1]] -> (!tfr.tensor) {\\n      CHECK-NEXT:       %[[cst_3:.*]] = arith.constant true\\n      CHECK-NEXT:       scf.yield %y : !tfr.tensor\\n      CHECK-NEXT:     } else {\\n      CHECK-NEXT:       %[[cst_4:.*]] = arith.constant true\\n      CHECK-NEXT:       scf.yield %z : !tfr.tensor\\n      CHECK-NEXT:     }\\n      CHECK-NEXT:     scf.yield %[[if_stmt1]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %[[if_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[n:.*]] = arith.constant 10 : i64\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %x[%[[cst]]] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[begin:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-NEXT:   %[[end:.*]] = arith.index_cast %[[n]] : i64 to index\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[for_stmt:.*]] = scf.for %[[itr_1:.*]] = %[[begin]] to %[[end]] step %[[step]]\\n      CHECK-SAME:       iter_args(%[[it_arg:.*]] = %[[elt]]) -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[elt_1:.*]] = tfr.get_element %x[%itr_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%[[it_arg]], %[[elt_1]]) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-NEXT:   tfr.return %[[for_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%ins: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK: %[[attr:.*]] = tfr.constant i64 -> !tfr.attr\\n      CHECK: %Const = tfr.call @tf__const(%{{.*}}, %[[attr]]) : (!tfr.attr, !tfr.attr) -> (!tfr.tensor)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_control_flow(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_control_flow', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor,\\n      CHECK-SAME:     %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT: %[[if:.*]] = scf.if %pred -> (!tfr.tensor) {\\n      CHECK-NEXT:   arith.constant true\\n      CHECK-NEXT:   scf.yield %x : !tfr.tensor\\n      CHECK-NEXT: } else {\\n      CHECK-NEXT:   arith.constant true\\n      CHECK-NEXT:   scf.yield %y : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %if_stmt : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_three_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor, %z: !tfr.tensor,\\n      CHECK-SAME:     %select: !tfr.attr{tfr.name=\"act\",tfr.default=\"z\"}) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[cst:.*]] = tfr.constant \"x\" -> !tfr.attr\\n      CHECK-NEXT:   %[[eq:.*]] = tfr.equal %select, %[[cst]] -> i1\\n      CHECK-NEXT:   %[[if_stmt:.*]] = scf.if %[[eq]] -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[cst_1:.*]] = arith.constant true\\n      CHECK-NEXT:     scf.yield %x : !tfr.tensor\\n      CHECK-NEXT:   } else {\\n      CHECK-NEXT:     %[[cst_2:.*]] = tfr.constant \"y\" -> !tfr.attr\\n      CHECK-NEXT:     %[[eq_1:.*]] = tfr.equal %select, %[[cst_2]] -> i1\\n      CHECK-NEXT:     %[[if_stmt1:.*]] = scf.if %[[eq_1]] -> (!tfr.tensor) {\\n      CHECK-NEXT:       %[[cst_3:.*]] = arith.constant true\\n      CHECK-NEXT:       scf.yield %y : !tfr.tensor\\n      CHECK-NEXT:     } else {\\n      CHECK-NEXT:       %[[cst_4:.*]] = arith.constant true\\n      CHECK-NEXT:       scf.yield %z : !tfr.tensor\\n      CHECK-NEXT:     }\\n      CHECK-NEXT:     scf.yield %[[if_stmt1]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %[[if_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[n:.*]] = arith.constant 10 : i64\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %x[%[[cst]]] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[begin:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-NEXT:   %[[end:.*]] = arith.index_cast %[[n]] : i64 to index\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[for_stmt:.*]] = scf.for %[[itr_1:.*]] = %[[begin]] to %[[end]] step %[[step]]\\n      CHECK-SAME:       iter_args(%[[it_arg:.*]] = %[[elt]]) -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[elt_1:.*]] = tfr.get_element %x[%itr_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%[[it_arg]], %[[elt_1]]) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-NEXT:   tfr.return %[[for_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%ins: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK: %[[attr:.*]] = tfr.constant i64 -> !tfr.attr\\n      CHECK: %Const = tfr.call @tf__const(%{{.*}}, %[[attr]]) : (!tfr.attr, !tfr.attr) -> (!tfr.tensor)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_control_flow(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_control_flow', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor,\\n      CHECK-SAME:     %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT: %[[if:.*]] = scf.if %pred -> (!tfr.tensor) {\\n      CHECK-NEXT:   arith.constant true\\n      CHECK-NEXT:   scf.yield %x : !tfr.tensor\\n      CHECK-NEXT: } else {\\n      CHECK-NEXT:   arith.constant true\\n      CHECK-NEXT:   scf.yield %y : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %if_stmt : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_three_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor, %z: !tfr.tensor,\\n      CHECK-SAME:     %select: !tfr.attr{tfr.name=\"act\",tfr.default=\"z\"}) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[cst:.*]] = tfr.constant \"x\" -> !tfr.attr\\n      CHECK-NEXT:   %[[eq:.*]] = tfr.equal %select, %[[cst]] -> i1\\n      CHECK-NEXT:   %[[if_stmt:.*]] = scf.if %[[eq]] -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[cst_1:.*]] = arith.constant true\\n      CHECK-NEXT:     scf.yield %x : !tfr.tensor\\n      CHECK-NEXT:   } else {\\n      CHECK-NEXT:     %[[cst_2:.*]] = tfr.constant \"y\" -> !tfr.attr\\n      CHECK-NEXT:     %[[eq_1:.*]] = tfr.equal %select, %[[cst_2]] -> i1\\n      CHECK-NEXT:     %[[if_stmt1:.*]] = scf.if %[[eq_1]] -> (!tfr.tensor) {\\n      CHECK-NEXT:       %[[cst_3:.*]] = arith.constant true\\n      CHECK-NEXT:       scf.yield %y : !tfr.tensor\\n      CHECK-NEXT:     } else {\\n      CHECK-NEXT:       %[[cst_4:.*]] = arith.constant true\\n      CHECK-NEXT:       scf.yield %z : !tfr.tensor\\n      CHECK-NEXT:     }\\n      CHECK-NEXT:     scf.yield %[[if_stmt1]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %[[if_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[n:.*]] = arith.constant 10 : i64\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %x[%[[cst]]] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[begin:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-NEXT:   %[[end:.*]] = arith.index_cast %[[n]] : i64 to index\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[for_stmt:.*]] = scf.for %[[itr_1:.*]] = %[[begin]] to %[[end]] step %[[step]]\\n      CHECK-SAME:       iter_args(%[[it_arg:.*]] = %[[elt]]) -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[elt_1:.*]] = tfr.get_element %x[%itr_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%[[it_arg]], %[[elt_1]]) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-NEXT:   tfr.return %[[for_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%ins: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK: %[[attr:.*]] = tfr.constant i64 -> !tfr.attr\\n      CHECK: %Const = tfr.call @tf__const(%{{.*}}, %[[attr]]) : (!tfr.attr, !tfr.attr) -> (!tfr.tensor)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_control_flow(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_control_flow', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor,\\n      CHECK-SAME:     %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT: %[[if:.*]] = scf.if %pred -> (!tfr.tensor) {\\n      CHECK-NEXT:   arith.constant true\\n      CHECK-NEXT:   scf.yield %x : !tfr.tensor\\n      CHECK-NEXT: } else {\\n      CHECK-NEXT:   arith.constant true\\n      CHECK-NEXT:   scf.yield %y : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %if_stmt : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_three_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor, %z: !tfr.tensor,\\n      CHECK-SAME:     %select: !tfr.attr{tfr.name=\"act\",tfr.default=\"z\"}) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[cst:.*]] = tfr.constant \"x\" -> !tfr.attr\\n      CHECK-NEXT:   %[[eq:.*]] = tfr.equal %select, %[[cst]] -> i1\\n      CHECK-NEXT:   %[[if_stmt:.*]] = scf.if %[[eq]] -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[cst_1:.*]] = arith.constant true\\n      CHECK-NEXT:     scf.yield %x : !tfr.tensor\\n      CHECK-NEXT:   } else {\\n      CHECK-NEXT:     %[[cst_2:.*]] = tfr.constant \"y\" -> !tfr.attr\\n      CHECK-NEXT:     %[[eq_1:.*]] = tfr.equal %select, %[[cst_2]] -> i1\\n      CHECK-NEXT:     %[[if_stmt1:.*]] = scf.if %[[eq_1]] -> (!tfr.tensor) {\\n      CHECK-NEXT:       %[[cst_3:.*]] = arith.constant true\\n      CHECK-NEXT:       scf.yield %y : !tfr.tensor\\n      CHECK-NEXT:     } else {\\n      CHECK-NEXT:       %[[cst_4:.*]] = arith.constant true\\n      CHECK-NEXT:       scf.yield %z : !tfr.tensor\\n      CHECK-NEXT:     }\\n      CHECK-NEXT:     scf.yield %[[if_stmt1]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %[[if_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[n:.*]] = arith.constant 10 : i64\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %x[%[[cst]]] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[begin:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-NEXT:   %[[end:.*]] = arith.index_cast %[[n]] : i64 to index\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[for_stmt:.*]] = scf.for %[[itr_1:.*]] = %[[begin]] to %[[end]] step %[[step]]\\n      CHECK-SAME:       iter_args(%[[it_arg:.*]] = %[[elt]]) -> (!tfr.tensor) {\\n      CHECK-NEXT:     %[[elt_1:.*]] = tfr.get_element %x[%itr_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%[[it_arg]], %[[elt_1]]) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-NEXT:   tfr.return %[[for_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%ins: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK: %[[attr:.*]] = tfr.constant i64 -> !tfr.attr\\n      CHECK: %Const = tfr.call @tf__const(%{{.*}}, %[[attr]]) : (!tfr.attr, !tfr.attr) -> (!tfr.tensor)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)"
        ]
    },
    {
        "func_name": "test_tfr_tf_ops",
        "original": "def test_tfr_tf_ops(self):\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_tf_ops', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_complex_tf_op(%lhs: !tfr.tensor, %rhs: !tfr.tensor) -> (!tfr.tensor_list) {\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[zero:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.subi %[[zero]], %cst : i64\\n      CHECK-NEXT:   %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst_1]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[list:.*]] = \"tfr.build_list\"(%rhs, %[[cst_2]]) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[cst_3:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[cst_4:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[zero_1:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[pack:.*]] = tfr.call @tf__pack(%[[list]], %[[zero_1]]) : (!tfr.tensor_list, i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_5:.*]] = \"tfr.constant_tensor\"(%[[cst_3]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[SplitV:.*]] = tfr.call @tf__split_v(%lhs, %[[pack]], %[[cst_5]], %[[cst_4]])\\n      CHECK-NEXT:   %[[idx:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %SplitV[%idx] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[idx_1:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_1:.*]] = tfr.get_element %SplitV[%idx_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[list_1:.*]] = \"tfr.build_list\"(%rhs, %rhs) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[cst_6:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[cst_7:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[zero_2:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[pack_1:.*]] = tfr.call @tf__pack(%[[list_1]], %[[zero_2]]) : (!tfr.tensor_list, i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_8:.*]] = \"tfr.constant_tensor\"(%[[cst_6]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[SplitV_1:.*]] = tfr.call @tf__split_v(%lhs, %[[pack_1]], %[[cst_8]], %[[cst_7]])\\n      CHECK-NEXT:   %[[idx_2:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt_2:.*]] = tfr.get_element %SplitV_1[%idx_2] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[idx_3:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_3:.*]] = tfr.get_element %SplitV_1[%idx_3] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_9:.*]] = arith.constant true\\n      CHECK-NEXT:   %[[list_2:.*]] = \"tfr.build_list\"(%[[elt]], %[[elt_3]]) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   tfr.return %[[list_2]] : !tfr.tensor_list\\n      CHECK-NEXT:   }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:    %cst = arith.constant true\\n      CHECK-NEXT:    %[[Id:.*]] = tfr.call @tf__identity(%x) : (!tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:    tfr.return %[[Id]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor,\\n      CHECK-SAME:     %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[if_stmt:.*]] = scf.if %pred -> (!tfr.tensor) {\\n      CHECK-NEXT:     %cst = arith.constant true\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%x, %y) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-NEXT:   } else {\\n      CHECK-NEXT:     %cst_1 = arith.constant true\\n      CHECK-NEXT:     %[[cst_2:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:     %[[list:.*]] = \"tfr.build_list\"(%x, %y) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:     %[[Concat:.*]] = tfr.call @tf__concat(%[[cst_2]], %[[list]]) : (i64, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Concat]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %[[if_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%ins: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %cst = arith.constant true\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %ins[%cst_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_2:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_1:.*]] = tfr.get_element %ins[%cst_2] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_3:.*]] = arith.constant false\\n      CHECK-NEXT:   %[[call:.*]] = tfr.call @tf__test_two_inputs_op(\\n      CHECK-SAME:     %[[elt]], %[[elt_1]], %[[cst_3]]) : (!tfr.tensor, !tfr.tensor, i1) -> (!tfr.tensor)\\n      CHECK-NEXT:   tfr.return %[[call]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__add_(!tfr.tensor<T>,!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__concat_(!tfr.tensor<i32_>,!tfr.tensor_list<N,T>) -> (!tfr.tensor<T>) attributes {N,T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__identity_(!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__pack_(!tfr.tensor_list<N,T>,i64{tfr.name=\"axis\",tfr.type=\"int\"}) -> (!tfr.tensor<T>) attributes {N,T,axis,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__split_v_(!tfr.tensor<T>,!tfr.tensor<Tlen>,!tfr.tensor<i32_>,i64{tfr.name=\"num_split\",tfr.type=\"int\"}) -> (!tfr.tensor_list<num_split,T>) attributes {T,Tlen,f32_,i1_,i32_,i64_,num_split}\\n\\n      CHECK-LABEL: tfr.func @tf__test_complex_tf_op_(!tfr.tensor<T>,!tfr.tensor<Tlen>,i64{tfr.name=\"N\",tfr.type=\"int\"}) -> (!tfr.tensor_list<N,T>) attributes {N,T,Tlen,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op_(!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op_(!tfr.tensor_list<N,T>) -> (!tfr.tensor<T>) attributes {N,T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op_(!tfr.tensor<T>,!tfr.tensor<T>,i1{tfr.name=\"pred\",tfr.type=\"bool\"}) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_,pred}\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_outputs_op_(!tfr.tensor<T>) -> (!tfr.tensor<T>,!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
        "mutated": [
            "def test_tfr_tf_ops(self):\n    if False:\n        i = 10\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_tf_ops', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_complex_tf_op(%lhs: !tfr.tensor, %rhs: !tfr.tensor) -> (!tfr.tensor_list) {\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[zero:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.subi %[[zero]], %cst : i64\\n      CHECK-NEXT:   %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst_1]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[list:.*]] = \"tfr.build_list\"(%rhs, %[[cst_2]]) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[cst_3:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[cst_4:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[zero_1:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[pack:.*]] = tfr.call @tf__pack(%[[list]], %[[zero_1]]) : (!tfr.tensor_list, i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_5:.*]] = \"tfr.constant_tensor\"(%[[cst_3]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[SplitV:.*]] = tfr.call @tf__split_v(%lhs, %[[pack]], %[[cst_5]], %[[cst_4]])\\n      CHECK-NEXT:   %[[idx:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %SplitV[%idx] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[idx_1:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_1:.*]] = tfr.get_element %SplitV[%idx_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[list_1:.*]] = \"tfr.build_list\"(%rhs, %rhs) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[cst_6:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[cst_7:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[zero_2:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[pack_1:.*]] = tfr.call @tf__pack(%[[list_1]], %[[zero_2]]) : (!tfr.tensor_list, i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_8:.*]] = \"tfr.constant_tensor\"(%[[cst_6]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[SplitV_1:.*]] = tfr.call @tf__split_v(%lhs, %[[pack_1]], %[[cst_8]], %[[cst_7]])\\n      CHECK-NEXT:   %[[idx_2:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt_2:.*]] = tfr.get_element %SplitV_1[%idx_2] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[idx_3:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_3:.*]] = tfr.get_element %SplitV_1[%idx_3] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_9:.*]] = arith.constant true\\n      CHECK-NEXT:   %[[list_2:.*]] = \"tfr.build_list\"(%[[elt]], %[[elt_3]]) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   tfr.return %[[list_2]] : !tfr.tensor_list\\n      CHECK-NEXT:   }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:    %cst = arith.constant true\\n      CHECK-NEXT:    %[[Id:.*]] = tfr.call @tf__identity(%x) : (!tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:    tfr.return %[[Id]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor,\\n      CHECK-SAME:     %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[if_stmt:.*]] = scf.if %pred -> (!tfr.tensor) {\\n      CHECK-NEXT:     %cst = arith.constant true\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%x, %y) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-NEXT:   } else {\\n      CHECK-NEXT:     %cst_1 = arith.constant true\\n      CHECK-NEXT:     %[[cst_2:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:     %[[list:.*]] = \"tfr.build_list\"(%x, %y) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:     %[[Concat:.*]] = tfr.call @tf__concat(%[[cst_2]], %[[list]]) : (i64, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Concat]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %[[if_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%ins: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %cst = arith.constant true\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %ins[%cst_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_2:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_1:.*]] = tfr.get_element %ins[%cst_2] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_3:.*]] = arith.constant false\\n      CHECK-NEXT:   %[[call:.*]] = tfr.call @tf__test_two_inputs_op(\\n      CHECK-SAME:     %[[elt]], %[[elt_1]], %[[cst_3]]) : (!tfr.tensor, !tfr.tensor, i1) -> (!tfr.tensor)\\n      CHECK-NEXT:   tfr.return %[[call]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__add_(!tfr.tensor<T>,!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__concat_(!tfr.tensor<i32_>,!tfr.tensor_list<N,T>) -> (!tfr.tensor<T>) attributes {N,T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__identity_(!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__pack_(!tfr.tensor_list<N,T>,i64{tfr.name=\"axis\",tfr.type=\"int\"}) -> (!tfr.tensor<T>) attributes {N,T,axis,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__split_v_(!tfr.tensor<T>,!tfr.tensor<Tlen>,!tfr.tensor<i32_>,i64{tfr.name=\"num_split\",tfr.type=\"int\"}) -> (!tfr.tensor_list<num_split,T>) attributes {T,Tlen,f32_,i1_,i32_,i64_,num_split}\\n\\n      CHECK-LABEL: tfr.func @tf__test_complex_tf_op_(!tfr.tensor<T>,!tfr.tensor<Tlen>,i64{tfr.name=\"N\",tfr.type=\"int\"}) -> (!tfr.tensor_list<N,T>) attributes {N,T,Tlen,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op_(!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op_(!tfr.tensor_list<N,T>) -> (!tfr.tensor<T>) attributes {N,T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op_(!tfr.tensor<T>,!tfr.tensor<T>,i1{tfr.name=\"pred\",tfr.type=\"bool\"}) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_,pred}\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_outputs_op_(!tfr.tensor<T>) -> (!tfr.tensor<T>,!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_tf_ops(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_tf_ops', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_complex_tf_op(%lhs: !tfr.tensor, %rhs: !tfr.tensor) -> (!tfr.tensor_list) {\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[zero:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.subi %[[zero]], %cst : i64\\n      CHECK-NEXT:   %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst_1]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[list:.*]] = \"tfr.build_list\"(%rhs, %[[cst_2]]) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[cst_3:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[cst_4:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[zero_1:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[pack:.*]] = tfr.call @tf__pack(%[[list]], %[[zero_1]]) : (!tfr.tensor_list, i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_5:.*]] = \"tfr.constant_tensor\"(%[[cst_3]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[SplitV:.*]] = tfr.call @tf__split_v(%lhs, %[[pack]], %[[cst_5]], %[[cst_4]])\\n      CHECK-NEXT:   %[[idx:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %SplitV[%idx] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[idx_1:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_1:.*]] = tfr.get_element %SplitV[%idx_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[list_1:.*]] = \"tfr.build_list\"(%rhs, %rhs) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[cst_6:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[cst_7:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[zero_2:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[pack_1:.*]] = tfr.call @tf__pack(%[[list_1]], %[[zero_2]]) : (!tfr.tensor_list, i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_8:.*]] = \"tfr.constant_tensor\"(%[[cst_6]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[SplitV_1:.*]] = tfr.call @tf__split_v(%lhs, %[[pack_1]], %[[cst_8]], %[[cst_7]])\\n      CHECK-NEXT:   %[[idx_2:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt_2:.*]] = tfr.get_element %SplitV_1[%idx_2] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[idx_3:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_3:.*]] = tfr.get_element %SplitV_1[%idx_3] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_9:.*]] = arith.constant true\\n      CHECK-NEXT:   %[[list_2:.*]] = \"tfr.build_list\"(%[[elt]], %[[elt_3]]) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   tfr.return %[[list_2]] : !tfr.tensor_list\\n      CHECK-NEXT:   }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:    %cst = arith.constant true\\n      CHECK-NEXT:    %[[Id:.*]] = tfr.call @tf__identity(%x) : (!tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:    tfr.return %[[Id]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor,\\n      CHECK-SAME:     %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[if_stmt:.*]] = scf.if %pred -> (!tfr.tensor) {\\n      CHECK-NEXT:     %cst = arith.constant true\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%x, %y) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-NEXT:   } else {\\n      CHECK-NEXT:     %cst_1 = arith.constant true\\n      CHECK-NEXT:     %[[cst_2:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:     %[[list:.*]] = \"tfr.build_list\"(%x, %y) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:     %[[Concat:.*]] = tfr.call @tf__concat(%[[cst_2]], %[[list]]) : (i64, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Concat]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %[[if_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%ins: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %cst = arith.constant true\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %ins[%cst_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_2:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_1:.*]] = tfr.get_element %ins[%cst_2] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_3:.*]] = arith.constant false\\n      CHECK-NEXT:   %[[call:.*]] = tfr.call @tf__test_two_inputs_op(\\n      CHECK-SAME:     %[[elt]], %[[elt_1]], %[[cst_3]]) : (!tfr.tensor, !tfr.tensor, i1) -> (!tfr.tensor)\\n      CHECK-NEXT:   tfr.return %[[call]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__add_(!tfr.tensor<T>,!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__concat_(!tfr.tensor<i32_>,!tfr.tensor_list<N,T>) -> (!tfr.tensor<T>) attributes {N,T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__identity_(!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__pack_(!tfr.tensor_list<N,T>,i64{tfr.name=\"axis\",tfr.type=\"int\"}) -> (!tfr.tensor<T>) attributes {N,T,axis,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__split_v_(!tfr.tensor<T>,!tfr.tensor<Tlen>,!tfr.tensor<i32_>,i64{tfr.name=\"num_split\",tfr.type=\"int\"}) -> (!tfr.tensor_list<num_split,T>) attributes {T,Tlen,f32_,i1_,i32_,i64_,num_split}\\n\\n      CHECK-LABEL: tfr.func @tf__test_complex_tf_op_(!tfr.tensor<T>,!tfr.tensor<Tlen>,i64{tfr.name=\"N\",tfr.type=\"int\"}) -> (!tfr.tensor_list<N,T>) attributes {N,T,Tlen,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op_(!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op_(!tfr.tensor_list<N,T>) -> (!tfr.tensor<T>) attributes {N,T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op_(!tfr.tensor<T>,!tfr.tensor<T>,i1{tfr.name=\"pred\",tfr.type=\"bool\"}) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_,pred}\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_outputs_op_(!tfr.tensor<T>) -> (!tfr.tensor<T>,!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_tf_ops(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_tf_ops', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_complex_tf_op(%lhs: !tfr.tensor, %rhs: !tfr.tensor) -> (!tfr.tensor_list) {\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[zero:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.subi %[[zero]], %cst : i64\\n      CHECK-NEXT:   %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst_1]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[list:.*]] = \"tfr.build_list\"(%rhs, %[[cst_2]]) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[cst_3:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[cst_4:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[zero_1:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[pack:.*]] = tfr.call @tf__pack(%[[list]], %[[zero_1]]) : (!tfr.tensor_list, i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_5:.*]] = \"tfr.constant_tensor\"(%[[cst_3]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[SplitV:.*]] = tfr.call @tf__split_v(%lhs, %[[pack]], %[[cst_5]], %[[cst_4]])\\n      CHECK-NEXT:   %[[idx:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %SplitV[%idx] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[idx_1:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_1:.*]] = tfr.get_element %SplitV[%idx_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[list_1:.*]] = \"tfr.build_list\"(%rhs, %rhs) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[cst_6:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[cst_7:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[zero_2:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[pack_1:.*]] = tfr.call @tf__pack(%[[list_1]], %[[zero_2]]) : (!tfr.tensor_list, i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_8:.*]] = \"tfr.constant_tensor\"(%[[cst_6]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[SplitV_1:.*]] = tfr.call @tf__split_v(%lhs, %[[pack_1]], %[[cst_8]], %[[cst_7]])\\n      CHECK-NEXT:   %[[idx_2:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt_2:.*]] = tfr.get_element %SplitV_1[%idx_2] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[idx_3:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_3:.*]] = tfr.get_element %SplitV_1[%idx_3] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_9:.*]] = arith.constant true\\n      CHECK-NEXT:   %[[list_2:.*]] = \"tfr.build_list\"(%[[elt]], %[[elt_3]]) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   tfr.return %[[list_2]] : !tfr.tensor_list\\n      CHECK-NEXT:   }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:    %cst = arith.constant true\\n      CHECK-NEXT:    %[[Id:.*]] = tfr.call @tf__identity(%x) : (!tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:    tfr.return %[[Id]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor,\\n      CHECK-SAME:     %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[if_stmt:.*]] = scf.if %pred -> (!tfr.tensor) {\\n      CHECK-NEXT:     %cst = arith.constant true\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%x, %y) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-NEXT:   } else {\\n      CHECK-NEXT:     %cst_1 = arith.constant true\\n      CHECK-NEXT:     %[[cst_2:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:     %[[list:.*]] = \"tfr.build_list\"(%x, %y) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:     %[[Concat:.*]] = tfr.call @tf__concat(%[[cst_2]], %[[list]]) : (i64, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Concat]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %[[if_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%ins: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %cst = arith.constant true\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %ins[%cst_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_2:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_1:.*]] = tfr.get_element %ins[%cst_2] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_3:.*]] = arith.constant false\\n      CHECK-NEXT:   %[[call:.*]] = tfr.call @tf__test_two_inputs_op(\\n      CHECK-SAME:     %[[elt]], %[[elt_1]], %[[cst_3]]) : (!tfr.tensor, !tfr.tensor, i1) -> (!tfr.tensor)\\n      CHECK-NEXT:   tfr.return %[[call]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__add_(!tfr.tensor<T>,!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__concat_(!tfr.tensor<i32_>,!tfr.tensor_list<N,T>) -> (!tfr.tensor<T>) attributes {N,T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__identity_(!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__pack_(!tfr.tensor_list<N,T>,i64{tfr.name=\"axis\",tfr.type=\"int\"}) -> (!tfr.tensor<T>) attributes {N,T,axis,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__split_v_(!tfr.tensor<T>,!tfr.tensor<Tlen>,!tfr.tensor<i32_>,i64{tfr.name=\"num_split\",tfr.type=\"int\"}) -> (!tfr.tensor_list<num_split,T>) attributes {T,Tlen,f32_,i1_,i32_,i64_,num_split}\\n\\n      CHECK-LABEL: tfr.func @tf__test_complex_tf_op_(!tfr.tensor<T>,!tfr.tensor<Tlen>,i64{tfr.name=\"N\",tfr.type=\"int\"}) -> (!tfr.tensor_list<N,T>) attributes {N,T,Tlen,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op_(!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op_(!tfr.tensor_list<N,T>) -> (!tfr.tensor<T>) attributes {N,T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op_(!tfr.tensor<T>,!tfr.tensor<T>,i1{tfr.name=\"pred\",tfr.type=\"bool\"}) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_,pred}\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_outputs_op_(!tfr.tensor<T>) -> (!tfr.tensor<T>,!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_tf_ops(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_tf_ops', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_complex_tf_op(%lhs: !tfr.tensor, %rhs: !tfr.tensor) -> (!tfr.tensor_list) {\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[zero:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.subi %[[zero]], %cst : i64\\n      CHECK-NEXT:   %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst_1]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[list:.*]] = \"tfr.build_list\"(%rhs, %[[cst_2]]) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[cst_3:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[cst_4:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[zero_1:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[pack:.*]] = tfr.call @tf__pack(%[[list]], %[[zero_1]]) : (!tfr.tensor_list, i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_5:.*]] = \"tfr.constant_tensor\"(%[[cst_3]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[SplitV:.*]] = tfr.call @tf__split_v(%lhs, %[[pack]], %[[cst_5]], %[[cst_4]])\\n      CHECK-NEXT:   %[[idx:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %SplitV[%idx] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[idx_1:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_1:.*]] = tfr.get_element %SplitV[%idx_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[list_1:.*]] = \"tfr.build_list\"(%rhs, %rhs) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[cst_6:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[cst_7:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[zero_2:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[pack_1:.*]] = tfr.call @tf__pack(%[[list_1]], %[[zero_2]]) : (!tfr.tensor_list, i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_8:.*]] = \"tfr.constant_tensor\"(%[[cst_6]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[SplitV_1:.*]] = tfr.call @tf__split_v(%lhs, %[[pack_1]], %[[cst_8]], %[[cst_7]])\\n      CHECK-NEXT:   %[[idx_2:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt_2:.*]] = tfr.get_element %SplitV_1[%idx_2] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[idx_3:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_3:.*]] = tfr.get_element %SplitV_1[%idx_3] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_9:.*]] = arith.constant true\\n      CHECK-NEXT:   %[[list_2:.*]] = \"tfr.build_list\"(%[[elt]], %[[elt_3]]) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   tfr.return %[[list_2]] : !tfr.tensor_list\\n      CHECK-NEXT:   }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:    %cst = arith.constant true\\n      CHECK-NEXT:    %[[Id:.*]] = tfr.call @tf__identity(%x) : (!tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:    tfr.return %[[Id]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor,\\n      CHECK-SAME:     %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[if_stmt:.*]] = scf.if %pred -> (!tfr.tensor) {\\n      CHECK-NEXT:     %cst = arith.constant true\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%x, %y) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-NEXT:   } else {\\n      CHECK-NEXT:     %cst_1 = arith.constant true\\n      CHECK-NEXT:     %[[cst_2:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:     %[[list:.*]] = \"tfr.build_list\"(%x, %y) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:     %[[Concat:.*]] = tfr.call @tf__concat(%[[cst_2]], %[[list]]) : (i64, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Concat]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %[[if_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%ins: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %cst = arith.constant true\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %ins[%cst_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_2:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_1:.*]] = tfr.get_element %ins[%cst_2] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_3:.*]] = arith.constant false\\n      CHECK-NEXT:   %[[call:.*]] = tfr.call @tf__test_two_inputs_op(\\n      CHECK-SAME:     %[[elt]], %[[elt_1]], %[[cst_3]]) : (!tfr.tensor, !tfr.tensor, i1) -> (!tfr.tensor)\\n      CHECK-NEXT:   tfr.return %[[call]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__add_(!tfr.tensor<T>,!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__concat_(!tfr.tensor<i32_>,!tfr.tensor_list<N,T>) -> (!tfr.tensor<T>) attributes {N,T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__identity_(!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__pack_(!tfr.tensor_list<N,T>,i64{tfr.name=\"axis\",tfr.type=\"int\"}) -> (!tfr.tensor<T>) attributes {N,T,axis,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__split_v_(!tfr.tensor<T>,!tfr.tensor<Tlen>,!tfr.tensor<i32_>,i64{tfr.name=\"num_split\",tfr.type=\"int\"}) -> (!tfr.tensor_list<num_split,T>) attributes {T,Tlen,f32_,i1_,i32_,i64_,num_split}\\n\\n      CHECK-LABEL: tfr.func @tf__test_complex_tf_op_(!tfr.tensor<T>,!tfr.tensor<Tlen>,i64{tfr.name=\"N\",tfr.type=\"int\"}) -> (!tfr.tensor_list<N,T>) attributes {N,T,Tlen,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op_(!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op_(!tfr.tensor_list<N,T>) -> (!tfr.tensor<T>) attributes {N,T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op_(!tfr.tensor<T>,!tfr.tensor<T>,i1{tfr.name=\"pred\",tfr.type=\"bool\"}) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_,pred}\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_outputs_op_(!tfr.tensor<T>) -> (!tfr.tensor<T>,!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_tf_ops(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_tf_ops', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_complex_tf_op(%lhs: !tfr.tensor, %rhs: !tfr.tensor) -> (!tfr.tensor_list) {\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[zero:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.subi %[[zero]], %cst : i64\\n      CHECK-NEXT:   %[[cst_2:.*]] = \"tfr.constant_tensor\"(%[[cst_1]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[list:.*]] = \"tfr.build_list\"(%rhs, %[[cst_2]]) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[cst_3:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[cst_4:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[zero_1:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[pack:.*]] = tfr.call @tf__pack(%[[list]], %[[zero_1]]) : (!tfr.tensor_list, i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_5:.*]] = \"tfr.constant_tensor\"(%[[cst_3]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[SplitV:.*]] = tfr.call @tf__split_v(%lhs, %[[pack]], %[[cst_5]], %[[cst_4]])\\n      CHECK-NEXT:   %[[idx:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %SplitV[%idx] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[idx_1:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_1:.*]] = tfr.get_element %SplitV[%idx_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[list_1:.*]] = \"tfr.build_list\"(%rhs, %rhs) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[cst_6:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[cst_7:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[zero_2:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:   %[[pack_1:.*]] = tfr.call @tf__pack(%[[list_1]], %[[zero_2]]) : (!tfr.tensor_list, i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_8:.*]] = \"tfr.constant_tensor\"(%[[cst_6]]) : (i64) -> !tfr.tensor\\n      CHECK-NEXT:   %[[SplitV_1:.*]] = tfr.call @tf__split_v(%lhs, %[[pack_1]], %[[cst_8]], %[[cst_7]])\\n      CHECK-NEXT:   %[[idx_2:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt_2:.*]] = tfr.get_element %SplitV_1[%idx_2] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[idx_3:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_3:.*]] = tfr.get_element %SplitV_1[%idx_3] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_9:.*]] = arith.constant true\\n      CHECK-NEXT:   %[[list_2:.*]] = \"tfr.build_list\"(%[[elt]], %[[elt_3]]) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   tfr.return %[[list_2]] : !tfr.tensor_list\\n      CHECK-NEXT:   }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:    %cst = arith.constant true\\n      CHECK-NEXT:    %[[Id:.*]] = tfr.call @tf__identity(%x) : (!tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:    tfr.return %[[Id]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op(%x: !tfr.tensor, %y: !tfr.tensor,\\n      CHECK-SAME:     %pred: i1{tfr.name=\"pred\",tfr.default=false}) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[if_stmt:.*]] = scf.if %pred -> (!tfr.tensor) {\\n      CHECK-NEXT:     %cst = arith.constant true\\n      CHECK-NEXT:     %[[Add:.*]] = tfr.call @tf__add(%x, %y) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Add]] : !tfr.tensor\\n      CHECK-NEXT:   } else {\\n      CHECK-NEXT:     %cst_1 = arith.constant true\\n      CHECK-NEXT:     %[[cst_2:.*]] = arith.constant 0 : i64\\n      CHECK-NEXT:     %[[list:.*]] = \"tfr.build_list\"(%x, %y) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:     %[[Concat:.*]] = tfr.call @tf__concat(%[[cst_2]], %[[list]]) : (i64, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK-NEXT:     scf.yield %[[Concat]] : !tfr.tensor\\n      CHECK-NEXT:   }\\n      CHECK-NEXT:   tfr.return %[[if_stmt]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op(%ins: !tfr.tensor_list) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %cst = arith.constant true\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[elt:.*]] = tfr.get_element %ins[%cst_1] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_2:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   %[[elt_1:.*]] = tfr.get_element %ins[%cst_2] : (!tfr.tensor_list, index) -> !tfr.tensor\\n      CHECK-NEXT:   %[[cst_3:.*]] = arith.constant false\\n      CHECK-NEXT:   %[[call:.*]] = tfr.call @tf__test_two_inputs_op(\\n      CHECK-SAME:     %[[elt]], %[[elt_1]], %[[cst_3]]) : (!tfr.tensor, !tfr.tensor, i1) -> (!tfr.tensor)\\n      CHECK-NEXT:   tfr.return %[[call]] : !tfr.tensor\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__add_(!tfr.tensor<T>,!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__concat_(!tfr.tensor<i32_>,!tfr.tensor_list<N,T>) -> (!tfr.tensor<T>) attributes {N,T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__identity_(!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__pack_(!tfr.tensor_list<N,T>,i64{tfr.name=\"axis\",tfr.type=\"int\"}) -> (!tfr.tensor<T>) attributes {N,T,axis,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__split_v_(!tfr.tensor<T>,!tfr.tensor<Tlen>,!tfr.tensor<i32_>,i64{tfr.name=\"num_split\",tfr.type=\"int\"}) -> (!tfr.tensor_list<num_split,T>) attributes {T,Tlen,f32_,i1_,i32_,i64_,num_split}\\n\\n      CHECK-LABEL: tfr.func @tf__test_complex_tf_op_(!tfr.tensor<T>,!tfr.tensor<Tlen>,i64{tfr.name=\"N\",tfr.type=\"int\"}) -> (!tfr.tensor_list<N,T>) attributes {N,T,Tlen,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op_(!tfr.tensor<T>) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_input_n_op_(!tfr.tensor_list<N,T>) -> (!tfr.tensor<T>) attributes {N,T,f32_,i1_,i32_,i64_}\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_inputs_op_(!tfr.tensor<T>,!tfr.tensor<T>,i1{tfr.name=\"pred\",tfr.type=\"bool\"}) -> (!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_,pred}\\n\\n      CHECK-LABEL: tfr.func @tf__test_two_outputs_op_(!tfr.tensor<T>) -> (!tfr.tensor<T>,!tfr.tensor<T>) attributes {T,f32_,i1_,i32_,i64_}\\n    '\n    self._check_code(mlir_code, mlir_code_exp)"
        ]
    },
    {
        "func_name": "test_tfr_attrs",
        "original": "def test_tfr_attrs(self):\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_attrs', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_num_attrs_op(\\n      CHECK-SAME:     %x: i64{tfr.name=\"x1\",tfr.default=-10},\\n      CHECK-SAME:     %y: i64{tfr.name=\"y1\",tfr.default=1},\\n      CHECK-SAME:     %x1: f32{tfr.name=\"x2\",tfr.default=0.0},\\n      CHECK-SAME:     %y1: f32{tfr.name=\"y2\",tfr.default=-3.0}) -> () {\\n      CHECK-NEXT: %{{.*}} = \"tfr.build_list\"(%x, %y) : (i64, i64) -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"eq\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ult\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ule\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ugt\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"uge\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ne\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.addi %x, %y : i64\\n      CHECK-NEXT: %[[sub_1:.*]] = arith.subi %x, %y : i64\\n      CHECK-NEXT: %[[add_1:.*]] = arith.addi %[[sub_1]], %x : i64\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT: %{{.*}} = arith.addi %[[add_1]], %[[cst]] : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpf \"ugt\", %x1, %y1 : f32\\n      CHECK-NEXT: %{{.*}} = arith.addf %x1, %y1 : f32\\n      CHECK-NEXT: %{{.*}} = \"tfr.build_list\"(%x1, %y1) : (f32, f32) -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = arith.constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_non_num_attrs_op(\\n      CHECK-SAME:     %x: !tfr.attr{tfr.name=\"z\"},\\n      CHECK-SAME:     %y: !tfr.attr{tfr.name=\"x\",tfr.default=\"hello\"},\\n      CHECK-SAME:     %z: !tfr.attr{tfr.name=\"y\",tfr.default=f32}) -> () {\\n      CHECK-NEXT: %{{.*}} = tfr.equal %x, %y -> i1\\n      CHECK-NEXT: %[[cst:.*]] = tfr.constant \"test\" -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = tfr.equal %x, %[[cst]] -> i1\\n      CHECK-NEXT: %{{.*}} = tfr.equal %y, %z -> i1\\n      CHECK-NEXT: %{{.*}} = arith.constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
        "mutated": [
            "def test_tfr_attrs(self):\n    if False:\n        i = 10\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_attrs', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_num_attrs_op(\\n      CHECK-SAME:     %x: i64{tfr.name=\"x1\",tfr.default=-10},\\n      CHECK-SAME:     %y: i64{tfr.name=\"y1\",tfr.default=1},\\n      CHECK-SAME:     %x1: f32{tfr.name=\"x2\",tfr.default=0.0},\\n      CHECK-SAME:     %y1: f32{tfr.name=\"y2\",tfr.default=-3.0}) -> () {\\n      CHECK-NEXT: %{{.*}} = \"tfr.build_list\"(%x, %y) : (i64, i64) -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"eq\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ult\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ule\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ugt\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"uge\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ne\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.addi %x, %y : i64\\n      CHECK-NEXT: %[[sub_1:.*]] = arith.subi %x, %y : i64\\n      CHECK-NEXT: %[[add_1:.*]] = arith.addi %[[sub_1]], %x : i64\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT: %{{.*}} = arith.addi %[[add_1]], %[[cst]] : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpf \"ugt\", %x1, %y1 : f32\\n      CHECK-NEXT: %{{.*}} = arith.addf %x1, %y1 : f32\\n      CHECK-NEXT: %{{.*}} = \"tfr.build_list\"(%x1, %y1) : (f32, f32) -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = arith.constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_non_num_attrs_op(\\n      CHECK-SAME:     %x: !tfr.attr{tfr.name=\"z\"},\\n      CHECK-SAME:     %y: !tfr.attr{tfr.name=\"x\",tfr.default=\"hello\"},\\n      CHECK-SAME:     %z: !tfr.attr{tfr.name=\"y\",tfr.default=f32}) -> () {\\n      CHECK-NEXT: %{{.*}} = tfr.equal %x, %y -> i1\\n      CHECK-NEXT: %[[cst:.*]] = tfr.constant \"test\" -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = tfr.equal %x, %[[cst]] -> i1\\n      CHECK-NEXT: %{{.*}} = tfr.equal %y, %z -> i1\\n      CHECK-NEXT: %{{.*}} = arith.constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_attrs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_attrs', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_num_attrs_op(\\n      CHECK-SAME:     %x: i64{tfr.name=\"x1\",tfr.default=-10},\\n      CHECK-SAME:     %y: i64{tfr.name=\"y1\",tfr.default=1},\\n      CHECK-SAME:     %x1: f32{tfr.name=\"x2\",tfr.default=0.0},\\n      CHECK-SAME:     %y1: f32{tfr.name=\"y2\",tfr.default=-3.0}) -> () {\\n      CHECK-NEXT: %{{.*}} = \"tfr.build_list\"(%x, %y) : (i64, i64) -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"eq\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ult\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ule\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ugt\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"uge\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ne\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.addi %x, %y : i64\\n      CHECK-NEXT: %[[sub_1:.*]] = arith.subi %x, %y : i64\\n      CHECK-NEXT: %[[add_1:.*]] = arith.addi %[[sub_1]], %x : i64\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT: %{{.*}} = arith.addi %[[add_1]], %[[cst]] : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpf \"ugt\", %x1, %y1 : f32\\n      CHECK-NEXT: %{{.*}} = arith.addf %x1, %y1 : f32\\n      CHECK-NEXT: %{{.*}} = \"tfr.build_list\"(%x1, %y1) : (f32, f32) -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = arith.constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_non_num_attrs_op(\\n      CHECK-SAME:     %x: !tfr.attr{tfr.name=\"z\"},\\n      CHECK-SAME:     %y: !tfr.attr{tfr.name=\"x\",tfr.default=\"hello\"},\\n      CHECK-SAME:     %z: !tfr.attr{tfr.name=\"y\",tfr.default=f32}) -> () {\\n      CHECK-NEXT: %{{.*}} = tfr.equal %x, %y -> i1\\n      CHECK-NEXT: %[[cst:.*]] = tfr.constant \"test\" -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = tfr.equal %x, %[[cst]] -> i1\\n      CHECK-NEXT: %{{.*}} = tfr.equal %y, %z -> i1\\n      CHECK-NEXT: %{{.*}} = arith.constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_attrs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_attrs', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_num_attrs_op(\\n      CHECK-SAME:     %x: i64{tfr.name=\"x1\",tfr.default=-10},\\n      CHECK-SAME:     %y: i64{tfr.name=\"y1\",tfr.default=1},\\n      CHECK-SAME:     %x1: f32{tfr.name=\"x2\",tfr.default=0.0},\\n      CHECK-SAME:     %y1: f32{tfr.name=\"y2\",tfr.default=-3.0}) -> () {\\n      CHECK-NEXT: %{{.*}} = \"tfr.build_list\"(%x, %y) : (i64, i64) -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"eq\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ult\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ule\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ugt\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"uge\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ne\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.addi %x, %y : i64\\n      CHECK-NEXT: %[[sub_1:.*]] = arith.subi %x, %y : i64\\n      CHECK-NEXT: %[[add_1:.*]] = arith.addi %[[sub_1]], %x : i64\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT: %{{.*}} = arith.addi %[[add_1]], %[[cst]] : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpf \"ugt\", %x1, %y1 : f32\\n      CHECK-NEXT: %{{.*}} = arith.addf %x1, %y1 : f32\\n      CHECK-NEXT: %{{.*}} = \"tfr.build_list\"(%x1, %y1) : (f32, f32) -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = arith.constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_non_num_attrs_op(\\n      CHECK-SAME:     %x: !tfr.attr{tfr.name=\"z\"},\\n      CHECK-SAME:     %y: !tfr.attr{tfr.name=\"x\",tfr.default=\"hello\"},\\n      CHECK-SAME:     %z: !tfr.attr{tfr.name=\"y\",tfr.default=f32}) -> () {\\n      CHECK-NEXT: %{{.*}} = tfr.equal %x, %y -> i1\\n      CHECK-NEXT: %[[cst:.*]] = tfr.constant \"test\" -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = tfr.equal %x, %[[cst]] -> i1\\n      CHECK-NEXT: %{{.*}} = tfr.equal %y, %z -> i1\\n      CHECK-NEXT: %{{.*}} = arith.constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_attrs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_attrs', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_num_attrs_op(\\n      CHECK-SAME:     %x: i64{tfr.name=\"x1\",tfr.default=-10},\\n      CHECK-SAME:     %y: i64{tfr.name=\"y1\",tfr.default=1},\\n      CHECK-SAME:     %x1: f32{tfr.name=\"x2\",tfr.default=0.0},\\n      CHECK-SAME:     %y1: f32{tfr.name=\"y2\",tfr.default=-3.0}) -> () {\\n      CHECK-NEXT: %{{.*}} = \"tfr.build_list\"(%x, %y) : (i64, i64) -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"eq\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ult\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ule\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ugt\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"uge\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ne\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.addi %x, %y : i64\\n      CHECK-NEXT: %[[sub_1:.*]] = arith.subi %x, %y : i64\\n      CHECK-NEXT: %[[add_1:.*]] = arith.addi %[[sub_1]], %x : i64\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT: %{{.*}} = arith.addi %[[add_1]], %[[cst]] : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpf \"ugt\", %x1, %y1 : f32\\n      CHECK-NEXT: %{{.*}} = arith.addf %x1, %y1 : f32\\n      CHECK-NEXT: %{{.*}} = \"tfr.build_list\"(%x1, %y1) : (f32, f32) -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = arith.constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_non_num_attrs_op(\\n      CHECK-SAME:     %x: !tfr.attr{tfr.name=\"z\"},\\n      CHECK-SAME:     %y: !tfr.attr{tfr.name=\"x\",tfr.default=\"hello\"},\\n      CHECK-SAME:     %z: !tfr.attr{tfr.name=\"y\",tfr.default=f32}) -> () {\\n      CHECK-NEXT: %{{.*}} = tfr.equal %x, %y -> i1\\n      CHECK-NEXT: %[[cst:.*]] = tfr.constant \"test\" -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = tfr.equal %x, %[[cst]] -> i1\\n      CHECK-NEXT: %{{.*}} = tfr.equal %y, %z -> i1\\n      CHECK-NEXT: %{{.*}} = arith.constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tfr_attrs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_attrs', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_num_attrs_op(\\n      CHECK-SAME:     %x: i64{tfr.name=\"x1\",tfr.default=-10},\\n      CHECK-SAME:     %y: i64{tfr.name=\"y1\",tfr.default=1},\\n      CHECK-SAME:     %x1: f32{tfr.name=\"x2\",tfr.default=0.0},\\n      CHECK-SAME:     %y1: f32{tfr.name=\"y2\",tfr.default=-3.0}) -> () {\\n      CHECK-NEXT: %{{.*}} = \"tfr.build_list\"(%x, %y) : (i64, i64) -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"eq\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ult\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ule\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ugt\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"uge\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpi \"ne\", %x, %y : i64\\n      CHECK-NEXT: %{{.*}} = arith.addi %x, %y : i64\\n      CHECK-NEXT: %[[sub_1:.*]] = arith.subi %x, %y : i64\\n      CHECK-NEXT: %[[add_1:.*]] = arith.addi %[[sub_1]], %x : i64\\n      CHECK-NEXT: %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT: %{{.*}} = arith.addi %[[add_1]], %[[cst]] : i64\\n      CHECK-NEXT: %{{.*}} = arith.cmpf \"ugt\", %x1, %y1 : f32\\n      CHECK-NEXT: %{{.*}} = arith.addf %x1, %y1 : f32\\n      CHECK-NEXT: %{{.*}} = \"tfr.build_list\"(%x1, %y1) : (f32, f32) -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = arith.constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n\\n      CHECK-LABEL: tfr.func @tf__test_non_num_attrs_op(\\n      CHECK-SAME:     %x: !tfr.attr{tfr.name=\"z\"},\\n      CHECK-SAME:     %y: !tfr.attr{tfr.name=\"x\",tfr.default=\"hello\"},\\n      CHECK-SAME:     %z: !tfr.attr{tfr.name=\"y\",tfr.default=f32}) -> () {\\n      CHECK-NEXT: %{{.*}} = tfr.equal %x, %y -> i1\\n      CHECK-NEXT: %[[cst:.*]] = tfr.constant \"test\" -> !tfr.attr\\n      CHECK-NEXT: %{{.*}} = tfr.equal %x, %[[cst]] -> i1\\n      CHECK-NEXT: %{{.*}} = tfr.equal %y, %z -> i1\\n      CHECK-NEXT: %{{.*}} = arith.constant true\\n      CHECK-NEXT: tfr.return\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)"
        ]
    },
    {
        "func_name": "test_tf_tensor_shape",
        "original": "def test_tf_tensor_shape(self):\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_shapes', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[shape:.*]] = tfr.get_shape %x -> !shape.shape\\n\\n      CHECK-NEXT:   %[[shape_1:.*]] = tfr.get_shape %x -> !shape.shape\\n      CHECK-NEXT:   %[[len:.*]] = shape.rank %[[shape_1]] : !shape.shape -> !shape.size\\n      CHECK-NEXT:   %[[index:.*]] = shape.size_to_index %[[len]] : !shape.size\\n      CHECK-NEXT:   %[[begin:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   scf.for %[[itr_1:.*]] = %[[begin]] to %[[index]] step %[[step]]  {\\n      CHECK-NEXT:     %[[size:.*]] = shape.get_extent %[[shape_1]], %[[itr_1]]: !shape.shape, index -> !shape.size\\n      CHECK-NEXT:     %[[elt:.*]] = shape.size_to_index %[[size]] : !shape.size\\n      CHECK-NEXT:     scf.yield\\n      CHECK-NEXT:   }\\n\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[len_1:.*]] = shape.rank %shape_1 : !shape.shape -> !shape.size\\n      CHECK-NEXT:   %[[len_size_1:.*]] = shape.size_to_index %[[len_1]] : !shape.size\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[begin_1:.*]] = arith.index_cast %[[cst]] : i64 to index\\n      CHECK-NEXT:   %[[step_1:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-NEXT:   scf.for %[[itr_3:.*]] = %[[begin_1]] to %[[len_size_1]] step %[[step_1]]\\n\\n      CHECK:        %[[cst:.*]] = tfr.constant i32 -> !tfr.attr\\n      CHECK-NEXT:   %[[Shape:.*]] = tfr.call @tf__shape(%x, %[[cst]]) : (!tfr.tensor, !tfr.attr) -> (!tfr.tensor)\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-NEXT:   tfr.return %x : !tfr.tensor\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
        "mutated": [
            "def test_tf_tensor_shape(self):\n    if False:\n        i = 10\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_shapes', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[shape:.*]] = tfr.get_shape %x -> !shape.shape\\n\\n      CHECK-NEXT:   %[[shape_1:.*]] = tfr.get_shape %x -> !shape.shape\\n      CHECK-NEXT:   %[[len:.*]] = shape.rank %[[shape_1]] : !shape.shape -> !shape.size\\n      CHECK-NEXT:   %[[index:.*]] = shape.size_to_index %[[len]] : !shape.size\\n      CHECK-NEXT:   %[[begin:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   scf.for %[[itr_1:.*]] = %[[begin]] to %[[index]] step %[[step]]  {\\n      CHECK-NEXT:     %[[size:.*]] = shape.get_extent %[[shape_1]], %[[itr_1]]: !shape.shape, index -> !shape.size\\n      CHECK-NEXT:     %[[elt:.*]] = shape.size_to_index %[[size]] : !shape.size\\n      CHECK-NEXT:     scf.yield\\n      CHECK-NEXT:   }\\n\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[len_1:.*]] = shape.rank %shape_1 : !shape.shape -> !shape.size\\n      CHECK-NEXT:   %[[len_size_1:.*]] = shape.size_to_index %[[len_1]] : !shape.size\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[begin_1:.*]] = arith.index_cast %[[cst]] : i64 to index\\n      CHECK-NEXT:   %[[step_1:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-NEXT:   scf.for %[[itr_3:.*]] = %[[begin_1]] to %[[len_size_1]] step %[[step_1]]\\n\\n      CHECK:        %[[cst:.*]] = tfr.constant i32 -> !tfr.attr\\n      CHECK-NEXT:   %[[Shape:.*]] = tfr.call @tf__shape(%x, %[[cst]]) : (!tfr.tensor, !tfr.attr) -> (!tfr.tensor)\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-NEXT:   tfr.return %x : !tfr.tensor\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tf_tensor_shape(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_shapes', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[shape:.*]] = tfr.get_shape %x -> !shape.shape\\n\\n      CHECK-NEXT:   %[[shape_1:.*]] = tfr.get_shape %x -> !shape.shape\\n      CHECK-NEXT:   %[[len:.*]] = shape.rank %[[shape_1]] : !shape.shape -> !shape.size\\n      CHECK-NEXT:   %[[index:.*]] = shape.size_to_index %[[len]] : !shape.size\\n      CHECK-NEXT:   %[[begin:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   scf.for %[[itr_1:.*]] = %[[begin]] to %[[index]] step %[[step]]  {\\n      CHECK-NEXT:     %[[size:.*]] = shape.get_extent %[[shape_1]], %[[itr_1]]: !shape.shape, index -> !shape.size\\n      CHECK-NEXT:     %[[elt:.*]] = shape.size_to_index %[[size]] : !shape.size\\n      CHECK-NEXT:     scf.yield\\n      CHECK-NEXT:   }\\n\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[len_1:.*]] = shape.rank %shape_1 : !shape.shape -> !shape.size\\n      CHECK-NEXT:   %[[len_size_1:.*]] = shape.size_to_index %[[len_1]] : !shape.size\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[begin_1:.*]] = arith.index_cast %[[cst]] : i64 to index\\n      CHECK-NEXT:   %[[step_1:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-NEXT:   scf.for %[[itr_3:.*]] = %[[begin_1]] to %[[len_size_1]] step %[[step_1]]\\n\\n      CHECK:        %[[cst:.*]] = tfr.constant i32 -> !tfr.attr\\n      CHECK-NEXT:   %[[Shape:.*]] = tfr.call @tf__shape(%x, %[[cst]]) : (!tfr.tensor, !tfr.attr) -> (!tfr.tensor)\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-NEXT:   tfr.return %x : !tfr.tensor\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tf_tensor_shape(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_shapes', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[shape:.*]] = tfr.get_shape %x -> !shape.shape\\n\\n      CHECK-NEXT:   %[[shape_1:.*]] = tfr.get_shape %x -> !shape.shape\\n      CHECK-NEXT:   %[[len:.*]] = shape.rank %[[shape_1]] : !shape.shape -> !shape.size\\n      CHECK-NEXT:   %[[index:.*]] = shape.size_to_index %[[len]] : !shape.size\\n      CHECK-NEXT:   %[[begin:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   scf.for %[[itr_1:.*]] = %[[begin]] to %[[index]] step %[[step]]  {\\n      CHECK-NEXT:     %[[size:.*]] = shape.get_extent %[[shape_1]], %[[itr_1]]: !shape.shape, index -> !shape.size\\n      CHECK-NEXT:     %[[elt:.*]] = shape.size_to_index %[[size]] : !shape.size\\n      CHECK-NEXT:     scf.yield\\n      CHECK-NEXT:   }\\n\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[len_1:.*]] = shape.rank %shape_1 : !shape.shape -> !shape.size\\n      CHECK-NEXT:   %[[len_size_1:.*]] = shape.size_to_index %[[len_1]] : !shape.size\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[begin_1:.*]] = arith.index_cast %[[cst]] : i64 to index\\n      CHECK-NEXT:   %[[step_1:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-NEXT:   scf.for %[[itr_3:.*]] = %[[begin_1]] to %[[len_size_1]] step %[[step_1]]\\n\\n      CHECK:        %[[cst:.*]] = tfr.constant i32 -> !tfr.attr\\n      CHECK-NEXT:   %[[Shape:.*]] = tfr.call @tf__shape(%x, %[[cst]]) : (!tfr.tensor, !tfr.attr) -> (!tfr.tensor)\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-NEXT:   tfr.return %x : !tfr.tensor\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tf_tensor_shape(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_shapes', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[shape:.*]] = tfr.get_shape %x -> !shape.shape\\n\\n      CHECK-NEXT:   %[[shape_1:.*]] = tfr.get_shape %x -> !shape.shape\\n      CHECK-NEXT:   %[[len:.*]] = shape.rank %[[shape_1]] : !shape.shape -> !shape.size\\n      CHECK-NEXT:   %[[index:.*]] = shape.size_to_index %[[len]] : !shape.size\\n      CHECK-NEXT:   %[[begin:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   scf.for %[[itr_1:.*]] = %[[begin]] to %[[index]] step %[[step]]  {\\n      CHECK-NEXT:     %[[size:.*]] = shape.get_extent %[[shape_1]], %[[itr_1]]: !shape.shape, index -> !shape.size\\n      CHECK-NEXT:     %[[elt:.*]] = shape.size_to_index %[[size]] : !shape.size\\n      CHECK-NEXT:     scf.yield\\n      CHECK-NEXT:   }\\n\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[len_1:.*]] = shape.rank %shape_1 : !shape.shape -> !shape.size\\n      CHECK-NEXT:   %[[len_size_1:.*]] = shape.size_to_index %[[len_1]] : !shape.size\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[begin_1:.*]] = arith.index_cast %[[cst]] : i64 to index\\n      CHECK-NEXT:   %[[step_1:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-NEXT:   scf.for %[[itr_3:.*]] = %[[begin_1]] to %[[len_size_1]] step %[[step_1]]\\n\\n      CHECK:        %[[cst:.*]] = tfr.constant i32 -> !tfr.attr\\n      CHECK-NEXT:   %[[Shape:.*]] = tfr.call @tf__shape(%x, %[[cst]]) : (!tfr.tensor, !tfr.attr) -> (!tfr.tensor)\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-NEXT:   tfr.return %x : !tfr.tensor\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_tf_tensor_shape(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_shapes', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[shape:.*]] = tfr.get_shape %x -> !shape.shape\\n\\n      CHECK-NEXT:   %[[shape_1:.*]] = tfr.get_shape %x -> !shape.shape\\n      CHECK-NEXT:   %[[len:.*]] = shape.rank %[[shape_1]] : !shape.shape -> !shape.size\\n      CHECK-NEXT:   %[[index:.*]] = shape.size_to_index %[[len]] : !shape.size\\n      CHECK-NEXT:   %[[begin:.*]] = arith.constant 0 : index\\n      CHECK-NEXT:   %[[step:.*]] = arith.constant 1 : index\\n      CHECK-NEXT:   scf.for %[[itr_1:.*]] = %[[begin]] to %[[index]] step %[[step]]  {\\n      CHECK-NEXT:     %[[size:.*]] = shape.get_extent %[[shape_1]], %[[itr_1]]: !shape.shape, index -> !shape.size\\n      CHECK-NEXT:     %[[elt:.*]] = shape.size_to_index %[[size]] : !shape.size\\n      CHECK-NEXT:     scf.yield\\n      CHECK-NEXT:   }\\n\\n      CHECK-NEXT:   %[[cst:.*]] = arith.constant 1 : i64\\n      CHECK-NEXT:   %[[len_1:.*]] = shape.rank %shape_1 : !shape.shape -> !shape.size\\n      CHECK-NEXT:   %[[len_size_1:.*]] = shape.size_to_index %[[len_1]] : !shape.size\\n      CHECK-NEXT:   %[[cst_1:.*]] = arith.constant 2 : i64\\n      CHECK-NEXT:   %[[begin_1:.*]] = arith.index_cast %[[cst]] : i64 to index\\n      CHECK-NEXT:   %[[step_1:.*]] = arith.index_cast %[[cst_1]] : i64 to index\\n      CHECK-NEXT:   scf.for %[[itr_3:.*]] = %[[begin_1]] to %[[len_size_1]] step %[[step_1]]\\n\\n      CHECK:        %[[cst:.*]] = tfr.constant i32 -> !tfr.attr\\n      CHECK-NEXT:   %[[Shape:.*]] = tfr.call @tf__shape(%x, %[[cst]]) : (!tfr.tensor, !tfr.attr) -> (!tfr.tensor)\\n      CHECK-NEXT:   %{{.*}} = arith.constant true\\n      CHECK-NEXT:   tfr.return %x : !tfr.tensor\\n      CHECK-NEXT: }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)"
        ]
    },
    {
        "func_name": "test_temp_function",
        "original": "def test_temp_function(self):\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_temp', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list)\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[list:.*]] = \"tfr.build_list\"(%x) : (!tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[call:.*]] = tfr.call @tf__test_identity_n_op(%[[list]]) : (!tfr.tensor_list)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
        "mutated": [
            "def test_temp_function(self):\n    if False:\n        i = 10\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_temp', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list)\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[list:.*]] = \"tfr.build_list\"(%x) : (!tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[call:.*]] = tfr.call @tf__test_identity_n_op(%[[list]]) : (!tfr.tensor_list)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_temp_function(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_temp', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list)\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[list:.*]] = \"tfr.build_list\"(%x) : (!tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[call:.*]] = tfr.call @tf__test_identity_n_op(%[[list]]) : (!tfr.tensor_list)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_temp_function(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_temp', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list)\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[list:.*]] = \"tfr.build_list\"(%x) : (!tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[call:.*]] = tfr.call @tf__test_identity_n_op(%[[list]]) : (!tfr.tensor_list)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_temp_function(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_temp', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list)\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[list:.*]] = \"tfr.build_list\"(%x) : (!tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[call:.*]] = tfr.call @tf__test_identity_n_op(%[[list]]) : (!tfr.tensor_list)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_temp_function(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_temp', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list)\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[list:.*]] = \"tfr.build_list\"(%x) : (!tfr.tensor) -> !tfr.tensor_list\\n      CHECK-NEXT:   %[[call:.*]] = tfr.call @tf__test_identity_n_op(%[[list]]) : (!tfr.tensor_list)\\n    '\n    self._check_code(mlir_code, mlir_code_exp)"
        ]
    },
    {
        "func_name": "test_quant_builtins",
        "original": "def test_quant_builtins(self):\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_quant', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[raw_data:.*]] = tfr.quant_raw_data(%x) : (!tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:   %[[qparam:.*]]:2 = tfr.quant_qparam(%x) : (!tfr.tensor) -> (!tfr.tensor, !tfr.tensor)\\n      CHECK:        %[[list:.*]] = \"tfr.build_list\"(%[[qparam]]#0, %[[qparam]]#0) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK:        %[[factor:.*]] = tfr.quant_scale_factor(%{{.*}}, %[[list]]) : (f32, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK:        %[[list1:.*]] = \"tfr.build_list\"(%[[factor]]) : (!tfr.tensor) -> !tfr.tensor_list\\n      CHECK:        %[[factor1:.*]] = tfr.quant_scale_factor(%{{.*}}, %[[list1]]) : (f32, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK-NEXT:   %[[Sub:.*]] = tfr.call @tf__sub(%[[raw_data]], %[[qparam]]#1) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK:        %[[act_range:.*]]:2 = tfr.quant_act_range(%{{.*}}, %{{.*}}, %{{.*}}) : (!tfr.attr, f32, i64) -> (!tfr.tensor, !tfr.tensor)\\n      CHECK:        %[[rescale:.*]] = tfr.quant_rescale(%[[Sub]], %[[factor1]], %{{.*}}) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor)\\n      CHECK:        %[[attr:.*]] = tfr.constant i16 -> !tfr.attr\\n      CHECK:        %[[Cast:.*]] = tfr.call @tf__cast(%[[rescale]], %[[attr]], %{{.*}}) : (!tfr.tensor, !tfr.attr, i1) -> (!tfr.tensor)\\n      CHECK:        %[[attr_1:.*]] = tfr.constant i8 -> !tfr.attr\\n      CHECK:        tfr.call @tf__cast(%[[Cast]], %[[attr_1]], %{{.*}}) : (!tfr.tensor, !tfr.attr, i1) -> (!tfr.tensor)\\n      CHECK:       }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list) {\\n      CHECK-NEXT:   %[[raw_data:.*]] = tfr.quant_raw_data(%x) : (!tfr.tensor_list) -> (!tfr.tensor_list)\\n      CHECK:        tfr.return %[[raw_data:.*]] : !tfr.tensor_list\\n      CHECK:       }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
        "mutated": [
            "def test_quant_builtins(self):\n    if False:\n        i = 10\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_quant', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[raw_data:.*]] = tfr.quant_raw_data(%x) : (!tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:   %[[qparam:.*]]:2 = tfr.quant_qparam(%x) : (!tfr.tensor) -> (!tfr.tensor, !tfr.tensor)\\n      CHECK:        %[[list:.*]] = \"tfr.build_list\"(%[[qparam]]#0, %[[qparam]]#0) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK:        %[[factor:.*]] = tfr.quant_scale_factor(%{{.*}}, %[[list]]) : (f32, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK:        %[[list1:.*]] = \"tfr.build_list\"(%[[factor]]) : (!tfr.tensor) -> !tfr.tensor_list\\n      CHECK:        %[[factor1:.*]] = tfr.quant_scale_factor(%{{.*}}, %[[list1]]) : (f32, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK-NEXT:   %[[Sub:.*]] = tfr.call @tf__sub(%[[raw_data]], %[[qparam]]#1) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK:        %[[act_range:.*]]:2 = tfr.quant_act_range(%{{.*}}, %{{.*}}, %{{.*}}) : (!tfr.attr, f32, i64) -> (!tfr.tensor, !tfr.tensor)\\n      CHECK:        %[[rescale:.*]] = tfr.quant_rescale(%[[Sub]], %[[factor1]], %{{.*}}) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor)\\n      CHECK:        %[[attr:.*]] = tfr.constant i16 -> !tfr.attr\\n      CHECK:        %[[Cast:.*]] = tfr.call @tf__cast(%[[rescale]], %[[attr]], %{{.*}}) : (!tfr.tensor, !tfr.attr, i1) -> (!tfr.tensor)\\n      CHECK:        %[[attr_1:.*]] = tfr.constant i8 -> !tfr.attr\\n      CHECK:        tfr.call @tf__cast(%[[Cast]], %[[attr_1]], %{{.*}}) : (!tfr.tensor, !tfr.attr, i1) -> (!tfr.tensor)\\n      CHECK:       }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list) {\\n      CHECK-NEXT:   %[[raw_data:.*]] = tfr.quant_raw_data(%x) : (!tfr.tensor_list) -> (!tfr.tensor_list)\\n      CHECK:        tfr.return %[[raw_data:.*]] : !tfr.tensor_list\\n      CHECK:       }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_quant_builtins(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_quant', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[raw_data:.*]] = tfr.quant_raw_data(%x) : (!tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:   %[[qparam:.*]]:2 = tfr.quant_qparam(%x) : (!tfr.tensor) -> (!tfr.tensor, !tfr.tensor)\\n      CHECK:        %[[list:.*]] = \"tfr.build_list\"(%[[qparam]]#0, %[[qparam]]#0) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK:        %[[factor:.*]] = tfr.quant_scale_factor(%{{.*}}, %[[list]]) : (f32, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK:        %[[list1:.*]] = \"tfr.build_list\"(%[[factor]]) : (!tfr.tensor) -> !tfr.tensor_list\\n      CHECK:        %[[factor1:.*]] = tfr.quant_scale_factor(%{{.*}}, %[[list1]]) : (f32, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK-NEXT:   %[[Sub:.*]] = tfr.call @tf__sub(%[[raw_data]], %[[qparam]]#1) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK:        %[[act_range:.*]]:2 = tfr.quant_act_range(%{{.*}}, %{{.*}}, %{{.*}}) : (!tfr.attr, f32, i64) -> (!tfr.tensor, !tfr.tensor)\\n      CHECK:        %[[rescale:.*]] = tfr.quant_rescale(%[[Sub]], %[[factor1]], %{{.*}}) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor)\\n      CHECK:        %[[attr:.*]] = tfr.constant i16 -> !tfr.attr\\n      CHECK:        %[[Cast:.*]] = tfr.call @tf__cast(%[[rescale]], %[[attr]], %{{.*}}) : (!tfr.tensor, !tfr.attr, i1) -> (!tfr.tensor)\\n      CHECK:        %[[attr_1:.*]] = tfr.constant i8 -> !tfr.attr\\n      CHECK:        tfr.call @tf__cast(%[[Cast]], %[[attr_1]], %{{.*}}) : (!tfr.tensor, !tfr.attr, i1) -> (!tfr.tensor)\\n      CHECK:       }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list) {\\n      CHECK-NEXT:   %[[raw_data:.*]] = tfr.quant_raw_data(%x) : (!tfr.tensor_list) -> (!tfr.tensor_list)\\n      CHECK:        tfr.return %[[raw_data:.*]] : !tfr.tensor_list\\n      CHECK:       }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_quant_builtins(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_quant', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[raw_data:.*]] = tfr.quant_raw_data(%x) : (!tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:   %[[qparam:.*]]:2 = tfr.quant_qparam(%x) : (!tfr.tensor) -> (!tfr.tensor, !tfr.tensor)\\n      CHECK:        %[[list:.*]] = \"tfr.build_list\"(%[[qparam]]#0, %[[qparam]]#0) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK:        %[[factor:.*]] = tfr.quant_scale_factor(%{{.*}}, %[[list]]) : (f32, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK:        %[[list1:.*]] = \"tfr.build_list\"(%[[factor]]) : (!tfr.tensor) -> !tfr.tensor_list\\n      CHECK:        %[[factor1:.*]] = tfr.quant_scale_factor(%{{.*}}, %[[list1]]) : (f32, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK-NEXT:   %[[Sub:.*]] = tfr.call @tf__sub(%[[raw_data]], %[[qparam]]#1) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK:        %[[act_range:.*]]:2 = tfr.quant_act_range(%{{.*}}, %{{.*}}, %{{.*}}) : (!tfr.attr, f32, i64) -> (!tfr.tensor, !tfr.tensor)\\n      CHECK:        %[[rescale:.*]] = tfr.quant_rescale(%[[Sub]], %[[factor1]], %{{.*}}) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor)\\n      CHECK:        %[[attr:.*]] = tfr.constant i16 -> !tfr.attr\\n      CHECK:        %[[Cast:.*]] = tfr.call @tf__cast(%[[rescale]], %[[attr]], %{{.*}}) : (!tfr.tensor, !tfr.attr, i1) -> (!tfr.tensor)\\n      CHECK:        %[[attr_1:.*]] = tfr.constant i8 -> !tfr.attr\\n      CHECK:        tfr.call @tf__cast(%[[Cast]], %[[attr_1]], %{{.*}}) : (!tfr.tensor, !tfr.attr, i1) -> (!tfr.tensor)\\n      CHECK:       }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list) {\\n      CHECK-NEXT:   %[[raw_data:.*]] = tfr.quant_raw_data(%x) : (!tfr.tensor_list) -> (!tfr.tensor_list)\\n      CHECK:        tfr.return %[[raw_data:.*]] : !tfr.tensor_list\\n      CHECK:       }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_quant_builtins(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_quant', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[raw_data:.*]] = tfr.quant_raw_data(%x) : (!tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:   %[[qparam:.*]]:2 = tfr.quant_qparam(%x) : (!tfr.tensor) -> (!tfr.tensor, !tfr.tensor)\\n      CHECK:        %[[list:.*]] = \"tfr.build_list\"(%[[qparam]]#0, %[[qparam]]#0) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK:        %[[factor:.*]] = tfr.quant_scale_factor(%{{.*}}, %[[list]]) : (f32, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK:        %[[list1:.*]] = \"tfr.build_list\"(%[[factor]]) : (!tfr.tensor) -> !tfr.tensor_list\\n      CHECK:        %[[factor1:.*]] = tfr.quant_scale_factor(%{{.*}}, %[[list1]]) : (f32, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK-NEXT:   %[[Sub:.*]] = tfr.call @tf__sub(%[[raw_data]], %[[qparam]]#1) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK:        %[[act_range:.*]]:2 = tfr.quant_act_range(%{{.*}}, %{{.*}}, %{{.*}}) : (!tfr.attr, f32, i64) -> (!tfr.tensor, !tfr.tensor)\\n      CHECK:        %[[rescale:.*]] = tfr.quant_rescale(%[[Sub]], %[[factor1]], %{{.*}}) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor)\\n      CHECK:        %[[attr:.*]] = tfr.constant i16 -> !tfr.attr\\n      CHECK:        %[[Cast:.*]] = tfr.call @tf__cast(%[[rescale]], %[[attr]], %{{.*}}) : (!tfr.tensor, !tfr.attr, i1) -> (!tfr.tensor)\\n      CHECK:        %[[attr_1:.*]] = tfr.constant i8 -> !tfr.attr\\n      CHECK:        tfr.call @tf__cast(%[[Cast]], %[[attr_1]], %{{.*}}) : (!tfr.tensor, !tfr.attr, i1) -> (!tfr.tensor)\\n      CHECK:       }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list) {\\n      CHECK-NEXT:   %[[raw_data:.*]] = tfr.quant_raw_data(%x) : (!tfr.tensor_list) -> (!tfr.tensor_list)\\n      CHECK:        tfr.return %[[raw_data:.*]] : !tfr.tensor_list\\n      CHECK:       }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)",
            "def test_quant_builtins(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mlir_code = tfr_gen(sys.modules[__name__], '_tfr_quant', [test_ops])\n    mlir_code_exp = '\\n      CHECK-LABEL: tfr.func @tf__test_identity_op(%x: !tfr.tensor) -> (!tfr.tensor) {\\n      CHECK-NEXT:   %[[raw_data:.*]] = tfr.quant_raw_data(%x) : (!tfr.tensor) -> (!tfr.tensor)\\n      CHECK-NEXT:   %[[qparam:.*]]:2 = tfr.quant_qparam(%x) : (!tfr.tensor) -> (!tfr.tensor, !tfr.tensor)\\n      CHECK:        %[[list:.*]] = \"tfr.build_list\"(%[[qparam]]#0, %[[qparam]]#0) : (!tfr.tensor, !tfr.tensor) -> !tfr.tensor_list\\n      CHECK:        %[[factor:.*]] = tfr.quant_scale_factor(%{{.*}}, %[[list]]) : (f32, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK:        %[[list1:.*]] = \"tfr.build_list\"(%[[factor]]) : (!tfr.tensor) -> !tfr.tensor_list\\n      CHECK:        %[[factor1:.*]] = tfr.quant_scale_factor(%{{.*}}, %[[list1]]) : (f32, !tfr.tensor_list) -> (!tfr.tensor)\\n      CHECK-NEXT:   %[[Sub:.*]] = tfr.call @tf__sub(%[[raw_data]], %[[qparam]]#1) : (!tfr.tensor, !tfr.tensor) -> (!tfr.tensor)\\n      CHECK:        %[[act_range:.*]]:2 = tfr.quant_act_range(%{{.*}}, %{{.*}}, %{{.*}}) : (!tfr.attr, f32, i64) -> (!tfr.tensor, !tfr.tensor)\\n      CHECK:        %[[rescale:.*]] = tfr.quant_rescale(%[[Sub]], %[[factor1]], %{{.*}}) : (!tfr.tensor, !tfr.tensor, i64) -> (!tfr.tensor)\\n      CHECK:        %[[attr:.*]] = tfr.constant i16 -> !tfr.attr\\n      CHECK:        %[[Cast:.*]] = tfr.call @tf__cast(%[[rescale]], %[[attr]], %{{.*}}) : (!tfr.tensor, !tfr.attr, i1) -> (!tfr.tensor)\\n      CHECK:        %[[attr_1:.*]] = tfr.constant i8 -> !tfr.attr\\n      CHECK:        tfr.call @tf__cast(%[[Cast]], %[[attr_1]], %{{.*}}) : (!tfr.tensor, !tfr.attr, i1) -> (!tfr.tensor)\\n      CHECK:       }\\n\\n      CHECK-LABEL: tfr.func @tf__test_identity_n_op(%x: !tfr.tensor_list) -> (!tfr.tensor_list) {\\n      CHECK-NEXT:   %[[raw_data:.*]] = tfr.quant_raw_data(%x) : (!tfr.tensor_list) -> (!tfr.tensor_list)\\n      CHECK:        tfr.return %[[raw_data:.*]] : !tfr.tensor_list\\n      CHECK:       }\\n    '\n    self._check_code(mlir_code, mlir_code_exp)"
        ]
    }
]