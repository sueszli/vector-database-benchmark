[
    {
        "func_name": "_make_ellipse",
        "original": "def _make_ellipse(mean, cov, ax, level=0.95, color=None):\n    \"\"\"Support function for scatter_ellipse.\"\"\"\n    from matplotlib.patches import Ellipse\n    (v, w) = np.linalg.eigh(cov)\n    u = w[0] / np.linalg.norm(w[0])\n    angle = np.arctan(u[1] / u[0])\n    angle = 180 * angle / np.pi\n    v = 2 * np.sqrt(v * stats.chi2.ppf(level, 2))\n    ell = Ellipse(mean[:2], v[0], v[1], 180 + angle, facecolor='none', edgecolor=color, lw=1.5)\n    ell.set_clip_box(ax.bbox)\n    ell.set_alpha(0.5)\n    ax.add_artist(ell)",
        "mutated": [
            "def _make_ellipse(mean, cov, ax, level=0.95, color=None):\n    if False:\n        i = 10\n    'Support function for scatter_ellipse.'\n    from matplotlib.patches import Ellipse\n    (v, w) = np.linalg.eigh(cov)\n    u = w[0] / np.linalg.norm(w[0])\n    angle = np.arctan(u[1] / u[0])\n    angle = 180 * angle / np.pi\n    v = 2 * np.sqrt(v * stats.chi2.ppf(level, 2))\n    ell = Ellipse(mean[:2], v[0], v[1], 180 + angle, facecolor='none', edgecolor=color, lw=1.5)\n    ell.set_clip_box(ax.bbox)\n    ell.set_alpha(0.5)\n    ax.add_artist(ell)",
            "def _make_ellipse(mean, cov, ax, level=0.95, color=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Support function for scatter_ellipse.'\n    from matplotlib.patches import Ellipse\n    (v, w) = np.linalg.eigh(cov)\n    u = w[0] / np.linalg.norm(w[0])\n    angle = np.arctan(u[1] / u[0])\n    angle = 180 * angle / np.pi\n    v = 2 * np.sqrt(v * stats.chi2.ppf(level, 2))\n    ell = Ellipse(mean[:2], v[0], v[1], 180 + angle, facecolor='none', edgecolor=color, lw=1.5)\n    ell.set_clip_box(ax.bbox)\n    ell.set_alpha(0.5)\n    ax.add_artist(ell)",
            "def _make_ellipse(mean, cov, ax, level=0.95, color=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Support function for scatter_ellipse.'\n    from matplotlib.patches import Ellipse\n    (v, w) = np.linalg.eigh(cov)\n    u = w[0] / np.linalg.norm(w[0])\n    angle = np.arctan(u[1] / u[0])\n    angle = 180 * angle / np.pi\n    v = 2 * np.sqrt(v * stats.chi2.ppf(level, 2))\n    ell = Ellipse(mean[:2], v[0], v[1], 180 + angle, facecolor='none', edgecolor=color, lw=1.5)\n    ell.set_clip_box(ax.bbox)\n    ell.set_alpha(0.5)\n    ax.add_artist(ell)",
            "def _make_ellipse(mean, cov, ax, level=0.95, color=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Support function for scatter_ellipse.'\n    from matplotlib.patches import Ellipse\n    (v, w) = np.linalg.eigh(cov)\n    u = w[0] / np.linalg.norm(w[0])\n    angle = np.arctan(u[1] / u[0])\n    angle = 180 * angle / np.pi\n    v = 2 * np.sqrt(v * stats.chi2.ppf(level, 2))\n    ell = Ellipse(mean[:2], v[0], v[1], 180 + angle, facecolor='none', edgecolor=color, lw=1.5)\n    ell.set_clip_box(ax.bbox)\n    ell.set_alpha(0.5)\n    ax.add_artist(ell)",
            "def _make_ellipse(mean, cov, ax, level=0.95, color=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Support function for scatter_ellipse.'\n    from matplotlib.patches import Ellipse\n    (v, w) = np.linalg.eigh(cov)\n    u = w[0] / np.linalg.norm(w[0])\n    angle = np.arctan(u[1] / u[0])\n    angle = 180 * angle / np.pi\n    v = 2 * np.sqrt(v * stats.chi2.ppf(level, 2))\n    ell = Ellipse(mean[:2], v[0], v[1], 180 + angle, facecolor='none', edgecolor=color, lw=1.5)\n    ell.set_clip_box(ax.bbox)\n    ell.set_alpha(0.5)\n    ax.add_artist(ell)"
        ]
    },
    {
        "func_name": "scatter_ellipse",
        "original": "def scatter_ellipse(data, level=0.9, varnames=None, ell_kwds=None, plot_kwds=None, add_titles=False, keep_ticks=False, fig=None):\n    \"\"\"Create a grid of scatter plots with confidence ellipses.\n\n    ell_kwds, plot_kdes not used yet\n\n    looks ok with 5 or 6 variables, too crowded with 8, too empty with 1\n\n    Parameters\n    ----------\n    data : array_like\n        Input data.\n    level : scalar, optional\n        Default is 0.9.\n    varnames : list[str], optional\n        Variable names.  Used for y-axis labels, and if `add_titles` is True\n        also for titles.  If not given, integers 1..data.shape[1] are used.\n    ell_kwds : dict, optional\n        UNUSED\n    plot_kwds : dict, optional\n        UNUSED\n    add_titles : bool, optional\n        Whether or not to add titles to each subplot.  Default is False.\n        Titles are constructed from `varnames`.\n    keep_ticks : bool, optional\n        If False (default), remove all axis ticks.\n    fig : Figure, optional\n        If given, this figure is simply returned.  Otherwise a new figure is\n        created.\n\n    Returns\n    -------\n    Figure\n        If `fig` is None, the created figure.  Otherwise `fig` itself.\n\n    Examples\n    --------\n    >>> import statsmodels.api as sm\n    >>> import matplotlib.pyplot as plt\n    >>> import numpy as np\n\n    >>> from statsmodels.graphics.plot_grids import scatter_ellipse\n    >>> data = sm.datasets.statecrime.load_pandas().data\n    >>> fig = plt.figure(figsize=(8,8))\n    >>> scatter_ellipse(data, varnames=data.columns, fig=fig)\n    >>> plt.show()\n\n    .. plot:: plots/graphics_plot_grids_scatter_ellipse.py\n    \"\"\"\n    fig = utils.create_mpl_fig(fig)\n    import matplotlib.ticker as mticker\n    data = np.asanyarray(data)\n    nvars = data.shape[1]\n    if varnames is None:\n        varnames = ['var%d' % i for i in range(nvars)]\n    plot_kwds_ = dict(ls='none', marker='.', color='k', alpha=0.5)\n    if plot_kwds:\n        plot_kwds_.update(plot_kwds)\n    ell_kwds_ = dict(color='k')\n    if ell_kwds:\n        ell_kwds_.update(ell_kwds)\n    dmean = data.mean(0)\n    dcov = np.cov(data, rowvar=0)\n    for i in range(1, nvars):\n        ax_last = None\n        for j in range(i):\n            ax = fig.add_subplot(nvars - 1, nvars - 1, (i - 1) * (nvars - 1) + j + 1)\n            formatter = mticker.FormatStrFormatter('% 3.1f')\n            ax.yaxis.set_major_formatter(formatter)\n            ax.xaxis.set_major_formatter(formatter)\n            idx = np.array([j, i])\n            ax.plot(*data[:, idx].T, **plot_kwds_)\n            if np.isscalar(level):\n                level = [level]\n            for alpha in level:\n                _make_ellipse(dmean[idx], dcov[idx[:, None], idx], ax, level=alpha, **ell_kwds_)\n            if add_titles:\n                ax.set_title('%s-%s' % (varnames[i], varnames[j]))\n            if not ax.is_first_col():\n                if not keep_ticks:\n                    ax.set_yticks([])\n                else:\n                    ax.yaxis.set_major_locator(mticker.MaxNLocator(3))\n            else:\n                ax.set_ylabel(varnames[i])\n            if ax.is_last_row():\n                ax.set_xlabel(varnames[j])\n            elif not keep_ticks:\n                ax.set_xticks([])\n            else:\n                ax.xaxis.set_major_locator(mticker.MaxNLocator(3))\n            dcorr = np.corrcoef(data, rowvar=0)\n            dc = dcorr[idx[:, None], idx]\n            xlim = ax.get_xlim()\n            ylim = ax.get_ylim()\n            yrangeq = ylim[0] + 0.4 * (ylim[1] - ylim[0])\n            if dc[1, 0] < -0.25 or (dc[1, 0] < 0.25 and dmean[idx][1] > yrangeq):\n                yt = ylim[0] + 0.1 * (ylim[1] - ylim[0])\n            else:\n                yt = ylim[1] - 0.2 * (ylim[1] - ylim[0])\n            xt = xlim[0] + 0.1 * (xlim[1] - xlim[0])\n            ax.text(xt, yt, '$\\\\rho=%0.2f$' % dc[1, 0])\n    for ax in fig.axes:\n        if ax.is_last_row():\n            ax.xaxis.set_major_locator(mticker.MaxNLocator(3))\n        if ax.is_first_col():\n            ax.yaxis.set_major_locator(mticker.MaxNLocator(3))\n    return fig",
        "mutated": [
            "def scatter_ellipse(data, level=0.9, varnames=None, ell_kwds=None, plot_kwds=None, add_titles=False, keep_ticks=False, fig=None):\n    if False:\n        i = 10\n    'Create a grid of scatter plots with confidence ellipses.\\n\\n    ell_kwds, plot_kdes not used yet\\n\\n    looks ok with 5 or 6 variables, too crowded with 8, too empty with 1\\n\\n    Parameters\\n    ----------\\n    data : array_like\\n        Input data.\\n    level : scalar, optional\\n        Default is 0.9.\\n    varnames : list[str], optional\\n        Variable names.  Used for y-axis labels, and if `add_titles` is True\\n        also for titles.  If not given, integers 1..data.shape[1] are used.\\n    ell_kwds : dict, optional\\n        UNUSED\\n    plot_kwds : dict, optional\\n        UNUSED\\n    add_titles : bool, optional\\n        Whether or not to add titles to each subplot.  Default is False.\\n        Titles are constructed from `varnames`.\\n    keep_ticks : bool, optional\\n        If False (default), remove all axis ticks.\\n    fig : Figure, optional\\n        If given, this figure is simply returned.  Otherwise a new figure is\\n        created.\\n\\n    Returns\\n    -------\\n    Figure\\n        If `fig` is None, the created figure.  Otherwise `fig` itself.\\n\\n    Examples\\n    --------\\n    >>> import statsmodels.api as sm\\n    >>> import matplotlib.pyplot as plt\\n    >>> import numpy as np\\n\\n    >>> from statsmodels.graphics.plot_grids import scatter_ellipse\\n    >>> data = sm.datasets.statecrime.load_pandas().data\\n    >>> fig = plt.figure(figsize=(8,8))\\n    >>> scatter_ellipse(data, varnames=data.columns, fig=fig)\\n    >>> plt.show()\\n\\n    .. plot:: plots/graphics_plot_grids_scatter_ellipse.py\\n    '\n    fig = utils.create_mpl_fig(fig)\n    import matplotlib.ticker as mticker\n    data = np.asanyarray(data)\n    nvars = data.shape[1]\n    if varnames is None:\n        varnames = ['var%d' % i for i in range(nvars)]\n    plot_kwds_ = dict(ls='none', marker='.', color='k', alpha=0.5)\n    if plot_kwds:\n        plot_kwds_.update(plot_kwds)\n    ell_kwds_ = dict(color='k')\n    if ell_kwds:\n        ell_kwds_.update(ell_kwds)\n    dmean = data.mean(0)\n    dcov = np.cov(data, rowvar=0)\n    for i in range(1, nvars):\n        ax_last = None\n        for j in range(i):\n            ax = fig.add_subplot(nvars - 1, nvars - 1, (i - 1) * (nvars - 1) + j + 1)\n            formatter = mticker.FormatStrFormatter('% 3.1f')\n            ax.yaxis.set_major_formatter(formatter)\n            ax.xaxis.set_major_formatter(formatter)\n            idx = np.array([j, i])\n            ax.plot(*data[:, idx].T, **plot_kwds_)\n            if np.isscalar(level):\n                level = [level]\n            for alpha in level:\n                _make_ellipse(dmean[idx], dcov[idx[:, None], idx], ax, level=alpha, **ell_kwds_)\n            if add_titles:\n                ax.set_title('%s-%s' % (varnames[i], varnames[j]))\n            if not ax.is_first_col():\n                if not keep_ticks:\n                    ax.set_yticks([])\n                else:\n                    ax.yaxis.set_major_locator(mticker.MaxNLocator(3))\n            else:\n                ax.set_ylabel(varnames[i])\n            if ax.is_last_row():\n                ax.set_xlabel(varnames[j])\n            elif not keep_ticks:\n                ax.set_xticks([])\n            else:\n                ax.xaxis.set_major_locator(mticker.MaxNLocator(3))\n            dcorr = np.corrcoef(data, rowvar=0)\n            dc = dcorr[idx[:, None], idx]\n            xlim = ax.get_xlim()\n            ylim = ax.get_ylim()\n            yrangeq = ylim[0] + 0.4 * (ylim[1] - ylim[0])\n            if dc[1, 0] < -0.25 or (dc[1, 0] < 0.25 and dmean[idx][1] > yrangeq):\n                yt = ylim[0] + 0.1 * (ylim[1] - ylim[0])\n            else:\n                yt = ylim[1] - 0.2 * (ylim[1] - ylim[0])\n            xt = xlim[0] + 0.1 * (xlim[1] - xlim[0])\n            ax.text(xt, yt, '$\\\\rho=%0.2f$' % dc[1, 0])\n    for ax in fig.axes:\n        if ax.is_last_row():\n            ax.xaxis.set_major_locator(mticker.MaxNLocator(3))\n        if ax.is_first_col():\n            ax.yaxis.set_major_locator(mticker.MaxNLocator(3))\n    return fig",
            "def scatter_ellipse(data, level=0.9, varnames=None, ell_kwds=None, plot_kwds=None, add_titles=False, keep_ticks=False, fig=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create a grid of scatter plots with confidence ellipses.\\n\\n    ell_kwds, plot_kdes not used yet\\n\\n    looks ok with 5 or 6 variables, too crowded with 8, too empty with 1\\n\\n    Parameters\\n    ----------\\n    data : array_like\\n        Input data.\\n    level : scalar, optional\\n        Default is 0.9.\\n    varnames : list[str], optional\\n        Variable names.  Used for y-axis labels, and if `add_titles` is True\\n        also for titles.  If not given, integers 1..data.shape[1] are used.\\n    ell_kwds : dict, optional\\n        UNUSED\\n    plot_kwds : dict, optional\\n        UNUSED\\n    add_titles : bool, optional\\n        Whether or not to add titles to each subplot.  Default is False.\\n        Titles are constructed from `varnames`.\\n    keep_ticks : bool, optional\\n        If False (default), remove all axis ticks.\\n    fig : Figure, optional\\n        If given, this figure is simply returned.  Otherwise a new figure is\\n        created.\\n\\n    Returns\\n    -------\\n    Figure\\n        If `fig` is None, the created figure.  Otherwise `fig` itself.\\n\\n    Examples\\n    --------\\n    >>> import statsmodels.api as sm\\n    >>> import matplotlib.pyplot as plt\\n    >>> import numpy as np\\n\\n    >>> from statsmodels.graphics.plot_grids import scatter_ellipse\\n    >>> data = sm.datasets.statecrime.load_pandas().data\\n    >>> fig = plt.figure(figsize=(8,8))\\n    >>> scatter_ellipse(data, varnames=data.columns, fig=fig)\\n    >>> plt.show()\\n\\n    .. plot:: plots/graphics_plot_grids_scatter_ellipse.py\\n    '\n    fig = utils.create_mpl_fig(fig)\n    import matplotlib.ticker as mticker\n    data = np.asanyarray(data)\n    nvars = data.shape[1]\n    if varnames is None:\n        varnames = ['var%d' % i for i in range(nvars)]\n    plot_kwds_ = dict(ls='none', marker='.', color='k', alpha=0.5)\n    if plot_kwds:\n        plot_kwds_.update(plot_kwds)\n    ell_kwds_ = dict(color='k')\n    if ell_kwds:\n        ell_kwds_.update(ell_kwds)\n    dmean = data.mean(0)\n    dcov = np.cov(data, rowvar=0)\n    for i in range(1, nvars):\n        ax_last = None\n        for j in range(i):\n            ax = fig.add_subplot(nvars - 1, nvars - 1, (i - 1) * (nvars - 1) + j + 1)\n            formatter = mticker.FormatStrFormatter('% 3.1f')\n            ax.yaxis.set_major_formatter(formatter)\n            ax.xaxis.set_major_formatter(formatter)\n            idx = np.array([j, i])\n            ax.plot(*data[:, idx].T, **plot_kwds_)\n            if np.isscalar(level):\n                level = [level]\n            for alpha in level:\n                _make_ellipse(dmean[idx], dcov[idx[:, None], idx], ax, level=alpha, **ell_kwds_)\n            if add_titles:\n                ax.set_title('%s-%s' % (varnames[i], varnames[j]))\n            if not ax.is_first_col():\n                if not keep_ticks:\n                    ax.set_yticks([])\n                else:\n                    ax.yaxis.set_major_locator(mticker.MaxNLocator(3))\n            else:\n                ax.set_ylabel(varnames[i])\n            if ax.is_last_row():\n                ax.set_xlabel(varnames[j])\n            elif not keep_ticks:\n                ax.set_xticks([])\n            else:\n                ax.xaxis.set_major_locator(mticker.MaxNLocator(3))\n            dcorr = np.corrcoef(data, rowvar=0)\n            dc = dcorr[idx[:, None], idx]\n            xlim = ax.get_xlim()\n            ylim = ax.get_ylim()\n            yrangeq = ylim[0] + 0.4 * (ylim[1] - ylim[0])\n            if dc[1, 0] < -0.25 or (dc[1, 0] < 0.25 and dmean[idx][1] > yrangeq):\n                yt = ylim[0] + 0.1 * (ylim[1] - ylim[0])\n            else:\n                yt = ylim[1] - 0.2 * (ylim[1] - ylim[0])\n            xt = xlim[0] + 0.1 * (xlim[1] - xlim[0])\n            ax.text(xt, yt, '$\\\\rho=%0.2f$' % dc[1, 0])\n    for ax in fig.axes:\n        if ax.is_last_row():\n            ax.xaxis.set_major_locator(mticker.MaxNLocator(3))\n        if ax.is_first_col():\n            ax.yaxis.set_major_locator(mticker.MaxNLocator(3))\n    return fig",
            "def scatter_ellipse(data, level=0.9, varnames=None, ell_kwds=None, plot_kwds=None, add_titles=False, keep_ticks=False, fig=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create a grid of scatter plots with confidence ellipses.\\n\\n    ell_kwds, plot_kdes not used yet\\n\\n    looks ok with 5 or 6 variables, too crowded with 8, too empty with 1\\n\\n    Parameters\\n    ----------\\n    data : array_like\\n        Input data.\\n    level : scalar, optional\\n        Default is 0.9.\\n    varnames : list[str], optional\\n        Variable names.  Used for y-axis labels, and if `add_titles` is True\\n        also for titles.  If not given, integers 1..data.shape[1] are used.\\n    ell_kwds : dict, optional\\n        UNUSED\\n    plot_kwds : dict, optional\\n        UNUSED\\n    add_titles : bool, optional\\n        Whether or not to add titles to each subplot.  Default is False.\\n        Titles are constructed from `varnames`.\\n    keep_ticks : bool, optional\\n        If False (default), remove all axis ticks.\\n    fig : Figure, optional\\n        If given, this figure is simply returned.  Otherwise a new figure is\\n        created.\\n\\n    Returns\\n    -------\\n    Figure\\n        If `fig` is None, the created figure.  Otherwise `fig` itself.\\n\\n    Examples\\n    --------\\n    >>> import statsmodels.api as sm\\n    >>> import matplotlib.pyplot as plt\\n    >>> import numpy as np\\n\\n    >>> from statsmodels.graphics.plot_grids import scatter_ellipse\\n    >>> data = sm.datasets.statecrime.load_pandas().data\\n    >>> fig = plt.figure(figsize=(8,8))\\n    >>> scatter_ellipse(data, varnames=data.columns, fig=fig)\\n    >>> plt.show()\\n\\n    .. plot:: plots/graphics_plot_grids_scatter_ellipse.py\\n    '\n    fig = utils.create_mpl_fig(fig)\n    import matplotlib.ticker as mticker\n    data = np.asanyarray(data)\n    nvars = data.shape[1]\n    if varnames is None:\n        varnames = ['var%d' % i for i in range(nvars)]\n    plot_kwds_ = dict(ls='none', marker='.', color='k', alpha=0.5)\n    if plot_kwds:\n        plot_kwds_.update(plot_kwds)\n    ell_kwds_ = dict(color='k')\n    if ell_kwds:\n        ell_kwds_.update(ell_kwds)\n    dmean = data.mean(0)\n    dcov = np.cov(data, rowvar=0)\n    for i in range(1, nvars):\n        ax_last = None\n        for j in range(i):\n            ax = fig.add_subplot(nvars - 1, nvars - 1, (i - 1) * (nvars - 1) + j + 1)\n            formatter = mticker.FormatStrFormatter('% 3.1f')\n            ax.yaxis.set_major_formatter(formatter)\n            ax.xaxis.set_major_formatter(formatter)\n            idx = np.array([j, i])\n            ax.plot(*data[:, idx].T, **plot_kwds_)\n            if np.isscalar(level):\n                level = [level]\n            for alpha in level:\n                _make_ellipse(dmean[idx], dcov[idx[:, None], idx], ax, level=alpha, **ell_kwds_)\n            if add_titles:\n                ax.set_title('%s-%s' % (varnames[i], varnames[j]))\n            if not ax.is_first_col():\n                if not keep_ticks:\n                    ax.set_yticks([])\n                else:\n                    ax.yaxis.set_major_locator(mticker.MaxNLocator(3))\n            else:\n                ax.set_ylabel(varnames[i])\n            if ax.is_last_row():\n                ax.set_xlabel(varnames[j])\n            elif not keep_ticks:\n                ax.set_xticks([])\n            else:\n                ax.xaxis.set_major_locator(mticker.MaxNLocator(3))\n            dcorr = np.corrcoef(data, rowvar=0)\n            dc = dcorr[idx[:, None], idx]\n            xlim = ax.get_xlim()\n            ylim = ax.get_ylim()\n            yrangeq = ylim[0] + 0.4 * (ylim[1] - ylim[0])\n            if dc[1, 0] < -0.25 or (dc[1, 0] < 0.25 and dmean[idx][1] > yrangeq):\n                yt = ylim[0] + 0.1 * (ylim[1] - ylim[0])\n            else:\n                yt = ylim[1] - 0.2 * (ylim[1] - ylim[0])\n            xt = xlim[0] + 0.1 * (xlim[1] - xlim[0])\n            ax.text(xt, yt, '$\\\\rho=%0.2f$' % dc[1, 0])\n    for ax in fig.axes:\n        if ax.is_last_row():\n            ax.xaxis.set_major_locator(mticker.MaxNLocator(3))\n        if ax.is_first_col():\n            ax.yaxis.set_major_locator(mticker.MaxNLocator(3))\n    return fig",
            "def scatter_ellipse(data, level=0.9, varnames=None, ell_kwds=None, plot_kwds=None, add_titles=False, keep_ticks=False, fig=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create a grid of scatter plots with confidence ellipses.\\n\\n    ell_kwds, plot_kdes not used yet\\n\\n    looks ok with 5 or 6 variables, too crowded with 8, too empty with 1\\n\\n    Parameters\\n    ----------\\n    data : array_like\\n        Input data.\\n    level : scalar, optional\\n        Default is 0.9.\\n    varnames : list[str], optional\\n        Variable names.  Used for y-axis labels, and if `add_titles` is True\\n        also for titles.  If not given, integers 1..data.shape[1] are used.\\n    ell_kwds : dict, optional\\n        UNUSED\\n    plot_kwds : dict, optional\\n        UNUSED\\n    add_titles : bool, optional\\n        Whether or not to add titles to each subplot.  Default is False.\\n        Titles are constructed from `varnames`.\\n    keep_ticks : bool, optional\\n        If False (default), remove all axis ticks.\\n    fig : Figure, optional\\n        If given, this figure is simply returned.  Otherwise a new figure is\\n        created.\\n\\n    Returns\\n    -------\\n    Figure\\n        If `fig` is None, the created figure.  Otherwise `fig` itself.\\n\\n    Examples\\n    --------\\n    >>> import statsmodels.api as sm\\n    >>> import matplotlib.pyplot as plt\\n    >>> import numpy as np\\n\\n    >>> from statsmodels.graphics.plot_grids import scatter_ellipse\\n    >>> data = sm.datasets.statecrime.load_pandas().data\\n    >>> fig = plt.figure(figsize=(8,8))\\n    >>> scatter_ellipse(data, varnames=data.columns, fig=fig)\\n    >>> plt.show()\\n\\n    .. plot:: plots/graphics_plot_grids_scatter_ellipse.py\\n    '\n    fig = utils.create_mpl_fig(fig)\n    import matplotlib.ticker as mticker\n    data = np.asanyarray(data)\n    nvars = data.shape[1]\n    if varnames is None:\n        varnames = ['var%d' % i for i in range(nvars)]\n    plot_kwds_ = dict(ls='none', marker='.', color='k', alpha=0.5)\n    if plot_kwds:\n        plot_kwds_.update(plot_kwds)\n    ell_kwds_ = dict(color='k')\n    if ell_kwds:\n        ell_kwds_.update(ell_kwds)\n    dmean = data.mean(0)\n    dcov = np.cov(data, rowvar=0)\n    for i in range(1, nvars):\n        ax_last = None\n        for j in range(i):\n            ax = fig.add_subplot(nvars - 1, nvars - 1, (i - 1) * (nvars - 1) + j + 1)\n            formatter = mticker.FormatStrFormatter('% 3.1f')\n            ax.yaxis.set_major_formatter(formatter)\n            ax.xaxis.set_major_formatter(formatter)\n            idx = np.array([j, i])\n            ax.plot(*data[:, idx].T, **plot_kwds_)\n            if np.isscalar(level):\n                level = [level]\n            for alpha in level:\n                _make_ellipse(dmean[idx], dcov[idx[:, None], idx], ax, level=alpha, **ell_kwds_)\n            if add_titles:\n                ax.set_title('%s-%s' % (varnames[i], varnames[j]))\n            if not ax.is_first_col():\n                if not keep_ticks:\n                    ax.set_yticks([])\n                else:\n                    ax.yaxis.set_major_locator(mticker.MaxNLocator(3))\n            else:\n                ax.set_ylabel(varnames[i])\n            if ax.is_last_row():\n                ax.set_xlabel(varnames[j])\n            elif not keep_ticks:\n                ax.set_xticks([])\n            else:\n                ax.xaxis.set_major_locator(mticker.MaxNLocator(3))\n            dcorr = np.corrcoef(data, rowvar=0)\n            dc = dcorr[idx[:, None], idx]\n            xlim = ax.get_xlim()\n            ylim = ax.get_ylim()\n            yrangeq = ylim[0] + 0.4 * (ylim[1] - ylim[0])\n            if dc[1, 0] < -0.25 or (dc[1, 0] < 0.25 and dmean[idx][1] > yrangeq):\n                yt = ylim[0] + 0.1 * (ylim[1] - ylim[0])\n            else:\n                yt = ylim[1] - 0.2 * (ylim[1] - ylim[0])\n            xt = xlim[0] + 0.1 * (xlim[1] - xlim[0])\n            ax.text(xt, yt, '$\\\\rho=%0.2f$' % dc[1, 0])\n    for ax in fig.axes:\n        if ax.is_last_row():\n            ax.xaxis.set_major_locator(mticker.MaxNLocator(3))\n        if ax.is_first_col():\n            ax.yaxis.set_major_locator(mticker.MaxNLocator(3))\n    return fig",
            "def scatter_ellipse(data, level=0.9, varnames=None, ell_kwds=None, plot_kwds=None, add_titles=False, keep_ticks=False, fig=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create a grid of scatter plots with confidence ellipses.\\n\\n    ell_kwds, plot_kdes not used yet\\n\\n    looks ok with 5 or 6 variables, too crowded with 8, too empty with 1\\n\\n    Parameters\\n    ----------\\n    data : array_like\\n        Input data.\\n    level : scalar, optional\\n        Default is 0.9.\\n    varnames : list[str], optional\\n        Variable names.  Used for y-axis labels, and if `add_titles` is True\\n        also for titles.  If not given, integers 1..data.shape[1] are used.\\n    ell_kwds : dict, optional\\n        UNUSED\\n    plot_kwds : dict, optional\\n        UNUSED\\n    add_titles : bool, optional\\n        Whether or not to add titles to each subplot.  Default is False.\\n        Titles are constructed from `varnames`.\\n    keep_ticks : bool, optional\\n        If False (default), remove all axis ticks.\\n    fig : Figure, optional\\n        If given, this figure is simply returned.  Otherwise a new figure is\\n        created.\\n\\n    Returns\\n    -------\\n    Figure\\n        If `fig` is None, the created figure.  Otherwise `fig` itself.\\n\\n    Examples\\n    --------\\n    >>> import statsmodels.api as sm\\n    >>> import matplotlib.pyplot as plt\\n    >>> import numpy as np\\n\\n    >>> from statsmodels.graphics.plot_grids import scatter_ellipse\\n    >>> data = sm.datasets.statecrime.load_pandas().data\\n    >>> fig = plt.figure(figsize=(8,8))\\n    >>> scatter_ellipse(data, varnames=data.columns, fig=fig)\\n    >>> plt.show()\\n\\n    .. plot:: plots/graphics_plot_grids_scatter_ellipse.py\\n    '\n    fig = utils.create_mpl_fig(fig)\n    import matplotlib.ticker as mticker\n    data = np.asanyarray(data)\n    nvars = data.shape[1]\n    if varnames is None:\n        varnames = ['var%d' % i for i in range(nvars)]\n    plot_kwds_ = dict(ls='none', marker='.', color='k', alpha=0.5)\n    if plot_kwds:\n        plot_kwds_.update(plot_kwds)\n    ell_kwds_ = dict(color='k')\n    if ell_kwds:\n        ell_kwds_.update(ell_kwds)\n    dmean = data.mean(0)\n    dcov = np.cov(data, rowvar=0)\n    for i in range(1, nvars):\n        ax_last = None\n        for j in range(i):\n            ax = fig.add_subplot(nvars - 1, nvars - 1, (i - 1) * (nvars - 1) + j + 1)\n            formatter = mticker.FormatStrFormatter('% 3.1f')\n            ax.yaxis.set_major_formatter(formatter)\n            ax.xaxis.set_major_formatter(formatter)\n            idx = np.array([j, i])\n            ax.plot(*data[:, idx].T, **plot_kwds_)\n            if np.isscalar(level):\n                level = [level]\n            for alpha in level:\n                _make_ellipse(dmean[idx], dcov[idx[:, None], idx], ax, level=alpha, **ell_kwds_)\n            if add_titles:\n                ax.set_title('%s-%s' % (varnames[i], varnames[j]))\n            if not ax.is_first_col():\n                if not keep_ticks:\n                    ax.set_yticks([])\n                else:\n                    ax.yaxis.set_major_locator(mticker.MaxNLocator(3))\n            else:\n                ax.set_ylabel(varnames[i])\n            if ax.is_last_row():\n                ax.set_xlabel(varnames[j])\n            elif not keep_ticks:\n                ax.set_xticks([])\n            else:\n                ax.xaxis.set_major_locator(mticker.MaxNLocator(3))\n            dcorr = np.corrcoef(data, rowvar=0)\n            dc = dcorr[idx[:, None], idx]\n            xlim = ax.get_xlim()\n            ylim = ax.get_ylim()\n            yrangeq = ylim[0] + 0.4 * (ylim[1] - ylim[0])\n            if dc[1, 0] < -0.25 or (dc[1, 0] < 0.25 and dmean[idx][1] > yrangeq):\n                yt = ylim[0] + 0.1 * (ylim[1] - ylim[0])\n            else:\n                yt = ylim[1] - 0.2 * (ylim[1] - ylim[0])\n            xt = xlim[0] + 0.1 * (xlim[1] - xlim[0])\n            ax.text(xt, yt, '$\\\\rho=%0.2f$' % dc[1, 0])\n    for ax in fig.axes:\n        if ax.is_last_row():\n            ax.xaxis.set_major_locator(mticker.MaxNLocator(3))\n        if ax.is_first_col():\n            ax.yaxis.set_major_locator(mticker.MaxNLocator(3))\n    return fig"
        ]
    }
]