[
    {
        "func_name": "get_row_nnz",
        "original": "def get_row_nnz(mat, row):\n    \"\"\"Return the number of nonzeros in row.\n    \"\"\"\n    return mat.indptr[row + 1] - mat.indptr[row]",
        "mutated": [
            "def get_row_nnz(mat, row):\n    if False:\n        i = 10\n    'Return the number of nonzeros in row.\\n    '\n    return mat.indptr[row + 1] - mat.indptr[row]",
            "def get_row_nnz(mat, row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the number of nonzeros in row.\\n    '\n    return mat.indptr[row + 1] - mat.indptr[row]",
            "def get_row_nnz(mat, row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the number of nonzeros in row.\\n    '\n    return mat.indptr[row + 1] - mat.indptr[row]",
            "def get_row_nnz(mat, row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the number of nonzeros in row.\\n    '\n    return mat.indptr[row + 1] - mat.indptr[row]",
            "def get_row_nnz(mat, row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the number of nonzeros in row.\\n    '\n    return mat.indptr[row + 1] - mat.indptr[row]"
        ]
    },
    {
        "func_name": "compress_matrix",
        "original": "def compress_matrix(A, b, equil_eps: float=1e-10):\n    \"\"\"Compresses A and b by eliminating redundant rows.\n\n    Identifies rows that are multiples of another row.\n    Reduces A and b to C = PA, d = Pb, where P has one\n    nonzero per row.\n\n    Parameters\n    ----------\n    A : SciPy CSR matrix\n        The constraints matrix to compress.\n    b : NumPy 1D array\n        The vector associated with the constraints matrix.\n    equil_eps : float, optional\n        Standard for considering two numbers equivalent.\n\n    Returns\n    -------\n    tuple\n        The tuple (A, b, P) where A and b are compressed according to P.\n    \"\"\"\n    P_V = []\n    P_I = []\n    P_J = []\n    row_to_keep = []\n    sparsity_to_row = {}\n    prev_ptr = A.indptr[0]\n    for row_num in range(A.shape[0]):\n        keep_row = True\n        ptr = A.indptr[row_num + 1]\n        pattern = tuple(A.indices[prev_ptr:ptr])\n        nnz = ptr - prev_ptr\n        if nnz == 0 or np.linalg.norm(A.data[prev_ptr:ptr]) < equil_eps:\n            keep_row = False\n            P_V.append(0.0)\n            P_I.append(row_num)\n            P_J.append(0)\n        elif pattern in sparsity_to_row and nnz == get_row_nnz(A, sparsity_to_row[pattern][0]):\n            row_matches = sparsity_to_row[pattern]\n            for row_match in row_matches:\n                cur_vals = A.data[prev_ptr:ptr]\n                prev_match_ptr = A.indptr[row_match]\n                match_ptr = A.indptr[row_match + 1]\n                match_vals = A.data[prev_match_ptr:match_ptr]\n                ratio = cur_vals / match_vals\n                if np.ptp(ratio) < equil_eps and abs(ratio[0] - b[row_num] / b[row_match]) < equil_eps:\n                    keep_row = False\n                    P_V.append(ratio[0])\n                    P_I.append(row_num)\n                    P_J.append(row_match)\n            if keep_row:\n                sparsity_to_row[pattern].append(row_num)\n        else:\n            sparsity_to_row[pattern] = [row_num]\n        if keep_row:\n            row_to_keep.append(row_num)\n            P_V.append(1.0)\n            P_I.append(row_num)\n            P_J.append(len(row_to_keep) - 1)\n    cols = max(len(row_to_keep), 1)\n    P = sp.coo_matrix((P_V, (P_I, P_J)), (A.shape[0], cols))\n    A_compr = A[row_to_keep, :]\n    b_compr = b[row_to_keep]\n    return (A_compr, b_compr, P)",
        "mutated": [
            "def compress_matrix(A, b, equil_eps: float=1e-10):\n    if False:\n        i = 10\n    'Compresses A and b by eliminating redundant rows.\\n\\n    Identifies rows that are multiples of another row.\\n    Reduces A and b to C = PA, d = Pb, where P has one\\n    nonzero per row.\\n\\n    Parameters\\n    ----------\\n    A : SciPy CSR matrix\\n        The constraints matrix to compress.\\n    b : NumPy 1D array\\n        The vector associated with the constraints matrix.\\n    equil_eps : float, optional\\n        Standard for considering two numbers equivalent.\\n\\n    Returns\\n    -------\\n    tuple\\n        The tuple (A, b, P) where A and b are compressed according to P.\\n    '\n    P_V = []\n    P_I = []\n    P_J = []\n    row_to_keep = []\n    sparsity_to_row = {}\n    prev_ptr = A.indptr[0]\n    for row_num in range(A.shape[0]):\n        keep_row = True\n        ptr = A.indptr[row_num + 1]\n        pattern = tuple(A.indices[prev_ptr:ptr])\n        nnz = ptr - prev_ptr\n        if nnz == 0 or np.linalg.norm(A.data[prev_ptr:ptr]) < equil_eps:\n            keep_row = False\n            P_V.append(0.0)\n            P_I.append(row_num)\n            P_J.append(0)\n        elif pattern in sparsity_to_row and nnz == get_row_nnz(A, sparsity_to_row[pattern][0]):\n            row_matches = sparsity_to_row[pattern]\n            for row_match in row_matches:\n                cur_vals = A.data[prev_ptr:ptr]\n                prev_match_ptr = A.indptr[row_match]\n                match_ptr = A.indptr[row_match + 1]\n                match_vals = A.data[prev_match_ptr:match_ptr]\n                ratio = cur_vals / match_vals\n                if np.ptp(ratio) < equil_eps and abs(ratio[0] - b[row_num] / b[row_match]) < equil_eps:\n                    keep_row = False\n                    P_V.append(ratio[0])\n                    P_I.append(row_num)\n                    P_J.append(row_match)\n            if keep_row:\n                sparsity_to_row[pattern].append(row_num)\n        else:\n            sparsity_to_row[pattern] = [row_num]\n        if keep_row:\n            row_to_keep.append(row_num)\n            P_V.append(1.0)\n            P_I.append(row_num)\n            P_J.append(len(row_to_keep) - 1)\n    cols = max(len(row_to_keep), 1)\n    P = sp.coo_matrix((P_V, (P_I, P_J)), (A.shape[0], cols))\n    A_compr = A[row_to_keep, :]\n    b_compr = b[row_to_keep]\n    return (A_compr, b_compr, P)",
            "def compress_matrix(A, b, equil_eps: float=1e-10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compresses A and b by eliminating redundant rows.\\n\\n    Identifies rows that are multiples of another row.\\n    Reduces A and b to C = PA, d = Pb, where P has one\\n    nonzero per row.\\n\\n    Parameters\\n    ----------\\n    A : SciPy CSR matrix\\n        The constraints matrix to compress.\\n    b : NumPy 1D array\\n        The vector associated with the constraints matrix.\\n    equil_eps : float, optional\\n        Standard for considering two numbers equivalent.\\n\\n    Returns\\n    -------\\n    tuple\\n        The tuple (A, b, P) where A and b are compressed according to P.\\n    '\n    P_V = []\n    P_I = []\n    P_J = []\n    row_to_keep = []\n    sparsity_to_row = {}\n    prev_ptr = A.indptr[0]\n    for row_num in range(A.shape[0]):\n        keep_row = True\n        ptr = A.indptr[row_num + 1]\n        pattern = tuple(A.indices[prev_ptr:ptr])\n        nnz = ptr - prev_ptr\n        if nnz == 0 or np.linalg.norm(A.data[prev_ptr:ptr]) < equil_eps:\n            keep_row = False\n            P_V.append(0.0)\n            P_I.append(row_num)\n            P_J.append(0)\n        elif pattern in sparsity_to_row and nnz == get_row_nnz(A, sparsity_to_row[pattern][0]):\n            row_matches = sparsity_to_row[pattern]\n            for row_match in row_matches:\n                cur_vals = A.data[prev_ptr:ptr]\n                prev_match_ptr = A.indptr[row_match]\n                match_ptr = A.indptr[row_match + 1]\n                match_vals = A.data[prev_match_ptr:match_ptr]\n                ratio = cur_vals / match_vals\n                if np.ptp(ratio) < equil_eps and abs(ratio[0] - b[row_num] / b[row_match]) < equil_eps:\n                    keep_row = False\n                    P_V.append(ratio[0])\n                    P_I.append(row_num)\n                    P_J.append(row_match)\n            if keep_row:\n                sparsity_to_row[pattern].append(row_num)\n        else:\n            sparsity_to_row[pattern] = [row_num]\n        if keep_row:\n            row_to_keep.append(row_num)\n            P_V.append(1.0)\n            P_I.append(row_num)\n            P_J.append(len(row_to_keep) - 1)\n    cols = max(len(row_to_keep), 1)\n    P = sp.coo_matrix((P_V, (P_I, P_J)), (A.shape[0], cols))\n    A_compr = A[row_to_keep, :]\n    b_compr = b[row_to_keep]\n    return (A_compr, b_compr, P)",
            "def compress_matrix(A, b, equil_eps: float=1e-10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compresses A and b by eliminating redundant rows.\\n\\n    Identifies rows that are multiples of another row.\\n    Reduces A and b to C = PA, d = Pb, where P has one\\n    nonzero per row.\\n\\n    Parameters\\n    ----------\\n    A : SciPy CSR matrix\\n        The constraints matrix to compress.\\n    b : NumPy 1D array\\n        The vector associated with the constraints matrix.\\n    equil_eps : float, optional\\n        Standard for considering two numbers equivalent.\\n\\n    Returns\\n    -------\\n    tuple\\n        The tuple (A, b, P) where A and b are compressed according to P.\\n    '\n    P_V = []\n    P_I = []\n    P_J = []\n    row_to_keep = []\n    sparsity_to_row = {}\n    prev_ptr = A.indptr[0]\n    for row_num in range(A.shape[0]):\n        keep_row = True\n        ptr = A.indptr[row_num + 1]\n        pattern = tuple(A.indices[prev_ptr:ptr])\n        nnz = ptr - prev_ptr\n        if nnz == 0 or np.linalg.norm(A.data[prev_ptr:ptr]) < equil_eps:\n            keep_row = False\n            P_V.append(0.0)\n            P_I.append(row_num)\n            P_J.append(0)\n        elif pattern in sparsity_to_row and nnz == get_row_nnz(A, sparsity_to_row[pattern][0]):\n            row_matches = sparsity_to_row[pattern]\n            for row_match in row_matches:\n                cur_vals = A.data[prev_ptr:ptr]\n                prev_match_ptr = A.indptr[row_match]\n                match_ptr = A.indptr[row_match + 1]\n                match_vals = A.data[prev_match_ptr:match_ptr]\n                ratio = cur_vals / match_vals\n                if np.ptp(ratio) < equil_eps and abs(ratio[0] - b[row_num] / b[row_match]) < equil_eps:\n                    keep_row = False\n                    P_V.append(ratio[0])\n                    P_I.append(row_num)\n                    P_J.append(row_match)\n            if keep_row:\n                sparsity_to_row[pattern].append(row_num)\n        else:\n            sparsity_to_row[pattern] = [row_num]\n        if keep_row:\n            row_to_keep.append(row_num)\n            P_V.append(1.0)\n            P_I.append(row_num)\n            P_J.append(len(row_to_keep) - 1)\n    cols = max(len(row_to_keep), 1)\n    P = sp.coo_matrix((P_V, (P_I, P_J)), (A.shape[0], cols))\n    A_compr = A[row_to_keep, :]\n    b_compr = b[row_to_keep]\n    return (A_compr, b_compr, P)",
            "def compress_matrix(A, b, equil_eps: float=1e-10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compresses A and b by eliminating redundant rows.\\n\\n    Identifies rows that are multiples of another row.\\n    Reduces A and b to C = PA, d = Pb, where P has one\\n    nonzero per row.\\n\\n    Parameters\\n    ----------\\n    A : SciPy CSR matrix\\n        The constraints matrix to compress.\\n    b : NumPy 1D array\\n        The vector associated with the constraints matrix.\\n    equil_eps : float, optional\\n        Standard for considering two numbers equivalent.\\n\\n    Returns\\n    -------\\n    tuple\\n        The tuple (A, b, P) where A and b are compressed according to P.\\n    '\n    P_V = []\n    P_I = []\n    P_J = []\n    row_to_keep = []\n    sparsity_to_row = {}\n    prev_ptr = A.indptr[0]\n    for row_num in range(A.shape[0]):\n        keep_row = True\n        ptr = A.indptr[row_num + 1]\n        pattern = tuple(A.indices[prev_ptr:ptr])\n        nnz = ptr - prev_ptr\n        if nnz == 0 or np.linalg.norm(A.data[prev_ptr:ptr]) < equil_eps:\n            keep_row = False\n            P_V.append(0.0)\n            P_I.append(row_num)\n            P_J.append(0)\n        elif pattern in sparsity_to_row and nnz == get_row_nnz(A, sparsity_to_row[pattern][0]):\n            row_matches = sparsity_to_row[pattern]\n            for row_match in row_matches:\n                cur_vals = A.data[prev_ptr:ptr]\n                prev_match_ptr = A.indptr[row_match]\n                match_ptr = A.indptr[row_match + 1]\n                match_vals = A.data[prev_match_ptr:match_ptr]\n                ratio = cur_vals / match_vals\n                if np.ptp(ratio) < equil_eps and abs(ratio[0] - b[row_num] / b[row_match]) < equil_eps:\n                    keep_row = False\n                    P_V.append(ratio[0])\n                    P_I.append(row_num)\n                    P_J.append(row_match)\n            if keep_row:\n                sparsity_to_row[pattern].append(row_num)\n        else:\n            sparsity_to_row[pattern] = [row_num]\n        if keep_row:\n            row_to_keep.append(row_num)\n            P_V.append(1.0)\n            P_I.append(row_num)\n            P_J.append(len(row_to_keep) - 1)\n    cols = max(len(row_to_keep), 1)\n    P = sp.coo_matrix((P_V, (P_I, P_J)), (A.shape[0], cols))\n    A_compr = A[row_to_keep, :]\n    b_compr = b[row_to_keep]\n    return (A_compr, b_compr, P)",
            "def compress_matrix(A, b, equil_eps: float=1e-10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compresses A and b by eliminating redundant rows.\\n\\n    Identifies rows that are multiples of another row.\\n    Reduces A and b to C = PA, d = Pb, where P has one\\n    nonzero per row.\\n\\n    Parameters\\n    ----------\\n    A : SciPy CSR matrix\\n        The constraints matrix to compress.\\n    b : NumPy 1D array\\n        The vector associated with the constraints matrix.\\n    equil_eps : float, optional\\n        Standard for considering two numbers equivalent.\\n\\n    Returns\\n    -------\\n    tuple\\n        The tuple (A, b, P) where A and b are compressed according to P.\\n    '\n    P_V = []\n    P_I = []\n    P_J = []\n    row_to_keep = []\n    sparsity_to_row = {}\n    prev_ptr = A.indptr[0]\n    for row_num in range(A.shape[0]):\n        keep_row = True\n        ptr = A.indptr[row_num + 1]\n        pattern = tuple(A.indices[prev_ptr:ptr])\n        nnz = ptr - prev_ptr\n        if nnz == 0 or np.linalg.norm(A.data[prev_ptr:ptr]) < equil_eps:\n            keep_row = False\n            P_V.append(0.0)\n            P_I.append(row_num)\n            P_J.append(0)\n        elif pattern in sparsity_to_row and nnz == get_row_nnz(A, sparsity_to_row[pattern][0]):\n            row_matches = sparsity_to_row[pattern]\n            for row_match in row_matches:\n                cur_vals = A.data[prev_ptr:ptr]\n                prev_match_ptr = A.indptr[row_match]\n                match_ptr = A.indptr[row_match + 1]\n                match_vals = A.data[prev_match_ptr:match_ptr]\n                ratio = cur_vals / match_vals\n                if np.ptp(ratio) < equil_eps and abs(ratio[0] - b[row_num] / b[row_match]) < equil_eps:\n                    keep_row = False\n                    P_V.append(ratio[0])\n                    P_I.append(row_num)\n                    P_J.append(row_match)\n            if keep_row:\n                sparsity_to_row[pattern].append(row_num)\n        else:\n            sparsity_to_row[pattern] = [row_num]\n        if keep_row:\n            row_to_keep.append(row_num)\n            P_V.append(1.0)\n            P_I.append(row_num)\n            P_J.append(len(row_to_keep) - 1)\n    cols = max(len(row_to_keep), 1)\n    P = sp.coo_matrix((P_V, (P_I, P_J)), (A.shape[0], cols))\n    A_compr = A[row_to_keep, :]\n    b_compr = b[row_to_keep]\n    return (A_compr, b_compr, P)"
        ]
    }
]