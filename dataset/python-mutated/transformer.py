import re
import sympy
from sympy.external import import_module
from sympy.parsing.latex.errors import LaTeXParsingError
lark = import_module('lark')
if lark:
    from lark import Transformer, Token
else:

    class Transformer:

        def transform(self, *args):
            if False:
                return 10
            pass

    class Token:
        pass

class TransformToSymPyExpr(Transformer):
    """Returns a SymPy expression that is generated by traversing the ``lark.Tree``
    passed to the ``.transform()`` function.

    Notes
    =====

    **This class is never supposed to be used directly.**

    In order to tweak the behavior of this class, it has to be subclassed and then after
    the required modifications are made, the name of the new class should be passed to
    the :py:class:`LarkLaTeXParser` class by using the ``transformer`` argument in the
    constructor.

    Parameters
    ==========

    visit_tokens : bool, optional
        For information about what this option does, see `here
        <https://lark-parser.readthedocs.io/en/latest/visitors.html#lark.visitors.Transformer>`_.

        Note that the option must be set to ``True`` for the default parser to work.
    """
    SYMBOL = sympy.Symbol
    DIGIT = sympy.core.numbers.Integer

    def CMD_INFTY(self, tokens):
        if False:
            i = 10
            return i + 15
        return sympy.oo

    def GREEK_SYMBOL(self, tokens):
        if False:
            print('Hello World!')
        variable_name = re.sub('var', '', tokens[1:])
        return sympy.Symbol(variable_name)

    def BASIC_SUBSCRIPTED_SYMBOL(self, tokens):
        if False:
            i = 10
            return i + 15
        (symbol, sub) = tokens.value.split('_')
        if sub.startswith('{'):
            return sympy.Symbol('%s_{%s}' % (symbol, sub[1:-1]))
        else:
            return sympy.Symbol('%s_{%s}' % (symbol, sub))

    def GREEK_SUBSCRIPTED_SYMBOL(self, tokens):
        if False:
            return 10
        (greek_letter, sub) = tokens.value.split('_')
        greek_letter = re.sub('var', '', greek_letter[1:])
        if sub.startswith('{'):
            return sympy.Symbol('%s_{%s}' % (greek_letter, sub[1:-1]))
        else:
            return sympy.Symbol('%s_{%s}' % (greek_letter, sub))

    def SYMBOL_WITH_GREEK_SUBSCRIPT(self, tokens):
        if False:
            for i in range(10):
                print('nop')
        (symbol, sub) = tokens.value.split('_')
        if sub.startswith('{'):
            greek_letter = sub[2:-1]
            greek_letter = re.sub('var', '', greek_letter)
            return sympy.Symbol('%s_{%s}' % (symbol, greek_letter))
        else:
            greek_letter = sub[1:]
            greek_letter = re.sub('var', '', greek_letter)
            return sympy.Symbol('%s_{%s}' % (symbol, greek_letter))

    def multi_letter_symbol(self, tokens):
        if False:
            i = 10
            return i + 15
        return sympy.Symbol(tokens[2])

    def number(self, tokens):
        if False:
            return 10
        if '.' in tokens[0]:
            return sympy.core.numbers.Float(tokens[0])
        else:
            return sympy.core.numbers.Integer(tokens[0])

    def latex_string(self, tokens):
        if False:
            print('Hello World!')
        return tokens[0]

    def group_round_parentheses(self, tokens):
        if False:
            i = 10
            return i + 15
        return tokens[1]

    def group_square_brackets(self, tokens):
        if False:
            i = 10
            return i + 15
        return tokens[1]

    def group_curly_parentheses(self, tokens):
        if False:
            while True:
                i = 10
        return tokens[1]

    def eq(self, tokens):
        if False:
            while True:
                i = 10
        return sympy.Eq(tokens[0], tokens[2])

    def ne(self, tokens):
        if False:
            print('Hello World!')
        return sympy.Ne(tokens[0], tokens[2])

    def lt(self, tokens):
        if False:
            print('Hello World!')
        return sympy.Lt(tokens[0], tokens[2])

    def lte(self, tokens):
        if False:
            while True:
                i = 10
        return sympy.Le(tokens[0], tokens[2])

    def gt(self, tokens):
        if False:
            print('Hello World!')
        return sympy.Gt(tokens[0], tokens[2])

    def gte(self, tokens):
        if False:
            while True:
                i = 10
        return sympy.Ge(tokens[0], tokens[2])

    def add(self, tokens):
        if False:
            return 10
        return sympy.Add(tokens[0], tokens[2])

    def sub(self, tokens):
        if False:
            while True:
                i = 10
        if len(tokens) == 2:
            return -tokens[1]
        elif len(tokens) == 3:
            return sympy.Add(tokens[0], -tokens[2])

    def mul(self, tokens):
        if False:
            print('Hello World!')
        return sympy.Mul(tokens[0], tokens[2])

    def div(self, tokens):
        if False:
            while True:
                i = 10
        return sympy.Mul(tokens[0], sympy.Pow(tokens[2], -1))

    def adjacent_expressions(self, tokens):
        if False:
            return 10
        from sympy.physics.quantum import Bra, Ket
        if isinstance(tokens[0], Ket) and isinstance(tokens[1], Bra):
            from sympy.physics.quantum import OuterProduct
            return OuterProduct(tokens[0], tokens[1])
        elif tokens[0] == sympy.Symbol('d'):
            return (tokens[0], tokens[1])
        elif isinstance(tokens[0], tuple):
            return sympy.Derivative(tokens[1], tokens[0][1])
        else:
            return sympy.Mul(tokens[0], tokens[1])

    def superscript(self, tokens):
        if False:
            while True:
                i = 10
        return sympy.Pow(tokens[0], tokens[2])

    def fraction(self, tokens):
        if False:
            i = 10
            return i + 15
        numerator = tokens[1]
        if isinstance(tokens[2], tuple):
            (_, variable) = tokens[2]
            return ('derivative', variable)
        else:
            denominator = tokens[2]
            return sympy.Mul(numerator, sympy.Pow(denominator, -1))

    def binomial(self, tokens):
        if False:
            while True:
                i = 10
        return sympy.binomial(tokens[1], tokens[2])

    def normal_integral(self, tokens):
        if False:
            for i in range(10):
                print('nop')
        underscore_index = None
        caret_index = None
        if '_' in tokens:
            underscore_index = tokens.index('_')
        if '^' in tokens:
            caret_index = tokens.index('^')
        lower_bound = tokens[underscore_index + 1] if underscore_index else None
        upper_bound = tokens[caret_index + 1] if caret_index else None
        differential_symbol = self._extract_differential_symbol(tokens)
        if differential_symbol is None:
            raise LaTeXParsingError('Differential symbol was not found in the expression.Valid differential symbols are "d", "\\text{d}, and "\\mathrm{d}".')
        differential_variable_index = tokens.index(differential_symbol) + 1
        differential_variable = tokens[differential_variable_index]
        if lower_bound is not None and upper_bound is None:
            raise LaTeXParsingError('Lower bound for the integral was found, but upper bound was not found.')
        if upper_bound is not None and lower_bound is None:
            raise LaTeXParsingError('Upper bound for the integral was found, but lower bound was not found.')
        if underscore_index is not None and underscore_index == differential_variable_index - 3:
            integrand = 1
        elif caret_index is not None and caret_index == differential_variable_index - 3:
            integrand = 1
        elif differential_variable_index == 2:
            integrand = 1
        else:
            integrand = tokens[differential_variable_index - 2]
        if lower_bound is not None:
            return sympy.Integral(integrand, (differential_variable, lower_bound, upper_bound))
        else:
            return sympy.Integral(integrand, differential_variable)

    def group_curly_parentheses_int(self, tokens):
        if False:
            i = 10
            return i + 15
        if len(tokens) == 3:
            return (1, tokens[1])
        elif len(tokens) == 4:
            return (tokens[1], tokens[2])

    def special_fraction(self, tokens):
        if False:
            while True:
                i = 10
        (numerator, variable) = tokens[1]
        denominator = tokens[2]
        return (sympy.Mul(numerator, sympy.Pow(denominator, -1)), variable)

    def integral_with_special_fraction(self, tokens):
        if False:
            for i in range(10):
                print('nop')
        underscore_index = None
        caret_index = None
        if '_' in tokens:
            underscore_index = tokens.index('_')
        if '^' in tokens:
            caret_index = tokens.index('^')
        lower_bound = tokens[underscore_index + 1] if underscore_index else None
        upper_bound = tokens[caret_index + 1] if caret_index else None
        if lower_bound is not None and upper_bound is None:
            raise LaTeXParsingError('Lower bound for the integral was found, but upper bound was not found.')
        if upper_bound is not None and lower_bound is None:
            raise LaTeXParsingError('Upper bound for the integral was found, but lower bound was not found.')
        (integrand, differential_variable) = tokens[-1]
        if lower_bound is not None:
            return sympy.Integral(integrand, (differential_variable, lower_bound, upper_bound))
        else:
            return sympy.Integral(integrand, differential_variable)

    def group_curly_parentheses_special(self, tokens):
        if False:
            while True:
                i = 10
        underscore_index = tokens.index('_')
        caret_index = tokens.index('^')
        left_brace_index = tokens.index('{', underscore_index)
        right_brace_index = tokens.index('}', underscore_index)
        bottom_limit = tokens[left_brace_index + 1:right_brace_index]
        top_limit = tokens[caret_index + 1:]
        index_variable = bottom_limit[0]
        lower_limit = bottom_limit[-1]
        upper_limit = top_limit[0]
        return (index_variable, lower_limit, upper_limit)

    def summation(self, tokens):
        if False:
            i = 10
            return i + 15
        return sympy.Sum(tokens[2], tokens[1])

    def product(self, tokens):
        if False:
            i = 10
            return i + 15
        return sympy.Product(tokens[2], tokens[1])

    def limit_dir_expr(self, tokens):
        if False:
            while True:
                i = 10
        caret_index = tokens.index('^')
        if '{' in tokens:
            left_curly_brace_index = tokens.index('{', caret_index)
            direction = tokens[left_curly_brace_index + 1]
        else:
            direction = tokens[caret_index + 1]
        if direction == '+':
            return (tokens[0], '+')
        elif direction == '-':
            return (tokens[0], '-')
        else:
            return (tokens[0], '+-')

    def group_curly_parentheses_lim(self, tokens):
        if False:
            while True:
                i = 10
        limit_variable = tokens[1]
        if isinstance(tokens[3], tuple):
            (destination, direction) = tokens[3]
        else:
            destination = tokens[3]
            direction = '+-'
        return (limit_variable, destination, direction)

    def limit(self, tokens):
        if False:
            for i in range(10):
                print('nop')
        (limit_variable, destination, direction) = tokens[2]
        return sympy.Limit(tokens[-1], limit_variable, destination, direction)

    def differential(self, tokens):
        if False:
            while True:
                i = 10
        return tokens[1]

    def derivative(self, tokens):
        if False:
            return 10
        return sympy.Derivative(tokens[-1], tokens[5])

    def list_of_expressions(self, tokens):
        if False:
            for i in range(10):
                print('nop')
        if len(tokens) == 1:
            return tokens
        else:

            def remove_tokens(args):
                if False:
                    i = 10
                    return i + 15
                if isinstance(args, Token):
                    if args.type != 'COMMA':
                        raise LaTeXParsingError('A comma token was expected, but some other token was encountered.')
                    return False
                return True
            return filter(remove_tokens, tokens)

    def function_applied(self, tokens):
        if False:
            for i in range(10):
                print('nop')
        return sympy.Function(tokens[0])(*tokens[2])

    def min(self, tokens):
        if False:
            for i in range(10):
                print('nop')
        return sympy.Min(*tokens[2])

    def max(self, tokens):
        if False:
            while True:
                i = 10
        return sympy.Max(*tokens[2])

    def bra(self, tokens):
        if False:
            return 10
        from sympy.physics.quantum import Bra
        return Bra(tokens[1])

    def ket(self, tokens):
        if False:
            while True:
                i = 10
        from sympy.physics.quantum import Ket
        return Ket(tokens[1])

    def inner_product(self, tokens):
        if False:
            return 10
        from sympy.physics.quantum import Bra, Ket, InnerProduct
        return InnerProduct(Bra(tokens[1]), Ket(tokens[3]))

    def sin(self, tokens):
        if False:
            return 10
        return sympy.sin(tokens[1])

    def cos(self, tokens):
        if False:
            i = 10
            return i + 15
        return sympy.cos(tokens[1])

    def tan(self, tokens):
        if False:
            for i in range(10):
                print('nop')
        return sympy.tan(tokens[1])

    def csc(self, tokens):
        if False:
            for i in range(10):
                print('nop')
        return sympy.csc(tokens[1])

    def sec(self, tokens):
        if False:
            return 10
        return sympy.sec(tokens[1])

    def cot(self, tokens):
        if False:
            while True:
                i = 10
        return sympy.cot(tokens[1])

    def sin_power(self, tokens):
        if False:
            print('Hello World!')
        exponent = tokens[2]
        if exponent == -1:
            return sympy.asin(tokens[-1])
        else:
            return sympy.Pow(sympy.sin(tokens[-1]), exponent)

    def cos_power(self, tokens):
        if False:
            while True:
                i = 10
        exponent = tokens[2]
        if exponent == -1:
            return sympy.acos(tokens[-1])
        else:
            return sympy.Pow(sympy.cos(tokens[-1]), exponent)

    def tan_power(self, tokens):
        if False:
            i = 10
            return i + 15
        exponent = tokens[2]
        if exponent == -1:
            return sympy.atan(tokens[-1])
        else:
            return sympy.Pow(sympy.tan(tokens[-1]), exponent)

    def csc_power(self, tokens):
        if False:
            i = 10
            return i + 15
        exponent = tokens[2]
        if exponent == -1:
            return sympy.acsc(tokens[-1])
        else:
            return sympy.Pow(sympy.csc(tokens[-1]), exponent)

    def sec_power(self, tokens):
        if False:
            return 10
        exponent = tokens[2]
        if exponent == -1:
            return sympy.asec(tokens[-1])
        else:
            return sympy.Pow(sympy.sec(tokens[-1]), exponent)

    def cot_power(self, tokens):
        if False:
            i = 10
            return i + 15
        exponent = tokens[2]
        if exponent == -1:
            return sympy.acot(tokens[-1])
        else:
            return sympy.Pow(sympy.cot(tokens[-1]), exponent)

    def arcsin(self, tokens):
        if False:
            while True:
                i = 10
        return sympy.asin(tokens[1])

    def arccos(self, tokens):
        if False:
            i = 10
            return i + 15
        return sympy.acos(tokens[1])

    def arctan(self, tokens):
        if False:
            print('Hello World!')
        return sympy.atan(tokens[1])

    def arccsc(self, tokens):
        if False:
            i = 10
            return i + 15
        return sympy.acsc(tokens[1])

    def arcsec(self, tokens):
        if False:
            while True:
                i = 10
        return sympy.asec(tokens[1])

    def arccot(self, tokens):
        if False:
            print('Hello World!')
        return sympy.acot(tokens[1])

    def sinh(self, tokens):
        if False:
            i = 10
            return i + 15
        return sympy.sinh(tokens[1])

    def cosh(self, tokens):
        if False:
            i = 10
            return i + 15
        return sympy.cosh(tokens[1])

    def tanh(self, tokens):
        if False:
            return 10
        return sympy.tanh(tokens[1])

    def asinh(self, tokens):
        if False:
            return 10
        return sympy.asinh(tokens[1])

    def acosh(self, tokens):
        if False:
            i = 10
            return i + 15
        return sympy.acosh(tokens[1])

    def atanh(self, tokens):
        if False:
            print('Hello World!')
        return sympy.atanh(tokens[1])

    def abs(self, tokens):
        if False:
            for i in range(10):
                print('nop')
        return sympy.Abs(tokens[1])

    def floor(self, tokens):
        if False:
            for i in range(10):
                print('nop')
        return sympy.floor(tokens[1])

    def ceil(self, tokens):
        if False:
            while True:
                i = 10
        return sympy.ceiling(tokens[1])

    def factorial(self, tokens):
        if False:
            while True:
                i = 10
        return sympy.factorial(tokens[0])

    def conjugate(self, tokens):
        if False:
            print('Hello World!')
        return sympy.conjugate(tokens[1])

    def square_root(self, tokens):
        if False:
            print('Hello World!')
        if len(tokens) == 2:
            return sympy.sqrt(tokens[1])
        elif len(tokens) == 3:
            return sympy.root(tokens[2], tokens[1])

    def exponential(self, tokens):
        if False:
            while True:
                i = 10
        return sympy.exp(tokens[1])

    def log(self, tokens):
        if False:
            return 10
        if tokens[0].type == 'FUNC_LG':
            return sympy.log(tokens[1], 10)
        elif tokens[0].type == 'FUNC_LN':
            return sympy.log(tokens[1])
        elif tokens[0].type == 'FUNC_LOG':
            if '_' in tokens:
                return sympy.log(tokens[3], tokens[2])
            else:
                return sympy.log(tokens[1])

    def _extract_differential_symbol(self, s: str):
        if False:
            for i in range(10):
                print('nop')
        differential_symbols = {'d', '\\text{d}', '\\mathrm{d}'}
        differential_symbol = next((symbol for symbol in differential_symbols if symbol in s), None)
        return differential_symbol