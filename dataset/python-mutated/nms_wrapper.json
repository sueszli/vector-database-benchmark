[
    {
        "func_name": "nms",
        "original": "def nms(dets, thresh, use_gpu_nms=True, device_id=0):\n    \"\"\"\n    Dispatches the call to either CPU or GPU NMS implementations\n    \"\"\"\n    if dets.shape[0] == 0:\n        return []\n    if gpu_nms_available and use_gpu_nms:\n        return gpu_nms(dets, thresh, device_id=device_id)\n    else:\n        return cpu_nms(dets, thresh)",
        "mutated": [
            "def nms(dets, thresh, use_gpu_nms=True, device_id=0):\n    if False:\n        i = 10\n    '\\n    Dispatches the call to either CPU or GPU NMS implementations\\n    '\n    if dets.shape[0] == 0:\n        return []\n    if gpu_nms_available and use_gpu_nms:\n        return gpu_nms(dets, thresh, device_id=device_id)\n    else:\n        return cpu_nms(dets, thresh)",
            "def nms(dets, thresh, use_gpu_nms=True, device_id=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Dispatches the call to either CPU or GPU NMS implementations\\n    '\n    if dets.shape[0] == 0:\n        return []\n    if gpu_nms_available and use_gpu_nms:\n        return gpu_nms(dets, thresh, device_id=device_id)\n    else:\n        return cpu_nms(dets, thresh)",
            "def nms(dets, thresh, use_gpu_nms=True, device_id=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Dispatches the call to either CPU or GPU NMS implementations\\n    '\n    if dets.shape[0] == 0:\n        return []\n    if gpu_nms_available and use_gpu_nms:\n        return gpu_nms(dets, thresh, device_id=device_id)\n    else:\n        return cpu_nms(dets, thresh)",
            "def nms(dets, thresh, use_gpu_nms=True, device_id=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Dispatches the call to either CPU or GPU NMS implementations\\n    '\n    if dets.shape[0] == 0:\n        return []\n    if gpu_nms_available and use_gpu_nms:\n        return gpu_nms(dets, thresh, device_id=device_id)\n    else:\n        return cpu_nms(dets, thresh)",
            "def nms(dets, thresh, use_gpu_nms=True, device_id=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Dispatches the call to either CPU or GPU NMS implementations\\n    '\n    if dets.shape[0] == 0:\n        return []\n    if gpu_nms_available and use_gpu_nms:\n        return gpu_nms(dets, thresh, device_id=device_id)\n    else:\n        return cpu_nms(dets, thresh)"
        ]
    },
    {
        "func_name": "apply_nms_to_single_image_results",
        "original": "def apply_nms_to_single_image_results(coords, labels, scores, use_gpu_nms, device_id, nms_threshold=0.5, conf_threshold=0.0):\n    \"\"\"\n    Applies nms to the results for a single image.\n\n    Args:\n        coords:             (x_min, y_min, x_max, y_max) coordinates for n rois. shape = (n, 4)\n        labels:             the predicted label per roi. shape = (n, 1)\n        scores:             the predicted score per roi. shape = (n, 1)\n        nms_threshold:      the threshold for discarding overlapping ROIs in nms\n        conf_threshold:     a minimum value for the score of an ROI. ROIs with lower score will be discarded\n\n    Returns:\n        nmsKeepIndices - the indices of the ROIs to keep after nms\n    \"\"\"\n    allIndices = []\n    nmsRects = [[[]] for _ in range(max(labels) + 1)]\n    coordsWithScores = np.hstack((coords, np.array([scores]).T))\n    for i in range(max(labels) + 1):\n        indices = np.where(np.array(labels) == i)[0]\n        nmsRects[i][0] = coordsWithScores[indices, :]\n        allIndices.append(indices)\n    (_, nmsKeepIndicesList) = apply_nms_to_test_set_results(nmsRects, nms_threshold, conf_threshold, use_gpu_nms, device_id)\n    nmsKeepIndices = []\n    for i in range(max(labels) + 1):\n        for keepIndex in nmsKeepIndicesList[i][0]:\n            nmsKeepIndices.append(allIndices[i][keepIndex])\n    assert len(nmsKeepIndices) == len(set(nmsKeepIndices))\n    return nmsKeepIndices",
        "mutated": [
            "def apply_nms_to_single_image_results(coords, labels, scores, use_gpu_nms, device_id, nms_threshold=0.5, conf_threshold=0.0):\n    if False:\n        i = 10\n    '\\n    Applies nms to the results for a single image.\\n\\n    Args:\\n        coords:             (x_min, y_min, x_max, y_max) coordinates for n rois. shape = (n, 4)\\n        labels:             the predicted label per roi. shape = (n, 1)\\n        scores:             the predicted score per roi. shape = (n, 1)\\n        nms_threshold:      the threshold for discarding overlapping ROIs in nms\\n        conf_threshold:     a minimum value for the score of an ROI. ROIs with lower score will be discarded\\n\\n    Returns:\\n        nmsKeepIndices - the indices of the ROIs to keep after nms\\n    '\n    allIndices = []\n    nmsRects = [[[]] for _ in range(max(labels) + 1)]\n    coordsWithScores = np.hstack((coords, np.array([scores]).T))\n    for i in range(max(labels) + 1):\n        indices = np.where(np.array(labels) == i)[0]\n        nmsRects[i][0] = coordsWithScores[indices, :]\n        allIndices.append(indices)\n    (_, nmsKeepIndicesList) = apply_nms_to_test_set_results(nmsRects, nms_threshold, conf_threshold, use_gpu_nms, device_id)\n    nmsKeepIndices = []\n    for i in range(max(labels) + 1):\n        for keepIndex in nmsKeepIndicesList[i][0]:\n            nmsKeepIndices.append(allIndices[i][keepIndex])\n    assert len(nmsKeepIndices) == len(set(nmsKeepIndices))\n    return nmsKeepIndices",
            "def apply_nms_to_single_image_results(coords, labels, scores, use_gpu_nms, device_id, nms_threshold=0.5, conf_threshold=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Applies nms to the results for a single image.\\n\\n    Args:\\n        coords:             (x_min, y_min, x_max, y_max) coordinates for n rois. shape = (n, 4)\\n        labels:             the predicted label per roi. shape = (n, 1)\\n        scores:             the predicted score per roi. shape = (n, 1)\\n        nms_threshold:      the threshold for discarding overlapping ROIs in nms\\n        conf_threshold:     a minimum value for the score of an ROI. ROIs with lower score will be discarded\\n\\n    Returns:\\n        nmsKeepIndices - the indices of the ROIs to keep after nms\\n    '\n    allIndices = []\n    nmsRects = [[[]] for _ in range(max(labels) + 1)]\n    coordsWithScores = np.hstack((coords, np.array([scores]).T))\n    for i in range(max(labels) + 1):\n        indices = np.where(np.array(labels) == i)[0]\n        nmsRects[i][0] = coordsWithScores[indices, :]\n        allIndices.append(indices)\n    (_, nmsKeepIndicesList) = apply_nms_to_test_set_results(nmsRects, nms_threshold, conf_threshold, use_gpu_nms, device_id)\n    nmsKeepIndices = []\n    for i in range(max(labels) + 1):\n        for keepIndex in nmsKeepIndicesList[i][0]:\n            nmsKeepIndices.append(allIndices[i][keepIndex])\n    assert len(nmsKeepIndices) == len(set(nmsKeepIndices))\n    return nmsKeepIndices",
            "def apply_nms_to_single_image_results(coords, labels, scores, use_gpu_nms, device_id, nms_threshold=0.5, conf_threshold=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Applies nms to the results for a single image.\\n\\n    Args:\\n        coords:             (x_min, y_min, x_max, y_max) coordinates for n rois. shape = (n, 4)\\n        labels:             the predicted label per roi. shape = (n, 1)\\n        scores:             the predicted score per roi. shape = (n, 1)\\n        nms_threshold:      the threshold for discarding overlapping ROIs in nms\\n        conf_threshold:     a minimum value for the score of an ROI. ROIs with lower score will be discarded\\n\\n    Returns:\\n        nmsKeepIndices - the indices of the ROIs to keep after nms\\n    '\n    allIndices = []\n    nmsRects = [[[]] for _ in range(max(labels) + 1)]\n    coordsWithScores = np.hstack((coords, np.array([scores]).T))\n    for i in range(max(labels) + 1):\n        indices = np.where(np.array(labels) == i)[0]\n        nmsRects[i][0] = coordsWithScores[indices, :]\n        allIndices.append(indices)\n    (_, nmsKeepIndicesList) = apply_nms_to_test_set_results(nmsRects, nms_threshold, conf_threshold, use_gpu_nms, device_id)\n    nmsKeepIndices = []\n    for i in range(max(labels) + 1):\n        for keepIndex in nmsKeepIndicesList[i][0]:\n            nmsKeepIndices.append(allIndices[i][keepIndex])\n    assert len(nmsKeepIndices) == len(set(nmsKeepIndices))\n    return nmsKeepIndices",
            "def apply_nms_to_single_image_results(coords, labels, scores, use_gpu_nms, device_id, nms_threshold=0.5, conf_threshold=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Applies nms to the results for a single image.\\n\\n    Args:\\n        coords:             (x_min, y_min, x_max, y_max) coordinates for n rois. shape = (n, 4)\\n        labels:             the predicted label per roi. shape = (n, 1)\\n        scores:             the predicted score per roi. shape = (n, 1)\\n        nms_threshold:      the threshold for discarding overlapping ROIs in nms\\n        conf_threshold:     a minimum value for the score of an ROI. ROIs with lower score will be discarded\\n\\n    Returns:\\n        nmsKeepIndices - the indices of the ROIs to keep after nms\\n    '\n    allIndices = []\n    nmsRects = [[[]] for _ in range(max(labels) + 1)]\n    coordsWithScores = np.hstack((coords, np.array([scores]).T))\n    for i in range(max(labels) + 1):\n        indices = np.where(np.array(labels) == i)[0]\n        nmsRects[i][0] = coordsWithScores[indices, :]\n        allIndices.append(indices)\n    (_, nmsKeepIndicesList) = apply_nms_to_test_set_results(nmsRects, nms_threshold, conf_threshold, use_gpu_nms, device_id)\n    nmsKeepIndices = []\n    for i in range(max(labels) + 1):\n        for keepIndex in nmsKeepIndicesList[i][0]:\n            nmsKeepIndices.append(allIndices[i][keepIndex])\n    assert len(nmsKeepIndices) == len(set(nmsKeepIndices))\n    return nmsKeepIndices",
            "def apply_nms_to_single_image_results(coords, labels, scores, use_gpu_nms, device_id, nms_threshold=0.5, conf_threshold=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Applies nms to the results for a single image.\\n\\n    Args:\\n        coords:             (x_min, y_min, x_max, y_max) coordinates for n rois. shape = (n, 4)\\n        labels:             the predicted label per roi. shape = (n, 1)\\n        scores:             the predicted score per roi. shape = (n, 1)\\n        nms_threshold:      the threshold for discarding overlapping ROIs in nms\\n        conf_threshold:     a minimum value for the score of an ROI. ROIs with lower score will be discarded\\n\\n    Returns:\\n        nmsKeepIndices - the indices of the ROIs to keep after nms\\n    '\n    allIndices = []\n    nmsRects = [[[]] for _ in range(max(labels) + 1)]\n    coordsWithScores = np.hstack((coords, np.array([scores]).T))\n    for i in range(max(labels) + 1):\n        indices = np.where(np.array(labels) == i)[0]\n        nmsRects[i][0] = coordsWithScores[indices, :]\n        allIndices.append(indices)\n    (_, nmsKeepIndicesList) = apply_nms_to_test_set_results(nmsRects, nms_threshold, conf_threshold, use_gpu_nms, device_id)\n    nmsKeepIndices = []\n    for i in range(max(labels) + 1):\n        for keepIndex in nmsKeepIndicesList[i][0]:\n            nmsKeepIndices.append(allIndices[i][keepIndex])\n    assert len(nmsKeepIndices) == len(set(nmsKeepIndices))\n    return nmsKeepIndices"
        ]
    },
    {
        "func_name": "apply_nms_to_test_set_results",
        "original": "def apply_nms_to_test_set_results(all_boxes, nms_threshold, conf_threshold, use_gpu_nms, device_id):\n    \"\"\"\n    Applies nms to the results of multiple images.\n\n    Args:\n        all_boxes:      shape of all_boxes: e.g. 21 classes x 4952 images x 58 rois x 5 coords+score\n        nms_threshold:  the threshold for discarding overlapping ROIs in nms\n        conf_threshold: a minimum value for the score of an ROI. ROIs with lower score will be discarded\n\n    Returns:\n        nms_boxes - the reduced set of rois after nms\n        nmsKeepIndices - the indices of the ROIs to keep after nms\n    \"\"\"\n    num_classes = len(all_boxes)\n    num_images = len(all_boxes[0])\n    nms_boxes = [[[] for _ in range(num_images)] for _ in range(num_classes)]\n    nms_keepIndices = [[[] for _ in range(num_images)] for _ in range(num_classes)]\n    for cls_ind in range(num_classes):\n        for im_ind in range(num_images):\n            dets = all_boxes[cls_ind][im_ind]\n            if len(dets) == 0:\n                continue\n            if len(dets) == 1:\n                keep = [0]\n            else:\n                keep = nms(dets.astype(np.float32), nms_threshold, use_gpu_nms, device_id)\n            if conf_threshold > 0:\n                keep_conf_idx = np.where(dets[:, -1] > conf_threshold)\n                keep = list(set(keep_conf_idx[0]).intersection(keep))\n            if len(keep) == 0:\n                continue\n            nms_boxes[cls_ind][im_ind] = dets[keep, :].copy()\n            nms_keepIndices[cls_ind][im_ind] = keep\n    return (nms_boxes, nms_keepIndices)",
        "mutated": [
            "def apply_nms_to_test_set_results(all_boxes, nms_threshold, conf_threshold, use_gpu_nms, device_id):\n    if False:\n        i = 10\n    '\\n    Applies nms to the results of multiple images.\\n\\n    Args:\\n        all_boxes:      shape of all_boxes: e.g. 21 classes x 4952 images x 58 rois x 5 coords+score\\n        nms_threshold:  the threshold for discarding overlapping ROIs in nms\\n        conf_threshold: a minimum value for the score of an ROI. ROIs with lower score will be discarded\\n\\n    Returns:\\n        nms_boxes - the reduced set of rois after nms\\n        nmsKeepIndices - the indices of the ROIs to keep after nms\\n    '\n    num_classes = len(all_boxes)\n    num_images = len(all_boxes[0])\n    nms_boxes = [[[] for _ in range(num_images)] for _ in range(num_classes)]\n    nms_keepIndices = [[[] for _ in range(num_images)] for _ in range(num_classes)]\n    for cls_ind in range(num_classes):\n        for im_ind in range(num_images):\n            dets = all_boxes[cls_ind][im_ind]\n            if len(dets) == 0:\n                continue\n            if len(dets) == 1:\n                keep = [0]\n            else:\n                keep = nms(dets.astype(np.float32), nms_threshold, use_gpu_nms, device_id)\n            if conf_threshold > 0:\n                keep_conf_idx = np.where(dets[:, -1] > conf_threshold)\n                keep = list(set(keep_conf_idx[0]).intersection(keep))\n            if len(keep) == 0:\n                continue\n            nms_boxes[cls_ind][im_ind] = dets[keep, :].copy()\n            nms_keepIndices[cls_ind][im_ind] = keep\n    return (nms_boxes, nms_keepIndices)",
            "def apply_nms_to_test_set_results(all_boxes, nms_threshold, conf_threshold, use_gpu_nms, device_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Applies nms to the results of multiple images.\\n\\n    Args:\\n        all_boxes:      shape of all_boxes: e.g. 21 classes x 4952 images x 58 rois x 5 coords+score\\n        nms_threshold:  the threshold for discarding overlapping ROIs in nms\\n        conf_threshold: a minimum value for the score of an ROI. ROIs with lower score will be discarded\\n\\n    Returns:\\n        nms_boxes - the reduced set of rois after nms\\n        nmsKeepIndices - the indices of the ROIs to keep after nms\\n    '\n    num_classes = len(all_boxes)\n    num_images = len(all_boxes[0])\n    nms_boxes = [[[] for _ in range(num_images)] for _ in range(num_classes)]\n    nms_keepIndices = [[[] for _ in range(num_images)] for _ in range(num_classes)]\n    for cls_ind in range(num_classes):\n        for im_ind in range(num_images):\n            dets = all_boxes[cls_ind][im_ind]\n            if len(dets) == 0:\n                continue\n            if len(dets) == 1:\n                keep = [0]\n            else:\n                keep = nms(dets.astype(np.float32), nms_threshold, use_gpu_nms, device_id)\n            if conf_threshold > 0:\n                keep_conf_idx = np.where(dets[:, -1] > conf_threshold)\n                keep = list(set(keep_conf_idx[0]).intersection(keep))\n            if len(keep) == 0:\n                continue\n            nms_boxes[cls_ind][im_ind] = dets[keep, :].copy()\n            nms_keepIndices[cls_ind][im_ind] = keep\n    return (nms_boxes, nms_keepIndices)",
            "def apply_nms_to_test_set_results(all_boxes, nms_threshold, conf_threshold, use_gpu_nms, device_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Applies nms to the results of multiple images.\\n\\n    Args:\\n        all_boxes:      shape of all_boxes: e.g. 21 classes x 4952 images x 58 rois x 5 coords+score\\n        nms_threshold:  the threshold for discarding overlapping ROIs in nms\\n        conf_threshold: a minimum value for the score of an ROI. ROIs with lower score will be discarded\\n\\n    Returns:\\n        nms_boxes - the reduced set of rois after nms\\n        nmsKeepIndices - the indices of the ROIs to keep after nms\\n    '\n    num_classes = len(all_boxes)\n    num_images = len(all_boxes[0])\n    nms_boxes = [[[] for _ in range(num_images)] for _ in range(num_classes)]\n    nms_keepIndices = [[[] for _ in range(num_images)] for _ in range(num_classes)]\n    for cls_ind in range(num_classes):\n        for im_ind in range(num_images):\n            dets = all_boxes[cls_ind][im_ind]\n            if len(dets) == 0:\n                continue\n            if len(dets) == 1:\n                keep = [0]\n            else:\n                keep = nms(dets.astype(np.float32), nms_threshold, use_gpu_nms, device_id)\n            if conf_threshold > 0:\n                keep_conf_idx = np.where(dets[:, -1] > conf_threshold)\n                keep = list(set(keep_conf_idx[0]).intersection(keep))\n            if len(keep) == 0:\n                continue\n            nms_boxes[cls_ind][im_ind] = dets[keep, :].copy()\n            nms_keepIndices[cls_ind][im_ind] = keep\n    return (nms_boxes, nms_keepIndices)",
            "def apply_nms_to_test_set_results(all_boxes, nms_threshold, conf_threshold, use_gpu_nms, device_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Applies nms to the results of multiple images.\\n\\n    Args:\\n        all_boxes:      shape of all_boxes: e.g. 21 classes x 4952 images x 58 rois x 5 coords+score\\n        nms_threshold:  the threshold for discarding overlapping ROIs in nms\\n        conf_threshold: a minimum value for the score of an ROI. ROIs with lower score will be discarded\\n\\n    Returns:\\n        nms_boxes - the reduced set of rois after nms\\n        nmsKeepIndices - the indices of the ROIs to keep after nms\\n    '\n    num_classes = len(all_boxes)\n    num_images = len(all_boxes[0])\n    nms_boxes = [[[] for _ in range(num_images)] for _ in range(num_classes)]\n    nms_keepIndices = [[[] for _ in range(num_images)] for _ in range(num_classes)]\n    for cls_ind in range(num_classes):\n        for im_ind in range(num_images):\n            dets = all_boxes[cls_ind][im_ind]\n            if len(dets) == 0:\n                continue\n            if len(dets) == 1:\n                keep = [0]\n            else:\n                keep = nms(dets.astype(np.float32), nms_threshold, use_gpu_nms, device_id)\n            if conf_threshold > 0:\n                keep_conf_idx = np.where(dets[:, -1] > conf_threshold)\n                keep = list(set(keep_conf_idx[0]).intersection(keep))\n            if len(keep) == 0:\n                continue\n            nms_boxes[cls_ind][im_ind] = dets[keep, :].copy()\n            nms_keepIndices[cls_ind][im_ind] = keep\n    return (nms_boxes, nms_keepIndices)",
            "def apply_nms_to_test_set_results(all_boxes, nms_threshold, conf_threshold, use_gpu_nms, device_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Applies nms to the results of multiple images.\\n\\n    Args:\\n        all_boxes:      shape of all_boxes: e.g. 21 classes x 4952 images x 58 rois x 5 coords+score\\n        nms_threshold:  the threshold for discarding overlapping ROIs in nms\\n        conf_threshold: a minimum value for the score of an ROI. ROIs with lower score will be discarded\\n\\n    Returns:\\n        nms_boxes - the reduced set of rois after nms\\n        nmsKeepIndices - the indices of the ROIs to keep after nms\\n    '\n    num_classes = len(all_boxes)\n    num_images = len(all_boxes[0])\n    nms_boxes = [[[] for _ in range(num_images)] for _ in range(num_classes)]\n    nms_keepIndices = [[[] for _ in range(num_images)] for _ in range(num_classes)]\n    for cls_ind in range(num_classes):\n        for im_ind in range(num_images):\n            dets = all_boxes[cls_ind][im_ind]\n            if len(dets) == 0:\n                continue\n            if len(dets) == 1:\n                keep = [0]\n            else:\n                keep = nms(dets.astype(np.float32), nms_threshold, use_gpu_nms, device_id)\n            if conf_threshold > 0:\n                keep_conf_idx = np.where(dets[:, -1] > conf_threshold)\n                keep = list(set(keep_conf_idx[0]).intersection(keep))\n            if len(keep) == 0:\n                continue\n            nms_boxes[cls_ind][im_ind] = dets[keep, :].copy()\n            nms_keepIndices[cls_ind][im_ind] = keep\n    return (nms_boxes, nms_keepIndices)"
        ]
    }
]