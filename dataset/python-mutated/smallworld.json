[
    {
        "func_name": "random_reference",
        "original": "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef random_reference(G, niter=1, connectivity=True, seed=None):\n    \"\"\"Compute a random graph by swapping edges of a given graph.\n\n    Parameters\n    ----------\n    G : graph\n        An undirected graph with 4 or more nodes.\n\n    niter : integer (optional, default=1)\n        An edge is rewired approximately `niter` times.\n\n    connectivity : boolean (optional, default=True)\n        When True, ensure connectivity for the randomized graph.\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    G : graph\n        The randomized graph.\n\n    Raises\n    ------\n    NetworkXError\n        If there are fewer than 4 nodes or 2 edges in `G`\n\n    Notes\n    -----\n    The implementation is adapted from the algorithm by Maslov and Sneppen\n    (2002) [1]_.\n\n    References\n    ----------\n    .. [1] Maslov, Sergei, and Kim Sneppen.\n           \"Specificity and stability in topology of protein networks.\"\n           Science 296.5569 (2002): 910-913.\n    \"\"\"\n    if len(G) < 4:\n        raise nx.NetworkXError('Graph has fewer than four nodes.')\n    if len(G.edges) < 2:\n        raise nx.NetworkXError('Graph has fewer that 2 edges')\n    from networkx.utils import cumulative_distribution, discrete_sequence\n    local_conn = nx.connectivity.local_edge_connectivity\n    G = G.copy()\n    (keys, degrees) = zip(*G.degree())\n    cdf = cumulative_distribution(degrees)\n    nnodes = len(G)\n    nedges = nx.number_of_edges(G)\n    niter = niter * nedges\n    ntries = int(nnodes * nedges / (nnodes * (nnodes - 1) / 2))\n    swapcount = 0\n    for i in range(niter):\n        n = 0\n        while n < ntries:\n            (ai, ci) = discrete_sequence(2, cdistribution=cdf, seed=seed)\n            if ai == ci:\n                continue\n            a = keys[ai]\n            c = keys[ci]\n            b = seed.choice(list(G.neighbors(a)))\n            d = seed.choice(list(G.neighbors(c)))\n            if b in [a, c, d] or d in [a, b, c]:\n                continue\n            if d not in G[a] and b not in G[c]:\n                G.add_edge(a, d)\n                G.add_edge(c, b)\n                G.remove_edge(a, b)\n                G.remove_edge(c, d)\n                if connectivity and local_conn(G, a, b) == 0:\n                    G.remove_edge(a, d)\n                    G.remove_edge(c, b)\n                    G.add_edge(a, b)\n                    G.add_edge(c, d)\n                else:\n                    swapcount += 1\n                    break\n            n += 1\n    return G",
        "mutated": [
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef random_reference(G, niter=1, connectivity=True, seed=None):\n    if False:\n        i = 10\n    'Compute a random graph by swapping edges of a given graph.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        An undirected graph with 4 or more nodes.\\n\\n    niter : integer (optional, default=1)\\n        An edge is rewired approximately `niter` times.\\n\\n    connectivity : boolean (optional, default=True)\\n        When True, ensure connectivity for the randomized graph.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : graph\\n        The randomized graph.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If there are fewer than 4 nodes or 2 edges in `G`\\n\\n    Notes\\n    -----\\n    The implementation is adapted from the algorithm by Maslov and Sneppen\\n    (2002) [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Maslov, Sergei, and Kim Sneppen.\\n           \"Specificity and stability in topology of protein networks.\"\\n           Science 296.5569 (2002): 910-913.\\n    '\n    if len(G) < 4:\n        raise nx.NetworkXError('Graph has fewer than four nodes.')\n    if len(G.edges) < 2:\n        raise nx.NetworkXError('Graph has fewer that 2 edges')\n    from networkx.utils import cumulative_distribution, discrete_sequence\n    local_conn = nx.connectivity.local_edge_connectivity\n    G = G.copy()\n    (keys, degrees) = zip(*G.degree())\n    cdf = cumulative_distribution(degrees)\n    nnodes = len(G)\n    nedges = nx.number_of_edges(G)\n    niter = niter * nedges\n    ntries = int(nnodes * nedges / (nnodes * (nnodes - 1) / 2))\n    swapcount = 0\n    for i in range(niter):\n        n = 0\n        while n < ntries:\n            (ai, ci) = discrete_sequence(2, cdistribution=cdf, seed=seed)\n            if ai == ci:\n                continue\n            a = keys[ai]\n            c = keys[ci]\n            b = seed.choice(list(G.neighbors(a)))\n            d = seed.choice(list(G.neighbors(c)))\n            if b in [a, c, d] or d in [a, b, c]:\n                continue\n            if d not in G[a] and b not in G[c]:\n                G.add_edge(a, d)\n                G.add_edge(c, b)\n                G.remove_edge(a, b)\n                G.remove_edge(c, d)\n                if connectivity and local_conn(G, a, b) == 0:\n                    G.remove_edge(a, d)\n                    G.remove_edge(c, b)\n                    G.add_edge(a, b)\n                    G.add_edge(c, d)\n                else:\n                    swapcount += 1\n                    break\n            n += 1\n    return G",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef random_reference(G, niter=1, connectivity=True, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute a random graph by swapping edges of a given graph.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        An undirected graph with 4 or more nodes.\\n\\n    niter : integer (optional, default=1)\\n        An edge is rewired approximately `niter` times.\\n\\n    connectivity : boolean (optional, default=True)\\n        When True, ensure connectivity for the randomized graph.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : graph\\n        The randomized graph.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If there are fewer than 4 nodes or 2 edges in `G`\\n\\n    Notes\\n    -----\\n    The implementation is adapted from the algorithm by Maslov and Sneppen\\n    (2002) [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Maslov, Sergei, and Kim Sneppen.\\n           \"Specificity and stability in topology of protein networks.\"\\n           Science 296.5569 (2002): 910-913.\\n    '\n    if len(G) < 4:\n        raise nx.NetworkXError('Graph has fewer than four nodes.')\n    if len(G.edges) < 2:\n        raise nx.NetworkXError('Graph has fewer that 2 edges')\n    from networkx.utils import cumulative_distribution, discrete_sequence\n    local_conn = nx.connectivity.local_edge_connectivity\n    G = G.copy()\n    (keys, degrees) = zip(*G.degree())\n    cdf = cumulative_distribution(degrees)\n    nnodes = len(G)\n    nedges = nx.number_of_edges(G)\n    niter = niter * nedges\n    ntries = int(nnodes * nedges / (nnodes * (nnodes - 1) / 2))\n    swapcount = 0\n    for i in range(niter):\n        n = 0\n        while n < ntries:\n            (ai, ci) = discrete_sequence(2, cdistribution=cdf, seed=seed)\n            if ai == ci:\n                continue\n            a = keys[ai]\n            c = keys[ci]\n            b = seed.choice(list(G.neighbors(a)))\n            d = seed.choice(list(G.neighbors(c)))\n            if b in [a, c, d] or d in [a, b, c]:\n                continue\n            if d not in G[a] and b not in G[c]:\n                G.add_edge(a, d)\n                G.add_edge(c, b)\n                G.remove_edge(a, b)\n                G.remove_edge(c, d)\n                if connectivity and local_conn(G, a, b) == 0:\n                    G.remove_edge(a, d)\n                    G.remove_edge(c, b)\n                    G.add_edge(a, b)\n                    G.add_edge(c, d)\n                else:\n                    swapcount += 1\n                    break\n            n += 1\n    return G",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef random_reference(G, niter=1, connectivity=True, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute a random graph by swapping edges of a given graph.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        An undirected graph with 4 or more nodes.\\n\\n    niter : integer (optional, default=1)\\n        An edge is rewired approximately `niter` times.\\n\\n    connectivity : boolean (optional, default=True)\\n        When True, ensure connectivity for the randomized graph.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : graph\\n        The randomized graph.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If there are fewer than 4 nodes or 2 edges in `G`\\n\\n    Notes\\n    -----\\n    The implementation is adapted from the algorithm by Maslov and Sneppen\\n    (2002) [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Maslov, Sergei, and Kim Sneppen.\\n           \"Specificity and stability in topology of protein networks.\"\\n           Science 296.5569 (2002): 910-913.\\n    '\n    if len(G) < 4:\n        raise nx.NetworkXError('Graph has fewer than four nodes.')\n    if len(G.edges) < 2:\n        raise nx.NetworkXError('Graph has fewer that 2 edges')\n    from networkx.utils import cumulative_distribution, discrete_sequence\n    local_conn = nx.connectivity.local_edge_connectivity\n    G = G.copy()\n    (keys, degrees) = zip(*G.degree())\n    cdf = cumulative_distribution(degrees)\n    nnodes = len(G)\n    nedges = nx.number_of_edges(G)\n    niter = niter * nedges\n    ntries = int(nnodes * nedges / (nnodes * (nnodes - 1) / 2))\n    swapcount = 0\n    for i in range(niter):\n        n = 0\n        while n < ntries:\n            (ai, ci) = discrete_sequence(2, cdistribution=cdf, seed=seed)\n            if ai == ci:\n                continue\n            a = keys[ai]\n            c = keys[ci]\n            b = seed.choice(list(G.neighbors(a)))\n            d = seed.choice(list(G.neighbors(c)))\n            if b in [a, c, d] or d in [a, b, c]:\n                continue\n            if d not in G[a] and b not in G[c]:\n                G.add_edge(a, d)\n                G.add_edge(c, b)\n                G.remove_edge(a, b)\n                G.remove_edge(c, d)\n                if connectivity and local_conn(G, a, b) == 0:\n                    G.remove_edge(a, d)\n                    G.remove_edge(c, b)\n                    G.add_edge(a, b)\n                    G.add_edge(c, d)\n                else:\n                    swapcount += 1\n                    break\n            n += 1\n    return G",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef random_reference(G, niter=1, connectivity=True, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute a random graph by swapping edges of a given graph.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        An undirected graph with 4 or more nodes.\\n\\n    niter : integer (optional, default=1)\\n        An edge is rewired approximately `niter` times.\\n\\n    connectivity : boolean (optional, default=True)\\n        When True, ensure connectivity for the randomized graph.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : graph\\n        The randomized graph.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If there are fewer than 4 nodes or 2 edges in `G`\\n\\n    Notes\\n    -----\\n    The implementation is adapted from the algorithm by Maslov and Sneppen\\n    (2002) [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Maslov, Sergei, and Kim Sneppen.\\n           \"Specificity and stability in topology of protein networks.\"\\n           Science 296.5569 (2002): 910-913.\\n    '\n    if len(G) < 4:\n        raise nx.NetworkXError('Graph has fewer than four nodes.')\n    if len(G.edges) < 2:\n        raise nx.NetworkXError('Graph has fewer that 2 edges')\n    from networkx.utils import cumulative_distribution, discrete_sequence\n    local_conn = nx.connectivity.local_edge_connectivity\n    G = G.copy()\n    (keys, degrees) = zip(*G.degree())\n    cdf = cumulative_distribution(degrees)\n    nnodes = len(G)\n    nedges = nx.number_of_edges(G)\n    niter = niter * nedges\n    ntries = int(nnodes * nedges / (nnodes * (nnodes - 1) / 2))\n    swapcount = 0\n    for i in range(niter):\n        n = 0\n        while n < ntries:\n            (ai, ci) = discrete_sequence(2, cdistribution=cdf, seed=seed)\n            if ai == ci:\n                continue\n            a = keys[ai]\n            c = keys[ci]\n            b = seed.choice(list(G.neighbors(a)))\n            d = seed.choice(list(G.neighbors(c)))\n            if b in [a, c, d] or d in [a, b, c]:\n                continue\n            if d not in G[a] and b not in G[c]:\n                G.add_edge(a, d)\n                G.add_edge(c, b)\n                G.remove_edge(a, b)\n                G.remove_edge(c, d)\n                if connectivity and local_conn(G, a, b) == 0:\n                    G.remove_edge(a, d)\n                    G.remove_edge(c, b)\n                    G.add_edge(a, b)\n                    G.add_edge(c, d)\n                else:\n                    swapcount += 1\n                    break\n            n += 1\n    return G",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef random_reference(G, niter=1, connectivity=True, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute a random graph by swapping edges of a given graph.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        An undirected graph with 4 or more nodes.\\n\\n    niter : integer (optional, default=1)\\n        An edge is rewired approximately `niter` times.\\n\\n    connectivity : boolean (optional, default=True)\\n        When True, ensure connectivity for the randomized graph.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : graph\\n        The randomized graph.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If there are fewer than 4 nodes or 2 edges in `G`\\n\\n    Notes\\n    -----\\n    The implementation is adapted from the algorithm by Maslov and Sneppen\\n    (2002) [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Maslov, Sergei, and Kim Sneppen.\\n           \"Specificity and stability in topology of protein networks.\"\\n           Science 296.5569 (2002): 910-913.\\n    '\n    if len(G) < 4:\n        raise nx.NetworkXError('Graph has fewer than four nodes.')\n    if len(G.edges) < 2:\n        raise nx.NetworkXError('Graph has fewer that 2 edges')\n    from networkx.utils import cumulative_distribution, discrete_sequence\n    local_conn = nx.connectivity.local_edge_connectivity\n    G = G.copy()\n    (keys, degrees) = zip(*G.degree())\n    cdf = cumulative_distribution(degrees)\n    nnodes = len(G)\n    nedges = nx.number_of_edges(G)\n    niter = niter * nedges\n    ntries = int(nnodes * nedges / (nnodes * (nnodes - 1) / 2))\n    swapcount = 0\n    for i in range(niter):\n        n = 0\n        while n < ntries:\n            (ai, ci) = discrete_sequence(2, cdistribution=cdf, seed=seed)\n            if ai == ci:\n                continue\n            a = keys[ai]\n            c = keys[ci]\n            b = seed.choice(list(G.neighbors(a)))\n            d = seed.choice(list(G.neighbors(c)))\n            if b in [a, c, d] or d in [a, b, c]:\n                continue\n            if d not in G[a] and b not in G[c]:\n                G.add_edge(a, d)\n                G.add_edge(c, b)\n                G.remove_edge(a, b)\n                G.remove_edge(c, d)\n                if connectivity and local_conn(G, a, b) == 0:\n                    G.remove_edge(a, d)\n                    G.remove_edge(c, b)\n                    G.add_edge(a, b)\n                    G.add_edge(c, d)\n                else:\n                    swapcount += 1\n                    break\n            n += 1\n    return G"
        ]
    },
    {
        "func_name": "lattice_reference",
        "original": "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(4)\n@nx._dispatch\ndef lattice_reference(G, niter=5, D=None, connectivity=True, seed=None):\n    \"\"\"Latticize the given graph by swapping edges.\n\n    Parameters\n    ----------\n    G : graph\n        An undirected graph.\n\n    niter : integer (optional, default=1)\n        An edge is rewired approximately niter times.\n\n    D : numpy.array (optional, default=None)\n        Distance to the diagonal matrix.\n\n    connectivity : boolean (optional, default=True)\n        Ensure connectivity for the latticized graph when set to True.\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    G : graph\n        The latticized graph.\n\n    Raises\n    ------\n    NetworkXError\n        If there are fewer than 4 nodes or 2 edges in `G`\n\n    Notes\n    -----\n    The implementation is adapted from the algorithm by Sporns et al. [1]_.\n    which is inspired from the original work by Maslov and Sneppen(2002) [2]_.\n\n    References\n    ----------\n    .. [1] Sporns, Olaf, and Jonathan D. Zwi.\n       \"The small world of the cerebral cortex.\"\n       Neuroinformatics 2.2 (2004): 145-162.\n    .. [2] Maslov, Sergei, and Kim Sneppen.\n       \"Specificity and stability in topology of protein networks.\"\n       Science 296.5569 (2002): 910-913.\n    \"\"\"\n    import numpy as np\n    from networkx.utils import cumulative_distribution, discrete_sequence\n    local_conn = nx.connectivity.local_edge_connectivity\n    if len(G) < 4:\n        raise nx.NetworkXError('Graph has fewer than four nodes.')\n    if len(G.edges) < 2:\n        raise nx.NetworkXError('Graph has fewer that 2 edges')\n    G = G.copy()\n    (keys, degrees) = zip(*G.degree())\n    cdf = cumulative_distribution(degrees)\n    nnodes = len(G)\n    nedges = nx.number_of_edges(G)\n    if D is None:\n        D = np.zeros((nnodes, nnodes))\n        un = np.arange(1, nnodes)\n        um = np.arange(nnodes - 1, 0, -1)\n        u = np.append((0,), np.where(un < um, un, um))\n        for v in range(int(np.ceil(nnodes / 2))):\n            D[nnodes - v - 1, :] = np.append(u[v + 1:], u[:v + 1])\n            D[v, :] = D[nnodes - v - 1, :][::-1]\n    niter = niter * nedges\n    max_attempts = int(nnodes * nedges / (nnodes * (nnodes - 1) / 2))\n    for _ in range(niter):\n        n = 0\n        while n < max_attempts:\n            (ai, ci) = discrete_sequence(2, cdistribution=cdf, seed=seed)\n            if ai == ci:\n                continue\n            a = keys[ai]\n            c = keys[ci]\n            b = seed.choice(list(G.neighbors(a)))\n            d = seed.choice(list(G.neighbors(c)))\n            bi = keys.index(b)\n            di = keys.index(d)\n            if b in [a, c, d] or d in [a, b, c]:\n                continue\n            if d not in G[a] and b not in G[c]:\n                if D[ai, bi] + D[ci, di] >= D[ai, ci] + D[bi, di]:\n                    G.add_edge(a, d)\n                    G.add_edge(c, b)\n                    G.remove_edge(a, b)\n                    G.remove_edge(c, d)\n                    if connectivity and local_conn(G, a, b) == 0:\n                        G.remove_edge(a, d)\n                        G.remove_edge(c, b)\n                        G.add_edge(a, b)\n                        G.add_edge(c, d)\n                    else:\n                        break\n            n += 1\n    return G",
        "mutated": [
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(4)\n@nx._dispatch\ndef lattice_reference(G, niter=5, D=None, connectivity=True, seed=None):\n    if False:\n        i = 10\n    'Latticize the given graph by swapping edges.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        An undirected graph.\\n\\n    niter : integer (optional, default=1)\\n        An edge is rewired approximately niter times.\\n\\n    D : numpy.array (optional, default=None)\\n        Distance to the diagonal matrix.\\n\\n    connectivity : boolean (optional, default=True)\\n        Ensure connectivity for the latticized graph when set to True.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : graph\\n        The latticized graph.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If there are fewer than 4 nodes or 2 edges in `G`\\n\\n    Notes\\n    -----\\n    The implementation is adapted from the algorithm by Sporns et al. [1]_.\\n    which is inspired from the original work by Maslov and Sneppen(2002) [2]_.\\n\\n    References\\n    ----------\\n    .. [1] Sporns, Olaf, and Jonathan D. Zwi.\\n       \"The small world of the cerebral cortex.\"\\n       Neuroinformatics 2.2 (2004): 145-162.\\n    .. [2] Maslov, Sergei, and Kim Sneppen.\\n       \"Specificity and stability in topology of protein networks.\"\\n       Science 296.5569 (2002): 910-913.\\n    '\n    import numpy as np\n    from networkx.utils import cumulative_distribution, discrete_sequence\n    local_conn = nx.connectivity.local_edge_connectivity\n    if len(G) < 4:\n        raise nx.NetworkXError('Graph has fewer than four nodes.')\n    if len(G.edges) < 2:\n        raise nx.NetworkXError('Graph has fewer that 2 edges')\n    G = G.copy()\n    (keys, degrees) = zip(*G.degree())\n    cdf = cumulative_distribution(degrees)\n    nnodes = len(G)\n    nedges = nx.number_of_edges(G)\n    if D is None:\n        D = np.zeros((nnodes, nnodes))\n        un = np.arange(1, nnodes)\n        um = np.arange(nnodes - 1, 0, -1)\n        u = np.append((0,), np.where(un < um, un, um))\n        for v in range(int(np.ceil(nnodes / 2))):\n            D[nnodes - v - 1, :] = np.append(u[v + 1:], u[:v + 1])\n            D[v, :] = D[nnodes - v - 1, :][::-1]\n    niter = niter * nedges\n    max_attempts = int(nnodes * nedges / (nnodes * (nnodes - 1) / 2))\n    for _ in range(niter):\n        n = 0\n        while n < max_attempts:\n            (ai, ci) = discrete_sequence(2, cdistribution=cdf, seed=seed)\n            if ai == ci:\n                continue\n            a = keys[ai]\n            c = keys[ci]\n            b = seed.choice(list(G.neighbors(a)))\n            d = seed.choice(list(G.neighbors(c)))\n            bi = keys.index(b)\n            di = keys.index(d)\n            if b in [a, c, d] or d in [a, b, c]:\n                continue\n            if d not in G[a] and b not in G[c]:\n                if D[ai, bi] + D[ci, di] >= D[ai, ci] + D[bi, di]:\n                    G.add_edge(a, d)\n                    G.add_edge(c, b)\n                    G.remove_edge(a, b)\n                    G.remove_edge(c, d)\n                    if connectivity and local_conn(G, a, b) == 0:\n                        G.remove_edge(a, d)\n                        G.remove_edge(c, b)\n                        G.add_edge(a, b)\n                        G.add_edge(c, d)\n                    else:\n                        break\n            n += 1\n    return G",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(4)\n@nx._dispatch\ndef lattice_reference(G, niter=5, D=None, connectivity=True, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Latticize the given graph by swapping edges.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        An undirected graph.\\n\\n    niter : integer (optional, default=1)\\n        An edge is rewired approximately niter times.\\n\\n    D : numpy.array (optional, default=None)\\n        Distance to the diagonal matrix.\\n\\n    connectivity : boolean (optional, default=True)\\n        Ensure connectivity for the latticized graph when set to True.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : graph\\n        The latticized graph.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If there are fewer than 4 nodes or 2 edges in `G`\\n\\n    Notes\\n    -----\\n    The implementation is adapted from the algorithm by Sporns et al. [1]_.\\n    which is inspired from the original work by Maslov and Sneppen(2002) [2]_.\\n\\n    References\\n    ----------\\n    .. [1] Sporns, Olaf, and Jonathan D. Zwi.\\n       \"The small world of the cerebral cortex.\"\\n       Neuroinformatics 2.2 (2004): 145-162.\\n    .. [2] Maslov, Sergei, and Kim Sneppen.\\n       \"Specificity and stability in topology of protein networks.\"\\n       Science 296.5569 (2002): 910-913.\\n    '\n    import numpy as np\n    from networkx.utils import cumulative_distribution, discrete_sequence\n    local_conn = nx.connectivity.local_edge_connectivity\n    if len(G) < 4:\n        raise nx.NetworkXError('Graph has fewer than four nodes.')\n    if len(G.edges) < 2:\n        raise nx.NetworkXError('Graph has fewer that 2 edges')\n    G = G.copy()\n    (keys, degrees) = zip(*G.degree())\n    cdf = cumulative_distribution(degrees)\n    nnodes = len(G)\n    nedges = nx.number_of_edges(G)\n    if D is None:\n        D = np.zeros((nnodes, nnodes))\n        un = np.arange(1, nnodes)\n        um = np.arange(nnodes - 1, 0, -1)\n        u = np.append((0,), np.where(un < um, un, um))\n        for v in range(int(np.ceil(nnodes / 2))):\n            D[nnodes - v - 1, :] = np.append(u[v + 1:], u[:v + 1])\n            D[v, :] = D[nnodes - v - 1, :][::-1]\n    niter = niter * nedges\n    max_attempts = int(nnodes * nedges / (nnodes * (nnodes - 1) / 2))\n    for _ in range(niter):\n        n = 0\n        while n < max_attempts:\n            (ai, ci) = discrete_sequence(2, cdistribution=cdf, seed=seed)\n            if ai == ci:\n                continue\n            a = keys[ai]\n            c = keys[ci]\n            b = seed.choice(list(G.neighbors(a)))\n            d = seed.choice(list(G.neighbors(c)))\n            bi = keys.index(b)\n            di = keys.index(d)\n            if b in [a, c, d] or d in [a, b, c]:\n                continue\n            if d not in G[a] and b not in G[c]:\n                if D[ai, bi] + D[ci, di] >= D[ai, ci] + D[bi, di]:\n                    G.add_edge(a, d)\n                    G.add_edge(c, b)\n                    G.remove_edge(a, b)\n                    G.remove_edge(c, d)\n                    if connectivity and local_conn(G, a, b) == 0:\n                        G.remove_edge(a, d)\n                        G.remove_edge(c, b)\n                        G.add_edge(a, b)\n                        G.add_edge(c, d)\n                    else:\n                        break\n            n += 1\n    return G",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(4)\n@nx._dispatch\ndef lattice_reference(G, niter=5, D=None, connectivity=True, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Latticize the given graph by swapping edges.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        An undirected graph.\\n\\n    niter : integer (optional, default=1)\\n        An edge is rewired approximately niter times.\\n\\n    D : numpy.array (optional, default=None)\\n        Distance to the diagonal matrix.\\n\\n    connectivity : boolean (optional, default=True)\\n        Ensure connectivity for the latticized graph when set to True.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : graph\\n        The latticized graph.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If there are fewer than 4 nodes or 2 edges in `G`\\n\\n    Notes\\n    -----\\n    The implementation is adapted from the algorithm by Sporns et al. [1]_.\\n    which is inspired from the original work by Maslov and Sneppen(2002) [2]_.\\n\\n    References\\n    ----------\\n    .. [1] Sporns, Olaf, and Jonathan D. Zwi.\\n       \"The small world of the cerebral cortex.\"\\n       Neuroinformatics 2.2 (2004): 145-162.\\n    .. [2] Maslov, Sergei, and Kim Sneppen.\\n       \"Specificity and stability in topology of protein networks.\"\\n       Science 296.5569 (2002): 910-913.\\n    '\n    import numpy as np\n    from networkx.utils import cumulative_distribution, discrete_sequence\n    local_conn = nx.connectivity.local_edge_connectivity\n    if len(G) < 4:\n        raise nx.NetworkXError('Graph has fewer than four nodes.')\n    if len(G.edges) < 2:\n        raise nx.NetworkXError('Graph has fewer that 2 edges')\n    G = G.copy()\n    (keys, degrees) = zip(*G.degree())\n    cdf = cumulative_distribution(degrees)\n    nnodes = len(G)\n    nedges = nx.number_of_edges(G)\n    if D is None:\n        D = np.zeros((nnodes, nnodes))\n        un = np.arange(1, nnodes)\n        um = np.arange(nnodes - 1, 0, -1)\n        u = np.append((0,), np.where(un < um, un, um))\n        for v in range(int(np.ceil(nnodes / 2))):\n            D[nnodes - v - 1, :] = np.append(u[v + 1:], u[:v + 1])\n            D[v, :] = D[nnodes - v - 1, :][::-1]\n    niter = niter * nedges\n    max_attempts = int(nnodes * nedges / (nnodes * (nnodes - 1) / 2))\n    for _ in range(niter):\n        n = 0\n        while n < max_attempts:\n            (ai, ci) = discrete_sequence(2, cdistribution=cdf, seed=seed)\n            if ai == ci:\n                continue\n            a = keys[ai]\n            c = keys[ci]\n            b = seed.choice(list(G.neighbors(a)))\n            d = seed.choice(list(G.neighbors(c)))\n            bi = keys.index(b)\n            di = keys.index(d)\n            if b in [a, c, d] or d in [a, b, c]:\n                continue\n            if d not in G[a] and b not in G[c]:\n                if D[ai, bi] + D[ci, di] >= D[ai, ci] + D[bi, di]:\n                    G.add_edge(a, d)\n                    G.add_edge(c, b)\n                    G.remove_edge(a, b)\n                    G.remove_edge(c, d)\n                    if connectivity and local_conn(G, a, b) == 0:\n                        G.remove_edge(a, d)\n                        G.remove_edge(c, b)\n                        G.add_edge(a, b)\n                        G.add_edge(c, d)\n                    else:\n                        break\n            n += 1\n    return G",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(4)\n@nx._dispatch\ndef lattice_reference(G, niter=5, D=None, connectivity=True, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Latticize the given graph by swapping edges.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        An undirected graph.\\n\\n    niter : integer (optional, default=1)\\n        An edge is rewired approximately niter times.\\n\\n    D : numpy.array (optional, default=None)\\n        Distance to the diagonal matrix.\\n\\n    connectivity : boolean (optional, default=True)\\n        Ensure connectivity for the latticized graph when set to True.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : graph\\n        The latticized graph.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If there are fewer than 4 nodes or 2 edges in `G`\\n\\n    Notes\\n    -----\\n    The implementation is adapted from the algorithm by Sporns et al. [1]_.\\n    which is inspired from the original work by Maslov and Sneppen(2002) [2]_.\\n\\n    References\\n    ----------\\n    .. [1] Sporns, Olaf, and Jonathan D. Zwi.\\n       \"The small world of the cerebral cortex.\"\\n       Neuroinformatics 2.2 (2004): 145-162.\\n    .. [2] Maslov, Sergei, and Kim Sneppen.\\n       \"Specificity and stability in topology of protein networks.\"\\n       Science 296.5569 (2002): 910-913.\\n    '\n    import numpy as np\n    from networkx.utils import cumulative_distribution, discrete_sequence\n    local_conn = nx.connectivity.local_edge_connectivity\n    if len(G) < 4:\n        raise nx.NetworkXError('Graph has fewer than four nodes.')\n    if len(G.edges) < 2:\n        raise nx.NetworkXError('Graph has fewer that 2 edges')\n    G = G.copy()\n    (keys, degrees) = zip(*G.degree())\n    cdf = cumulative_distribution(degrees)\n    nnodes = len(G)\n    nedges = nx.number_of_edges(G)\n    if D is None:\n        D = np.zeros((nnodes, nnodes))\n        un = np.arange(1, nnodes)\n        um = np.arange(nnodes - 1, 0, -1)\n        u = np.append((0,), np.where(un < um, un, um))\n        for v in range(int(np.ceil(nnodes / 2))):\n            D[nnodes - v - 1, :] = np.append(u[v + 1:], u[:v + 1])\n            D[v, :] = D[nnodes - v - 1, :][::-1]\n    niter = niter * nedges\n    max_attempts = int(nnodes * nedges / (nnodes * (nnodes - 1) / 2))\n    for _ in range(niter):\n        n = 0\n        while n < max_attempts:\n            (ai, ci) = discrete_sequence(2, cdistribution=cdf, seed=seed)\n            if ai == ci:\n                continue\n            a = keys[ai]\n            c = keys[ci]\n            b = seed.choice(list(G.neighbors(a)))\n            d = seed.choice(list(G.neighbors(c)))\n            bi = keys.index(b)\n            di = keys.index(d)\n            if b in [a, c, d] or d in [a, b, c]:\n                continue\n            if d not in G[a] and b not in G[c]:\n                if D[ai, bi] + D[ci, di] >= D[ai, ci] + D[bi, di]:\n                    G.add_edge(a, d)\n                    G.add_edge(c, b)\n                    G.remove_edge(a, b)\n                    G.remove_edge(c, d)\n                    if connectivity and local_conn(G, a, b) == 0:\n                        G.remove_edge(a, d)\n                        G.remove_edge(c, b)\n                        G.add_edge(a, b)\n                        G.add_edge(c, d)\n                    else:\n                        break\n            n += 1\n    return G",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(4)\n@nx._dispatch\ndef lattice_reference(G, niter=5, D=None, connectivity=True, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Latticize the given graph by swapping edges.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        An undirected graph.\\n\\n    niter : integer (optional, default=1)\\n        An edge is rewired approximately niter times.\\n\\n    D : numpy.array (optional, default=None)\\n        Distance to the diagonal matrix.\\n\\n    connectivity : boolean (optional, default=True)\\n        Ensure connectivity for the latticized graph when set to True.\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    G : graph\\n        The latticized graph.\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        If there are fewer than 4 nodes or 2 edges in `G`\\n\\n    Notes\\n    -----\\n    The implementation is adapted from the algorithm by Sporns et al. [1]_.\\n    which is inspired from the original work by Maslov and Sneppen(2002) [2]_.\\n\\n    References\\n    ----------\\n    .. [1] Sporns, Olaf, and Jonathan D. Zwi.\\n       \"The small world of the cerebral cortex.\"\\n       Neuroinformatics 2.2 (2004): 145-162.\\n    .. [2] Maslov, Sergei, and Kim Sneppen.\\n       \"Specificity and stability in topology of protein networks.\"\\n       Science 296.5569 (2002): 910-913.\\n    '\n    import numpy as np\n    from networkx.utils import cumulative_distribution, discrete_sequence\n    local_conn = nx.connectivity.local_edge_connectivity\n    if len(G) < 4:\n        raise nx.NetworkXError('Graph has fewer than four nodes.')\n    if len(G.edges) < 2:\n        raise nx.NetworkXError('Graph has fewer that 2 edges')\n    G = G.copy()\n    (keys, degrees) = zip(*G.degree())\n    cdf = cumulative_distribution(degrees)\n    nnodes = len(G)\n    nedges = nx.number_of_edges(G)\n    if D is None:\n        D = np.zeros((nnodes, nnodes))\n        un = np.arange(1, nnodes)\n        um = np.arange(nnodes - 1, 0, -1)\n        u = np.append((0,), np.where(un < um, un, um))\n        for v in range(int(np.ceil(nnodes / 2))):\n            D[nnodes - v - 1, :] = np.append(u[v + 1:], u[:v + 1])\n            D[v, :] = D[nnodes - v - 1, :][::-1]\n    niter = niter * nedges\n    max_attempts = int(nnodes * nedges / (nnodes * (nnodes - 1) / 2))\n    for _ in range(niter):\n        n = 0\n        while n < max_attempts:\n            (ai, ci) = discrete_sequence(2, cdistribution=cdf, seed=seed)\n            if ai == ci:\n                continue\n            a = keys[ai]\n            c = keys[ci]\n            b = seed.choice(list(G.neighbors(a)))\n            d = seed.choice(list(G.neighbors(c)))\n            bi = keys.index(b)\n            di = keys.index(d)\n            if b in [a, c, d] or d in [a, b, c]:\n                continue\n            if d not in G[a] and b not in G[c]:\n                if D[ai, bi] + D[ci, di] >= D[ai, ci] + D[bi, di]:\n                    G.add_edge(a, d)\n                    G.add_edge(c, b)\n                    G.remove_edge(a, b)\n                    G.remove_edge(c, d)\n                    if connectivity and local_conn(G, a, b) == 0:\n                        G.remove_edge(a, d)\n                        G.remove_edge(c, b)\n                        G.add_edge(a, b)\n                        G.add_edge(c, d)\n                    else:\n                        break\n            n += 1\n    return G"
        ]
    },
    {
        "func_name": "sigma",
        "original": "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef sigma(G, niter=100, nrand=10, seed=None):\n    \"\"\"Returns the small-world coefficient (sigma) of the given graph.\n\n    The small-world coefficient is defined as:\n    sigma = C/Cr / L/Lr\n    where C and L are respectively the average clustering coefficient and\n    average shortest path length of G. Cr and Lr are respectively the average\n    clustering coefficient and average shortest path length of an equivalent\n    random graph.\n\n    A graph is commonly classified as small-world if sigma>1.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        An undirected graph.\n    niter : integer (optional, default=100)\n        Approximate number of rewiring per edge to compute the equivalent\n        random graph.\n    nrand : integer (optional, default=10)\n        Number of random graphs generated to compute the average clustering\n        coefficient (Cr) and average shortest path length (Lr).\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n    Returns\n    -------\n    sigma : float\n        The small-world coefficient of G.\n\n    Notes\n    -----\n    The implementation is adapted from Humphries et al. [1]_ [2]_.\n\n    References\n    ----------\n    .. [1] The brainstem reticular formation is a small-world, not scale-free,\n           network M. D. Humphries, K. Gurney and T. J. Prescott,\n           Proc. Roy. Soc. B 2006 273, 503-511, doi:10.1098/rspb.2005.3354.\n    .. [2] Humphries and Gurney (2008).\n           \"Network 'Small-World-Ness': A Quantitative Method for Determining\n           Canonical Network Equivalence\".\n           PLoS One. 3 (4). PMID 18446219. doi:10.1371/journal.pone.0002051.\n    \"\"\"\n    import numpy as np\n    randMetrics = {'C': [], 'L': []}\n    for i in range(nrand):\n        Gr = random_reference(G, niter=niter, seed=seed)\n        randMetrics['C'].append(nx.transitivity(Gr))\n        randMetrics['L'].append(nx.average_shortest_path_length(Gr))\n    C = nx.transitivity(G)\n    L = nx.average_shortest_path_length(G)\n    Cr = np.mean(randMetrics['C'])\n    Lr = np.mean(randMetrics['L'])\n    sigma = C / Cr / (L / Lr)\n    return sigma",
        "mutated": [
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef sigma(G, niter=100, nrand=10, seed=None):\n    if False:\n        i = 10\n    'Returns the small-world coefficient (sigma) of the given graph.\\n\\n    The small-world coefficient is defined as:\\n    sigma = C/Cr / L/Lr\\n    where C and L are respectively the average clustering coefficient and\\n    average shortest path length of G. Cr and Lr are respectively the average\\n    clustering coefficient and average shortest path length of an equivalent\\n    random graph.\\n\\n    A graph is commonly classified as small-world if sigma>1.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        An undirected graph.\\n    niter : integer (optional, default=100)\\n        Approximate number of rewiring per edge to compute the equivalent\\n        random graph.\\n    nrand : integer (optional, default=10)\\n        Number of random graphs generated to compute the average clustering\\n        coefficient (Cr) and average shortest path length (Lr).\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    sigma : float\\n        The small-world coefficient of G.\\n\\n    Notes\\n    -----\\n    The implementation is adapted from Humphries et al. [1]_ [2]_.\\n\\n    References\\n    ----------\\n    .. [1] The brainstem reticular formation is a small-world, not scale-free,\\n           network M. D. Humphries, K. Gurney and T. J. Prescott,\\n           Proc. Roy. Soc. B 2006 273, 503-511, doi:10.1098/rspb.2005.3354.\\n    .. [2] Humphries and Gurney (2008).\\n           \"Network \\'Small-World-Ness\\': A Quantitative Method for Determining\\n           Canonical Network Equivalence\".\\n           PLoS One. 3 (4). PMID 18446219. doi:10.1371/journal.pone.0002051.\\n    '\n    import numpy as np\n    randMetrics = {'C': [], 'L': []}\n    for i in range(nrand):\n        Gr = random_reference(G, niter=niter, seed=seed)\n        randMetrics['C'].append(nx.transitivity(Gr))\n        randMetrics['L'].append(nx.average_shortest_path_length(Gr))\n    C = nx.transitivity(G)\n    L = nx.average_shortest_path_length(G)\n    Cr = np.mean(randMetrics['C'])\n    Lr = np.mean(randMetrics['L'])\n    sigma = C / Cr / (L / Lr)\n    return sigma",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef sigma(G, niter=100, nrand=10, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the small-world coefficient (sigma) of the given graph.\\n\\n    The small-world coefficient is defined as:\\n    sigma = C/Cr / L/Lr\\n    where C and L are respectively the average clustering coefficient and\\n    average shortest path length of G. Cr and Lr are respectively the average\\n    clustering coefficient and average shortest path length of an equivalent\\n    random graph.\\n\\n    A graph is commonly classified as small-world if sigma>1.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        An undirected graph.\\n    niter : integer (optional, default=100)\\n        Approximate number of rewiring per edge to compute the equivalent\\n        random graph.\\n    nrand : integer (optional, default=10)\\n        Number of random graphs generated to compute the average clustering\\n        coefficient (Cr) and average shortest path length (Lr).\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    sigma : float\\n        The small-world coefficient of G.\\n\\n    Notes\\n    -----\\n    The implementation is adapted from Humphries et al. [1]_ [2]_.\\n\\n    References\\n    ----------\\n    .. [1] The brainstem reticular formation is a small-world, not scale-free,\\n           network M. D. Humphries, K. Gurney and T. J. Prescott,\\n           Proc. Roy. Soc. B 2006 273, 503-511, doi:10.1098/rspb.2005.3354.\\n    .. [2] Humphries and Gurney (2008).\\n           \"Network \\'Small-World-Ness\\': A Quantitative Method for Determining\\n           Canonical Network Equivalence\".\\n           PLoS One. 3 (4). PMID 18446219. doi:10.1371/journal.pone.0002051.\\n    '\n    import numpy as np\n    randMetrics = {'C': [], 'L': []}\n    for i in range(nrand):\n        Gr = random_reference(G, niter=niter, seed=seed)\n        randMetrics['C'].append(nx.transitivity(Gr))\n        randMetrics['L'].append(nx.average_shortest_path_length(Gr))\n    C = nx.transitivity(G)\n    L = nx.average_shortest_path_length(G)\n    Cr = np.mean(randMetrics['C'])\n    Lr = np.mean(randMetrics['L'])\n    sigma = C / Cr / (L / Lr)\n    return sigma",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef sigma(G, niter=100, nrand=10, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the small-world coefficient (sigma) of the given graph.\\n\\n    The small-world coefficient is defined as:\\n    sigma = C/Cr / L/Lr\\n    where C and L are respectively the average clustering coefficient and\\n    average shortest path length of G. Cr and Lr are respectively the average\\n    clustering coefficient and average shortest path length of an equivalent\\n    random graph.\\n\\n    A graph is commonly classified as small-world if sigma>1.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        An undirected graph.\\n    niter : integer (optional, default=100)\\n        Approximate number of rewiring per edge to compute the equivalent\\n        random graph.\\n    nrand : integer (optional, default=10)\\n        Number of random graphs generated to compute the average clustering\\n        coefficient (Cr) and average shortest path length (Lr).\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    sigma : float\\n        The small-world coefficient of G.\\n\\n    Notes\\n    -----\\n    The implementation is adapted from Humphries et al. [1]_ [2]_.\\n\\n    References\\n    ----------\\n    .. [1] The brainstem reticular formation is a small-world, not scale-free,\\n           network M. D. Humphries, K. Gurney and T. J. Prescott,\\n           Proc. Roy. Soc. B 2006 273, 503-511, doi:10.1098/rspb.2005.3354.\\n    .. [2] Humphries and Gurney (2008).\\n           \"Network \\'Small-World-Ness\\': A Quantitative Method for Determining\\n           Canonical Network Equivalence\".\\n           PLoS One. 3 (4). PMID 18446219. doi:10.1371/journal.pone.0002051.\\n    '\n    import numpy as np\n    randMetrics = {'C': [], 'L': []}\n    for i in range(nrand):\n        Gr = random_reference(G, niter=niter, seed=seed)\n        randMetrics['C'].append(nx.transitivity(Gr))\n        randMetrics['L'].append(nx.average_shortest_path_length(Gr))\n    C = nx.transitivity(G)\n    L = nx.average_shortest_path_length(G)\n    Cr = np.mean(randMetrics['C'])\n    Lr = np.mean(randMetrics['L'])\n    sigma = C / Cr / (L / Lr)\n    return sigma",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef sigma(G, niter=100, nrand=10, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the small-world coefficient (sigma) of the given graph.\\n\\n    The small-world coefficient is defined as:\\n    sigma = C/Cr / L/Lr\\n    where C and L are respectively the average clustering coefficient and\\n    average shortest path length of G. Cr and Lr are respectively the average\\n    clustering coefficient and average shortest path length of an equivalent\\n    random graph.\\n\\n    A graph is commonly classified as small-world if sigma>1.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        An undirected graph.\\n    niter : integer (optional, default=100)\\n        Approximate number of rewiring per edge to compute the equivalent\\n        random graph.\\n    nrand : integer (optional, default=10)\\n        Number of random graphs generated to compute the average clustering\\n        coefficient (Cr) and average shortest path length (Lr).\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    sigma : float\\n        The small-world coefficient of G.\\n\\n    Notes\\n    -----\\n    The implementation is adapted from Humphries et al. [1]_ [2]_.\\n\\n    References\\n    ----------\\n    .. [1] The brainstem reticular formation is a small-world, not scale-free,\\n           network M. D. Humphries, K. Gurney and T. J. Prescott,\\n           Proc. Roy. Soc. B 2006 273, 503-511, doi:10.1098/rspb.2005.3354.\\n    .. [2] Humphries and Gurney (2008).\\n           \"Network \\'Small-World-Ness\\': A Quantitative Method for Determining\\n           Canonical Network Equivalence\".\\n           PLoS One. 3 (4). PMID 18446219. doi:10.1371/journal.pone.0002051.\\n    '\n    import numpy as np\n    randMetrics = {'C': [], 'L': []}\n    for i in range(nrand):\n        Gr = random_reference(G, niter=niter, seed=seed)\n        randMetrics['C'].append(nx.transitivity(Gr))\n        randMetrics['L'].append(nx.average_shortest_path_length(Gr))\n    C = nx.transitivity(G)\n    L = nx.average_shortest_path_length(G)\n    Cr = np.mean(randMetrics['C'])\n    Lr = np.mean(randMetrics['L'])\n    sigma = C / Cr / (L / Lr)\n    return sigma",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef sigma(G, niter=100, nrand=10, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the small-world coefficient (sigma) of the given graph.\\n\\n    The small-world coefficient is defined as:\\n    sigma = C/Cr / L/Lr\\n    where C and L are respectively the average clustering coefficient and\\n    average shortest path length of G. Cr and Lr are respectively the average\\n    clustering coefficient and average shortest path length of an equivalent\\n    random graph.\\n\\n    A graph is commonly classified as small-world if sigma>1.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        An undirected graph.\\n    niter : integer (optional, default=100)\\n        Approximate number of rewiring per edge to compute the equivalent\\n        random graph.\\n    nrand : integer (optional, default=10)\\n        Number of random graphs generated to compute the average clustering\\n        coefficient (Cr) and average shortest path length (Lr).\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n    Returns\\n    -------\\n    sigma : float\\n        The small-world coefficient of G.\\n\\n    Notes\\n    -----\\n    The implementation is adapted from Humphries et al. [1]_ [2]_.\\n\\n    References\\n    ----------\\n    .. [1] The brainstem reticular formation is a small-world, not scale-free,\\n           network M. D. Humphries, K. Gurney and T. J. Prescott,\\n           Proc. Roy. Soc. B 2006 273, 503-511, doi:10.1098/rspb.2005.3354.\\n    .. [2] Humphries and Gurney (2008).\\n           \"Network \\'Small-World-Ness\\': A Quantitative Method for Determining\\n           Canonical Network Equivalence\".\\n           PLoS One. 3 (4). PMID 18446219. doi:10.1371/journal.pone.0002051.\\n    '\n    import numpy as np\n    randMetrics = {'C': [], 'L': []}\n    for i in range(nrand):\n        Gr = random_reference(G, niter=niter, seed=seed)\n        randMetrics['C'].append(nx.transitivity(Gr))\n        randMetrics['L'].append(nx.average_shortest_path_length(Gr))\n    C = nx.transitivity(G)\n    L = nx.average_shortest_path_length(G)\n    Cr = np.mean(randMetrics['C'])\n    Lr = np.mean(randMetrics['L'])\n    sigma = C / Cr / (L / Lr)\n    return sigma"
        ]
    },
    {
        "func_name": "omega",
        "original": "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef omega(G, niter=5, nrand=10, seed=None):\n    \"\"\"Returns the small-world coefficient (omega) of a graph\n\n    The small-world coefficient of a graph G is:\n\n    omega = Lr/L - C/Cl\n\n    where C and L are respectively the average clustering coefficient and\n    average shortest path length of G. Lr is the average shortest path length\n    of an equivalent random graph and Cl is the average clustering coefficient\n    of an equivalent lattice graph.\n\n    The small-world coefficient (omega) measures how much G is like a lattice\n    or a random graph. Negative values mean G is similar to a lattice whereas\n    positive values mean G is a random graph.\n    Values close to 0 mean that G has small-world characteristics.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        An undirected graph.\n\n    niter: integer (optional, default=5)\n        Approximate number of rewiring per edge to compute the equivalent\n        random graph.\n\n    nrand: integer (optional, default=10)\n        Number of random graphs generated to compute the maximal clustering\n        coefficient (Cr) and average shortest path length (Lr).\n\n    seed : integer, random_state, or None (default)\n        Indicator of random number generation state.\n        See :ref:`Randomness<randomness>`.\n\n\n    Returns\n    -------\n    omega : float\n        The small-world coefficient (omega)\n\n    Notes\n    -----\n    The implementation is adapted from the algorithm by Telesford et al. [1]_.\n\n    References\n    ----------\n    .. [1] Telesford, Joyce, Hayasaka, Burdette, and Laurienti (2011).\n           \"The Ubiquity of Small-World Networks\".\n           Brain Connectivity. 1 (0038): 367-75.  PMC 3604768. PMID 22432451.\n           doi:10.1089/brain.2011.0038.\n    \"\"\"\n    import numpy as np\n    randMetrics = {'C': [], 'L': []}\n    Cl = nx.average_clustering(G)\n    niter_lattice_reference = niter\n    niter_random_reference = niter * 2\n    for _ in range(nrand):\n        Gr = random_reference(G, niter=niter_random_reference, seed=seed)\n        randMetrics['L'].append(nx.average_shortest_path_length(Gr))\n        Gl = lattice_reference(G, niter=niter_lattice_reference, seed=seed)\n        Cl_temp = nx.average_clustering(Gl)\n        if Cl_temp > Cl:\n            Cl = Cl_temp\n    C = nx.average_clustering(G)\n    L = nx.average_shortest_path_length(G)\n    Lr = np.mean(randMetrics['L'])\n    omega = Lr / L - C / Cl\n    return omega",
        "mutated": [
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef omega(G, niter=5, nrand=10, seed=None):\n    if False:\n        i = 10\n    'Returns the small-world coefficient (omega) of a graph\\n\\n    The small-world coefficient of a graph G is:\\n\\n    omega = Lr/L - C/Cl\\n\\n    where C and L are respectively the average clustering coefficient and\\n    average shortest path length of G. Lr is the average shortest path length\\n    of an equivalent random graph and Cl is the average clustering coefficient\\n    of an equivalent lattice graph.\\n\\n    The small-world coefficient (omega) measures how much G is like a lattice\\n    or a random graph. Negative values mean G is similar to a lattice whereas\\n    positive values mean G is a random graph.\\n    Values close to 0 mean that G has small-world characteristics.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        An undirected graph.\\n\\n    niter: integer (optional, default=5)\\n        Approximate number of rewiring per edge to compute the equivalent\\n        random graph.\\n\\n    nrand: integer (optional, default=10)\\n        Number of random graphs generated to compute the maximal clustering\\n        coefficient (Cr) and average shortest path length (Lr).\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n\\n    Returns\\n    -------\\n    omega : float\\n        The small-world coefficient (omega)\\n\\n    Notes\\n    -----\\n    The implementation is adapted from the algorithm by Telesford et al. [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Telesford, Joyce, Hayasaka, Burdette, and Laurienti (2011).\\n           \"The Ubiquity of Small-World Networks\".\\n           Brain Connectivity. 1 (0038): 367-75.  PMC 3604768. PMID 22432451.\\n           doi:10.1089/brain.2011.0038.\\n    '\n    import numpy as np\n    randMetrics = {'C': [], 'L': []}\n    Cl = nx.average_clustering(G)\n    niter_lattice_reference = niter\n    niter_random_reference = niter * 2\n    for _ in range(nrand):\n        Gr = random_reference(G, niter=niter_random_reference, seed=seed)\n        randMetrics['L'].append(nx.average_shortest_path_length(Gr))\n        Gl = lattice_reference(G, niter=niter_lattice_reference, seed=seed)\n        Cl_temp = nx.average_clustering(Gl)\n        if Cl_temp > Cl:\n            Cl = Cl_temp\n    C = nx.average_clustering(G)\n    L = nx.average_shortest_path_length(G)\n    Lr = np.mean(randMetrics['L'])\n    omega = Lr / L - C / Cl\n    return omega",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef omega(G, niter=5, nrand=10, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the small-world coefficient (omega) of a graph\\n\\n    The small-world coefficient of a graph G is:\\n\\n    omega = Lr/L - C/Cl\\n\\n    where C and L are respectively the average clustering coefficient and\\n    average shortest path length of G. Lr is the average shortest path length\\n    of an equivalent random graph and Cl is the average clustering coefficient\\n    of an equivalent lattice graph.\\n\\n    The small-world coefficient (omega) measures how much G is like a lattice\\n    or a random graph. Negative values mean G is similar to a lattice whereas\\n    positive values mean G is a random graph.\\n    Values close to 0 mean that G has small-world characteristics.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        An undirected graph.\\n\\n    niter: integer (optional, default=5)\\n        Approximate number of rewiring per edge to compute the equivalent\\n        random graph.\\n\\n    nrand: integer (optional, default=10)\\n        Number of random graphs generated to compute the maximal clustering\\n        coefficient (Cr) and average shortest path length (Lr).\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n\\n    Returns\\n    -------\\n    omega : float\\n        The small-world coefficient (omega)\\n\\n    Notes\\n    -----\\n    The implementation is adapted from the algorithm by Telesford et al. [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Telesford, Joyce, Hayasaka, Burdette, and Laurienti (2011).\\n           \"The Ubiquity of Small-World Networks\".\\n           Brain Connectivity. 1 (0038): 367-75.  PMC 3604768. PMID 22432451.\\n           doi:10.1089/brain.2011.0038.\\n    '\n    import numpy as np\n    randMetrics = {'C': [], 'L': []}\n    Cl = nx.average_clustering(G)\n    niter_lattice_reference = niter\n    niter_random_reference = niter * 2\n    for _ in range(nrand):\n        Gr = random_reference(G, niter=niter_random_reference, seed=seed)\n        randMetrics['L'].append(nx.average_shortest_path_length(Gr))\n        Gl = lattice_reference(G, niter=niter_lattice_reference, seed=seed)\n        Cl_temp = nx.average_clustering(Gl)\n        if Cl_temp > Cl:\n            Cl = Cl_temp\n    C = nx.average_clustering(G)\n    L = nx.average_shortest_path_length(G)\n    Lr = np.mean(randMetrics['L'])\n    omega = Lr / L - C / Cl\n    return omega",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef omega(G, niter=5, nrand=10, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the small-world coefficient (omega) of a graph\\n\\n    The small-world coefficient of a graph G is:\\n\\n    omega = Lr/L - C/Cl\\n\\n    where C and L are respectively the average clustering coefficient and\\n    average shortest path length of G. Lr is the average shortest path length\\n    of an equivalent random graph and Cl is the average clustering coefficient\\n    of an equivalent lattice graph.\\n\\n    The small-world coefficient (omega) measures how much G is like a lattice\\n    or a random graph. Negative values mean G is similar to a lattice whereas\\n    positive values mean G is a random graph.\\n    Values close to 0 mean that G has small-world characteristics.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        An undirected graph.\\n\\n    niter: integer (optional, default=5)\\n        Approximate number of rewiring per edge to compute the equivalent\\n        random graph.\\n\\n    nrand: integer (optional, default=10)\\n        Number of random graphs generated to compute the maximal clustering\\n        coefficient (Cr) and average shortest path length (Lr).\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n\\n    Returns\\n    -------\\n    omega : float\\n        The small-world coefficient (omega)\\n\\n    Notes\\n    -----\\n    The implementation is adapted from the algorithm by Telesford et al. [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Telesford, Joyce, Hayasaka, Burdette, and Laurienti (2011).\\n           \"The Ubiquity of Small-World Networks\".\\n           Brain Connectivity. 1 (0038): 367-75.  PMC 3604768. PMID 22432451.\\n           doi:10.1089/brain.2011.0038.\\n    '\n    import numpy as np\n    randMetrics = {'C': [], 'L': []}\n    Cl = nx.average_clustering(G)\n    niter_lattice_reference = niter\n    niter_random_reference = niter * 2\n    for _ in range(nrand):\n        Gr = random_reference(G, niter=niter_random_reference, seed=seed)\n        randMetrics['L'].append(nx.average_shortest_path_length(Gr))\n        Gl = lattice_reference(G, niter=niter_lattice_reference, seed=seed)\n        Cl_temp = nx.average_clustering(Gl)\n        if Cl_temp > Cl:\n            Cl = Cl_temp\n    C = nx.average_clustering(G)\n    L = nx.average_shortest_path_length(G)\n    Lr = np.mean(randMetrics['L'])\n    omega = Lr / L - C / Cl\n    return omega",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef omega(G, niter=5, nrand=10, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the small-world coefficient (omega) of a graph\\n\\n    The small-world coefficient of a graph G is:\\n\\n    omega = Lr/L - C/Cl\\n\\n    where C and L are respectively the average clustering coefficient and\\n    average shortest path length of G. Lr is the average shortest path length\\n    of an equivalent random graph and Cl is the average clustering coefficient\\n    of an equivalent lattice graph.\\n\\n    The small-world coefficient (omega) measures how much G is like a lattice\\n    or a random graph. Negative values mean G is similar to a lattice whereas\\n    positive values mean G is a random graph.\\n    Values close to 0 mean that G has small-world characteristics.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        An undirected graph.\\n\\n    niter: integer (optional, default=5)\\n        Approximate number of rewiring per edge to compute the equivalent\\n        random graph.\\n\\n    nrand: integer (optional, default=10)\\n        Number of random graphs generated to compute the maximal clustering\\n        coefficient (Cr) and average shortest path length (Lr).\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n\\n    Returns\\n    -------\\n    omega : float\\n        The small-world coefficient (omega)\\n\\n    Notes\\n    -----\\n    The implementation is adapted from the algorithm by Telesford et al. [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Telesford, Joyce, Hayasaka, Burdette, and Laurienti (2011).\\n           \"The Ubiquity of Small-World Networks\".\\n           Brain Connectivity. 1 (0038): 367-75.  PMC 3604768. PMID 22432451.\\n           doi:10.1089/brain.2011.0038.\\n    '\n    import numpy as np\n    randMetrics = {'C': [], 'L': []}\n    Cl = nx.average_clustering(G)\n    niter_lattice_reference = niter\n    niter_random_reference = niter * 2\n    for _ in range(nrand):\n        Gr = random_reference(G, niter=niter_random_reference, seed=seed)\n        randMetrics['L'].append(nx.average_shortest_path_length(Gr))\n        Gl = lattice_reference(G, niter=niter_lattice_reference, seed=seed)\n        Cl_temp = nx.average_clustering(Gl)\n        if Cl_temp > Cl:\n            Cl = Cl_temp\n    C = nx.average_clustering(G)\n    L = nx.average_shortest_path_length(G)\n    Lr = np.mean(randMetrics['L'])\n    omega = Lr / L - C / Cl\n    return omega",
            "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@py_random_state(3)\n@nx._dispatch\ndef omega(G, niter=5, nrand=10, seed=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the small-world coefficient (omega) of a graph\\n\\n    The small-world coefficient of a graph G is:\\n\\n    omega = Lr/L - C/Cl\\n\\n    where C and L are respectively the average clustering coefficient and\\n    average shortest path length of G. Lr is the average shortest path length\\n    of an equivalent random graph and Cl is the average clustering coefficient\\n    of an equivalent lattice graph.\\n\\n    The small-world coefficient (omega) measures how much G is like a lattice\\n    or a random graph. Negative values mean G is similar to a lattice whereas\\n    positive values mean G is a random graph.\\n    Values close to 0 mean that G has small-world characteristics.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        An undirected graph.\\n\\n    niter: integer (optional, default=5)\\n        Approximate number of rewiring per edge to compute the equivalent\\n        random graph.\\n\\n    nrand: integer (optional, default=10)\\n        Number of random graphs generated to compute the maximal clustering\\n        coefficient (Cr) and average shortest path length (Lr).\\n\\n    seed : integer, random_state, or None (default)\\n        Indicator of random number generation state.\\n        See :ref:`Randomness<randomness>`.\\n\\n\\n    Returns\\n    -------\\n    omega : float\\n        The small-world coefficient (omega)\\n\\n    Notes\\n    -----\\n    The implementation is adapted from the algorithm by Telesford et al. [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Telesford, Joyce, Hayasaka, Burdette, and Laurienti (2011).\\n           \"The Ubiquity of Small-World Networks\".\\n           Brain Connectivity. 1 (0038): 367-75.  PMC 3604768. PMID 22432451.\\n           doi:10.1089/brain.2011.0038.\\n    '\n    import numpy as np\n    randMetrics = {'C': [], 'L': []}\n    Cl = nx.average_clustering(G)\n    niter_lattice_reference = niter\n    niter_random_reference = niter * 2\n    for _ in range(nrand):\n        Gr = random_reference(G, niter=niter_random_reference, seed=seed)\n        randMetrics['L'].append(nx.average_shortest_path_length(Gr))\n        Gl = lattice_reference(G, niter=niter_lattice_reference, seed=seed)\n        Cl_temp = nx.average_clustering(Gl)\n        if Cl_temp > Cl:\n            Cl = Cl_temp\n    C = nx.average_clustering(G)\n    L = nx.average_shortest_path_length(G)\n    Lr = np.mean(randMetrics['L'])\n    omega = Lr / L - C / Cl\n    return omega"
        ]
    }
]