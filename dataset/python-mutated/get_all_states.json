[
    {
        "func_name": "_get_subgames_states",
        "original": "def _get_subgames_states(state, all_states, depth_limit, depth, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered):\n    \"\"\"Extract non-chance states for a subgame into the all_states dict.\"\"\"\n    if state.is_terminal():\n        if include_terminals:\n            state_str = to_string(state)\n            if state_str not in all_states:\n                all_states[state_str] = state.clone()\n        return\n    if depth > depth_limit >= 0:\n        return\n    is_mean_field = state.current_player() == pyspiel.PlayerId.MEAN_FIELD\n    if state.is_chance_node() and include_chance_states or (is_mean_field and include_mean_field_states) or (not (state.is_chance_node() or is_mean_field)):\n        state_str = to_string(state)\n        if state_str not in all_states:\n            all_states[state_str] = state.clone()\n        elif stop_if_encountered:\n            return\n    if is_mean_field:\n        support = state.distribution_support()\n        state_for_search = state.clone()\n        support_length = len(support)\n        state_for_search.update_distribution([1.0 / support_length for _ in range(support_length)])\n        _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)\n    elif state.is_simultaneous_node():\n        joint_legal_actions = [state.legal_actions(player) for player in range(state.get_game().num_players())]\n        for joint_actions in itertools.product(*joint_legal_actions):\n            state_for_search = state.clone()\n            state_for_search.apply_actions(list(joint_actions))\n            _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)\n    else:\n        for action in state.legal_actions():\n            state_for_search = state.child(action)\n            _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)",
        "mutated": [
            "def _get_subgames_states(state, all_states, depth_limit, depth, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered):\n    if False:\n        i = 10\n    'Extract non-chance states for a subgame into the all_states dict.'\n    if state.is_terminal():\n        if include_terminals:\n            state_str = to_string(state)\n            if state_str not in all_states:\n                all_states[state_str] = state.clone()\n        return\n    if depth > depth_limit >= 0:\n        return\n    is_mean_field = state.current_player() == pyspiel.PlayerId.MEAN_FIELD\n    if state.is_chance_node() and include_chance_states or (is_mean_field and include_mean_field_states) or (not (state.is_chance_node() or is_mean_field)):\n        state_str = to_string(state)\n        if state_str not in all_states:\n            all_states[state_str] = state.clone()\n        elif stop_if_encountered:\n            return\n    if is_mean_field:\n        support = state.distribution_support()\n        state_for_search = state.clone()\n        support_length = len(support)\n        state_for_search.update_distribution([1.0 / support_length for _ in range(support_length)])\n        _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)\n    elif state.is_simultaneous_node():\n        joint_legal_actions = [state.legal_actions(player) for player in range(state.get_game().num_players())]\n        for joint_actions in itertools.product(*joint_legal_actions):\n            state_for_search = state.clone()\n            state_for_search.apply_actions(list(joint_actions))\n            _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)\n    else:\n        for action in state.legal_actions():\n            state_for_search = state.child(action)\n            _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)",
            "def _get_subgames_states(state, all_states, depth_limit, depth, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Extract non-chance states for a subgame into the all_states dict.'\n    if state.is_terminal():\n        if include_terminals:\n            state_str = to_string(state)\n            if state_str not in all_states:\n                all_states[state_str] = state.clone()\n        return\n    if depth > depth_limit >= 0:\n        return\n    is_mean_field = state.current_player() == pyspiel.PlayerId.MEAN_FIELD\n    if state.is_chance_node() and include_chance_states or (is_mean_field and include_mean_field_states) or (not (state.is_chance_node() or is_mean_field)):\n        state_str = to_string(state)\n        if state_str not in all_states:\n            all_states[state_str] = state.clone()\n        elif stop_if_encountered:\n            return\n    if is_mean_field:\n        support = state.distribution_support()\n        state_for_search = state.clone()\n        support_length = len(support)\n        state_for_search.update_distribution([1.0 / support_length for _ in range(support_length)])\n        _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)\n    elif state.is_simultaneous_node():\n        joint_legal_actions = [state.legal_actions(player) for player in range(state.get_game().num_players())]\n        for joint_actions in itertools.product(*joint_legal_actions):\n            state_for_search = state.clone()\n            state_for_search.apply_actions(list(joint_actions))\n            _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)\n    else:\n        for action in state.legal_actions():\n            state_for_search = state.child(action)\n            _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)",
            "def _get_subgames_states(state, all_states, depth_limit, depth, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Extract non-chance states for a subgame into the all_states dict.'\n    if state.is_terminal():\n        if include_terminals:\n            state_str = to_string(state)\n            if state_str not in all_states:\n                all_states[state_str] = state.clone()\n        return\n    if depth > depth_limit >= 0:\n        return\n    is_mean_field = state.current_player() == pyspiel.PlayerId.MEAN_FIELD\n    if state.is_chance_node() and include_chance_states or (is_mean_field and include_mean_field_states) or (not (state.is_chance_node() or is_mean_field)):\n        state_str = to_string(state)\n        if state_str not in all_states:\n            all_states[state_str] = state.clone()\n        elif stop_if_encountered:\n            return\n    if is_mean_field:\n        support = state.distribution_support()\n        state_for_search = state.clone()\n        support_length = len(support)\n        state_for_search.update_distribution([1.0 / support_length for _ in range(support_length)])\n        _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)\n    elif state.is_simultaneous_node():\n        joint_legal_actions = [state.legal_actions(player) for player in range(state.get_game().num_players())]\n        for joint_actions in itertools.product(*joint_legal_actions):\n            state_for_search = state.clone()\n            state_for_search.apply_actions(list(joint_actions))\n            _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)\n    else:\n        for action in state.legal_actions():\n            state_for_search = state.child(action)\n            _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)",
            "def _get_subgames_states(state, all_states, depth_limit, depth, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Extract non-chance states for a subgame into the all_states dict.'\n    if state.is_terminal():\n        if include_terminals:\n            state_str = to_string(state)\n            if state_str not in all_states:\n                all_states[state_str] = state.clone()\n        return\n    if depth > depth_limit >= 0:\n        return\n    is_mean_field = state.current_player() == pyspiel.PlayerId.MEAN_FIELD\n    if state.is_chance_node() and include_chance_states or (is_mean_field and include_mean_field_states) or (not (state.is_chance_node() or is_mean_field)):\n        state_str = to_string(state)\n        if state_str not in all_states:\n            all_states[state_str] = state.clone()\n        elif stop_if_encountered:\n            return\n    if is_mean_field:\n        support = state.distribution_support()\n        state_for_search = state.clone()\n        support_length = len(support)\n        state_for_search.update_distribution([1.0 / support_length for _ in range(support_length)])\n        _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)\n    elif state.is_simultaneous_node():\n        joint_legal_actions = [state.legal_actions(player) for player in range(state.get_game().num_players())]\n        for joint_actions in itertools.product(*joint_legal_actions):\n            state_for_search = state.clone()\n            state_for_search.apply_actions(list(joint_actions))\n            _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)\n    else:\n        for action in state.legal_actions():\n            state_for_search = state.child(action)\n            _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)",
            "def _get_subgames_states(state, all_states, depth_limit, depth, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Extract non-chance states for a subgame into the all_states dict.'\n    if state.is_terminal():\n        if include_terminals:\n            state_str = to_string(state)\n            if state_str not in all_states:\n                all_states[state_str] = state.clone()\n        return\n    if depth > depth_limit >= 0:\n        return\n    is_mean_field = state.current_player() == pyspiel.PlayerId.MEAN_FIELD\n    if state.is_chance_node() and include_chance_states or (is_mean_field and include_mean_field_states) or (not (state.is_chance_node() or is_mean_field)):\n        state_str = to_string(state)\n        if state_str not in all_states:\n            all_states[state_str] = state.clone()\n        elif stop_if_encountered:\n            return\n    if is_mean_field:\n        support = state.distribution_support()\n        state_for_search = state.clone()\n        support_length = len(support)\n        state_for_search.update_distribution([1.0 / support_length for _ in range(support_length)])\n        _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)\n    elif state.is_simultaneous_node():\n        joint_legal_actions = [state.legal_actions(player) for player in range(state.get_game().num_players())]\n        for joint_actions in itertools.product(*joint_legal_actions):\n            state_for_search = state.clone()\n            state_for_search.apply_actions(list(joint_actions))\n            _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)\n    else:\n        for action in state.legal_actions():\n            state_for_search = state.child(action)\n            _get_subgames_states(state_for_search, all_states, depth_limit, depth + 1, include_terminals, include_chance_states, include_mean_field_states, to_string, stop_if_encountered)"
        ]
    },
    {
        "func_name": "get_all_states",
        "original": "def get_all_states(game, depth_limit=-1, include_terminals=True, include_chance_states=False, include_mean_field_states=False, to_string=lambda s: s.history_str(), stop_if_encountered=True):\n    \"\"\"Gets all states in the game, indexed by their string representation.\n\n  For small games only! Useful for methods that solve the  games explicitly,\n  i.e. value iteration. Use this default implementation with caution as it does\n  a recursive tree walk of the game and could easily fill up memory for larger\n  games or games with long horizons.\n\n  Currently only works for sequential games.\n\n  Arguments:\n    game: The game to analyze, as returned by `load_game`.\n    depth_limit: How deeply to analyze the game tree. Negative means no limit, 0\n      means root-only, etc.\n    include_terminals: If True, include terminal states.\n    include_chance_states: If True, include chance node states.\n    include_mean_field_states: If True, include mean field node states.\n    to_string: The serialization function. We expect this to be\n      `lambda s: s.history_str()` as this enforces perfect recall, but for\n        historical reasons, using `str` is also supported, but the goal is to\n        remove this argument.\n    stop_if_encountered: if this is set, do not keep recursively adding states\n      if this state is already in the list. This allows support for games that\n      have cycles.\n\n  Returns:\n    A `dict` with `to_string(state)` keys and `pyspiel.State` values containing\n    all states encountered traversing the game tree up to the specified depth.\n  \"\"\"\n    root_states = game.new_initial_states()\n    all_states = dict()\n    for root in root_states:\n        _get_subgames_states(state=root, all_states=all_states, depth_limit=depth_limit, depth=0, include_terminals=include_terminals, include_chance_states=include_chance_states, include_mean_field_states=include_mean_field_states, to_string=to_string, stop_if_encountered=stop_if_encountered)\n    if not all_states:\n        raise ValueError('GetSubgameStates returned 0 states!')\n    return all_states",
        "mutated": [
            "def get_all_states(game, depth_limit=-1, include_terminals=True, include_chance_states=False, include_mean_field_states=False, to_string=lambda s: s.history_str(), stop_if_encountered=True):\n    if False:\n        i = 10\n    'Gets all states in the game, indexed by their string representation.\\n\\n  For small games only! Useful for methods that solve the  games explicitly,\\n  i.e. value iteration. Use this default implementation with caution as it does\\n  a recursive tree walk of the game and could easily fill up memory for larger\\n  games or games with long horizons.\\n\\n  Currently only works for sequential games.\\n\\n  Arguments:\\n    game: The game to analyze, as returned by `load_game`.\\n    depth_limit: How deeply to analyze the game tree. Negative means no limit, 0\\n      means root-only, etc.\\n    include_terminals: If True, include terminal states.\\n    include_chance_states: If True, include chance node states.\\n    include_mean_field_states: If True, include mean field node states.\\n    to_string: The serialization function. We expect this to be\\n      `lambda s: s.history_str()` as this enforces perfect recall, but for\\n        historical reasons, using `str` is also supported, but the goal is to\\n        remove this argument.\\n    stop_if_encountered: if this is set, do not keep recursively adding states\\n      if this state is already in the list. This allows support for games that\\n      have cycles.\\n\\n  Returns:\\n    A `dict` with `to_string(state)` keys and `pyspiel.State` values containing\\n    all states encountered traversing the game tree up to the specified depth.\\n  '\n    root_states = game.new_initial_states()\n    all_states = dict()\n    for root in root_states:\n        _get_subgames_states(state=root, all_states=all_states, depth_limit=depth_limit, depth=0, include_terminals=include_terminals, include_chance_states=include_chance_states, include_mean_field_states=include_mean_field_states, to_string=to_string, stop_if_encountered=stop_if_encountered)\n    if not all_states:\n        raise ValueError('GetSubgameStates returned 0 states!')\n    return all_states",
            "def get_all_states(game, depth_limit=-1, include_terminals=True, include_chance_states=False, include_mean_field_states=False, to_string=lambda s: s.history_str(), stop_if_encountered=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Gets all states in the game, indexed by their string representation.\\n\\n  For small games only! Useful for methods that solve the  games explicitly,\\n  i.e. value iteration. Use this default implementation with caution as it does\\n  a recursive tree walk of the game and could easily fill up memory for larger\\n  games or games with long horizons.\\n\\n  Currently only works for sequential games.\\n\\n  Arguments:\\n    game: The game to analyze, as returned by `load_game`.\\n    depth_limit: How deeply to analyze the game tree. Negative means no limit, 0\\n      means root-only, etc.\\n    include_terminals: If True, include terminal states.\\n    include_chance_states: If True, include chance node states.\\n    include_mean_field_states: If True, include mean field node states.\\n    to_string: The serialization function. We expect this to be\\n      `lambda s: s.history_str()` as this enforces perfect recall, but for\\n        historical reasons, using `str` is also supported, but the goal is to\\n        remove this argument.\\n    stop_if_encountered: if this is set, do not keep recursively adding states\\n      if this state is already in the list. This allows support for games that\\n      have cycles.\\n\\n  Returns:\\n    A `dict` with `to_string(state)` keys and `pyspiel.State` values containing\\n    all states encountered traversing the game tree up to the specified depth.\\n  '\n    root_states = game.new_initial_states()\n    all_states = dict()\n    for root in root_states:\n        _get_subgames_states(state=root, all_states=all_states, depth_limit=depth_limit, depth=0, include_terminals=include_terminals, include_chance_states=include_chance_states, include_mean_field_states=include_mean_field_states, to_string=to_string, stop_if_encountered=stop_if_encountered)\n    if not all_states:\n        raise ValueError('GetSubgameStates returned 0 states!')\n    return all_states",
            "def get_all_states(game, depth_limit=-1, include_terminals=True, include_chance_states=False, include_mean_field_states=False, to_string=lambda s: s.history_str(), stop_if_encountered=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Gets all states in the game, indexed by their string representation.\\n\\n  For small games only! Useful for methods that solve the  games explicitly,\\n  i.e. value iteration. Use this default implementation with caution as it does\\n  a recursive tree walk of the game and could easily fill up memory for larger\\n  games or games with long horizons.\\n\\n  Currently only works for sequential games.\\n\\n  Arguments:\\n    game: The game to analyze, as returned by `load_game`.\\n    depth_limit: How deeply to analyze the game tree. Negative means no limit, 0\\n      means root-only, etc.\\n    include_terminals: If True, include terminal states.\\n    include_chance_states: If True, include chance node states.\\n    include_mean_field_states: If True, include mean field node states.\\n    to_string: The serialization function. We expect this to be\\n      `lambda s: s.history_str()` as this enforces perfect recall, but for\\n        historical reasons, using `str` is also supported, but the goal is to\\n        remove this argument.\\n    stop_if_encountered: if this is set, do not keep recursively adding states\\n      if this state is already in the list. This allows support for games that\\n      have cycles.\\n\\n  Returns:\\n    A `dict` with `to_string(state)` keys and `pyspiel.State` values containing\\n    all states encountered traversing the game tree up to the specified depth.\\n  '\n    root_states = game.new_initial_states()\n    all_states = dict()\n    for root in root_states:\n        _get_subgames_states(state=root, all_states=all_states, depth_limit=depth_limit, depth=0, include_terminals=include_terminals, include_chance_states=include_chance_states, include_mean_field_states=include_mean_field_states, to_string=to_string, stop_if_encountered=stop_if_encountered)\n    if not all_states:\n        raise ValueError('GetSubgameStates returned 0 states!')\n    return all_states",
            "def get_all_states(game, depth_limit=-1, include_terminals=True, include_chance_states=False, include_mean_field_states=False, to_string=lambda s: s.history_str(), stop_if_encountered=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Gets all states in the game, indexed by their string representation.\\n\\n  For small games only! Useful for methods that solve the  games explicitly,\\n  i.e. value iteration. Use this default implementation with caution as it does\\n  a recursive tree walk of the game and could easily fill up memory for larger\\n  games or games with long horizons.\\n\\n  Currently only works for sequential games.\\n\\n  Arguments:\\n    game: The game to analyze, as returned by `load_game`.\\n    depth_limit: How deeply to analyze the game tree. Negative means no limit, 0\\n      means root-only, etc.\\n    include_terminals: If True, include terminal states.\\n    include_chance_states: If True, include chance node states.\\n    include_mean_field_states: If True, include mean field node states.\\n    to_string: The serialization function. We expect this to be\\n      `lambda s: s.history_str()` as this enforces perfect recall, but for\\n        historical reasons, using `str` is also supported, but the goal is to\\n        remove this argument.\\n    stop_if_encountered: if this is set, do not keep recursively adding states\\n      if this state is already in the list. This allows support for games that\\n      have cycles.\\n\\n  Returns:\\n    A `dict` with `to_string(state)` keys and `pyspiel.State` values containing\\n    all states encountered traversing the game tree up to the specified depth.\\n  '\n    root_states = game.new_initial_states()\n    all_states = dict()\n    for root in root_states:\n        _get_subgames_states(state=root, all_states=all_states, depth_limit=depth_limit, depth=0, include_terminals=include_terminals, include_chance_states=include_chance_states, include_mean_field_states=include_mean_field_states, to_string=to_string, stop_if_encountered=stop_if_encountered)\n    if not all_states:\n        raise ValueError('GetSubgameStates returned 0 states!')\n    return all_states",
            "def get_all_states(game, depth_limit=-1, include_terminals=True, include_chance_states=False, include_mean_field_states=False, to_string=lambda s: s.history_str(), stop_if_encountered=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Gets all states in the game, indexed by their string representation.\\n\\n  For small games only! Useful for methods that solve the  games explicitly,\\n  i.e. value iteration. Use this default implementation with caution as it does\\n  a recursive tree walk of the game and could easily fill up memory for larger\\n  games or games with long horizons.\\n\\n  Currently only works for sequential games.\\n\\n  Arguments:\\n    game: The game to analyze, as returned by `load_game`.\\n    depth_limit: How deeply to analyze the game tree. Negative means no limit, 0\\n      means root-only, etc.\\n    include_terminals: If True, include terminal states.\\n    include_chance_states: If True, include chance node states.\\n    include_mean_field_states: If True, include mean field node states.\\n    to_string: The serialization function. We expect this to be\\n      `lambda s: s.history_str()` as this enforces perfect recall, but for\\n        historical reasons, using `str` is also supported, but the goal is to\\n        remove this argument.\\n    stop_if_encountered: if this is set, do not keep recursively adding states\\n      if this state is already in the list. This allows support for games that\\n      have cycles.\\n\\n  Returns:\\n    A `dict` with `to_string(state)` keys and `pyspiel.State` values containing\\n    all states encountered traversing the game tree up to the specified depth.\\n  '\n    root_states = game.new_initial_states()\n    all_states = dict()\n    for root in root_states:\n        _get_subgames_states(state=root, all_states=all_states, depth_limit=depth_limit, depth=0, include_terminals=include_terminals, include_chance_states=include_chance_states, include_mean_field_states=include_mean_field_states, to_string=to_string, stop_if_encountered=stop_if_encountered)\n    if not all_states:\n        raise ValueError('GetSubgameStates returned 0 states!')\n    return all_states"
        ]
    }
]