[
    {
        "func_name": "__init__",
        "original": "def __init__(self, window_size=8, max_gap=30):\n    \"\"\"Superimpose one set of atoms onto another using structural data.\n\n        Structures are superimposed using guide atoms, CA and C4', for protein\n        and nucleic acid molecules respectively.\n\n        Parameters\n        ----------\n        window_size : float, optional\n            CE algorithm parameter. Used to define paths when building the\n            CE similarity matrix. Default is 8.\n        max_gap : float, optional\n            CE algorithm parameter. Maximum gap size. Default is 30.\n        \"\"\"\n    assert window_size > 0, 'window_size must be greater than 0'\n    assert max_gap >= 0, 'max_gap must be positive (or zero)'\n    self.window_size = window_size\n    self.max_gap = max_gap\n    self.rms = None",
        "mutated": [
            "def __init__(self, window_size=8, max_gap=30):\n    if False:\n        i = 10\n    \"Superimpose one set of atoms onto another using structural data.\\n\\n        Structures are superimposed using guide atoms, CA and C4', for protein\\n        and nucleic acid molecules respectively.\\n\\n        Parameters\\n        ----------\\n        window_size : float, optional\\n            CE algorithm parameter. Used to define paths when building the\\n            CE similarity matrix. Default is 8.\\n        max_gap : float, optional\\n            CE algorithm parameter. Maximum gap size. Default is 30.\\n        \"\n    assert window_size > 0, 'window_size must be greater than 0'\n    assert max_gap >= 0, 'max_gap must be positive (or zero)'\n    self.window_size = window_size\n    self.max_gap = max_gap\n    self.rms = None",
            "def __init__(self, window_size=8, max_gap=30):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Superimpose one set of atoms onto another using structural data.\\n\\n        Structures are superimposed using guide atoms, CA and C4', for protein\\n        and nucleic acid molecules respectively.\\n\\n        Parameters\\n        ----------\\n        window_size : float, optional\\n            CE algorithm parameter. Used to define paths when building the\\n            CE similarity matrix. Default is 8.\\n        max_gap : float, optional\\n            CE algorithm parameter. Maximum gap size. Default is 30.\\n        \"\n    assert window_size > 0, 'window_size must be greater than 0'\n    assert max_gap >= 0, 'max_gap must be positive (or zero)'\n    self.window_size = window_size\n    self.max_gap = max_gap\n    self.rms = None",
            "def __init__(self, window_size=8, max_gap=30):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Superimpose one set of atoms onto another using structural data.\\n\\n        Structures are superimposed using guide atoms, CA and C4', for protein\\n        and nucleic acid molecules respectively.\\n\\n        Parameters\\n        ----------\\n        window_size : float, optional\\n            CE algorithm parameter. Used to define paths when building the\\n            CE similarity matrix. Default is 8.\\n        max_gap : float, optional\\n            CE algorithm parameter. Maximum gap size. Default is 30.\\n        \"\n    assert window_size > 0, 'window_size must be greater than 0'\n    assert max_gap >= 0, 'max_gap must be positive (or zero)'\n    self.window_size = window_size\n    self.max_gap = max_gap\n    self.rms = None",
            "def __init__(self, window_size=8, max_gap=30):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Superimpose one set of atoms onto another using structural data.\\n\\n        Structures are superimposed using guide atoms, CA and C4', for protein\\n        and nucleic acid molecules respectively.\\n\\n        Parameters\\n        ----------\\n        window_size : float, optional\\n            CE algorithm parameter. Used to define paths when building the\\n            CE similarity matrix. Default is 8.\\n        max_gap : float, optional\\n            CE algorithm parameter. Maximum gap size. Default is 30.\\n        \"\n    assert window_size > 0, 'window_size must be greater than 0'\n    assert max_gap >= 0, 'max_gap must be positive (or zero)'\n    self.window_size = window_size\n    self.max_gap = max_gap\n    self.rms = None",
            "def __init__(self, window_size=8, max_gap=30):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Superimpose one set of atoms onto another using structural data.\\n\\n        Structures are superimposed using guide atoms, CA and C4', for protein\\n        and nucleic acid molecules respectively.\\n\\n        Parameters\\n        ----------\\n        window_size : float, optional\\n            CE algorithm parameter. Used to define paths when building the\\n            CE similarity matrix. Default is 8.\\n        max_gap : float, optional\\n            CE algorithm parameter. Maximum gap size. Default is 30.\\n        \"\n    assert window_size > 0, 'window_size must be greater than 0'\n    assert max_gap >= 0, 'max_gap must be positive (or zero)'\n    self.window_size = window_size\n    self.max_gap = max_gap\n    self.rms = None"
        ]
    },
    {
        "func_name": "get_guide_coord_from_structure",
        "original": "def get_guide_coord_from_structure(self, structure):\n    \"\"\"Return the coordinates of guide atoms in the structure.\n\n        We use guide atoms (C-alpha and C4' atoms) since it is much faster than\n        using all atoms in the calculation without a significant loss in\n        accuracy.\n        \"\"\"\n    coords = []\n    for chain in sorted(structure.get_chains()):\n        for resid in sorted(chain, key=_RESID_SORTER):\n            if 'CA' in resid:\n                coords.append(resid['CA'].coord.tolist())\n            elif \"C4'\" in resid:\n                coords.append(resid[\"C4'\"].coord.tolist())\n    if not coords:\n        msg = f'Structure {structure.id} does not have any guide atoms.'\n        raise PDBException(msg)\n    return coords",
        "mutated": [
            "def get_guide_coord_from_structure(self, structure):\n    if False:\n        i = 10\n    \"Return the coordinates of guide atoms in the structure.\\n\\n        We use guide atoms (C-alpha and C4' atoms) since it is much faster than\\n        using all atoms in the calculation without a significant loss in\\n        accuracy.\\n        \"\n    coords = []\n    for chain in sorted(structure.get_chains()):\n        for resid in sorted(chain, key=_RESID_SORTER):\n            if 'CA' in resid:\n                coords.append(resid['CA'].coord.tolist())\n            elif \"C4'\" in resid:\n                coords.append(resid[\"C4'\"].coord.tolist())\n    if not coords:\n        msg = f'Structure {structure.id} does not have any guide atoms.'\n        raise PDBException(msg)\n    return coords",
            "def get_guide_coord_from_structure(self, structure):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return the coordinates of guide atoms in the structure.\\n\\n        We use guide atoms (C-alpha and C4' atoms) since it is much faster than\\n        using all atoms in the calculation without a significant loss in\\n        accuracy.\\n        \"\n    coords = []\n    for chain in sorted(structure.get_chains()):\n        for resid in sorted(chain, key=_RESID_SORTER):\n            if 'CA' in resid:\n                coords.append(resid['CA'].coord.tolist())\n            elif \"C4'\" in resid:\n                coords.append(resid[\"C4'\"].coord.tolist())\n    if not coords:\n        msg = f'Structure {structure.id} does not have any guide atoms.'\n        raise PDBException(msg)\n    return coords",
            "def get_guide_coord_from_structure(self, structure):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return the coordinates of guide atoms in the structure.\\n\\n        We use guide atoms (C-alpha and C4' atoms) since it is much faster than\\n        using all atoms in the calculation without a significant loss in\\n        accuracy.\\n        \"\n    coords = []\n    for chain in sorted(structure.get_chains()):\n        for resid in sorted(chain, key=_RESID_SORTER):\n            if 'CA' in resid:\n                coords.append(resid['CA'].coord.tolist())\n            elif \"C4'\" in resid:\n                coords.append(resid[\"C4'\"].coord.tolist())\n    if not coords:\n        msg = f'Structure {structure.id} does not have any guide atoms.'\n        raise PDBException(msg)\n    return coords",
            "def get_guide_coord_from_structure(self, structure):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return the coordinates of guide atoms in the structure.\\n\\n        We use guide atoms (C-alpha and C4' atoms) since it is much faster than\\n        using all atoms in the calculation without a significant loss in\\n        accuracy.\\n        \"\n    coords = []\n    for chain in sorted(structure.get_chains()):\n        for resid in sorted(chain, key=_RESID_SORTER):\n            if 'CA' in resid:\n                coords.append(resid['CA'].coord.tolist())\n            elif \"C4'\" in resid:\n                coords.append(resid[\"C4'\"].coord.tolist())\n    if not coords:\n        msg = f'Structure {structure.id} does not have any guide atoms.'\n        raise PDBException(msg)\n    return coords",
            "def get_guide_coord_from_structure(self, structure):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return the coordinates of guide atoms in the structure.\\n\\n        We use guide atoms (C-alpha and C4' atoms) since it is much faster than\\n        using all atoms in the calculation without a significant loss in\\n        accuracy.\\n        \"\n    coords = []\n    for chain in sorted(structure.get_chains()):\n        for resid in sorted(chain, key=_RESID_SORTER):\n            if 'CA' in resid:\n                coords.append(resid['CA'].coord.tolist())\n            elif \"C4'\" in resid:\n                coords.append(resid[\"C4'\"].coord.tolist())\n    if not coords:\n        msg = f'Structure {structure.id} does not have any guide atoms.'\n        raise PDBException(msg)\n    return coords"
        ]
    },
    {
        "func_name": "set_reference",
        "original": "def set_reference(self, structure):\n    \"\"\"Define a reference structure onto which all others will be aligned.\"\"\"\n    self.refcoord = self.get_guide_coord_from_structure(structure)\n    if len(self.refcoord) < self.window_size * 2:\n        n_atoms = len(self.refcoord)\n        msg = f'Too few atoms in the reference structure ({n_atoms}). Try reducing the window_size parameter.'\n        raise PDBException(msg)",
        "mutated": [
            "def set_reference(self, structure):\n    if False:\n        i = 10\n    'Define a reference structure onto which all others will be aligned.'\n    self.refcoord = self.get_guide_coord_from_structure(structure)\n    if len(self.refcoord) < self.window_size * 2:\n        n_atoms = len(self.refcoord)\n        msg = f'Too few atoms in the reference structure ({n_atoms}). Try reducing the window_size parameter.'\n        raise PDBException(msg)",
            "def set_reference(self, structure):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Define a reference structure onto which all others will be aligned.'\n    self.refcoord = self.get_guide_coord_from_structure(structure)\n    if len(self.refcoord) < self.window_size * 2:\n        n_atoms = len(self.refcoord)\n        msg = f'Too few atoms in the reference structure ({n_atoms}). Try reducing the window_size parameter.'\n        raise PDBException(msg)",
            "def set_reference(self, structure):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Define a reference structure onto which all others will be aligned.'\n    self.refcoord = self.get_guide_coord_from_structure(structure)\n    if len(self.refcoord) < self.window_size * 2:\n        n_atoms = len(self.refcoord)\n        msg = f'Too few atoms in the reference structure ({n_atoms}). Try reducing the window_size parameter.'\n        raise PDBException(msg)",
            "def set_reference(self, structure):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Define a reference structure onto which all others will be aligned.'\n    self.refcoord = self.get_guide_coord_from_structure(structure)\n    if len(self.refcoord) < self.window_size * 2:\n        n_atoms = len(self.refcoord)\n        msg = f'Too few atoms in the reference structure ({n_atoms}). Try reducing the window_size parameter.'\n        raise PDBException(msg)",
            "def set_reference(self, structure):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Define a reference structure onto which all others will be aligned.'\n    self.refcoord = self.get_guide_coord_from_structure(structure)\n    if len(self.refcoord) < self.window_size * 2:\n        n_atoms = len(self.refcoord)\n        msg = f'Too few atoms in the reference structure ({n_atoms}). Try reducing the window_size parameter.'\n        raise PDBException(msg)"
        ]
    },
    {
        "func_name": "align",
        "original": "def align(self, structure, transform=True):\n    \"\"\"Align the input structure onto the reference structure.\n\n        Parameters\n        ----------\n        transform: bool, optional\n            If True (default), apply the rotation/translation that minimizes\n            the RMSD between the two structures to the input structure. If\n            False, the structure is not modified but the optimal RMSD will\n            still be calculated.\n        \"\"\"\n    self.rms = None\n    coord = self.get_guide_coord_from_structure(structure)\n    if len(coord) < self.window_size * 2:\n        n_atoms = len(coord)\n        msg = f'Too few atoms in the mobile structure ({n_atoms}). Try reducing the window_size parameter.'\n        raise PDBException(msg)\n    paths = run_cealign(self.refcoord, coord, self.window_size, self.max_gap)\n    unique_paths = {(tuple(pA), tuple(pB)) for (pA, pB) in paths}\n    (best_rmsd, best_u) = (1000000.0, None)\n    for u_path in unique_paths:\n        (idxA, idxB) = u_path\n        coordsA = np.array([self.refcoord[i] for i in idxA])\n        coordsB = np.array([coord[i] for i in idxB])\n        aln = QCPSuperimposer()\n        aln.set(coordsA, coordsB)\n        aln.run()\n        if aln.rms < best_rmsd:\n            best_rmsd = aln.rms\n            best_u = (aln.rot, aln.tran)\n    if best_u is None:\n        raise RuntimeError('Failed to find a suitable alignment.')\n    if transform:\n        (rotmtx, trvec) = best_u\n        for chain in structure.get_chains():\n            for resid in chain.get_unpacked_list():\n                for atom in resid.get_unpacked_list():\n                    atom.transform(rotmtx, trvec)\n    self.rms = best_rmsd",
        "mutated": [
            "def align(self, structure, transform=True):\n    if False:\n        i = 10\n    'Align the input structure onto the reference structure.\\n\\n        Parameters\\n        ----------\\n        transform: bool, optional\\n            If True (default), apply the rotation/translation that minimizes\\n            the RMSD between the two structures to the input structure. If\\n            False, the structure is not modified but the optimal RMSD will\\n            still be calculated.\\n        '\n    self.rms = None\n    coord = self.get_guide_coord_from_structure(structure)\n    if len(coord) < self.window_size * 2:\n        n_atoms = len(coord)\n        msg = f'Too few atoms in the mobile structure ({n_atoms}). Try reducing the window_size parameter.'\n        raise PDBException(msg)\n    paths = run_cealign(self.refcoord, coord, self.window_size, self.max_gap)\n    unique_paths = {(tuple(pA), tuple(pB)) for (pA, pB) in paths}\n    (best_rmsd, best_u) = (1000000.0, None)\n    for u_path in unique_paths:\n        (idxA, idxB) = u_path\n        coordsA = np.array([self.refcoord[i] for i in idxA])\n        coordsB = np.array([coord[i] for i in idxB])\n        aln = QCPSuperimposer()\n        aln.set(coordsA, coordsB)\n        aln.run()\n        if aln.rms < best_rmsd:\n            best_rmsd = aln.rms\n            best_u = (aln.rot, aln.tran)\n    if best_u is None:\n        raise RuntimeError('Failed to find a suitable alignment.')\n    if transform:\n        (rotmtx, trvec) = best_u\n        for chain in structure.get_chains():\n            for resid in chain.get_unpacked_list():\n                for atom in resid.get_unpacked_list():\n                    atom.transform(rotmtx, trvec)\n    self.rms = best_rmsd",
            "def align(self, structure, transform=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Align the input structure onto the reference structure.\\n\\n        Parameters\\n        ----------\\n        transform: bool, optional\\n            If True (default), apply the rotation/translation that minimizes\\n            the RMSD between the two structures to the input structure. If\\n            False, the structure is not modified but the optimal RMSD will\\n            still be calculated.\\n        '\n    self.rms = None\n    coord = self.get_guide_coord_from_structure(structure)\n    if len(coord) < self.window_size * 2:\n        n_atoms = len(coord)\n        msg = f'Too few atoms in the mobile structure ({n_atoms}). Try reducing the window_size parameter.'\n        raise PDBException(msg)\n    paths = run_cealign(self.refcoord, coord, self.window_size, self.max_gap)\n    unique_paths = {(tuple(pA), tuple(pB)) for (pA, pB) in paths}\n    (best_rmsd, best_u) = (1000000.0, None)\n    for u_path in unique_paths:\n        (idxA, idxB) = u_path\n        coordsA = np.array([self.refcoord[i] for i in idxA])\n        coordsB = np.array([coord[i] for i in idxB])\n        aln = QCPSuperimposer()\n        aln.set(coordsA, coordsB)\n        aln.run()\n        if aln.rms < best_rmsd:\n            best_rmsd = aln.rms\n            best_u = (aln.rot, aln.tran)\n    if best_u is None:\n        raise RuntimeError('Failed to find a suitable alignment.')\n    if transform:\n        (rotmtx, trvec) = best_u\n        for chain in structure.get_chains():\n            for resid in chain.get_unpacked_list():\n                for atom in resid.get_unpacked_list():\n                    atom.transform(rotmtx, trvec)\n    self.rms = best_rmsd",
            "def align(self, structure, transform=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Align the input structure onto the reference structure.\\n\\n        Parameters\\n        ----------\\n        transform: bool, optional\\n            If True (default), apply the rotation/translation that minimizes\\n            the RMSD between the two structures to the input structure. If\\n            False, the structure is not modified but the optimal RMSD will\\n            still be calculated.\\n        '\n    self.rms = None\n    coord = self.get_guide_coord_from_structure(structure)\n    if len(coord) < self.window_size * 2:\n        n_atoms = len(coord)\n        msg = f'Too few atoms in the mobile structure ({n_atoms}). Try reducing the window_size parameter.'\n        raise PDBException(msg)\n    paths = run_cealign(self.refcoord, coord, self.window_size, self.max_gap)\n    unique_paths = {(tuple(pA), tuple(pB)) for (pA, pB) in paths}\n    (best_rmsd, best_u) = (1000000.0, None)\n    for u_path in unique_paths:\n        (idxA, idxB) = u_path\n        coordsA = np.array([self.refcoord[i] for i in idxA])\n        coordsB = np.array([coord[i] for i in idxB])\n        aln = QCPSuperimposer()\n        aln.set(coordsA, coordsB)\n        aln.run()\n        if aln.rms < best_rmsd:\n            best_rmsd = aln.rms\n            best_u = (aln.rot, aln.tran)\n    if best_u is None:\n        raise RuntimeError('Failed to find a suitable alignment.')\n    if transform:\n        (rotmtx, trvec) = best_u\n        for chain in structure.get_chains():\n            for resid in chain.get_unpacked_list():\n                for atom in resid.get_unpacked_list():\n                    atom.transform(rotmtx, trvec)\n    self.rms = best_rmsd",
            "def align(self, structure, transform=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Align the input structure onto the reference structure.\\n\\n        Parameters\\n        ----------\\n        transform: bool, optional\\n            If True (default), apply the rotation/translation that minimizes\\n            the RMSD between the two structures to the input structure. If\\n            False, the structure is not modified but the optimal RMSD will\\n            still be calculated.\\n        '\n    self.rms = None\n    coord = self.get_guide_coord_from_structure(structure)\n    if len(coord) < self.window_size * 2:\n        n_atoms = len(coord)\n        msg = f'Too few atoms in the mobile structure ({n_atoms}). Try reducing the window_size parameter.'\n        raise PDBException(msg)\n    paths = run_cealign(self.refcoord, coord, self.window_size, self.max_gap)\n    unique_paths = {(tuple(pA), tuple(pB)) for (pA, pB) in paths}\n    (best_rmsd, best_u) = (1000000.0, None)\n    for u_path in unique_paths:\n        (idxA, idxB) = u_path\n        coordsA = np.array([self.refcoord[i] for i in idxA])\n        coordsB = np.array([coord[i] for i in idxB])\n        aln = QCPSuperimposer()\n        aln.set(coordsA, coordsB)\n        aln.run()\n        if aln.rms < best_rmsd:\n            best_rmsd = aln.rms\n            best_u = (aln.rot, aln.tran)\n    if best_u is None:\n        raise RuntimeError('Failed to find a suitable alignment.')\n    if transform:\n        (rotmtx, trvec) = best_u\n        for chain in structure.get_chains():\n            for resid in chain.get_unpacked_list():\n                for atom in resid.get_unpacked_list():\n                    atom.transform(rotmtx, trvec)\n    self.rms = best_rmsd",
            "def align(self, structure, transform=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Align the input structure onto the reference structure.\\n\\n        Parameters\\n        ----------\\n        transform: bool, optional\\n            If True (default), apply the rotation/translation that minimizes\\n            the RMSD between the two structures to the input structure. If\\n            False, the structure is not modified but the optimal RMSD will\\n            still be calculated.\\n        '\n    self.rms = None\n    coord = self.get_guide_coord_from_structure(structure)\n    if len(coord) < self.window_size * 2:\n        n_atoms = len(coord)\n        msg = f'Too few atoms in the mobile structure ({n_atoms}). Try reducing the window_size parameter.'\n        raise PDBException(msg)\n    paths = run_cealign(self.refcoord, coord, self.window_size, self.max_gap)\n    unique_paths = {(tuple(pA), tuple(pB)) for (pA, pB) in paths}\n    (best_rmsd, best_u) = (1000000.0, None)\n    for u_path in unique_paths:\n        (idxA, idxB) = u_path\n        coordsA = np.array([self.refcoord[i] for i in idxA])\n        coordsB = np.array([coord[i] for i in idxB])\n        aln = QCPSuperimposer()\n        aln.set(coordsA, coordsB)\n        aln.run()\n        if aln.rms < best_rmsd:\n            best_rmsd = aln.rms\n            best_u = (aln.rot, aln.tran)\n    if best_u is None:\n        raise RuntimeError('Failed to find a suitable alignment.')\n    if transform:\n        (rotmtx, trvec) = best_u\n        for chain in structure.get_chains():\n            for resid in chain.get_unpacked_list():\n                for atom in resid.get_unpacked_list():\n                    atom.transform(rotmtx, trvec)\n    self.rms = best_rmsd"
        ]
    }
]