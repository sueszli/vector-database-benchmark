[
    {
        "func_name": "match_2nd_hypergeometric",
        "original": "def match_2nd_hypergeometric(eq, func):\n    x = func.args[0]\n    df = func.diff(x)\n    a3 = Wild('a3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    b3 = Wild('b3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    c3 = Wild('c3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    deq = a3 * func.diff(x, 2) + b3 * df + c3 * func\n    r = collect(eq, [func.diff(x, 2), func.diff(x), func]).match(deq)\n    if r:\n        if not all((val.is_polynomial() for val in r.values())):\n            (n, d) = eq.as_numer_denom()\n            eq = expand(n)\n            r = collect(eq, [func.diff(x, 2), func.diff(x), func]).match(deq)\n    if r and r[a3] != 0:\n        A = cancel(r[b3] / r[a3])\n        B = cancel(r[c3] / r[a3])\n        return [A, B]\n    else:\n        return []",
        "mutated": [
            "def match_2nd_hypergeometric(eq, func):\n    if False:\n        i = 10\n    x = func.args[0]\n    df = func.diff(x)\n    a3 = Wild('a3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    b3 = Wild('b3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    c3 = Wild('c3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    deq = a3 * func.diff(x, 2) + b3 * df + c3 * func\n    r = collect(eq, [func.diff(x, 2), func.diff(x), func]).match(deq)\n    if r:\n        if not all((val.is_polynomial() for val in r.values())):\n            (n, d) = eq.as_numer_denom()\n            eq = expand(n)\n            r = collect(eq, [func.diff(x, 2), func.diff(x), func]).match(deq)\n    if r and r[a3] != 0:\n        A = cancel(r[b3] / r[a3])\n        B = cancel(r[c3] / r[a3])\n        return [A, B]\n    else:\n        return []",
            "def match_2nd_hypergeometric(eq, func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = func.args[0]\n    df = func.diff(x)\n    a3 = Wild('a3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    b3 = Wild('b3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    c3 = Wild('c3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    deq = a3 * func.diff(x, 2) + b3 * df + c3 * func\n    r = collect(eq, [func.diff(x, 2), func.diff(x), func]).match(deq)\n    if r:\n        if not all((val.is_polynomial() for val in r.values())):\n            (n, d) = eq.as_numer_denom()\n            eq = expand(n)\n            r = collect(eq, [func.diff(x, 2), func.diff(x), func]).match(deq)\n    if r and r[a3] != 0:\n        A = cancel(r[b3] / r[a3])\n        B = cancel(r[c3] / r[a3])\n        return [A, B]\n    else:\n        return []",
            "def match_2nd_hypergeometric(eq, func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = func.args[0]\n    df = func.diff(x)\n    a3 = Wild('a3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    b3 = Wild('b3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    c3 = Wild('c3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    deq = a3 * func.diff(x, 2) + b3 * df + c3 * func\n    r = collect(eq, [func.diff(x, 2), func.diff(x), func]).match(deq)\n    if r:\n        if not all((val.is_polynomial() for val in r.values())):\n            (n, d) = eq.as_numer_denom()\n            eq = expand(n)\n            r = collect(eq, [func.diff(x, 2), func.diff(x), func]).match(deq)\n    if r and r[a3] != 0:\n        A = cancel(r[b3] / r[a3])\n        B = cancel(r[c3] / r[a3])\n        return [A, B]\n    else:\n        return []",
            "def match_2nd_hypergeometric(eq, func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = func.args[0]\n    df = func.diff(x)\n    a3 = Wild('a3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    b3 = Wild('b3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    c3 = Wild('c3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    deq = a3 * func.diff(x, 2) + b3 * df + c3 * func\n    r = collect(eq, [func.diff(x, 2), func.diff(x), func]).match(deq)\n    if r:\n        if not all((val.is_polynomial() for val in r.values())):\n            (n, d) = eq.as_numer_denom()\n            eq = expand(n)\n            r = collect(eq, [func.diff(x, 2), func.diff(x), func]).match(deq)\n    if r and r[a3] != 0:\n        A = cancel(r[b3] / r[a3])\n        B = cancel(r[c3] / r[a3])\n        return [A, B]\n    else:\n        return []",
            "def match_2nd_hypergeometric(eq, func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = func.args[0]\n    df = func.diff(x)\n    a3 = Wild('a3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    b3 = Wild('b3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    c3 = Wild('c3', exclude=[func, func.diff(x), func.diff(x, 2)])\n    deq = a3 * func.diff(x, 2) + b3 * df + c3 * func\n    r = collect(eq, [func.diff(x, 2), func.diff(x), func]).match(deq)\n    if r:\n        if not all((val.is_polynomial() for val in r.values())):\n            (n, d) = eq.as_numer_denom()\n            eq = expand(n)\n            r = collect(eq, [func.diff(x, 2), func.diff(x), func]).match(deq)\n    if r and r[a3] != 0:\n        A = cancel(r[b3] / r[a3])\n        B = cancel(r[c3] / r[a3])\n        return [A, B]\n    else:\n        return []"
        ]
    },
    {
        "func_name": "_power_counting",
        "original": "def _power_counting(num):\n    _pow = {0}\n    for val in num:\n        if val.has(x):\n            if isinstance(val, Pow) and val.as_base_exp()[0] == x:\n                _pow.add(val.as_base_exp()[1])\n            elif val == x:\n                _pow.add(val.as_base_exp()[1])\n            else:\n                _pow.update(_power_counting(val.args))\n    return _pow",
        "mutated": [
            "def _power_counting(num):\n    if False:\n        i = 10\n    _pow = {0}\n    for val in num:\n        if val.has(x):\n            if isinstance(val, Pow) and val.as_base_exp()[0] == x:\n                _pow.add(val.as_base_exp()[1])\n            elif val == x:\n                _pow.add(val.as_base_exp()[1])\n            else:\n                _pow.update(_power_counting(val.args))\n    return _pow",
            "def _power_counting(num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    _pow = {0}\n    for val in num:\n        if val.has(x):\n            if isinstance(val, Pow) and val.as_base_exp()[0] == x:\n                _pow.add(val.as_base_exp()[1])\n            elif val == x:\n                _pow.add(val.as_base_exp()[1])\n            else:\n                _pow.update(_power_counting(val.args))\n    return _pow",
            "def _power_counting(num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    _pow = {0}\n    for val in num:\n        if val.has(x):\n            if isinstance(val, Pow) and val.as_base_exp()[0] == x:\n                _pow.add(val.as_base_exp()[1])\n            elif val == x:\n                _pow.add(val.as_base_exp()[1])\n            else:\n                _pow.update(_power_counting(val.args))\n    return _pow",
            "def _power_counting(num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    _pow = {0}\n    for val in num:\n        if val.has(x):\n            if isinstance(val, Pow) and val.as_base_exp()[0] == x:\n                _pow.add(val.as_base_exp()[1])\n            elif val == x:\n                _pow.add(val.as_base_exp()[1])\n            else:\n                _pow.update(_power_counting(val.args))\n    return _pow",
            "def _power_counting(num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    _pow = {0}\n    for val in num:\n        if val.has(x):\n            if isinstance(val, Pow) and val.as_base_exp()[0] == x:\n                _pow.add(val.as_base_exp()[1])\n            elif val == x:\n                _pow.add(val.as_base_exp()[1])\n            else:\n                _pow.update(_power_counting(val.args))\n    return _pow"
        ]
    },
    {
        "func_name": "equivalence_hypergeometric",
        "original": "def equivalence_hypergeometric(A, B, func):\n    x = func.args[0]\n    I1 = factor(cancel(A.diff(x) / 2 + A ** 2 / 4 - B))\n    J1 = factor(cancel(x ** 2 * I1 + S(1) / 4))\n    (num, dem) = J1.as_numer_denom()\n    num = powdenest(expand(num))\n    dem = powdenest(expand(dem))\n\n    def _power_counting(num):\n        _pow = {0}\n        for val in num:\n            if val.has(x):\n                if isinstance(val, Pow) and val.as_base_exp()[0] == x:\n                    _pow.add(val.as_base_exp()[1])\n                elif val == x:\n                    _pow.add(val.as_base_exp()[1])\n                else:\n                    _pow.update(_power_counting(val.args))\n        return _pow\n    pow_num = _power_counting((num,))\n    pow_dem = _power_counting((dem,))\n    pow_dem.update(pow_num)\n    _pow = pow_dem\n    k = gcd(_pow)\n    I0 = powdenest(simplify(factor((J1 / k ** 2 - S(1) / 4) / (x ** k) ** 2)), force=True)\n    I0 = factor(cancel(powdenest(I0.subs(x, x ** (S(1) / k)), force=True)))\n    if not I0.is_rational_function(x):\n        return None\n    (num, dem) = I0.as_numer_denom()\n    max_num_pow = max(_power_counting((num,)))\n    dem_args = dem.args\n    sing_point = []\n    dem_pow = []\n    for arg in dem_args:\n        if arg.has(x):\n            if isinstance(arg, Pow):\n                dem_pow.append(arg.as_base_exp()[1])\n                sing_point.append(list(roots(arg.as_base_exp()[0], x).keys())[0])\n            else:\n                dem_pow.append(arg.as_base_exp()[1])\n                sing_point.append(list(roots(arg, x).keys())[0])\n    dem_pow.sort()\n    if equivalence(max_num_pow, dem_pow) == '2F1':\n        return {'I0': I0, 'k': k, 'sing_point': sing_point, 'type': '2F1'}\n    else:\n        return None",
        "mutated": [
            "def equivalence_hypergeometric(A, B, func):\n    if False:\n        i = 10\n    x = func.args[0]\n    I1 = factor(cancel(A.diff(x) / 2 + A ** 2 / 4 - B))\n    J1 = factor(cancel(x ** 2 * I1 + S(1) / 4))\n    (num, dem) = J1.as_numer_denom()\n    num = powdenest(expand(num))\n    dem = powdenest(expand(dem))\n\n    def _power_counting(num):\n        _pow = {0}\n        for val in num:\n            if val.has(x):\n                if isinstance(val, Pow) and val.as_base_exp()[0] == x:\n                    _pow.add(val.as_base_exp()[1])\n                elif val == x:\n                    _pow.add(val.as_base_exp()[1])\n                else:\n                    _pow.update(_power_counting(val.args))\n        return _pow\n    pow_num = _power_counting((num,))\n    pow_dem = _power_counting((dem,))\n    pow_dem.update(pow_num)\n    _pow = pow_dem\n    k = gcd(_pow)\n    I0 = powdenest(simplify(factor((J1 / k ** 2 - S(1) / 4) / (x ** k) ** 2)), force=True)\n    I0 = factor(cancel(powdenest(I0.subs(x, x ** (S(1) / k)), force=True)))\n    if not I0.is_rational_function(x):\n        return None\n    (num, dem) = I0.as_numer_denom()\n    max_num_pow = max(_power_counting((num,)))\n    dem_args = dem.args\n    sing_point = []\n    dem_pow = []\n    for arg in dem_args:\n        if arg.has(x):\n            if isinstance(arg, Pow):\n                dem_pow.append(arg.as_base_exp()[1])\n                sing_point.append(list(roots(arg.as_base_exp()[0], x).keys())[0])\n            else:\n                dem_pow.append(arg.as_base_exp()[1])\n                sing_point.append(list(roots(arg, x).keys())[0])\n    dem_pow.sort()\n    if equivalence(max_num_pow, dem_pow) == '2F1':\n        return {'I0': I0, 'k': k, 'sing_point': sing_point, 'type': '2F1'}\n    else:\n        return None",
            "def equivalence_hypergeometric(A, B, func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = func.args[0]\n    I1 = factor(cancel(A.diff(x) / 2 + A ** 2 / 4 - B))\n    J1 = factor(cancel(x ** 2 * I1 + S(1) / 4))\n    (num, dem) = J1.as_numer_denom()\n    num = powdenest(expand(num))\n    dem = powdenest(expand(dem))\n\n    def _power_counting(num):\n        _pow = {0}\n        for val in num:\n            if val.has(x):\n                if isinstance(val, Pow) and val.as_base_exp()[0] == x:\n                    _pow.add(val.as_base_exp()[1])\n                elif val == x:\n                    _pow.add(val.as_base_exp()[1])\n                else:\n                    _pow.update(_power_counting(val.args))\n        return _pow\n    pow_num = _power_counting((num,))\n    pow_dem = _power_counting((dem,))\n    pow_dem.update(pow_num)\n    _pow = pow_dem\n    k = gcd(_pow)\n    I0 = powdenest(simplify(factor((J1 / k ** 2 - S(1) / 4) / (x ** k) ** 2)), force=True)\n    I0 = factor(cancel(powdenest(I0.subs(x, x ** (S(1) / k)), force=True)))\n    if not I0.is_rational_function(x):\n        return None\n    (num, dem) = I0.as_numer_denom()\n    max_num_pow = max(_power_counting((num,)))\n    dem_args = dem.args\n    sing_point = []\n    dem_pow = []\n    for arg in dem_args:\n        if arg.has(x):\n            if isinstance(arg, Pow):\n                dem_pow.append(arg.as_base_exp()[1])\n                sing_point.append(list(roots(arg.as_base_exp()[0], x).keys())[0])\n            else:\n                dem_pow.append(arg.as_base_exp()[1])\n                sing_point.append(list(roots(arg, x).keys())[0])\n    dem_pow.sort()\n    if equivalence(max_num_pow, dem_pow) == '2F1':\n        return {'I0': I0, 'k': k, 'sing_point': sing_point, 'type': '2F1'}\n    else:\n        return None",
            "def equivalence_hypergeometric(A, B, func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = func.args[0]\n    I1 = factor(cancel(A.diff(x) / 2 + A ** 2 / 4 - B))\n    J1 = factor(cancel(x ** 2 * I1 + S(1) / 4))\n    (num, dem) = J1.as_numer_denom()\n    num = powdenest(expand(num))\n    dem = powdenest(expand(dem))\n\n    def _power_counting(num):\n        _pow = {0}\n        for val in num:\n            if val.has(x):\n                if isinstance(val, Pow) and val.as_base_exp()[0] == x:\n                    _pow.add(val.as_base_exp()[1])\n                elif val == x:\n                    _pow.add(val.as_base_exp()[1])\n                else:\n                    _pow.update(_power_counting(val.args))\n        return _pow\n    pow_num = _power_counting((num,))\n    pow_dem = _power_counting((dem,))\n    pow_dem.update(pow_num)\n    _pow = pow_dem\n    k = gcd(_pow)\n    I0 = powdenest(simplify(factor((J1 / k ** 2 - S(1) / 4) / (x ** k) ** 2)), force=True)\n    I0 = factor(cancel(powdenest(I0.subs(x, x ** (S(1) / k)), force=True)))\n    if not I0.is_rational_function(x):\n        return None\n    (num, dem) = I0.as_numer_denom()\n    max_num_pow = max(_power_counting((num,)))\n    dem_args = dem.args\n    sing_point = []\n    dem_pow = []\n    for arg in dem_args:\n        if arg.has(x):\n            if isinstance(arg, Pow):\n                dem_pow.append(arg.as_base_exp()[1])\n                sing_point.append(list(roots(arg.as_base_exp()[0], x).keys())[0])\n            else:\n                dem_pow.append(arg.as_base_exp()[1])\n                sing_point.append(list(roots(arg, x).keys())[0])\n    dem_pow.sort()\n    if equivalence(max_num_pow, dem_pow) == '2F1':\n        return {'I0': I0, 'k': k, 'sing_point': sing_point, 'type': '2F1'}\n    else:\n        return None",
            "def equivalence_hypergeometric(A, B, func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = func.args[0]\n    I1 = factor(cancel(A.diff(x) / 2 + A ** 2 / 4 - B))\n    J1 = factor(cancel(x ** 2 * I1 + S(1) / 4))\n    (num, dem) = J1.as_numer_denom()\n    num = powdenest(expand(num))\n    dem = powdenest(expand(dem))\n\n    def _power_counting(num):\n        _pow = {0}\n        for val in num:\n            if val.has(x):\n                if isinstance(val, Pow) and val.as_base_exp()[0] == x:\n                    _pow.add(val.as_base_exp()[1])\n                elif val == x:\n                    _pow.add(val.as_base_exp()[1])\n                else:\n                    _pow.update(_power_counting(val.args))\n        return _pow\n    pow_num = _power_counting((num,))\n    pow_dem = _power_counting((dem,))\n    pow_dem.update(pow_num)\n    _pow = pow_dem\n    k = gcd(_pow)\n    I0 = powdenest(simplify(factor((J1 / k ** 2 - S(1) / 4) / (x ** k) ** 2)), force=True)\n    I0 = factor(cancel(powdenest(I0.subs(x, x ** (S(1) / k)), force=True)))\n    if not I0.is_rational_function(x):\n        return None\n    (num, dem) = I0.as_numer_denom()\n    max_num_pow = max(_power_counting((num,)))\n    dem_args = dem.args\n    sing_point = []\n    dem_pow = []\n    for arg in dem_args:\n        if arg.has(x):\n            if isinstance(arg, Pow):\n                dem_pow.append(arg.as_base_exp()[1])\n                sing_point.append(list(roots(arg.as_base_exp()[0], x).keys())[0])\n            else:\n                dem_pow.append(arg.as_base_exp()[1])\n                sing_point.append(list(roots(arg, x).keys())[0])\n    dem_pow.sort()\n    if equivalence(max_num_pow, dem_pow) == '2F1':\n        return {'I0': I0, 'k': k, 'sing_point': sing_point, 'type': '2F1'}\n    else:\n        return None",
            "def equivalence_hypergeometric(A, B, func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = func.args[0]\n    I1 = factor(cancel(A.diff(x) / 2 + A ** 2 / 4 - B))\n    J1 = factor(cancel(x ** 2 * I1 + S(1) / 4))\n    (num, dem) = J1.as_numer_denom()\n    num = powdenest(expand(num))\n    dem = powdenest(expand(dem))\n\n    def _power_counting(num):\n        _pow = {0}\n        for val in num:\n            if val.has(x):\n                if isinstance(val, Pow) and val.as_base_exp()[0] == x:\n                    _pow.add(val.as_base_exp()[1])\n                elif val == x:\n                    _pow.add(val.as_base_exp()[1])\n                else:\n                    _pow.update(_power_counting(val.args))\n        return _pow\n    pow_num = _power_counting((num,))\n    pow_dem = _power_counting((dem,))\n    pow_dem.update(pow_num)\n    _pow = pow_dem\n    k = gcd(_pow)\n    I0 = powdenest(simplify(factor((J1 / k ** 2 - S(1) / 4) / (x ** k) ** 2)), force=True)\n    I0 = factor(cancel(powdenest(I0.subs(x, x ** (S(1) / k)), force=True)))\n    if not I0.is_rational_function(x):\n        return None\n    (num, dem) = I0.as_numer_denom()\n    max_num_pow = max(_power_counting((num,)))\n    dem_args = dem.args\n    sing_point = []\n    dem_pow = []\n    for arg in dem_args:\n        if arg.has(x):\n            if isinstance(arg, Pow):\n                dem_pow.append(arg.as_base_exp()[1])\n                sing_point.append(list(roots(arg.as_base_exp()[0], x).keys())[0])\n            else:\n                dem_pow.append(arg.as_base_exp()[1])\n                sing_point.append(list(roots(arg, x).keys())[0])\n    dem_pow.sort()\n    if equivalence(max_num_pow, dem_pow) == '2F1':\n        return {'I0': I0, 'k': k, 'sing_point': sing_point, 'type': '2F1'}\n    else:\n        return None"
        ]
    },
    {
        "func_name": "match_2nd_2F1_hypergeometric",
        "original": "def match_2nd_2F1_hypergeometric(I, k, sing_point, func):\n    x = func.args[0]\n    a = Wild('a')\n    b = Wild('b')\n    c = Wild('c')\n    t = Wild('t')\n    s = Wild('s')\n    r = Wild('r')\n    alpha = Wild('alpha')\n    beta = Wild('beta')\n    gamma = Wild('gamma')\n    delta = Wild('delta')\n    I0 = ((a - b + 1) * (a - b - 1) * x ** 2 + 2 * ((1 - a - b) * c + 2 * a * b) * x + c * (c - 2)) / (4 * x ** 2 * (x - 1) ** 2)\n    if sing_point != [0, 1]:\n        eqs = []\n        sing_eqs = [-beta / alpha, -delta / gamma, (delta - beta) / (alpha - gamma)]\n        for i in range(3):\n            if i < len(sing_point):\n                eqs.append(Eq(sing_eqs[i], sing_point[i]))\n            else:\n                eqs.append(Eq(1 / sing_eqs[i], 0))\n        _beta = -alpha * sing_point[0]\n        _delta = -gamma * sing_point[1]\n        _gamma = alpha\n        if len(sing_point) == 3:\n            _gamma = (_beta + sing_point[2] * alpha) / (sing_point[2] - sing_point[1])\n        mob = (alpha * x + beta) / (gamma * x + delta)\n        mob = mob.subs(beta, _beta)\n        mob = mob.subs(delta, _delta)\n        mob = mob.subs(gamma, _gamma)\n        mob = cancel(mob)\n        t = (beta - delta * x) / (gamma * x - alpha)\n        t = cancel(t.subs(beta, _beta).subs(delta, _delta).subs(gamma, _gamma))\n    else:\n        mob = x\n        t = x\n    I = I.subs(x, t)\n    I = I * t.diff(x) ** 2\n    I = factor(I)\n    dict_I = {x ** 2: 0, x: 0, 1: 0}\n    (I0_num, I0_dem) = I0.as_numer_denom()\n    dict_I0 = {x ** 2: s ** 2 - 1, x: 2 * (1 - r) * c + (r + s) * (r - s), 1: c * (c - 2)}\n    dict_I.update(collect(expand(cancel(I * I0_dem)), [x ** 2, x], evaluate=False))\n    eqs = []\n    for key in [x ** 2, x, 1]:\n        eqs.append(Eq(dict_I[key], dict_I0[key]))\n    _c = 1 - factor(sqrt(1 + eqs[2].lhs))\n    if not _c.has(Symbol):\n        _c = min(list(roots(eqs[2], c)))\n    _s = factor(sqrt(eqs[0].lhs + 1))\n    _r = _c - factor(sqrt(_c ** 2 + _s ** 2 + eqs[1].lhs - 2 * _c))\n    _a = (_r + _s) / 2\n    _b = (_r - _s) / 2\n    rn = {'a': simplify(_a), 'b': simplify(_b), 'c': simplify(_c), 'k': k, 'mobius': mob, 'type': '2F1'}\n    return rn",
        "mutated": [
            "def match_2nd_2F1_hypergeometric(I, k, sing_point, func):\n    if False:\n        i = 10\n    x = func.args[0]\n    a = Wild('a')\n    b = Wild('b')\n    c = Wild('c')\n    t = Wild('t')\n    s = Wild('s')\n    r = Wild('r')\n    alpha = Wild('alpha')\n    beta = Wild('beta')\n    gamma = Wild('gamma')\n    delta = Wild('delta')\n    I0 = ((a - b + 1) * (a - b - 1) * x ** 2 + 2 * ((1 - a - b) * c + 2 * a * b) * x + c * (c - 2)) / (4 * x ** 2 * (x - 1) ** 2)\n    if sing_point != [0, 1]:\n        eqs = []\n        sing_eqs = [-beta / alpha, -delta / gamma, (delta - beta) / (alpha - gamma)]\n        for i in range(3):\n            if i < len(sing_point):\n                eqs.append(Eq(sing_eqs[i], sing_point[i]))\n            else:\n                eqs.append(Eq(1 / sing_eqs[i], 0))\n        _beta = -alpha * sing_point[0]\n        _delta = -gamma * sing_point[1]\n        _gamma = alpha\n        if len(sing_point) == 3:\n            _gamma = (_beta + sing_point[2] * alpha) / (sing_point[2] - sing_point[1])\n        mob = (alpha * x + beta) / (gamma * x + delta)\n        mob = mob.subs(beta, _beta)\n        mob = mob.subs(delta, _delta)\n        mob = mob.subs(gamma, _gamma)\n        mob = cancel(mob)\n        t = (beta - delta * x) / (gamma * x - alpha)\n        t = cancel(t.subs(beta, _beta).subs(delta, _delta).subs(gamma, _gamma))\n    else:\n        mob = x\n        t = x\n    I = I.subs(x, t)\n    I = I * t.diff(x) ** 2\n    I = factor(I)\n    dict_I = {x ** 2: 0, x: 0, 1: 0}\n    (I0_num, I0_dem) = I0.as_numer_denom()\n    dict_I0 = {x ** 2: s ** 2 - 1, x: 2 * (1 - r) * c + (r + s) * (r - s), 1: c * (c - 2)}\n    dict_I.update(collect(expand(cancel(I * I0_dem)), [x ** 2, x], evaluate=False))\n    eqs = []\n    for key in [x ** 2, x, 1]:\n        eqs.append(Eq(dict_I[key], dict_I0[key]))\n    _c = 1 - factor(sqrt(1 + eqs[2].lhs))\n    if not _c.has(Symbol):\n        _c = min(list(roots(eqs[2], c)))\n    _s = factor(sqrt(eqs[0].lhs + 1))\n    _r = _c - factor(sqrt(_c ** 2 + _s ** 2 + eqs[1].lhs - 2 * _c))\n    _a = (_r + _s) / 2\n    _b = (_r - _s) / 2\n    rn = {'a': simplify(_a), 'b': simplify(_b), 'c': simplify(_c), 'k': k, 'mobius': mob, 'type': '2F1'}\n    return rn",
            "def match_2nd_2F1_hypergeometric(I, k, sing_point, func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = func.args[0]\n    a = Wild('a')\n    b = Wild('b')\n    c = Wild('c')\n    t = Wild('t')\n    s = Wild('s')\n    r = Wild('r')\n    alpha = Wild('alpha')\n    beta = Wild('beta')\n    gamma = Wild('gamma')\n    delta = Wild('delta')\n    I0 = ((a - b + 1) * (a - b - 1) * x ** 2 + 2 * ((1 - a - b) * c + 2 * a * b) * x + c * (c - 2)) / (4 * x ** 2 * (x - 1) ** 2)\n    if sing_point != [0, 1]:\n        eqs = []\n        sing_eqs = [-beta / alpha, -delta / gamma, (delta - beta) / (alpha - gamma)]\n        for i in range(3):\n            if i < len(sing_point):\n                eqs.append(Eq(sing_eqs[i], sing_point[i]))\n            else:\n                eqs.append(Eq(1 / sing_eqs[i], 0))\n        _beta = -alpha * sing_point[0]\n        _delta = -gamma * sing_point[1]\n        _gamma = alpha\n        if len(sing_point) == 3:\n            _gamma = (_beta + sing_point[2] * alpha) / (sing_point[2] - sing_point[1])\n        mob = (alpha * x + beta) / (gamma * x + delta)\n        mob = mob.subs(beta, _beta)\n        mob = mob.subs(delta, _delta)\n        mob = mob.subs(gamma, _gamma)\n        mob = cancel(mob)\n        t = (beta - delta * x) / (gamma * x - alpha)\n        t = cancel(t.subs(beta, _beta).subs(delta, _delta).subs(gamma, _gamma))\n    else:\n        mob = x\n        t = x\n    I = I.subs(x, t)\n    I = I * t.diff(x) ** 2\n    I = factor(I)\n    dict_I = {x ** 2: 0, x: 0, 1: 0}\n    (I0_num, I0_dem) = I0.as_numer_denom()\n    dict_I0 = {x ** 2: s ** 2 - 1, x: 2 * (1 - r) * c + (r + s) * (r - s), 1: c * (c - 2)}\n    dict_I.update(collect(expand(cancel(I * I0_dem)), [x ** 2, x], evaluate=False))\n    eqs = []\n    for key in [x ** 2, x, 1]:\n        eqs.append(Eq(dict_I[key], dict_I0[key]))\n    _c = 1 - factor(sqrt(1 + eqs[2].lhs))\n    if not _c.has(Symbol):\n        _c = min(list(roots(eqs[2], c)))\n    _s = factor(sqrt(eqs[0].lhs + 1))\n    _r = _c - factor(sqrt(_c ** 2 + _s ** 2 + eqs[1].lhs - 2 * _c))\n    _a = (_r + _s) / 2\n    _b = (_r - _s) / 2\n    rn = {'a': simplify(_a), 'b': simplify(_b), 'c': simplify(_c), 'k': k, 'mobius': mob, 'type': '2F1'}\n    return rn",
            "def match_2nd_2F1_hypergeometric(I, k, sing_point, func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = func.args[0]\n    a = Wild('a')\n    b = Wild('b')\n    c = Wild('c')\n    t = Wild('t')\n    s = Wild('s')\n    r = Wild('r')\n    alpha = Wild('alpha')\n    beta = Wild('beta')\n    gamma = Wild('gamma')\n    delta = Wild('delta')\n    I0 = ((a - b + 1) * (a - b - 1) * x ** 2 + 2 * ((1 - a - b) * c + 2 * a * b) * x + c * (c - 2)) / (4 * x ** 2 * (x - 1) ** 2)\n    if sing_point != [0, 1]:\n        eqs = []\n        sing_eqs = [-beta / alpha, -delta / gamma, (delta - beta) / (alpha - gamma)]\n        for i in range(3):\n            if i < len(sing_point):\n                eqs.append(Eq(sing_eqs[i], sing_point[i]))\n            else:\n                eqs.append(Eq(1 / sing_eqs[i], 0))\n        _beta = -alpha * sing_point[0]\n        _delta = -gamma * sing_point[1]\n        _gamma = alpha\n        if len(sing_point) == 3:\n            _gamma = (_beta + sing_point[2] * alpha) / (sing_point[2] - sing_point[1])\n        mob = (alpha * x + beta) / (gamma * x + delta)\n        mob = mob.subs(beta, _beta)\n        mob = mob.subs(delta, _delta)\n        mob = mob.subs(gamma, _gamma)\n        mob = cancel(mob)\n        t = (beta - delta * x) / (gamma * x - alpha)\n        t = cancel(t.subs(beta, _beta).subs(delta, _delta).subs(gamma, _gamma))\n    else:\n        mob = x\n        t = x\n    I = I.subs(x, t)\n    I = I * t.diff(x) ** 2\n    I = factor(I)\n    dict_I = {x ** 2: 0, x: 0, 1: 0}\n    (I0_num, I0_dem) = I0.as_numer_denom()\n    dict_I0 = {x ** 2: s ** 2 - 1, x: 2 * (1 - r) * c + (r + s) * (r - s), 1: c * (c - 2)}\n    dict_I.update(collect(expand(cancel(I * I0_dem)), [x ** 2, x], evaluate=False))\n    eqs = []\n    for key in [x ** 2, x, 1]:\n        eqs.append(Eq(dict_I[key], dict_I0[key]))\n    _c = 1 - factor(sqrt(1 + eqs[2].lhs))\n    if not _c.has(Symbol):\n        _c = min(list(roots(eqs[2], c)))\n    _s = factor(sqrt(eqs[0].lhs + 1))\n    _r = _c - factor(sqrt(_c ** 2 + _s ** 2 + eqs[1].lhs - 2 * _c))\n    _a = (_r + _s) / 2\n    _b = (_r - _s) / 2\n    rn = {'a': simplify(_a), 'b': simplify(_b), 'c': simplify(_c), 'k': k, 'mobius': mob, 'type': '2F1'}\n    return rn",
            "def match_2nd_2F1_hypergeometric(I, k, sing_point, func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = func.args[0]\n    a = Wild('a')\n    b = Wild('b')\n    c = Wild('c')\n    t = Wild('t')\n    s = Wild('s')\n    r = Wild('r')\n    alpha = Wild('alpha')\n    beta = Wild('beta')\n    gamma = Wild('gamma')\n    delta = Wild('delta')\n    I0 = ((a - b + 1) * (a - b - 1) * x ** 2 + 2 * ((1 - a - b) * c + 2 * a * b) * x + c * (c - 2)) / (4 * x ** 2 * (x - 1) ** 2)\n    if sing_point != [0, 1]:\n        eqs = []\n        sing_eqs = [-beta / alpha, -delta / gamma, (delta - beta) / (alpha - gamma)]\n        for i in range(3):\n            if i < len(sing_point):\n                eqs.append(Eq(sing_eqs[i], sing_point[i]))\n            else:\n                eqs.append(Eq(1 / sing_eqs[i], 0))\n        _beta = -alpha * sing_point[0]\n        _delta = -gamma * sing_point[1]\n        _gamma = alpha\n        if len(sing_point) == 3:\n            _gamma = (_beta + sing_point[2] * alpha) / (sing_point[2] - sing_point[1])\n        mob = (alpha * x + beta) / (gamma * x + delta)\n        mob = mob.subs(beta, _beta)\n        mob = mob.subs(delta, _delta)\n        mob = mob.subs(gamma, _gamma)\n        mob = cancel(mob)\n        t = (beta - delta * x) / (gamma * x - alpha)\n        t = cancel(t.subs(beta, _beta).subs(delta, _delta).subs(gamma, _gamma))\n    else:\n        mob = x\n        t = x\n    I = I.subs(x, t)\n    I = I * t.diff(x) ** 2\n    I = factor(I)\n    dict_I = {x ** 2: 0, x: 0, 1: 0}\n    (I0_num, I0_dem) = I0.as_numer_denom()\n    dict_I0 = {x ** 2: s ** 2 - 1, x: 2 * (1 - r) * c + (r + s) * (r - s), 1: c * (c - 2)}\n    dict_I.update(collect(expand(cancel(I * I0_dem)), [x ** 2, x], evaluate=False))\n    eqs = []\n    for key in [x ** 2, x, 1]:\n        eqs.append(Eq(dict_I[key], dict_I0[key]))\n    _c = 1 - factor(sqrt(1 + eqs[2].lhs))\n    if not _c.has(Symbol):\n        _c = min(list(roots(eqs[2], c)))\n    _s = factor(sqrt(eqs[0].lhs + 1))\n    _r = _c - factor(sqrt(_c ** 2 + _s ** 2 + eqs[1].lhs - 2 * _c))\n    _a = (_r + _s) / 2\n    _b = (_r - _s) / 2\n    rn = {'a': simplify(_a), 'b': simplify(_b), 'c': simplify(_c), 'k': k, 'mobius': mob, 'type': '2F1'}\n    return rn",
            "def match_2nd_2F1_hypergeometric(I, k, sing_point, func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = func.args[0]\n    a = Wild('a')\n    b = Wild('b')\n    c = Wild('c')\n    t = Wild('t')\n    s = Wild('s')\n    r = Wild('r')\n    alpha = Wild('alpha')\n    beta = Wild('beta')\n    gamma = Wild('gamma')\n    delta = Wild('delta')\n    I0 = ((a - b + 1) * (a - b - 1) * x ** 2 + 2 * ((1 - a - b) * c + 2 * a * b) * x + c * (c - 2)) / (4 * x ** 2 * (x - 1) ** 2)\n    if sing_point != [0, 1]:\n        eqs = []\n        sing_eqs = [-beta / alpha, -delta / gamma, (delta - beta) / (alpha - gamma)]\n        for i in range(3):\n            if i < len(sing_point):\n                eqs.append(Eq(sing_eqs[i], sing_point[i]))\n            else:\n                eqs.append(Eq(1 / sing_eqs[i], 0))\n        _beta = -alpha * sing_point[0]\n        _delta = -gamma * sing_point[1]\n        _gamma = alpha\n        if len(sing_point) == 3:\n            _gamma = (_beta + sing_point[2] * alpha) / (sing_point[2] - sing_point[1])\n        mob = (alpha * x + beta) / (gamma * x + delta)\n        mob = mob.subs(beta, _beta)\n        mob = mob.subs(delta, _delta)\n        mob = mob.subs(gamma, _gamma)\n        mob = cancel(mob)\n        t = (beta - delta * x) / (gamma * x - alpha)\n        t = cancel(t.subs(beta, _beta).subs(delta, _delta).subs(gamma, _gamma))\n    else:\n        mob = x\n        t = x\n    I = I.subs(x, t)\n    I = I * t.diff(x) ** 2\n    I = factor(I)\n    dict_I = {x ** 2: 0, x: 0, 1: 0}\n    (I0_num, I0_dem) = I0.as_numer_denom()\n    dict_I0 = {x ** 2: s ** 2 - 1, x: 2 * (1 - r) * c + (r + s) * (r - s), 1: c * (c - 2)}\n    dict_I.update(collect(expand(cancel(I * I0_dem)), [x ** 2, x], evaluate=False))\n    eqs = []\n    for key in [x ** 2, x, 1]:\n        eqs.append(Eq(dict_I[key], dict_I0[key]))\n    _c = 1 - factor(sqrt(1 + eqs[2].lhs))\n    if not _c.has(Symbol):\n        _c = min(list(roots(eqs[2], c)))\n    _s = factor(sqrt(eqs[0].lhs + 1))\n    _r = _c - factor(sqrt(_c ** 2 + _s ** 2 + eqs[1].lhs - 2 * _c))\n    _a = (_r + _s) / 2\n    _b = (_r - _s) / 2\n    rn = {'a': simplify(_a), 'b': simplify(_b), 'c': simplify(_c), 'k': k, 'mobius': mob, 'type': '2F1'}\n    return rn"
        ]
    },
    {
        "func_name": "equivalence",
        "original": "def equivalence(max_num_pow, dem_pow):\n    if max_num_pow == 2:\n        if dem_pow in [[2, 2], [2, 2, 2]]:\n            return '2F1'\n    elif max_num_pow == 1:\n        if dem_pow in [[1, 2, 2], [2, 2, 2], [1, 2], [2, 2]]:\n            return '2F1'\n    elif max_num_pow == 0:\n        if dem_pow in [[1, 1, 2], [2, 2], [1, 2, 2], [1, 1], [2], [1, 2], [2, 2]]:\n            return '2F1'\n    return None",
        "mutated": [
            "def equivalence(max_num_pow, dem_pow):\n    if False:\n        i = 10\n    if max_num_pow == 2:\n        if dem_pow in [[2, 2], [2, 2, 2]]:\n            return '2F1'\n    elif max_num_pow == 1:\n        if dem_pow in [[1, 2, 2], [2, 2, 2], [1, 2], [2, 2]]:\n            return '2F1'\n    elif max_num_pow == 0:\n        if dem_pow in [[1, 1, 2], [2, 2], [1, 2, 2], [1, 1], [2], [1, 2], [2, 2]]:\n            return '2F1'\n    return None",
            "def equivalence(max_num_pow, dem_pow):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if max_num_pow == 2:\n        if dem_pow in [[2, 2], [2, 2, 2]]:\n            return '2F1'\n    elif max_num_pow == 1:\n        if dem_pow in [[1, 2, 2], [2, 2, 2], [1, 2], [2, 2]]:\n            return '2F1'\n    elif max_num_pow == 0:\n        if dem_pow in [[1, 1, 2], [2, 2], [1, 2, 2], [1, 1], [2], [1, 2], [2, 2]]:\n            return '2F1'\n    return None",
            "def equivalence(max_num_pow, dem_pow):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if max_num_pow == 2:\n        if dem_pow in [[2, 2], [2, 2, 2]]:\n            return '2F1'\n    elif max_num_pow == 1:\n        if dem_pow in [[1, 2, 2], [2, 2, 2], [1, 2], [2, 2]]:\n            return '2F1'\n    elif max_num_pow == 0:\n        if dem_pow in [[1, 1, 2], [2, 2], [1, 2, 2], [1, 1], [2], [1, 2], [2, 2]]:\n            return '2F1'\n    return None",
            "def equivalence(max_num_pow, dem_pow):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if max_num_pow == 2:\n        if dem_pow in [[2, 2], [2, 2, 2]]:\n            return '2F1'\n    elif max_num_pow == 1:\n        if dem_pow in [[1, 2, 2], [2, 2, 2], [1, 2], [2, 2]]:\n            return '2F1'\n    elif max_num_pow == 0:\n        if dem_pow in [[1, 1, 2], [2, 2], [1, 2, 2], [1, 1], [2], [1, 2], [2, 2]]:\n            return '2F1'\n    return None",
            "def equivalence(max_num_pow, dem_pow):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if max_num_pow == 2:\n        if dem_pow in [[2, 2], [2, 2, 2]]:\n            return '2F1'\n    elif max_num_pow == 1:\n        if dem_pow in [[1, 2, 2], [2, 2, 2], [1, 2], [2, 2]]:\n            return '2F1'\n    elif max_num_pow == 0:\n        if dem_pow in [[1, 1, 2], [2, 2], [1, 2, 2], [1, 1], [2], [1, 2], [2, 2]]:\n            return '2F1'\n    return None"
        ]
    },
    {
        "func_name": "get_sol_2F1_hypergeometric",
        "original": "def get_sol_2F1_hypergeometric(eq, func, match_object):\n    x = func.args[0]\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.polys.polytools import factor\n    (C0, C1) = get_numbered_constants(eq, num=2)\n    a = match_object['a']\n    b = match_object['b']\n    c = match_object['c']\n    A = match_object['A']\n    sol = None\n    if c.is_integer == False:\n        sol = C0 * hyper([a, b], [c], x) + C1 * hyper([a - c + 1, b - c + 1], [2 - c], x) * x ** (1 - c)\n    elif c == 1:\n        y2 = Integral(exp(Integral((-(a + b + 1) * x + c) / (x ** 2 - x), x)) / hyperexpand(hyper([a, b], [c], x)) ** 2, x) * hyper([a, b], [c], x)\n        sol = C0 * hyper([a, b], [c], x) + C1 * y2\n    elif (c - a - b).is_integer == False:\n        sol = C0 * hyper([a, b], [1 + a + b - c], 1 - x) + C1 * hyper([c - a, c - b], [1 + c - a - b], 1 - x) * (1 - x) ** (c - a - b)\n    if sol:\n        subs = match_object['mobius']\n        dtdx = simplify(1 / subs.diff(x))\n        _B = ((a + b + 1) * x - c).subs(x, subs) * dtdx\n        _B = factor(_B + (x ** 2 - x).subs(x, subs) * (dtdx.diff(x) * dtdx))\n        _A = factor((x ** 2 - x).subs(x, subs) * dtdx ** 2)\n        e = exp(logcombine(Integral(cancel(_B / (2 * _A)), x), force=True))\n        sol = sol.subs(x, match_object['mobius'])\n        sol = sol.subs(x, x ** match_object['k'])\n        e = e.subs(x, x ** match_object['k'])\n        if not A.is_zero:\n            e1 = Integral(A / 2, x)\n            e1 = exp(logcombine(e1, force=True))\n            sol = cancel(e / e1 * x ** ((-match_object['k'] + 1) / 2)) * sol\n            sol = Eq(func, sol)\n            return sol\n        sol = cancel(e * x ** ((-match_object['k'] + 1) / 2)) * sol\n        sol = Eq(func, sol)\n    return sol",
        "mutated": [
            "def get_sol_2F1_hypergeometric(eq, func, match_object):\n    if False:\n        i = 10\n    x = func.args[0]\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.polys.polytools import factor\n    (C0, C1) = get_numbered_constants(eq, num=2)\n    a = match_object['a']\n    b = match_object['b']\n    c = match_object['c']\n    A = match_object['A']\n    sol = None\n    if c.is_integer == False:\n        sol = C0 * hyper([a, b], [c], x) + C1 * hyper([a - c + 1, b - c + 1], [2 - c], x) * x ** (1 - c)\n    elif c == 1:\n        y2 = Integral(exp(Integral((-(a + b + 1) * x + c) / (x ** 2 - x), x)) / hyperexpand(hyper([a, b], [c], x)) ** 2, x) * hyper([a, b], [c], x)\n        sol = C0 * hyper([a, b], [c], x) + C1 * y2\n    elif (c - a - b).is_integer == False:\n        sol = C0 * hyper([a, b], [1 + a + b - c], 1 - x) + C1 * hyper([c - a, c - b], [1 + c - a - b], 1 - x) * (1 - x) ** (c - a - b)\n    if sol:\n        subs = match_object['mobius']\n        dtdx = simplify(1 / subs.diff(x))\n        _B = ((a + b + 1) * x - c).subs(x, subs) * dtdx\n        _B = factor(_B + (x ** 2 - x).subs(x, subs) * (dtdx.diff(x) * dtdx))\n        _A = factor((x ** 2 - x).subs(x, subs) * dtdx ** 2)\n        e = exp(logcombine(Integral(cancel(_B / (2 * _A)), x), force=True))\n        sol = sol.subs(x, match_object['mobius'])\n        sol = sol.subs(x, x ** match_object['k'])\n        e = e.subs(x, x ** match_object['k'])\n        if not A.is_zero:\n            e1 = Integral(A / 2, x)\n            e1 = exp(logcombine(e1, force=True))\n            sol = cancel(e / e1 * x ** ((-match_object['k'] + 1) / 2)) * sol\n            sol = Eq(func, sol)\n            return sol\n        sol = cancel(e * x ** ((-match_object['k'] + 1) / 2)) * sol\n        sol = Eq(func, sol)\n    return sol",
            "def get_sol_2F1_hypergeometric(eq, func, match_object):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = func.args[0]\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.polys.polytools import factor\n    (C0, C1) = get_numbered_constants(eq, num=2)\n    a = match_object['a']\n    b = match_object['b']\n    c = match_object['c']\n    A = match_object['A']\n    sol = None\n    if c.is_integer == False:\n        sol = C0 * hyper([a, b], [c], x) + C1 * hyper([a - c + 1, b - c + 1], [2 - c], x) * x ** (1 - c)\n    elif c == 1:\n        y2 = Integral(exp(Integral((-(a + b + 1) * x + c) / (x ** 2 - x), x)) / hyperexpand(hyper([a, b], [c], x)) ** 2, x) * hyper([a, b], [c], x)\n        sol = C0 * hyper([a, b], [c], x) + C1 * y2\n    elif (c - a - b).is_integer == False:\n        sol = C0 * hyper([a, b], [1 + a + b - c], 1 - x) + C1 * hyper([c - a, c - b], [1 + c - a - b], 1 - x) * (1 - x) ** (c - a - b)\n    if sol:\n        subs = match_object['mobius']\n        dtdx = simplify(1 / subs.diff(x))\n        _B = ((a + b + 1) * x - c).subs(x, subs) * dtdx\n        _B = factor(_B + (x ** 2 - x).subs(x, subs) * (dtdx.diff(x) * dtdx))\n        _A = factor((x ** 2 - x).subs(x, subs) * dtdx ** 2)\n        e = exp(logcombine(Integral(cancel(_B / (2 * _A)), x), force=True))\n        sol = sol.subs(x, match_object['mobius'])\n        sol = sol.subs(x, x ** match_object['k'])\n        e = e.subs(x, x ** match_object['k'])\n        if not A.is_zero:\n            e1 = Integral(A / 2, x)\n            e1 = exp(logcombine(e1, force=True))\n            sol = cancel(e / e1 * x ** ((-match_object['k'] + 1) / 2)) * sol\n            sol = Eq(func, sol)\n            return sol\n        sol = cancel(e * x ** ((-match_object['k'] + 1) / 2)) * sol\n        sol = Eq(func, sol)\n    return sol",
            "def get_sol_2F1_hypergeometric(eq, func, match_object):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = func.args[0]\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.polys.polytools import factor\n    (C0, C1) = get_numbered_constants(eq, num=2)\n    a = match_object['a']\n    b = match_object['b']\n    c = match_object['c']\n    A = match_object['A']\n    sol = None\n    if c.is_integer == False:\n        sol = C0 * hyper([a, b], [c], x) + C1 * hyper([a - c + 1, b - c + 1], [2 - c], x) * x ** (1 - c)\n    elif c == 1:\n        y2 = Integral(exp(Integral((-(a + b + 1) * x + c) / (x ** 2 - x), x)) / hyperexpand(hyper([a, b], [c], x)) ** 2, x) * hyper([a, b], [c], x)\n        sol = C0 * hyper([a, b], [c], x) + C1 * y2\n    elif (c - a - b).is_integer == False:\n        sol = C0 * hyper([a, b], [1 + a + b - c], 1 - x) + C1 * hyper([c - a, c - b], [1 + c - a - b], 1 - x) * (1 - x) ** (c - a - b)\n    if sol:\n        subs = match_object['mobius']\n        dtdx = simplify(1 / subs.diff(x))\n        _B = ((a + b + 1) * x - c).subs(x, subs) * dtdx\n        _B = factor(_B + (x ** 2 - x).subs(x, subs) * (dtdx.diff(x) * dtdx))\n        _A = factor((x ** 2 - x).subs(x, subs) * dtdx ** 2)\n        e = exp(logcombine(Integral(cancel(_B / (2 * _A)), x), force=True))\n        sol = sol.subs(x, match_object['mobius'])\n        sol = sol.subs(x, x ** match_object['k'])\n        e = e.subs(x, x ** match_object['k'])\n        if not A.is_zero:\n            e1 = Integral(A / 2, x)\n            e1 = exp(logcombine(e1, force=True))\n            sol = cancel(e / e1 * x ** ((-match_object['k'] + 1) / 2)) * sol\n            sol = Eq(func, sol)\n            return sol\n        sol = cancel(e * x ** ((-match_object['k'] + 1) / 2)) * sol\n        sol = Eq(func, sol)\n    return sol",
            "def get_sol_2F1_hypergeometric(eq, func, match_object):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = func.args[0]\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.polys.polytools import factor\n    (C0, C1) = get_numbered_constants(eq, num=2)\n    a = match_object['a']\n    b = match_object['b']\n    c = match_object['c']\n    A = match_object['A']\n    sol = None\n    if c.is_integer == False:\n        sol = C0 * hyper([a, b], [c], x) + C1 * hyper([a - c + 1, b - c + 1], [2 - c], x) * x ** (1 - c)\n    elif c == 1:\n        y2 = Integral(exp(Integral((-(a + b + 1) * x + c) / (x ** 2 - x), x)) / hyperexpand(hyper([a, b], [c], x)) ** 2, x) * hyper([a, b], [c], x)\n        sol = C0 * hyper([a, b], [c], x) + C1 * y2\n    elif (c - a - b).is_integer == False:\n        sol = C0 * hyper([a, b], [1 + a + b - c], 1 - x) + C1 * hyper([c - a, c - b], [1 + c - a - b], 1 - x) * (1 - x) ** (c - a - b)\n    if sol:\n        subs = match_object['mobius']\n        dtdx = simplify(1 / subs.diff(x))\n        _B = ((a + b + 1) * x - c).subs(x, subs) * dtdx\n        _B = factor(_B + (x ** 2 - x).subs(x, subs) * (dtdx.diff(x) * dtdx))\n        _A = factor((x ** 2 - x).subs(x, subs) * dtdx ** 2)\n        e = exp(logcombine(Integral(cancel(_B / (2 * _A)), x), force=True))\n        sol = sol.subs(x, match_object['mobius'])\n        sol = sol.subs(x, x ** match_object['k'])\n        e = e.subs(x, x ** match_object['k'])\n        if not A.is_zero:\n            e1 = Integral(A / 2, x)\n            e1 = exp(logcombine(e1, force=True))\n            sol = cancel(e / e1 * x ** ((-match_object['k'] + 1) / 2)) * sol\n            sol = Eq(func, sol)\n            return sol\n        sol = cancel(e * x ** ((-match_object['k'] + 1) / 2)) * sol\n        sol = Eq(func, sol)\n    return sol",
            "def get_sol_2F1_hypergeometric(eq, func, match_object):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = func.args[0]\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.polys.polytools import factor\n    (C0, C1) = get_numbered_constants(eq, num=2)\n    a = match_object['a']\n    b = match_object['b']\n    c = match_object['c']\n    A = match_object['A']\n    sol = None\n    if c.is_integer == False:\n        sol = C0 * hyper([a, b], [c], x) + C1 * hyper([a - c + 1, b - c + 1], [2 - c], x) * x ** (1 - c)\n    elif c == 1:\n        y2 = Integral(exp(Integral((-(a + b + 1) * x + c) / (x ** 2 - x), x)) / hyperexpand(hyper([a, b], [c], x)) ** 2, x) * hyper([a, b], [c], x)\n        sol = C0 * hyper([a, b], [c], x) + C1 * y2\n    elif (c - a - b).is_integer == False:\n        sol = C0 * hyper([a, b], [1 + a + b - c], 1 - x) + C1 * hyper([c - a, c - b], [1 + c - a - b], 1 - x) * (1 - x) ** (c - a - b)\n    if sol:\n        subs = match_object['mobius']\n        dtdx = simplify(1 / subs.diff(x))\n        _B = ((a + b + 1) * x - c).subs(x, subs) * dtdx\n        _B = factor(_B + (x ** 2 - x).subs(x, subs) * (dtdx.diff(x) * dtdx))\n        _A = factor((x ** 2 - x).subs(x, subs) * dtdx ** 2)\n        e = exp(logcombine(Integral(cancel(_B / (2 * _A)), x), force=True))\n        sol = sol.subs(x, match_object['mobius'])\n        sol = sol.subs(x, x ** match_object['k'])\n        e = e.subs(x, x ** match_object['k'])\n        if not A.is_zero:\n            e1 = Integral(A / 2, x)\n            e1 = exp(logcombine(e1, force=True))\n            sol = cancel(e / e1 * x ** ((-match_object['k'] + 1) / 2)) * sol\n            sol = Eq(func, sol)\n            return sol\n        sol = cancel(e * x ** ((-match_object['k'] + 1) / 2)) * sol\n        sol = Eq(func, sol)\n    return sol"
        ]
    }
]