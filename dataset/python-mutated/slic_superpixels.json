[
    {
        "func_name": "_get_mask_centroids",
        "original": "def _get_mask_centroids(mask, n_centroids, multichannel):\n    \"\"\"Find regularly spaced centroids on a mask.\n\n    Parameters\n    ----------\n    mask : 3D ndarray\n        The mask within which the centroids must be positioned.\n    n_centroids : int\n        The number of centroids to be returned.\n\n    Returns\n    -------\n    centroids : 2D ndarray\n        The coordinates of the centroids with shape (n_centroids, 3).\n    steps : 1D ndarray\n        The approximate distance between two seeds in all dimensions.\n\n    \"\"\"\n    coord = np.array(np.nonzero(mask), dtype=float).T\n    rng = random.RandomState(123)\n    idx_full = np.arange(len(coord), dtype=int)\n    idx = np.sort(rng.choice(idx_full, min(n_centroids, len(coord)), replace=False))\n    dense_factor = 10\n    ndim_spatial = mask.ndim - 1 if multichannel else mask.ndim\n    n_dense = int(dense_factor ** ndim_spatial * n_centroids)\n    if len(coord) > n_dense:\n        idx_dense = np.sort(rng.choice(idx_full, n_dense, replace=False))\n    else:\n        idx_dense = Ellipsis\n    (centroids, _) = kmeans2(coord[idx_dense], coord[idx], iter=5)\n    dist = squareform(pdist(centroids))\n    np.fill_diagonal(dist, np.inf)\n    closest_pts = dist.argmin(-1)\n    steps = abs(centroids - centroids[closest_pts, :]).mean(0)\n    return (centroids, steps)",
        "mutated": [
            "def _get_mask_centroids(mask, n_centroids, multichannel):\n    if False:\n        i = 10\n    'Find regularly spaced centroids on a mask.\\n\\n    Parameters\\n    ----------\\n    mask : 3D ndarray\\n        The mask within which the centroids must be positioned.\\n    n_centroids : int\\n        The number of centroids to be returned.\\n\\n    Returns\\n    -------\\n    centroids : 2D ndarray\\n        The coordinates of the centroids with shape (n_centroids, 3).\\n    steps : 1D ndarray\\n        The approximate distance between two seeds in all dimensions.\\n\\n    '\n    coord = np.array(np.nonzero(mask), dtype=float).T\n    rng = random.RandomState(123)\n    idx_full = np.arange(len(coord), dtype=int)\n    idx = np.sort(rng.choice(idx_full, min(n_centroids, len(coord)), replace=False))\n    dense_factor = 10\n    ndim_spatial = mask.ndim - 1 if multichannel else mask.ndim\n    n_dense = int(dense_factor ** ndim_spatial * n_centroids)\n    if len(coord) > n_dense:\n        idx_dense = np.sort(rng.choice(idx_full, n_dense, replace=False))\n    else:\n        idx_dense = Ellipsis\n    (centroids, _) = kmeans2(coord[idx_dense], coord[idx], iter=5)\n    dist = squareform(pdist(centroids))\n    np.fill_diagonal(dist, np.inf)\n    closest_pts = dist.argmin(-1)\n    steps = abs(centroids - centroids[closest_pts, :]).mean(0)\n    return (centroids, steps)",
            "def _get_mask_centroids(mask, n_centroids, multichannel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Find regularly spaced centroids on a mask.\\n\\n    Parameters\\n    ----------\\n    mask : 3D ndarray\\n        The mask within which the centroids must be positioned.\\n    n_centroids : int\\n        The number of centroids to be returned.\\n\\n    Returns\\n    -------\\n    centroids : 2D ndarray\\n        The coordinates of the centroids with shape (n_centroids, 3).\\n    steps : 1D ndarray\\n        The approximate distance between two seeds in all dimensions.\\n\\n    '\n    coord = np.array(np.nonzero(mask), dtype=float).T\n    rng = random.RandomState(123)\n    idx_full = np.arange(len(coord), dtype=int)\n    idx = np.sort(rng.choice(idx_full, min(n_centroids, len(coord)), replace=False))\n    dense_factor = 10\n    ndim_spatial = mask.ndim - 1 if multichannel else mask.ndim\n    n_dense = int(dense_factor ** ndim_spatial * n_centroids)\n    if len(coord) > n_dense:\n        idx_dense = np.sort(rng.choice(idx_full, n_dense, replace=False))\n    else:\n        idx_dense = Ellipsis\n    (centroids, _) = kmeans2(coord[idx_dense], coord[idx], iter=5)\n    dist = squareform(pdist(centroids))\n    np.fill_diagonal(dist, np.inf)\n    closest_pts = dist.argmin(-1)\n    steps = abs(centroids - centroids[closest_pts, :]).mean(0)\n    return (centroids, steps)",
            "def _get_mask_centroids(mask, n_centroids, multichannel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Find regularly spaced centroids on a mask.\\n\\n    Parameters\\n    ----------\\n    mask : 3D ndarray\\n        The mask within which the centroids must be positioned.\\n    n_centroids : int\\n        The number of centroids to be returned.\\n\\n    Returns\\n    -------\\n    centroids : 2D ndarray\\n        The coordinates of the centroids with shape (n_centroids, 3).\\n    steps : 1D ndarray\\n        The approximate distance between two seeds in all dimensions.\\n\\n    '\n    coord = np.array(np.nonzero(mask), dtype=float).T\n    rng = random.RandomState(123)\n    idx_full = np.arange(len(coord), dtype=int)\n    idx = np.sort(rng.choice(idx_full, min(n_centroids, len(coord)), replace=False))\n    dense_factor = 10\n    ndim_spatial = mask.ndim - 1 if multichannel else mask.ndim\n    n_dense = int(dense_factor ** ndim_spatial * n_centroids)\n    if len(coord) > n_dense:\n        idx_dense = np.sort(rng.choice(idx_full, n_dense, replace=False))\n    else:\n        idx_dense = Ellipsis\n    (centroids, _) = kmeans2(coord[idx_dense], coord[idx], iter=5)\n    dist = squareform(pdist(centroids))\n    np.fill_diagonal(dist, np.inf)\n    closest_pts = dist.argmin(-1)\n    steps = abs(centroids - centroids[closest_pts, :]).mean(0)\n    return (centroids, steps)",
            "def _get_mask_centroids(mask, n_centroids, multichannel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Find regularly spaced centroids on a mask.\\n\\n    Parameters\\n    ----------\\n    mask : 3D ndarray\\n        The mask within which the centroids must be positioned.\\n    n_centroids : int\\n        The number of centroids to be returned.\\n\\n    Returns\\n    -------\\n    centroids : 2D ndarray\\n        The coordinates of the centroids with shape (n_centroids, 3).\\n    steps : 1D ndarray\\n        The approximate distance between two seeds in all dimensions.\\n\\n    '\n    coord = np.array(np.nonzero(mask), dtype=float).T\n    rng = random.RandomState(123)\n    idx_full = np.arange(len(coord), dtype=int)\n    idx = np.sort(rng.choice(idx_full, min(n_centroids, len(coord)), replace=False))\n    dense_factor = 10\n    ndim_spatial = mask.ndim - 1 if multichannel else mask.ndim\n    n_dense = int(dense_factor ** ndim_spatial * n_centroids)\n    if len(coord) > n_dense:\n        idx_dense = np.sort(rng.choice(idx_full, n_dense, replace=False))\n    else:\n        idx_dense = Ellipsis\n    (centroids, _) = kmeans2(coord[idx_dense], coord[idx], iter=5)\n    dist = squareform(pdist(centroids))\n    np.fill_diagonal(dist, np.inf)\n    closest_pts = dist.argmin(-1)\n    steps = abs(centroids - centroids[closest_pts, :]).mean(0)\n    return (centroids, steps)",
            "def _get_mask_centroids(mask, n_centroids, multichannel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Find regularly spaced centroids on a mask.\\n\\n    Parameters\\n    ----------\\n    mask : 3D ndarray\\n        The mask within which the centroids must be positioned.\\n    n_centroids : int\\n        The number of centroids to be returned.\\n\\n    Returns\\n    -------\\n    centroids : 2D ndarray\\n        The coordinates of the centroids with shape (n_centroids, 3).\\n    steps : 1D ndarray\\n        The approximate distance between two seeds in all dimensions.\\n\\n    '\n    coord = np.array(np.nonzero(mask), dtype=float).T\n    rng = random.RandomState(123)\n    idx_full = np.arange(len(coord), dtype=int)\n    idx = np.sort(rng.choice(idx_full, min(n_centroids, len(coord)), replace=False))\n    dense_factor = 10\n    ndim_spatial = mask.ndim - 1 if multichannel else mask.ndim\n    n_dense = int(dense_factor ** ndim_spatial * n_centroids)\n    if len(coord) > n_dense:\n        idx_dense = np.sort(rng.choice(idx_full, n_dense, replace=False))\n    else:\n        idx_dense = Ellipsis\n    (centroids, _) = kmeans2(coord[idx_dense], coord[idx], iter=5)\n    dist = squareform(pdist(centroids))\n    np.fill_diagonal(dist, np.inf)\n    closest_pts = dist.argmin(-1)\n    steps = abs(centroids - centroids[closest_pts, :]).mean(0)\n    return (centroids, steps)"
        ]
    },
    {
        "func_name": "_get_grid_centroids",
        "original": "def _get_grid_centroids(image, n_centroids):\n    \"\"\"Find regularly spaced centroids on the image.\n\n    Parameters\n    ----------\n    image : 2D, 3D or 4D ndarray\n        Input image, which can be 2D or 3D, and grayscale or\n        multichannel.\n    n_centroids : int\n        The (approximate) number of centroids to be returned.\n\n    Returns\n    -------\n    centroids : 2D ndarray\n        The coordinates of the centroids with shape (~n_centroids, 3).\n    steps : 1D ndarray\n        The approximate distance between two seeds in all dimensions.\n\n    \"\"\"\n    (d, h, w) = image.shape[:3]\n    (grid_z, grid_y, grid_x) = np.mgrid[:d, :h, :w]\n    slices = regular_grid(image.shape[:3], n_centroids)\n    centroids_z = grid_z[slices].ravel()[..., np.newaxis]\n    centroids_y = grid_y[slices].ravel()[..., np.newaxis]\n    centroids_x = grid_x[slices].ravel()[..., np.newaxis]\n    centroids = np.concatenate([centroids_z, centroids_y, centroids_x], axis=-1)\n    steps = np.asarray([float(s.step) if s.step is not None else 1.0 for s in slices])\n    return (centroids, steps)",
        "mutated": [
            "def _get_grid_centroids(image, n_centroids):\n    if False:\n        i = 10\n    'Find regularly spaced centroids on the image.\\n\\n    Parameters\\n    ----------\\n    image : 2D, 3D or 4D ndarray\\n        Input image, which can be 2D or 3D, and grayscale or\\n        multichannel.\\n    n_centroids : int\\n        The (approximate) number of centroids to be returned.\\n\\n    Returns\\n    -------\\n    centroids : 2D ndarray\\n        The coordinates of the centroids with shape (~n_centroids, 3).\\n    steps : 1D ndarray\\n        The approximate distance between two seeds in all dimensions.\\n\\n    '\n    (d, h, w) = image.shape[:3]\n    (grid_z, grid_y, grid_x) = np.mgrid[:d, :h, :w]\n    slices = regular_grid(image.shape[:3], n_centroids)\n    centroids_z = grid_z[slices].ravel()[..., np.newaxis]\n    centroids_y = grid_y[slices].ravel()[..., np.newaxis]\n    centroids_x = grid_x[slices].ravel()[..., np.newaxis]\n    centroids = np.concatenate([centroids_z, centroids_y, centroids_x], axis=-1)\n    steps = np.asarray([float(s.step) if s.step is not None else 1.0 for s in slices])\n    return (centroids, steps)",
            "def _get_grid_centroids(image, n_centroids):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Find regularly spaced centroids on the image.\\n\\n    Parameters\\n    ----------\\n    image : 2D, 3D or 4D ndarray\\n        Input image, which can be 2D or 3D, and grayscale or\\n        multichannel.\\n    n_centroids : int\\n        The (approximate) number of centroids to be returned.\\n\\n    Returns\\n    -------\\n    centroids : 2D ndarray\\n        The coordinates of the centroids with shape (~n_centroids, 3).\\n    steps : 1D ndarray\\n        The approximate distance between two seeds in all dimensions.\\n\\n    '\n    (d, h, w) = image.shape[:3]\n    (grid_z, grid_y, grid_x) = np.mgrid[:d, :h, :w]\n    slices = regular_grid(image.shape[:3], n_centroids)\n    centroids_z = grid_z[slices].ravel()[..., np.newaxis]\n    centroids_y = grid_y[slices].ravel()[..., np.newaxis]\n    centroids_x = grid_x[slices].ravel()[..., np.newaxis]\n    centroids = np.concatenate([centroids_z, centroids_y, centroids_x], axis=-1)\n    steps = np.asarray([float(s.step) if s.step is not None else 1.0 for s in slices])\n    return (centroids, steps)",
            "def _get_grid_centroids(image, n_centroids):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Find regularly spaced centroids on the image.\\n\\n    Parameters\\n    ----------\\n    image : 2D, 3D or 4D ndarray\\n        Input image, which can be 2D or 3D, and grayscale or\\n        multichannel.\\n    n_centroids : int\\n        The (approximate) number of centroids to be returned.\\n\\n    Returns\\n    -------\\n    centroids : 2D ndarray\\n        The coordinates of the centroids with shape (~n_centroids, 3).\\n    steps : 1D ndarray\\n        The approximate distance between two seeds in all dimensions.\\n\\n    '\n    (d, h, w) = image.shape[:3]\n    (grid_z, grid_y, grid_x) = np.mgrid[:d, :h, :w]\n    slices = regular_grid(image.shape[:3], n_centroids)\n    centroids_z = grid_z[slices].ravel()[..., np.newaxis]\n    centroids_y = grid_y[slices].ravel()[..., np.newaxis]\n    centroids_x = grid_x[slices].ravel()[..., np.newaxis]\n    centroids = np.concatenate([centroids_z, centroids_y, centroids_x], axis=-1)\n    steps = np.asarray([float(s.step) if s.step is not None else 1.0 for s in slices])\n    return (centroids, steps)",
            "def _get_grid_centroids(image, n_centroids):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Find regularly spaced centroids on the image.\\n\\n    Parameters\\n    ----------\\n    image : 2D, 3D or 4D ndarray\\n        Input image, which can be 2D or 3D, and grayscale or\\n        multichannel.\\n    n_centroids : int\\n        The (approximate) number of centroids to be returned.\\n\\n    Returns\\n    -------\\n    centroids : 2D ndarray\\n        The coordinates of the centroids with shape (~n_centroids, 3).\\n    steps : 1D ndarray\\n        The approximate distance between two seeds in all dimensions.\\n\\n    '\n    (d, h, w) = image.shape[:3]\n    (grid_z, grid_y, grid_x) = np.mgrid[:d, :h, :w]\n    slices = regular_grid(image.shape[:3], n_centroids)\n    centroids_z = grid_z[slices].ravel()[..., np.newaxis]\n    centroids_y = grid_y[slices].ravel()[..., np.newaxis]\n    centroids_x = grid_x[slices].ravel()[..., np.newaxis]\n    centroids = np.concatenate([centroids_z, centroids_y, centroids_x], axis=-1)\n    steps = np.asarray([float(s.step) if s.step is not None else 1.0 for s in slices])\n    return (centroids, steps)",
            "def _get_grid_centroids(image, n_centroids):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Find regularly spaced centroids on the image.\\n\\n    Parameters\\n    ----------\\n    image : 2D, 3D or 4D ndarray\\n        Input image, which can be 2D or 3D, and grayscale or\\n        multichannel.\\n    n_centroids : int\\n        The (approximate) number of centroids to be returned.\\n\\n    Returns\\n    -------\\n    centroids : 2D ndarray\\n        The coordinates of the centroids with shape (~n_centroids, 3).\\n    steps : 1D ndarray\\n        The approximate distance between two seeds in all dimensions.\\n\\n    '\n    (d, h, w) = image.shape[:3]\n    (grid_z, grid_y, grid_x) = np.mgrid[:d, :h, :w]\n    slices = regular_grid(image.shape[:3], n_centroids)\n    centroids_z = grid_z[slices].ravel()[..., np.newaxis]\n    centroids_y = grid_y[slices].ravel()[..., np.newaxis]\n    centroids_x = grid_x[slices].ravel()[..., np.newaxis]\n    centroids = np.concatenate([centroids_z, centroids_y, centroids_x], axis=-1)\n    steps = np.asarray([float(s.step) if s.step is not None else 1.0 for s in slices])\n    return (centroids, steps)"
        ]
    },
    {
        "func_name": "slic",
        "original": "@utils.channel_as_last_axis(multichannel_output=False)\ndef slic(image, n_segments=100, compactness=10.0, max_num_iter=10, sigma=0, spacing=None, convert2lab=None, enforce_connectivity=True, min_size_factor=0.5, max_size_factor=3, slic_zero=False, start_label=1, mask=None, *, channel_axis=-1):\n    \"\"\"Segments image using k-means clustering in Color-(x,y,z) space.\n\n    Parameters\n    ----------\n    image : (M, N[, P][, C]) ndarray\n        Input image. Can be 2D or 3D, and grayscale or multichannel\n        (see `channel_axis` parameter).\n        Input image must either be NaN-free or the NaN's must be masked out.\n    n_segments : int, optional\n        The (approximate) number of labels in the segmented output image.\n    compactness : float, optional\n        Balances color proximity and space proximity. Higher values give\n        more weight to space proximity, making superpixel shapes more\n        square/cubic. In SLICO mode, this is the initial compactness.\n        This parameter depends strongly on image contrast and on the\n        shapes of objects in the image. We recommend exploring possible\n        values on a log scale, e.g., 0.01, 0.1, 1, 10, 100, before\n        refining around a chosen value.\n    max_num_iter : int, optional\n        Maximum number of iterations of k-means.\n    sigma : float or array-like of floats, optional\n        Width of Gaussian smoothing kernel for pre-processing for each\n        dimension of the image. The same sigma is applied to each dimension in\n        case of a scalar value. Zero means no smoothing.\n        Note that `sigma` is automatically scaled if it is scalar and\n        if a manual voxel spacing is provided (see Notes section). If\n        sigma is array-like, its size must match ``image``'s number\n        of spatial dimensions.\n    spacing : array-like of floats, optional\n        The voxel spacing along each spatial dimension. By default,\n        `slic` assumes uniform spacing (same voxel resolution along\n        each spatial dimension).\n        This parameter controls the weights of the distances along the\n        spatial dimensions during k-means clustering.\n    convert2lab : bool, optional\n        Whether the input should be converted to Lab colorspace prior to\n        segmentation. The input image *must* be RGB. Highly recommended.\n        This option defaults to ``True`` when ``channel_axis` is not None *and*\n        ``image.shape[-1] == 3``.\n    enforce_connectivity : bool, optional\n        Whether the generated segments are connected or not\n    min_size_factor : float, optional\n        Proportion of the minimum segment size to be removed with respect\n        to the supposed segment size ```depth*width*height/n_segments```\n    max_size_factor : float, optional\n        Proportion of the maximum connected segment size. A value of 3 works\n        in most of the cases.\n    slic_zero : bool, optional\n        Run SLIC-zero, the zero-parameter mode of SLIC. [2]_\n    start_label : int, optional\n        The labels' index start. Should be 0 or 1.\n\n        .. versionadded:: 0.17\n           ``start_label`` was introduced in 0.17\n    mask : ndarray, optional\n        If provided, superpixels are computed only where mask is True,\n        and seed points are homogeneously distributed over the mask\n        using a k-means clustering strategy. Mask number of dimensions\n        must be equal to image number of spatial dimensions.\n\n        .. versionadded:: 0.17\n           ``mask`` was introduced in 0.17\n    channel_axis : int or None, optional\n        If None, the image is assumed to be a grayscale (single channel) image.\n        Otherwise, this parameter indicates which axis of the array corresponds\n        to channels.\n\n        .. versionadded:: 0.19\n           ``channel_axis`` was added in 0.19.\n\n    Returns\n    -------\n    labels : 2D or 3D array\n        Integer mask indicating segment labels.\n\n    Raises\n    ------\n    ValueError\n        If ``convert2lab`` is set to ``True`` but the last array\n        dimension is not of length 3.\n    ValueError\n        If ``start_label`` is not 0 or 1.\n    ValueError\n        If ``image`` contains unmasked NaN values.\n    ValueError\n        If ``image`` contains unmasked infinite values.\n    ValueError\n        If ``image`` is 2D but ``channel_axis`` is -1 (the default).\n\n    Notes\n    -----\n    * If `sigma > 0`, the image is smoothed using a Gaussian kernel prior to\n      segmentation.\n\n    * If `sigma` is scalar and `spacing` is provided, the kernel width is\n      divided along each dimension by the spacing. For example, if ``sigma=1``\n      and ``spacing=[5, 1, 1]``, the effective `sigma` is ``[0.2, 1, 1]``. This\n      ensures sensible smoothing for anisotropic images.\n\n    * The image is rescaled to be in [0, 1] prior to processing (masked\n      values are ignored).\n\n    * Images of shape (M, N, 3) are interpreted as 2D RGB images by default. To\n      interpret them as 3D with the last dimension having length 3, use\n      `channel_axis=None`.\n\n    * `start_label` is introduced to handle the issue [4]_. Label indexing\n      starts at 1 by default.\n\n    References\n    ----------\n    .. [1] Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi,\n        Pascal Fua, and Sabine S\u00fcsstrunk, SLIC Superpixels Compared to\n        State-of-the-art Superpixel Methods, TPAMI, May 2012.\n        :DOI:`10.1109/TPAMI.2012.120`\n    .. [2] https://www.epfl.ch/labs/ivrl/research/slic-superpixels/#SLICO\n    .. [3] Irving, Benjamin. \"maskSLIC: regional superpixel generation with\n           application to local pathology characterisation in medical images.\",\n           2016, :arXiv:`1606.09518`\n    .. [4] https://github.com/scikit-image/scikit-image/issues/3722\n\n    Examples\n    --------\n    >>> from skimage.segmentation import slic\n    >>> from skimage.data import astronaut\n    >>> img = astronaut()\n    >>> segments = slic(img, n_segments=100, compactness=10)\n\n    Increasing the compactness parameter yields more square regions:\n\n    >>> segments = slic(img, n_segments=100, compactness=20)\n\n    \"\"\"\n    if image.ndim == 2 and channel_axis is not None:\n        raise ValueError(f'channel_axis={channel_axis} indicates multichannel, which is not supported for a two-dimensional image; use channel_axis=None if the image is grayscale')\n    image = img_as_float(image)\n    float_dtype = utils._supported_float_type(image.dtype)\n    image = image.astype(float_dtype, copy=True)\n    if mask is not None:\n        mask = np.ascontiguousarray(mask, dtype=bool)\n        if channel_axis is not None:\n            mask_ = np.expand_dims(mask, axis=channel_axis)\n            mask_ = np.broadcast_to(mask_, image.shape)\n        else:\n            mask_ = mask\n        image_values = image[mask_]\n    else:\n        image_values = image\n    imin = image_values.min()\n    imax = image_values.max()\n    if np.isnan(imin):\n        raise ValueError('unmasked NaN values in image are not supported')\n    if np.isinf(imin) or np.isinf(imax):\n        raise ValueError('unmasked infinite values in image are not supported')\n    image -= imin\n    if imax != imin:\n        image /= imax - imin\n    use_mask = mask is not None\n    dtype = image.dtype\n    is_2d = False\n    multichannel = channel_axis is not None\n    if image.ndim == 2:\n        image = image[np.newaxis, ..., np.newaxis]\n        is_2d = True\n    elif image.ndim == 3 and multichannel:\n        image = image[np.newaxis, ...]\n        is_2d = True\n    elif image.ndim == 3 and (not multichannel):\n        image = image[..., np.newaxis]\n    if multichannel and (convert2lab or convert2lab is None):\n        if image.shape[channel_axis] != 3 and convert2lab:\n            raise ValueError('Lab colorspace conversion requires a RGB image.')\n        elif image.shape[channel_axis] == 3:\n            image = rgb2lab(image)\n    if start_label not in [0, 1]:\n        raise ValueError('start_label should be 0 or 1.')\n    update_centroids = False\n    if use_mask:\n        mask = mask.view('uint8')\n        if mask.ndim == 2:\n            mask = np.ascontiguousarray(mask[np.newaxis, ...])\n        if mask.shape != image.shape[:3]:\n            raise ValueError('image and mask should have the same shape.')\n        (centroids, steps) = _get_mask_centroids(mask, n_segments, multichannel)\n        update_centroids = True\n    else:\n        (centroids, steps) = _get_grid_centroids(image, n_segments)\n    if spacing is None:\n        spacing = np.ones(3, dtype=dtype)\n    elif isinstance(spacing, Iterable):\n        spacing = np.asarray(spacing, dtype=dtype)\n        if is_2d:\n            if spacing.size != 2:\n                if spacing.size == 3:\n                    warn('Input image is 2D: spacing number of elements must be 2. In the future, a ValueError will be raised.', FutureWarning, stacklevel=2)\n                else:\n                    raise ValueError(f'Input image is 2D, but spacing has {spacing.size} elements (expected 2).')\n            else:\n                spacing = np.insert(spacing, 0, 1)\n        elif spacing.size != 3:\n            raise ValueError(f'Input image is 3D, but spacing has {spacing.size} elements (expected 3).')\n        spacing = np.ascontiguousarray(spacing, dtype=dtype)\n    else:\n        raise TypeError('spacing must be None or iterable.')\n    if np.isscalar(sigma):\n        sigma = np.array([sigma, sigma, sigma], dtype=dtype)\n        sigma /= spacing\n    elif isinstance(sigma, Iterable):\n        sigma = np.asarray(sigma, dtype=dtype)\n        if is_2d:\n            if sigma.size != 2:\n                if spacing.size == 3:\n                    warn('Input image is 2D: sigma number of elements must be 2. In the future, a ValueError will be raised.', FutureWarning, stacklevel=2)\n                else:\n                    raise ValueError(f'Input image is 2D, but sigma has {sigma.size} elements (expected 2).')\n            else:\n                sigma = np.insert(sigma, 0, 0)\n        elif sigma.size != 3:\n            raise ValueError(f'Input image is 3D, but sigma has {sigma.size} elements (expected 3).')\n    if (sigma > 0).any():\n        sigma = list(sigma) + [0]\n        image = gaussian(image, sigma, mode='reflect')\n    n_centroids = centroids.shape[0]\n    segments = np.ascontiguousarray(np.concatenate([centroids, np.zeros((n_centroids, image.shape[3]))], axis=-1), dtype=dtype)\n    step = max(steps)\n    ratio = 1.0 / compactness\n    image = np.ascontiguousarray(image * ratio, dtype=dtype)\n    if update_centroids:\n        _slic_cython(image, mask, segments, step, max_num_iter, spacing, slic_zero, ignore_color=True, start_label=start_label)\n    labels = _slic_cython(image, mask, segments, step, max_num_iter, spacing, slic_zero, ignore_color=False, start_label=start_label)\n    if enforce_connectivity:\n        if use_mask:\n            segment_size = mask.sum() / n_centroids\n        else:\n            segment_size = math.prod(image.shape[:3]) / n_centroids\n        min_size = int(min_size_factor * segment_size)\n        max_size = int(max_size_factor * segment_size)\n        labels = _enforce_label_connectivity_cython(labels, min_size, max_size, start_label=start_label)\n    if is_2d:\n        labels = labels[0]\n    return labels",
        "mutated": [
            "@utils.channel_as_last_axis(multichannel_output=False)\ndef slic(image, n_segments=100, compactness=10.0, max_num_iter=10, sigma=0, spacing=None, convert2lab=None, enforce_connectivity=True, min_size_factor=0.5, max_size_factor=3, slic_zero=False, start_label=1, mask=None, *, channel_axis=-1):\n    if False:\n        i = 10\n    'Segments image using k-means clustering in Color-(x,y,z) space.\\n\\n    Parameters\\n    ----------\\n    image : (M, N[, P][, C]) ndarray\\n        Input image. Can be 2D or 3D, and grayscale or multichannel\\n        (see `channel_axis` parameter).\\n        Input image must either be NaN-free or the NaN\\'s must be masked out.\\n    n_segments : int, optional\\n        The (approximate) number of labels in the segmented output image.\\n    compactness : float, optional\\n        Balances color proximity and space proximity. Higher values give\\n        more weight to space proximity, making superpixel shapes more\\n        square/cubic. In SLICO mode, this is the initial compactness.\\n        This parameter depends strongly on image contrast and on the\\n        shapes of objects in the image. We recommend exploring possible\\n        values on a log scale, e.g., 0.01, 0.1, 1, 10, 100, before\\n        refining around a chosen value.\\n    max_num_iter : int, optional\\n        Maximum number of iterations of k-means.\\n    sigma : float or array-like of floats, optional\\n        Width of Gaussian smoothing kernel for pre-processing for each\\n        dimension of the image. The same sigma is applied to each dimension in\\n        case of a scalar value. Zero means no smoothing.\\n        Note that `sigma` is automatically scaled if it is scalar and\\n        if a manual voxel spacing is provided (see Notes section). If\\n        sigma is array-like, its size must match ``image``\\'s number\\n        of spatial dimensions.\\n    spacing : array-like of floats, optional\\n        The voxel spacing along each spatial dimension. By default,\\n        `slic` assumes uniform spacing (same voxel resolution along\\n        each spatial dimension).\\n        This parameter controls the weights of the distances along the\\n        spatial dimensions during k-means clustering.\\n    convert2lab : bool, optional\\n        Whether the input should be converted to Lab colorspace prior to\\n        segmentation. The input image *must* be RGB. Highly recommended.\\n        This option defaults to ``True`` when ``channel_axis` is not None *and*\\n        ``image.shape[-1] == 3``.\\n    enforce_connectivity : bool, optional\\n        Whether the generated segments are connected or not\\n    min_size_factor : float, optional\\n        Proportion of the minimum segment size to be removed with respect\\n        to the supposed segment size ```depth*width*height/n_segments```\\n    max_size_factor : float, optional\\n        Proportion of the maximum connected segment size. A value of 3 works\\n        in most of the cases.\\n    slic_zero : bool, optional\\n        Run SLIC-zero, the zero-parameter mode of SLIC. [2]_\\n    start_label : int, optional\\n        The labels\\' index start. Should be 0 or 1.\\n\\n        .. versionadded:: 0.17\\n           ``start_label`` was introduced in 0.17\\n    mask : ndarray, optional\\n        If provided, superpixels are computed only where mask is True,\\n        and seed points are homogeneously distributed over the mask\\n        using a k-means clustering strategy. Mask number of dimensions\\n        must be equal to image number of spatial dimensions.\\n\\n        .. versionadded:: 0.17\\n           ``mask`` was introduced in 0.17\\n    channel_axis : int or None, optional\\n        If None, the image is assumed to be a grayscale (single channel) image.\\n        Otherwise, this parameter indicates which axis of the array corresponds\\n        to channels.\\n\\n        .. versionadded:: 0.19\\n           ``channel_axis`` was added in 0.19.\\n\\n    Returns\\n    -------\\n    labels : 2D or 3D array\\n        Integer mask indicating segment labels.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If ``convert2lab`` is set to ``True`` but the last array\\n        dimension is not of length 3.\\n    ValueError\\n        If ``start_label`` is not 0 or 1.\\n    ValueError\\n        If ``image`` contains unmasked NaN values.\\n    ValueError\\n        If ``image`` contains unmasked infinite values.\\n    ValueError\\n        If ``image`` is 2D but ``channel_axis`` is -1 (the default).\\n\\n    Notes\\n    -----\\n    * If `sigma > 0`, the image is smoothed using a Gaussian kernel prior to\\n      segmentation.\\n\\n    * If `sigma` is scalar and `spacing` is provided, the kernel width is\\n      divided along each dimension by the spacing. For example, if ``sigma=1``\\n      and ``spacing=[5, 1, 1]``, the effective `sigma` is ``[0.2, 1, 1]``. This\\n      ensures sensible smoothing for anisotropic images.\\n\\n    * The image is rescaled to be in [0, 1] prior to processing (masked\\n      values are ignored).\\n\\n    * Images of shape (M, N, 3) are interpreted as 2D RGB images by default. To\\n      interpret them as 3D with the last dimension having length 3, use\\n      `channel_axis=None`.\\n\\n    * `start_label` is introduced to handle the issue [4]_. Label indexing\\n      starts at 1 by default.\\n\\n    References\\n    ----------\\n    .. [1] Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi,\\n        Pascal Fua, and Sabine S\u00fcsstrunk, SLIC Superpixels Compared to\\n        State-of-the-art Superpixel Methods, TPAMI, May 2012.\\n        :DOI:`10.1109/TPAMI.2012.120`\\n    .. [2] https://www.epfl.ch/labs/ivrl/research/slic-superpixels/#SLICO\\n    .. [3] Irving, Benjamin. \"maskSLIC: regional superpixel generation with\\n           application to local pathology characterisation in medical images.\",\\n           2016, :arXiv:`1606.09518`\\n    .. [4] https://github.com/scikit-image/scikit-image/issues/3722\\n\\n    Examples\\n    --------\\n    >>> from skimage.segmentation import slic\\n    >>> from skimage.data import astronaut\\n    >>> img = astronaut()\\n    >>> segments = slic(img, n_segments=100, compactness=10)\\n\\n    Increasing the compactness parameter yields more square regions:\\n\\n    >>> segments = slic(img, n_segments=100, compactness=20)\\n\\n    '\n    if image.ndim == 2 and channel_axis is not None:\n        raise ValueError(f'channel_axis={channel_axis} indicates multichannel, which is not supported for a two-dimensional image; use channel_axis=None if the image is grayscale')\n    image = img_as_float(image)\n    float_dtype = utils._supported_float_type(image.dtype)\n    image = image.astype(float_dtype, copy=True)\n    if mask is not None:\n        mask = np.ascontiguousarray(mask, dtype=bool)\n        if channel_axis is not None:\n            mask_ = np.expand_dims(mask, axis=channel_axis)\n            mask_ = np.broadcast_to(mask_, image.shape)\n        else:\n            mask_ = mask\n        image_values = image[mask_]\n    else:\n        image_values = image\n    imin = image_values.min()\n    imax = image_values.max()\n    if np.isnan(imin):\n        raise ValueError('unmasked NaN values in image are not supported')\n    if np.isinf(imin) or np.isinf(imax):\n        raise ValueError('unmasked infinite values in image are not supported')\n    image -= imin\n    if imax != imin:\n        image /= imax - imin\n    use_mask = mask is not None\n    dtype = image.dtype\n    is_2d = False\n    multichannel = channel_axis is not None\n    if image.ndim == 2:\n        image = image[np.newaxis, ..., np.newaxis]\n        is_2d = True\n    elif image.ndim == 3 and multichannel:\n        image = image[np.newaxis, ...]\n        is_2d = True\n    elif image.ndim == 3 and (not multichannel):\n        image = image[..., np.newaxis]\n    if multichannel and (convert2lab or convert2lab is None):\n        if image.shape[channel_axis] != 3 and convert2lab:\n            raise ValueError('Lab colorspace conversion requires a RGB image.')\n        elif image.shape[channel_axis] == 3:\n            image = rgb2lab(image)\n    if start_label not in [0, 1]:\n        raise ValueError('start_label should be 0 or 1.')\n    update_centroids = False\n    if use_mask:\n        mask = mask.view('uint8')\n        if mask.ndim == 2:\n            mask = np.ascontiguousarray(mask[np.newaxis, ...])\n        if mask.shape != image.shape[:3]:\n            raise ValueError('image and mask should have the same shape.')\n        (centroids, steps) = _get_mask_centroids(mask, n_segments, multichannel)\n        update_centroids = True\n    else:\n        (centroids, steps) = _get_grid_centroids(image, n_segments)\n    if spacing is None:\n        spacing = np.ones(3, dtype=dtype)\n    elif isinstance(spacing, Iterable):\n        spacing = np.asarray(spacing, dtype=dtype)\n        if is_2d:\n            if spacing.size != 2:\n                if spacing.size == 3:\n                    warn('Input image is 2D: spacing number of elements must be 2. In the future, a ValueError will be raised.', FutureWarning, stacklevel=2)\n                else:\n                    raise ValueError(f'Input image is 2D, but spacing has {spacing.size} elements (expected 2).')\n            else:\n                spacing = np.insert(spacing, 0, 1)\n        elif spacing.size != 3:\n            raise ValueError(f'Input image is 3D, but spacing has {spacing.size} elements (expected 3).')\n        spacing = np.ascontiguousarray(spacing, dtype=dtype)\n    else:\n        raise TypeError('spacing must be None or iterable.')\n    if np.isscalar(sigma):\n        sigma = np.array([sigma, sigma, sigma], dtype=dtype)\n        sigma /= spacing\n    elif isinstance(sigma, Iterable):\n        sigma = np.asarray(sigma, dtype=dtype)\n        if is_2d:\n            if sigma.size != 2:\n                if spacing.size == 3:\n                    warn('Input image is 2D: sigma number of elements must be 2. In the future, a ValueError will be raised.', FutureWarning, stacklevel=2)\n                else:\n                    raise ValueError(f'Input image is 2D, but sigma has {sigma.size} elements (expected 2).')\n            else:\n                sigma = np.insert(sigma, 0, 0)\n        elif sigma.size != 3:\n            raise ValueError(f'Input image is 3D, but sigma has {sigma.size} elements (expected 3).')\n    if (sigma > 0).any():\n        sigma = list(sigma) + [0]\n        image = gaussian(image, sigma, mode='reflect')\n    n_centroids = centroids.shape[0]\n    segments = np.ascontiguousarray(np.concatenate([centroids, np.zeros((n_centroids, image.shape[3]))], axis=-1), dtype=dtype)\n    step = max(steps)\n    ratio = 1.0 / compactness\n    image = np.ascontiguousarray(image * ratio, dtype=dtype)\n    if update_centroids:\n        _slic_cython(image, mask, segments, step, max_num_iter, spacing, slic_zero, ignore_color=True, start_label=start_label)\n    labels = _slic_cython(image, mask, segments, step, max_num_iter, spacing, slic_zero, ignore_color=False, start_label=start_label)\n    if enforce_connectivity:\n        if use_mask:\n            segment_size = mask.sum() / n_centroids\n        else:\n            segment_size = math.prod(image.shape[:3]) / n_centroids\n        min_size = int(min_size_factor * segment_size)\n        max_size = int(max_size_factor * segment_size)\n        labels = _enforce_label_connectivity_cython(labels, min_size, max_size, start_label=start_label)\n    if is_2d:\n        labels = labels[0]\n    return labels",
            "@utils.channel_as_last_axis(multichannel_output=False)\ndef slic(image, n_segments=100, compactness=10.0, max_num_iter=10, sigma=0, spacing=None, convert2lab=None, enforce_connectivity=True, min_size_factor=0.5, max_size_factor=3, slic_zero=False, start_label=1, mask=None, *, channel_axis=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Segments image using k-means clustering in Color-(x,y,z) space.\\n\\n    Parameters\\n    ----------\\n    image : (M, N[, P][, C]) ndarray\\n        Input image. Can be 2D or 3D, and grayscale or multichannel\\n        (see `channel_axis` parameter).\\n        Input image must either be NaN-free or the NaN\\'s must be masked out.\\n    n_segments : int, optional\\n        The (approximate) number of labels in the segmented output image.\\n    compactness : float, optional\\n        Balances color proximity and space proximity. Higher values give\\n        more weight to space proximity, making superpixel shapes more\\n        square/cubic. In SLICO mode, this is the initial compactness.\\n        This parameter depends strongly on image contrast and on the\\n        shapes of objects in the image. We recommend exploring possible\\n        values on a log scale, e.g., 0.01, 0.1, 1, 10, 100, before\\n        refining around a chosen value.\\n    max_num_iter : int, optional\\n        Maximum number of iterations of k-means.\\n    sigma : float or array-like of floats, optional\\n        Width of Gaussian smoothing kernel for pre-processing for each\\n        dimension of the image. The same sigma is applied to each dimension in\\n        case of a scalar value. Zero means no smoothing.\\n        Note that `sigma` is automatically scaled if it is scalar and\\n        if a manual voxel spacing is provided (see Notes section). If\\n        sigma is array-like, its size must match ``image``\\'s number\\n        of spatial dimensions.\\n    spacing : array-like of floats, optional\\n        The voxel spacing along each spatial dimension. By default,\\n        `slic` assumes uniform spacing (same voxel resolution along\\n        each spatial dimension).\\n        This parameter controls the weights of the distances along the\\n        spatial dimensions during k-means clustering.\\n    convert2lab : bool, optional\\n        Whether the input should be converted to Lab colorspace prior to\\n        segmentation. The input image *must* be RGB. Highly recommended.\\n        This option defaults to ``True`` when ``channel_axis` is not None *and*\\n        ``image.shape[-1] == 3``.\\n    enforce_connectivity : bool, optional\\n        Whether the generated segments are connected or not\\n    min_size_factor : float, optional\\n        Proportion of the minimum segment size to be removed with respect\\n        to the supposed segment size ```depth*width*height/n_segments```\\n    max_size_factor : float, optional\\n        Proportion of the maximum connected segment size. A value of 3 works\\n        in most of the cases.\\n    slic_zero : bool, optional\\n        Run SLIC-zero, the zero-parameter mode of SLIC. [2]_\\n    start_label : int, optional\\n        The labels\\' index start. Should be 0 or 1.\\n\\n        .. versionadded:: 0.17\\n           ``start_label`` was introduced in 0.17\\n    mask : ndarray, optional\\n        If provided, superpixels are computed only where mask is True,\\n        and seed points are homogeneously distributed over the mask\\n        using a k-means clustering strategy. Mask number of dimensions\\n        must be equal to image number of spatial dimensions.\\n\\n        .. versionadded:: 0.17\\n           ``mask`` was introduced in 0.17\\n    channel_axis : int or None, optional\\n        If None, the image is assumed to be a grayscale (single channel) image.\\n        Otherwise, this parameter indicates which axis of the array corresponds\\n        to channels.\\n\\n        .. versionadded:: 0.19\\n           ``channel_axis`` was added in 0.19.\\n\\n    Returns\\n    -------\\n    labels : 2D or 3D array\\n        Integer mask indicating segment labels.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If ``convert2lab`` is set to ``True`` but the last array\\n        dimension is not of length 3.\\n    ValueError\\n        If ``start_label`` is not 0 or 1.\\n    ValueError\\n        If ``image`` contains unmasked NaN values.\\n    ValueError\\n        If ``image`` contains unmasked infinite values.\\n    ValueError\\n        If ``image`` is 2D but ``channel_axis`` is -1 (the default).\\n\\n    Notes\\n    -----\\n    * If `sigma > 0`, the image is smoothed using a Gaussian kernel prior to\\n      segmentation.\\n\\n    * If `sigma` is scalar and `spacing` is provided, the kernel width is\\n      divided along each dimension by the spacing. For example, if ``sigma=1``\\n      and ``spacing=[5, 1, 1]``, the effective `sigma` is ``[0.2, 1, 1]``. This\\n      ensures sensible smoothing for anisotropic images.\\n\\n    * The image is rescaled to be in [0, 1] prior to processing (masked\\n      values are ignored).\\n\\n    * Images of shape (M, N, 3) are interpreted as 2D RGB images by default. To\\n      interpret them as 3D with the last dimension having length 3, use\\n      `channel_axis=None`.\\n\\n    * `start_label` is introduced to handle the issue [4]_. Label indexing\\n      starts at 1 by default.\\n\\n    References\\n    ----------\\n    .. [1] Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi,\\n        Pascal Fua, and Sabine S\u00fcsstrunk, SLIC Superpixels Compared to\\n        State-of-the-art Superpixel Methods, TPAMI, May 2012.\\n        :DOI:`10.1109/TPAMI.2012.120`\\n    .. [2] https://www.epfl.ch/labs/ivrl/research/slic-superpixels/#SLICO\\n    .. [3] Irving, Benjamin. \"maskSLIC: regional superpixel generation with\\n           application to local pathology characterisation in medical images.\",\\n           2016, :arXiv:`1606.09518`\\n    .. [4] https://github.com/scikit-image/scikit-image/issues/3722\\n\\n    Examples\\n    --------\\n    >>> from skimage.segmentation import slic\\n    >>> from skimage.data import astronaut\\n    >>> img = astronaut()\\n    >>> segments = slic(img, n_segments=100, compactness=10)\\n\\n    Increasing the compactness parameter yields more square regions:\\n\\n    >>> segments = slic(img, n_segments=100, compactness=20)\\n\\n    '\n    if image.ndim == 2 and channel_axis is not None:\n        raise ValueError(f'channel_axis={channel_axis} indicates multichannel, which is not supported for a two-dimensional image; use channel_axis=None if the image is grayscale')\n    image = img_as_float(image)\n    float_dtype = utils._supported_float_type(image.dtype)\n    image = image.astype(float_dtype, copy=True)\n    if mask is not None:\n        mask = np.ascontiguousarray(mask, dtype=bool)\n        if channel_axis is not None:\n            mask_ = np.expand_dims(mask, axis=channel_axis)\n            mask_ = np.broadcast_to(mask_, image.shape)\n        else:\n            mask_ = mask\n        image_values = image[mask_]\n    else:\n        image_values = image\n    imin = image_values.min()\n    imax = image_values.max()\n    if np.isnan(imin):\n        raise ValueError('unmasked NaN values in image are not supported')\n    if np.isinf(imin) or np.isinf(imax):\n        raise ValueError('unmasked infinite values in image are not supported')\n    image -= imin\n    if imax != imin:\n        image /= imax - imin\n    use_mask = mask is not None\n    dtype = image.dtype\n    is_2d = False\n    multichannel = channel_axis is not None\n    if image.ndim == 2:\n        image = image[np.newaxis, ..., np.newaxis]\n        is_2d = True\n    elif image.ndim == 3 and multichannel:\n        image = image[np.newaxis, ...]\n        is_2d = True\n    elif image.ndim == 3 and (not multichannel):\n        image = image[..., np.newaxis]\n    if multichannel and (convert2lab or convert2lab is None):\n        if image.shape[channel_axis] != 3 and convert2lab:\n            raise ValueError('Lab colorspace conversion requires a RGB image.')\n        elif image.shape[channel_axis] == 3:\n            image = rgb2lab(image)\n    if start_label not in [0, 1]:\n        raise ValueError('start_label should be 0 or 1.')\n    update_centroids = False\n    if use_mask:\n        mask = mask.view('uint8')\n        if mask.ndim == 2:\n            mask = np.ascontiguousarray(mask[np.newaxis, ...])\n        if mask.shape != image.shape[:3]:\n            raise ValueError('image and mask should have the same shape.')\n        (centroids, steps) = _get_mask_centroids(mask, n_segments, multichannel)\n        update_centroids = True\n    else:\n        (centroids, steps) = _get_grid_centroids(image, n_segments)\n    if spacing is None:\n        spacing = np.ones(3, dtype=dtype)\n    elif isinstance(spacing, Iterable):\n        spacing = np.asarray(spacing, dtype=dtype)\n        if is_2d:\n            if spacing.size != 2:\n                if spacing.size == 3:\n                    warn('Input image is 2D: spacing number of elements must be 2. In the future, a ValueError will be raised.', FutureWarning, stacklevel=2)\n                else:\n                    raise ValueError(f'Input image is 2D, but spacing has {spacing.size} elements (expected 2).')\n            else:\n                spacing = np.insert(spacing, 0, 1)\n        elif spacing.size != 3:\n            raise ValueError(f'Input image is 3D, but spacing has {spacing.size} elements (expected 3).')\n        spacing = np.ascontiguousarray(spacing, dtype=dtype)\n    else:\n        raise TypeError('spacing must be None or iterable.')\n    if np.isscalar(sigma):\n        sigma = np.array([sigma, sigma, sigma], dtype=dtype)\n        sigma /= spacing\n    elif isinstance(sigma, Iterable):\n        sigma = np.asarray(sigma, dtype=dtype)\n        if is_2d:\n            if sigma.size != 2:\n                if spacing.size == 3:\n                    warn('Input image is 2D: sigma number of elements must be 2. In the future, a ValueError will be raised.', FutureWarning, stacklevel=2)\n                else:\n                    raise ValueError(f'Input image is 2D, but sigma has {sigma.size} elements (expected 2).')\n            else:\n                sigma = np.insert(sigma, 0, 0)\n        elif sigma.size != 3:\n            raise ValueError(f'Input image is 3D, but sigma has {sigma.size} elements (expected 3).')\n    if (sigma > 0).any():\n        sigma = list(sigma) + [0]\n        image = gaussian(image, sigma, mode='reflect')\n    n_centroids = centroids.shape[0]\n    segments = np.ascontiguousarray(np.concatenate([centroids, np.zeros((n_centroids, image.shape[3]))], axis=-1), dtype=dtype)\n    step = max(steps)\n    ratio = 1.0 / compactness\n    image = np.ascontiguousarray(image * ratio, dtype=dtype)\n    if update_centroids:\n        _slic_cython(image, mask, segments, step, max_num_iter, spacing, slic_zero, ignore_color=True, start_label=start_label)\n    labels = _slic_cython(image, mask, segments, step, max_num_iter, spacing, slic_zero, ignore_color=False, start_label=start_label)\n    if enforce_connectivity:\n        if use_mask:\n            segment_size = mask.sum() / n_centroids\n        else:\n            segment_size = math.prod(image.shape[:3]) / n_centroids\n        min_size = int(min_size_factor * segment_size)\n        max_size = int(max_size_factor * segment_size)\n        labels = _enforce_label_connectivity_cython(labels, min_size, max_size, start_label=start_label)\n    if is_2d:\n        labels = labels[0]\n    return labels",
            "@utils.channel_as_last_axis(multichannel_output=False)\ndef slic(image, n_segments=100, compactness=10.0, max_num_iter=10, sigma=0, spacing=None, convert2lab=None, enforce_connectivity=True, min_size_factor=0.5, max_size_factor=3, slic_zero=False, start_label=1, mask=None, *, channel_axis=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Segments image using k-means clustering in Color-(x,y,z) space.\\n\\n    Parameters\\n    ----------\\n    image : (M, N[, P][, C]) ndarray\\n        Input image. Can be 2D or 3D, and grayscale or multichannel\\n        (see `channel_axis` parameter).\\n        Input image must either be NaN-free or the NaN\\'s must be masked out.\\n    n_segments : int, optional\\n        The (approximate) number of labels in the segmented output image.\\n    compactness : float, optional\\n        Balances color proximity and space proximity. Higher values give\\n        more weight to space proximity, making superpixel shapes more\\n        square/cubic. In SLICO mode, this is the initial compactness.\\n        This parameter depends strongly on image contrast and on the\\n        shapes of objects in the image. We recommend exploring possible\\n        values on a log scale, e.g., 0.01, 0.1, 1, 10, 100, before\\n        refining around a chosen value.\\n    max_num_iter : int, optional\\n        Maximum number of iterations of k-means.\\n    sigma : float or array-like of floats, optional\\n        Width of Gaussian smoothing kernel for pre-processing for each\\n        dimension of the image. The same sigma is applied to each dimension in\\n        case of a scalar value. Zero means no smoothing.\\n        Note that `sigma` is automatically scaled if it is scalar and\\n        if a manual voxel spacing is provided (see Notes section). If\\n        sigma is array-like, its size must match ``image``\\'s number\\n        of spatial dimensions.\\n    spacing : array-like of floats, optional\\n        The voxel spacing along each spatial dimension. By default,\\n        `slic` assumes uniform spacing (same voxel resolution along\\n        each spatial dimension).\\n        This parameter controls the weights of the distances along the\\n        spatial dimensions during k-means clustering.\\n    convert2lab : bool, optional\\n        Whether the input should be converted to Lab colorspace prior to\\n        segmentation. The input image *must* be RGB. Highly recommended.\\n        This option defaults to ``True`` when ``channel_axis` is not None *and*\\n        ``image.shape[-1] == 3``.\\n    enforce_connectivity : bool, optional\\n        Whether the generated segments are connected or not\\n    min_size_factor : float, optional\\n        Proportion of the minimum segment size to be removed with respect\\n        to the supposed segment size ```depth*width*height/n_segments```\\n    max_size_factor : float, optional\\n        Proportion of the maximum connected segment size. A value of 3 works\\n        in most of the cases.\\n    slic_zero : bool, optional\\n        Run SLIC-zero, the zero-parameter mode of SLIC. [2]_\\n    start_label : int, optional\\n        The labels\\' index start. Should be 0 or 1.\\n\\n        .. versionadded:: 0.17\\n           ``start_label`` was introduced in 0.17\\n    mask : ndarray, optional\\n        If provided, superpixels are computed only where mask is True,\\n        and seed points are homogeneously distributed over the mask\\n        using a k-means clustering strategy. Mask number of dimensions\\n        must be equal to image number of spatial dimensions.\\n\\n        .. versionadded:: 0.17\\n           ``mask`` was introduced in 0.17\\n    channel_axis : int or None, optional\\n        If None, the image is assumed to be a grayscale (single channel) image.\\n        Otherwise, this parameter indicates which axis of the array corresponds\\n        to channels.\\n\\n        .. versionadded:: 0.19\\n           ``channel_axis`` was added in 0.19.\\n\\n    Returns\\n    -------\\n    labels : 2D or 3D array\\n        Integer mask indicating segment labels.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If ``convert2lab`` is set to ``True`` but the last array\\n        dimension is not of length 3.\\n    ValueError\\n        If ``start_label`` is not 0 or 1.\\n    ValueError\\n        If ``image`` contains unmasked NaN values.\\n    ValueError\\n        If ``image`` contains unmasked infinite values.\\n    ValueError\\n        If ``image`` is 2D but ``channel_axis`` is -1 (the default).\\n\\n    Notes\\n    -----\\n    * If `sigma > 0`, the image is smoothed using a Gaussian kernel prior to\\n      segmentation.\\n\\n    * If `sigma` is scalar and `spacing` is provided, the kernel width is\\n      divided along each dimension by the spacing. For example, if ``sigma=1``\\n      and ``spacing=[5, 1, 1]``, the effective `sigma` is ``[0.2, 1, 1]``. This\\n      ensures sensible smoothing for anisotropic images.\\n\\n    * The image is rescaled to be in [0, 1] prior to processing (masked\\n      values are ignored).\\n\\n    * Images of shape (M, N, 3) are interpreted as 2D RGB images by default. To\\n      interpret them as 3D with the last dimension having length 3, use\\n      `channel_axis=None`.\\n\\n    * `start_label` is introduced to handle the issue [4]_. Label indexing\\n      starts at 1 by default.\\n\\n    References\\n    ----------\\n    .. [1] Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi,\\n        Pascal Fua, and Sabine S\u00fcsstrunk, SLIC Superpixels Compared to\\n        State-of-the-art Superpixel Methods, TPAMI, May 2012.\\n        :DOI:`10.1109/TPAMI.2012.120`\\n    .. [2] https://www.epfl.ch/labs/ivrl/research/slic-superpixels/#SLICO\\n    .. [3] Irving, Benjamin. \"maskSLIC: regional superpixel generation with\\n           application to local pathology characterisation in medical images.\",\\n           2016, :arXiv:`1606.09518`\\n    .. [4] https://github.com/scikit-image/scikit-image/issues/3722\\n\\n    Examples\\n    --------\\n    >>> from skimage.segmentation import slic\\n    >>> from skimage.data import astronaut\\n    >>> img = astronaut()\\n    >>> segments = slic(img, n_segments=100, compactness=10)\\n\\n    Increasing the compactness parameter yields more square regions:\\n\\n    >>> segments = slic(img, n_segments=100, compactness=20)\\n\\n    '\n    if image.ndim == 2 and channel_axis is not None:\n        raise ValueError(f'channel_axis={channel_axis} indicates multichannel, which is not supported for a two-dimensional image; use channel_axis=None if the image is grayscale')\n    image = img_as_float(image)\n    float_dtype = utils._supported_float_type(image.dtype)\n    image = image.astype(float_dtype, copy=True)\n    if mask is not None:\n        mask = np.ascontiguousarray(mask, dtype=bool)\n        if channel_axis is not None:\n            mask_ = np.expand_dims(mask, axis=channel_axis)\n            mask_ = np.broadcast_to(mask_, image.shape)\n        else:\n            mask_ = mask\n        image_values = image[mask_]\n    else:\n        image_values = image\n    imin = image_values.min()\n    imax = image_values.max()\n    if np.isnan(imin):\n        raise ValueError('unmasked NaN values in image are not supported')\n    if np.isinf(imin) or np.isinf(imax):\n        raise ValueError('unmasked infinite values in image are not supported')\n    image -= imin\n    if imax != imin:\n        image /= imax - imin\n    use_mask = mask is not None\n    dtype = image.dtype\n    is_2d = False\n    multichannel = channel_axis is not None\n    if image.ndim == 2:\n        image = image[np.newaxis, ..., np.newaxis]\n        is_2d = True\n    elif image.ndim == 3 and multichannel:\n        image = image[np.newaxis, ...]\n        is_2d = True\n    elif image.ndim == 3 and (not multichannel):\n        image = image[..., np.newaxis]\n    if multichannel and (convert2lab or convert2lab is None):\n        if image.shape[channel_axis] != 3 and convert2lab:\n            raise ValueError('Lab colorspace conversion requires a RGB image.')\n        elif image.shape[channel_axis] == 3:\n            image = rgb2lab(image)\n    if start_label not in [0, 1]:\n        raise ValueError('start_label should be 0 or 1.')\n    update_centroids = False\n    if use_mask:\n        mask = mask.view('uint8')\n        if mask.ndim == 2:\n            mask = np.ascontiguousarray(mask[np.newaxis, ...])\n        if mask.shape != image.shape[:3]:\n            raise ValueError('image and mask should have the same shape.')\n        (centroids, steps) = _get_mask_centroids(mask, n_segments, multichannel)\n        update_centroids = True\n    else:\n        (centroids, steps) = _get_grid_centroids(image, n_segments)\n    if spacing is None:\n        spacing = np.ones(3, dtype=dtype)\n    elif isinstance(spacing, Iterable):\n        spacing = np.asarray(spacing, dtype=dtype)\n        if is_2d:\n            if spacing.size != 2:\n                if spacing.size == 3:\n                    warn('Input image is 2D: spacing number of elements must be 2. In the future, a ValueError will be raised.', FutureWarning, stacklevel=2)\n                else:\n                    raise ValueError(f'Input image is 2D, but spacing has {spacing.size} elements (expected 2).')\n            else:\n                spacing = np.insert(spacing, 0, 1)\n        elif spacing.size != 3:\n            raise ValueError(f'Input image is 3D, but spacing has {spacing.size} elements (expected 3).')\n        spacing = np.ascontiguousarray(spacing, dtype=dtype)\n    else:\n        raise TypeError('spacing must be None or iterable.')\n    if np.isscalar(sigma):\n        sigma = np.array([sigma, sigma, sigma], dtype=dtype)\n        sigma /= spacing\n    elif isinstance(sigma, Iterable):\n        sigma = np.asarray(sigma, dtype=dtype)\n        if is_2d:\n            if sigma.size != 2:\n                if spacing.size == 3:\n                    warn('Input image is 2D: sigma number of elements must be 2. In the future, a ValueError will be raised.', FutureWarning, stacklevel=2)\n                else:\n                    raise ValueError(f'Input image is 2D, but sigma has {sigma.size} elements (expected 2).')\n            else:\n                sigma = np.insert(sigma, 0, 0)\n        elif sigma.size != 3:\n            raise ValueError(f'Input image is 3D, but sigma has {sigma.size} elements (expected 3).')\n    if (sigma > 0).any():\n        sigma = list(sigma) + [0]\n        image = gaussian(image, sigma, mode='reflect')\n    n_centroids = centroids.shape[0]\n    segments = np.ascontiguousarray(np.concatenate([centroids, np.zeros((n_centroids, image.shape[3]))], axis=-1), dtype=dtype)\n    step = max(steps)\n    ratio = 1.0 / compactness\n    image = np.ascontiguousarray(image * ratio, dtype=dtype)\n    if update_centroids:\n        _slic_cython(image, mask, segments, step, max_num_iter, spacing, slic_zero, ignore_color=True, start_label=start_label)\n    labels = _slic_cython(image, mask, segments, step, max_num_iter, spacing, slic_zero, ignore_color=False, start_label=start_label)\n    if enforce_connectivity:\n        if use_mask:\n            segment_size = mask.sum() / n_centroids\n        else:\n            segment_size = math.prod(image.shape[:3]) / n_centroids\n        min_size = int(min_size_factor * segment_size)\n        max_size = int(max_size_factor * segment_size)\n        labels = _enforce_label_connectivity_cython(labels, min_size, max_size, start_label=start_label)\n    if is_2d:\n        labels = labels[0]\n    return labels",
            "@utils.channel_as_last_axis(multichannel_output=False)\ndef slic(image, n_segments=100, compactness=10.0, max_num_iter=10, sigma=0, spacing=None, convert2lab=None, enforce_connectivity=True, min_size_factor=0.5, max_size_factor=3, slic_zero=False, start_label=1, mask=None, *, channel_axis=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Segments image using k-means clustering in Color-(x,y,z) space.\\n\\n    Parameters\\n    ----------\\n    image : (M, N[, P][, C]) ndarray\\n        Input image. Can be 2D or 3D, and grayscale or multichannel\\n        (see `channel_axis` parameter).\\n        Input image must either be NaN-free or the NaN\\'s must be masked out.\\n    n_segments : int, optional\\n        The (approximate) number of labels in the segmented output image.\\n    compactness : float, optional\\n        Balances color proximity and space proximity. Higher values give\\n        more weight to space proximity, making superpixel shapes more\\n        square/cubic. In SLICO mode, this is the initial compactness.\\n        This parameter depends strongly on image contrast and on the\\n        shapes of objects in the image. We recommend exploring possible\\n        values on a log scale, e.g., 0.01, 0.1, 1, 10, 100, before\\n        refining around a chosen value.\\n    max_num_iter : int, optional\\n        Maximum number of iterations of k-means.\\n    sigma : float or array-like of floats, optional\\n        Width of Gaussian smoothing kernel for pre-processing for each\\n        dimension of the image. The same sigma is applied to each dimension in\\n        case of a scalar value. Zero means no smoothing.\\n        Note that `sigma` is automatically scaled if it is scalar and\\n        if a manual voxel spacing is provided (see Notes section). If\\n        sigma is array-like, its size must match ``image``\\'s number\\n        of spatial dimensions.\\n    spacing : array-like of floats, optional\\n        The voxel spacing along each spatial dimension. By default,\\n        `slic` assumes uniform spacing (same voxel resolution along\\n        each spatial dimension).\\n        This parameter controls the weights of the distances along the\\n        spatial dimensions during k-means clustering.\\n    convert2lab : bool, optional\\n        Whether the input should be converted to Lab colorspace prior to\\n        segmentation. The input image *must* be RGB. Highly recommended.\\n        This option defaults to ``True`` when ``channel_axis` is not None *and*\\n        ``image.shape[-1] == 3``.\\n    enforce_connectivity : bool, optional\\n        Whether the generated segments are connected or not\\n    min_size_factor : float, optional\\n        Proportion of the minimum segment size to be removed with respect\\n        to the supposed segment size ```depth*width*height/n_segments```\\n    max_size_factor : float, optional\\n        Proportion of the maximum connected segment size. A value of 3 works\\n        in most of the cases.\\n    slic_zero : bool, optional\\n        Run SLIC-zero, the zero-parameter mode of SLIC. [2]_\\n    start_label : int, optional\\n        The labels\\' index start. Should be 0 or 1.\\n\\n        .. versionadded:: 0.17\\n           ``start_label`` was introduced in 0.17\\n    mask : ndarray, optional\\n        If provided, superpixels are computed only where mask is True,\\n        and seed points are homogeneously distributed over the mask\\n        using a k-means clustering strategy. Mask number of dimensions\\n        must be equal to image number of spatial dimensions.\\n\\n        .. versionadded:: 0.17\\n           ``mask`` was introduced in 0.17\\n    channel_axis : int or None, optional\\n        If None, the image is assumed to be a grayscale (single channel) image.\\n        Otherwise, this parameter indicates which axis of the array corresponds\\n        to channels.\\n\\n        .. versionadded:: 0.19\\n           ``channel_axis`` was added in 0.19.\\n\\n    Returns\\n    -------\\n    labels : 2D or 3D array\\n        Integer mask indicating segment labels.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If ``convert2lab`` is set to ``True`` but the last array\\n        dimension is not of length 3.\\n    ValueError\\n        If ``start_label`` is not 0 or 1.\\n    ValueError\\n        If ``image`` contains unmasked NaN values.\\n    ValueError\\n        If ``image`` contains unmasked infinite values.\\n    ValueError\\n        If ``image`` is 2D but ``channel_axis`` is -1 (the default).\\n\\n    Notes\\n    -----\\n    * If `sigma > 0`, the image is smoothed using a Gaussian kernel prior to\\n      segmentation.\\n\\n    * If `sigma` is scalar and `spacing` is provided, the kernel width is\\n      divided along each dimension by the spacing. For example, if ``sigma=1``\\n      and ``spacing=[5, 1, 1]``, the effective `sigma` is ``[0.2, 1, 1]``. This\\n      ensures sensible smoothing for anisotropic images.\\n\\n    * The image is rescaled to be in [0, 1] prior to processing (masked\\n      values are ignored).\\n\\n    * Images of shape (M, N, 3) are interpreted as 2D RGB images by default. To\\n      interpret them as 3D with the last dimension having length 3, use\\n      `channel_axis=None`.\\n\\n    * `start_label` is introduced to handle the issue [4]_. Label indexing\\n      starts at 1 by default.\\n\\n    References\\n    ----------\\n    .. [1] Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi,\\n        Pascal Fua, and Sabine S\u00fcsstrunk, SLIC Superpixels Compared to\\n        State-of-the-art Superpixel Methods, TPAMI, May 2012.\\n        :DOI:`10.1109/TPAMI.2012.120`\\n    .. [2] https://www.epfl.ch/labs/ivrl/research/slic-superpixels/#SLICO\\n    .. [3] Irving, Benjamin. \"maskSLIC: regional superpixel generation with\\n           application to local pathology characterisation in medical images.\",\\n           2016, :arXiv:`1606.09518`\\n    .. [4] https://github.com/scikit-image/scikit-image/issues/3722\\n\\n    Examples\\n    --------\\n    >>> from skimage.segmentation import slic\\n    >>> from skimage.data import astronaut\\n    >>> img = astronaut()\\n    >>> segments = slic(img, n_segments=100, compactness=10)\\n\\n    Increasing the compactness parameter yields more square regions:\\n\\n    >>> segments = slic(img, n_segments=100, compactness=20)\\n\\n    '\n    if image.ndim == 2 and channel_axis is not None:\n        raise ValueError(f'channel_axis={channel_axis} indicates multichannel, which is not supported for a two-dimensional image; use channel_axis=None if the image is grayscale')\n    image = img_as_float(image)\n    float_dtype = utils._supported_float_type(image.dtype)\n    image = image.astype(float_dtype, copy=True)\n    if mask is not None:\n        mask = np.ascontiguousarray(mask, dtype=bool)\n        if channel_axis is not None:\n            mask_ = np.expand_dims(mask, axis=channel_axis)\n            mask_ = np.broadcast_to(mask_, image.shape)\n        else:\n            mask_ = mask\n        image_values = image[mask_]\n    else:\n        image_values = image\n    imin = image_values.min()\n    imax = image_values.max()\n    if np.isnan(imin):\n        raise ValueError('unmasked NaN values in image are not supported')\n    if np.isinf(imin) or np.isinf(imax):\n        raise ValueError('unmasked infinite values in image are not supported')\n    image -= imin\n    if imax != imin:\n        image /= imax - imin\n    use_mask = mask is not None\n    dtype = image.dtype\n    is_2d = False\n    multichannel = channel_axis is not None\n    if image.ndim == 2:\n        image = image[np.newaxis, ..., np.newaxis]\n        is_2d = True\n    elif image.ndim == 3 and multichannel:\n        image = image[np.newaxis, ...]\n        is_2d = True\n    elif image.ndim == 3 and (not multichannel):\n        image = image[..., np.newaxis]\n    if multichannel and (convert2lab or convert2lab is None):\n        if image.shape[channel_axis] != 3 and convert2lab:\n            raise ValueError('Lab colorspace conversion requires a RGB image.')\n        elif image.shape[channel_axis] == 3:\n            image = rgb2lab(image)\n    if start_label not in [0, 1]:\n        raise ValueError('start_label should be 0 or 1.')\n    update_centroids = False\n    if use_mask:\n        mask = mask.view('uint8')\n        if mask.ndim == 2:\n            mask = np.ascontiguousarray(mask[np.newaxis, ...])\n        if mask.shape != image.shape[:3]:\n            raise ValueError('image and mask should have the same shape.')\n        (centroids, steps) = _get_mask_centroids(mask, n_segments, multichannel)\n        update_centroids = True\n    else:\n        (centroids, steps) = _get_grid_centroids(image, n_segments)\n    if spacing is None:\n        spacing = np.ones(3, dtype=dtype)\n    elif isinstance(spacing, Iterable):\n        spacing = np.asarray(spacing, dtype=dtype)\n        if is_2d:\n            if spacing.size != 2:\n                if spacing.size == 3:\n                    warn('Input image is 2D: spacing number of elements must be 2. In the future, a ValueError will be raised.', FutureWarning, stacklevel=2)\n                else:\n                    raise ValueError(f'Input image is 2D, but spacing has {spacing.size} elements (expected 2).')\n            else:\n                spacing = np.insert(spacing, 0, 1)\n        elif spacing.size != 3:\n            raise ValueError(f'Input image is 3D, but spacing has {spacing.size} elements (expected 3).')\n        spacing = np.ascontiguousarray(spacing, dtype=dtype)\n    else:\n        raise TypeError('spacing must be None or iterable.')\n    if np.isscalar(sigma):\n        sigma = np.array([sigma, sigma, sigma], dtype=dtype)\n        sigma /= spacing\n    elif isinstance(sigma, Iterable):\n        sigma = np.asarray(sigma, dtype=dtype)\n        if is_2d:\n            if sigma.size != 2:\n                if spacing.size == 3:\n                    warn('Input image is 2D: sigma number of elements must be 2. In the future, a ValueError will be raised.', FutureWarning, stacklevel=2)\n                else:\n                    raise ValueError(f'Input image is 2D, but sigma has {sigma.size} elements (expected 2).')\n            else:\n                sigma = np.insert(sigma, 0, 0)\n        elif sigma.size != 3:\n            raise ValueError(f'Input image is 3D, but sigma has {sigma.size} elements (expected 3).')\n    if (sigma > 0).any():\n        sigma = list(sigma) + [0]\n        image = gaussian(image, sigma, mode='reflect')\n    n_centroids = centroids.shape[0]\n    segments = np.ascontiguousarray(np.concatenate([centroids, np.zeros((n_centroids, image.shape[3]))], axis=-1), dtype=dtype)\n    step = max(steps)\n    ratio = 1.0 / compactness\n    image = np.ascontiguousarray(image * ratio, dtype=dtype)\n    if update_centroids:\n        _slic_cython(image, mask, segments, step, max_num_iter, spacing, slic_zero, ignore_color=True, start_label=start_label)\n    labels = _slic_cython(image, mask, segments, step, max_num_iter, spacing, slic_zero, ignore_color=False, start_label=start_label)\n    if enforce_connectivity:\n        if use_mask:\n            segment_size = mask.sum() / n_centroids\n        else:\n            segment_size = math.prod(image.shape[:3]) / n_centroids\n        min_size = int(min_size_factor * segment_size)\n        max_size = int(max_size_factor * segment_size)\n        labels = _enforce_label_connectivity_cython(labels, min_size, max_size, start_label=start_label)\n    if is_2d:\n        labels = labels[0]\n    return labels",
            "@utils.channel_as_last_axis(multichannel_output=False)\ndef slic(image, n_segments=100, compactness=10.0, max_num_iter=10, sigma=0, spacing=None, convert2lab=None, enforce_connectivity=True, min_size_factor=0.5, max_size_factor=3, slic_zero=False, start_label=1, mask=None, *, channel_axis=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Segments image using k-means clustering in Color-(x,y,z) space.\\n\\n    Parameters\\n    ----------\\n    image : (M, N[, P][, C]) ndarray\\n        Input image. Can be 2D or 3D, and grayscale or multichannel\\n        (see `channel_axis` parameter).\\n        Input image must either be NaN-free or the NaN\\'s must be masked out.\\n    n_segments : int, optional\\n        The (approximate) number of labels in the segmented output image.\\n    compactness : float, optional\\n        Balances color proximity and space proximity. Higher values give\\n        more weight to space proximity, making superpixel shapes more\\n        square/cubic. In SLICO mode, this is the initial compactness.\\n        This parameter depends strongly on image contrast and on the\\n        shapes of objects in the image. We recommend exploring possible\\n        values on a log scale, e.g., 0.01, 0.1, 1, 10, 100, before\\n        refining around a chosen value.\\n    max_num_iter : int, optional\\n        Maximum number of iterations of k-means.\\n    sigma : float or array-like of floats, optional\\n        Width of Gaussian smoothing kernel for pre-processing for each\\n        dimension of the image. The same sigma is applied to each dimension in\\n        case of a scalar value. Zero means no smoothing.\\n        Note that `sigma` is automatically scaled if it is scalar and\\n        if a manual voxel spacing is provided (see Notes section). If\\n        sigma is array-like, its size must match ``image``\\'s number\\n        of spatial dimensions.\\n    spacing : array-like of floats, optional\\n        The voxel spacing along each spatial dimension. By default,\\n        `slic` assumes uniform spacing (same voxel resolution along\\n        each spatial dimension).\\n        This parameter controls the weights of the distances along the\\n        spatial dimensions during k-means clustering.\\n    convert2lab : bool, optional\\n        Whether the input should be converted to Lab colorspace prior to\\n        segmentation. The input image *must* be RGB. Highly recommended.\\n        This option defaults to ``True`` when ``channel_axis` is not None *and*\\n        ``image.shape[-1] == 3``.\\n    enforce_connectivity : bool, optional\\n        Whether the generated segments are connected or not\\n    min_size_factor : float, optional\\n        Proportion of the minimum segment size to be removed with respect\\n        to the supposed segment size ```depth*width*height/n_segments```\\n    max_size_factor : float, optional\\n        Proportion of the maximum connected segment size. A value of 3 works\\n        in most of the cases.\\n    slic_zero : bool, optional\\n        Run SLIC-zero, the zero-parameter mode of SLIC. [2]_\\n    start_label : int, optional\\n        The labels\\' index start. Should be 0 or 1.\\n\\n        .. versionadded:: 0.17\\n           ``start_label`` was introduced in 0.17\\n    mask : ndarray, optional\\n        If provided, superpixels are computed only where mask is True,\\n        and seed points are homogeneously distributed over the mask\\n        using a k-means clustering strategy. Mask number of dimensions\\n        must be equal to image number of spatial dimensions.\\n\\n        .. versionadded:: 0.17\\n           ``mask`` was introduced in 0.17\\n    channel_axis : int or None, optional\\n        If None, the image is assumed to be a grayscale (single channel) image.\\n        Otherwise, this parameter indicates which axis of the array corresponds\\n        to channels.\\n\\n        .. versionadded:: 0.19\\n           ``channel_axis`` was added in 0.19.\\n\\n    Returns\\n    -------\\n    labels : 2D or 3D array\\n        Integer mask indicating segment labels.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If ``convert2lab`` is set to ``True`` but the last array\\n        dimension is not of length 3.\\n    ValueError\\n        If ``start_label`` is not 0 or 1.\\n    ValueError\\n        If ``image`` contains unmasked NaN values.\\n    ValueError\\n        If ``image`` contains unmasked infinite values.\\n    ValueError\\n        If ``image`` is 2D but ``channel_axis`` is -1 (the default).\\n\\n    Notes\\n    -----\\n    * If `sigma > 0`, the image is smoothed using a Gaussian kernel prior to\\n      segmentation.\\n\\n    * If `sigma` is scalar and `spacing` is provided, the kernel width is\\n      divided along each dimension by the spacing. For example, if ``sigma=1``\\n      and ``spacing=[5, 1, 1]``, the effective `sigma` is ``[0.2, 1, 1]``. This\\n      ensures sensible smoothing for anisotropic images.\\n\\n    * The image is rescaled to be in [0, 1] prior to processing (masked\\n      values are ignored).\\n\\n    * Images of shape (M, N, 3) are interpreted as 2D RGB images by default. To\\n      interpret them as 3D with the last dimension having length 3, use\\n      `channel_axis=None`.\\n\\n    * `start_label` is introduced to handle the issue [4]_. Label indexing\\n      starts at 1 by default.\\n\\n    References\\n    ----------\\n    .. [1] Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi,\\n        Pascal Fua, and Sabine S\u00fcsstrunk, SLIC Superpixels Compared to\\n        State-of-the-art Superpixel Methods, TPAMI, May 2012.\\n        :DOI:`10.1109/TPAMI.2012.120`\\n    .. [2] https://www.epfl.ch/labs/ivrl/research/slic-superpixels/#SLICO\\n    .. [3] Irving, Benjamin. \"maskSLIC: regional superpixel generation with\\n           application to local pathology characterisation in medical images.\",\\n           2016, :arXiv:`1606.09518`\\n    .. [4] https://github.com/scikit-image/scikit-image/issues/3722\\n\\n    Examples\\n    --------\\n    >>> from skimage.segmentation import slic\\n    >>> from skimage.data import astronaut\\n    >>> img = astronaut()\\n    >>> segments = slic(img, n_segments=100, compactness=10)\\n\\n    Increasing the compactness parameter yields more square regions:\\n\\n    >>> segments = slic(img, n_segments=100, compactness=20)\\n\\n    '\n    if image.ndim == 2 and channel_axis is not None:\n        raise ValueError(f'channel_axis={channel_axis} indicates multichannel, which is not supported for a two-dimensional image; use channel_axis=None if the image is grayscale')\n    image = img_as_float(image)\n    float_dtype = utils._supported_float_type(image.dtype)\n    image = image.astype(float_dtype, copy=True)\n    if mask is not None:\n        mask = np.ascontiguousarray(mask, dtype=bool)\n        if channel_axis is not None:\n            mask_ = np.expand_dims(mask, axis=channel_axis)\n            mask_ = np.broadcast_to(mask_, image.shape)\n        else:\n            mask_ = mask\n        image_values = image[mask_]\n    else:\n        image_values = image\n    imin = image_values.min()\n    imax = image_values.max()\n    if np.isnan(imin):\n        raise ValueError('unmasked NaN values in image are not supported')\n    if np.isinf(imin) or np.isinf(imax):\n        raise ValueError('unmasked infinite values in image are not supported')\n    image -= imin\n    if imax != imin:\n        image /= imax - imin\n    use_mask = mask is not None\n    dtype = image.dtype\n    is_2d = False\n    multichannel = channel_axis is not None\n    if image.ndim == 2:\n        image = image[np.newaxis, ..., np.newaxis]\n        is_2d = True\n    elif image.ndim == 3 and multichannel:\n        image = image[np.newaxis, ...]\n        is_2d = True\n    elif image.ndim == 3 and (not multichannel):\n        image = image[..., np.newaxis]\n    if multichannel and (convert2lab or convert2lab is None):\n        if image.shape[channel_axis] != 3 and convert2lab:\n            raise ValueError('Lab colorspace conversion requires a RGB image.')\n        elif image.shape[channel_axis] == 3:\n            image = rgb2lab(image)\n    if start_label not in [0, 1]:\n        raise ValueError('start_label should be 0 or 1.')\n    update_centroids = False\n    if use_mask:\n        mask = mask.view('uint8')\n        if mask.ndim == 2:\n            mask = np.ascontiguousarray(mask[np.newaxis, ...])\n        if mask.shape != image.shape[:3]:\n            raise ValueError('image and mask should have the same shape.')\n        (centroids, steps) = _get_mask_centroids(mask, n_segments, multichannel)\n        update_centroids = True\n    else:\n        (centroids, steps) = _get_grid_centroids(image, n_segments)\n    if spacing is None:\n        spacing = np.ones(3, dtype=dtype)\n    elif isinstance(spacing, Iterable):\n        spacing = np.asarray(spacing, dtype=dtype)\n        if is_2d:\n            if spacing.size != 2:\n                if spacing.size == 3:\n                    warn('Input image is 2D: spacing number of elements must be 2. In the future, a ValueError will be raised.', FutureWarning, stacklevel=2)\n                else:\n                    raise ValueError(f'Input image is 2D, but spacing has {spacing.size} elements (expected 2).')\n            else:\n                spacing = np.insert(spacing, 0, 1)\n        elif spacing.size != 3:\n            raise ValueError(f'Input image is 3D, but spacing has {spacing.size} elements (expected 3).')\n        spacing = np.ascontiguousarray(spacing, dtype=dtype)\n    else:\n        raise TypeError('spacing must be None or iterable.')\n    if np.isscalar(sigma):\n        sigma = np.array([sigma, sigma, sigma], dtype=dtype)\n        sigma /= spacing\n    elif isinstance(sigma, Iterable):\n        sigma = np.asarray(sigma, dtype=dtype)\n        if is_2d:\n            if sigma.size != 2:\n                if spacing.size == 3:\n                    warn('Input image is 2D: sigma number of elements must be 2. In the future, a ValueError will be raised.', FutureWarning, stacklevel=2)\n                else:\n                    raise ValueError(f'Input image is 2D, but sigma has {sigma.size} elements (expected 2).')\n            else:\n                sigma = np.insert(sigma, 0, 0)\n        elif sigma.size != 3:\n            raise ValueError(f'Input image is 3D, but sigma has {sigma.size} elements (expected 3).')\n    if (sigma > 0).any():\n        sigma = list(sigma) + [0]\n        image = gaussian(image, sigma, mode='reflect')\n    n_centroids = centroids.shape[0]\n    segments = np.ascontiguousarray(np.concatenate([centroids, np.zeros((n_centroids, image.shape[3]))], axis=-1), dtype=dtype)\n    step = max(steps)\n    ratio = 1.0 / compactness\n    image = np.ascontiguousarray(image * ratio, dtype=dtype)\n    if update_centroids:\n        _slic_cython(image, mask, segments, step, max_num_iter, spacing, slic_zero, ignore_color=True, start_label=start_label)\n    labels = _slic_cython(image, mask, segments, step, max_num_iter, spacing, slic_zero, ignore_color=False, start_label=start_label)\n    if enforce_connectivity:\n        if use_mask:\n            segment_size = mask.sum() / n_centroids\n        else:\n            segment_size = math.prod(image.shape[:3]) / n_centroids\n        min_size = int(min_size_factor * segment_size)\n        max_size = int(max_size_factor * segment_size)\n        labels = _enforce_label_connectivity_cython(labels, min_size, max_size, start_label=start_label)\n    if is_2d:\n        labels = labels[0]\n    return labels"
        ]
    }
]