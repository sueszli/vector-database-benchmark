[
    {
        "func_name": "mcarma22",
        "original": "def mcarma22(niter=10, nsample=1000, ar=None, ma=None, sig=0.5):\n    \"\"\"run Monte Carlo for ARMA(2,2)\n\n    DGP parameters currently hard coded\n    also sample size `nsample`\n\n    was not a self contained function, used instances from outer scope\n      now corrected\n\n    \"\"\"\n    if ar is None:\n        ar = [1.0, -0.55, -0.1]\n    if ma is None:\n        ma = [1.0, 0.3, 0.2]\n    results = []\n    results_bse = []\n    for _ in range(niter):\n        y2 = arma_generate_sample(ar, ma, nsample + 1000, sig)[-nsample:]\n        y2 -= y2.mean()\n        arest2 = Arma(y2)\n        (rhohat2a, cov_x2a, infodict, mesg, ier) = arest2.fit((2, 2))\n        results.append(rhohat2a)\n        err2a = arest2.geterrors(rhohat2a)\n        sige2a = np.sqrt(np.dot(err2a, err2a) / nsample)\n        if cov_x2a is not None:\n            results_bse.append(sige2a * np.sqrt(np.diag(cov_x2a)))\n        else:\n            results_bse.append(np.nan + np.zeros_like(rhohat2a))\n    return (np.r_[ar[1:], ma[1:]], np.array(results), np.array(results_bse))",
        "mutated": [
            "def mcarma22(niter=10, nsample=1000, ar=None, ma=None, sig=0.5):\n    if False:\n        i = 10\n    'run Monte Carlo for ARMA(2,2)\\n\\n    DGP parameters currently hard coded\\n    also sample size `nsample`\\n\\n    was not a self contained function, used instances from outer scope\\n      now corrected\\n\\n    '\n    if ar is None:\n        ar = [1.0, -0.55, -0.1]\n    if ma is None:\n        ma = [1.0, 0.3, 0.2]\n    results = []\n    results_bse = []\n    for _ in range(niter):\n        y2 = arma_generate_sample(ar, ma, nsample + 1000, sig)[-nsample:]\n        y2 -= y2.mean()\n        arest2 = Arma(y2)\n        (rhohat2a, cov_x2a, infodict, mesg, ier) = arest2.fit((2, 2))\n        results.append(rhohat2a)\n        err2a = arest2.geterrors(rhohat2a)\n        sige2a = np.sqrt(np.dot(err2a, err2a) / nsample)\n        if cov_x2a is not None:\n            results_bse.append(sige2a * np.sqrt(np.diag(cov_x2a)))\n        else:\n            results_bse.append(np.nan + np.zeros_like(rhohat2a))\n    return (np.r_[ar[1:], ma[1:]], np.array(results), np.array(results_bse))",
            "def mcarma22(niter=10, nsample=1000, ar=None, ma=None, sig=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'run Monte Carlo for ARMA(2,2)\\n\\n    DGP parameters currently hard coded\\n    also sample size `nsample`\\n\\n    was not a self contained function, used instances from outer scope\\n      now corrected\\n\\n    '\n    if ar is None:\n        ar = [1.0, -0.55, -0.1]\n    if ma is None:\n        ma = [1.0, 0.3, 0.2]\n    results = []\n    results_bse = []\n    for _ in range(niter):\n        y2 = arma_generate_sample(ar, ma, nsample + 1000, sig)[-nsample:]\n        y2 -= y2.mean()\n        arest2 = Arma(y2)\n        (rhohat2a, cov_x2a, infodict, mesg, ier) = arest2.fit((2, 2))\n        results.append(rhohat2a)\n        err2a = arest2.geterrors(rhohat2a)\n        sige2a = np.sqrt(np.dot(err2a, err2a) / nsample)\n        if cov_x2a is not None:\n            results_bse.append(sige2a * np.sqrt(np.diag(cov_x2a)))\n        else:\n            results_bse.append(np.nan + np.zeros_like(rhohat2a))\n    return (np.r_[ar[1:], ma[1:]], np.array(results), np.array(results_bse))",
            "def mcarma22(niter=10, nsample=1000, ar=None, ma=None, sig=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'run Monte Carlo for ARMA(2,2)\\n\\n    DGP parameters currently hard coded\\n    also sample size `nsample`\\n\\n    was not a self contained function, used instances from outer scope\\n      now corrected\\n\\n    '\n    if ar is None:\n        ar = [1.0, -0.55, -0.1]\n    if ma is None:\n        ma = [1.0, 0.3, 0.2]\n    results = []\n    results_bse = []\n    for _ in range(niter):\n        y2 = arma_generate_sample(ar, ma, nsample + 1000, sig)[-nsample:]\n        y2 -= y2.mean()\n        arest2 = Arma(y2)\n        (rhohat2a, cov_x2a, infodict, mesg, ier) = arest2.fit((2, 2))\n        results.append(rhohat2a)\n        err2a = arest2.geterrors(rhohat2a)\n        sige2a = np.sqrt(np.dot(err2a, err2a) / nsample)\n        if cov_x2a is not None:\n            results_bse.append(sige2a * np.sqrt(np.diag(cov_x2a)))\n        else:\n            results_bse.append(np.nan + np.zeros_like(rhohat2a))\n    return (np.r_[ar[1:], ma[1:]], np.array(results), np.array(results_bse))",
            "def mcarma22(niter=10, nsample=1000, ar=None, ma=None, sig=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'run Monte Carlo for ARMA(2,2)\\n\\n    DGP parameters currently hard coded\\n    also sample size `nsample`\\n\\n    was not a self contained function, used instances from outer scope\\n      now corrected\\n\\n    '\n    if ar is None:\n        ar = [1.0, -0.55, -0.1]\n    if ma is None:\n        ma = [1.0, 0.3, 0.2]\n    results = []\n    results_bse = []\n    for _ in range(niter):\n        y2 = arma_generate_sample(ar, ma, nsample + 1000, sig)[-nsample:]\n        y2 -= y2.mean()\n        arest2 = Arma(y2)\n        (rhohat2a, cov_x2a, infodict, mesg, ier) = arest2.fit((2, 2))\n        results.append(rhohat2a)\n        err2a = arest2.geterrors(rhohat2a)\n        sige2a = np.sqrt(np.dot(err2a, err2a) / nsample)\n        if cov_x2a is not None:\n            results_bse.append(sige2a * np.sqrt(np.diag(cov_x2a)))\n        else:\n            results_bse.append(np.nan + np.zeros_like(rhohat2a))\n    return (np.r_[ar[1:], ma[1:]], np.array(results), np.array(results_bse))",
            "def mcarma22(niter=10, nsample=1000, ar=None, ma=None, sig=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'run Monte Carlo for ARMA(2,2)\\n\\n    DGP parameters currently hard coded\\n    also sample size `nsample`\\n\\n    was not a self contained function, used instances from outer scope\\n      now corrected\\n\\n    '\n    if ar is None:\n        ar = [1.0, -0.55, -0.1]\n    if ma is None:\n        ma = [1.0, 0.3, 0.2]\n    results = []\n    results_bse = []\n    for _ in range(niter):\n        y2 = arma_generate_sample(ar, ma, nsample + 1000, sig)[-nsample:]\n        y2 -= y2.mean()\n        arest2 = Arma(y2)\n        (rhohat2a, cov_x2a, infodict, mesg, ier) = arest2.fit((2, 2))\n        results.append(rhohat2a)\n        err2a = arest2.geterrors(rhohat2a)\n        sige2a = np.sqrt(np.dot(err2a, err2a) / nsample)\n        if cov_x2a is not None:\n            results_bse.append(sige2a * np.sqrt(np.diag(cov_x2a)))\n        else:\n            results_bse.append(np.nan + np.zeros_like(rhohat2a))\n    return (np.r_[ar[1:], ma[1:]], np.array(results), np.array(results_bse))"
        ]
    },
    {
        "func_name": "mc_summary",
        "original": "def mc_summary(res, rt=None):\n    if rt is None:\n        rt = np.zeros(res.shape[1])\n    nanrows = np.isnan(res).any(1)\n    print('fractions of iterations with nans', nanrows.mean())\n    res = res[~nanrows]\n    print('RMSE')\n    print(np.sqrt(((res - rt) ** 2).mean(0)))\n    print('mean bias')\n    print((res - rt).mean(0))\n    print('median bias')\n    print(np.median(res - rt, 0))\n    print('median bias percent')\n    print(np.median((res - rt) / rt * 100, 0))\n    print('median absolute error')\n    print(np.median(np.abs(res - rt), 0))\n    print('positive error fraction')\n    print((res > rt).mean(0))",
        "mutated": [
            "def mc_summary(res, rt=None):\n    if False:\n        i = 10\n    if rt is None:\n        rt = np.zeros(res.shape[1])\n    nanrows = np.isnan(res).any(1)\n    print('fractions of iterations with nans', nanrows.mean())\n    res = res[~nanrows]\n    print('RMSE')\n    print(np.sqrt(((res - rt) ** 2).mean(0)))\n    print('mean bias')\n    print((res - rt).mean(0))\n    print('median bias')\n    print(np.median(res - rt, 0))\n    print('median bias percent')\n    print(np.median((res - rt) / rt * 100, 0))\n    print('median absolute error')\n    print(np.median(np.abs(res - rt), 0))\n    print('positive error fraction')\n    print((res > rt).mean(0))",
            "def mc_summary(res, rt=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if rt is None:\n        rt = np.zeros(res.shape[1])\n    nanrows = np.isnan(res).any(1)\n    print('fractions of iterations with nans', nanrows.mean())\n    res = res[~nanrows]\n    print('RMSE')\n    print(np.sqrt(((res - rt) ** 2).mean(0)))\n    print('mean bias')\n    print((res - rt).mean(0))\n    print('median bias')\n    print(np.median(res - rt, 0))\n    print('median bias percent')\n    print(np.median((res - rt) / rt * 100, 0))\n    print('median absolute error')\n    print(np.median(np.abs(res - rt), 0))\n    print('positive error fraction')\n    print((res > rt).mean(0))",
            "def mc_summary(res, rt=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if rt is None:\n        rt = np.zeros(res.shape[1])\n    nanrows = np.isnan(res).any(1)\n    print('fractions of iterations with nans', nanrows.mean())\n    res = res[~nanrows]\n    print('RMSE')\n    print(np.sqrt(((res - rt) ** 2).mean(0)))\n    print('mean bias')\n    print((res - rt).mean(0))\n    print('median bias')\n    print(np.median(res - rt, 0))\n    print('median bias percent')\n    print(np.median((res - rt) / rt * 100, 0))\n    print('median absolute error')\n    print(np.median(np.abs(res - rt), 0))\n    print('positive error fraction')\n    print((res > rt).mean(0))",
            "def mc_summary(res, rt=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if rt is None:\n        rt = np.zeros(res.shape[1])\n    nanrows = np.isnan(res).any(1)\n    print('fractions of iterations with nans', nanrows.mean())\n    res = res[~nanrows]\n    print('RMSE')\n    print(np.sqrt(((res - rt) ** 2).mean(0)))\n    print('mean bias')\n    print((res - rt).mean(0))\n    print('median bias')\n    print(np.median(res - rt, 0))\n    print('median bias percent')\n    print(np.median((res - rt) / rt * 100, 0))\n    print('median absolute error')\n    print(np.median(np.abs(res - rt), 0))\n    print('positive error fraction')\n    print((res > rt).mean(0))",
            "def mc_summary(res, rt=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if rt is None:\n        rt = np.zeros(res.shape[1])\n    nanrows = np.isnan(res).any(1)\n    print('fractions of iterations with nans', nanrows.mean())\n    res = res[~nanrows]\n    print('RMSE')\n    print(np.sqrt(((res - rt) ** 2).mean(0)))\n    print('mean bias')\n    print((res - rt).mean(0))\n    print('median bias')\n    print(np.median(res - rt, 0))\n    print('median bias percent')\n    print(np.median((res - rt) / rt * 100, 0))\n    print('median absolute error')\n    print(np.median(np.abs(res - rt), 0))\n    print('positive error fraction')\n    print((res > rt).mean(0))"
        ]
    }
]