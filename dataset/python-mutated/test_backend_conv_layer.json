[
    {
        "func_name": "slicable",
        "original": "def slicable(dim, pad=0):\n    \"\"\"\n    colapse outer dimensions into one and preserve inner dimension\n    this allows for easy cpu convolution in numpy\n\n    Arguments:\n        dim (tuple): dimensions list in a tuple\n        pad (int):  how many pixel paddings\n    \"\"\"\n    dim0 = np.prod(dim[:-1]) + pad\n    return (dim0, dim[-1])",
        "mutated": [
            "def slicable(dim, pad=0):\n    if False:\n        i = 10\n    '\\n    colapse outer dimensions into one and preserve inner dimension\\n    this allows for easy cpu convolution in numpy\\n\\n    Arguments:\\n        dim (tuple): dimensions list in a tuple\\n        pad (int):  how many pixel paddings\\n    '\n    dim0 = np.prod(dim[:-1]) + pad\n    return (dim0, dim[-1])",
            "def slicable(dim, pad=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    colapse outer dimensions into one and preserve inner dimension\\n    this allows for easy cpu convolution in numpy\\n\\n    Arguments:\\n        dim (tuple): dimensions list in a tuple\\n        pad (int):  how many pixel paddings\\n    '\n    dim0 = np.prod(dim[:-1]) + pad\n    return (dim0, dim[-1])",
            "def slicable(dim, pad=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    colapse outer dimensions into one and preserve inner dimension\\n    this allows for easy cpu convolution in numpy\\n\\n    Arguments:\\n        dim (tuple): dimensions list in a tuple\\n        pad (int):  how many pixel paddings\\n    '\n    dim0 = np.prod(dim[:-1]) + pad\n    return (dim0, dim[-1])",
            "def slicable(dim, pad=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    colapse outer dimensions into one and preserve inner dimension\\n    this allows for easy cpu convolution in numpy\\n\\n    Arguments:\\n        dim (tuple): dimensions list in a tuple\\n        pad (int):  how many pixel paddings\\n    '\n    dim0 = np.prod(dim[:-1]) + pad\n    return (dim0, dim[-1])",
            "def slicable(dim, pad=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    colapse outer dimensions into one and preserve inner dimension\\n    this allows for easy cpu convolution in numpy\\n\\n    Arguments:\\n        dim (tuple): dimensions list in a tuple\\n        pad (int):  how many pixel paddings\\n    '\n    dim0 = np.prod(dim[:-1]) + pad\n    return (dim0, dim[-1])"
        ]
    },
    {
        "func_name": "pixel_indices",
        "original": "def pixel_indices(conv, mt, pr, qs):\n    (T, R, S) = conv.TRS\n    (D, H, W) = conv.DHW\n    C = conv.C\n    HW = H * W\n    DHW = D * H * W\n    imax = C * DHW\n    idx = []\n    for c in range(C):\n        ci = c * DHW\n        for t in range(T):\n            z = mt + t\n            zi = ci + z * HW\n            zb = z >= 0 and z < D\n            for r in range(R):\n                y = pr + r\n                yi = zi + y * W\n                yb = zb and y >= 0 and (y < H)\n                for s in range(S):\n                    x = qs + s\n                    if yb and x >= 0 and (x < W):\n                        xi = yi + x\n                    else:\n                        xi = imax\n                    idx.append(xi)\n    return idx",
        "mutated": [
            "def pixel_indices(conv, mt, pr, qs):\n    if False:\n        i = 10\n    (T, R, S) = conv.TRS\n    (D, H, W) = conv.DHW\n    C = conv.C\n    HW = H * W\n    DHW = D * H * W\n    imax = C * DHW\n    idx = []\n    for c in range(C):\n        ci = c * DHW\n        for t in range(T):\n            z = mt + t\n            zi = ci + z * HW\n            zb = z >= 0 and z < D\n            for r in range(R):\n                y = pr + r\n                yi = zi + y * W\n                yb = zb and y >= 0 and (y < H)\n                for s in range(S):\n                    x = qs + s\n                    if yb and x >= 0 and (x < W):\n                        xi = yi + x\n                    else:\n                        xi = imax\n                    idx.append(xi)\n    return idx",
            "def pixel_indices(conv, mt, pr, qs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (T, R, S) = conv.TRS\n    (D, H, W) = conv.DHW\n    C = conv.C\n    HW = H * W\n    DHW = D * H * W\n    imax = C * DHW\n    idx = []\n    for c in range(C):\n        ci = c * DHW\n        for t in range(T):\n            z = mt + t\n            zi = ci + z * HW\n            zb = z >= 0 and z < D\n            for r in range(R):\n                y = pr + r\n                yi = zi + y * W\n                yb = zb and y >= 0 and (y < H)\n                for s in range(S):\n                    x = qs + s\n                    if yb and x >= 0 and (x < W):\n                        xi = yi + x\n                    else:\n                        xi = imax\n                    idx.append(xi)\n    return idx",
            "def pixel_indices(conv, mt, pr, qs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (T, R, S) = conv.TRS\n    (D, H, W) = conv.DHW\n    C = conv.C\n    HW = H * W\n    DHW = D * H * W\n    imax = C * DHW\n    idx = []\n    for c in range(C):\n        ci = c * DHW\n        for t in range(T):\n            z = mt + t\n            zi = ci + z * HW\n            zb = z >= 0 and z < D\n            for r in range(R):\n                y = pr + r\n                yi = zi + y * W\n                yb = zb and y >= 0 and (y < H)\n                for s in range(S):\n                    x = qs + s\n                    if yb and x >= 0 and (x < W):\n                        xi = yi + x\n                    else:\n                        xi = imax\n                    idx.append(xi)\n    return idx",
            "def pixel_indices(conv, mt, pr, qs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (T, R, S) = conv.TRS\n    (D, H, W) = conv.DHW\n    C = conv.C\n    HW = H * W\n    DHW = D * H * W\n    imax = C * DHW\n    idx = []\n    for c in range(C):\n        ci = c * DHW\n        for t in range(T):\n            z = mt + t\n            zi = ci + z * HW\n            zb = z >= 0 and z < D\n            for r in range(R):\n                y = pr + r\n                yi = zi + y * W\n                yb = zb and y >= 0 and (y < H)\n                for s in range(S):\n                    x = qs + s\n                    if yb and x >= 0 and (x < W):\n                        xi = yi + x\n                    else:\n                        xi = imax\n                    idx.append(xi)\n    return idx",
            "def pixel_indices(conv, mt, pr, qs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (T, R, S) = conv.TRS\n    (D, H, W) = conv.DHW\n    C = conv.C\n    HW = H * W\n    DHW = D * H * W\n    imax = C * DHW\n    idx = []\n    for c in range(C):\n        ci = c * DHW\n        for t in range(T):\n            z = mt + t\n            zi = ci + z * HW\n            zb = z >= 0 and z < D\n            for r in range(R):\n                y = pr + r\n                yi = zi + y * W\n                yb = zb and y >= 0 and (y < H)\n                for s in range(S):\n                    x = qs + s\n                    if yb and x >= 0 and (x < W):\n                        xi = yi + x\n                    else:\n                        xi = imax\n                    idx.append(xi)\n    return idx"
        ]
    },
    {
        "func_name": "run_backend_conv",
        "original": "def run_backend_conv(lib, layer, I, F, E, dtype):\n    beI = lib.array(I, dtype=dtype)\n    beF = lib.array(F, dtype=dtype)\n    beE = lib.array(E, dtype=dtype)\n    beO = lib.zeros(layer.dimO, dtype=dtype)\n    lib.fprop_conv(layer, beI, beF, beO)\n    beB = lib.zeros(layer.dimI, dtype=dtype)\n    lib.bprop_conv(layer, beF, beE, beB)\n    beU = lib.zeros(layer.dimF, dtype=dtype)\n    lib.update_conv(layer, beI, beE, beU)\n    return (beO, beB, beU)",
        "mutated": [
            "def run_backend_conv(lib, layer, I, F, E, dtype):\n    if False:\n        i = 10\n    beI = lib.array(I, dtype=dtype)\n    beF = lib.array(F, dtype=dtype)\n    beE = lib.array(E, dtype=dtype)\n    beO = lib.zeros(layer.dimO, dtype=dtype)\n    lib.fprop_conv(layer, beI, beF, beO)\n    beB = lib.zeros(layer.dimI, dtype=dtype)\n    lib.bprop_conv(layer, beF, beE, beB)\n    beU = lib.zeros(layer.dimF, dtype=dtype)\n    lib.update_conv(layer, beI, beE, beU)\n    return (beO, beB, beU)",
            "def run_backend_conv(lib, layer, I, F, E, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    beI = lib.array(I, dtype=dtype)\n    beF = lib.array(F, dtype=dtype)\n    beE = lib.array(E, dtype=dtype)\n    beO = lib.zeros(layer.dimO, dtype=dtype)\n    lib.fprop_conv(layer, beI, beF, beO)\n    beB = lib.zeros(layer.dimI, dtype=dtype)\n    lib.bprop_conv(layer, beF, beE, beB)\n    beU = lib.zeros(layer.dimF, dtype=dtype)\n    lib.update_conv(layer, beI, beE, beU)\n    return (beO, beB, beU)",
            "def run_backend_conv(lib, layer, I, F, E, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    beI = lib.array(I, dtype=dtype)\n    beF = lib.array(F, dtype=dtype)\n    beE = lib.array(E, dtype=dtype)\n    beO = lib.zeros(layer.dimO, dtype=dtype)\n    lib.fprop_conv(layer, beI, beF, beO)\n    beB = lib.zeros(layer.dimI, dtype=dtype)\n    lib.bprop_conv(layer, beF, beE, beB)\n    beU = lib.zeros(layer.dimF, dtype=dtype)\n    lib.update_conv(layer, beI, beE, beU)\n    return (beO, beB, beU)",
            "def run_backend_conv(lib, layer, I, F, E, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    beI = lib.array(I, dtype=dtype)\n    beF = lib.array(F, dtype=dtype)\n    beE = lib.array(E, dtype=dtype)\n    beO = lib.zeros(layer.dimO, dtype=dtype)\n    lib.fprop_conv(layer, beI, beF, beO)\n    beB = lib.zeros(layer.dimI, dtype=dtype)\n    lib.bprop_conv(layer, beF, beE, beB)\n    beU = lib.zeros(layer.dimF, dtype=dtype)\n    lib.update_conv(layer, beI, beE, beU)\n    return (beO, beB, beU)",
            "def run_backend_conv(lib, layer, I, F, E, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    beI = lib.array(I, dtype=dtype)\n    beF = lib.array(F, dtype=dtype)\n    beE = lib.array(E, dtype=dtype)\n    beO = lib.zeros(layer.dimO, dtype=dtype)\n    lib.fprop_conv(layer, beI, beF, beO)\n    beB = lib.zeros(layer.dimI, dtype=dtype)\n    lib.bprop_conv(layer, beF, beE, beB)\n    beU = lib.zeros(layer.dimF, dtype=dtype)\n    lib.update_conv(layer, beI, beE, beU)\n    return (beO, beB, beU)"
        ]
    },
    {
        "func_name": "pytest_generate_tests",
        "original": "def pytest_generate_tests(metafunc):\n    \"\"\"\n    Build a list of test arguments.\n\n    \"\"\"\n    N_C_K = [(64, 64, 64), (32, 1, 128)]\n    D_H_W = [(3, 7, 58), (3, 1, 68)]\n    T_R_S = [(3, 3, 3), (1, 3, 3), (1, 1, 11)]\n    pad_d_h_w = [(0, 1, 1), (0, 0, 1)]\n    str_d_h_w = [(1, 1, 1), (1, 1, 2)]\n    if 'fargs_tests' in metafunc.fixturenames:\n        fargs = itt.product(N_C_K, D_H_W, T_R_S, pad_d_h_w, str_d_h_w)\n        metafunc.parametrize('fargs_tests', fargs)",
        "mutated": [
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n    '\\n    Build a list of test arguments.\\n\\n    '\n    N_C_K = [(64, 64, 64), (32, 1, 128)]\n    D_H_W = [(3, 7, 58), (3, 1, 68)]\n    T_R_S = [(3, 3, 3), (1, 3, 3), (1, 1, 11)]\n    pad_d_h_w = [(0, 1, 1), (0, 0, 1)]\n    str_d_h_w = [(1, 1, 1), (1, 1, 2)]\n    if 'fargs_tests' in metafunc.fixturenames:\n        fargs = itt.product(N_C_K, D_H_W, T_R_S, pad_d_h_w, str_d_h_w)\n        metafunc.parametrize('fargs_tests', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Build a list of test arguments.\\n\\n    '\n    N_C_K = [(64, 64, 64), (32, 1, 128)]\n    D_H_W = [(3, 7, 58), (3, 1, 68)]\n    T_R_S = [(3, 3, 3), (1, 3, 3), (1, 1, 11)]\n    pad_d_h_w = [(0, 1, 1), (0, 0, 1)]\n    str_d_h_w = [(1, 1, 1), (1, 1, 2)]\n    if 'fargs_tests' in metafunc.fixturenames:\n        fargs = itt.product(N_C_K, D_H_W, T_R_S, pad_d_h_w, str_d_h_w)\n        metafunc.parametrize('fargs_tests', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Build a list of test arguments.\\n\\n    '\n    N_C_K = [(64, 64, 64), (32, 1, 128)]\n    D_H_W = [(3, 7, 58), (3, 1, 68)]\n    T_R_S = [(3, 3, 3), (1, 3, 3), (1, 1, 11)]\n    pad_d_h_w = [(0, 1, 1), (0, 0, 1)]\n    str_d_h_w = [(1, 1, 1), (1, 1, 2)]\n    if 'fargs_tests' in metafunc.fixturenames:\n        fargs = itt.product(N_C_K, D_H_W, T_R_S, pad_d_h_w, str_d_h_w)\n        metafunc.parametrize('fargs_tests', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Build a list of test arguments.\\n\\n    '\n    N_C_K = [(64, 64, 64), (32, 1, 128)]\n    D_H_W = [(3, 7, 58), (3, 1, 68)]\n    T_R_S = [(3, 3, 3), (1, 3, 3), (1, 1, 11)]\n    pad_d_h_w = [(0, 1, 1), (0, 0, 1)]\n    str_d_h_w = [(1, 1, 1), (1, 1, 2)]\n    if 'fargs_tests' in metafunc.fixturenames:\n        fargs = itt.product(N_C_K, D_H_W, T_R_S, pad_d_h_w, str_d_h_w)\n        metafunc.parametrize('fargs_tests', fargs)",
            "def pytest_generate_tests(metafunc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Build a list of test arguments.\\n\\n    '\n    N_C_K = [(64, 64, 64), (32, 1, 128)]\n    D_H_W = [(3, 7, 58), (3, 1, 68)]\n    T_R_S = [(3, 3, 3), (1, 3, 3), (1, 1, 11)]\n    pad_d_h_w = [(0, 1, 1), (0, 0, 1)]\n    str_d_h_w = [(1, 1, 1), (1, 1, 2)]\n    if 'fargs_tests' in metafunc.fixturenames:\n        fargs = itt.product(N_C_K, D_H_W, T_R_S, pad_d_h_w, str_d_h_w)\n        metafunc.parametrize('fargs_tests', fargs)"
        ]
    },
    {
        "func_name": "test_conv_layer_mkl",
        "original": "def test_conv_layer_mkl(fargs_tests, backend_pair_mkl):\n    dtype = np.float32\n    (nm, nc) = backend_pair_mkl\n    (N, C, K) = fargs_tests[0]\n    (D, H, W) = fargs_tests[1]\n    (T, R, S) = fargs_tests[2]\n    (padding_d, padding_h, padding_w) = fargs_tests[3]\n    (strides_d, strides_h, strides_w) = fargs_tests[4]\n    conv_nm = nm.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    conv_nc = nc.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    assert conv_nc.dimI == conv_nm.dimI\n    assert conv_nc.dimF == conv_nm.dimF\n    assert conv_nc.dimO == conv_nm.dimO\n    assert conv_nc.M == conv_nm.M\n    dimI = conv_nm.dimI\n    dimF = conv_nm.dimF\n    dimO = conv_nm.dimO\n    if any(np.array(dimO) <= 0):\n        return\n    cpuI = np.random.uniform(-0.8, 0.8, slicable(dimI, 1)).astype(np.float32)\n    cpuF = np.random.uniform(0.0, 0.3, slicable(dimF)).astype(np.float32)\n    cpuE = np.random.uniform(-0.2, 0.2, dimO).astype(np.float32)\n    cpuI[-1, :] = 0.0\n    beI = cpuI[:-1, :].reshape(dimI)\n    beF = cpuF.reshape(dimF)\n    beE = cpuE\n    start_mkl = default_timer()\n    (nmO, nmB, nmU) = run_backend_conv(nm, conv_nm, beI, beF, beE, dtype)\n    end_mkl = default_timer()\n    start_cpu = default_timer()\n    (ncO, ncB, ncU) = run_backend_conv(nc, conv_nc, beI, beF, beE, dtype)\n    end_cpu = default_timer()\n    neon_logger.display('mkltime: %s, cputime %s' % (end_mkl - start_mkl, end_cpu - start_cpu))\n    cpuO = np.zeros(dimO, dtype=dtype)\n    cpuB = np.zeros(slicable(dimI, 1), dtype=dtype)\n    cpuU = np.zeros(slicable(dimF), dtype=dtype)\n    (D, H, W) = conv_nc.DHW\n    (T, R, S) = conv_nc.TRS\n    (M, P, Q) = conv_nc.MPQ\n    (pad_d, pad_h, pad_w) = conv_nc.padding\n    (str_d, str_h, str_w) = conv_nc.strides\n    for m in range(M):\n        mt = m * str_d - pad_d\n        for p in range(P):\n            pr = p * str_h - pad_h\n            for q in range(Q):\n                qs = q * str_w - pad_w\n                idx = pixel_indices(conv_nc, mt, pr, qs)\n                cpuO[:, m, p, q, :] = np.dot(cpuF.T, cpuI[idx, :])\n                cpuB[idx, :] += np.dot(cpuF, cpuE[:, m, p, q, :])\n                cpuU += np.dot(cpuI[idx, :], cpuE[:, m, p, q, :].T)\n    for (op, nmA, ncA, cpuA, w) in (('fprop', nmO, ncO, cpuO, Q), ('bprop', nmB, ncB.reshape(dimI), cpuB[:-1, :].reshape(dimI), W), ('update', nmU, ncU.reshape(dimF), cpuU.reshape(dimF), S)):\n        neon_logger.display(op)\n        ncAnp = ncA.get().astype(np.float32)\n        nmAnp = nmA.get().astype(np.float32)\n        ncdif = cpuA - ncAnp\n        nmdif = cpuA - nmAnp\n        maxval = abs(cpuA).max()\n        ncmaxdif = abs(ncdif).max()\n        nmmaxdif = abs(nmdif).max()\n        ncRatio = ncmaxdif / float(maxval)\n        nmRatio = nmmaxdif / float(maxval)\n        assert ncRatio < 1e-05\n        assert nmRatio < 1e-05\n        assert allclose_with_out(ncA.get(), cpuA, rtol=0, atol=1e-05)\n        assert allclose_with_out(nmA.get(), cpuA, rtol=0, atol=0.001)",
        "mutated": [
            "def test_conv_layer_mkl(fargs_tests, backend_pair_mkl):\n    if False:\n        i = 10\n    dtype = np.float32\n    (nm, nc) = backend_pair_mkl\n    (N, C, K) = fargs_tests[0]\n    (D, H, W) = fargs_tests[1]\n    (T, R, S) = fargs_tests[2]\n    (padding_d, padding_h, padding_w) = fargs_tests[3]\n    (strides_d, strides_h, strides_w) = fargs_tests[4]\n    conv_nm = nm.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    conv_nc = nc.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    assert conv_nc.dimI == conv_nm.dimI\n    assert conv_nc.dimF == conv_nm.dimF\n    assert conv_nc.dimO == conv_nm.dimO\n    assert conv_nc.M == conv_nm.M\n    dimI = conv_nm.dimI\n    dimF = conv_nm.dimF\n    dimO = conv_nm.dimO\n    if any(np.array(dimO) <= 0):\n        return\n    cpuI = np.random.uniform(-0.8, 0.8, slicable(dimI, 1)).astype(np.float32)\n    cpuF = np.random.uniform(0.0, 0.3, slicable(dimF)).astype(np.float32)\n    cpuE = np.random.uniform(-0.2, 0.2, dimO).astype(np.float32)\n    cpuI[-1, :] = 0.0\n    beI = cpuI[:-1, :].reshape(dimI)\n    beF = cpuF.reshape(dimF)\n    beE = cpuE\n    start_mkl = default_timer()\n    (nmO, nmB, nmU) = run_backend_conv(nm, conv_nm, beI, beF, beE, dtype)\n    end_mkl = default_timer()\n    start_cpu = default_timer()\n    (ncO, ncB, ncU) = run_backend_conv(nc, conv_nc, beI, beF, beE, dtype)\n    end_cpu = default_timer()\n    neon_logger.display('mkltime: %s, cputime %s' % (end_mkl - start_mkl, end_cpu - start_cpu))\n    cpuO = np.zeros(dimO, dtype=dtype)\n    cpuB = np.zeros(slicable(dimI, 1), dtype=dtype)\n    cpuU = np.zeros(slicable(dimF), dtype=dtype)\n    (D, H, W) = conv_nc.DHW\n    (T, R, S) = conv_nc.TRS\n    (M, P, Q) = conv_nc.MPQ\n    (pad_d, pad_h, pad_w) = conv_nc.padding\n    (str_d, str_h, str_w) = conv_nc.strides\n    for m in range(M):\n        mt = m * str_d - pad_d\n        for p in range(P):\n            pr = p * str_h - pad_h\n            for q in range(Q):\n                qs = q * str_w - pad_w\n                idx = pixel_indices(conv_nc, mt, pr, qs)\n                cpuO[:, m, p, q, :] = np.dot(cpuF.T, cpuI[idx, :])\n                cpuB[idx, :] += np.dot(cpuF, cpuE[:, m, p, q, :])\n                cpuU += np.dot(cpuI[idx, :], cpuE[:, m, p, q, :].T)\n    for (op, nmA, ncA, cpuA, w) in (('fprop', nmO, ncO, cpuO, Q), ('bprop', nmB, ncB.reshape(dimI), cpuB[:-1, :].reshape(dimI), W), ('update', nmU, ncU.reshape(dimF), cpuU.reshape(dimF), S)):\n        neon_logger.display(op)\n        ncAnp = ncA.get().astype(np.float32)\n        nmAnp = nmA.get().astype(np.float32)\n        ncdif = cpuA - ncAnp\n        nmdif = cpuA - nmAnp\n        maxval = abs(cpuA).max()\n        ncmaxdif = abs(ncdif).max()\n        nmmaxdif = abs(nmdif).max()\n        ncRatio = ncmaxdif / float(maxval)\n        nmRatio = nmmaxdif / float(maxval)\n        assert ncRatio < 1e-05\n        assert nmRatio < 1e-05\n        assert allclose_with_out(ncA.get(), cpuA, rtol=0, atol=1e-05)\n        assert allclose_with_out(nmA.get(), cpuA, rtol=0, atol=0.001)",
            "def test_conv_layer_mkl(fargs_tests, backend_pair_mkl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dtype = np.float32\n    (nm, nc) = backend_pair_mkl\n    (N, C, K) = fargs_tests[0]\n    (D, H, W) = fargs_tests[1]\n    (T, R, S) = fargs_tests[2]\n    (padding_d, padding_h, padding_w) = fargs_tests[3]\n    (strides_d, strides_h, strides_w) = fargs_tests[4]\n    conv_nm = nm.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    conv_nc = nc.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    assert conv_nc.dimI == conv_nm.dimI\n    assert conv_nc.dimF == conv_nm.dimF\n    assert conv_nc.dimO == conv_nm.dimO\n    assert conv_nc.M == conv_nm.M\n    dimI = conv_nm.dimI\n    dimF = conv_nm.dimF\n    dimO = conv_nm.dimO\n    if any(np.array(dimO) <= 0):\n        return\n    cpuI = np.random.uniform(-0.8, 0.8, slicable(dimI, 1)).astype(np.float32)\n    cpuF = np.random.uniform(0.0, 0.3, slicable(dimF)).astype(np.float32)\n    cpuE = np.random.uniform(-0.2, 0.2, dimO).astype(np.float32)\n    cpuI[-1, :] = 0.0\n    beI = cpuI[:-1, :].reshape(dimI)\n    beF = cpuF.reshape(dimF)\n    beE = cpuE\n    start_mkl = default_timer()\n    (nmO, nmB, nmU) = run_backend_conv(nm, conv_nm, beI, beF, beE, dtype)\n    end_mkl = default_timer()\n    start_cpu = default_timer()\n    (ncO, ncB, ncU) = run_backend_conv(nc, conv_nc, beI, beF, beE, dtype)\n    end_cpu = default_timer()\n    neon_logger.display('mkltime: %s, cputime %s' % (end_mkl - start_mkl, end_cpu - start_cpu))\n    cpuO = np.zeros(dimO, dtype=dtype)\n    cpuB = np.zeros(slicable(dimI, 1), dtype=dtype)\n    cpuU = np.zeros(slicable(dimF), dtype=dtype)\n    (D, H, W) = conv_nc.DHW\n    (T, R, S) = conv_nc.TRS\n    (M, P, Q) = conv_nc.MPQ\n    (pad_d, pad_h, pad_w) = conv_nc.padding\n    (str_d, str_h, str_w) = conv_nc.strides\n    for m in range(M):\n        mt = m * str_d - pad_d\n        for p in range(P):\n            pr = p * str_h - pad_h\n            for q in range(Q):\n                qs = q * str_w - pad_w\n                idx = pixel_indices(conv_nc, mt, pr, qs)\n                cpuO[:, m, p, q, :] = np.dot(cpuF.T, cpuI[idx, :])\n                cpuB[idx, :] += np.dot(cpuF, cpuE[:, m, p, q, :])\n                cpuU += np.dot(cpuI[idx, :], cpuE[:, m, p, q, :].T)\n    for (op, nmA, ncA, cpuA, w) in (('fprop', nmO, ncO, cpuO, Q), ('bprop', nmB, ncB.reshape(dimI), cpuB[:-1, :].reshape(dimI), W), ('update', nmU, ncU.reshape(dimF), cpuU.reshape(dimF), S)):\n        neon_logger.display(op)\n        ncAnp = ncA.get().astype(np.float32)\n        nmAnp = nmA.get().astype(np.float32)\n        ncdif = cpuA - ncAnp\n        nmdif = cpuA - nmAnp\n        maxval = abs(cpuA).max()\n        ncmaxdif = abs(ncdif).max()\n        nmmaxdif = abs(nmdif).max()\n        ncRatio = ncmaxdif / float(maxval)\n        nmRatio = nmmaxdif / float(maxval)\n        assert ncRatio < 1e-05\n        assert nmRatio < 1e-05\n        assert allclose_with_out(ncA.get(), cpuA, rtol=0, atol=1e-05)\n        assert allclose_with_out(nmA.get(), cpuA, rtol=0, atol=0.001)",
            "def test_conv_layer_mkl(fargs_tests, backend_pair_mkl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dtype = np.float32\n    (nm, nc) = backend_pair_mkl\n    (N, C, K) = fargs_tests[0]\n    (D, H, W) = fargs_tests[1]\n    (T, R, S) = fargs_tests[2]\n    (padding_d, padding_h, padding_w) = fargs_tests[3]\n    (strides_d, strides_h, strides_w) = fargs_tests[4]\n    conv_nm = nm.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    conv_nc = nc.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    assert conv_nc.dimI == conv_nm.dimI\n    assert conv_nc.dimF == conv_nm.dimF\n    assert conv_nc.dimO == conv_nm.dimO\n    assert conv_nc.M == conv_nm.M\n    dimI = conv_nm.dimI\n    dimF = conv_nm.dimF\n    dimO = conv_nm.dimO\n    if any(np.array(dimO) <= 0):\n        return\n    cpuI = np.random.uniform(-0.8, 0.8, slicable(dimI, 1)).astype(np.float32)\n    cpuF = np.random.uniform(0.0, 0.3, slicable(dimF)).astype(np.float32)\n    cpuE = np.random.uniform(-0.2, 0.2, dimO).astype(np.float32)\n    cpuI[-1, :] = 0.0\n    beI = cpuI[:-1, :].reshape(dimI)\n    beF = cpuF.reshape(dimF)\n    beE = cpuE\n    start_mkl = default_timer()\n    (nmO, nmB, nmU) = run_backend_conv(nm, conv_nm, beI, beF, beE, dtype)\n    end_mkl = default_timer()\n    start_cpu = default_timer()\n    (ncO, ncB, ncU) = run_backend_conv(nc, conv_nc, beI, beF, beE, dtype)\n    end_cpu = default_timer()\n    neon_logger.display('mkltime: %s, cputime %s' % (end_mkl - start_mkl, end_cpu - start_cpu))\n    cpuO = np.zeros(dimO, dtype=dtype)\n    cpuB = np.zeros(slicable(dimI, 1), dtype=dtype)\n    cpuU = np.zeros(slicable(dimF), dtype=dtype)\n    (D, H, W) = conv_nc.DHW\n    (T, R, S) = conv_nc.TRS\n    (M, P, Q) = conv_nc.MPQ\n    (pad_d, pad_h, pad_w) = conv_nc.padding\n    (str_d, str_h, str_w) = conv_nc.strides\n    for m in range(M):\n        mt = m * str_d - pad_d\n        for p in range(P):\n            pr = p * str_h - pad_h\n            for q in range(Q):\n                qs = q * str_w - pad_w\n                idx = pixel_indices(conv_nc, mt, pr, qs)\n                cpuO[:, m, p, q, :] = np.dot(cpuF.T, cpuI[idx, :])\n                cpuB[idx, :] += np.dot(cpuF, cpuE[:, m, p, q, :])\n                cpuU += np.dot(cpuI[idx, :], cpuE[:, m, p, q, :].T)\n    for (op, nmA, ncA, cpuA, w) in (('fprop', nmO, ncO, cpuO, Q), ('bprop', nmB, ncB.reshape(dimI), cpuB[:-1, :].reshape(dimI), W), ('update', nmU, ncU.reshape(dimF), cpuU.reshape(dimF), S)):\n        neon_logger.display(op)\n        ncAnp = ncA.get().astype(np.float32)\n        nmAnp = nmA.get().astype(np.float32)\n        ncdif = cpuA - ncAnp\n        nmdif = cpuA - nmAnp\n        maxval = abs(cpuA).max()\n        ncmaxdif = abs(ncdif).max()\n        nmmaxdif = abs(nmdif).max()\n        ncRatio = ncmaxdif / float(maxval)\n        nmRatio = nmmaxdif / float(maxval)\n        assert ncRatio < 1e-05\n        assert nmRatio < 1e-05\n        assert allclose_with_out(ncA.get(), cpuA, rtol=0, atol=1e-05)\n        assert allclose_with_out(nmA.get(), cpuA, rtol=0, atol=0.001)",
            "def test_conv_layer_mkl(fargs_tests, backend_pair_mkl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dtype = np.float32\n    (nm, nc) = backend_pair_mkl\n    (N, C, K) = fargs_tests[0]\n    (D, H, W) = fargs_tests[1]\n    (T, R, S) = fargs_tests[2]\n    (padding_d, padding_h, padding_w) = fargs_tests[3]\n    (strides_d, strides_h, strides_w) = fargs_tests[4]\n    conv_nm = nm.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    conv_nc = nc.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    assert conv_nc.dimI == conv_nm.dimI\n    assert conv_nc.dimF == conv_nm.dimF\n    assert conv_nc.dimO == conv_nm.dimO\n    assert conv_nc.M == conv_nm.M\n    dimI = conv_nm.dimI\n    dimF = conv_nm.dimF\n    dimO = conv_nm.dimO\n    if any(np.array(dimO) <= 0):\n        return\n    cpuI = np.random.uniform(-0.8, 0.8, slicable(dimI, 1)).astype(np.float32)\n    cpuF = np.random.uniform(0.0, 0.3, slicable(dimF)).astype(np.float32)\n    cpuE = np.random.uniform(-0.2, 0.2, dimO).astype(np.float32)\n    cpuI[-1, :] = 0.0\n    beI = cpuI[:-1, :].reshape(dimI)\n    beF = cpuF.reshape(dimF)\n    beE = cpuE\n    start_mkl = default_timer()\n    (nmO, nmB, nmU) = run_backend_conv(nm, conv_nm, beI, beF, beE, dtype)\n    end_mkl = default_timer()\n    start_cpu = default_timer()\n    (ncO, ncB, ncU) = run_backend_conv(nc, conv_nc, beI, beF, beE, dtype)\n    end_cpu = default_timer()\n    neon_logger.display('mkltime: %s, cputime %s' % (end_mkl - start_mkl, end_cpu - start_cpu))\n    cpuO = np.zeros(dimO, dtype=dtype)\n    cpuB = np.zeros(slicable(dimI, 1), dtype=dtype)\n    cpuU = np.zeros(slicable(dimF), dtype=dtype)\n    (D, H, W) = conv_nc.DHW\n    (T, R, S) = conv_nc.TRS\n    (M, P, Q) = conv_nc.MPQ\n    (pad_d, pad_h, pad_w) = conv_nc.padding\n    (str_d, str_h, str_w) = conv_nc.strides\n    for m in range(M):\n        mt = m * str_d - pad_d\n        for p in range(P):\n            pr = p * str_h - pad_h\n            for q in range(Q):\n                qs = q * str_w - pad_w\n                idx = pixel_indices(conv_nc, mt, pr, qs)\n                cpuO[:, m, p, q, :] = np.dot(cpuF.T, cpuI[idx, :])\n                cpuB[idx, :] += np.dot(cpuF, cpuE[:, m, p, q, :])\n                cpuU += np.dot(cpuI[idx, :], cpuE[:, m, p, q, :].T)\n    for (op, nmA, ncA, cpuA, w) in (('fprop', nmO, ncO, cpuO, Q), ('bprop', nmB, ncB.reshape(dimI), cpuB[:-1, :].reshape(dimI), W), ('update', nmU, ncU.reshape(dimF), cpuU.reshape(dimF), S)):\n        neon_logger.display(op)\n        ncAnp = ncA.get().astype(np.float32)\n        nmAnp = nmA.get().astype(np.float32)\n        ncdif = cpuA - ncAnp\n        nmdif = cpuA - nmAnp\n        maxval = abs(cpuA).max()\n        ncmaxdif = abs(ncdif).max()\n        nmmaxdif = abs(nmdif).max()\n        ncRatio = ncmaxdif / float(maxval)\n        nmRatio = nmmaxdif / float(maxval)\n        assert ncRatio < 1e-05\n        assert nmRatio < 1e-05\n        assert allclose_with_out(ncA.get(), cpuA, rtol=0, atol=1e-05)\n        assert allclose_with_out(nmA.get(), cpuA, rtol=0, atol=0.001)",
            "def test_conv_layer_mkl(fargs_tests, backend_pair_mkl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dtype = np.float32\n    (nm, nc) = backend_pair_mkl\n    (N, C, K) = fargs_tests[0]\n    (D, H, W) = fargs_tests[1]\n    (T, R, S) = fargs_tests[2]\n    (padding_d, padding_h, padding_w) = fargs_tests[3]\n    (strides_d, strides_h, strides_w) = fargs_tests[4]\n    conv_nm = nm.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    conv_nc = nc.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    assert conv_nc.dimI == conv_nm.dimI\n    assert conv_nc.dimF == conv_nm.dimF\n    assert conv_nc.dimO == conv_nm.dimO\n    assert conv_nc.M == conv_nm.M\n    dimI = conv_nm.dimI\n    dimF = conv_nm.dimF\n    dimO = conv_nm.dimO\n    if any(np.array(dimO) <= 0):\n        return\n    cpuI = np.random.uniform(-0.8, 0.8, slicable(dimI, 1)).astype(np.float32)\n    cpuF = np.random.uniform(0.0, 0.3, slicable(dimF)).astype(np.float32)\n    cpuE = np.random.uniform(-0.2, 0.2, dimO).astype(np.float32)\n    cpuI[-1, :] = 0.0\n    beI = cpuI[:-1, :].reshape(dimI)\n    beF = cpuF.reshape(dimF)\n    beE = cpuE\n    start_mkl = default_timer()\n    (nmO, nmB, nmU) = run_backend_conv(nm, conv_nm, beI, beF, beE, dtype)\n    end_mkl = default_timer()\n    start_cpu = default_timer()\n    (ncO, ncB, ncU) = run_backend_conv(nc, conv_nc, beI, beF, beE, dtype)\n    end_cpu = default_timer()\n    neon_logger.display('mkltime: %s, cputime %s' % (end_mkl - start_mkl, end_cpu - start_cpu))\n    cpuO = np.zeros(dimO, dtype=dtype)\n    cpuB = np.zeros(slicable(dimI, 1), dtype=dtype)\n    cpuU = np.zeros(slicable(dimF), dtype=dtype)\n    (D, H, W) = conv_nc.DHW\n    (T, R, S) = conv_nc.TRS\n    (M, P, Q) = conv_nc.MPQ\n    (pad_d, pad_h, pad_w) = conv_nc.padding\n    (str_d, str_h, str_w) = conv_nc.strides\n    for m in range(M):\n        mt = m * str_d - pad_d\n        for p in range(P):\n            pr = p * str_h - pad_h\n            for q in range(Q):\n                qs = q * str_w - pad_w\n                idx = pixel_indices(conv_nc, mt, pr, qs)\n                cpuO[:, m, p, q, :] = np.dot(cpuF.T, cpuI[idx, :])\n                cpuB[idx, :] += np.dot(cpuF, cpuE[:, m, p, q, :])\n                cpuU += np.dot(cpuI[idx, :], cpuE[:, m, p, q, :].T)\n    for (op, nmA, ncA, cpuA, w) in (('fprop', nmO, ncO, cpuO, Q), ('bprop', nmB, ncB.reshape(dimI), cpuB[:-1, :].reshape(dimI), W), ('update', nmU, ncU.reshape(dimF), cpuU.reshape(dimF), S)):\n        neon_logger.display(op)\n        ncAnp = ncA.get().astype(np.float32)\n        nmAnp = nmA.get().astype(np.float32)\n        ncdif = cpuA - ncAnp\n        nmdif = cpuA - nmAnp\n        maxval = abs(cpuA).max()\n        ncmaxdif = abs(ncdif).max()\n        nmmaxdif = abs(nmdif).max()\n        ncRatio = ncmaxdif / float(maxval)\n        nmRatio = nmmaxdif / float(maxval)\n        assert ncRatio < 1e-05\n        assert nmRatio < 1e-05\n        assert allclose_with_out(ncA.get(), cpuA, rtol=0, atol=1e-05)\n        assert allclose_with_out(nmA.get(), cpuA, rtol=0, atol=0.001)"
        ]
    },
    {
        "func_name": "test_conv_layer",
        "original": "@pytest.mark.hasgpu\ndef test_conv_layer(fargs_tests, backend_pair):\n    dtype = np.float32\n    (ng, nc) = backend_pair\n    if ng.compute_capability < (5, 0):\n        pytest.skip(msg='Test requires Maxwell or higher')\n    (N, C, K) = fargs_tests[0]\n    (D, H, W) = fargs_tests[1]\n    (T, R, S) = fargs_tests[2]\n    (padding_d, padding_h, padding_w) = fargs_tests[3]\n    (strides_d, strides_h, strides_w) = fargs_tests[4]\n    conv_ng = ng.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    conv_nc = nc.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    assert conv_nc.dimI == conv_ng.dimI\n    assert conv_nc.dimF == conv_ng.dimF\n    assert conv_nc.dimO == conv_ng.dimO\n    assert conv_nc.M == conv_ng.M\n    dimI = conv_ng.dimI\n    dimF = conv_ng.dimF\n    dimO = conv_ng.dimO\n    if any(np.array(dimO) <= 0):\n        return\n    cpuI = np.random.uniform(-0.8, 0.8, slicable(dimI, 1)).astype(np.float32)\n    cpuF = np.random.uniform(0.0, 0.3, slicable(dimF)).astype(np.float32)\n    cpuE = np.random.uniform(-0.2, 0.2, dimO).astype(np.float32)\n    cpuI[-1, :] = 0.0\n    beI = cpuI[:-1, :].reshape(dimI)\n    beF = cpuF.reshape(dimF)\n    beE = cpuE\n    start_gpu = default_timer()\n    (ngO, ngB, ngU) = run_backend_conv(ng, conv_ng, beI, beF, beE, dtype)\n    end_gpu = default_timer()\n    start_cpu = default_timer()\n    (ncO, ncB, ncU) = run_backend_conv(nc, conv_nc, beI, beF, beE, dtype)\n    end_cpu = default_timer()\n    neon_logger.display('gputime: %s, cputime %s' % (end_gpu - start_gpu, end_cpu - start_cpu))\n    cpuO = np.zeros(dimO, dtype=dtype)\n    cpuB = np.zeros(slicable(dimI, 1), dtype=dtype)\n    cpuU = np.zeros(slicable(dimF), dtype=dtype)\n    (D, H, W) = conv_nc.DHW\n    (T, R, S) = conv_nc.TRS\n    (M, P, Q) = conv_nc.MPQ\n    (pad_d, pad_h, pad_w) = conv_nc.padding\n    (str_d, str_h, str_w) = conv_nc.strides\n    for m in range(M):\n        mt = m * str_d - pad_d\n        for p in range(P):\n            pr = p * str_h - pad_h\n            for q in range(Q):\n                qs = q * str_w - pad_w\n                idx = pixel_indices(conv_nc, mt, pr, qs)\n                cpuO[:, m, p, q, :] = np.dot(cpuF.T, cpuI[idx, :])\n                cpuB[idx, :] += np.dot(cpuF, cpuE[:, m, p, q, :])\n                cpuU += np.dot(cpuI[idx, :], cpuE[:, m, p, q, :].T)\n    for (opA, ngA, ncA, cpuA, w) in (('fprop', ngO, ncO, cpuO, Q), ('bprop', ngB, ncB.reshape(dimI), cpuB[:-1, :].reshape(dimI), W), ('update', ngU, ncU.reshape(dimF), cpuU.reshape(dimF), S)):\n        neon_logger.display(opA)\n        ncAnp = ncA.get().astype(np.float32)\n        ngAnp = ngA.get().astype(np.float32)\n        ncdif = cpuA - ncAnp\n        ngdif = cpuA - ngAnp\n        maxval = abs(cpuA).max()\n        ncmaxdif = abs(ncdif).max()\n        ngmaxdif = abs(ngdif).max()\n        ncRatio = ncmaxdif / float(maxval)\n        ngRatio = ngmaxdif / float(maxval)\n        assert ncRatio < 1e-05\n        assert ngRatio < 1e-05\n        assert allclose_with_out(ncA.get(), cpuA, rtol=1e-05, atol=0.0001)\n        assert allclose_with_out(ngA.get(), cpuA, rtol=1e-05, atol=0.001)",
        "mutated": [
            "@pytest.mark.hasgpu\ndef test_conv_layer(fargs_tests, backend_pair):\n    if False:\n        i = 10\n    dtype = np.float32\n    (ng, nc) = backend_pair\n    if ng.compute_capability < (5, 0):\n        pytest.skip(msg='Test requires Maxwell or higher')\n    (N, C, K) = fargs_tests[0]\n    (D, H, W) = fargs_tests[1]\n    (T, R, S) = fargs_tests[2]\n    (padding_d, padding_h, padding_w) = fargs_tests[3]\n    (strides_d, strides_h, strides_w) = fargs_tests[4]\n    conv_ng = ng.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    conv_nc = nc.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    assert conv_nc.dimI == conv_ng.dimI\n    assert conv_nc.dimF == conv_ng.dimF\n    assert conv_nc.dimO == conv_ng.dimO\n    assert conv_nc.M == conv_ng.M\n    dimI = conv_ng.dimI\n    dimF = conv_ng.dimF\n    dimO = conv_ng.dimO\n    if any(np.array(dimO) <= 0):\n        return\n    cpuI = np.random.uniform(-0.8, 0.8, slicable(dimI, 1)).astype(np.float32)\n    cpuF = np.random.uniform(0.0, 0.3, slicable(dimF)).astype(np.float32)\n    cpuE = np.random.uniform(-0.2, 0.2, dimO).astype(np.float32)\n    cpuI[-1, :] = 0.0\n    beI = cpuI[:-1, :].reshape(dimI)\n    beF = cpuF.reshape(dimF)\n    beE = cpuE\n    start_gpu = default_timer()\n    (ngO, ngB, ngU) = run_backend_conv(ng, conv_ng, beI, beF, beE, dtype)\n    end_gpu = default_timer()\n    start_cpu = default_timer()\n    (ncO, ncB, ncU) = run_backend_conv(nc, conv_nc, beI, beF, beE, dtype)\n    end_cpu = default_timer()\n    neon_logger.display('gputime: %s, cputime %s' % (end_gpu - start_gpu, end_cpu - start_cpu))\n    cpuO = np.zeros(dimO, dtype=dtype)\n    cpuB = np.zeros(slicable(dimI, 1), dtype=dtype)\n    cpuU = np.zeros(slicable(dimF), dtype=dtype)\n    (D, H, W) = conv_nc.DHW\n    (T, R, S) = conv_nc.TRS\n    (M, P, Q) = conv_nc.MPQ\n    (pad_d, pad_h, pad_w) = conv_nc.padding\n    (str_d, str_h, str_w) = conv_nc.strides\n    for m in range(M):\n        mt = m * str_d - pad_d\n        for p in range(P):\n            pr = p * str_h - pad_h\n            for q in range(Q):\n                qs = q * str_w - pad_w\n                idx = pixel_indices(conv_nc, mt, pr, qs)\n                cpuO[:, m, p, q, :] = np.dot(cpuF.T, cpuI[idx, :])\n                cpuB[idx, :] += np.dot(cpuF, cpuE[:, m, p, q, :])\n                cpuU += np.dot(cpuI[idx, :], cpuE[:, m, p, q, :].T)\n    for (opA, ngA, ncA, cpuA, w) in (('fprop', ngO, ncO, cpuO, Q), ('bprop', ngB, ncB.reshape(dimI), cpuB[:-1, :].reshape(dimI), W), ('update', ngU, ncU.reshape(dimF), cpuU.reshape(dimF), S)):\n        neon_logger.display(opA)\n        ncAnp = ncA.get().astype(np.float32)\n        ngAnp = ngA.get().astype(np.float32)\n        ncdif = cpuA - ncAnp\n        ngdif = cpuA - ngAnp\n        maxval = abs(cpuA).max()\n        ncmaxdif = abs(ncdif).max()\n        ngmaxdif = abs(ngdif).max()\n        ncRatio = ncmaxdif / float(maxval)\n        ngRatio = ngmaxdif / float(maxval)\n        assert ncRatio < 1e-05\n        assert ngRatio < 1e-05\n        assert allclose_with_out(ncA.get(), cpuA, rtol=1e-05, atol=0.0001)\n        assert allclose_with_out(ngA.get(), cpuA, rtol=1e-05, atol=0.001)",
            "@pytest.mark.hasgpu\ndef test_conv_layer(fargs_tests, backend_pair):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dtype = np.float32\n    (ng, nc) = backend_pair\n    if ng.compute_capability < (5, 0):\n        pytest.skip(msg='Test requires Maxwell or higher')\n    (N, C, K) = fargs_tests[0]\n    (D, H, W) = fargs_tests[1]\n    (T, R, S) = fargs_tests[2]\n    (padding_d, padding_h, padding_w) = fargs_tests[3]\n    (strides_d, strides_h, strides_w) = fargs_tests[4]\n    conv_ng = ng.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    conv_nc = nc.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    assert conv_nc.dimI == conv_ng.dimI\n    assert conv_nc.dimF == conv_ng.dimF\n    assert conv_nc.dimO == conv_ng.dimO\n    assert conv_nc.M == conv_ng.M\n    dimI = conv_ng.dimI\n    dimF = conv_ng.dimF\n    dimO = conv_ng.dimO\n    if any(np.array(dimO) <= 0):\n        return\n    cpuI = np.random.uniform(-0.8, 0.8, slicable(dimI, 1)).astype(np.float32)\n    cpuF = np.random.uniform(0.0, 0.3, slicable(dimF)).astype(np.float32)\n    cpuE = np.random.uniform(-0.2, 0.2, dimO).astype(np.float32)\n    cpuI[-1, :] = 0.0\n    beI = cpuI[:-1, :].reshape(dimI)\n    beF = cpuF.reshape(dimF)\n    beE = cpuE\n    start_gpu = default_timer()\n    (ngO, ngB, ngU) = run_backend_conv(ng, conv_ng, beI, beF, beE, dtype)\n    end_gpu = default_timer()\n    start_cpu = default_timer()\n    (ncO, ncB, ncU) = run_backend_conv(nc, conv_nc, beI, beF, beE, dtype)\n    end_cpu = default_timer()\n    neon_logger.display('gputime: %s, cputime %s' % (end_gpu - start_gpu, end_cpu - start_cpu))\n    cpuO = np.zeros(dimO, dtype=dtype)\n    cpuB = np.zeros(slicable(dimI, 1), dtype=dtype)\n    cpuU = np.zeros(slicable(dimF), dtype=dtype)\n    (D, H, W) = conv_nc.DHW\n    (T, R, S) = conv_nc.TRS\n    (M, P, Q) = conv_nc.MPQ\n    (pad_d, pad_h, pad_w) = conv_nc.padding\n    (str_d, str_h, str_w) = conv_nc.strides\n    for m in range(M):\n        mt = m * str_d - pad_d\n        for p in range(P):\n            pr = p * str_h - pad_h\n            for q in range(Q):\n                qs = q * str_w - pad_w\n                idx = pixel_indices(conv_nc, mt, pr, qs)\n                cpuO[:, m, p, q, :] = np.dot(cpuF.T, cpuI[idx, :])\n                cpuB[idx, :] += np.dot(cpuF, cpuE[:, m, p, q, :])\n                cpuU += np.dot(cpuI[idx, :], cpuE[:, m, p, q, :].T)\n    for (opA, ngA, ncA, cpuA, w) in (('fprop', ngO, ncO, cpuO, Q), ('bprop', ngB, ncB.reshape(dimI), cpuB[:-1, :].reshape(dimI), W), ('update', ngU, ncU.reshape(dimF), cpuU.reshape(dimF), S)):\n        neon_logger.display(opA)\n        ncAnp = ncA.get().astype(np.float32)\n        ngAnp = ngA.get().astype(np.float32)\n        ncdif = cpuA - ncAnp\n        ngdif = cpuA - ngAnp\n        maxval = abs(cpuA).max()\n        ncmaxdif = abs(ncdif).max()\n        ngmaxdif = abs(ngdif).max()\n        ncRatio = ncmaxdif / float(maxval)\n        ngRatio = ngmaxdif / float(maxval)\n        assert ncRatio < 1e-05\n        assert ngRatio < 1e-05\n        assert allclose_with_out(ncA.get(), cpuA, rtol=1e-05, atol=0.0001)\n        assert allclose_with_out(ngA.get(), cpuA, rtol=1e-05, atol=0.001)",
            "@pytest.mark.hasgpu\ndef test_conv_layer(fargs_tests, backend_pair):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dtype = np.float32\n    (ng, nc) = backend_pair\n    if ng.compute_capability < (5, 0):\n        pytest.skip(msg='Test requires Maxwell or higher')\n    (N, C, K) = fargs_tests[0]\n    (D, H, W) = fargs_tests[1]\n    (T, R, S) = fargs_tests[2]\n    (padding_d, padding_h, padding_w) = fargs_tests[3]\n    (strides_d, strides_h, strides_w) = fargs_tests[4]\n    conv_ng = ng.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    conv_nc = nc.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    assert conv_nc.dimI == conv_ng.dimI\n    assert conv_nc.dimF == conv_ng.dimF\n    assert conv_nc.dimO == conv_ng.dimO\n    assert conv_nc.M == conv_ng.M\n    dimI = conv_ng.dimI\n    dimF = conv_ng.dimF\n    dimO = conv_ng.dimO\n    if any(np.array(dimO) <= 0):\n        return\n    cpuI = np.random.uniform(-0.8, 0.8, slicable(dimI, 1)).astype(np.float32)\n    cpuF = np.random.uniform(0.0, 0.3, slicable(dimF)).astype(np.float32)\n    cpuE = np.random.uniform(-0.2, 0.2, dimO).astype(np.float32)\n    cpuI[-1, :] = 0.0\n    beI = cpuI[:-1, :].reshape(dimI)\n    beF = cpuF.reshape(dimF)\n    beE = cpuE\n    start_gpu = default_timer()\n    (ngO, ngB, ngU) = run_backend_conv(ng, conv_ng, beI, beF, beE, dtype)\n    end_gpu = default_timer()\n    start_cpu = default_timer()\n    (ncO, ncB, ncU) = run_backend_conv(nc, conv_nc, beI, beF, beE, dtype)\n    end_cpu = default_timer()\n    neon_logger.display('gputime: %s, cputime %s' % (end_gpu - start_gpu, end_cpu - start_cpu))\n    cpuO = np.zeros(dimO, dtype=dtype)\n    cpuB = np.zeros(slicable(dimI, 1), dtype=dtype)\n    cpuU = np.zeros(slicable(dimF), dtype=dtype)\n    (D, H, W) = conv_nc.DHW\n    (T, R, S) = conv_nc.TRS\n    (M, P, Q) = conv_nc.MPQ\n    (pad_d, pad_h, pad_w) = conv_nc.padding\n    (str_d, str_h, str_w) = conv_nc.strides\n    for m in range(M):\n        mt = m * str_d - pad_d\n        for p in range(P):\n            pr = p * str_h - pad_h\n            for q in range(Q):\n                qs = q * str_w - pad_w\n                idx = pixel_indices(conv_nc, mt, pr, qs)\n                cpuO[:, m, p, q, :] = np.dot(cpuF.T, cpuI[idx, :])\n                cpuB[idx, :] += np.dot(cpuF, cpuE[:, m, p, q, :])\n                cpuU += np.dot(cpuI[idx, :], cpuE[:, m, p, q, :].T)\n    for (opA, ngA, ncA, cpuA, w) in (('fprop', ngO, ncO, cpuO, Q), ('bprop', ngB, ncB.reshape(dimI), cpuB[:-1, :].reshape(dimI), W), ('update', ngU, ncU.reshape(dimF), cpuU.reshape(dimF), S)):\n        neon_logger.display(opA)\n        ncAnp = ncA.get().astype(np.float32)\n        ngAnp = ngA.get().astype(np.float32)\n        ncdif = cpuA - ncAnp\n        ngdif = cpuA - ngAnp\n        maxval = abs(cpuA).max()\n        ncmaxdif = abs(ncdif).max()\n        ngmaxdif = abs(ngdif).max()\n        ncRatio = ncmaxdif / float(maxval)\n        ngRatio = ngmaxdif / float(maxval)\n        assert ncRatio < 1e-05\n        assert ngRatio < 1e-05\n        assert allclose_with_out(ncA.get(), cpuA, rtol=1e-05, atol=0.0001)\n        assert allclose_with_out(ngA.get(), cpuA, rtol=1e-05, atol=0.001)",
            "@pytest.mark.hasgpu\ndef test_conv_layer(fargs_tests, backend_pair):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dtype = np.float32\n    (ng, nc) = backend_pair\n    if ng.compute_capability < (5, 0):\n        pytest.skip(msg='Test requires Maxwell or higher')\n    (N, C, K) = fargs_tests[0]\n    (D, H, W) = fargs_tests[1]\n    (T, R, S) = fargs_tests[2]\n    (padding_d, padding_h, padding_w) = fargs_tests[3]\n    (strides_d, strides_h, strides_w) = fargs_tests[4]\n    conv_ng = ng.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    conv_nc = nc.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    assert conv_nc.dimI == conv_ng.dimI\n    assert conv_nc.dimF == conv_ng.dimF\n    assert conv_nc.dimO == conv_ng.dimO\n    assert conv_nc.M == conv_ng.M\n    dimI = conv_ng.dimI\n    dimF = conv_ng.dimF\n    dimO = conv_ng.dimO\n    if any(np.array(dimO) <= 0):\n        return\n    cpuI = np.random.uniform(-0.8, 0.8, slicable(dimI, 1)).astype(np.float32)\n    cpuF = np.random.uniform(0.0, 0.3, slicable(dimF)).astype(np.float32)\n    cpuE = np.random.uniform(-0.2, 0.2, dimO).astype(np.float32)\n    cpuI[-1, :] = 0.0\n    beI = cpuI[:-1, :].reshape(dimI)\n    beF = cpuF.reshape(dimF)\n    beE = cpuE\n    start_gpu = default_timer()\n    (ngO, ngB, ngU) = run_backend_conv(ng, conv_ng, beI, beF, beE, dtype)\n    end_gpu = default_timer()\n    start_cpu = default_timer()\n    (ncO, ncB, ncU) = run_backend_conv(nc, conv_nc, beI, beF, beE, dtype)\n    end_cpu = default_timer()\n    neon_logger.display('gputime: %s, cputime %s' % (end_gpu - start_gpu, end_cpu - start_cpu))\n    cpuO = np.zeros(dimO, dtype=dtype)\n    cpuB = np.zeros(slicable(dimI, 1), dtype=dtype)\n    cpuU = np.zeros(slicable(dimF), dtype=dtype)\n    (D, H, W) = conv_nc.DHW\n    (T, R, S) = conv_nc.TRS\n    (M, P, Q) = conv_nc.MPQ\n    (pad_d, pad_h, pad_w) = conv_nc.padding\n    (str_d, str_h, str_w) = conv_nc.strides\n    for m in range(M):\n        mt = m * str_d - pad_d\n        for p in range(P):\n            pr = p * str_h - pad_h\n            for q in range(Q):\n                qs = q * str_w - pad_w\n                idx = pixel_indices(conv_nc, mt, pr, qs)\n                cpuO[:, m, p, q, :] = np.dot(cpuF.T, cpuI[idx, :])\n                cpuB[idx, :] += np.dot(cpuF, cpuE[:, m, p, q, :])\n                cpuU += np.dot(cpuI[idx, :], cpuE[:, m, p, q, :].T)\n    for (opA, ngA, ncA, cpuA, w) in (('fprop', ngO, ncO, cpuO, Q), ('bprop', ngB, ncB.reshape(dimI), cpuB[:-1, :].reshape(dimI), W), ('update', ngU, ncU.reshape(dimF), cpuU.reshape(dimF), S)):\n        neon_logger.display(opA)\n        ncAnp = ncA.get().astype(np.float32)\n        ngAnp = ngA.get().astype(np.float32)\n        ncdif = cpuA - ncAnp\n        ngdif = cpuA - ngAnp\n        maxval = abs(cpuA).max()\n        ncmaxdif = abs(ncdif).max()\n        ngmaxdif = abs(ngdif).max()\n        ncRatio = ncmaxdif / float(maxval)\n        ngRatio = ngmaxdif / float(maxval)\n        assert ncRatio < 1e-05\n        assert ngRatio < 1e-05\n        assert allclose_with_out(ncA.get(), cpuA, rtol=1e-05, atol=0.0001)\n        assert allclose_with_out(ngA.get(), cpuA, rtol=1e-05, atol=0.001)",
            "@pytest.mark.hasgpu\ndef test_conv_layer(fargs_tests, backend_pair):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dtype = np.float32\n    (ng, nc) = backend_pair\n    if ng.compute_capability < (5, 0):\n        pytest.skip(msg='Test requires Maxwell or higher')\n    (N, C, K) = fargs_tests[0]\n    (D, H, W) = fargs_tests[1]\n    (T, R, S) = fargs_tests[2]\n    (padding_d, padding_h, padding_w) = fargs_tests[3]\n    (strides_d, strides_h, strides_w) = fargs_tests[4]\n    conv_ng = ng.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    conv_nc = nc.conv_layer(dtype, N, C, K, D, H, W, T, R, S, padding_d, padding_h, padding_w, strides_d, strides_h, strides_w)\n    assert conv_nc.dimI == conv_ng.dimI\n    assert conv_nc.dimF == conv_ng.dimF\n    assert conv_nc.dimO == conv_ng.dimO\n    assert conv_nc.M == conv_ng.M\n    dimI = conv_ng.dimI\n    dimF = conv_ng.dimF\n    dimO = conv_ng.dimO\n    if any(np.array(dimO) <= 0):\n        return\n    cpuI = np.random.uniform(-0.8, 0.8, slicable(dimI, 1)).astype(np.float32)\n    cpuF = np.random.uniform(0.0, 0.3, slicable(dimF)).astype(np.float32)\n    cpuE = np.random.uniform(-0.2, 0.2, dimO).astype(np.float32)\n    cpuI[-1, :] = 0.0\n    beI = cpuI[:-1, :].reshape(dimI)\n    beF = cpuF.reshape(dimF)\n    beE = cpuE\n    start_gpu = default_timer()\n    (ngO, ngB, ngU) = run_backend_conv(ng, conv_ng, beI, beF, beE, dtype)\n    end_gpu = default_timer()\n    start_cpu = default_timer()\n    (ncO, ncB, ncU) = run_backend_conv(nc, conv_nc, beI, beF, beE, dtype)\n    end_cpu = default_timer()\n    neon_logger.display('gputime: %s, cputime %s' % (end_gpu - start_gpu, end_cpu - start_cpu))\n    cpuO = np.zeros(dimO, dtype=dtype)\n    cpuB = np.zeros(slicable(dimI, 1), dtype=dtype)\n    cpuU = np.zeros(slicable(dimF), dtype=dtype)\n    (D, H, W) = conv_nc.DHW\n    (T, R, S) = conv_nc.TRS\n    (M, P, Q) = conv_nc.MPQ\n    (pad_d, pad_h, pad_w) = conv_nc.padding\n    (str_d, str_h, str_w) = conv_nc.strides\n    for m in range(M):\n        mt = m * str_d - pad_d\n        for p in range(P):\n            pr = p * str_h - pad_h\n            for q in range(Q):\n                qs = q * str_w - pad_w\n                idx = pixel_indices(conv_nc, mt, pr, qs)\n                cpuO[:, m, p, q, :] = np.dot(cpuF.T, cpuI[idx, :])\n                cpuB[idx, :] += np.dot(cpuF, cpuE[:, m, p, q, :])\n                cpuU += np.dot(cpuI[idx, :], cpuE[:, m, p, q, :].T)\n    for (opA, ngA, ncA, cpuA, w) in (('fprop', ngO, ncO, cpuO, Q), ('bprop', ngB, ncB.reshape(dimI), cpuB[:-1, :].reshape(dimI), W), ('update', ngU, ncU.reshape(dimF), cpuU.reshape(dimF), S)):\n        neon_logger.display(opA)\n        ncAnp = ncA.get().astype(np.float32)\n        ngAnp = ngA.get().astype(np.float32)\n        ncdif = cpuA - ncAnp\n        ngdif = cpuA - ngAnp\n        maxval = abs(cpuA).max()\n        ncmaxdif = abs(ncdif).max()\n        ngmaxdif = abs(ngdif).max()\n        ncRatio = ncmaxdif / float(maxval)\n        ngRatio = ngmaxdif / float(maxval)\n        assert ncRatio < 1e-05\n        assert ngRatio < 1e-05\n        assert allclose_with_out(ncA.get(), cpuA, rtol=1e-05, atol=0.0001)\n        assert allclose_with_out(ngA.get(), cpuA, rtol=1e-05, atol=0.001)"
        ]
    }
]