[
    {
        "func_name": "get_auto_step_size",
        "original": "def get_auto_step_size(max_squared_sum, alpha_scaled, loss, fit_intercept, n_samples=None, is_saga=False):\n    \"\"\"Compute automatic step size for SAG solver.\n\n    The step size is set to 1 / (alpha_scaled + L + fit_intercept) where L is\n    the max sum of squares for over all samples.\n\n    Parameters\n    ----------\n    max_squared_sum : float\n        Maximum squared sum of X over samples.\n\n    alpha_scaled : float\n        Constant that multiplies the regularization term, scaled by\n        1. / n_samples, the number of samples.\n\n    loss : {'log', 'squared', 'multinomial'}\n        The loss function used in SAG solver.\n\n    fit_intercept : bool\n        Specifies if a constant (a.k.a. bias or intercept) will be\n        added to the decision function.\n\n    n_samples : int, default=None\n        Number of rows in X. Useful if is_saga=True.\n\n    is_saga : bool, default=False\n        Whether to return step size for the SAGA algorithm or the SAG\n        algorithm.\n\n    Returns\n    -------\n    step_size : float\n        Step size used in SAG solver.\n\n    References\n    ----------\n    Schmidt, M., Roux, N. L., & Bach, F. (2013).\n    Minimizing finite sums with the stochastic average gradient\n    https://hal.inria.fr/hal-00860051/document\n\n    :arxiv:`Defazio, A., Bach F. & Lacoste-Julien S. (2014).\n    \"SAGA: A Fast Incremental Gradient Method With Support\n    for Non-Strongly Convex Composite Objectives\" <1407.0202>`\n    \"\"\"\n    if loss in ('log', 'multinomial'):\n        L = 0.25 * (max_squared_sum + int(fit_intercept)) + alpha_scaled\n    elif loss == 'squared':\n        L = max_squared_sum + int(fit_intercept) + alpha_scaled\n    else:\n        raise ValueError(\"Unknown loss function for SAG solver, got %s instead of 'log' or 'squared'\" % loss)\n    if is_saga:\n        mun = min(2 * n_samples * alpha_scaled, L)\n        step = 1.0 / (2 * L + mun)\n    else:\n        step = 1.0 / L\n    return step",
        "mutated": [
            "def get_auto_step_size(max_squared_sum, alpha_scaled, loss, fit_intercept, n_samples=None, is_saga=False):\n    if False:\n        i = 10\n    'Compute automatic step size for SAG solver.\\n\\n    The step size is set to 1 / (alpha_scaled + L + fit_intercept) where L is\\n    the max sum of squares for over all samples.\\n\\n    Parameters\\n    ----------\\n    max_squared_sum : float\\n        Maximum squared sum of X over samples.\\n\\n    alpha_scaled : float\\n        Constant that multiplies the regularization term, scaled by\\n        1. / n_samples, the number of samples.\\n\\n    loss : {\\'log\\', \\'squared\\', \\'multinomial\\'}\\n        The loss function used in SAG solver.\\n\\n    fit_intercept : bool\\n        Specifies if a constant (a.k.a. bias or intercept) will be\\n        added to the decision function.\\n\\n    n_samples : int, default=None\\n        Number of rows in X. Useful if is_saga=True.\\n\\n    is_saga : bool, default=False\\n        Whether to return step size for the SAGA algorithm or the SAG\\n        algorithm.\\n\\n    Returns\\n    -------\\n    step_size : float\\n        Step size used in SAG solver.\\n\\n    References\\n    ----------\\n    Schmidt, M., Roux, N. L., & Bach, F. (2013).\\n    Minimizing finite sums with the stochastic average gradient\\n    https://hal.inria.fr/hal-00860051/document\\n\\n    :arxiv:`Defazio, A., Bach F. & Lacoste-Julien S. (2014).\\n    \"SAGA: A Fast Incremental Gradient Method With Support\\n    for Non-Strongly Convex Composite Objectives\" <1407.0202>`\\n    '\n    if loss in ('log', 'multinomial'):\n        L = 0.25 * (max_squared_sum + int(fit_intercept)) + alpha_scaled\n    elif loss == 'squared':\n        L = max_squared_sum + int(fit_intercept) + alpha_scaled\n    else:\n        raise ValueError(\"Unknown loss function for SAG solver, got %s instead of 'log' or 'squared'\" % loss)\n    if is_saga:\n        mun = min(2 * n_samples * alpha_scaled, L)\n        step = 1.0 / (2 * L + mun)\n    else:\n        step = 1.0 / L\n    return step",
            "def get_auto_step_size(max_squared_sum, alpha_scaled, loss, fit_intercept, n_samples=None, is_saga=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute automatic step size for SAG solver.\\n\\n    The step size is set to 1 / (alpha_scaled + L + fit_intercept) where L is\\n    the max sum of squares for over all samples.\\n\\n    Parameters\\n    ----------\\n    max_squared_sum : float\\n        Maximum squared sum of X over samples.\\n\\n    alpha_scaled : float\\n        Constant that multiplies the regularization term, scaled by\\n        1. / n_samples, the number of samples.\\n\\n    loss : {\\'log\\', \\'squared\\', \\'multinomial\\'}\\n        The loss function used in SAG solver.\\n\\n    fit_intercept : bool\\n        Specifies if a constant (a.k.a. bias or intercept) will be\\n        added to the decision function.\\n\\n    n_samples : int, default=None\\n        Number of rows in X. Useful if is_saga=True.\\n\\n    is_saga : bool, default=False\\n        Whether to return step size for the SAGA algorithm or the SAG\\n        algorithm.\\n\\n    Returns\\n    -------\\n    step_size : float\\n        Step size used in SAG solver.\\n\\n    References\\n    ----------\\n    Schmidt, M., Roux, N. L., & Bach, F. (2013).\\n    Minimizing finite sums with the stochastic average gradient\\n    https://hal.inria.fr/hal-00860051/document\\n\\n    :arxiv:`Defazio, A., Bach F. & Lacoste-Julien S. (2014).\\n    \"SAGA: A Fast Incremental Gradient Method With Support\\n    for Non-Strongly Convex Composite Objectives\" <1407.0202>`\\n    '\n    if loss in ('log', 'multinomial'):\n        L = 0.25 * (max_squared_sum + int(fit_intercept)) + alpha_scaled\n    elif loss == 'squared':\n        L = max_squared_sum + int(fit_intercept) + alpha_scaled\n    else:\n        raise ValueError(\"Unknown loss function for SAG solver, got %s instead of 'log' or 'squared'\" % loss)\n    if is_saga:\n        mun = min(2 * n_samples * alpha_scaled, L)\n        step = 1.0 / (2 * L + mun)\n    else:\n        step = 1.0 / L\n    return step",
            "def get_auto_step_size(max_squared_sum, alpha_scaled, loss, fit_intercept, n_samples=None, is_saga=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute automatic step size for SAG solver.\\n\\n    The step size is set to 1 / (alpha_scaled + L + fit_intercept) where L is\\n    the max sum of squares for over all samples.\\n\\n    Parameters\\n    ----------\\n    max_squared_sum : float\\n        Maximum squared sum of X over samples.\\n\\n    alpha_scaled : float\\n        Constant that multiplies the regularization term, scaled by\\n        1. / n_samples, the number of samples.\\n\\n    loss : {\\'log\\', \\'squared\\', \\'multinomial\\'}\\n        The loss function used in SAG solver.\\n\\n    fit_intercept : bool\\n        Specifies if a constant (a.k.a. bias or intercept) will be\\n        added to the decision function.\\n\\n    n_samples : int, default=None\\n        Number of rows in X. Useful if is_saga=True.\\n\\n    is_saga : bool, default=False\\n        Whether to return step size for the SAGA algorithm or the SAG\\n        algorithm.\\n\\n    Returns\\n    -------\\n    step_size : float\\n        Step size used in SAG solver.\\n\\n    References\\n    ----------\\n    Schmidt, M., Roux, N. L., & Bach, F. (2013).\\n    Minimizing finite sums with the stochastic average gradient\\n    https://hal.inria.fr/hal-00860051/document\\n\\n    :arxiv:`Defazio, A., Bach F. & Lacoste-Julien S. (2014).\\n    \"SAGA: A Fast Incremental Gradient Method With Support\\n    for Non-Strongly Convex Composite Objectives\" <1407.0202>`\\n    '\n    if loss in ('log', 'multinomial'):\n        L = 0.25 * (max_squared_sum + int(fit_intercept)) + alpha_scaled\n    elif loss == 'squared':\n        L = max_squared_sum + int(fit_intercept) + alpha_scaled\n    else:\n        raise ValueError(\"Unknown loss function for SAG solver, got %s instead of 'log' or 'squared'\" % loss)\n    if is_saga:\n        mun = min(2 * n_samples * alpha_scaled, L)\n        step = 1.0 / (2 * L + mun)\n    else:\n        step = 1.0 / L\n    return step",
            "def get_auto_step_size(max_squared_sum, alpha_scaled, loss, fit_intercept, n_samples=None, is_saga=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute automatic step size for SAG solver.\\n\\n    The step size is set to 1 / (alpha_scaled + L + fit_intercept) where L is\\n    the max sum of squares for over all samples.\\n\\n    Parameters\\n    ----------\\n    max_squared_sum : float\\n        Maximum squared sum of X over samples.\\n\\n    alpha_scaled : float\\n        Constant that multiplies the regularization term, scaled by\\n        1. / n_samples, the number of samples.\\n\\n    loss : {\\'log\\', \\'squared\\', \\'multinomial\\'}\\n        The loss function used in SAG solver.\\n\\n    fit_intercept : bool\\n        Specifies if a constant (a.k.a. bias or intercept) will be\\n        added to the decision function.\\n\\n    n_samples : int, default=None\\n        Number of rows in X. Useful if is_saga=True.\\n\\n    is_saga : bool, default=False\\n        Whether to return step size for the SAGA algorithm or the SAG\\n        algorithm.\\n\\n    Returns\\n    -------\\n    step_size : float\\n        Step size used in SAG solver.\\n\\n    References\\n    ----------\\n    Schmidt, M., Roux, N. L., & Bach, F. (2013).\\n    Minimizing finite sums with the stochastic average gradient\\n    https://hal.inria.fr/hal-00860051/document\\n\\n    :arxiv:`Defazio, A., Bach F. & Lacoste-Julien S. (2014).\\n    \"SAGA: A Fast Incremental Gradient Method With Support\\n    for Non-Strongly Convex Composite Objectives\" <1407.0202>`\\n    '\n    if loss in ('log', 'multinomial'):\n        L = 0.25 * (max_squared_sum + int(fit_intercept)) + alpha_scaled\n    elif loss == 'squared':\n        L = max_squared_sum + int(fit_intercept) + alpha_scaled\n    else:\n        raise ValueError(\"Unknown loss function for SAG solver, got %s instead of 'log' or 'squared'\" % loss)\n    if is_saga:\n        mun = min(2 * n_samples * alpha_scaled, L)\n        step = 1.0 / (2 * L + mun)\n    else:\n        step = 1.0 / L\n    return step",
            "def get_auto_step_size(max_squared_sum, alpha_scaled, loss, fit_intercept, n_samples=None, is_saga=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute automatic step size for SAG solver.\\n\\n    The step size is set to 1 / (alpha_scaled + L + fit_intercept) where L is\\n    the max sum of squares for over all samples.\\n\\n    Parameters\\n    ----------\\n    max_squared_sum : float\\n        Maximum squared sum of X over samples.\\n\\n    alpha_scaled : float\\n        Constant that multiplies the regularization term, scaled by\\n        1. / n_samples, the number of samples.\\n\\n    loss : {\\'log\\', \\'squared\\', \\'multinomial\\'}\\n        The loss function used in SAG solver.\\n\\n    fit_intercept : bool\\n        Specifies if a constant (a.k.a. bias or intercept) will be\\n        added to the decision function.\\n\\n    n_samples : int, default=None\\n        Number of rows in X. Useful if is_saga=True.\\n\\n    is_saga : bool, default=False\\n        Whether to return step size for the SAGA algorithm or the SAG\\n        algorithm.\\n\\n    Returns\\n    -------\\n    step_size : float\\n        Step size used in SAG solver.\\n\\n    References\\n    ----------\\n    Schmidt, M., Roux, N. L., & Bach, F. (2013).\\n    Minimizing finite sums with the stochastic average gradient\\n    https://hal.inria.fr/hal-00860051/document\\n\\n    :arxiv:`Defazio, A., Bach F. & Lacoste-Julien S. (2014).\\n    \"SAGA: A Fast Incremental Gradient Method With Support\\n    for Non-Strongly Convex Composite Objectives\" <1407.0202>`\\n    '\n    if loss in ('log', 'multinomial'):\n        L = 0.25 * (max_squared_sum + int(fit_intercept)) + alpha_scaled\n    elif loss == 'squared':\n        L = max_squared_sum + int(fit_intercept) + alpha_scaled\n    else:\n        raise ValueError(\"Unknown loss function for SAG solver, got %s instead of 'log' or 'squared'\" % loss)\n    if is_saga:\n        mun = min(2 * n_samples * alpha_scaled, L)\n        step = 1.0 / (2 * L + mun)\n    else:\n        step = 1.0 / L\n    return step"
        ]
    },
    {
        "func_name": "sag_solver",
        "original": "def sag_solver(X, y, sample_weight=None, loss='log', alpha=1.0, beta=0.0, max_iter=1000, tol=0.001, verbose=0, random_state=None, check_input=True, max_squared_sum=None, warm_start_mem=None, is_saga=False):\n    \"\"\"SAG solver for Ridge and LogisticRegression.\n\n    SAG stands for Stochastic Average Gradient: the gradient of the loss is\n    estimated each sample at a time and the model is updated along the way with\n    a constant learning rate.\n\n    IMPORTANT NOTE: 'sag' solver converges faster on columns that are on the\n    same scale. You can normalize the data by using\n    sklearn.preprocessing.StandardScaler on your data before passing it to the\n    fit method.\n\n    This implementation works with data represented as dense numpy arrays or\n    sparse scipy arrays of floating point values for the features. It will\n    fit the data according to squared loss or log loss.\n\n    The regularizer is a penalty added to the loss function that shrinks model\n    parameters towards the zero vector using the squared euclidean norm L2.\n\n    .. versionadded:: 0.17\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\n        Training data.\n\n    y : ndarray of shape (n_samples,)\n        Target values. With loss='multinomial', y must be label encoded\n        (see preprocessing.LabelEncoder).\n\n    sample_weight : array-like of shape (n_samples,), default=None\n        Weights applied to individual samples (1. for unweighted).\n\n    loss : {'log', 'squared', 'multinomial'}, default='log'\n        Loss function that will be optimized:\n        -'log' is the binary logistic loss, as used in LogisticRegression.\n        -'squared' is the squared loss, as used in Ridge.\n        -'multinomial' is the multinomial logistic loss, as used in\n         LogisticRegression.\n\n        .. versionadded:: 0.18\n           *loss='multinomial'*\n\n    alpha : float, default=1.\n        L2 regularization term in the objective function\n        ``(0.5 * alpha * || W ||_F^2)``.\n\n    beta : float, default=0.\n        L1 regularization term in the objective function\n        ``(beta * || W ||_1)``. Only applied if ``is_saga`` is set to True.\n\n    max_iter : int, default=1000\n        The max number of passes over the training data if the stopping\n        criteria is not reached.\n\n    tol : float, default=0.001\n        The stopping criteria for the weights. The iterations will stop when\n        max(change in weights) / max(weights) < tol.\n\n    verbose : int, default=0\n        The verbosity level.\n\n    random_state : int, RandomState instance or None, default=None\n        Used when shuffling the data. Pass an int for reproducible output\n        across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    check_input : bool, default=True\n        If False, the input arrays X and y will not be checked.\n\n    max_squared_sum : float, default=None\n        Maximum squared sum of X over samples. If None, it will be computed,\n        going through all the samples. The value should be precomputed\n        to speed up cross validation.\n\n    warm_start_mem : dict, default=None\n        The initialization parameters used for warm starting. Warm starting is\n        currently used in LogisticRegression but not in Ridge.\n        It contains:\n            - 'coef': the weight vector, with the intercept in last line\n                if the intercept is fitted.\n            - 'gradient_memory': the scalar gradient for all seen samples.\n            - 'sum_gradient': the sum of gradient over all seen samples,\n                for each feature.\n            - 'intercept_sum_gradient': the sum of gradient over all seen\n                samples, for the intercept.\n            - 'seen': array of boolean describing the seen samples.\n            - 'num_seen': the number of seen samples.\n\n    is_saga : bool, default=False\n        Whether to use the SAGA algorithm or the SAG algorithm. SAGA behaves\n        better in the first epochs, and allow for l1 regularisation.\n\n    Returns\n    -------\n    coef_ : ndarray of shape (n_features,)\n        Weight vector.\n\n    n_iter_ : int\n        The number of full pass on all samples.\n\n    warm_start_mem : dict\n        Contains a 'coef' key with the fitted result, and possibly the\n        fitted intercept at the end of the array. Contains also other keys\n        used for warm starting.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn import linear_model\n    >>> n_samples, n_features = 10, 5\n    >>> rng = np.random.RandomState(0)\n    >>> X = rng.randn(n_samples, n_features)\n    >>> y = rng.randn(n_samples)\n    >>> clf = linear_model.Ridge(solver='sag')\n    >>> clf.fit(X, y)\n    Ridge(solver='sag')\n\n    >>> X = np.array([[-1, -1], [-2, -1], [1, 1], [2, 1]])\n    >>> y = np.array([1, 1, 2, 2])\n    >>> clf = linear_model.LogisticRegression(\n    ...     solver='sag', multi_class='multinomial')\n    >>> clf.fit(X, y)\n    LogisticRegression(multi_class='multinomial', solver='sag')\n\n    References\n    ----------\n    Schmidt, M., Roux, N. L., & Bach, F. (2013).\n    Minimizing finite sums with the stochastic average gradient\n    https://hal.inria.fr/hal-00860051/document\n\n    :arxiv:`Defazio, A., Bach F. & Lacoste-Julien S. (2014).\n    \"SAGA: A Fast Incremental Gradient Method With Support\n    for Non-Strongly Convex Composite Objectives\" <1407.0202>`\n\n    See Also\n    --------\n    Ridge, SGDRegressor, ElasticNet, Lasso, SVR,\n    LogisticRegression, SGDClassifier, LinearSVC, Perceptron\n    \"\"\"\n    if warm_start_mem is None:\n        warm_start_mem = {}\n    if max_iter is None:\n        max_iter = 1000\n    if check_input:\n        _dtype = [np.float64, np.float32]\n        X = check_array(X, dtype=_dtype, accept_sparse='csr', order='C')\n        y = check_array(y, dtype=_dtype, ensure_2d=False, order='C')\n    (n_samples, n_features) = (X.shape[0], X.shape[1])\n    alpha_scaled = float(alpha) / n_samples\n    beta_scaled = float(beta) / n_samples\n    n_classes = int(y.max()) + 1 if loss == 'multinomial' else 1\n    sample_weight = _check_sample_weight(sample_weight, X, dtype=X.dtype)\n    if 'coef' in warm_start_mem.keys():\n        coef_init = warm_start_mem['coef']\n    else:\n        coef_init = np.zeros((n_features, n_classes), dtype=X.dtype, order='C')\n    fit_intercept = coef_init.shape[0] == n_features + 1\n    if fit_intercept:\n        intercept_init = coef_init[-1, :]\n        coef_init = coef_init[:-1, :]\n    else:\n        intercept_init = np.zeros(n_classes, dtype=X.dtype)\n    if 'intercept_sum_gradient' in warm_start_mem.keys():\n        intercept_sum_gradient = warm_start_mem['intercept_sum_gradient']\n    else:\n        intercept_sum_gradient = np.zeros(n_classes, dtype=X.dtype)\n    if 'gradient_memory' in warm_start_mem.keys():\n        gradient_memory_init = warm_start_mem['gradient_memory']\n    else:\n        gradient_memory_init = np.zeros((n_samples, n_classes), dtype=X.dtype, order='C')\n    if 'sum_gradient' in warm_start_mem.keys():\n        sum_gradient_init = warm_start_mem['sum_gradient']\n    else:\n        sum_gradient_init = np.zeros((n_features, n_classes), dtype=X.dtype, order='C')\n    if 'seen' in warm_start_mem.keys():\n        seen_init = warm_start_mem['seen']\n    else:\n        seen_init = np.zeros(n_samples, dtype=np.int32, order='C')\n    if 'num_seen' in warm_start_mem.keys():\n        num_seen_init = warm_start_mem['num_seen']\n    else:\n        num_seen_init = 0\n    (dataset, intercept_decay) = make_dataset(X, y, sample_weight, random_state)\n    if max_squared_sum is None:\n        max_squared_sum = row_norms(X, squared=True).max()\n    step_size = get_auto_step_size(max_squared_sum, alpha_scaled, loss, fit_intercept, n_samples=n_samples, is_saga=is_saga)\n    if step_size * alpha_scaled == 1:\n        raise ZeroDivisionError('Current sag implementation does not handle the case step_size * alpha_scaled == 1')\n    sag = sag64 if X.dtype == np.float64 else sag32\n    (num_seen, n_iter_) = sag(dataset, coef_init, intercept_init, n_samples, n_features, n_classes, tol, max_iter, loss, step_size, alpha_scaled, beta_scaled, sum_gradient_init, gradient_memory_init, seen_init, num_seen_init, fit_intercept, intercept_sum_gradient, intercept_decay, is_saga, verbose)\n    if n_iter_ == max_iter:\n        warnings.warn('The max_iter was reached which means the coef_ did not converge', ConvergenceWarning)\n    if fit_intercept:\n        coef_init = np.vstack((coef_init, intercept_init))\n    warm_start_mem = {'coef': coef_init, 'sum_gradient': sum_gradient_init, 'intercept_sum_gradient': intercept_sum_gradient, 'gradient_memory': gradient_memory_init, 'seen': seen_init, 'num_seen': num_seen}\n    if loss == 'multinomial':\n        coef_ = coef_init.T\n    else:\n        coef_ = coef_init[:, 0]\n    return (coef_, n_iter_, warm_start_mem)",
        "mutated": [
            "def sag_solver(X, y, sample_weight=None, loss='log', alpha=1.0, beta=0.0, max_iter=1000, tol=0.001, verbose=0, random_state=None, check_input=True, max_squared_sum=None, warm_start_mem=None, is_saga=False):\n    if False:\n        i = 10\n    'SAG solver for Ridge and LogisticRegression.\\n\\n    SAG stands for Stochastic Average Gradient: the gradient of the loss is\\n    estimated each sample at a time and the model is updated along the way with\\n    a constant learning rate.\\n\\n    IMPORTANT NOTE: \\'sag\\' solver converges faster on columns that are on the\\n    same scale. You can normalize the data by using\\n    sklearn.preprocessing.StandardScaler on your data before passing it to the\\n    fit method.\\n\\n    This implementation works with data represented as dense numpy arrays or\\n    sparse scipy arrays of floating point values for the features. It will\\n    fit the data according to squared loss or log loss.\\n\\n    The regularizer is a penalty added to the loss function that shrinks model\\n    parameters towards the zero vector using the squared euclidean norm L2.\\n\\n    .. versionadded:: 0.17\\n\\n    Parameters\\n    ----------\\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\\n        Training data.\\n\\n    y : ndarray of shape (n_samples,)\\n        Target values. With loss=\\'multinomial\\', y must be label encoded\\n        (see preprocessing.LabelEncoder).\\n\\n    sample_weight : array-like of shape (n_samples,), default=None\\n        Weights applied to individual samples (1. for unweighted).\\n\\n    loss : {\\'log\\', \\'squared\\', \\'multinomial\\'}, default=\\'log\\'\\n        Loss function that will be optimized:\\n        -\\'log\\' is the binary logistic loss, as used in LogisticRegression.\\n        -\\'squared\\' is the squared loss, as used in Ridge.\\n        -\\'multinomial\\' is the multinomial logistic loss, as used in\\n         LogisticRegression.\\n\\n        .. versionadded:: 0.18\\n           *loss=\\'multinomial\\'*\\n\\n    alpha : float, default=1.\\n        L2 regularization term in the objective function\\n        ``(0.5 * alpha * || W ||_F^2)``.\\n\\n    beta : float, default=0.\\n        L1 regularization term in the objective function\\n        ``(beta * || W ||_1)``. Only applied if ``is_saga`` is set to True.\\n\\n    max_iter : int, default=1000\\n        The max number of passes over the training data if the stopping\\n        criteria is not reached.\\n\\n    tol : float, default=0.001\\n        The stopping criteria for the weights. The iterations will stop when\\n        max(change in weights) / max(weights) < tol.\\n\\n    verbose : int, default=0\\n        The verbosity level.\\n\\n    random_state : int, RandomState instance or None, default=None\\n        Used when shuffling the data. Pass an int for reproducible output\\n        across multiple function calls.\\n        See :term:`Glossary <random_state>`.\\n\\n    check_input : bool, default=True\\n        If False, the input arrays X and y will not be checked.\\n\\n    max_squared_sum : float, default=None\\n        Maximum squared sum of X over samples. If None, it will be computed,\\n        going through all the samples. The value should be precomputed\\n        to speed up cross validation.\\n\\n    warm_start_mem : dict, default=None\\n        The initialization parameters used for warm starting. Warm starting is\\n        currently used in LogisticRegression but not in Ridge.\\n        It contains:\\n            - \\'coef\\': the weight vector, with the intercept in last line\\n                if the intercept is fitted.\\n            - \\'gradient_memory\\': the scalar gradient for all seen samples.\\n            - \\'sum_gradient\\': the sum of gradient over all seen samples,\\n                for each feature.\\n            - \\'intercept_sum_gradient\\': the sum of gradient over all seen\\n                samples, for the intercept.\\n            - \\'seen\\': array of boolean describing the seen samples.\\n            - \\'num_seen\\': the number of seen samples.\\n\\n    is_saga : bool, default=False\\n        Whether to use the SAGA algorithm or the SAG algorithm. SAGA behaves\\n        better in the first epochs, and allow for l1 regularisation.\\n\\n    Returns\\n    -------\\n    coef_ : ndarray of shape (n_features,)\\n        Weight vector.\\n\\n    n_iter_ : int\\n        The number of full pass on all samples.\\n\\n    warm_start_mem : dict\\n        Contains a \\'coef\\' key with the fitted result, and possibly the\\n        fitted intercept at the end of the array. Contains also other keys\\n        used for warm starting.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from sklearn import linear_model\\n    >>> n_samples, n_features = 10, 5\\n    >>> rng = np.random.RandomState(0)\\n    >>> X = rng.randn(n_samples, n_features)\\n    >>> y = rng.randn(n_samples)\\n    >>> clf = linear_model.Ridge(solver=\\'sag\\')\\n    >>> clf.fit(X, y)\\n    Ridge(solver=\\'sag\\')\\n\\n    >>> X = np.array([[-1, -1], [-2, -1], [1, 1], [2, 1]])\\n    >>> y = np.array([1, 1, 2, 2])\\n    >>> clf = linear_model.LogisticRegression(\\n    ...     solver=\\'sag\\', multi_class=\\'multinomial\\')\\n    >>> clf.fit(X, y)\\n    LogisticRegression(multi_class=\\'multinomial\\', solver=\\'sag\\')\\n\\n    References\\n    ----------\\n    Schmidt, M., Roux, N. L., & Bach, F. (2013).\\n    Minimizing finite sums with the stochastic average gradient\\n    https://hal.inria.fr/hal-00860051/document\\n\\n    :arxiv:`Defazio, A., Bach F. & Lacoste-Julien S. (2014).\\n    \"SAGA: A Fast Incremental Gradient Method With Support\\n    for Non-Strongly Convex Composite Objectives\" <1407.0202>`\\n\\n    See Also\\n    --------\\n    Ridge, SGDRegressor, ElasticNet, Lasso, SVR,\\n    LogisticRegression, SGDClassifier, LinearSVC, Perceptron\\n    '\n    if warm_start_mem is None:\n        warm_start_mem = {}\n    if max_iter is None:\n        max_iter = 1000\n    if check_input:\n        _dtype = [np.float64, np.float32]\n        X = check_array(X, dtype=_dtype, accept_sparse='csr', order='C')\n        y = check_array(y, dtype=_dtype, ensure_2d=False, order='C')\n    (n_samples, n_features) = (X.shape[0], X.shape[1])\n    alpha_scaled = float(alpha) / n_samples\n    beta_scaled = float(beta) / n_samples\n    n_classes = int(y.max()) + 1 if loss == 'multinomial' else 1\n    sample_weight = _check_sample_weight(sample_weight, X, dtype=X.dtype)\n    if 'coef' in warm_start_mem.keys():\n        coef_init = warm_start_mem['coef']\n    else:\n        coef_init = np.zeros((n_features, n_classes), dtype=X.dtype, order='C')\n    fit_intercept = coef_init.shape[0] == n_features + 1\n    if fit_intercept:\n        intercept_init = coef_init[-1, :]\n        coef_init = coef_init[:-1, :]\n    else:\n        intercept_init = np.zeros(n_classes, dtype=X.dtype)\n    if 'intercept_sum_gradient' in warm_start_mem.keys():\n        intercept_sum_gradient = warm_start_mem['intercept_sum_gradient']\n    else:\n        intercept_sum_gradient = np.zeros(n_classes, dtype=X.dtype)\n    if 'gradient_memory' in warm_start_mem.keys():\n        gradient_memory_init = warm_start_mem['gradient_memory']\n    else:\n        gradient_memory_init = np.zeros((n_samples, n_classes), dtype=X.dtype, order='C')\n    if 'sum_gradient' in warm_start_mem.keys():\n        sum_gradient_init = warm_start_mem['sum_gradient']\n    else:\n        sum_gradient_init = np.zeros((n_features, n_classes), dtype=X.dtype, order='C')\n    if 'seen' in warm_start_mem.keys():\n        seen_init = warm_start_mem['seen']\n    else:\n        seen_init = np.zeros(n_samples, dtype=np.int32, order='C')\n    if 'num_seen' in warm_start_mem.keys():\n        num_seen_init = warm_start_mem['num_seen']\n    else:\n        num_seen_init = 0\n    (dataset, intercept_decay) = make_dataset(X, y, sample_weight, random_state)\n    if max_squared_sum is None:\n        max_squared_sum = row_norms(X, squared=True).max()\n    step_size = get_auto_step_size(max_squared_sum, alpha_scaled, loss, fit_intercept, n_samples=n_samples, is_saga=is_saga)\n    if step_size * alpha_scaled == 1:\n        raise ZeroDivisionError('Current sag implementation does not handle the case step_size * alpha_scaled == 1')\n    sag = sag64 if X.dtype == np.float64 else sag32\n    (num_seen, n_iter_) = sag(dataset, coef_init, intercept_init, n_samples, n_features, n_classes, tol, max_iter, loss, step_size, alpha_scaled, beta_scaled, sum_gradient_init, gradient_memory_init, seen_init, num_seen_init, fit_intercept, intercept_sum_gradient, intercept_decay, is_saga, verbose)\n    if n_iter_ == max_iter:\n        warnings.warn('The max_iter was reached which means the coef_ did not converge', ConvergenceWarning)\n    if fit_intercept:\n        coef_init = np.vstack((coef_init, intercept_init))\n    warm_start_mem = {'coef': coef_init, 'sum_gradient': sum_gradient_init, 'intercept_sum_gradient': intercept_sum_gradient, 'gradient_memory': gradient_memory_init, 'seen': seen_init, 'num_seen': num_seen}\n    if loss == 'multinomial':\n        coef_ = coef_init.T\n    else:\n        coef_ = coef_init[:, 0]\n    return (coef_, n_iter_, warm_start_mem)",
            "def sag_solver(X, y, sample_weight=None, loss='log', alpha=1.0, beta=0.0, max_iter=1000, tol=0.001, verbose=0, random_state=None, check_input=True, max_squared_sum=None, warm_start_mem=None, is_saga=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'SAG solver for Ridge and LogisticRegression.\\n\\n    SAG stands for Stochastic Average Gradient: the gradient of the loss is\\n    estimated each sample at a time and the model is updated along the way with\\n    a constant learning rate.\\n\\n    IMPORTANT NOTE: \\'sag\\' solver converges faster on columns that are on the\\n    same scale. You can normalize the data by using\\n    sklearn.preprocessing.StandardScaler on your data before passing it to the\\n    fit method.\\n\\n    This implementation works with data represented as dense numpy arrays or\\n    sparse scipy arrays of floating point values for the features. It will\\n    fit the data according to squared loss or log loss.\\n\\n    The regularizer is a penalty added to the loss function that shrinks model\\n    parameters towards the zero vector using the squared euclidean norm L2.\\n\\n    .. versionadded:: 0.17\\n\\n    Parameters\\n    ----------\\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\\n        Training data.\\n\\n    y : ndarray of shape (n_samples,)\\n        Target values. With loss=\\'multinomial\\', y must be label encoded\\n        (see preprocessing.LabelEncoder).\\n\\n    sample_weight : array-like of shape (n_samples,), default=None\\n        Weights applied to individual samples (1. for unweighted).\\n\\n    loss : {\\'log\\', \\'squared\\', \\'multinomial\\'}, default=\\'log\\'\\n        Loss function that will be optimized:\\n        -\\'log\\' is the binary logistic loss, as used in LogisticRegression.\\n        -\\'squared\\' is the squared loss, as used in Ridge.\\n        -\\'multinomial\\' is the multinomial logistic loss, as used in\\n         LogisticRegression.\\n\\n        .. versionadded:: 0.18\\n           *loss=\\'multinomial\\'*\\n\\n    alpha : float, default=1.\\n        L2 regularization term in the objective function\\n        ``(0.5 * alpha * || W ||_F^2)``.\\n\\n    beta : float, default=0.\\n        L1 regularization term in the objective function\\n        ``(beta * || W ||_1)``. Only applied if ``is_saga`` is set to True.\\n\\n    max_iter : int, default=1000\\n        The max number of passes over the training data if the stopping\\n        criteria is not reached.\\n\\n    tol : float, default=0.001\\n        The stopping criteria for the weights. The iterations will stop when\\n        max(change in weights) / max(weights) < tol.\\n\\n    verbose : int, default=0\\n        The verbosity level.\\n\\n    random_state : int, RandomState instance or None, default=None\\n        Used when shuffling the data. Pass an int for reproducible output\\n        across multiple function calls.\\n        See :term:`Glossary <random_state>`.\\n\\n    check_input : bool, default=True\\n        If False, the input arrays X and y will not be checked.\\n\\n    max_squared_sum : float, default=None\\n        Maximum squared sum of X over samples. If None, it will be computed,\\n        going through all the samples. The value should be precomputed\\n        to speed up cross validation.\\n\\n    warm_start_mem : dict, default=None\\n        The initialization parameters used for warm starting. Warm starting is\\n        currently used in LogisticRegression but not in Ridge.\\n        It contains:\\n            - \\'coef\\': the weight vector, with the intercept in last line\\n                if the intercept is fitted.\\n            - \\'gradient_memory\\': the scalar gradient for all seen samples.\\n            - \\'sum_gradient\\': the sum of gradient over all seen samples,\\n                for each feature.\\n            - \\'intercept_sum_gradient\\': the sum of gradient over all seen\\n                samples, for the intercept.\\n            - \\'seen\\': array of boolean describing the seen samples.\\n            - \\'num_seen\\': the number of seen samples.\\n\\n    is_saga : bool, default=False\\n        Whether to use the SAGA algorithm or the SAG algorithm. SAGA behaves\\n        better in the first epochs, and allow for l1 regularisation.\\n\\n    Returns\\n    -------\\n    coef_ : ndarray of shape (n_features,)\\n        Weight vector.\\n\\n    n_iter_ : int\\n        The number of full pass on all samples.\\n\\n    warm_start_mem : dict\\n        Contains a \\'coef\\' key with the fitted result, and possibly the\\n        fitted intercept at the end of the array. Contains also other keys\\n        used for warm starting.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from sklearn import linear_model\\n    >>> n_samples, n_features = 10, 5\\n    >>> rng = np.random.RandomState(0)\\n    >>> X = rng.randn(n_samples, n_features)\\n    >>> y = rng.randn(n_samples)\\n    >>> clf = linear_model.Ridge(solver=\\'sag\\')\\n    >>> clf.fit(X, y)\\n    Ridge(solver=\\'sag\\')\\n\\n    >>> X = np.array([[-1, -1], [-2, -1], [1, 1], [2, 1]])\\n    >>> y = np.array([1, 1, 2, 2])\\n    >>> clf = linear_model.LogisticRegression(\\n    ...     solver=\\'sag\\', multi_class=\\'multinomial\\')\\n    >>> clf.fit(X, y)\\n    LogisticRegression(multi_class=\\'multinomial\\', solver=\\'sag\\')\\n\\n    References\\n    ----------\\n    Schmidt, M., Roux, N. L., & Bach, F. (2013).\\n    Minimizing finite sums with the stochastic average gradient\\n    https://hal.inria.fr/hal-00860051/document\\n\\n    :arxiv:`Defazio, A., Bach F. & Lacoste-Julien S. (2014).\\n    \"SAGA: A Fast Incremental Gradient Method With Support\\n    for Non-Strongly Convex Composite Objectives\" <1407.0202>`\\n\\n    See Also\\n    --------\\n    Ridge, SGDRegressor, ElasticNet, Lasso, SVR,\\n    LogisticRegression, SGDClassifier, LinearSVC, Perceptron\\n    '\n    if warm_start_mem is None:\n        warm_start_mem = {}\n    if max_iter is None:\n        max_iter = 1000\n    if check_input:\n        _dtype = [np.float64, np.float32]\n        X = check_array(X, dtype=_dtype, accept_sparse='csr', order='C')\n        y = check_array(y, dtype=_dtype, ensure_2d=False, order='C')\n    (n_samples, n_features) = (X.shape[0], X.shape[1])\n    alpha_scaled = float(alpha) / n_samples\n    beta_scaled = float(beta) / n_samples\n    n_classes = int(y.max()) + 1 if loss == 'multinomial' else 1\n    sample_weight = _check_sample_weight(sample_weight, X, dtype=X.dtype)\n    if 'coef' in warm_start_mem.keys():\n        coef_init = warm_start_mem['coef']\n    else:\n        coef_init = np.zeros((n_features, n_classes), dtype=X.dtype, order='C')\n    fit_intercept = coef_init.shape[0] == n_features + 1\n    if fit_intercept:\n        intercept_init = coef_init[-1, :]\n        coef_init = coef_init[:-1, :]\n    else:\n        intercept_init = np.zeros(n_classes, dtype=X.dtype)\n    if 'intercept_sum_gradient' in warm_start_mem.keys():\n        intercept_sum_gradient = warm_start_mem['intercept_sum_gradient']\n    else:\n        intercept_sum_gradient = np.zeros(n_classes, dtype=X.dtype)\n    if 'gradient_memory' in warm_start_mem.keys():\n        gradient_memory_init = warm_start_mem['gradient_memory']\n    else:\n        gradient_memory_init = np.zeros((n_samples, n_classes), dtype=X.dtype, order='C')\n    if 'sum_gradient' in warm_start_mem.keys():\n        sum_gradient_init = warm_start_mem['sum_gradient']\n    else:\n        sum_gradient_init = np.zeros((n_features, n_classes), dtype=X.dtype, order='C')\n    if 'seen' in warm_start_mem.keys():\n        seen_init = warm_start_mem['seen']\n    else:\n        seen_init = np.zeros(n_samples, dtype=np.int32, order='C')\n    if 'num_seen' in warm_start_mem.keys():\n        num_seen_init = warm_start_mem['num_seen']\n    else:\n        num_seen_init = 0\n    (dataset, intercept_decay) = make_dataset(X, y, sample_weight, random_state)\n    if max_squared_sum is None:\n        max_squared_sum = row_norms(X, squared=True).max()\n    step_size = get_auto_step_size(max_squared_sum, alpha_scaled, loss, fit_intercept, n_samples=n_samples, is_saga=is_saga)\n    if step_size * alpha_scaled == 1:\n        raise ZeroDivisionError('Current sag implementation does not handle the case step_size * alpha_scaled == 1')\n    sag = sag64 if X.dtype == np.float64 else sag32\n    (num_seen, n_iter_) = sag(dataset, coef_init, intercept_init, n_samples, n_features, n_classes, tol, max_iter, loss, step_size, alpha_scaled, beta_scaled, sum_gradient_init, gradient_memory_init, seen_init, num_seen_init, fit_intercept, intercept_sum_gradient, intercept_decay, is_saga, verbose)\n    if n_iter_ == max_iter:\n        warnings.warn('The max_iter was reached which means the coef_ did not converge', ConvergenceWarning)\n    if fit_intercept:\n        coef_init = np.vstack((coef_init, intercept_init))\n    warm_start_mem = {'coef': coef_init, 'sum_gradient': sum_gradient_init, 'intercept_sum_gradient': intercept_sum_gradient, 'gradient_memory': gradient_memory_init, 'seen': seen_init, 'num_seen': num_seen}\n    if loss == 'multinomial':\n        coef_ = coef_init.T\n    else:\n        coef_ = coef_init[:, 0]\n    return (coef_, n_iter_, warm_start_mem)",
            "def sag_solver(X, y, sample_weight=None, loss='log', alpha=1.0, beta=0.0, max_iter=1000, tol=0.001, verbose=0, random_state=None, check_input=True, max_squared_sum=None, warm_start_mem=None, is_saga=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'SAG solver for Ridge and LogisticRegression.\\n\\n    SAG stands for Stochastic Average Gradient: the gradient of the loss is\\n    estimated each sample at a time and the model is updated along the way with\\n    a constant learning rate.\\n\\n    IMPORTANT NOTE: \\'sag\\' solver converges faster on columns that are on the\\n    same scale. You can normalize the data by using\\n    sklearn.preprocessing.StandardScaler on your data before passing it to the\\n    fit method.\\n\\n    This implementation works with data represented as dense numpy arrays or\\n    sparse scipy arrays of floating point values for the features. It will\\n    fit the data according to squared loss or log loss.\\n\\n    The regularizer is a penalty added to the loss function that shrinks model\\n    parameters towards the zero vector using the squared euclidean norm L2.\\n\\n    .. versionadded:: 0.17\\n\\n    Parameters\\n    ----------\\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\\n        Training data.\\n\\n    y : ndarray of shape (n_samples,)\\n        Target values. With loss=\\'multinomial\\', y must be label encoded\\n        (see preprocessing.LabelEncoder).\\n\\n    sample_weight : array-like of shape (n_samples,), default=None\\n        Weights applied to individual samples (1. for unweighted).\\n\\n    loss : {\\'log\\', \\'squared\\', \\'multinomial\\'}, default=\\'log\\'\\n        Loss function that will be optimized:\\n        -\\'log\\' is the binary logistic loss, as used in LogisticRegression.\\n        -\\'squared\\' is the squared loss, as used in Ridge.\\n        -\\'multinomial\\' is the multinomial logistic loss, as used in\\n         LogisticRegression.\\n\\n        .. versionadded:: 0.18\\n           *loss=\\'multinomial\\'*\\n\\n    alpha : float, default=1.\\n        L2 regularization term in the objective function\\n        ``(0.5 * alpha * || W ||_F^2)``.\\n\\n    beta : float, default=0.\\n        L1 regularization term in the objective function\\n        ``(beta * || W ||_1)``. Only applied if ``is_saga`` is set to True.\\n\\n    max_iter : int, default=1000\\n        The max number of passes over the training data if the stopping\\n        criteria is not reached.\\n\\n    tol : float, default=0.001\\n        The stopping criteria for the weights. The iterations will stop when\\n        max(change in weights) / max(weights) < tol.\\n\\n    verbose : int, default=0\\n        The verbosity level.\\n\\n    random_state : int, RandomState instance or None, default=None\\n        Used when shuffling the data. Pass an int for reproducible output\\n        across multiple function calls.\\n        See :term:`Glossary <random_state>`.\\n\\n    check_input : bool, default=True\\n        If False, the input arrays X and y will not be checked.\\n\\n    max_squared_sum : float, default=None\\n        Maximum squared sum of X over samples. If None, it will be computed,\\n        going through all the samples. The value should be precomputed\\n        to speed up cross validation.\\n\\n    warm_start_mem : dict, default=None\\n        The initialization parameters used for warm starting. Warm starting is\\n        currently used in LogisticRegression but not in Ridge.\\n        It contains:\\n            - \\'coef\\': the weight vector, with the intercept in last line\\n                if the intercept is fitted.\\n            - \\'gradient_memory\\': the scalar gradient for all seen samples.\\n            - \\'sum_gradient\\': the sum of gradient over all seen samples,\\n                for each feature.\\n            - \\'intercept_sum_gradient\\': the sum of gradient over all seen\\n                samples, for the intercept.\\n            - \\'seen\\': array of boolean describing the seen samples.\\n            - \\'num_seen\\': the number of seen samples.\\n\\n    is_saga : bool, default=False\\n        Whether to use the SAGA algorithm or the SAG algorithm. SAGA behaves\\n        better in the first epochs, and allow for l1 regularisation.\\n\\n    Returns\\n    -------\\n    coef_ : ndarray of shape (n_features,)\\n        Weight vector.\\n\\n    n_iter_ : int\\n        The number of full pass on all samples.\\n\\n    warm_start_mem : dict\\n        Contains a \\'coef\\' key with the fitted result, and possibly the\\n        fitted intercept at the end of the array. Contains also other keys\\n        used for warm starting.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from sklearn import linear_model\\n    >>> n_samples, n_features = 10, 5\\n    >>> rng = np.random.RandomState(0)\\n    >>> X = rng.randn(n_samples, n_features)\\n    >>> y = rng.randn(n_samples)\\n    >>> clf = linear_model.Ridge(solver=\\'sag\\')\\n    >>> clf.fit(X, y)\\n    Ridge(solver=\\'sag\\')\\n\\n    >>> X = np.array([[-1, -1], [-2, -1], [1, 1], [2, 1]])\\n    >>> y = np.array([1, 1, 2, 2])\\n    >>> clf = linear_model.LogisticRegression(\\n    ...     solver=\\'sag\\', multi_class=\\'multinomial\\')\\n    >>> clf.fit(X, y)\\n    LogisticRegression(multi_class=\\'multinomial\\', solver=\\'sag\\')\\n\\n    References\\n    ----------\\n    Schmidt, M., Roux, N. L., & Bach, F. (2013).\\n    Minimizing finite sums with the stochastic average gradient\\n    https://hal.inria.fr/hal-00860051/document\\n\\n    :arxiv:`Defazio, A., Bach F. & Lacoste-Julien S. (2014).\\n    \"SAGA: A Fast Incremental Gradient Method With Support\\n    for Non-Strongly Convex Composite Objectives\" <1407.0202>`\\n\\n    See Also\\n    --------\\n    Ridge, SGDRegressor, ElasticNet, Lasso, SVR,\\n    LogisticRegression, SGDClassifier, LinearSVC, Perceptron\\n    '\n    if warm_start_mem is None:\n        warm_start_mem = {}\n    if max_iter is None:\n        max_iter = 1000\n    if check_input:\n        _dtype = [np.float64, np.float32]\n        X = check_array(X, dtype=_dtype, accept_sparse='csr', order='C')\n        y = check_array(y, dtype=_dtype, ensure_2d=False, order='C')\n    (n_samples, n_features) = (X.shape[0], X.shape[1])\n    alpha_scaled = float(alpha) / n_samples\n    beta_scaled = float(beta) / n_samples\n    n_classes = int(y.max()) + 1 if loss == 'multinomial' else 1\n    sample_weight = _check_sample_weight(sample_weight, X, dtype=X.dtype)\n    if 'coef' in warm_start_mem.keys():\n        coef_init = warm_start_mem['coef']\n    else:\n        coef_init = np.zeros((n_features, n_classes), dtype=X.dtype, order='C')\n    fit_intercept = coef_init.shape[0] == n_features + 1\n    if fit_intercept:\n        intercept_init = coef_init[-1, :]\n        coef_init = coef_init[:-1, :]\n    else:\n        intercept_init = np.zeros(n_classes, dtype=X.dtype)\n    if 'intercept_sum_gradient' in warm_start_mem.keys():\n        intercept_sum_gradient = warm_start_mem['intercept_sum_gradient']\n    else:\n        intercept_sum_gradient = np.zeros(n_classes, dtype=X.dtype)\n    if 'gradient_memory' in warm_start_mem.keys():\n        gradient_memory_init = warm_start_mem['gradient_memory']\n    else:\n        gradient_memory_init = np.zeros((n_samples, n_classes), dtype=X.dtype, order='C')\n    if 'sum_gradient' in warm_start_mem.keys():\n        sum_gradient_init = warm_start_mem['sum_gradient']\n    else:\n        sum_gradient_init = np.zeros((n_features, n_classes), dtype=X.dtype, order='C')\n    if 'seen' in warm_start_mem.keys():\n        seen_init = warm_start_mem['seen']\n    else:\n        seen_init = np.zeros(n_samples, dtype=np.int32, order='C')\n    if 'num_seen' in warm_start_mem.keys():\n        num_seen_init = warm_start_mem['num_seen']\n    else:\n        num_seen_init = 0\n    (dataset, intercept_decay) = make_dataset(X, y, sample_weight, random_state)\n    if max_squared_sum is None:\n        max_squared_sum = row_norms(X, squared=True).max()\n    step_size = get_auto_step_size(max_squared_sum, alpha_scaled, loss, fit_intercept, n_samples=n_samples, is_saga=is_saga)\n    if step_size * alpha_scaled == 1:\n        raise ZeroDivisionError('Current sag implementation does not handle the case step_size * alpha_scaled == 1')\n    sag = sag64 if X.dtype == np.float64 else sag32\n    (num_seen, n_iter_) = sag(dataset, coef_init, intercept_init, n_samples, n_features, n_classes, tol, max_iter, loss, step_size, alpha_scaled, beta_scaled, sum_gradient_init, gradient_memory_init, seen_init, num_seen_init, fit_intercept, intercept_sum_gradient, intercept_decay, is_saga, verbose)\n    if n_iter_ == max_iter:\n        warnings.warn('The max_iter was reached which means the coef_ did not converge', ConvergenceWarning)\n    if fit_intercept:\n        coef_init = np.vstack((coef_init, intercept_init))\n    warm_start_mem = {'coef': coef_init, 'sum_gradient': sum_gradient_init, 'intercept_sum_gradient': intercept_sum_gradient, 'gradient_memory': gradient_memory_init, 'seen': seen_init, 'num_seen': num_seen}\n    if loss == 'multinomial':\n        coef_ = coef_init.T\n    else:\n        coef_ = coef_init[:, 0]\n    return (coef_, n_iter_, warm_start_mem)",
            "def sag_solver(X, y, sample_weight=None, loss='log', alpha=1.0, beta=0.0, max_iter=1000, tol=0.001, verbose=0, random_state=None, check_input=True, max_squared_sum=None, warm_start_mem=None, is_saga=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'SAG solver for Ridge and LogisticRegression.\\n\\n    SAG stands for Stochastic Average Gradient: the gradient of the loss is\\n    estimated each sample at a time and the model is updated along the way with\\n    a constant learning rate.\\n\\n    IMPORTANT NOTE: \\'sag\\' solver converges faster on columns that are on the\\n    same scale. You can normalize the data by using\\n    sklearn.preprocessing.StandardScaler on your data before passing it to the\\n    fit method.\\n\\n    This implementation works with data represented as dense numpy arrays or\\n    sparse scipy arrays of floating point values for the features. It will\\n    fit the data according to squared loss or log loss.\\n\\n    The regularizer is a penalty added to the loss function that shrinks model\\n    parameters towards the zero vector using the squared euclidean norm L2.\\n\\n    .. versionadded:: 0.17\\n\\n    Parameters\\n    ----------\\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\\n        Training data.\\n\\n    y : ndarray of shape (n_samples,)\\n        Target values. With loss=\\'multinomial\\', y must be label encoded\\n        (see preprocessing.LabelEncoder).\\n\\n    sample_weight : array-like of shape (n_samples,), default=None\\n        Weights applied to individual samples (1. for unweighted).\\n\\n    loss : {\\'log\\', \\'squared\\', \\'multinomial\\'}, default=\\'log\\'\\n        Loss function that will be optimized:\\n        -\\'log\\' is the binary logistic loss, as used in LogisticRegression.\\n        -\\'squared\\' is the squared loss, as used in Ridge.\\n        -\\'multinomial\\' is the multinomial logistic loss, as used in\\n         LogisticRegression.\\n\\n        .. versionadded:: 0.18\\n           *loss=\\'multinomial\\'*\\n\\n    alpha : float, default=1.\\n        L2 regularization term in the objective function\\n        ``(0.5 * alpha * || W ||_F^2)``.\\n\\n    beta : float, default=0.\\n        L1 regularization term in the objective function\\n        ``(beta * || W ||_1)``. Only applied if ``is_saga`` is set to True.\\n\\n    max_iter : int, default=1000\\n        The max number of passes over the training data if the stopping\\n        criteria is not reached.\\n\\n    tol : float, default=0.001\\n        The stopping criteria for the weights. The iterations will stop when\\n        max(change in weights) / max(weights) < tol.\\n\\n    verbose : int, default=0\\n        The verbosity level.\\n\\n    random_state : int, RandomState instance or None, default=None\\n        Used when shuffling the data. Pass an int for reproducible output\\n        across multiple function calls.\\n        See :term:`Glossary <random_state>`.\\n\\n    check_input : bool, default=True\\n        If False, the input arrays X and y will not be checked.\\n\\n    max_squared_sum : float, default=None\\n        Maximum squared sum of X over samples. If None, it will be computed,\\n        going through all the samples. The value should be precomputed\\n        to speed up cross validation.\\n\\n    warm_start_mem : dict, default=None\\n        The initialization parameters used for warm starting. Warm starting is\\n        currently used in LogisticRegression but not in Ridge.\\n        It contains:\\n            - \\'coef\\': the weight vector, with the intercept in last line\\n                if the intercept is fitted.\\n            - \\'gradient_memory\\': the scalar gradient for all seen samples.\\n            - \\'sum_gradient\\': the sum of gradient over all seen samples,\\n                for each feature.\\n            - \\'intercept_sum_gradient\\': the sum of gradient over all seen\\n                samples, for the intercept.\\n            - \\'seen\\': array of boolean describing the seen samples.\\n            - \\'num_seen\\': the number of seen samples.\\n\\n    is_saga : bool, default=False\\n        Whether to use the SAGA algorithm or the SAG algorithm. SAGA behaves\\n        better in the first epochs, and allow for l1 regularisation.\\n\\n    Returns\\n    -------\\n    coef_ : ndarray of shape (n_features,)\\n        Weight vector.\\n\\n    n_iter_ : int\\n        The number of full pass on all samples.\\n\\n    warm_start_mem : dict\\n        Contains a \\'coef\\' key with the fitted result, and possibly the\\n        fitted intercept at the end of the array. Contains also other keys\\n        used for warm starting.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from sklearn import linear_model\\n    >>> n_samples, n_features = 10, 5\\n    >>> rng = np.random.RandomState(0)\\n    >>> X = rng.randn(n_samples, n_features)\\n    >>> y = rng.randn(n_samples)\\n    >>> clf = linear_model.Ridge(solver=\\'sag\\')\\n    >>> clf.fit(X, y)\\n    Ridge(solver=\\'sag\\')\\n\\n    >>> X = np.array([[-1, -1], [-2, -1], [1, 1], [2, 1]])\\n    >>> y = np.array([1, 1, 2, 2])\\n    >>> clf = linear_model.LogisticRegression(\\n    ...     solver=\\'sag\\', multi_class=\\'multinomial\\')\\n    >>> clf.fit(X, y)\\n    LogisticRegression(multi_class=\\'multinomial\\', solver=\\'sag\\')\\n\\n    References\\n    ----------\\n    Schmidt, M., Roux, N. L., & Bach, F. (2013).\\n    Minimizing finite sums with the stochastic average gradient\\n    https://hal.inria.fr/hal-00860051/document\\n\\n    :arxiv:`Defazio, A., Bach F. & Lacoste-Julien S. (2014).\\n    \"SAGA: A Fast Incremental Gradient Method With Support\\n    for Non-Strongly Convex Composite Objectives\" <1407.0202>`\\n\\n    See Also\\n    --------\\n    Ridge, SGDRegressor, ElasticNet, Lasso, SVR,\\n    LogisticRegression, SGDClassifier, LinearSVC, Perceptron\\n    '\n    if warm_start_mem is None:\n        warm_start_mem = {}\n    if max_iter is None:\n        max_iter = 1000\n    if check_input:\n        _dtype = [np.float64, np.float32]\n        X = check_array(X, dtype=_dtype, accept_sparse='csr', order='C')\n        y = check_array(y, dtype=_dtype, ensure_2d=False, order='C')\n    (n_samples, n_features) = (X.shape[0], X.shape[1])\n    alpha_scaled = float(alpha) / n_samples\n    beta_scaled = float(beta) / n_samples\n    n_classes = int(y.max()) + 1 if loss == 'multinomial' else 1\n    sample_weight = _check_sample_weight(sample_weight, X, dtype=X.dtype)\n    if 'coef' in warm_start_mem.keys():\n        coef_init = warm_start_mem['coef']\n    else:\n        coef_init = np.zeros((n_features, n_classes), dtype=X.dtype, order='C')\n    fit_intercept = coef_init.shape[0] == n_features + 1\n    if fit_intercept:\n        intercept_init = coef_init[-1, :]\n        coef_init = coef_init[:-1, :]\n    else:\n        intercept_init = np.zeros(n_classes, dtype=X.dtype)\n    if 'intercept_sum_gradient' in warm_start_mem.keys():\n        intercept_sum_gradient = warm_start_mem['intercept_sum_gradient']\n    else:\n        intercept_sum_gradient = np.zeros(n_classes, dtype=X.dtype)\n    if 'gradient_memory' in warm_start_mem.keys():\n        gradient_memory_init = warm_start_mem['gradient_memory']\n    else:\n        gradient_memory_init = np.zeros((n_samples, n_classes), dtype=X.dtype, order='C')\n    if 'sum_gradient' in warm_start_mem.keys():\n        sum_gradient_init = warm_start_mem['sum_gradient']\n    else:\n        sum_gradient_init = np.zeros((n_features, n_classes), dtype=X.dtype, order='C')\n    if 'seen' in warm_start_mem.keys():\n        seen_init = warm_start_mem['seen']\n    else:\n        seen_init = np.zeros(n_samples, dtype=np.int32, order='C')\n    if 'num_seen' in warm_start_mem.keys():\n        num_seen_init = warm_start_mem['num_seen']\n    else:\n        num_seen_init = 0\n    (dataset, intercept_decay) = make_dataset(X, y, sample_weight, random_state)\n    if max_squared_sum is None:\n        max_squared_sum = row_norms(X, squared=True).max()\n    step_size = get_auto_step_size(max_squared_sum, alpha_scaled, loss, fit_intercept, n_samples=n_samples, is_saga=is_saga)\n    if step_size * alpha_scaled == 1:\n        raise ZeroDivisionError('Current sag implementation does not handle the case step_size * alpha_scaled == 1')\n    sag = sag64 if X.dtype == np.float64 else sag32\n    (num_seen, n_iter_) = sag(dataset, coef_init, intercept_init, n_samples, n_features, n_classes, tol, max_iter, loss, step_size, alpha_scaled, beta_scaled, sum_gradient_init, gradient_memory_init, seen_init, num_seen_init, fit_intercept, intercept_sum_gradient, intercept_decay, is_saga, verbose)\n    if n_iter_ == max_iter:\n        warnings.warn('The max_iter was reached which means the coef_ did not converge', ConvergenceWarning)\n    if fit_intercept:\n        coef_init = np.vstack((coef_init, intercept_init))\n    warm_start_mem = {'coef': coef_init, 'sum_gradient': sum_gradient_init, 'intercept_sum_gradient': intercept_sum_gradient, 'gradient_memory': gradient_memory_init, 'seen': seen_init, 'num_seen': num_seen}\n    if loss == 'multinomial':\n        coef_ = coef_init.T\n    else:\n        coef_ = coef_init[:, 0]\n    return (coef_, n_iter_, warm_start_mem)",
            "def sag_solver(X, y, sample_weight=None, loss='log', alpha=1.0, beta=0.0, max_iter=1000, tol=0.001, verbose=0, random_state=None, check_input=True, max_squared_sum=None, warm_start_mem=None, is_saga=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'SAG solver for Ridge and LogisticRegression.\\n\\n    SAG stands for Stochastic Average Gradient: the gradient of the loss is\\n    estimated each sample at a time and the model is updated along the way with\\n    a constant learning rate.\\n\\n    IMPORTANT NOTE: \\'sag\\' solver converges faster on columns that are on the\\n    same scale. You can normalize the data by using\\n    sklearn.preprocessing.StandardScaler on your data before passing it to the\\n    fit method.\\n\\n    This implementation works with data represented as dense numpy arrays or\\n    sparse scipy arrays of floating point values for the features. It will\\n    fit the data according to squared loss or log loss.\\n\\n    The regularizer is a penalty added to the loss function that shrinks model\\n    parameters towards the zero vector using the squared euclidean norm L2.\\n\\n    .. versionadded:: 0.17\\n\\n    Parameters\\n    ----------\\n    X : {array-like, sparse matrix} of shape (n_samples, n_features)\\n        Training data.\\n\\n    y : ndarray of shape (n_samples,)\\n        Target values. With loss=\\'multinomial\\', y must be label encoded\\n        (see preprocessing.LabelEncoder).\\n\\n    sample_weight : array-like of shape (n_samples,), default=None\\n        Weights applied to individual samples (1. for unweighted).\\n\\n    loss : {\\'log\\', \\'squared\\', \\'multinomial\\'}, default=\\'log\\'\\n        Loss function that will be optimized:\\n        -\\'log\\' is the binary logistic loss, as used in LogisticRegression.\\n        -\\'squared\\' is the squared loss, as used in Ridge.\\n        -\\'multinomial\\' is the multinomial logistic loss, as used in\\n         LogisticRegression.\\n\\n        .. versionadded:: 0.18\\n           *loss=\\'multinomial\\'*\\n\\n    alpha : float, default=1.\\n        L2 regularization term in the objective function\\n        ``(0.5 * alpha * || W ||_F^2)``.\\n\\n    beta : float, default=0.\\n        L1 regularization term in the objective function\\n        ``(beta * || W ||_1)``. Only applied if ``is_saga`` is set to True.\\n\\n    max_iter : int, default=1000\\n        The max number of passes over the training data if the stopping\\n        criteria is not reached.\\n\\n    tol : float, default=0.001\\n        The stopping criteria for the weights. The iterations will stop when\\n        max(change in weights) / max(weights) < tol.\\n\\n    verbose : int, default=0\\n        The verbosity level.\\n\\n    random_state : int, RandomState instance or None, default=None\\n        Used when shuffling the data. Pass an int for reproducible output\\n        across multiple function calls.\\n        See :term:`Glossary <random_state>`.\\n\\n    check_input : bool, default=True\\n        If False, the input arrays X and y will not be checked.\\n\\n    max_squared_sum : float, default=None\\n        Maximum squared sum of X over samples. If None, it will be computed,\\n        going through all the samples. The value should be precomputed\\n        to speed up cross validation.\\n\\n    warm_start_mem : dict, default=None\\n        The initialization parameters used for warm starting. Warm starting is\\n        currently used in LogisticRegression but not in Ridge.\\n        It contains:\\n            - \\'coef\\': the weight vector, with the intercept in last line\\n                if the intercept is fitted.\\n            - \\'gradient_memory\\': the scalar gradient for all seen samples.\\n            - \\'sum_gradient\\': the sum of gradient over all seen samples,\\n                for each feature.\\n            - \\'intercept_sum_gradient\\': the sum of gradient over all seen\\n                samples, for the intercept.\\n            - \\'seen\\': array of boolean describing the seen samples.\\n            - \\'num_seen\\': the number of seen samples.\\n\\n    is_saga : bool, default=False\\n        Whether to use the SAGA algorithm or the SAG algorithm. SAGA behaves\\n        better in the first epochs, and allow for l1 regularisation.\\n\\n    Returns\\n    -------\\n    coef_ : ndarray of shape (n_features,)\\n        Weight vector.\\n\\n    n_iter_ : int\\n        The number of full pass on all samples.\\n\\n    warm_start_mem : dict\\n        Contains a \\'coef\\' key with the fitted result, and possibly the\\n        fitted intercept at the end of the array. Contains also other keys\\n        used for warm starting.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from sklearn import linear_model\\n    >>> n_samples, n_features = 10, 5\\n    >>> rng = np.random.RandomState(0)\\n    >>> X = rng.randn(n_samples, n_features)\\n    >>> y = rng.randn(n_samples)\\n    >>> clf = linear_model.Ridge(solver=\\'sag\\')\\n    >>> clf.fit(X, y)\\n    Ridge(solver=\\'sag\\')\\n\\n    >>> X = np.array([[-1, -1], [-2, -1], [1, 1], [2, 1]])\\n    >>> y = np.array([1, 1, 2, 2])\\n    >>> clf = linear_model.LogisticRegression(\\n    ...     solver=\\'sag\\', multi_class=\\'multinomial\\')\\n    >>> clf.fit(X, y)\\n    LogisticRegression(multi_class=\\'multinomial\\', solver=\\'sag\\')\\n\\n    References\\n    ----------\\n    Schmidt, M., Roux, N. L., & Bach, F. (2013).\\n    Minimizing finite sums with the stochastic average gradient\\n    https://hal.inria.fr/hal-00860051/document\\n\\n    :arxiv:`Defazio, A., Bach F. & Lacoste-Julien S. (2014).\\n    \"SAGA: A Fast Incremental Gradient Method With Support\\n    for Non-Strongly Convex Composite Objectives\" <1407.0202>`\\n\\n    See Also\\n    --------\\n    Ridge, SGDRegressor, ElasticNet, Lasso, SVR,\\n    LogisticRegression, SGDClassifier, LinearSVC, Perceptron\\n    '\n    if warm_start_mem is None:\n        warm_start_mem = {}\n    if max_iter is None:\n        max_iter = 1000\n    if check_input:\n        _dtype = [np.float64, np.float32]\n        X = check_array(X, dtype=_dtype, accept_sparse='csr', order='C')\n        y = check_array(y, dtype=_dtype, ensure_2d=False, order='C')\n    (n_samples, n_features) = (X.shape[0], X.shape[1])\n    alpha_scaled = float(alpha) / n_samples\n    beta_scaled = float(beta) / n_samples\n    n_classes = int(y.max()) + 1 if loss == 'multinomial' else 1\n    sample_weight = _check_sample_weight(sample_weight, X, dtype=X.dtype)\n    if 'coef' in warm_start_mem.keys():\n        coef_init = warm_start_mem['coef']\n    else:\n        coef_init = np.zeros((n_features, n_classes), dtype=X.dtype, order='C')\n    fit_intercept = coef_init.shape[0] == n_features + 1\n    if fit_intercept:\n        intercept_init = coef_init[-1, :]\n        coef_init = coef_init[:-1, :]\n    else:\n        intercept_init = np.zeros(n_classes, dtype=X.dtype)\n    if 'intercept_sum_gradient' in warm_start_mem.keys():\n        intercept_sum_gradient = warm_start_mem['intercept_sum_gradient']\n    else:\n        intercept_sum_gradient = np.zeros(n_classes, dtype=X.dtype)\n    if 'gradient_memory' in warm_start_mem.keys():\n        gradient_memory_init = warm_start_mem['gradient_memory']\n    else:\n        gradient_memory_init = np.zeros((n_samples, n_classes), dtype=X.dtype, order='C')\n    if 'sum_gradient' in warm_start_mem.keys():\n        sum_gradient_init = warm_start_mem['sum_gradient']\n    else:\n        sum_gradient_init = np.zeros((n_features, n_classes), dtype=X.dtype, order='C')\n    if 'seen' in warm_start_mem.keys():\n        seen_init = warm_start_mem['seen']\n    else:\n        seen_init = np.zeros(n_samples, dtype=np.int32, order='C')\n    if 'num_seen' in warm_start_mem.keys():\n        num_seen_init = warm_start_mem['num_seen']\n    else:\n        num_seen_init = 0\n    (dataset, intercept_decay) = make_dataset(X, y, sample_weight, random_state)\n    if max_squared_sum is None:\n        max_squared_sum = row_norms(X, squared=True).max()\n    step_size = get_auto_step_size(max_squared_sum, alpha_scaled, loss, fit_intercept, n_samples=n_samples, is_saga=is_saga)\n    if step_size * alpha_scaled == 1:\n        raise ZeroDivisionError('Current sag implementation does not handle the case step_size * alpha_scaled == 1')\n    sag = sag64 if X.dtype == np.float64 else sag32\n    (num_seen, n_iter_) = sag(dataset, coef_init, intercept_init, n_samples, n_features, n_classes, tol, max_iter, loss, step_size, alpha_scaled, beta_scaled, sum_gradient_init, gradient_memory_init, seen_init, num_seen_init, fit_intercept, intercept_sum_gradient, intercept_decay, is_saga, verbose)\n    if n_iter_ == max_iter:\n        warnings.warn('The max_iter was reached which means the coef_ did not converge', ConvergenceWarning)\n    if fit_intercept:\n        coef_init = np.vstack((coef_init, intercept_init))\n    warm_start_mem = {'coef': coef_init, 'sum_gradient': sum_gradient_init, 'intercept_sum_gradient': intercept_sum_gradient, 'gradient_memory': gradient_memory_init, 'seen': seen_init, 'num_seen': num_seen}\n    if loss == 'multinomial':\n        coef_ = coef_init.T\n    else:\n        coef_ = coef_init[:, 0]\n    return (coef_, n_iter_, warm_start_mem)"
        ]
    }
]