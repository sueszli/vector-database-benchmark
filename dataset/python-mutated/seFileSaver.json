[
    {
        "func_name": "__init",
        "original": "def __init(self):\n    pass",
        "mutated": [
            "def __init(self):\n    if False:\n        i = 10\n    pass",
            "def __init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pass",
            "def __init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pass",
            "def __init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pass",
            "def __init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pass"
        ]
    },
    {
        "func_name": "SaveFile",
        "original": "def SaveFile(self, AllScene, filename, dirname, reSaveFlag=0):\n    i1 = '    '\n    i2 = i1 + i1\n    out_file = open(filename, 'w')\n    print('dirname:' + dirname)\n    if not os.path.isdir(dirname):\n        os.mkdir(dirname)\n    savepathname = Filename(filename)\n    self.savepath = savepathname.getBasenameWoExtension()\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# Auto Generated Code by Scene Editor\\n')\n    out_file.write('# Edit with caution\\n')\n    out_file.write('# Using this file in your code:\\n')\n    out_file.write('# For example, if you have named this file as \"myscene.py\"\\n')\n    out_file.write('# Do the following:\\n')\n    out_file.write('# from myscene import * \\n')\n    out_file.write('# theScene=SavedScene() #instantiate the class\\n')\n    out_file.write('# IMPORTANT: All the documentation below refers to \"theScene\" as the instance of SavedScene()\\n')\n    out_file.write('##########################################################################################################\\n\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# Import Panda Modules\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('from direct.directbase.DirectStart import * # Core functionality for running the \"show\"\\n')\n    out_file.write('from direct.actor import Actor # Importing models with animations\\n')\n    out_file.write('from direct.directutil import Mopath # Motion Paths\\n')\n    out_file.write('from direct.interval import MopathInterval # Motion Paths\\n')\n    out_file.write('from direct.interval.IntervalGlobal import * # Intervals for interpolation, sequencing and parallelization\\n')\n    out_file.write('from direct.particles import ParticleEffect # Particle Systems\\n')\n    out_file.write('from direct.particles import ForceGroup # Forces acting on Particles\\n')\n    out_file.write('from direct.particles import Particles\\n\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# This class stores the entire scene\\n')\n    out_file.write('##########################################################################################################\\n\\n')\n    out_file.write('class SavedScene(DirectObject): # We inherit from DirectObject so that we can use self.accept method to catch messages\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '# These dictionaries are required for re-loading a scene in the editor\\n')\n    out_file.write(i1 + '# They can be used to access the objects as well\\n\\n')\n    out_file.write(i1 + 'ModelDic={}# Stores all the models and static geometry\\n')\n    out_file.write(i1 + 'ModelRefDic={}# Stores the paths to the models\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'ActorDic={}# Stores all the actors\\n')\n    out_file.write(i1 + 'ActorRefDic={}# Stores the paths to the actors\\n')\n    out_file.write(i1 + 'ActorAnimsDic={}# Stores the animations for each actor\\n')\n    out_file.write(i1 + 'blendAnimDict={}# Stores all the blended animations\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'LightDict={}# Stores all the lights\\n')\n    out_file.write(i1 + 'LightTypes={}# Stores types for the lights\\n')\n    out_file.write(i1 + 'LightNodes={}# Stores the actual nodes for the lights\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'dummyDict={}# Stores dummies\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'collisionDict={}# Stores Collision information\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'curveDict={}# Stores Mopath information\\n')\n    out_file.write(i1 + 'curveIntervals=[]# Stores list of mopath intervals\\n')\n    out_file.write(i1 + 'curveRefColl=[]# Stores paths to mopaths\\n')\n    out_file.write(i1 + 'curveIntervalsDict={}# Stores mopath intervals\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'particleDict={}# Stores particles\\n')\n    out_file.write(i1 + 'particleNodes={}# Stores particle nodes\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '#Light Count\\n')\n    out_file.write(i1 + 'ambientCount=0\\n')\n    out_file.write(i1 + 'directionalCount=0\\n')\n    out_file.write(i1 + 'pointCount=0\\n')\n    out_file.write(i1 + 'spotCount=0\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '#Lighting Attribute\\n')\n    out_file.write(i1 + 'lightAttrib = LightAttrib.makeAllOff()# Initialize lighting\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'CollisionHandler=CollisionHandlerEvent()# Setup a Collision Handler\\n')\n    out_file.write(i1 + '##########################################################################################################\\n')\n    out_file.write(i1 + '# Constructor: this is run first when you instantiate the SavedScene class\\n')\n    out_file.write(i1 + '##########################################################################################################\\n')\n    out_file.write(i1 + 'def __init__(self,loadmode=1,seParticleEffect=None,seParticles=None,executionpath=None):# loadmode 0 specifies that this file is being loaded by the scene editor and it passes its own versions of the particle fx modules\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'self.loadmode=loadmode\\n')\n    out_file.write(i2 + 'self.seParticleEffect=seParticleEffect\\n')\n    out_file.write(i2 + 'self.seParticles=seParticles\\n')\n    out_file.write(i2 + 'self.executionpath=executionpath\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'base.enableParticles()# Enable Particle effects\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'self.cTrav = CollisionTraverser() # Setup a traverser for collisions\\n')\n    out_file.write(i2 + 'base.cTrav = self.cTrav\\n')\n    out_file.write(i2 + 'self.CollisionHandler.setInPattern(\"enter%in\")# The message to be raised when something enters a collision node\\n')\n    out_file.write(i2 + 'self.CollisionHandler.setOutPattern(\"exit%in\")# The message to be raised when something exits a collision node\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the models\\n')\n    out_file.write(i2 + '# To access these models:\\n')\n    out_file.write(i2 + '# theScene.ModelDic[\"\\'Model_Name\"\\']\\n')\n    out_file.write(i2 + '# where theScene is the SavedScene class instance\\n')\n    out_file.write(i2 + '# Properties saved include:\\n')\n    out_file.write(i2 + '# Transformations\\n')\n    out_file.write(i2 + '# Alpha and color\\n')\n    out_file.write(i2 + '# Parent and child information\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for model in AllScene.ModelDic:\n        out_file.write('\\n')\n        modelS = str(model)\n        if 1:\n            out_file.write(i2 + \"# Loading model's egg file\\n\")\n            newpath = dirname + '/' + AllScene.ModelRefDic[model].getBasename()\n            newpathF = Filename(newpath)\n            newpathSpecific = newpathF.toOsSpecific()\n            fnamelist = []\n            modelData = EggData()\n            modelData.read(AllScene.ModelRefDic[model])\n            textures = EggTextureCollection()\n            textures.findUsedTextures(modelData)\n            for index in range(textures.getNumTextures()):\n                texture = textures.getTexture(index)\n                texfilename = texture.getFilename()\n                fnamelist.append(texfilename.getFullpath())\n                oldFilename = Filename(Filename(AllScene.ModelRefDic[model].getDirname()), texfilename)\n                if not oldFilename.isRegularFile():\n                    if texfilename.resolveFilename(getTexturePath(), ''):\n                        oldFilename = texfilename\n                oldtexpath = oldFilename.toOsSpecific()\n                newtexpath = dirname + '/' + texfilename.getBasename()\n                newtexpathF = Filename(newtexpath)\n                newtexpathSpecific = newtexpathF.toOsSpecific()\n                print('TEXTURE SAVER:: copying' + oldtexpath + ' to ' + newtexpathSpecific)\n                if oldtexpath != newtexpathSpecific:\n                    shutil.copyfile(oldtexpath, newtexpathSpecific)\n            oldModelpath = AllScene.ModelRefDic[model].toOsSpecific()\n            print('FILESAVER:: copying from ' + AllScene.ModelRefDic[model].toOsSpecific() + 'to' + newpathSpecific)\n            if oldModelpath != newpathSpecific:\n                shutil.copyfile(oldModelpath, newpathSpecific)\n            e = EggData()\n            e.read(AllScene.ModelRefDic[model])\n            etc = EggTextureCollection()\n            etc.extractTextures(e)\n            for index in range(len(fnamelist)):\n                print(fnamelist[index])\n                tex = etc.findFilename(Filename(fnamelist[index]))\n                fn = Filename(tex.getFilename())\n                fn.setDirname('')\n                tex.setFilename(fn)\n                e.writeEgg(Filename.fromOsSpecific(newpathSpecific))\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + modelS + \"=loader.loadModel('\" + self.savepath + '/' + AllScene.ModelRefDic[model].getBasename() + \"')\\n\")\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.' + modelS + \"=loader.loadModel(self.executionpath + '/\" + AllScene.ModelRefDic[model].getBasename() + \"')\\n\")\n            out_file.write('\\n')\n            out_file.write(i2 + '# Transforming the model\\n')\n            out_file.write(i2 + 'self.' + modelS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.ModelDic[model].getX(), AllScene.ModelDic[model].getY(), AllScene.ModelDic[model].getZ(), AllScene.ModelDic[model].getH(), AllScene.ModelDic[model].getP(), AllScene.ModelDic[model].getR(), AllScene.ModelDic[model].getSx(), AllScene.ModelDic[model].getSy(), AllScene.ModelDic[model].getSz()))\n            if AllScene.ModelDic[model].hasTransparency():\n                out_file.write('\\n')\n                out_file.write(i2 + '# Alpha\\n')\n                out_file.write(i2 + 'self.' + modelS + '.setTransparency(1)\\n')\n                clr = AllScene.ModelDic[model].getColor()\n                out_file.write(i2 + 'self.' + modelS + '.setColor(%.4f,%.4f,%.4f,%.4f)\\n' % (clr.getX(), clr.getY(), clr.getZ(), clr.getW()))\n            out_file.write('\\n')\n            out_file.write(i2 + '# Reparent To Render for now and later we update all the parentings\\n')\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(render)\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.ModelDic[\"Model_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + modelS + '.setTag(\"Metadata\",\"' + AllScene.ModelDic[model].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            out_file.write(i2 + \"self.ModelDic['\" + modelS + \"']=self.\" + AllScene.ModelDic[model].getName() + '\\n')\n            out_file.write(i2 + \"self.ModelRefDic['\" + modelS + \"']='\" + AllScene.ModelRefDic[model].getBasename() + \"'\\n\")\n            out_file.write(i2 + \"self.ModelDic['\" + modelS + \"'].setName('\" + modelS + \"')\\n\")\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the Dummy Objects\\n')\n    out_file.write(i2 + '# To access the dummies\\n')\n    out_file.write(i2 + \"# theScene.dummyDict['Dummy_Name']\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for dummy in AllScene.dummyDict:\n        out_file.write('\\n')\n        dummyS = str(dummy)\n        if 1:\n            out_file.write(i2 + 'self.' + dummyS + '=loader.loadModel(\"models/misc/sphere\")\\n')\n            out_file.write(i2 + '# Transforming the Dummy\\n')\n            out_file.write(i2 + 'self.' + dummyS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.dummyDict[dummy].getX(), AllScene.dummyDict[dummy].getY(), AllScene.dummyDict[dummy].getZ(), AllScene.dummyDict[dummy].getH(), AllScene.dummyDict[dummy].getP(), AllScene.dummyDict[dummy].getR(), AllScene.dummyDict[dummy].getSx(), AllScene.dummyDict[dummy].getSy(), AllScene.dummyDict[dummy].getSz()))\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"']=self.\" + AllScene.dummyDict[dummy].getName() + '\\n')\n            out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"'].setName('\" + dummyS + \"')\\n\")\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.dummyDict[\"Dummy_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + dummyS + '.setTag(\"Metadata\",\"' + AllScene.dummyDict[dummy].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the Actors and animations\\n')\n    out_file.write(i2 + '# To access the Actors\\n')\n    out_file.write(i2 + \"# theScene.ActorDic['Actor_Name']\\n\")\n    out_file.write(i2 + \"# theScene.ActorDic['Actor_Name'].play('Animation_Name')\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for actor in AllScene.ActorDic:\n        out_file.write('\\n')\n        actorS = str(actor)\n        if 1:\n            newpath = dirname + '/' + AllScene.ActorRefDic[actor].getBasename()\n            newpathF = Filename(newpath)\n            newpathSpecific = newpathF.toOsSpecific()\n            actorfnamelist = []\n            actorData = EggData()\n            actorData.read(AllScene.ActorRefDic[actor])\n            textures = EggTextureCollection()\n            textures.findUsedTextures(actorData)\n            for index in range(textures.getNumTextures()):\n                texture = textures.getTexture(index)\n                texfilename = texture.getFilename()\n                actorfnamelist.append(texfilename.getFullpath())\n                oldFilename = Filename(Filename(AllScene.ActorRefDic[actor].getDirname()), texfilename)\n                if not oldFilename.isRegularFile():\n                    if texfilename.resolveFilename(getTexturePath(), ''):\n                        oldFilename = texfilename\n                oldtexpath = oldFilename.toOsSpecific()\n                newtexpath = dirname + '/' + texfilename.getBasename()\n                newtexpathF = Filename(newtexpath)\n                newtexpathSpecific = newtexpathF.toOsSpecific()\n                print('TEXTURE SAVER:: copying' + oldtexpath + ' to ' + newtexpathSpecific)\n                if oldtexpath != newtexpathSpecific:\n                    shutil.copyfile(oldtexpath, newtexpathSpecific)\n            oldActorpath = AllScene.ActorRefDic[actor].toOsSpecific()\n            print('FILESAVER:: copying from ' + AllScene.ActorRefDic[actor].toOsSpecific() + 'to' + newpathSpecific)\n            if oldActorpath != newpathSpecific:\n                shutil.copyfile(oldActorpath, newpathSpecific)\n            e = EggData()\n            e.read(AllScene.ActorRefDic[actor])\n            etc = EggTextureCollection()\n            etc.extractTextures(e)\n            for index in range(len(actorfnamelist)):\n                print(actorfnamelist[index])\n                tex = etc.findFilename(Filename(actorfnamelist[index]))\n                fn = Filename(tex.getFilename())\n                fn.setDirname('')\n                tex.setFilename(fn)\n                e.writeEgg(Filename.fromOsSpecific(newpathSpecific))\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + \"=Actor.Actor('\" + self.savepath + '/' + AllScene.ActorRefDic[actor].getBasename() + \"')\\n\")\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + \"=Actor.Actor(self.executionpath + '/\" + AllScene.ActorRefDic[actor].getBasename() + \"')\\n\")\n            out_file.write(i2 + '# Transforming the Actor\\n')\n            out_file.write(i2 + 'self.' + actorS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.ActorDic[actor].getX(), AllScene.ActorDic[actor].getY(), AllScene.ActorDic[actor].getZ(), AllScene.ActorDic[actor].getH(), AllScene.ActorDic[actor].getP(), AllScene.ActorDic[actor].getR(), AllScene.ActorDic[actor].getSx(), AllScene.ActorDic[actor].getSy(), AllScene.ActorDic[actor].getSz()))\n            if AllScene.ActorDic[actor].hasTransparency():\n                out_file.write(i2 + '# Alpha\\n')\n                out_file.write(i2 + 'self.' + actorS + '.setTransparency(1)\\n')\n                clr = AllScene.ActorDic[actor].getColor()\n                out_file.write(i2 + 'self.' + actorS + '.setColor(%.4f,%.4f,%.4f,%.4f)\\n' % (clr.getX(), clr.getY(), clr.getZ(), clr.getW()))\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(render)\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.ActorDic[\"Actor_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + actorS + '.setTag(\"Metadata\",\"' + AllScene.ActorDic[actor].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            ActorAnimations = AllScene.getAnimationDictFromActor(actor)\n            ActorAnimationsInvoke = {}\n            if ActorAnimations != {}:\n                for animation in ActorAnimations:\n                    if not animation is None:\n                        print('ACTOR ANIMATIONS:' + ActorAnimations[animation])\n                        oldAnimPath = Filename(ActorAnimations[animation])\n                        oldAnim = oldAnimPath.toOsSpecific()\n                        dirOS = Filename(dirname)\n                        newAnim = dirOS.toOsSpecific() + '\\\\' + oldAnimPath.getBasename()\n                        print('ACTOR ANIM SAVER:: Comparing' + oldAnim + 'and' + newAnim)\n                        if oldAnim != newAnim:\n                            shutil.copyfile(oldAnim, newAnim)\n                        newAnimF = Filename.fromOsSpecific(newAnim)\n                        ActorAnimationsInvoke[animation] = 'self.executionpath +' + '/' + newAnimF.getBasename()\n                        ActorAnimations[animation] = self.savepath + '/' + newAnimF.getBasename()\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + '.loadAnims(' + str(ActorAnimations) + ')\\n')\n            out_file.write(i2 + 'else:\\n')\n            theloadAnimString = str(ActorAnimationsInvoke)\n            print('LOAD ANIM STRING BEFORE' + theloadAnimString)\n            theloadAnimString = theloadAnimString.replace(\"'self.executionpath +\", \"self.executionpath + '\")\n            print('LOAD ANIM STRING AFTER' + theloadAnimString)\n            out_file.write(i2 + i1 + 'self.' + actorS + '.loadAnims(' + theloadAnimString + ')\\n')\n            out_file.write(i2 + \"self.ActorDic['\" + actorS + \"']=self.\" + AllScene.ActorDic[actor].getName() + '\\n')\n            out_file.write(i2 + \"self.ActorRefDic['\" + actorS + \"']='\" + AllScene.ActorRefDic[actor].getBasename() + \"'\\n\")\n            out_file.write(i2 + \"self.ActorDic['\" + actorS + \"'].setName('\" + actorS + \"')\\n\")\n            if actor in AllScene.blendAnimDict:\n                out_file.write(i2 + 'self.blendAnimDict[\"' + actorS + '\"]=' + str(AllScene.blendAnimDict[actor]) + '\\n')\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for setting up Collision Nodes\\n')\n    out_file.write(i2 + '# To use collision detection:\\n')\n    out_file.write(i2 + '# You must set up your own bitmasking and event handlers, the traverser \"cTrav\" is created for you at the top\\n')\n    out_file.write(i2 + '# The collision nodes are stored in collisionDict\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for collnode in AllScene.collisionDict:\n        collnodeS = str(collnode)\n        solid = AllScene.collisionDict[collnode].node().getSolid(0)\n        nodetype = solid.getType().getName()\n        if nodetype == 'CollisionSphere':\n            out_file.write(i2 + 'collSolid=CollisionSphere(%.3f,%.3f,%.3f,%.3f)\\n' % (solid.getCenter().getX(), solid.getCenter().getY(), solid.getCenter().getZ(), solid.getRadius()))\n            pass\n        elif nodetype == 'CollisionPolygon':\n            ax = AllScene.collisionDict[collnode].getTag('A_X')\n            ay = AllScene.collisionDict[collnode].getTag('A_Y')\n            az = AllScene.collisionDict[collnode].getTag('A_Z')\n            bx = AllScene.collisionDict[collnode].getTag('B_X')\n            by = AllScene.collisionDict[collnode].getTag('B_Y')\n            bz = AllScene.collisionDict[collnode].getTag('B_Z')\n            cx = AllScene.collisionDict[collnode].getTag('C_X')\n            cy = AllScene.collisionDict[collnode].getTag('C_Y')\n            cz = AllScene.collisionDict[collnode].getTag('C_Z')\n            out_file.write(i2 + 'pointA =  Point3(' + ax + ',' + ay + ',' + az + ')\\n')\n            out_file.write(i2 + 'pointB =  Point3(' + bx + ',' + by + ',' + bz + ')\\n')\n            out_file.write(i2 + 'pointC =  Point3(' + cx + ',' + cy + ',' + cz + ')\\n')\n            out_file.write(i2 + 'collSolid=CollisionPolygon(pointA, pointB, pointC)\\n')\n            pass\n        elif nodetype == 'CollisionSegment':\n            A = AllScene.collisionDict[collnode].node().getSolid(0).getPointA()\n            B = AllScene.collisionDict[collnode].node().getSolid(0).getPointB()\n            out_file.write(i2 + 'pointA =  Point3(%.3f,%.3f,%.3f)\\n' % (A.getX(), A.getY(), A.getZ()))\n            out_file.write(i2 + 'pointB =  Point3(%.3f,%.3f,%.3f)\\n' % (B.getX(), B.getY(), B.getZ()))\n            out_file.write(i2 + 'collSolid=CollisionSegment()\\n')\n            out_file.write(i2 + 'collSolid.setPointA(pointA)\\n')\n            out_file.write(i2 + 'collSolid.setFromLens(base.cam.node(),Point2(-1,1))\\n')\n            out_file.write(i2 + 'collSolid.setPointB(pointB)\\n')\n            pass\n        elif nodetype == 'CollisionRay':\n            P = AllScene.collisionDict[collnode].node().getSolid(0).getOrigin()\n            V = AllScene.collisionDict[collnode].node().getSolid(0).getDirection()\n            out_file.write(i2 + 'point=Point3(%.3f,%.3f,%.3f)\\n' % (P.getX(), P.getY(), P.getZ()))\n            out_file.write(i2 + 'vector=Vec3(%.3f,%.3f,%.3f)\\n' % (V.getX(), V.getY(), V.getZ()))\n            out_file.write(i2 + 'collSolid=CollisionRay()\\n')\n            out_file.write(i2 + 'collSolid.setOrigin(point)\\n')\n            out_file.write(i2 + 'collSolid.setDirection(vector)\\n')\n            pass\n        else:\n            print('Invalid Collision Node: ' + nodetype)\n        out_file.write('\\n')\n        out_file.write(i2 + 'self.' + collnodeS + '_Node' + '=CollisionNode(\"' + collnodeS + '\")\\n')\n        out_file.write(i2 + 'self.' + collnodeS + '_Node' + '.addSolid(collSolid)\\n')\n        out_file.write(i2 + 'base.cTrav.addCollider(self.' + collnodeS + '_Node,self.CollisionHandler)\\n')\n        out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for Lighting\\n')\n    out_file.write(i2 + '# To manipulated lights:\\n')\n    out_file.write(i2 + \"# Manipulate the light node in theScene.LightNodes['Light_Name']\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    LightList = AllScene.lightManager.getLightNodeList()\n    for light in LightList:\n        type = light.getType()\n        if type == 'ambient':\n            out_file.write(i2 + '# Ambient Light\\n')\n            out_file.write(i2 + 'self.ambientCount += 1\\n')\n            out_file.write(i2 + \"alight = AmbientLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'directional':\n            out_file.write(i2 + '# Directional Light\\n')\n            out_file.write(i2 + 'self.directionalCount += 1\\n')\n            out_file.write(i2 + \"alight = DirectionalLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setHpr(Vec3(' + str(light.getH()) + ',' + str(light.getP()) + ',' + str(light.getR()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'point':\n            out_file.write(i2 + '# Point Light\\n')\n            out_file.write(i2 + 'self.pointCount += 1\\n')\n            out_file.write(i2 + \"alight = PointLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setAttenuation(Vec3(' + str(light.getAttenuation().getX()) + ',' + str(light.getAttenuation().getY()) + ',' + str(light.getAttenuation().getZ()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'spot':\n            out_file.write(i2 + '# Spot Light\\n')\n            out_file.write(i2 + 'self.spotCount += 1\\n')\n            out_file.write(i2 + \"alight = Spotlight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alens = PerspectiveLens()\\n')\n            out_file.write(i2 + 'alight.setLens(alens)\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setAttenuation(Vec3(' + str(light.getAttenuation().getX()) + ',' + str(light.getAttenuation().getY()) + ',' + str(light.getAttenuation().getZ()) + '))\\n')\n            out_file.write(i2 + 'alight.setExponent(' + str(light.getExponent()) + ')\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setHpr(Vec3(' + str(light.getH()) + ',' + str(light.getP()) + ',' + str(light.getR()) + '))\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        else:\n            out_file.write(i2 + \"print 'Invalid light type'\")\n            out_file.write(i2 + 'return None')\n        out_file.write('\\n')\n    out_file.write(i2 + '# Enable Ligthing\\n')\n    out_file.write(i2 + 'render.node().setAttrib(self.lightAttrib)\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '# Load Particle Effects. The parameters to this function are to allow us to use our modified versions of the Particle Effects modules when loading this file with the level editor\\n')\n    out_file.write(i2 + 'self.starteffects(self.loadmode,self.seParticleEffect,self.seParticles)\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '# Save Camera Settings\\n')\n    out_file.write(i2 + 'camera.setX(' + str(camera.getX()) + ')\\n')\n    out_file.write(i2 + 'camera.setY(' + str(camera.getY()) + ')\\n')\n    out_file.write(i2 + 'camera.setZ(' + str(camera.getZ()) + ')\\n')\n    out_file.write(i2 + 'camera.setH(' + str(camera.getH()) + ')\\n')\n    out_file.write(i2 + 'camera.setP(' + str(camera.getP()) + ')\\n')\n    out_file.write(i2 + 'camera.setR(' + str(camera.getR()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setNear(' + str(camera.getChild(0).node().getLens().getNear()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFar(' + str(camera.getChild(0).node().getLens().getFar()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFov(VBase2(%.5f,%.5f))\\n' % (camera.getChild(0).node().getLens().getHfov(), camera.getChild(0).node().getLens().getVfov()))\n    FilmSize = camera.getChild(0).node().getLens().getFilmSize()\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFilmSize(%.3f,%.3f)\\n' % (FilmSize.getX(), FilmSize.getY()))\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFocalLength(' + str(camera.getChild(0).node().getLens().getFocalLength()) + ')\\n')\n    out_file.write(i2 + 'camera.setTag(\"Metadata\",\"' + camera.getTag('Metadata') + '\")\\n')\n    out_file.write(i2 + 'camera.reparentTo(render)\\n')\n    out_file.write(i2 + 'base.disableMouse()\\n')\n    self.bgColor = base.getBackgroundColor()\n    out_file.write(i2 + 'base.setBackgroundColor(%.3f,%.3f,%.3f)\\n' % (self.bgColor.getX(), self.bgColor.getY(), self.bgColor.getZ()))\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Motion Paths\\n')\n    out_file.write(i2 + '# Using Mopaths:\\n')\n    out_file.write(i2 + '# theScene.curveIntervals[0].start() or .loop() will play curve with index 0\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for node in AllScene.curveDict:\n        curveCollection = AllScene.curveDict[node]\n        curvenumber = 0\n        for curve in curveCollection:\n            filestring = dirname + '\\\\' + str(node) + '_curve_' + str(curvenumber) + '.egg'\n            f = Filename.fromOsSpecific(filestring)\n            filestring = f.getBasename()\n            curve.writeEgg(f)\n            out_file.write(i2 + 'm=Mopath.Mopath()\\n')\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'm.loadFile(\"' + self.savepath + '/' + filestring + '\")\\n')\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'm.loadFile(self.executionpath + \"/' + filestring + '\")\\n')\n            out_file.write(i2 + 'mp=MopathInterval(m,self.' + str(node) + ')\\n')\n            out_file.write(i2 + 'self.curveIntervals.append(mp)\\n')\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.curveRefColl.append(\"' + self.savepath + '/' + filestring + '\")\\n')\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.curveRefColl.append(self.executionpath + \"/' + filestring + '\")\\n')\n            curvenumber = curvenumber + 1\n        out_file.write(i2 + 'self.curveIntervalsDict[\"' + str(node) + '\"]=self.curveIntervals\\n')\n        out_file.write(i2 + 'self.curveDict[\"' + str(node) + '\"]=self.curveRefColl\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Reparenting\\n')\n    out_file.write(i2 + '# A final pass is done on setting all the scenegraph hierarchy after all objects are laoded\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for model in AllScene.ModelDic:\n        modelS = str(model)\n        parent = AllScene.ModelDic[model].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.ModelDic['\" + modelS + \"']=self.\" + AllScene.ModelDic[model].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for dummy in AllScene.dummyDict:\n        dummyS = str(dummy)\n        parent = AllScene.dummyDict[dummy].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"']=self.\" + AllScene.dummyDict[dummy].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for actor in AllScene.ActorDic:\n        actorS = str(actor)\n        parent = AllScene.ActorDic[actor].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.ActorDic['\" + actorS + \"']=self.\" + AllScene.ActorDic[actor].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for collnode in AllScene.collisionDict:\n        collnodeS = str(collnode)\n        solid = AllScene.collisionDict[collnode].node().getSolid(0)\n        nodetype = solid.getType().getName()\n        parentname = AllScene.collisionDict[collnode].getParent().getName()\n        if parentname == 'render' or parentname == 'camera':\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=' + parentname + '.attachNewNode(self.' + collnodeS + '_Node)\\n')\n        elif parentname in AllScene.particleDict:\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=self.' + parentname + 'getEffect().attachNewNode(self.' + collnodeS + '_Node)\\n')\n        else:\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=self.' + parentname + '.attachNewNode(self.' + collnodeS + '_Node)\\n')\n        dictelem = AllScene.collisionDict[collnode]\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (dictelem.getX(), dictelem.getY(), dictelem.getZ(), dictelem.getH(), dictelem.getP(), dictelem.getR(), dictelem.getSx(), dictelem.getSy(), dictelem.getSz()))\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\"Metadata\",\"' + AllScene.collisionDict[collnode].getTag('Metadata') + '\")\\n')\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].show()\\n')\n        if nodetype == 'CollisionPolygon':\n            ax = float(AllScene.collisionDict[collnode].getTag('A_X'))\n            ay = float(AllScene.collisionDict[collnode].getTag('A_Y'))\n            az = float(AllScene.collisionDict[collnode].getTag('A_Z'))\n            bx = float(AllScene.collisionDict[collnode].getTag('B_X'))\n            by = float(AllScene.collisionDict[collnode].getTag('B_Y'))\n            bz = float(AllScene.collisionDict[collnode].getTag('B_Z'))\n            cx = float(AllScene.collisionDict[collnode].getTag('C_X'))\n            cy = float(AllScene.collisionDict[collnode].getTag('C_Y'))\n            cz = float(AllScene.collisionDict[collnode].getTag('C_Z'))\n            out_file.write(i2 + 'pointA=Point3(%.3f,%.3f,%.3f)\\n' % (ax, ay, az))\n            out_file.write(i2 + 'pointB=Point3(%.3f,%.3f,%.3f)\\n' % (bx, by, bz))\n            out_file.write(i2 + 'pointC=Point3(%.3f,%.3f,%.3f)\\n' % (cx, cy, cz))\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_X\\',\\'%f\\'%pointA.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_Y\\',\\'%f\\'%pointA.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_Z\\',\\'%f\\'%pointA.getZ())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_X\\',\\'%f\\'%pointB.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_Y\\',\\'%f\\'%pointB.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_Z\\',\\'%f\\'%pointB.getZ())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_X\\',\\'%f\\'%pointC.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_Y\\',\\'%f\\'%pointC.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_Z\\',\\'%f\\'%pointC.getZ())\\n')\n        out_file.write(i2 + '\\n')\n    for effect in AllScene.particleDict:\n        parent = AllScene.particleNodes[effect].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.particleDict[\"' + str(effect) + '\"].reparentTo(' + parent + ')\\n')\n        else:\n            out_file.write(i2 + 'self.particleDict[\"' + str(effect) + '\"].reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + '\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Particle Effects\\n')\n    out_file.write(i2 + '# Using Particles:\\n')\n    out_file.write(i2 + '# theScene.enableeffect(\"Effect_Name\")\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write(i1 + 'def starteffects(self,mode,seParticleEffect=None,seParticles=None):\\n')\n    for effect in AllScene.particleDict:\n        effectS = str(effect)\n        out_file.write(i2 + 'self.' + effectS + '=' + effectS + '(mode,seParticleEffect,seParticles)\\n')\n        out_file.write(i2 + 'effect=self.' + effectS + '.getEffect()\\n')\n        out_file.write(i2 + 'self.particleDict[\"' + effectS + '\"]=effect\\n')\n        out_file.write(i2 + 'effect.reparentTo(render)\\n')\n        thenode = AllScene.particleNodes[effect]\n        out_file.write(i2 + 'self.particleDict[\"' + effectS + '\"].setPosHprScale(%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f)\\n' % (thenode.getX(), thenode.getY(), thenode.getZ(), thenode.getH(), thenode.getP(), thenode.getR(), thenode.getSx(), thenode.getSy(), thenode.getSz()))\n        out_file.write('\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def enableeffect(self,effect_name):\\n')\n    out_file.write(i2 + 'self.particleDict[effect_name].enable()\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def disableeffect(self,effect_name):\\n')\n    out_file.write(i2 + 'self.particleDict[effect_name].disable()\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Animation Blending\\n')\n    out_file.write(i2 + '# Using blending:\\n')\n    out_file.write(i2 + '# theScene.playBlendAnim(actor,blendname)\\n')\n    out_file.write(i2 + '# theScene.stopBlendAnim(actor,blendname)\\n')\n    out_file.write(i2 + '# theScene.changeBlendAnim(actor,blendname,blend_amount)\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write(i1 + 'def playBlendAnim(self,actor,blendName,loop=0):\\n')\n    out_file.write(i2 + 'actor.enableBlend()\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'actor.setControlEffect(blendList[0],blendList[2])\\n')\n    out_file.write(i2 + 'actor.setControlEffect(blendList[1],1.0-blendList[2])\\n')\n    out_file.write(i2 + 'if(loop):\\n')\n    out_file.write(i2 + i1 + 'actor.loop(blendList[0])\\n')\n    out_file.write(i2 + i1 + 'actor.loop(blendList[1])\\n')\n    out_file.write(i2 + 'else:\\n')\n    out_file.write(i2 + i1 + 'actor.start(blendList[0])\\n')\n    out_file.write(i2 + i1 + 'actor.start(blendList[1])\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def stopBlendAnim(self,actor,blendName):\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'actor.stop(blendList[0])\\n')\n    out_file.write(i2 + 'actor.stop(blendList[1])\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def changeBlending(self,actor,blendName,blending):\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'blendList[2]=blending\\n')\n    out_file.write(i2 + 'self.blendAnimDict[actor.getName()]={blendName:[blendList[0],blendList[1],blending]}\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Hide and Show Methods\\n')\n    out_file.write(i2 + '# These will help you hide/show dummies, collision solids, effect nodes etc.\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideDummies(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for dummy in self.dummyDict:\\n')\n    out_file.write(i2 + i1 + 'self.dummyDict[dummy].reparentTo(hidden)\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideCollSolids(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for collSolid in self.collisionDict:\\n')\n    out_file.write(i2 + i1 + 'self.collisionDict[collSolid].hide()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideEffectNodes(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for effectnode in self.particleNodes:\\n')\n    out_file.write(i2 + i1 + 'self.particleNodes[effectnode].hide()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showDummies(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for dummy in self.dummyDict:\\n')\n    out_file.write(i2 + i1 + 'self.dummyDict[dummy].reparentTo(hidden)\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showCollSolids(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for collSolid in self.collisionDict:\\n')\n    out_file.write(i2 + i1 + 'self.collisionDict[collSolid].show()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showEffectNodes(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for effectnode in self.particleNodes:\\n')\n    out_file.write(i2 + i1 + 'self.particleNodes[effectnode].show()\\n\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Particle Effects\\n')\n    out_file.write(i2 + '# This is where effect parameters are saved in a class\\n')\n    out_file.write(i2 + '# The class is then instantiated in the starteffects method and appended to the dictionaries\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for effect in AllScene.particleDict:\n        out_file.write('\\n\\n')\n        out_file.write('class ' + str(effect) + ':\\n')\n        out_file.write(i1 + 'def __init__(self,mode=1,seParticleEffect=None,seParticles=None):\\n')\n        out_file.write(i2 + 'if(mode==0):\\n')\n        out_file.write(i2 + i1 + 'self.effect=seParticleEffect.ParticleEffect()\\n')\n        out_file.write(i2 + 'else:\\n')\n        out_file.write(i2 + i1 + 'self.effect=ParticleEffect.ParticleEffect()\\n')\n        AllScene.particleDict[effect].AppendConfig(out_file)\n        out_file.write('\\n\\n')\n        out_file.write(i1 + 'def starteffect(self):\\n')\n        out_file.write(i2 + 'pass\\n')\n        out_file.write('\\n\\n')\n        out_file.write(i1 + 'def stopeffect(self):\\n')\n        out_file.write(i2 + 'pass\\n\\n')\n        out_file.write(i1 + 'def getEffect(self):\\n')\n        out_file.write(i2 + 'return self.effect\\n\\n')\n    out_file.close()",
        "mutated": [
            "def SaveFile(self, AllScene, filename, dirname, reSaveFlag=0):\n    if False:\n        i = 10\n    i1 = '    '\n    i2 = i1 + i1\n    out_file = open(filename, 'w')\n    print('dirname:' + dirname)\n    if not os.path.isdir(dirname):\n        os.mkdir(dirname)\n    savepathname = Filename(filename)\n    self.savepath = savepathname.getBasenameWoExtension()\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# Auto Generated Code by Scene Editor\\n')\n    out_file.write('# Edit with caution\\n')\n    out_file.write('# Using this file in your code:\\n')\n    out_file.write('# For example, if you have named this file as \"myscene.py\"\\n')\n    out_file.write('# Do the following:\\n')\n    out_file.write('# from myscene import * \\n')\n    out_file.write('# theScene=SavedScene() #instantiate the class\\n')\n    out_file.write('# IMPORTANT: All the documentation below refers to \"theScene\" as the instance of SavedScene()\\n')\n    out_file.write('##########################################################################################################\\n\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# Import Panda Modules\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('from direct.directbase.DirectStart import * # Core functionality for running the \"show\"\\n')\n    out_file.write('from direct.actor import Actor # Importing models with animations\\n')\n    out_file.write('from direct.directutil import Mopath # Motion Paths\\n')\n    out_file.write('from direct.interval import MopathInterval # Motion Paths\\n')\n    out_file.write('from direct.interval.IntervalGlobal import * # Intervals for interpolation, sequencing and parallelization\\n')\n    out_file.write('from direct.particles import ParticleEffect # Particle Systems\\n')\n    out_file.write('from direct.particles import ForceGroup # Forces acting on Particles\\n')\n    out_file.write('from direct.particles import Particles\\n\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# This class stores the entire scene\\n')\n    out_file.write('##########################################################################################################\\n\\n')\n    out_file.write('class SavedScene(DirectObject): # We inherit from DirectObject so that we can use self.accept method to catch messages\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '# These dictionaries are required for re-loading a scene in the editor\\n')\n    out_file.write(i1 + '# They can be used to access the objects as well\\n\\n')\n    out_file.write(i1 + 'ModelDic={}# Stores all the models and static geometry\\n')\n    out_file.write(i1 + 'ModelRefDic={}# Stores the paths to the models\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'ActorDic={}# Stores all the actors\\n')\n    out_file.write(i1 + 'ActorRefDic={}# Stores the paths to the actors\\n')\n    out_file.write(i1 + 'ActorAnimsDic={}# Stores the animations for each actor\\n')\n    out_file.write(i1 + 'blendAnimDict={}# Stores all the blended animations\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'LightDict={}# Stores all the lights\\n')\n    out_file.write(i1 + 'LightTypes={}# Stores types for the lights\\n')\n    out_file.write(i1 + 'LightNodes={}# Stores the actual nodes for the lights\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'dummyDict={}# Stores dummies\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'collisionDict={}# Stores Collision information\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'curveDict={}# Stores Mopath information\\n')\n    out_file.write(i1 + 'curveIntervals=[]# Stores list of mopath intervals\\n')\n    out_file.write(i1 + 'curveRefColl=[]# Stores paths to mopaths\\n')\n    out_file.write(i1 + 'curveIntervalsDict={}# Stores mopath intervals\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'particleDict={}# Stores particles\\n')\n    out_file.write(i1 + 'particleNodes={}# Stores particle nodes\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '#Light Count\\n')\n    out_file.write(i1 + 'ambientCount=0\\n')\n    out_file.write(i1 + 'directionalCount=0\\n')\n    out_file.write(i1 + 'pointCount=0\\n')\n    out_file.write(i1 + 'spotCount=0\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '#Lighting Attribute\\n')\n    out_file.write(i1 + 'lightAttrib = LightAttrib.makeAllOff()# Initialize lighting\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'CollisionHandler=CollisionHandlerEvent()# Setup a Collision Handler\\n')\n    out_file.write(i1 + '##########################################################################################################\\n')\n    out_file.write(i1 + '# Constructor: this is run first when you instantiate the SavedScene class\\n')\n    out_file.write(i1 + '##########################################################################################################\\n')\n    out_file.write(i1 + 'def __init__(self,loadmode=1,seParticleEffect=None,seParticles=None,executionpath=None):# loadmode 0 specifies that this file is being loaded by the scene editor and it passes its own versions of the particle fx modules\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'self.loadmode=loadmode\\n')\n    out_file.write(i2 + 'self.seParticleEffect=seParticleEffect\\n')\n    out_file.write(i2 + 'self.seParticles=seParticles\\n')\n    out_file.write(i2 + 'self.executionpath=executionpath\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'base.enableParticles()# Enable Particle effects\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'self.cTrav = CollisionTraverser() # Setup a traverser for collisions\\n')\n    out_file.write(i2 + 'base.cTrav = self.cTrav\\n')\n    out_file.write(i2 + 'self.CollisionHandler.setInPattern(\"enter%in\")# The message to be raised when something enters a collision node\\n')\n    out_file.write(i2 + 'self.CollisionHandler.setOutPattern(\"exit%in\")# The message to be raised when something exits a collision node\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the models\\n')\n    out_file.write(i2 + '# To access these models:\\n')\n    out_file.write(i2 + '# theScene.ModelDic[\"\\'Model_Name\"\\']\\n')\n    out_file.write(i2 + '# where theScene is the SavedScene class instance\\n')\n    out_file.write(i2 + '# Properties saved include:\\n')\n    out_file.write(i2 + '# Transformations\\n')\n    out_file.write(i2 + '# Alpha and color\\n')\n    out_file.write(i2 + '# Parent and child information\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for model in AllScene.ModelDic:\n        out_file.write('\\n')\n        modelS = str(model)\n        if 1:\n            out_file.write(i2 + \"# Loading model's egg file\\n\")\n            newpath = dirname + '/' + AllScene.ModelRefDic[model].getBasename()\n            newpathF = Filename(newpath)\n            newpathSpecific = newpathF.toOsSpecific()\n            fnamelist = []\n            modelData = EggData()\n            modelData.read(AllScene.ModelRefDic[model])\n            textures = EggTextureCollection()\n            textures.findUsedTextures(modelData)\n            for index in range(textures.getNumTextures()):\n                texture = textures.getTexture(index)\n                texfilename = texture.getFilename()\n                fnamelist.append(texfilename.getFullpath())\n                oldFilename = Filename(Filename(AllScene.ModelRefDic[model].getDirname()), texfilename)\n                if not oldFilename.isRegularFile():\n                    if texfilename.resolveFilename(getTexturePath(), ''):\n                        oldFilename = texfilename\n                oldtexpath = oldFilename.toOsSpecific()\n                newtexpath = dirname + '/' + texfilename.getBasename()\n                newtexpathF = Filename(newtexpath)\n                newtexpathSpecific = newtexpathF.toOsSpecific()\n                print('TEXTURE SAVER:: copying' + oldtexpath + ' to ' + newtexpathSpecific)\n                if oldtexpath != newtexpathSpecific:\n                    shutil.copyfile(oldtexpath, newtexpathSpecific)\n            oldModelpath = AllScene.ModelRefDic[model].toOsSpecific()\n            print('FILESAVER:: copying from ' + AllScene.ModelRefDic[model].toOsSpecific() + 'to' + newpathSpecific)\n            if oldModelpath != newpathSpecific:\n                shutil.copyfile(oldModelpath, newpathSpecific)\n            e = EggData()\n            e.read(AllScene.ModelRefDic[model])\n            etc = EggTextureCollection()\n            etc.extractTextures(e)\n            for index in range(len(fnamelist)):\n                print(fnamelist[index])\n                tex = etc.findFilename(Filename(fnamelist[index]))\n                fn = Filename(tex.getFilename())\n                fn.setDirname('')\n                tex.setFilename(fn)\n                e.writeEgg(Filename.fromOsSpecific(newpathSpecific))\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + modelS + \"=loader.loadModel('\" + self.savepath + '/' + AllScene.ModelRefDic[model].getBasename() + \"')\\n\")\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.' + modelS + \"=loader.loadModel(self.executionpath + '/\" + AllScene.ModelRefDic[model].getBasename() + \"')\\n\")\n            out_file.write('\\n')\n            out_file.write(i2 + '# Transforming the model\\n')\n            out_file.write(i2 + 'self.' + modelS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.ModelDic[model].getX(), AllScene.ModelDic[model].getY(), AllScene.ModelDic[model].getZ(), AllScene.ModelDic[model].getH(), AllScene.ModelDic[model].getP(), AllScene.ModelDic[model].getR(), AllScene.ModelDic[model].getSx(), AllScene.ModelDic[model].getSy(), AllScene.ModelDic[model].getSz()))\n            if AllScene.ModelDic[model].hasTransparency():\n                out_file.write('\\n')\n                out_file.write(i2 + '# Alpha\\n')\n                out_file.write(i2 + 'self.' + modelS + '.setTransparency(1)\\n')\n                clr = AllScene.ModelDic[model].getColor()\n                out_file.write(i2 + 'self.' + modelS + '.setColor(%.4f,%.4f,%.4f,%.4f)\\n' % (clr.getX(), clr.getY(), clr.getZ(), clr.getW()))\n            out_file.write('\\n')\n            out_file.write(i2 + '# Reparent To Render for now and later we update all the parentings\\n')\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(render)\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.ModelDic[\"Model_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + modelS + '.setTag(\"Metadata\",\"' + AllScene.ModelDic[model].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            out_file.write(i2 + \"self.ModelDic['\" + modelS + \"']=self.\" + AllScene.ModelDic[model].getName() + '\\n')\n            out_file.write(i2 + \"self.ModelRefDic['\" + modelS + \"']='\" + AllScene.ModelRefDic[model].getBasename() + \"'\\n\")\n            out_file.write(i2 + \"self.ModelDic['\" + modelS + \"'].setName('\" + modelS + \"')\\n\")\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the Dummy Objects\\n')\n    out_file.write(i2 + '# To access the dummies\\n')\n    out_file.write(i2 + \"# theScene.dummyDict['Dummy_Name']\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for dummy in AllScene.dummyDict:\n        out_file.write('\\n')\n        dummyS = str(dummy)\n        if 1:\n            out_file.write(i2 + 'self.' + dummyS + '=loader.loadModel(\"models/misc/sphere\")\\n')\n            out_file.write(i2 + '# Transforming the Dummy\\n')\n            out_file.write(i2 + 'self.' + dummyS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.dummyDict[dummy].getX(), AllScene.dummyDict[dummy].getY(), AllScene.dummyDict[dummy].getZ(), AllScene.dummyDict[dummy].getH(), AllScene.dummyDict[dummy].getP(), AllScene.dummyDict[dummy].getR(), AllScene.dummyDict[dummy].getSx(), AllScene.dummyDict[dummy].getSy(), AllScene.dummyDict[dummy].getSz()))\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"']=self.\" + AllScene.dummyDict[dummy].getName() + '\\n')\n            out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"'].setName('\" + dummyS + \"')\\n\")\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.dummyDict[\"Dummy_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + dummyS + '.setTag(\"Metadata\",\"' + AllScene.dummyDict[dummy].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the Actors and animations\\n')\n    out_file.write(i2 + '# To access the Actors\\n')\n    out_file.write(i2 + \"# theScene.ActorDic['Actor_Name']\\n\")\n    out_file.write(i2 + \"# theScene.ActorDic['Actor_Name'].play('Animation_Name')\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for actor in AllScene.ActorDic:\n        out_file.write('\\n')\n        actorS = str(actor)\n        if 1:\n            newpath = dirname + '/' + AllScene.ActorRefDic[actor].getBasename()\n            newpathF = Filename(newpath)\n            newpathSpecific = newpathF.toOsSpecific()\n            actorfnamelist = []\n            actorData = EggData()\n            actorData.read(AllScene.ActorRefDic[actor])\n            textures = EggTextureCollection()\n            textures.findUsedTextures(actorData)\n            for index in range(textures.getNumTextures()):\n                texture = textures.getTexture(index)\n                texfilename = texture.getFilename()\n                actorfnamelist.append(texfilename.getFullpath())\n                oldFilename = Filename(Filename(AllScene.ActorRefDic[actor].getDirname()), texfilename)\n                if not oldFilename.isRegularFile():\n                    if texfilename.resolveFilename(getTexturePath(), ''):\n                        oldFilename = texfilename\n                oldtexpath = oldFilename.toOsSpecific()\n                newtexpath = dirname + '/' + texfilename.getBasename()\n                newtexpathF = Filename(newtexpath)\n                newtexpathSpecific = newtexpathF.toOsSpecific()\n                print('TEXTURE SAVER:: copying' + oldtexpath + ' to ' + newtexpathSpecific)\n                if oldtexpath != newtexpathSpecific:\n                    shutil.copyfile(oldtexpath, newtexpathSpecific)\n            oldActorpath = AllScene.ActorRefDic[actor].toOsSpecific()\n            print('FILESAVER:: copying from ' + AllScene.ActorRefDic[actor].toOsSpecific() + 'to' + newpathSpecific)\n            if oldActorpath != newpathSpecific:\n                shutil.copyfile(oldActorpath, newpathSpecific)\n            e = EggData()\n            e.read(AllScene.ActorRefDic[actor])\n            etc = EggTextureCollection()\n            etc.extractTextures(e)\n            for index in range(len(actorfnamelist)):\n                print(actorfnamelist[index])\n                tex = etc.findFilename(Filename(actorfnamelist[index]))\n                fn = Filename(tex.getFilename())\n                fn.setDirname('')\n                tex.setFilename(fn)\n                e.writeEgg(Filename.fromOsSpecific(newpathSpecific))\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + \"=Actor.Actor('\" + self.savepath + '/' + AllScene.ActorRefDic[actor].getBasename() + \"')\\n\")\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + \"=Actor.Actor(self.executionpath + '/\" + AllScene.ActorRefDic[actor].getBasename() + \"')\\n\")\n            out_file.write(i2 + '# Transforming the Actor\\n')\n            out_file.write(i2 + 'self.' + actorS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.ActorDic[actor].getX(), AllScene.ActorDic[actor].getY(), AllScene.ActorDic[actor].getZ(), AllScene.ActorDic[actor].getH(), AllScene.ActorDic[actor].getP(), AllScene.ActorDic[actor].getR(), AllScene.ActorDic[actor].getSx(), AllScene.ActorDic[actor].getSy(), AllScene.ActorDic[actor].getSz()))\n            if AllScene.ActorDic[actor].hasTransparency():\n                out_file.write(i2 + '# Alpha\\n')\n                out_file.write(i2 + 'self.' + actorS + '.setTransparency(1)\\n')\n                clr = AllScene.ActorDic[actor].getColor()\n                out_file.write(i2 + 'self.' + actorS + '.setColor(%.4f,%.4f,%.4f,%.4f)\\n' % (clr.getX(), clr.getY(), clr.getZ(), clr.getW()))\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(render)\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.ActorDic[\"Actor_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + actorS + '.setTag(\"Metadata\",\"' + AllScene.ActorDic[actor].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            ActorAnimations = AllScene.getAnimationDictFromActor(actor)\n            ActorAnimationsInvoke = {}\n            if ActorAnimations != {}:\n                for animation in ActorAnimations:\n                    if not animation is None:\n                        print('ACTOR ANIMATIONS:' + ActorAnimations[animation])\n                        oldAnimPath = Filename(ActorAnimations[animation])\n                        oldAnim = oldAnimPath.toOsSpecific()\n                        dirOS = Filename(dirname)\n                        newAnim = dirOS.toOsSpecific() + '\\\\' + oldAnimPath.getBasename()\n                        print('ACTOR ANIM SAVER:: Comparing' + oldAnim + 'and' + newAnim)\n                        if oldAnim != newAnim:\n                            shutil.copyfile(oldAnim, newAnim)\n                        newAnimF = Filename.fromOsSpecific(newAnim)\n                        ActorAnimationsInvoke[animation] = 'self.executionpath +' + '/' + newAnimF.getBasename()\n                        ActorAnimations[animation] = self.savepath + '/' + newAnimF.getBasename()\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + '.loadAnims(' + str(ActorAnimations) + ')\\n')\n            out_file.write(i2 + 'else:\\n')\n            theloadAnimString = str(ActorAnimationsInvoke)\n            print('LOAD ANIM STRING BEFORE' + theloadAnimString)\n            theloadAnimString = theloadAnimString.replace(\"'self.executionpath +\", \"self.executionpath + '\")\n            print('LOAD ANIM STRING AFTER' + theloadAnimString)\n            out_file.write(i2 + i1 + 'self.' + actorS + '.loadAnims(' + theloadAnimString + ')\\n')\n            out_file.write(i2 + \"self.ActorDic['\" + actorS + \"']=self.\" + AllScene.ActorDic[actor].getName() + '\\n')\n            out_file.write(i2 + \"self.ActorRefDic['\" + actorS + \"']='\" + AllScene.ActorRefDic[actor].getBasename() + \"'\\n\")\n            out_file.write(i2 + \"self.ActorDic['\" + actorS + \"'].setName('\" + actorS + \"')\\n\")\n            if actor in AllScene.blendAnimDict:\n                out_file.write(i2 + 'self.blendAnimDict[\"' + actorS + '\"]=' + str(AllScene.blendAnimDict[actor]) + '\\n')\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for setting up Collision Nodes\\n')\n    out_file.write(i2 + '# To use collision detection:\\n')\n    out_file.write(i2 + '# You must set up your own bitmasking and event handlers, the traverser \"cTrav\" is created for you at the top\\n')\n    out_file.write(i2 + '# The collision nodes are stored in collisionDict\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for collnode in AllScene.collisionDict:\n        collnodeS = str(collnode)\n        solid = AllScene.collisionDict[collnode].node().getSolid(0)\n        nodetype = solid.getType().getName()\n        if nodetype == 'CollisionSphere':\n            out_file.write(i2 + 'collSolid=CollisionSphere(%.3f,%.3f,%.3f,%.3f)\\n' % (solid.getCenter().getX(), solid.getCenter().getY(), solid.getCenter().getZ(), solid.getRadius()))\n            pass\n        elif nodetype == 'CollisionPolygon':\n            ax = AllScene.collisionDict[collnode].getTag('A_X')\n            ay = AllScene.collisionDict[collnode].getTag('A_Y')\n            az = AllScene.collisionDict[collnode].getTag('A_Z')\n            bx = AllScene.collisionDict[collnode].getTag('B_X')\n            by = AllScene.collisionDict[collnode].getTag('B_Y')\n            bz = AllScene.collisionDict[collnode].getTag('B_Z')\n            cx = AllScene.collisionDict[collnode].getTag('C_X')\n            cy = AllScene.collisionDict[collnode].getTag('C_Y')\n            cz = AllScene.collisionDict[collnode].getTag('C_Z')\n            out_file.write(i2 + 'pointA =  Point3(' + ax + ',' + ay + ',' + az + ')\\n')\n            out_file.write(i2 + 'pointB =  Point3(' + bx + ',' + by + ',' + bz + ')\\n')\n            out_file.write(i2 + 'pointC =  Point3(' + cx + ',' + cy + ',' + cz + ')\\n')\n            out_file.write(i2 + 'collSolid=CollisionPolygon(pointA, pointB, pointC)\\n')\n            pass\n        elif nodetype == 'CollisionSegment':\n            A = AllScene.collisionDict[collnode].node().getSolid(0).getPointA()\n            B = AllScene.collisionDict[collnode].node().getSolid(0).getPointB()\n            out_file.write(i2 + 'pointA =  Point3(%.3f,%.3f,%.3f)\\n' % (A.getX(), A.getY(), A.getZ()))\n            out_file.write(i2 + 'pointB =  Point3(%.3f,%.3f,%.3f)\\n' % (B.getX(), B.getY(), B.getZ()))\n            out_file.write(i2 + 'collSolid=CollisionSegment()\\n')\n            out_file.write(i2 + 'collSolid.setPointA(pointA)\\n')\n            out_file.write(i2 + 'collSolid.setFromLens(base.cam.node(),Point2(-1,1))\\n')\n            out_file.write(i2 + 'collSolid.setPointB(pointB)\\n')\n            pass\n        elif nodetype == 'CollisionRay':\n            P = AllScene.collisionDict[collnode].node().getSolid(0).getOrigin()\n            V = AllScene.collisionDict[collnode].node().getSolid(0).getDirection()\n            out_file.write(i2 + 'point=Point3(%.3f,%.3f,%.3f)\\n' % (P.getX(), P.getY(), P.getZ()))\n            out_file.write(i2 + 'vector=Vec3(%.3f,%.3f,%.3f)\\n' % (V.getX(), V.getY(), V.getZ()))\n            out_file.write(i2 + 'collSolid=CollisionRay()\\n')\n            out_file.write(i2 + 'collSolid.setOrigin(point)\\n')\n            out_file.write(i2 + 'collSolid.setDirection(vector)\\n')\n            pass\n        else:\n            print('Invalid Collision Node: ' + nodetype)\n        out_file.write('\\n')\n        out_file.write(i2 + 'self.' + collnodeS + '_Node' + '=CollisionNode(\"' + collnodeS + '\")\\n')\n        out_file.write(i2 + 'self.' + collnodeS + '_Node' + '.addSolid(collSolid)\\n')\n        out_file.write(i2 + 'base.cTrav.addCollider(self.' + collnodeS + '_Node,self.CollisionHandler)\\n')\n        out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for Lighting\\n')\n    out_file.write(i2 + '# To manipulated lights:\\n')\n    out_file.write(i2 + \"# Manipulate the light node in theScene.LightNodes['Light_Name']\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    LightList = AllScene.lightManager.getLightNodeList()\n    for light in LightList:\n        type = light.getType()\n        if type == 'ambient':\n            out_file.write(i2 + '# Ambient Light\\n')\n            out_file.write(i2 + 'self.ambientCount += 1\\n')\n            out_file.write(i2 + \"alight = AmbientLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'directional':\n            out_file.write(i2 + '# Directional Light\\n')\n            out_file.write(i2 + 'self.directionalCount += 1\\n')\n            out_file.write(i2 + \"alight = DirectionalLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setHpr(Vec3(' + str(light.getH()) + ',' + str(light.getP()) + ',' + str(light.getR()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'point':\n            out_file.write(i2 + '# Point Light\\n')\n            out_file.write(i2 + 'self.pointCount += 1\\n')\n            out_file.write(i2 + \"alight = PointLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setAttenuation(Vec3(' + str(light.getAttenuation().getX()) + ',' + str(light.getAttenuation().getY()) + ',' + str(light.getAttenuation().getZ()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'spot':\n            out_file.write(i2 + '# Spot Light\\n')\n            out_file.write(i2 + 'self.spotCount += 1\\n')\n            out_file.write(i2 + \"alight = Spotlight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alens = PerspectiveLens()\\n')\n            out_file.write(i2 + 'alight.setLens(alens)\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setAttenuation(Vec3(' + str(light.getAttenuation().getX()) + ',' + str(light.getAttenuation().getY()) + ',' + str(light.getAttenuation().getZ()) + '))\\n')\n            out_file.write(i2 + 'alight.setExponent(' + str(light.getExponent()) + ')\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setHpr(Vec3(' + str(light.getH()) + ',' + str(light.getP()) + ',' + str(light.getR()) + '))\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        else:\n            out_file.write(i2 + \"print 'Invalid light type'\")\n            out_file.write(i2 + 'return None')\n        out_file.write('\\n')\n    out_file.write(i2 + '# Enable Ligthing\\n')\n    out_file.write(i2 + 'render.node().setAttrib(self.lightAttrib)\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '# Load Particle Effects. The parameters to this function are to allow us to use our modified versions of the Particle Effects modules when loading this file with the level editor\\n')\n    out_file.write(i2 + 'self.starteffects(self.loadmode,self.seParticleEffect,self.seParticles)\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '# Save Camera Settings\\n')\n    out_file.write(i2 + 'camera.setX(' + str(camera.getX()) + ')\\n')\n    out_file.write(i2 + 'camera.setY(' + str(camera.getY()) + ')\\n')\n    out_file.write(i2 + 'camera.setZ(' + str(camera.getZ()) + ')\\n')\n    out_file.write(i2 + 'camera.setH(' + str(camera.getH()) + ')\\n')\n    out_file.write(i2 + 'camera.setP(' + str(camera.getP()) + ')\\n')\n    out_file.write(i2 + 'camera.setR(' + str(camera.getR()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setNear(' + str(camera.getChild(0).node().getLens().getNear()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFar(' + str(camera.getChild(0).node().getLens().getFar()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFov(VBase2(%.5f,%.5f))\\n' % (camera.getChild(0).node().getLens().getHfov(), camera.getChild(0).node().getLens().getVfov()))\n    FilmSize = camera.getChild(0).node().getLens().getFilmSize()\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFilmSize(%.3f,%.3f)\\n' % (FilmSize.getX(), FilmSize.getY()))\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFocalLength(' + str(camera.getChild(0).node().getLens().getFocalLength()) + ')\\n')\n    out_file.write(i2 + 'camera.setTag(\"Metadata\",\"' + camera.getTag('Metadata') + '\")\\n')\n    out_file.write(i2 + 'camera.reparentTo(render)\\n')\n    out_file.write(i2 + 'base.disableMouse()\\n')\n    self.bgColor = base.getBackgroundColor()\n    out_file.write(i2 + 'base.setBackgroundColor(%.3f,%.3f,%.3f)\\n' % (self.bgColor.getX(), self.bgColor.getY(), self.bgColor.getZ()))\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Motion Paths\\n')\n    out_file.write(i2 + '# Using Mopaths:\\n')\n    out_file.write(i2 + '# theScene.curveIntervals[0].start() or .loop() will play curve with index 0\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for node in AllScene.curveDict:\n        curveCollection = AllScene.curveDict[node]\n        curvenumber = 0\n        for curve in curveCollection:\n            filestring = dirname + '\\\\' + str(node) + '_curve_' + str(curvenumber) + '.egg'\n            f = Filename.fromOsSpecific(filestring)\n            filestring = f.getBasename()\n            curve.writeEgg(f)\n            out_file.write(i2 + 'm=Mopath.Mopath()\\n')\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'm.loadFile(\"' + self.savepath + '/' + filestring + '\")\\n')\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'm.loadFile(self.executionpath + \"/' + filestring + '\")\\n')\n            out_file.write(i2 + 'mp=MopathInterval(m,self.' + str(node) + ')\\n')\n            out_file.write(i2 + 'self.curveIntervals.append(mp)\\n')\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.curveRefColl.append(\"' + self.savepath + '/' + filestring + '\")\\n')\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.curveRefColl.append(self.executionpath + \"/' + filestring + '\")\\n')\n            curvenumber = curvenumber + 1\n        out_file.write(i2 + 'self.curveIntervalsDict[\"' + str(node) + '\"]=self.curveIntervals\\n')\n        out_file.write(i2 + 'self.curveDict[\"' + str(node) + '\"]=self.curveRefColl\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Reparenting\\n')\n    out_file.write(i2 + '# A final pass is done on setting all the scenegraph hierarchy after all objects are laoded\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for model in AllScene.ModelDic:\n        modelS = str(model)\n        parent = AllScene.ModelDic[model].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.ModelDic['\" + modelS + \"']=self.\" + AllScene.ModelDic[model].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for dummy in AllScene.dummyDict:\n        dummyS = str(dummy)\n        parent = AllScene.dummyDict[dummy].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"']=self.\" + AllScene.dummyDict[dummy].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for actor in AllScene.ActorDic:\n        actorS = str(actor)\n        parent = AllScene.ActorDic[actor].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.ActorDic['\" + actorS + \"']=self.\" + AllScene.ActorDic[actor].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for collnode in AllScene.collisionDict:\n        collnodeS = str(collnode)\n        solid = AllScene.collisionDict[collnode].node().getSolid(0)\n        nodetype = solid.getType().getName()\n        parentname = AllScene.collisionDict[collnode].getParent().getName()\n        if parentname == 'render' or parentname == 'camera':\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=' + parentname + '.attachNewNode(self.' + collnodeS + '_Node)\\n')\n        elif parentname in AllScene.particleDict:\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=self.' + parentname + 'getEffect().attachNewNode(self.' + collnodeS + '_Node)\\n')\n        else:\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=self.' + parentname + '.attachNewNode(self.' + collnodeS + '_Node)\\n')\n        dictelem = AllScene.collisionDict[collnode]\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (dictelem.getX(), dictelem.getY(), dictelem.getZ(), dictelem.getH(), dictelem.getP(), dictelem.getR(), dictelem.getSx(), dictelem.getSy(), dictelem.getSz()))\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\"Metadata\",\"' + AllScene.collisionDict[collnode].getTag('Metadata') + '\")\\n')\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].show()\\n')\n        if nodetype == 'CollisionPolygon':\n            ax = float(AllScene.collisionDict[collnode].getTag('A_X'))\n            ay = float(AllScene.collisionDict[collnode].getTag('A_Y'))\n            az = float(AllScene.collisionDict[collnode].getTag('A_Z'))\n            bx = float(AllScene.collisionDict[collnode].getTag('B_X'))\n            by = float(AllScene.collisionDict[collnode].getTag('B_Y'))\n            bz = float(AllScene.collisionDict[collnode].getTag('B_Z'))\n            cx = float(AllScene.collisionDict[collnode].getTag('C_X'))\n            cy = float(AllScene.collisionDict[collnode].getTag('C_Y'))\n            cz = float(AllScene.collisionDict[collnode].getTag('C_Z'))\n            out_file.write(i2 + 'pointA=Point3(%.3f,%.3f,%.3f)\\n' % (ax, ay, az))\n            out_file.write(i2 + 'pointB=Point3(%.3f,%.3f,%.3f)\\n' % (bx, by, bz))\n            out_file.write(i2 + 'pointC=Point3(%.3f,%.3f,%.3f)\\n' % (cx, cy, cz))\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_X\\',\\'%f\\'%pointA.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_Y\\',\\'%f\\'%pointA.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_Z\\',\\'%f\\'%pointA.getZ())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_X\\',\\'%f\\'%pointB.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_Y\\',\\'%f\\'%pointB.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_Z\\',\\'%f\\'%pointB.getZ())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_X\\',\\'%f\\'%pointC.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_Y\\',\\'%f\\'%pointC.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_Z\\',\\'%f\\'%pointC.getZ())\\n')\n        out_file.write(i2 + '\\n')\n    for effect in AllScene.particleDict:\n        parent = AllScene.particleNodes[effect].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.particleDict[\"' + str(effect) + '\"].reparentTo(' + parent + ')\\n')\n        else:\n            out_file.write(i2 + 'self.particleDict[\"' + str(effect) + '\"].reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + '\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Particle Effects\\n')\n    out_file.write(i2 + '# Using Particles:\\n')\n    out_file.write(i2 + '# theScene.enableeffect(\"Effect_Name\")\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write(i1 + 'def starteffects(self,mode,seParticleEffect=None,seParticles=None):\\n')\n    for effect in AllScene.particleDict:\n        effectS = str(effect)\n        out_file.write(i2 + 'self.' + effectS + '=' + effectS + '(mode,seParticleEffect,seParticles)\\n')\n        out_file.write(i2 + 'effect=self.' + effectS + '.getEffect()\\n')\n        out_file.write(i2 + 'self.particleDict[\"' + effectS + '\"]=effect\\n')\n        out_file.write(i2 + 'effect.reparentTo(render)\\n')\n        thenode = AllScene.particleNodes[effect]\n        out_file.write(i2 + 'self.particleDict[\"' + effectS + '\"].setPosHprScale(%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f)\\n' % (thenode.getX(), thenode.getY(), thenode.getZ(), thenode.getH(), thenode.getP(), thenode.getR(), thenode.getSx(), thenode.getSy(), thenode.getSz()))\n        out_file.write('\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def enableeffect(self,effect_name):\\n')\n    out_file.write(i2 + 'self.particleDict[effect_name].enable()\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def disableeffect(self,effect_name):\\n')\n    out_file.write(i2 + 'self.particleDict[effect_name].disable()\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Animation Blending\\n')\n    out_file.write(i2 + '# Using blending:\\n')\n    out_file.write(i2 + '# theScene.playBlendAnim(actor,blendname)\\n')\n    out_file.write(i2 + '# theScene.stopBlendAnim(actor,blendname)\\n')\n    out_file.write(i2 + '# theScene.changeBlendAnim(actor,blendname,blend_amount)\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write(i1 + 'def playBlendAnim(self,actor,blendName,loop=0):\\n')\n    out_file.write(i2 + 'actor.enableBlend()\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'actor.setControlEffect(blendList[0],blendList[2])\\n')\n    out_file.write(i2 + 'actor.setControlEffect(blendList[1],1.0-blendList[2])\\n')\n    out_file.write(i2 + 'if(loop):\\n')\n    out_file.write(i2 + i1 + 'actor.loop(blendList[0])\\n')\n    out_file.write(i2 + i1 + 'actor.loop(blendList[1])\\n')\n    out_file.write(i2 + 'else:\\n')\n    out_file.write(i2 + i1 + 'actor.start(blendList[0])\\n')\n    out_file.write(i2 + i1 + 'actor.start(blendList[1])\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def stopBlendAnim(self,actor,blendName):\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'actor.stop(blendList[0])\\n')\n    out_file.write(i2 + 'actor.stop(blendList[1])\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def changeBlending(self,actor,blendName,blending):\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'blendList[2]=blending\\n')\n    out_file.write(i2 + 'self.blendAnimDict[actor.getName()]={blendName:[blendList[0],blendList[1],blending]}\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Hide and Show Methods\\n')\n    out_file.write(i2 + '# These will help you hide/show dummies, collision solids, effect nodes etc.\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideDummies(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for dummy in self.dummyDict:\\n')\n    out_file.write(i2 + i1 + 'self.dummyDict[dummy].reparentTo(hidden)\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideCollSolids(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for collSolid in self.collisionDict:\\n')\n    out_file.write(i2 + i1 + 'self.collisionDict[collSolid].hide()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideEffectNodes(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for effectnode in self.particleNodes:\\n')\n    out_file.write(i2 + i1 + 'self.particleNodes[effectnode].hide()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showDummies(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for dummy in self.dummyDict:\\n')\n    out_file.write(i2 + i1 + 'self.dummyDict[dummy].reparentTo(hidden)\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showCollSolids(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for collSolid in self.collisionDict:\\n')\n    out_file.write(i2 + i1 + 'self.collisionDict[collSolid].show()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showEffectNodes(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for effectnode in self.particleNodes:\\n')\n    out_file.write(i2 + i1 + 'self.particleNodes[effectnode].show()\\n\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Particle Effects\\n')\n    out_file.write(i2 + '# This is where effect parameters are saved in a class\\n')\n    out_file.write(i2 + '# The class is then instantiated in the starteffects method and appended to the dictionaries\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for effect in AllScene.particleDict:\n        out_file.write('\\n\\n')\n        out_file.write('class ' + str(effect) + ':\\n')\n        out_file.write(i1 + 'def __init__(self,mode=1,seParticleEffect=None,seParticles=None):\\n')\n        out_file.write(i2 + 'if(mode==0):\\n')\n        out_file.write(i2 + i1 + 'self.effect=seParticleEffect.ParticleEffect()\\n')\n        out_file.write(i2 + 'else:\\n')\n        out_file.write(i2 + i1 + 'self.effect=ParticleEffect.ParticleEffect()\\n')\n        AllScene.particleDict[effect].AppendConfig(out_file)\n        out_file.write('\\n\\n')\n        out_file.write(i1 + 'def starteffect(self):\\n')\n        out_file.write(i2 + 'pass\\n')\n        out_file.write('\\n\\n')\n        out_file.write(i1 + 'def stopeffect(self):\\n')\n        out_file.write(i2 + 'pass\\n\\n')\n        out_file.write(i1 + 'def getEffect(self):\\n')\n        out_file.write(i2 + 'return self.effect\\n\\n')\n    out_file.close()",
            "def SaveFile(self, AllScene, filename, dirname, reSaveFlag=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    i1 = '    '\n    i2 = i1 + i1\n    out_file = open(filename, 'w')\n    print('dirname:' + dirname)\n    if not os.path.isdir(dirname):\n        os.mkdir(dirname)\n    savepathname = Filename(filename)\n    self.savepath = savepathname.getBasenameWoExtension()\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# Auto Generated Code by Scene Editor\\n')\n    out_file.write('# Edit with caution\\n')\n    out_file.write('# Using this file in your code:\\n')\n    out_file.write('# For example, if you have named this file as \"myscene.py\"\\n')\n    out_file.write('# Do the following:\\n')\n    out_file.write('# from myscene import * \\n')\n    out_file.write('# theScene=SavedScene() #instantiate the class\\n')\n    out_file.write('# IMPORTANT: All the documentation below refers to \"theScene\" as the instance of SavedScene()\\n')\n    out_file.write('##########################################################################################################\\n\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# Import Panda Modules\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('from direct.directbase.DirectStart import * # Core functionality for running the \"show\"\\n')\n    out_file.write('from direct.actor import Actor # Importing models with animations\\n')\n    out_file.write('from direct.directutil import Mopath # Motion Paths\\n')\n    out_file.write('from direct.interval import MopathInterval # Motion Paths\\n')\n    out_file.write('from direct.interval.IntervalGlobal import * # Intervals for interpolation, sequencing and parallelization\\n')\n    out_file.write('from direct.particles import ParticleEffect # Particle Systems\\n')\n    out_file.write('from direct.particles import ForceGroup # Forces acting on Particles\\n')\n    out_file.write('from direct.particles import Particles\\n\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# This class stores the entire scene\\n')\n    out_file.write('##########################################################################################################\\n\\n')\n    out_file.write('class SavedScene(DirectObject): # We inherit from DirectObject so that we can use self.accept method to catch messages\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '# These dictionaries are required for re-loading a scene in the editor\\n')\n    out_file.write(i1 + '# They can be used to access the objects as well\\n\\n')\n    out_file.write(i1 + 'ModelDic={}# Stores all the models and static geometry\\n')\n    out_file.write(i1 + 'ModelRefDic={}# Stores the paths to the models\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'ActorDic={}# Stores all the actors\\n')\n    out_file.write(i1 + 'ActorRefDic={}# Stores the paths to the actors\\n')\n    out_file.write(i1 + 'ActorAnimsDic={}# Stores the animations for each actor\\n')\n    out_file.write(i1 + 'blendAnimDict={}# Stores all the blended animations\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'LightDict={}# Stores all the lights\\n')\n    out_file.write(i1 + 'LightTypes={}# Stores types for the lights\\n')\n    out_file.write(i1 + 'LightNodes={}# Stores the actual nodes for the lights\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'dummyDict={}# Stores dummies\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'collisionDict={}# Stores Collision information\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'curveDict={}# Stores Mopath information\\n')\n    out_file.write(i1 + 'curveIntervals=[]# Stores list of mopath intervals\\n')\n    out_file.write(i1 + 'curveRefColl=[]# Stores paths to mopaths\\n')\n    out_file.write(i1 + 'curveIntervalsDict={}# Stores mopath intervals\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'particleDict={}# Stores particles\\n')\n    out_file.write(i1 + 'particleNodes={}# Stores particle nodes\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '#Light Count\\n')\n    out_file.write(i1 + 'ambientCount=0\\n')\n    out_file.write(i1 + 'directionalCount=0\\n')\n    out_file.write(i1 + 'pointCount=0\\n')\n    out_file.write(i1 + 'spotCount=0\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '#Lighting Attribute\\n')\n    out_file.write(i1 + 'lightAttrib = LightAttrib.makeAllOff()# Initialize lighting\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'CollisionHandler=CollisionHandlerEvent()# Setup a Collision Handler\\n')\n    out_file.write(i1 + '##########################################################################################################\\n')\n    out_file.write(i1 + '# Constructor: this is run first when you instantiate the SavedScene class\\n')\n    out_file.write(i1 + '##########################################################################################################\\n')\n    out_file.write(i1 + 'def __init__(self,loadmode=1,seParticleEffect=None,seParticles=None,executionpath=None):# loadmode 0 specifies that this file is being loaded by the scene editor and it passes its own versions of the particle fx modules\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'self.loadmode=loadmode\\n')\n    out_file.write(i2 + 'self.seParticleEffect=seParticleEffect\\n')\n    out_file.write(i2 + 'self.seParticles=seParticles\\n')\n    out_file.write(i2 + 'self.executionpath=executionpath\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'base.enableParticles()# Enable Particle effects\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'self.cTrav = CollisionTraverser() # Setup a traverser for collisions\\n')\n    out_file.write(i2 + 'base.cTrav = self.cTrav\\n')\n    out_file.write(i2 + 'self.CollisionHandler.setInPattern(\"enter%in\")# The message to be raised when something enters a collision node\\n')\n    out_file.write(i2 + 'self.CollisionHandler.setOutPattern(\"exit%in\")# The message to be raised when something exits a collision node\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the models\\n')\n    out_file.write(i2 + '# To access these models:\\n')\n    out_file.write(i2 + '# theScene.ModelDic[\"\\'Model_Name\"\\']\\n')\n    out_file.write(i2 + '# where theScene is the SavedScene class instance\\n')\n    out_file.write(i2 + '# Properties saved include:\\n')\n    out_file.write(i2 + '# Transformations\\n')\n    out_file.write(i2 + '# Alpha and color\\n')\n    out_file.write(i2 + '# Parent and child information\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for model in AllScene.ModelDic:\n        out_file.write('\\n')\n        modelS = str(model)\n        if 1:\n            out_file.write(i2 + \"# Loading model's egg file\\n\")\n            newpath = dirname + '/' + AllScene.ModelRefDic[model].getBasename()\n            newpathF = Filename(newpath)\n            newpathSpecific = newpathF.toOsSpecific()\n            fnamelist = []\n            modelData = EggData()\n            modelData.read(AllScene.ModelRefDic[model])\n            textures = EggTextureCollection()\n            textures.findUsedTextures(modelData)\n            for index in range(textures.getNumTextures()):\n                texture = textures.getTexture(index)\n                texfilename = texture.getFilename()\n                fnamelist.append(texfilename.getFullpath())\n                oldFilename = Filename(Filename(AllScene.ModelRefDic[model].getDirname()), texfilename)\n                if not oldFilename.isRegularFile():\n                    if texfilename.resolveFilename(getTexturePath(), ''):\n                        oldFilename = texfilename\n                oldtexpath = oldFilename.toOsSpecific()\n                newtexpath = dirname + '/' + texfilename.getBasename()\n                newtexpathF = Filename(newtexpath)\n                newtexpathSpecific = newtexpathF.toOsSpecific()\n                print('TEXTURE SAVER:: copying' + oldtexpath + ' to ' + newtexpathSpecific)\n                if oldtexpath != newtexpathSpecific:\n                    shutil.copyfile(oldtexpath, newtexpathSpecific)\n            oldModelpath = AllScene.ModelRefDic[model].toOsSpecific()\n            print('FILESAVER:: copying from ' + AllScene.ModelRefDic[model].toOsSpecific() + 'to' + newpathSpecific)\n            if oldModelpath != newpathSpecific:\n                shutil.copyfile(oldModelpath, newpathSpecific)\n            e = EggData()\n            e.read(AllScene.ModelRefDic[model])\n            etc = EggTextureCollection()\n            etc.extractTextures(e)\n            for index in range(len(fnamelist)):\n                print(fnamelist[index])\n                tex = etc.findFilename(Filename(fnamelist[index]))\n                fn = Filename(tex.getFilename())\n                fn.setDirname('')\n                tex.setFilename(fn)\n                e.writeEgg(Filename.fromOsSpecific(newpathSpecific))\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + modelS + \"=loader.loadModel('\" + self.savepath + '/' + AllScene.ModelRefDic[model].getBasename() + \"')\\n\")\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.' + modelS + \"=loader.loadModel(self.executionpath + '/\" + AllScene.ModelRefDic[model].getBasename() + \"')\\n\")\n            out_file.write('\\n')\n            out_file.write(i2 + '# Transforming the model\\n')\n            out_file.write(i2 + 'self.' + modelS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.ModelDic[model].getX(), AllScene.ModelDic[model].getY(), AllScene.ModelDic[model].getZ(), AllScene.ModelDic[model].getH(), AllScene.ModelDic[model].getP(), AllScene.ModelDic[model].getR(), AllScene.ModelDic[model].getSx(), AllScene.ModelDic[model].getSy(), AllScene.ModelDic[model].getSz()))\n            if AllScene.ModelDic[model].hasTransparency():\n                out_file.write('\\n')\n                out_file.write(i2 + '# Alpha\\n')\n                out_file.write(i2 + 'self.' + modelS + '.setTransparency(1)\\n')\n                clr = AllScene.ModelDic[model].getColor()\n                out_file.write(i2 + 'self.' + modelS + '.setColor(%.4f,%.4f,%.4f,%.4f)\\n' % (clr.getX(), clr.getY(), clr.getZ(), clr.getW()))\n            out_file.write('\\n')\n            out_file.write(i2 + '# Reparent To Render for now and later we update all the parentings\\n')\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(render)\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.ModelDic[\"Model_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + modelS + '.setTag(\"Metadata\",\"' + AllScene.ModelDic[model].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            out_file.write(i2 + \"self.ModelDic['\" + modelS + \"']=self.\" + AllScene.ModelDic[model].getName() + '\\n')\n            out_file.write(i2 + \"self.ModelRefDic['\" + modelS + \"']='\" + AllScene.ModelRefDic[model].getBasename() + \"'\\n\")\n            out_file.write(i2 + \"self.ModelDic['\" + modelS + \"'].setName('\" + modelS + \"')\\n\")\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the Dummy Objects\\n')\n    out_file.write(i2 + '# To access the dummies\\n')\n    out_file.write(i2 + \"# theScene.dummyDict['Dummy_Name']\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for dummy in AllScene.dummyDict:\n        out_file.write('\\n')\n        dummyS = str(dummy)\n        if 1:\n            out_file.write(i2 + 'self.' + dummyS + '=loader.loadModel(\"models/misc/sphere\")\\n')\n            out_file.write(i2 + '# Transforming the Dummy\\n')\n            out_file.write(i2 + 'self.' + dummyS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.dummyDict[dummy].getX(), AllScene.dummyDict[dummy].getY(), AllScene.dummyDict[dummy].getZ(), AllScene.dummyDict[dummy].getH(), AllScene.dummyDict[dummy].getP(), AllScene.dummyDict[dummy].getR(), AllScene.dummyDict[dummy].getSx(), AllScene.dummyDict[dummy].getSy(), AllScene.dummyDict[dummy].getSz()))\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"']=self.\" + AllScene.dummyDict[dummy].getName() + '\\n')\n            out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"'].setName('\" + dummyS + \"')\\n\")\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.dummyDict[\"Dummy_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + dummyS + '.setTag(\"Metadata\",\"' + AllScene.dummyDict[dummy].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the Actors and animations\\n')\n    out_file.write(i2 + '# To access the Actors\\n')\n    out_file.write(i2 + \"# theScene.ActorDic['Actor_Name']\\n\")\n    out_file.write(i2 + \"# theScene.ActorDic['Actor_Name'].play('Animation_Name')\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for actor in AllScene.ActorDic:\n        out_file.write('\\n')\n        actorS = str(actor)\n        if 1:\n            newpath = dirname + '/' + AllScene.ActorRefDic[actor].getBasename()\n            newpathF = Filename(newpath)\n            newpathSpecific = newpathF.toOsSpecific()\n            actorfnamelist = []\n            actorData = EggData()\n            actorData.read(AllScene.ActorRefDic[actor])\n            textures = EggTextureCollection()\n            textures.findUsedTextures(actorData)\n            for index in range(textures.getNumTextures()):\n                texture = textures.getTexture(index)\n                texfilename = texture.getFilename()\n                actorfnamelist.append(texfilename.getFullpath())\n                oldFilename = Filename(Filename(AllScene.ActorRefDic[actor].getDirname()), texfilename)\n                if not oldFilename.isRegularFile():\n                    if texfilename.resolveFilename(getTexturePath(), ''):\n                        oldFilename = texfilename\n                oldtexpath = oldFilename.toOsSpecific()\n                newtexpath = dirname + '/' + texfilename.getBasename()\n                newtexpathF = Filename(newtexpath)\n                newtexpathSpecific = newtexpathF.toOsSpecific()\n                print('TEXTURE SAVER:: copying' + oldtexpath + ' to ' + newtexpathSpecific)\n                if oldtexpath != newtexpathSpecific:\n                    shutil.copyfile(oldtexpath, newtexpathSpecific)\n            oldActorpath = AllScene.ActorRefDic[actor].toOsSpecific()\n            print('FILESAVER:: copying from ' + AllScene.ActorRefDic[actor].toOsSpecific() + 'to' + newpathSpecific)\n            if oldActorpath != newpathSpecific:\n                shutil.copyfile(oldActorpath, newpathSpecific)\n            e = EggData()\n            e.read(AllScene.ActorRefDic[actor])\n            etc = EggTextureCollection()\n            etc.extractTextures(e)\n            for index in range(len(actorfnamelist)):\n                print(actorfnamelist[index])\n                tex = etc.findFilename(Filename(actorfnamelist[index]))\n                fn = Filename(tex.getFilename())\n                fn.setDirname('')\n                tex.setFilename(fn)\n                e.writeEgg(Filename.fromOsSpecific(newpathSpecific))\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + \"=Actor.Actor('\" + self.savepath + '/' + AllScene.ActorRefDic[actor].getBasename() + \"')\\n\")\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + \"=Actor.Actor(self.executionpath + '/\" + AllScene.ActorRefDic[actor].getBasename() + \"')\\n\")\n            out_file.write(i2 + '# Transforming the Actor\\n')\n            out_file.write(i2 + 'self.' + actorS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.ActorDic[actor].getX(), AllScene.ActorDic[actor].getY(), AllScene.ActorDic[actor].getZ(), AllScene.ActorDic[actor].getH(), AllScene.ActorDic[actor].getP(), AllScene.ActorDic[actor].getR(), AllScene.ActorDic[actor].getSx(), AllScene.ActorDic[actor].getSy(), AllScene.ActorDic[actor].getSz()))\n            if AllScene.ActorDic[actor].hasTransparency():\n                out_file.write(i2 + '# Alpha\\n')\n                out_file.write(i2 + 'self.' + actorS + '.setTransparency(1)\\n')\n                clr = AllScene.ActorDic[actor].getColor()\n                out_file.write(i2 + 'self.' + actorS + '.setColor(%.4f,%.4f,%.4f,%.4f)\\n' % (clr.getX(), clr.getY(), clr.getZ(), clr.getW()))\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(render)\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.ActorDic[\"Actor_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + actorS + '.setTag(\"Metadata\",\"' + AllScene.ActorDic[actor].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            ActorAnimations = AllScene.getAnimationDictFromActor(actor)\n            ActorAnimationsInvoke = {}\n            if ActorAnimations != {}:\n                for animation in ActorAnimations:\n                    if not animation is None:\n                        print('ACTOR ANIMATIONS:' + ActorAnimations[animation])\n                        oldAnimPath = Filename(ActorAnimations[animation])\n                        oldAnim = oldAnimPath.toOsSpecific()\n                        dirOS = Filename(dirname)\n                        newAnim = dirOS.toOsSpecific() + '\\\\' + oldAnimPath.getBasename()\n                        print('ACTOR ANIM SAVER:: Comparing' + oldAnim + 'and' + newAnim)\n                        if oldAnim != newAnim:\n                            shutil.copyfile(oldAnim, newAnim)\n                        newAnimF = Filename.fromOsSpecific(newAnim)\n                        ActorAnimationsInvoke[animation] = 'self.executionpath +' + '/' + newAnimF.getBasename()\n                        ActorAnimations[animation] = self.savepath + '/' + newAnimF.getBasename()\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + '.loadAnims(' + str(ActorAnimations) + ')\\n')\n            out_file.write(i2 + 'else:\\n')\n            theloadAnimString = str(ActorAnimationsInvoke)\n            print('LOAD ANIM STRING BEFORE' + theloadAnimString)\n            theloadAnimString = theloadAnimString.replace(\"'self.executionpath +\", \"self.executionpath + '\")\n            print('LOAD ANIM STRING AFTER' + theloadAnimString)\n            out_file.write(i2 + i1 + 'self.' + actorS + '.loadAnims(' + theloadAnimString + ')\\n')\n            out_file.write(i2 + \"self.ActorDic['\" + actorS + \"']=self.\" + AllScene.ActorDic[actor].getName() + '\\n')\n            out_file.write(i2 + \"self.ActorRefDic['\" + actorS + \"']='\" + AllScene.ActorRefDic[actor].getBasename() + \"'\\n\")\n            out_file.write(i2 + \"self.ActorDic['\" + actorS + \"'].setName('\" + actorS + \"')\\n\")\n            if actor in AllScene.blendAnimDict:\n                out_file.write(i2 + 'self.blendAnimDict[\"' + actorS + '\"]=' + str(AllScene.blendAnimDict[actor]) + '\\n')\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for setting up Collision Nodes\\n')\n    out_file.write(i2 + '# To use collision detection:\\n')\n    out_file.write(i2 + '# You must set up your own bitmasking and event handlers, the traverser \"cTrav\" is created for you at the top\\n')\n    out_file.write(i2 + '# The collision nodes are stored in collisionDict\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for collnode in AllScene.collisionDict:\n        collnodeS = str(collnode)\n        solid = AllScene.collisionDict[collnode].node().getSolid(0)\n        nodetype = solid.getType().getName()\n        if nodetype == 'CollisionSphere':\n            out_file.write(i2 + 'collSolid=CollisionSphere(%.3f,%.3f,%.3f,%.3f)\\n' % (solid.getCenter().getX(), solid.getCenter().getY(), solid.getCenter().getZ(), solid.getRadius()))\n            pass\n        elif nodetype == 'CollisionPolygon':\n            ax = AllScene.collisionDict[collnode].getTag('A_X')\n            ay = AllScene.collisionDict[collnode].getTag('A_Y')\n            az = AllScene.collisionDict[collnode].getTag('A_Z')\n            bx = AllScene.collisionDict[collnode].getTag('B_X')\n            by = AllScene.collisionDict[collnode].getTag('B_Y')\n            bz = AllScene.collisionDict[collnode].getTag('B_Z')\n            cx = AllScene.collisionDict[collnode].getTag('C_X')\n            cy = AllScene.collisionDict[collnode].getTag('C_Y')\n            cz = AllScene.collisionDict[collnode].getTag('C_Z')\n            out_file.write(i2 + 'pointA =  Point3(' + ax + ',' + ay + ',' + az + ')\\n')\n            out_file.write(i2 + 'pointB =  Point3(' + bx + ',' + by + ',' + bz + ')\\n')\n            out_file.write(i2 + 'pointC =  Point3(' + cx + ',' + cy + ',' + cz + ')\\n')\n            out_file.write(i2 + 'collSolid=CollisionPolygon(pointA, pointB, pointC)\\n')\n            pass\n        elif nodetype == 'CollisionSegment':\n            A = AllScene.collisionDict[collnode].node().getSolid(0).getPointA()\n            B = AllScene.collisionDict[collnode].node().getSolid(0).getPointB()\n            out_file.write(i2 + 'pointA =  Point3(%.3f,%.3f,%.3f)\\n' % (A.getX(), A.getY(), A.getZ()))\n            out_file.write(i2 + 'pointB =  Point3(%.3f,%.3f,%.3f)\\n' % (B.getX(), B.getY(), B.getZ()))\n            out_file.write(i2 + 'collSolid=CollisionSegment()\\n')\n            out_file.write(i2 + 'collSolid.setPointA(pointA)\\n')\n            out_file.write(i2 + 'collSolid.setFromLens(base.cam.node(),Point2(-1,1))\\n')\n            out_file.write(i2 + 'collSolid.setPointB(pointB)\\n')\n            pass\n        elif nodetype == 'CollisionRay':\n            P = AllScene.collisionDict[collnode].node().getSolid(0).getOrigin()\n            V = AllScene.collisionDict[collnode].node().getSolid(0).getDirection()\n            out_file.write(i2 + 'point=Point3(%.3f,%.3f,%.3f)\\n' % (P.getX(), P.getY(), P.getZ()))\n            out_file.write(i2 + 'vector=Vec3(%.3f,%.3f,%.3f)\\n' % (V.getX(), V.getY(), V.getZ()))\n            out_file.write(i2 + 'collSolid=CollisionRay()\\n')\n            out_file.write(i2 + 'collSolid.setOrigin(point)\\n')\n            out_file.write(i2 + 'collSolid.setDirection(vector)\\n')\n            pass\n        else:\n            print('Invalid Collision Node: ' + nodetype)\n        out_file.write('\\n')\n        out_file.write(i2 + 'self.' + collnodeS + '_Node' + '=CollisionNode(\"' + collnodeS + '\")\\n')\n        out_file.write(i2 + 'self.' + collnodeS + '_Node' + '.addSolid(collSolid)\\n')\n        out_file.write(i2 + 'base.cTrav.addCollider(self.' + collnodeS + '_Node,self.CollisionHandler)\\n')\n        out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for Lighting\\n')\n    out_file.write(i2 + '# To manipulated lights:\\n')\n    out_file.write(i2 + \"# Manipulate the light node in theScene.LightNodes['Light_Name']\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    LightList = AllScene.lightManager.getLightNodeList()\n    for light in LightList:\n        type = light.getType()\n        if type == 'ambient':\n            out_file.write(i2 + '# Ambient Light\\n')\n            out_file.write(i2 + 'self.ambientCount += 1\\n')\n            out_file.write(i2 + \"alight = AmbientLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'directional':\n            out_file.write(i2 + '# Directional Light\\n')\n            out_file.write(i2 + 'self.directionalCount += 1\\n')\n            out_file.write(i2 + \"alight = DirectionalLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setHpr(Vec3(' + str(light.getH()) + ',' + str(light.getP()) + ',' + str(light.getR()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'point':\n            out_file.write(i2 + '# Point Light\\n')\n            out_file.write(i2 + 'self.pointCount += 1\\n')\n            out_file.write(i2 + \"alight = PointLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setAttenuation(Vec3(' + str(light.getAttenuation().getX()) + ',' + str(light.getAttenuation().getY()) + ',' + str(light.getAttenuation().getZ()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'spot':\n            out_file.write(i2 + '# Spot Light\\n')\n            out_file.write(i2 + 'self.spotCount += 1\\n')\n            out_file.write(i2 + \"alight = Spotlight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alens = PerspectiveLens()\\n')\n            out_file.write(i2 + 'alight.setLens(alens)\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setAttenuation(Vec3(' + str(light.getAttenuation().getX()) + ',' + str(light.getAttenuation().getY()) + ',' + str(light.getAttenuation().getZ()) + '))\\n')\n            out_file.write(i2 + 'alight.setExponent(' + str(light.getExponent()) + ')\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setHpr(Vec3(' + str(light.getH()) + ',' + str(light.getP()) + ',' + str(light.getR()) + '))\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        else:\n            out_file.write(i2 + \"print 'Invalid light type'\")\n            out_file.write(i2 + 'return None')\n        out_file.write('\\n')\n    out_file.write(i2 + '# Enable Ligthing\\n')\n    out_file.write(i2 + 'render.node().setAttrib(self.lightAttrib)\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '# Load Particle Effects. The parameters to this function are to allow us to use our modified versions of the Particle Effects modules when loading this file with the level editor\\n')\n    out_file.write(i2 + 'self.starteffects(self.loadmode,self.seParticleEffect,self.seParticles)\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '# Save Camera Settings\\n')\n    out_file.write(i2 + 'camera.setX(' + str(camera.getX()) + ')\\n')\n    out_file.write(i2 + 'camera.setY(' + str(camera.getY()) + ')\\n')\n    out_file.write(i2 + 'camera.setZ(' + str(camera.getZ()) + ')\\n')\n    out_file.write(i2 + 'camera.setH(' + str(camera.getH()) + ')\\n')\n    out_file.write(i2 + 'camera.setP(' + str(camera.getP()) + ')\\n')\n    out_file.write(i2 + 'camera.setR(' + str(camera.getR()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setNear(' + str(camera.getChild(0).node().getLens().getNear()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFar(' + str(camera.getChild(0).node().getLens().getFar()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFov(VBase2(%.5f,%.5f))\\n' % (camera.getChild(0).node().getLens().getHfov(), camera.getChild(0).node().getLens().getVfov()))\n    FilmSize = camera.getChild(0).node().getLens().getFilmSize()\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFilmSize(%.3f,%.3f)\\n' % (FilmSize.getX(), FilmSize.getY()))\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFocalLength(' + str(camera.getChild(0).node().getLens().getFocalLength()) + ')\\n')\n    out_file.write(i2 + 'camera.setTag(\"Metadata\",\"' + camera.getTag('Metadata') + '\")\\n')\n    out_file.write(i2 + 'camera.reparentTo(render)\\n')\n    out_file.write(i2 + 'base.disableMouse()\\n')\n    self.bgColor = base.getBackgroundColor()\n    out_file.write(i2 + 'base.setBackgroundColor(%.3f,%.3f,%.3f)\\n' % (self.bgColor.getX(), self.bgColor.getY(), self.bgColor.getZ()))\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Motion Paths\\n')\n    out_file.write(i2 + '# Using Mopaths:\\n')\n    out_file.write(i2 + '# theScene.curveIntervals[0].start() or .loop() will play curve with index 0\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for node in AllScene.curveDict:\n        curveCollection = AllScene.curveDict[node]\n        curvenumber = 0\n        for curve in curveCollection:\n            filestring = dirname + '\\\\' + str(node) + '_curve_' + str(curvenumber) + '.egg'\n            f = Filename.fromOsSpecific(filestring)\n            filestring = f.getBasename()\n            curve.writeEgg(f)\n            out_file.write(i2 + 'm=Mopath.Mopath()\\n')\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'm.loadFile(\"' + self.savepath + '/' + filestring + '\")\\n')\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'm.loadFile(self.executionpath + \"/' + filestring + '\")\\n')\n            out_file.write(i2 + 'mp=MopathInterval(m,self.' + str(node) + ')\\n')\n            out_file.write(i2 + 'self.curveIntervals.append(mp)\\n')\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.curveRefColl.append(\"' + self.savepath + '/' + filestring + '\")\\n')\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.curveRefColl.append(self.executionpath + \"/' + filestring + '\")\\n')\n            curvenumber = curvenumber + 1\n        out_file.write(i2 + 'self.curveIntervalsDict[\"' + str(node) + '\"]=self.curveIntervals\\n')\n        out_file.write(i2 + 'self.curveDict[\"' + str(node) + '\"]=self.curveRefColl\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Reparenting\\n')\n    out_file.write(i2 + '# A final pass is done on setting all the scenegraph hierarchy after all objects are laoded\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for model in AllScene.ModelDic:\n        modelS = str(model)\n        parent = AllScene.ModelDic[model].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.ModelDic['\" + modelS + \"']=self.\" + AllScene.ModelDic[model].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for dummy in AllScene.dummyDict:\n        dummyS = str(dummy)\n        parent = AllScene.dummyDict[dummy].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"']=self.\" + AllScene.dummyDict[dummy].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for actor in AllScene.ActorDic:\n        actorS = str(actor)\n        parent = AllScene.ActorDic[actor].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.ActorDic['\" + actorS + \"']=self.\" + AllScene.ActorDic[actor].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for collnode in AllScene.collisionDict:\n        collnodeS = str(collnode)\n        solid = AllScene.collisionDict[collnode].node().getSolid(0)\n        nodetype = solid.getType().getName()\n        parentname = AllScene.collisionDict[collnode].getParent().getName()\n        if parentname == 'render' or parentname == 'camera':\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=' + parentname + '.attachNewNode(self.' + collnodeS + '_Node)\\n')\n        elif parentname in AllScene.particleDict:\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=self.' + parentname + 'getEffect().attachNewNode(self.' + collnodeS + '_Node)\\n')\n        else:\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=self.' + parentname + '.attachNewNode(self.' + collnodeS + '_Node)\\n')\n        dictelem = AllScene.collisionDict[collnode]\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (dictelem.getX(), dictelem.getY(), dictelem.getZ(), dictelem.getH(), dictelem.getP(), dictelem.getR(), dictelem.getSx(), dictelem.getSy(), dictelem.getSz()))\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\"Metadata\",\"' + AllScene.collisionDict[collnode].getTag('Metadata') + '\")\\n')\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].show()\\n')\n        if nodetype == 'CollisionPolygon':\n            ax = float(AllScene.collisionDict[collnode].getTag('A_X'))\n            ay = float(AllScene.collisionDict[collnode].getTag('A_Y'))\n            az = float(AllScene.collisionDict[collnode].getTag('A_Z'))\n            bx = float(AllScene.collisionDict[collnode].getTag('B_X'))\n            by = float(AllScene.collisionDict[collnode].getTag('B_Y'))\n            bz = float(AllScene.collisionDict[collnode].getTag('B_Z'))\n            cx = float(AllScene.collisionDict[collnode].getTag('C_X'))\n            cy = float(AllScene.collisionDict[collnode].getTag('C_Y'))\n            cz = float(AllScene.collisionDict[collnode].getTag('C_Z'))\n            out_file.write(i2 + 'pointA=Point3(%.3f,%.3f,%.3f)\\n' % (ax, ay, az))\n            out_file.write(i2 + 'pointB=Point3(%.3f,%.3f,%.3f)\\n' % (bx, by, bz))\n            out_file.write(i2 + 'pointC=Point3(%.3f,%.3f,%.3f)\\n' % (cx, cy, cz))\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_X\\',\\'%f\\'%pointA.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_Y\\',\\'%f\\'%pointA.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_Z\\',\\'%f\\'%pointA.getZ())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_X\\',\\'%f\\'%pointB.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_Y\\',\\'%f\\'%pointB.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_Z\\',\\'%f\\'%pointB.getZ())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_X\\',\\'%f\\'%pointC.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_Y\\',\\'%f\\'%pointC.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_Z\\',\\'%f\\'%pointC.getZ())\\n')\n        out_file.write(i2 + '\\n')\n    for effect in AllScene.particleDict:\n        parent = AllScene.particleNodes[effect].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.particleDict[\"' + str(effect) + '\"].reparentTo(' + parent + ')\\n')\n        else:\n            out_file.write(i2 + 'self.particleDict[\"' + str(effect) + '\"].reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + '\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Particle Effects\\n')\n    out_file.write(i2 + '# Using Particles:\\n')\n    out_file.write(i2 + '# theScene.enableeffect(\"Effect_Name\")\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write(i1 + 'def starteffects(self,mode,seParticleEffect=None,seParticles=None):\\n')\n    for effect in AllScene.particleDict:\n        effectS = str(effect)\n        out_file.write(i2 + 'self.' + effectS + '=' + effectS + '(mode,seParticleEffect,seParticles)\\n')\n        out_file.write(i2 + 'effect=self.' + effectS + '.getEffect()\\n')\n        out_file.write(i2 + 'self.particleDict[\"' + effectS + '\"]=effect\\n')\n        out_file.write(i2 + 'effect.reparentTo(render)\\n')\n        thenode = AllScene.particleNodes[effect]\n        out_file.write(i2 + 'self.particleDict[\"' + effectS + '\"].setPosHprScale(%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f)\\n' % (thenode.getX(), thenode.getY(), thenode.getZ(), thenode.getH(), thenode.getP(), thenode.getR(), thenode.getSx(), thenode.getSy(), thenode.getSz()))\n        out_file.write('\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def enableeffect(self,effect_name):\\n')\n    out_file.write(i2 + 'self.particleDict[effect_name].enable()\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def disableeffect(self,effect_name):\\n')\n    out_file.write(i2 + 'self.particleDict[effect_name].disable()\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Animation Blending\\n')\n    out_file.write(i2 + '# Using blending:\\n')\n    out_file.write(i2 + '# theScene.playBlendAnim(actor,blendname)\\n')\n    out_file.write(i2 + '# theScene.stopBlendAnim(actor,blendname)\\n')\n    out_file.write(i2 + '# theScene.changeBlendAnim(actor,blendname,blend_amount)\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write(i1 + 'def playBlendAnim(self,actor,blendName,loop=0):\\n')\n    out_file.write(i2 + 'actor.enableBlend()\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'actor.setControlEffect(blendList[0],blendList[2])\\n')\n    out_file.write(i2 + 'actor.setControlEffect(blendList[1],1.0-blendList[2])\\n')\n    out_file.write(i2 + 'if(loop):\\n')\n    out_file.write(i2 + i1 + 'actor.loop(blendList[0])\\n')\n    out_file.write(i2 + i1 + 'actor.loop(blendList[1])\\n')\n    out_file.write(i2 + 'else:\\n')\n    out_file.write(i2 + i1 + 'actor.start(blendList[0])\\n')\n    out_file.write(i2 + i1 + 'actor.start(blendList[1])\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def stopBlendAnim(self,actor,blendName):\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'actor.stop(blendList[0])\\n')\n    out_file.write(i2 + 'actor.stop(blendList[1])\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def changeBlending(self,actor,blendName,blending):\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'blendList[2]=blending\\n')\n    out_file.write(i2 + 'self.blendAnimDict[actor.getName()]={blendName:[blendList[0],blendList[1],blending]}\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Hide and Show Methods\\n')\n    out_file.write(i2 + '# These will help you hide/show dummies, collision solids, effect nodes etc.\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideDummies(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for dummy in self.dummyDict:\\n')\n    out_file.write(i2 + i1 + 'self.dummyDict[dummy].reparentTo(hidden)\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideCollSolids(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for collSolid in self.collisionDict:\\n')\n    out_file.write(i2 + i1 + 'self.collisionDict[collSolid].hide()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideEffectNodes(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for effectnode in self.particleNodes:\\n')\n    out_file.write(i2 + i1 + 'self.particleNodes[effectnode].hide()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showDummies(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for dummy in self.dummyDict:\\n')\n    out_file.write(i2 + i1 + 'self.dummyDict[dummy].reparentTo(hidden)\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showCollSolids(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for collSolid in self.collisionDict:\\n')\n    out_file.write(i2 + i1 + 'self.collisionDict[collSolid].show()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showEffectNodes(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for effectnode in self.particleNodes:\\n')\n    out_file.write(i2 + i1 + 'self.particleNodes[effectnode].show()\\n\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Particle Effects\\n')\n    out_file.write(i2 + '# This is where effect parameters are saved in a class\\n')\n    out_file.write(i2 + '# The class is then instantiated in the starteffects method and appended to the dictionaries\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for effect in AllScene.particleDict:\n        out_file.write('\\n\\n')\n        out_file.write('class ' + str(effect) + ':\\n')\n        out_file.write(i1 + 'def __init__(self,mode=1,seParticleEffect=None,seParticles=None):\\n')\n        out_file.write(i2 + 'if(mode==0):\\n')\n        out_file.write(i2 + i1 + 'self.effect=seParticleEffect.ParticleEffect()\\n')\n        out_file.write(i2 + 'else:\\n')\n        out_file.write(i2 + i1 + 'self.effect=ParticleEffect.ParticleEffect()\\n')\n        AllScene.particleDict[effect].AppendConfig(out_file)\n        out_file.write('\\n\\n')\n        out_file.write(i1 + 'def starteffect(self):\\n')\n        out_file.write(i2 + 'pass\\n')\n        out_file.write('\\n\\n')\n        out_file.write(i1 + 'def stopeffect(self):\\n')\n        out_file.write(i2 + 'pass\\n\\n')\n        out_file.write(i1 + 'def getEffect(self):\\n')\n        out_file.write(i2 + 'return self.effect\\n\\n')\n    out_file.close()",
            "def SaveFile(self, AllScene, filename, dirname, reSaveFlag=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    i1 = '    '\n    i2 = i1 + i1\n    out_file = open(filename, 'w')\n    print('dirname:' + dirname)\n    if not os.path.isdir(dirname):\n        os.mkdir(dirname)\n    savepathname = Filename(filename)\n    self.savepath = savepathname.getBasenameWoExtension()\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# Auto Generated Code by Scene Editor\\n')\n    out_file.write('# Edit with caution\\n')\n    out_file.write('# Using this file in your code:\\n')\n    out_file.write('# For example, if you have named this file as \"myscene.py\"\\n')\n    out_file.write('# Do the following:\\n')\n    out_file.write('# from myscene import * \\n')\n    out_file.write('# theScene=SavedScene() #instantiate the class\\n')\n    out_file.write('# IMPORTANT: All the documentation below refers to \"theScene\" as the instance of SavedScene()\\n')\n    out_file.write('##########################################################################################################\\n\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# Import Panda Modules\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('from direct.directbase.DirectStart import * # Core functionality for running the \"show\"\\n')\n    out_file.write('from direct.actor import Actor # Importing models with animations\\n')\n    out_file.write('from direct.directutil import Mopath # Motion Paths\\n')\n    out_file.write('from direct.interval import MopathInterval # Motion Paths\\n')\n    out_file.write('from direct.interval.IntervalGlobal import * # Intervals for interpolation, sequencing and parallelization\\n')\n    out_file.write('from direct.particles import ParticleEffect # Particle Systems\\n')\n    out_file.write('from direct.particles import ForceGroup # Forces acting on Particles\\n')\n    out_file.write('from direct.particles import Particles\\n\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# This class stores the entire scene\\n')\n    out_file.write('##########################################################################################################\\n\\n')\n    out_file.write('class SavedScene(DirectObject): # We inherit from DirectObject so that we can use self.accept method to catch messages\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '# These dictionaries are required for re-loading a scene in the editor\\n')\n    out_file.write(i1 + '# They can be used to access the objects as well\\n\\n')\n    out_file.write(i1 + 'ModelDic={}# Stores all the models and static geometry\\n')\n    out_file.write(i1 + 'ModelRefDic={}# Stores the paths to the models\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'ActorDic={}# Stores all the actors\\n')\n    out_file.write(i1 + 'ActorRefDic={}# Stores the paths to the actors\\n')\n    out_file.write(i1 + 'ActorAnimsDic={}# Stores the animations for each actor\\n')\n    out_file.write(i1 + 'blendAnimDict={}# Stores all the blended animations\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'LightDict={}# Stores all the lights\\n')\n    out_file.write(i1 + 'LightTypes={}# Stores types for the lights\\n')\n    out_file.write(i1 + 'LightNodes={}# Stores the actual nodes for the lights\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'dummyDict={}# Stores dummies\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'collisionDict={}# Stores Collision information\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'curveDict={}# Stores Mopath information\\n')\n    out_file.write(i1 + 'curveIntervals=[]# Stores list of mopath intervals\\n')\n    out_file.write(i1 + 'curveRefColl=[]# Stores paths to mopaths\\n')\n    out_file.write(i1 + 'curveIntervalsDict={}# Stores mopath intervals\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'particleDict={}# Stores particles\\n')\n    out_file.write(i1 + 'particleNodes={}# Stores particle nodes\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '#Light Count\\n')\n    out_file.write(i1 + 'ambientCount=0\\n')\n    out_file.write(i1 + 'directionalCount=0\\n')\n    out_file.write(i1 + 'pointCount=0\\n')\n    out_file.write(i1 + 'spotCount=0\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '#Lighting Attribute\\n')\n    out_file.write(i1 + 'lightAttrib = LightAttrib.makeAllOff()# Initialize lighting\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'CollisionHandler=CollisionHandlerEvent()# Setup a Collision Handler\\n')\n    out_file.write(i1 + '##########################################################################################################\\n')\n    out_file.write(i1 + '# Constructor: this is run first when you instantiate the SavedScene class\\n')\n    out_file.write(i1 + '##########################################################################################################\\n')\n    out_file.write(i1 + 'def __init__(self,loadmode=1,seParticleEffect=None,seParticles=None,executionpath=None):# loadmode 0 specifies that this file is being loaded by the scene editor and it passes its own versions of the particle fx modules\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'self.loadmode=loadmode\\n')\n    out_file.write(i2 + 'self.seParticleEffect=seParticleEffect\\n')\n    out_file.write(i2 + 'self.seParticles=seParticles\\n')\n    out_file.write(i2 + 'self.executionpath=executionpath\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'base.enableParticles()# Enable Particle effects\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'self.cTrav = CollisionTraverser() # Setup a traverser for collisions\\n')\n    out_file.write(i2 + 'base.cTrav = self.cTrav\\n')\n    out_file.write(i2 + 'self.CollisionHandler.setInPattern(\"enter%in\")# The message to be raised when something enters a collision node\\n')\n    out_file.write(i2 + 'self.CollisionHandler.setOutPattern(\"exit%in\")# The message to be raised when something exits a collision node\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the models\\n')\n    out_file.write(i2 + '# To access these models:\\n')\n    out_file.write(i2 + '# theScene.ModelDic[\"\\'Model_Name\"\\']\\n')\n    out_file.write(i2 + '# where theScene is the SavedScene class instance\\n')\n    out_file.write(i2 + '# Properties saved include:\\n')\n    out_file.write(i2 + '# Transformations\\n')\n    out_file.write(i2 + '# Alpha and color\\n')\n    out_file.write(i2 + '# Parent and child information\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for model in AllScene.ModelDic:\n        out_file.write('\\n')\n        modelS = str(model)\n        if 1:\n            out_file.write(i2 + \"# Loading model's egg file\\n\")\n            newpath = dirname + '/' + AllScene.ModelRefDic[model].getBasename()\n            newpathF = Filename(newpath)\n            newpathSpecific = newpathF.toOsSpecific()\n            fnamelist = []\n            modelData = EggData()\n            modelData.read(AllScene.ModelRefDic[model])\n            textures = EggTextureCollection()\n            textures.findUsedTextures(modelData)\n            for index in range(textures.getNumTextures()):\n                texture = textures.getTexture(index)\n                texfilename = texture.getFilename()\n                fnamelist.append(texfilename.getFullpath())\n                oldFilename = Filename(Filename(AllScene.ModelRefDic[model].getDirname()), texfilename)\n                if not oldFilename.isRegularFile():\n                    if texfilename.resolveFilename(getTexturePath(), ''):\n                        oldFilename = texfilename\n                oldtexpath = oldFilename.toOsSpecific()\n                newtexpath = dirname + '/' + texfilename.getBasename()\n                newtexpathF = Filename(newtexpath)\n                newtexpathSpecific = newtexpathF.toOsSpecific()\n                print('TEXTURE SAVER:: copying' + oldtexpath + ' to ' + newtexpathSpecific)\n                if oldtexpath != newtexpathSpecific:\n                    shutil.copyfile(oldtexpath, newtexpathSpecific)\n            oldModelpath = AllScene.ModelRefDic[model].toOsSpecific()\n            print('FILESAVER:: copying from ' + AllScene.ModelRefDic[model].toOsSpecific() + 'to' + newpathSpecific)\n            if oldModelpath != newpathSpecific:\n                shutil.copyfile(oldModelpath, newpathSpecific)\n            e = EggData()\n            e.read(AllScene.ModelRefDic[model])\n            etc = EggTextureCollection()\n            etc.extractTextures(e)\n            for index in range(len(fnamelist)):\n                print(fnamelist[index])\n                tex = etc.findFilename(Filename(fnamelist[index]))\n                fn = Filename(tex.getFilename())\n                fn.setDirname('')\n                tex.setFilename(fn)\n                e.writeEgg(Filename.fromOsSpecific(newpathSpecific))\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + modelS + \"=loader.loadModel('\" + self.savepath + '/' + AllScene.ModelRefDic[model].getBasename() + \"')\\n\")\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.' + modelS + \"=loader.loadModel(self.executionpath + '/\" + AllScene.ModelRefDic[model].getBasename() + \"')\\n\")\n            out_file.write('\\n')\n            out_file.write(i2 + '# Transforming the model\\n')\n            out_file.write(i2 + 'self.' + modelS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.ModelDic[model].getX(), AllScene.ModelDic[model].getY(), AllScene.ModelDic[model].getZ(), AllScene.ModelDic[model].getH(), AllScene.ModelDic[model].getP(), AllScene.ModelDic[model].getR(), AllScene.ModelDic[model].getSx(), AllScene.ModelDic[model].getSy(), AllScene.ModelDic[model].getSz()))\n            if AllScene.ModelDic[model].hasTransparency():\n                out_file.write('\\n')\n                out_file.write(i2 + '# Alpha\\n')\n                out_file.write(i2 + 'self.' + modelS + '.setTransparency(1)\\n')\n                clr = AllScene.ModelDic[model].getColor()\n                out_file.write(i2 + 'self.' + modelS + '.setColor(%.4f,%.4f,%.4f,%.4f)\\n' % (clr.getX(), clr.getY(), clr.getZ(), clr.getW()))\n            out_file.write('\\n')\n            out_file.write(i2 + '# Reparent To Render for now and later we update all the parentings\\n')\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(render)\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.ModelDic[\"Model_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + modelS + '.setTag(\"Metadata\",\"' + AllScene.ModelDic[model].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            out_file.write(i2 + \"self.ModelDic['\" + modelS + \"']=self.\" + AllScene.ModelDic[model].getName() + '\\n')\n            out_file.write(i2 + \"self.ModelRefDic['\" + modelS + \"']='\" + AllScene.ModelRefDic[model].getBasename() + \"'\\n\")\n            out_file.write(i2 + \"self.ModelDic['\" + modelS + \"'].setName('\" + modelS + \"')\\n\")\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the Dummy Objects\\n')\n    out_file.write(i2 + '# To access the dummies\\n')\n    out_file.write(i2 + \"# theScene.dummyDict['Dummy_Name']\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for dummy in AllScene.dummyDict:\n        out_file.write('\\n')\n        dummyS = str(dummy)\n        if 1:\n            out_file.write(i2 + 'self.' + dummyS + '=loader.loadModel(\"models/misc/sphere\")\\n')\n            out_file.write(i2 + '# Transforming the Dummy\\n')\n            out_file.write(i2 + 'self.' + dummyS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.dummyDict[dummy].getX(), AllScene.dummyDict[dummy].getY(), AllScene.dummyDict[dummy].getZ(), AllScene.dummyDict[dummy].getH(), AllScene.dummyDict[dummy].getP(), AllScene.dummyDict[dummy].getR(), AllScene.dummyDict[dummy].getSx(), AllScene.dummyDict[dummy].getSy(), AllScene.dummyDict[dummy].getSz()))\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"']=self.\" + AllScene.dummyDict[dummy].getName() + '\\n')\n            out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"'].setName('\" + dummyS + \"')\\n\")\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.dummyDict[\"Dummy_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + dummyS + '.setTag(\"Metadata\",\"' + AllScene.dummyDict[dummy].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the Actors and animations\\n')\n    out_file.write(i2 + '# To access the Actors\\n')\n    out_file.write(i2 + \"# theScene.ActorDic['Actor_Name']\\n\")\n    out_file.write(i2 + \"# theScene.ActorDic['Actor_Name'].play('Animation_Name')\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for actor in AllScene.ActorDic:\n        out_file.write('\\n')\n        actorS = str(actor)\n        if 1:\n            newpath = dirname + '/' + AllScene.ActorRefDic[actor].getBasename()\n            newpathF = Filename(newpath)\n            newpathSpecific = newpathF.toOsSpecific()\n            actorfnamelist = []\n            actorData = EggData()\n            actorData.read(AllScene.ActorRefDic[actor])\n            textures = EggTextureCollection()\n            textures.findUsedTextures(actorData)\n            for index in range(textures.getNumTextures()):\n                texture = textures.getTexture(index)\n                texfilename = texture.getFilename()\n                actorfnamelist.append(texfilename.getFullpath())\n                oldFilename = Filename(Filename(AllScene.ActorRefDic[actor].getDirname()), texfilename)\n                if not oldFilename.isRegularFile():\n                    if texfilename.resolveFilename(getTexturePath(), ''):\n                        oldFilename = texfilename\n                oldtexpath = oldFilename.toOsSpecific()\n                newtexpath = dirname + '/' + texfilename.getBasename()\n                newtexpathF = Filename(newtexpath)\n                newtexpathSpecific = newtexpathF.toOsSpecific()\n                print('TEXTURE SAVER:: copying' + oldtexpath + ' to ' + newtexpathSpecific)\n                if oldtexpath != newtexpathSpecific:\n                    shutil.copyfile(oldtexpath, newtexpathSpecific)\n            oldActorpath = AllScene.ActorRefDic[actor].toOsSpecific()\n            print('FILESAVER:: copying from ' + AllScene.ActorRefDic[actor].toOsSpecific() + 'to' + newpathSpecific)\n            if oldActorpath != newpathSpecific:\n                shutil.copyfile(oldActorpath, newpathSpecific)\n            e = EggData()\n            e.read(AllScene.ActorRefDic[actor])\n            etc = EggTextureCollection()\n            etc.extractTextures(e)\n            for index in range(len(actorfnamelist)):\n                print(actorfnamelist[index])\n                tex = etc.findFilename(Filename(actorfnamelist[index]))\n                fn = Filename(tex.getFilename())\n                fn.setDirname('')\n                tex.setFilename(fn)\n                e.writeEgg(Filename.fromOsSpecific(newpathSpecific))\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + \"=Actor.Actor('\" + self.savepath + '/' + AllScene.ActorRefDic[actor].getBasename() + \"')\\n\")\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + \"=Actor.Actor(self.executionpath + '/\" + AllScene.ActorRefDic[actor].getBasename() + \"')\\n\")\n            out_file.write(i2 + '# Transforming the Actor\\n')\n            out_file.write(i2 + 'self.' + actorS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.ActorDic[actor].getX(), AllScene.ActorDic[actor].getY(), AllScene.ActorDic[actor].getZ(), AllScene.ActorDic[actor].getH(), AllScene.ActorDic[actor].getP(), AllScene.ActorDic[actor].getR(), AllScene.ActorDic[actor].getSx(), AllScene.ActorDic[actor].getSy(), AllScene.ActorDic[actor].getSz()))\n            if AllScene.ActorDic[actor].hasTransparency():\n                out_file.write(i2 + '# Alpha\\n')\n                out_file.write(i2 + 'self.' + actorS + '.setTransparency(1)\\n')\n                clr = AllScene.ActorDic[actor].getColor()\n                out_file.write(i2 + 'self.' + actorS + '.setColor(%.4f,%.4f,%.4f,%.4f)\\n' % (clr.getX(), clr.getY(), clr.getZ(), clr.getW()))\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(render)\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.ActorDic[\"Actor_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + actorS + '.setTag(\"Metadata\",\"' + AllScene.ActorDic[actor].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            ActorAnimations = AllScene.getAnimationDictFromActor(actor)\n            ActorAnimationsInvoke = {}\n            if ActorAnimations != {}:\n                for animation in ActorAnimations:\n                    if not animation is None:\n                        print('ACTOR ANIMATIONS:' + ActorAnimations[animation])\n                        oldAnimPath = Filename(ActorAnimations[animation])\n                        oldAnim = oldAnimPath.toOsSpecific()\n                        dirOS = Filename(dirname)\n                        newAnim = dirOS.toOsSpecific() + '\\\\' + oldAnimPath.getBasename()\n                        print('ACTOR ANIM SAVER:: Comparing' + oldAnim + 'and' + newAnim)\n                        if oldAnim != newAnim:\n                            shutil.copyfile(oldAnim, newAnim)\n                        newAnimF = Filename.fromOsSpecific(newAnim)\n                        ActorAnimationsInvoke[animation] = 'self.executionpath +' + '/' + newAnimF.getBasename()\n                        ActorAnimations[animation] = self.savepath + '/' + newAnimF.getBasename()\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + '.loadAnims(' + str(ActorAnimations) + ')\\n')\n            out_file.write(i2 + 'else:\\n')\n            theloadAnimString = str(ActorAnimationsInvoke)\n            print('LOAD ANIM STRING BEFORE' + theloadAnimString)\n            theloadAnimString = theloadAnimString.replace(\"'self.executionpath +\", \"self.executionpath + '\")\n            print('LOAD ANIM STRING AFTER' + theloadAnimString)\n            out_file.write(i2 + i1 + 'self.' + actorS + '.loadAnims(' + theloadAnimString + ')\\n')\n            out_file.write(i2 + \"self.ActorDic['\" + actorS + \"']=self.\" + AllScene.ActorDic[actor].getName() + '\\n')\n            out_file.write(i2 + \"self.ActorRefDic['\" + actorS + \"']='\" + AllScene.ActorRefDic[actor].getBasename() + \"'\\n\")\n            out_file.write(i2 + \"self.ActorDic['\" + actorS + \"'].setName('\" + actorS + \"')\\n\")\n            if actor in AllScene.blendAnimDict:\n                out_file.write(i2 + 'self.blendAnimDict[\"' + actorS + '\"]=' + str(AllScene.blendAnimDict[actor]) + '\\n')\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for setting up Collision Nodes\\n')\n    out_file.write(i2 + '# To use collision detection:\\n')\n    out_file.write(i2 + '# You must set up your own bitmasking and event handlers, the traverser \"cTrav\" is created for you at the top\\n')\n    out_file.write(i2 + '# The collision nodes are stored in collisionDict\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for collnode in AllScene.collisionDict:\n        collnodeS = str(collnode)\n        solid = AllScene.collisionDict[collnode].node().getSolid(0)\n        nodetype = solid.getType().getName()\n        if nodetype == 'CollisionSphere':\n            out_file.write(i2 + 'collSolid=CollisionSphere(%.3f,%.3f,%.3f,%.3f)\\n' % (solid.getCenter().getX(), solid.getCenter().getY(), solid.getCenter().getZ(), solid.getRadius()))\n            pass\n        elif nodetype == 'CollisionPolygon':\n            ax = AllScene.collisionDict[collnode].getTag('A_X')\n            ay = AllScene.collisionDict[collnode].getTag('A_Y')\n            az = AllScene.collisionDict[collnode].getTag('A_Z')\n            bx = AllScene.collisionDict[collnode].getTag('B_X')\n            by = AllScene.collisionDict[collnode].getTag('B_Y')\n            bz = AllScene.collisionDict[collnode].getTag('B_Z')\n            cx = AllScene.collisionDict[collnode].getTag('C_X')\n            cy = AllScene.collisionDict[collnode].getTag('C_Y')\n            cz = AllScene.collisionDict[collnode].getTag('C_Z')\n            out_file.write(i2 + 'pointA =  Point3(' + ax + ',' + ay + ',' + az + ')\\n')\n            out_file.write(i2 + 'pointB =  Point3(' + bx + ',' + by + ',' + bz + ')\\n')\n            out_file.write(i2 + 'pointC =  Point3(' + cx + ',' + cy + ',' + cz + ')\\n')\n            out_file.write(i2 + 'collSolid=CollisionPolygon(pointA, pointB, pointC)\\n')\n            pass\n        elif nodetype == 'CollisionSegment':\n            A = AllScene.collisionDict[collnode].node().getSolid(0).getPointA()\n            B = AllScene.collisionDict[collnode].node().getSolid(0).getPointB()\n            out_file.write(i2 + 'pointA =  Point3(%.3f,%.3f,%.3f)\\n' % (A.getX(), A.getY(), A.getZ()))\n            out_file.write(i2 + 'pointB =  Point3(%.3f,%.3f,%.3f)\\n' % (B.getX(), B.getY(), B.getZ()))\n            out_file.write(i2 + 'collSolid=CollisionSegment()\\n')\n            out_file.write(i2 + 'collSolid.setPointA(pointA)\\n')\n            out_file.write(i2 + 'collSolid.setFromLens(base.cam.node(),Point2(-1,1))\\n')\n            out_file.write(i2 + 'collSolid.setPointB(pointB)\\n')\n            pass\n        elif nodetype == 'CollisionRay':\n            P = AllScene.collisionDict[collnode].node().getSolid(0).getOrigin()\n            V = AllScene.collisionDict[collnode].node().getSolid(0).getDirection()\n            out_file.write(i2 + 'point=Point3(%.3f,%.3f,%.3f)\\n' % (P.getX(), P.getY(), P.getZ()))\n            out_file.write(i2 + 'vector=Vec3(%.3f,%.3f,%.3f)\\n' % (V.getX(), V.getY(), V.getZ()))\n            out_file.write(i2 + 'collSolid=CollisionRay()\\n')\n            out_file.write(i2 + 'collSolid.setOrigin(point)\\n')\n            out_file.write(i2 + 'collSolid.setDirection(vector)\\n')\n            pass\n        else:\n            print('Invalid Collision Node: ' + nodetype)\n        out_file.write('\\n')\n        out_file.write(i2 + 'self.' + collnodeS + '_Node' + '=CollisionNode(\"' + collnodeS + '\")\\n')\n        out_file.write(i2 + 'self.' + collnodeS + '_Node' + '.addSolid(collSolid)\\n')\n        out_file.write(i2 + 'base.cTrav.addCollider(self.' + collnodeS + '_Node,self.CollisionHandler)\\n')\n        out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for Lighting\\n')\n    out_file.write(i2 + '# To manipulated lights:\\n')\n    out_file.write(i2 + \"# Manipulate the light node in theScene.LightNodes['Light_Name']\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    LightList = AllScene.lightManager.getLightNodeList()\n    for light in LightList:\n        type = light.getType()\n        if type == 'ambient':\n            out_file.write(i2 + '# Ambient Light\\n')\n            out_file.write(i2 + 'self.ambientCount += 1\\n')\n            out_file.write(i2 + \"alight = AmbientLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'directional':\n            out_file.write(i2 + '# Directional Light\\n')\n            out_file.write(i2 + 'self.directionalCount += 1\\n')\n            out_file.write(i2 + \"alight = DirectionalLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setHpr(Vec3(' + str(light.getH()) + ',' + str(light.getP()) + ',' + str(light.getR()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'point':\n            out_file.write(i2 + '# Point Light\\n')\n            out_file.write(i2 + 'self.pointCount += 1\\n')\n            out_file.write(i2 + \"alight = PointLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setAttenuation(Vec3(' + str(light.getAttenuation().getX()) + ',' + str(light.getAttenuation().getY()) + ',' + str(light.getAttenuation().getZ()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'spot':\n            out_file.write(i2 + '# Spot Light\\n')\n            out_file.write(i2 + 'self.spotCount += 1\\n')\n            out_file.write(i2 + \"alight = Spotlight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alens = PerspectiveLens()\\n')\n            out_file.write(i2 + 'alight.setLens(alens)\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setAttenuation(Vec3(' + str(light.getAttenuation().getX()) + ',' + str(light.getAttenuation().getY()) + ',' + str(light.getAttenuation().getZ()) + '))\\n')\n            out_file.write(i2 + 'alight.setExponent(' + str(light.getExponent()) + ')\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setHpr(Vec3(' + str(light.getH()) + ',' + str(light.getP()) + ',' + str(light.getR()) + '))\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        else:\n            out_file.write(i2 + \"print 'Invalid light type'\")\n            out_file.write(i2 + 'return None')\n        out_file.write('\\n')\n    out_file.write(i2 + '# Enable Ligthing\\n')\n    out_file.write(i2 + 'render.node().setAttrib(self.lightAttrib)\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '# Load Particle Effects. The parameters to this function are to allow us to use our modified versions of the Particle Effects modules when loading this file with the level editor\\n')\n    out_file.write(i2 + 'self.starteffects(self.loadmode,self.seParticleEffect,self.seParticles)\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '# Save Camera Settings\\n')\n    out_file.write(i2 + 'camera.setX(' + str(camera.getX()) + ')\\n')\n    out_file.write(i2 + 'camera.setY(' + str(camera.getY()) + ')\\n')\n    out_file.write(i2 + 'camera.setZ(' + str(camera.getZ()) + ')\\n')\n    out_file.write(i2 + 'camera.setH(' + str(camera.getH()) + ')\\n')\n    out_file.write(i2 + 'camera.setP(' + str(camera.getP()) + ')\\n')\n    out_file.write(i2 + 'camera.setR(' + str(camera.getR()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setNear(' + str(camera.getChild(0).node().getLens().getNear()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFar(' + str(camera.getChild(0).node().getLens().getFar()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFov(VBase2(%.5f,%.5f))\\n' % (camera.getChild(0).node().getLens().getHfov(), camera.getChild(0).node().getLens().getVfov()))\n    FilmSize = camera.getChild(0).node().getLens().getFilmSize()\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFilmSize(%.3f,%.3f)\\n' % (FilmSize.getX(), FilmSize.getY()))\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFocalLength(' + str(camera.getChild(0).node().getLens().getFocalLength()) + ')\\n')\n    out_file.write(i2 + 'camera.setTag(\"Metadata\",\"' + camera.getTag('Metadata') + '\")\\n')\n    out_file.write(i2 + 'camera.reparentTo(render)\\n')\n    out_file.write(i2 + 'base.disableMouse()\\n')\n    self.bgColor = base.getBackgroundColor()\n    out_file.write(i2 + 'base.setBackgroundColor(%.3f,%.3f,%.3f)\\n' % (self.bgColor.getX(), self.bgColor.getY(), self.bgColor.getZ()))\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Motion Paths\\n')\n    out_file.write(i2 + '# Using Mopaths:\\n')\n    out_file.write(i2 + '# theScene.curveIntervals[0].start() or .loop() will play curve with index 0\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for node in AllScene.curveDict:\n        curveCollection = AllScene.curveDict[node]\n        curvenumber = 0\n        for curve in curveCollection:\n            filestring = dirname + '\\\\' + str(node) + '_curve_' + str(curvenumber) + '.egg'\n            f = Filename.fromOsSpecific(filestring)\n            filestring = f.getBasename()\n            curve.writeEgg(f)\n            out_file.write(i2 + 'm=Mopath.Mopath()\\n')\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'm.loadFile(\"' + self.savepath + '/' + filestring + '\")\\n')\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'm.loadFile(self.executionpath + \"/' + filestring + '\")\\n')\n            out_file.write(i2 + 'mp=MopathInterval(m,self.' + str(node) + ')\\n')\n            out_file.write(i2 + 'self.curveIntervals.append(mp)\\n')\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.curveRefColl.append(\"' + self.savepath + '/' + filestring + '\")\\n')\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.curveRefColl.append(self.executionpath + \"/' + filestring + '\")\\n')\n            curvenumber = curvenumber + 1\n        out_file.write(i2 + 'self.curveIntervalsDict[\"' + str(node) + '\"]=self.curveIntervals\\n')\n        out_file.write(i2 + 'self.curveDict[\"' + str(node) + '\"]=self.curveRefColl\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Reparenting\\n')\n    out_file.write(i2 + '# A final pass is done on setting all the scenegraph hierarchy after all objects are laoded\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for model in AllScene.ModelDic:\n        modelS = str(model)\n        parent = AllScene.ModelDic[model].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.ModelDic['\" + modelS + \"']=self.\" + AllScene.ModelDic[model].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for dummy in AllScene.dummyDict:\n        dummyS = str(dummy)\n        parent = AllScene.dummyDict[dummy].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"']=self.\" + AllScene.dummyDict[dummy].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for actor in AllScene.ActorDic:\n        actorS = str(actor)\n        parent = AllScene.ActorDic[actor].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.ActorDic['\" + actorS + \"']=self.\" + AllScene.ActorDic[actor].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for collnode in AllScene.collisionDict:\n        collnodeS = str(collnode)\n        solid = AllScene.collisionDict[collnode].node().getSolid(0)\n        nodetype = solid.getType().getName()\n        parentname = AllScene.collisionDict[collnode].getParent().getName()\n        if parentname == 'render' or parentname == 'camera':\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=' + parentname + '.attachNewNode(self.' + collnodeS + '_Node)\\n')\n        elif parentname in AllScene.particleDict:\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=self.' + parentname + 'getEffect().attachNewNode(self.' + collnodeS + '_Node)\\n')\n        else:\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=self.' + parentname + '.attachNewNode(self.' + collnodeS + '_Node)\\n')\n        dictelem = AllScene.collisionDict[collnode]\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (dictelem.getX(), dictelem.getY(), dictelem.getZ(), dictelem.getH(), dictelem.getP(), dictelem.getR(), dictelem.getSx(), dictelem.getSy(), dictelem.getSz()))\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\"Metadata\",\"' + AllScene.collisionDict[collnode].getTag('Metadata') + '\")\\n')\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].show()\\n')\n        if nodetype == 'CollisionPolygon':\n            ax = float(AllScene.collisionDict[collnode].getTag('A_X'))\n            ay = float(AllScene.collisionDict[collnode].getTag('A_Y'))\n            az = float(AllScene.collisionDict[collnode].getTag('A_Z'))\n            bx = float(AllScene.collisionDict[collnode].getTag('B_X'))\n            by = float(AllScene.collisionDict[collnode].getTag('B_Y'))\n            bz = float(AllScene.collisionDict[collnode].getTag('B_Z'))\n            cx = float(AllScene.collisionDict[collnode].getTag('C_X'))\n            cy = float(AllScene.collisionDict[collnode].getTag('C_Y'))\n            cz = float(AllScene.collisionDict[collnode].getTag('C_Z'))\n            out_file.write(i2 + 'pointA=Point3(%.3f,%.3f,%.3f)\\n' % (ax, ay, az))\n            out_file.write(i2 + 'pointB=Point3(%.3f,%.3f,%.3f)\\n' % (bx, by, bz))\n            out_file.write(i2 + 'pointC=Point3(%.3f,%.3f,%.3f)\\n' % (cx, cy, cz))\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_X\\',\\'%f\\'%pointA.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_Y\\',\\'%f\\'%pointA.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_Z\\',\\'%f\\'%pointA.getZ())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_X\\',\\'%f\\'%pointB.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_Y\\',\\'%f\\'%pointB.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_Z\\',\\'%f\\'%pointB.getZ())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_X\\',\\'%f\\'%pointC.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_Y\\',\\'%f\\'%pointC.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_Z\\',\\'%f\\'%pointC.getZ())\\n')\n        out_file.write(i2 + '\\n')\n    for effect in AllScene.particleDict:\n        parent = AllScene.particleNodes[effect].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.particleDict[\"' + str(effect) + '\"].reparentTo(' + parent + ')\\n')\n        else:\n            out_file.write(i2 + 'self.particleDict[\"' + str(effect) + '\"].reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + '\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Particle Effects\\n')\n    out_file.write(i2 + '# Using Particles:\\n')\n    out_file.write(i2 + '# theScene.enableeffect(\"Effect_Name\")\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write(i1 + 'def starteffects(self,mode,seParticleEffect=None,seParticles=None):\\n')\n    for effect in AllScene.particleDict:\n        effectS = str(effect)\n        out_file.write(i2 + 'self.' + effectS + '=' + effectS + '(mode,seParticleEffect,seParticles)\\n')\n        out_file.write(i2 + 'effect=self.' + effectS + '.getEffect()\\n')\n        out_file.write(i2 + 'self.particleDict[\"' + effectS + '\"]=effect\\n')\n        out_file.write(i2 + 'effect.reparentTo(render)\\n')\n        thenode = AllScene.particleNodes[effect]\n        out_file.write(i2 + 'self.particleDict[\"' + effectS + '\"].setPosHprScale(%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f)\\n' % (thenode.getX(), thenode.getY(), thenode.getZ(), thenode.getH(), thenode.getP(), thenode.getR(), thenode.getSx(), thenode.getSy(), thenode.getSz()))\n        out_file.write('\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def enableeffect(self,effect_name):\\n')\n    out_file.write(i2 + 'self.particleDict[effect_name].enable()\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def disableeffect(self,effect_name):\\n')\n    out_file.write(i2 + 'self.particleDict[effect_name].disable()\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Animation Blending\\n')\n    out_file.write(i2 + '# Using blending:\\n')\n    out_file.write(i2 + '# theScene.playBlendAnim(actor,blendname)\\n')\n    out_file.write(i2 + '# theScene.stopBlendAnim(actor,blendname)\\n')\n    out_file.write(i2 + '# theScene.changeBlendAnim(actor,blendname,blend_amount)\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write(i1 + 'def playBlendAnim(self,actor,blendName,loop=0):\\n')\n    out_file.write(i2 + 'actor.enableBlend()\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'actor.setControlEffect(blendList[0],blendList[2])\\n')\n    out_file.write(i2 + 'actor.setControlEffect(blendList[1],1.0-blendList[2])\\n')\n    out_file.write(i2 + 'if(loop):\\n')\n    out_file.write(i2 + i1 + 'actor.loop(blendList[0])\\n')\n    out_file.write(i2 + i1 + 'actor.loop(blendList[1])\\n')\n    out_file.write(i2 + 'else:\\n')\n    out_file.write(i2 + i1 + 'actor.start(blendList[0])\\n')\n    out_file.write(i2 + i1 + 'actor.start(blendList[1])\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def stopBlendAnim(self,actor,blendName):\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'actor.stop(blendList[0])\\n')\n    out_file.write(i2 + 'actor.stop(blendList[1])\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def changeBlending(self,actor,blendName,blending):\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'blendList[2]=blending\\n')\n    out_file.write(i2 + 'self.blendAnimDict[actor.getName()]={blendName:[blendList[0],blendList[1],blending]}\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Hide and Show Methods\\n')\n    out_file.write(i2 + '# These will help you hide/show dummies, collision solids, effect nodes etc.\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideDummies(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for dummy in self.dummyDict:\\n')\n    out_file.write(i2 + i1 + 'self.dummyDict[dummy].reparentTo(hidden)\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideCollSolids(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for collSolid in self.collisionDict:\\n')\n    out_file.write(i2 + i1 + 'self.collisionDict[collSolid].hide()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideEffectNodes(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for effectnode in self.particleNodes:\\n')\n    out_file.write(i2 + i1 + 'self.particleNodes[effectnode].hide()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showDummies(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for dummy in self.dummyDict:\\n')\n    out_file.write(i2 + i1 + 'self.dummyDict[dummy].reparentTo(hidden)\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showCollSolids(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for collSolid in self.collisionDict:\\n')\n    out_file.write(i2 + i1 + 'self.collisionDict[collSolid].show()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showEffectNodes(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for effectnode in self.particleNodes:\\n')\n    out_file.write(i2 + i1 + 'self.particleNodes[effectnode].show()\\n\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Particle Effects\\n')\n    out_file.write(i2 + '# This is where effect parameters are saved in a class\\n')\n    out_file.write(i2 + '# The class is then instantiated in the starteffects method and appended to the dictionaries\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for effect in AllScene.particleDict:\n        out_file.write('\\n\\n')\n        out_file.write('class ' + str(effect) + ':\\n')\n        out_file.write(i1 + 'def __init__(self,mode=1,seParticleEffect=None,seParticles=None):\\n')\n        out_file.write(i2 + 'if(mode==0):\\n')\n        out_file.write(i2 + i1 + 'self.effect=seParticleEffect.ParticleEffect()\\n')\n        out_file.write(i2 + 'else:\\n')\n        out_file.write(i2 + i1 + 'self.effect=ParticleEffect.ParticleEffect()\\n')\n        AllScene.particleDict[effect].AppendConfig(out_file)\n        out_file.write('\\n\\n')\n        out_file.write(i1 + 'def starteffect(self):\\n')\n        out_file.write(i2 + 'pass\\n')\n        out_file.write('\\n\\n')\n        out_file.write(i1 + 'def stopeffect(self):\\n')\n        out_file.write(i2 + 'pass\\n\\n')\n        out_file.write(i1 + 'def getEffect(self):\\n')\n        out_file.write(i2 + 'return self.effect\\n\\n')\n    out_file.close()",
            "def SaveFile(self, AllScene, filename, dirname, reSaveFlag=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    i1 = '    '\n    i2 = i1 + i1\n    out_file = open(filename, 'w')\n    print('dirname:' + dirname)\n    if not os.path.isdir(dirname):\n        os.mkdir(dirname)\n    savepathname = Filename(filename)\n    self.savepath = savepathname.getBasenameWoExtension()\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# Auto Generated Code by Scene Editor\\n')\n    out_file.write('# Edit with caution\\n')\n    out_file.write('# Using this file in your code:\\n')\n    out_file.write('# For example, if you have named this file as \"myscene.py\"\\n')\n    out_file.write('# Do the following:\\n')\n    out_file.write('# from myscene import * \\n')\n    out_file.write('# theScene=SavedScene() #instantiate the class\\n')\n    out_file.write('# IMPORTANT: All the documentation below refers to \"theScene\" as the instance of SavedScene()\\n')\n    out_file.write('##########################################################################################################\\n\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# Import Panda Modules\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('from direct.directbase.DirectStart import * # Core functionality for running the \"show\"\\n')\n    out_file.write('from direct.actor import Actor # Importing models with animations\\n')\n    out_file.write('from direct.directutil import Mopath # Motion Paths\\n')\n    out_file.write('from direct.interval import MopathInterval # Motion Paths\\n')\n    out_file.write('from direct.interval.IntervalGlobal import * # Intervals for interpolation, sequencing and parallelization\\n')\n    out_file.write('from direct.particles import ParticleEffect # Particle Systems\\n')\n    out_file.write('from direct.particles import ForceGroup # Forces acting on Particles\\n')\n    out_file.write('from direct.particles import Particles\\n\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# This class stores the entire scene\\n')\n    out_file.write('##########################################################################################################\\n\\n')\n    out_file.write('class SavedScene(DirectObject): # We inherit from DirectObject so that we can use self.accept method to catch messages\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '# These dictionaries are required for re-loading a scene in the editor\\n')\n    out_file.write(i1 + '# They can be used to access the objects as well\\n\\n')\n    out_file.write(i1 + 'ModelDic={}# Stores all the models and static geometry\\n')\n    out_file.write(i1 + 'ModelRefDic={}# Stores the paths to the models\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'ActorDic={}# Stores all the actors\\n')\n    out_file.write(i1 + 'ActorRefDic={}# Stores the paths to the actors\\n')\n    out_file.write(i1 + 'ActorAnimsDic={}# Stores the animations for each actor\\n')\n    out_file.write(i1 + 'blendAnimDict={}# Stores all the blended animations\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'LightDict={}# Stores all the lights\\n')\n    out_file.write(i1 + 'LightTypes={}# Stores types for the lights\\n')\n    out_file.write(i1 + 'LightNodes={}# Stores the actual nodes for the lights\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'dummyDict={}# Stores dummies\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'collisionDict={}# Stores Collision information\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'curveDict={}# Stores Mopath information\\n')\n    out_file.write(i1 + 'curveIntervals=[]# Stores list of mopath intervals\\n')\n    out_file.write(i1 + 'curveRefColl=[]# Stores paths to mopaths\\n')\n    out_file.write(i1 + 'curveIntervalsDict={}# Stores mopath intervals\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'particleDict={}# Stores particles\\n')\n    out_file.write(i1 + 'particleNodes={}# Stores particle nodes\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '#Light Count\\n')\n    out_file.write(i1 + 'ambientCount=0\\n')\n    out_file.write(i1 + 'directionalCount=0\\n')\n    out_file.write(i1 + 'pointCount=0\\n')\n    out_file.write(i1 + 'spotCount=0\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '#Lighting Attribute\\n')\n    out_file.write(i1 + 'lightAttrib = LightAttrib.makeAllOff()# Initialize lighting\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'CollisionHandler=CollisionHandlerEvent()# Setup a Collision Handler\\n')\n    out_file.write(i1 + '##########################################################################################################\\n')\n    out_file.write(i1 + '# Constructor: this is run first when you instantiate the SavedScene class\\n')\n    out_file.write(i1 + '##########################################################################################################\\n')\n    out_file.write(i1 + 'def __init__(self,loadmode=1,seParticleEffect=None,seParticles=None,executionpath=None):# loadmode 0 specifies that this file is being loaded by the scene editor and it passes its own versions of the particle fx modules\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'self.loadmode=loadmode\\n')\n    out_file.write(i2 + 'self.seParticleEffect=seParticleEffect\\n')\n    out_file.write(i2 + 'self.seParticles=seParticles\\n')\n    out_file.write(i2 + 'self.executionpath=executionpath\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'base.enableParticles()# Enable Particle effects\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'self.cTrav = CollisionTraverser() # Setup a traverser for collisions\\n')\n    out_file.write(i2 + 'base.cTrav = self.cTrav\\n')\n    out_file.write(i2 + 'self.CollisionHandler.setInPattern(\"enter%in\")# The message to be raised when something enters a collision node\\n')\n    out_file.write(i2 + 'self.CollisionHandler.setOutPattern(\"exit%in\")# The message to be raised when something exits a collision node\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the models\\n')\n    out_file.write(i2 + '# To access these models:\\n')\n    out_file.write(i2 + '# theScene.ModelDic[\"\\'Model_Name\"\\']\\n')\n    out_file.write(i2 + '# where theScene is the SavedScene class instance\\n')\n    out_file.write(i2 + '# Properties saved include:\\n')\n    out_file.write(i2 + '# Transformations\\n')\n    out_file.write(i2 + '# Alpha and color\\n')\n    out_file.write(i2 + '# Parent and child information\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for model in AllScene.ModelDic:\n        out_file.write('\\n')\n        modelS = str(model)\n        if 1:\n            out_file.write(i2 + \"# Loading model's egg file\\n\")\n            newpath = dirname + '/' + AllScene.ModelRefDic[model].getBasename()\n            newpathF = Filename(newpath)\n            newpathSpecific = newpathF.toOsSpecific()\n            fnamelist = []\n            modelData = EggData()\n            modelData.read(AllScene.ModelRefDic[model])\n            textures = EggTextureCollection()\n            textures.findUsedTextures(modelData)\n            for index in range(textures.getNumTextures()):\n                texture = textures.getTexture(index)\n                texfilename = texture.getFilename()\n                fnamelist.append(texfilename.getFullpath())\n                oldFilename = Filename(Filename(AllScene.ModelRefDic[model].getDirname()), texfilename)\n                if not oldFilename.isRegularFile():\n                    if texfilename.resolveFilename(getTexturePath(), ''):\n                        oldFilename = texfilename\n                oldtexpath = oldFilename.toOsSpecific()\n                newtexpath = dirname + '/' + texfilename.getBasename()\n                newtexpathF = Filename(newtexpath)\n                newtexpathSpecific = newtexpathF.toOsSpecific()\n                print('TEXTURE SAVER:: copying' + oldtexpath + ' to ' + newtexpathSpecific)\n                if oldtexpath != newtexpathSpecific:\n                    shutil.copyfile(oldtexpath, newtexpathSpecific)\n            oldModelpath = AllScene.ModelRefDic[model].toOsSpecific()\n            print('FILESAVER:: copying from ' + AllScene.ModelRefDic[model].toOsSpecific() + 'to' + newpathSpecific)\n            if oldModelpath != newpathSpecific:\n                shutil.copyfile(oldModelpath, newpathSpecific)\n            e = EggData()\n            e.read(AllScene.ModelRefDic[model])\n            etc = EggTextureCollection()\n            etc.extractTextures(e)\n            for index in range(len(fnamelist)):\n                print(fnamelist[index])\n                tex = etc.findFilename(Filename(fnamelist[index]))\n                fn = Filename(tex.getFilename())\n                fn.setDirname('')\n                tex.setFilename(fn)\n                e.writeEgg(Filename.fromOsSpecific(newpathSpecific))\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + modelS + \"=loader.loadModel('\" + self.savepath + '/' + AllScene.ModelRefDic[model].getBasename() + \"')\\n\")\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.' + modelS + \"=loader.loadModel(self.executionpath + '/\" + AllScene.ModelRefDic[model].getBasename() + \"')\\n\")\n            out_file.write('\\n')\n            out_file.write(i2 + '# Transforming the model\\n')\n            out_file.write(i2 + 'self.' + modelS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.ModelDic[model].getX(), AllScene.ModelDic[model].getY(), AllScene.ModelDic[model].getZ(), AllScene.ModelDic[model].getH(), AllScene.ModelDic[model].getP(), AllScene.ModelDic[model].getR(), AllScene.ModelDic[model].getSx(), AllScene.ModelDic[model].getSy(), AllScene.ModelDic[model].getSz()))\n            if AllScene.ModelDic[model].hasTransparency():\n                out_file.write('\\n')\n                out_file.write(i2 + '# Alpha\\n')\n                out_file.write(i2 + 'self.' + modelS + '.setTransparency(1)\\n')\n                clr = AllScene.ModelDic[model].getColor()\n                out_file.write(i2 + 'self.' + modelS + '.setColor(%.4f,%.4f,%.4f,%.4f)\\n' % (clr.getX(), clr.getY(), clr.getZ(), clr.getW()))\n            out_file.write('\\n')\n            out_file.write(i2 + '# Reparent To Render for now and later we update all the parentings\\n')\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(render)\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.ModelDic[\"Model_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + modelS + '.setTag(\"Metadata\",\"' + AllScene.ModelDic[model].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            out_file.write(i2 + \"self.ModelDic['\" + modelS + \"']=self.\" + AllScene.ModelDic[model].getName() + '\\n')\n            out_file.write(i2 + \"self.ModelRefDic['\" + modelS + \"']='\" + AllScene.ModelRefDic[model].getBasename() + \"'\\n\")\n            out_file.write(i2 + \"self.ModelDic['\" + modelS + \"'].setName('\" + modelS + \"')\\n\")\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the Dummy Objects\\n')\n    out_file.write(i2 + '# To access the dummies\\n')\n    out_file.write(i2 + \"# theScene.dummyDict['Dummy_Name']\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for dummy in AllScene.dummyDict:\n        out_file.write('\\n')\n        dummyS = str(dummy)\n        if 1:\n            out_file.write(i2 + 'self.' + dummyS + '=loader.loadModel(\"models/misc/sphere\")\\n')\n            out_file.write(i2 + '# Transforming the Dummy\\n')\n            out_file.write(i2 + 'self.' + dummyS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.dummyDict[dummy].getX(), AllScene.dummyDict[dummy].getY(), AllScene.dummyDict[dummy].getZ(), AllScene.dummyDict[dummy].getH(), AllScene.dummyDict[dummy].getP(), AllScene.dummyDict[dummy].getR(), AllScene.dummyDict[dummy].getSx(), AllScene.dummyDict[dummy].getSy(), AllScene.dummyDict[dummy].getSz()))\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"']=self.\" + AllScene.dummyDict[dummy].getName() + '\\n')\n            out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"'].setName('\" + dummyS + \"')\\n\")\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.dummyDict[\"Dummy_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + dummyS + '.setTag(\"Metadata\",\"' + AllScene.dummyDict[dummy].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the Actors and animations\\n')\n    out_file.write(i2 + '# To access the Actors\\n')\n    out_file.write(i2 + \"# theScene.ActorDic['Actor_Name']\\n\")\n    out_file.write(i2 + \"# theScene.ActorDic['Actor_Name'].play('Animation_Name')\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for actor in AllScene.ActorDic:\n        out_file.write('\\n')\n        actorS = str(actor)\n        if 1:\n            newpath = dirname + '/' + AllScene.ActorRefDic[actor].getBasename()\n            newpathF = Filename(newpath)\n            newpathSpecific = newpathF.toOsSpecific()\n            actorfnamelist = []\n            actorData = EggData()\n            actorData.read(AllScene.ActorRefDic[actor])\n            textures = EggTextureCollection()\n            textures.findUsedTextures(actorData)\n            for index in range(textures.getNumTextures()):\n                texture = textures.getTexture(index)\n                texfilename = texture.getFilename()\n                actorfnamelist.append(texfilename.getFullpath())\n                oldFilename = Filename(Filename(AllScene.ActorRefDic[actor].getDirname()), texfilename)\n                if not oldFilename.isRegularFile():\n                    if texfilename.resolveFilename(getTexturePath(), ''):\n                        oldFilename = texfilename\n                oldtexpath = oldFilename.toOsSpecific()\n                newtexpath = dirname + '/' + texfilename.getBasename()\n                newtexpathF = Filename(newtexpath)\n                newtexpathSpecific = newtexpathF.toOsSpecific()\n                print('TEXTURE SAVER:: copying' + oldtexpath + ' to ' + newtexpathSpecific)\n                if oldtexpath != newtexpathSpecific:\n                    shutil.copyfile(oldtexpath, newtexpathSpecific)\n            oldActorpath = AllScene.ActorRefDic[actor].toOsSpecific()\n            print('FILESAVER:: copying from ' + AllScene.ActorRefDic[actor].toOsSpecific() + 'to' + newpathSpecific)\n            if oldActorpath != newpathSpecific:\n                shutil.copyfile(oldActorpath, newpathSpecific)\n            e = EggData()\n            e.read(AllScene.ActorRefDic[actor])\n            etc = EggTextureCollection()\n            etc.extractTextures(e)\n            for index in range(len(actorfnamelist)):\n                print(actorfnamelist[index])\n                tex = etc.findFilename(Filename(actorfnamelist[index]))\n                fn = Filename(tex.getFilename())\n                fn.setDirname('')\n                tex.setFilename(fn)\n                e.writeEgg(Filename.fromOsSpecific(newpathSpecific))\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + \"=Actor.Actor('\" + self.savepath + '/' + AllScene.ActorRefDic[actor].getBasename() + \"')\\n\")\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + \"=Actor.Actor(self.executionpath + '/\" + AllScene.ActorRefDic[actor].getBasename() + \"')\\n\")\n            out_file.write(i2 + '# Transforming the Actor\\n')\n            out_file.write(i2 + 'self.' + actorS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.ActorDic[actor].getX(), AllScene.ActorDic[actor].getY(), AllScene.ActorDic[actor].getZ(), AllScene.ActorDic[actor].getH(), AllScene.ActorDic[actor].getP(), AllScene.ActorDic[actor].getR(), AllScene.ActorDic[actor].getSx(), AllScene.ActorDic[actor].getSy(), AllScene.ActorDic[actor].getSz()))\n            if AllScene.ActorDic[actor].hasTransparency():\n                out_file.write(i2 + '# Alpha\\n')\n                out_file.write(i2 + 'self.' + actorS + '.setTransparency(1)\\n')\n                clr = AllScene.ActorDic[actor].getColor()\n                out_file.write(i2 + 'self.' + actorS + '.setColor(%.4f,%.4f,%.4f,%.4f)\\n' % (clr.getX(), clr.getY(), clr.getZ(), clr.getW()))\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(render)\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.ActorDic[\"Actor_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + actorS + '.setTag(\"Metadata\",\"' + AllScene.ActorDic[actor].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            ActorAnimations = AllScene.getAnimationDictFromActor(actor)\n            ActorAnimationsInvoke = {}\n            if ActorAnimations != {}:\n                for animation in ActorAnimations:\n                    if not animation is None:\n                        print('ACTOR ANIMATIONS:' + ActorAnimations[animation])\n                        oldAnimPath = Filename(ActorAnimations[animation])\n                        oldAnim = oldAnimPath.toOsSpecific()\n                        dirOS = Filename(dirname)\n                        newAnim = dirOS.toOsSpecific() + '\\\\' + oldAnimPath.getBasename()\n                        print('ACTOR ANIM SAVER:: Comparing' + oldAnim + 'and' + newAnim)\n                        if oldAnim != newAnim:\n                            shutil.copyfile(oldAnim, newAnim)\n                        newAnimF = Filename.fromOsSpecific(newAnim)\n                        ActorAnimationsInvoke[animation] = 'self.executionpath +' + '/' + newAnimF.getBasename()\n                        ActorAnimations[animation] = self.savepath + '/' + newAnimF.getBasename()\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + '.loadAnims(' + str(ActorAnimations) + ')\\n')\n            out_file.write(i2 + 'else:\\n')\n            theloadAnimString = str(ActorAnimationsInvoke)\n            print('LOAD ANIM STRING BEFORE' + theloadAnimString)\n            theloadAnimString = theloadAnimString.replace(\"'self.executionpath +\", \"self.executionpath + '\")\n            print('LOAD ANIM STRING AFTER' + theloadAnimString)\n            out_file.write(i2 + i1 + 'self.' + actorS + '.loadAnims(' + theloadAnimString + ')\\n')\n            out_file.write(i2 + \"self.ActorDic['\" + actorS + \"']=self.\" + AllScene.ActorDic[actor].getName() + '\\n')\n            out_file.write(i2 + \"self.ActorRefDic['\" + actorS + \"']='\" + AllScene.ActorRefDic[actor].getBasename() + \"'\\n\")\n            out_file.write(i2 + \"self.ActorDic['\" + actorS + \"'].setName('\" + actorS + \"')\\n\")\n            if actor in AllScene.blendAnimDict:\n                out_file.write(i2 + 'self.blendAnimDict[\"' + actorS + '\"]=' + str(AllScene.blendAnimDict[actor]) + '\\n')\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for setting up Collision Nodes\\n')\n    out_file.write(i2 + '# To use collision detection:\\n')\n    out_file.write(i2 + '# You must set up your own bitmasking and event handlers, the traverser \"cTrav\" is created for you at the top\\n')\n    out_file.write(i2 + '# The collision nodes are stored in collisionDict\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for collnode in AllScene.collisionDict:\n        collnodeS = str(collnode)\n        solid = AllScene.collisionDict[collnode].node().getSolid(0)\n        nodetype = solid.getType().getName()\n        if nodetype == 'CollisionSphere':\n            out_file.write(i2 + 'collSolid=CollisionSphere(%.3f,%.3f,%.3f,%.3f)\\n' % (solid.getCenter().getX(), solid.getCenter().getY(), solid.getCenter().getZ(), solid.getRadius()))\n            pass\n        elif nodetype == 'CollisionPolygon':\n            ax = AllScene.collisionDict[collnode].getTag('A_X')\n            ay = AllScene.collisionDict[collnode].getTag('A_Y')\n            az = AllScene.collisionDict[collnode].getTag('A_Z')\n            bx = AllScene.collisionDict[collnode].getTag('B_X')\n            by = AllScene.collisionDict[collnode].getTag('B_Y')\n            bz = AllScene.collisionDict[collnode].getTag('B_Z')\n            cx = AllScene.collisionDict[collnode].getTag('C_X')\n            cy = AllScene.collisionDict[collnode].getTag('C_Y')\n            cz = AllScene.collisionDict[collnode].getTag('C_Z')\n            out_file.write(i2 + 'pointA =  Point3(' + ax + ',' + ay + ',' + az + ')\\n')\n            out_file.write(i2 + 'pointB =  Point3(' + bx + ',' + by + ',' + bz + ')\\n')\n            out_file.write(i2 + 'pointC =  Point3(' + cx + ',' + cy + ',' + cz + ')\\n')\n            out_file.write(i2 + 'collSolid=CollisionPolygon(pointA, pointB, pointC)\\n')\n            pass\n        elif nodetype == 'CollisionSegment':\n            A = AllScene.collisionDict[collnode].node().getSolid(0).getPointA()\n            B = AllScene.collisionDict[collnode].node().getSolid(0).getPointB()\n            out_file.write(i2 + 'pointA =  Point3(%.3f,%.3f,%.3f)\\n' % (A.getX(), A.getY(), A.getZ()))\n            out_file.write(i2 + 'pointB =  Point3(%.3f,%.3f,%.3f)\\n' % (B.getX(), B.getY(), B.getZ()))\n            out_file.write(i2 + 'collSolid=CollisionSegment()\\n')\n            out_file.write(i2 + 'collSolid.setPointA(pointA)\\n')\n            out_file.write(i2 + 'collSolid.setFromLens(base.cam.node(),Point2(-1,1))\\n')\n            out_file.write(i2 + 'collSolid.setPointB(pointB)\\n')\n            pass\n        elif nodetype == 'CollisionRay':\n            P = AllScene.collisionDict[collnode].node().getSolid(0).getOrigin()\n            V = AllScene.collisionDict[collnode].node().getSolid(0).getDirection()\n            out_file.write(i2 + 'point=Point3(%.3f,%.3f,%.3f)\\n' % (P.getX(), P.getY(), P.getZ()))\n            out_file.write(i2 + 'vector=Vec3(%.3f,%.3f,%.3f)\\n' % (V.getX(), V.getY(), V.getZ()))\n            out_file.write(i2 + 'collSolid=CollisionRay()\\n')\n            out_file.write(i2 + 'collSolid.setOrigin(point)\\n')\n            out_file.write(i2 + 'collSolid.setDirection(vector)\\n')\n            pass\n        else:\n            print('Invalid Collision Node: ' + nodetype)\n        out_file.write('\\n')\n        out_file.write(i2 + 'self.' + collnodeS + '_Node' + '=CollisionNode(\"' + collnodeS + '\")\\n')\n        out_file.write(i2 + 'self.' + collnodeS + '_Node' + '.addSolid(collSolid)\\n')\n        out_file.write(i2 + 'base.cTrav.addCollider(self.' + collnodeS + '_Node,self.CollisionHandler)\\n')\n        out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for Lighting\\n')\n    out_file.write(i2 + '# To manipulated lights:\\n')\n    out_file.write(i2 + \"# Manipulate the light node in theScene.LightNodes['Light_Name']\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    LightList = AllScene.lightManager.getLightNodeList()\n    for light in LightList:\n        type = light.getType()\n        if type == 'ambient':\n            out_file.write(i2 + '# Ambient Light\\n')\n            out_file.write(i2 + 'self.ambientCount += 1\\n')\n            out_file.write(i2 + \"alight = AmbientLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'directional':\n            out_file.write(i2 + '# Directional Light\\n')\n            out_file.write(i2 + 'self.directionalCount += 1\\n')\n            out_file.write(i2 + \"alight = DirectionalLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setHpr(Vec3(' + str(light.getH()) + ',' + str(light.getP()) + ',' + str(light.getR()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'point':\n            out_file.write(i2 + '# Point Light\\n')\n            out_file.write(i2 + 'self.pointCount += 1\\n')\n            out_file.write(i2 + \"alight = PointLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setAttenuation(Vec3(' + str(light.getAttenuation().getX()) + ',' + str(light.getAttenuation().getY()) + ',' + str(light.getAttenuation().getZ()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'spot':\n            out_file.write(i2 + '# Spot Light\\n')\n            out_file.write(i2 + 'self.spotCount += 1\\n')\n            out_file.write(i2 + \"alight = Spotlight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alens = PerspectiveLens()\\n')\n            out_file.write(i2 + 'alight.setLens(alens)\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setAttenuation(Vec3(' + str(light.getAttenuation().getX()) + ',' + str(light.getAttenuation().getY()) + ',' + str(light.getAttenuation().getZ()) + '))\\n')\n            out_file.write(i2 + 'alight.setExponent(' + str(light.getExponent()) + ')\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setHpr(Vec3(' + str(light.getH()) + ',' + str(light.getP()) + ',' + str(light.getR()) + '))\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        else:\n            out_file.write(i2 + \"print 'Invalid light type'\")\n            out_file.write(i2 + 'return None')\n        out_file.write('\\n')\n    out_file.write(i2 + '# Enable Ligthing\\n')\n    out_file.write(i2 + 'render.node().setAttrib(self.lightAttrib)\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '# Load Particle Effects. The parameters to this function are to allow us to use our modified versions of the Particle Effects modules when loading this file with the level editor\\n')\n    out_file.write(i2 + 'self.starteffects(self.loadmode,self.seParticleEffect,self.seParticles)\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '# Save Camera Settings\\n')\n    out_file.write(i2 + 'camera.setX(' + str(camera.getX()) + ')\\n')\n    out_file.write(i2 + 'camera.setY(' + str(camera.getY()) + ')\\n')\n    out_file.write(i2 + 'camera.setZ(' + str(camera.getZ()) + ')\\n')\n    out_file.write(i2 + 'camera.setH(' + str(camera.getH()) + ')\\n')\n    out_file.write(i2 + 'camera.setP(' + str(camera.getP()) + ')\\n')\n    out_file.write(i2 + 'camera.setR(' + str(camera.getR()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setNear(' + str(camera.getChild(0).node().getLens().getNear()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFar(' + str(camera.getChild(0).node().getLens().getFar()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFov(VBase2(%.5f,%.5f))\\n' % (camera.getChild(0).node().getLens().getHfov(), camera.getChild(0).node().getLens().getVfov()))\n    FilmSize = camera.getChild(0).node().getLens().getFilmSize()\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFilmSize(%.3f,%.3f)\\n' % (FilmSize.getX(), FilmSize.getY()))\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFocalLength(' + str(camera.getChild(0).node().getLens().getFocalLength()) + ')\\n')\n    out_file.write(i2 + 'camera.setTag(\"Metadata\",\"' + camera.getTag('Metadata') + '\")\\n')\n    out_file.write(i2 + 'camera.reparentTo(render)\\n')\n    out_file.write(i2 + 'base.disableMouse()\\n')\n    self.bgColor = base.getBackgroundColor()\n    out_file.write(i2 + 'base.setBackgroundColor(%.3f,%.3f,%.3f)\\n' % (self.bgColor.getX(), self.bgColor.getY(), self.bgColor.getZ()))\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Motion Paths\\n')\n    out_file.write(i2 + '# Using Mopaths:\\n')\n    out_file.write(i2 + '# theScene.curveIntervals[0].start() or .loop() will play curve with index 0\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for node in AllScene.curveDict:\n        curveCollection = AllScene.curveDict[node]\n        curvenumber = 0\n        for curve in curveCollection:\n            filestring = dirname + '\\\\' + str(node) + '_curve_' + str(curvenumber) + '.egg'\n            f = Filename.fromOsSpecific(filestring)\n            filestring = f.getBasename()\n            curve.writeEgg(f)\n            out_file.write(i2 + 'm=Mopath.Mopath()\\n')\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'm.loadFile(\"' + self.savepath + '/' + filestring + '\")\\n')\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'm.loadFile(self.executionpath + \"/' + filestring + '\")\\n')\n            out_file.write(i2 + 'mp=MopathInterval(m,self.' + str(node) + ')\\n')\n            out_file.write(i2 + 'self.curveIntervals.append(mp)\\n')\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.curveRefColl.append(\"' + self.savepath + '/' + filestring + '\")\\n')\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.curveRefColl.append(self.executionpath + \"/' + filestring + '\")\\n')\n            curvenumber = curvenumber + 1\n        out_file.write(i2 + 'self.curveIntervalsDict[\"' + str(node) + '\"]=self.curveIntervals\\n')\n        out_file.write(i2 + 'self.curveDict[\"' + str(node) + '\"]=self.curveRefColl\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Reparenting\\n')\n    out_file.write(i2 + '# A final pass is done on setting all the scenegraph hierarchy after all objects are laoded\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for model in AllScene.ModelDic:\n        modelS = str(model)\n        parent = AllScene.ModelDic[model].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.ModelDic['\" + modelS + \"']=self.\" + AllScene.ModelDic[model].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for dummy in AllScene.dummyDict:\n        dummyS = str(dummy)\n        parent = AllScene.dummyDict[dummy].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"']=self.\" + AllScene.dummyDict[dummy].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for actor in AllScene.ActorDic:\n        actorS = str(actor)\n        parent = AllScene.ActorDic[actor].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.ActorDic['\" + actorS + \"']=self.\" + AllScene.ActorDic[actor].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for collnode in AllScene.collisionDict:\n        collnodeS = str(collnode)\n        solid = AllScene.collisionDict[collnode].node().getSolid(0)\n        nodetype = solid.getType().getName()\n        parentname = AllScene.collisionDict[collnode].getParent().getName()\n        if parentname == 'render' or parentname == 'camera':\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=' + parentname + '.attachNewNode(self.' + collnodeS + '_Node)\\n')\n        elif parentname in AllScene.particleDict:\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=self.' + parentname + 'getEffect().attachNewNode(self.' + collnodeS + '_Node)\\n')\n        else:\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=self.' + parentname + '.attachNewNode(self.' + collnodeS + '_Node)\\n')\n        dictelem = AllScene.collisionDict[collnode]\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (dictelem.getX(), dictelem.getY(), dictelem.getZ(), dictelem.getH(), dictelem.getP(), dictelem.getR(), dictelem.getSx(), dictelem.getSy(), dictelem.getSz()))\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\"Metadata\",\"' + AllScene.collisionDict[collnode].getTag('Metadata') + '\")\\n')\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].show()\\n')\n        if nodetype == 'CollisionPolygon':\n            ax = float(AllScene.collisionDict[collnode].getTag('A_X'))\n            ay = float(AllScene.collisionDict[collnode].getTag('A_Y'))\n            az = float(AllScene.collisionDict[collnode].getTag('A_Z'))\n            bx = float(AllScene.collisionDict[collnode].getTag('B_X'))\n            by = float(AllScene.collisionDict[collnode].getTag('B_Y'))\n            bz = float(AllScene.collisionDict[collnode].getTag('B_Z'))\n            cx = float(AllScene.collisionDict[collnode].getTag('C_X'))\n            cy = float(AllScene.collisionDict[collnode].getTag('C_Y'))\n            cz = float(AllScene.collisionDict[collnode].getTag('C_Z'))\n            out_file.write(i2 + 'pointA=Point3(%.3f,%.3f,%.3f)\\n' % (ax, ay, az))\n            out_file.write(i2 + 'pointB=Point3(%.3f,%.3f,%.3f)\\n' % (bx, by, bz))\n            out_file.write(i2 + 'pointC=Point3(%.3f,%.3f,%.3f)\\n' % (cx, cy, cz))\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_X\\',\\'%f\\'%pointA.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_Y\\',\\'%f\\'%pointA.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_Z\\',\\'%f\\'%pointA.getZ())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_X\\',\\'%f\\'%pointB.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_Y\\',\\'%f\\'%pointB.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_Z\\',\\'%f\\'%pointB.getZ())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_X\\',\\'%f\\'%pointC.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_Y\\',\\'%f\\'%pointC.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_Z\\',\\'%f\\'%pointC.getZ())\\n')\n        out_file.write(i2 + '\\n')\n    for effect in AllScene.particleDict:\n        parent = AllScene.particleNodes[effect].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.particleDict[\"' + str(effect) + '\"].reparentTo(' + parent + ')\\n')\n        else:\n            out_file.write(i2 + 'self.particleDict[\"' + str(effect) + '\"].reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + '\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Particle Effects\\n')\n    out_file.write(i2 + '# Using Particles:\\n')\n    out_file.write(i2 + '# theScene.enableeffect(\"Effect_Name\")\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write(i1 + 'def starteffects(self,mode,seParticleEffect=None,seParticles=None):\\n')\n    for effect in AllScene.particleDict:\n        effectS = str(effect)\n        out_file.write(i2 + 'self.' + effectS + '=' + effectS + '(mode,seParticleEffect,seParticles)\\n')\n        out_file.write(i2 + 'effect=self.' + effectS + '.getEffect()\\n')\n        out_file.write(i2 + 'self.particleDict[\"' + effectS + '\"]=effect\\n')\n        out_file.write(i2 + 'effect.reparentTo(render)\\n')\n        thenode = AllScene.particleNodes[effect]\n        out_file.write(i2 + 'self.particleDict[\"' + effectS + '\"].setPosHprScale(%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f)\\n' % (thenode.getX(), thenode.getY(), thenode.getZ(), thenode.getH(), thenode.getP(), thenode.getR(), thenode.getSx(), thenode.getSy(), thenode.getSz()))\n        out_file.write('\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def enableeffect(self,effect_name):\\n')\n    out_file.write(i2 + 'self.particleDict[effect_name].enable()\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def disableeffect(self,effect_name):\\n')\n    out_file.write(i2 + 'self.particleDict[effect_name].disable()\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Animation Blending\\n')\n    out_file.write(i2 + '# Using blending:\\n')\n    out_file.write(i2 + '# theScene.playBlendAnim(actor,blendname)\\n')\n    out_file.write(i2 + '# theScene.stopBlendAnim(actor,blendname)\\n')\n    out_file.write(i2 + '# theScene.changeBlendAnim(actor,blendname,blend_amount)\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write(i1 + 'def playBlendAnim(self,actor,blendName,loop=0):\\n')\n    out_file.write(i2 + 'actor.enableBlend()\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'actor.setControlEffect(blendList[0],blendList[2])\\n')\n    out_file.write(i2 + 'actor.setControlEffect(blendList[1],1.0-blendList[2])\\n')\n    out_file.write(i2 + 'if(loop):\\n')\n    out_file.write(i2 + i1 + 'actor.loop(blendList[0])\\n')\n    out_file.write(i2 + i1 + 'actor.loop(blendList[1])\\n')\n    out_file.write(i2 + 'else:\\n')\n    out_file.write(i2 + i1 + 'actor.start(blendList[0])\\n')\n    out_file.write(i2 + i1 + 'actor.start(blendList[1])\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def stopBlendAnim(self,actor,blendName):\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'actor.stop(blendList[0])\\n')\n    out_file.write(i2 + 'actor.stop(blendList[1])\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def changeBlending(self,actor,blendName,blending):\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'blendList[2]=blending\\n')\n    out_file.write(i2 + 'self.blendAnimDict[actor.getName()]={blendName:[blendList[0],blendList[1],blending]}\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Hide and Show Methods\\n')\n    out_file.write(i2 + '# These will help you hide/show dummies, collision solids, effect nodes etc.\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideDummies(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for dummy in self.dummyDict:\\n')\n    out_file.write(i2 + i1 + 'self.dummyDict[dummy].reparentTo(hidden)\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideCollSolids(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for collSolid in self.collisionDict:\\n')\n    out_file.write(i2 + i1 + 'self.collisionDict[collSolid].hide()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideEffectNodes(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for effectnode in self.particleNodes:\\n')\n    out_file.write(i2 + i1 + 'self.particleNodes[effectnode].hide()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showDummies(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for dummy in self.dummyDict:\\n')\n    out_file.write(i2 + i1 + 'self.dummyDict[dummy].reparentTo(hidden)\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showCollSolids(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for collSolid in self.collisionDict:\\n')\n    out_file.write(i2 + i1 + 'self.collisionDict[collSolid].show()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showEffectNodes(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for effectnode in self.particleNodes:\\n')\n    out_file.write(i2 + i1 + 'self.particleNodes[effectnode].show()\\n\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Particle Effects\\n')\n    out_file.write(i2 + '# This is where effect parameters are saved in a class\\n')\n    out_file.write(i2 + '# The class is then instantiated in the starteffects method and appended to the dictionaries\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for effect in AllScene.particleDict:\n        out_file.write('\\n\\n')\n        out_file.write('class ' + str(effect) + ':\\n')\n        out_file.write(i1 + 'def __init__(self,mode=1,seParticleEffect=None,seParticles=None):\\n')\n        out_file.write(i2 + 'if(mode==0):\\n')\n        out_file.write(i2 + i1 + 'self.effect=seParticleEffect.ParticleEffect()\\n')\n        out_file.write(i2 + 'else:\\n')\n        out_file.write(i2 + i1 + 'self.effect=ParticleEffect.ParticleEffect()\\n')\n        AllScene.particleDict[effect].AppendConfig(out_file)\n        out_file.write('\\n\\n')\n        out_file.write(i1 + 'def starteffect(self):\\n')\n        out_file.write(i2 + 'pass\\n')\n        out_file.write('\\n\\n')\n        out_file.write(i1 + 'def stopeffect(self):\\n')\n        out_file.write(i2 + 'pass\\n\\n')\n        out_file.write(i1 + 'def getEffect(self):\\n')\n        out_file.write(i2 + 'return self.effect\\n\\n')\n    out_file.close()",
            "def SaveFile(self, AllScene, filename, dirname, reSaveFlag=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    i1 = '    '\n    i2 = i1 + i1\n    out_file = open(filename, 'w')\n    print('dirname:' + dirname)\n    if not os.path.isdir(dirname):\n        os.mkdir(dirname)\n    savepathname = Filename(filename)\n    self.savepath = savepathname.getBasenameWoExtension()\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# Auto Generated Code by Scene Editor\\n')\n    out_file.write('# Edit with caution\\n')\n    out_file.write('# Using this file in your code:\\n')\n    out_file.write('# For example, if you have named this file as \"myscene.py\"\\n')\n    out_file.write('# Do the following:\\n')\n    out_file.write('# from myscene import * \\n')\n    out_file.write('# theScene=SavedScene() #instantiate the class\\n')\n    out_file.write('# IMPORTANT: All the documentation below refers to \"theScene\" as the instance of SavedScene()\\n')\n    out_file.write('##########################################################################################################\\n\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# Import Panda Modules\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('from direct.directbase.DirectStart import * # Core functionality for running the \"show\"\\n')\n    out_file.write('from direct.actor import Actor # Importing models with animations\\n')\n    out_file.write('from direct.directutil import Mopath # Motion Paths\\n')\n    out_file.write('from direct.interval import MopathInterval # Motion Paths\\n')\n    out_file.write('from direct.interval.IntervalGlobal import * # Intervals for interpolation, sequencing and parallelization\\n')\n    out_file.write('from direct.particles import ParticleEffect # Particle Systems\\n')\n    out_file.write('from direct.particles import ForceGroup # Forces acting on Particles\\n')\n    out_file.write('from direct.particles import Particles\\n\\n')\n    out_file.write('##########################################################################################################\\n')\n    out_file.write('# This class stores the entire scene\\n')\n    out_file.write('##########################################################################################################\\n\\n')\n    out_file.write('class SavedScene(DirectObject): # We inherit from DirectObject so that we can use self.accept method to catch messages\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '# These dictionaries are required for re-loading a scene in the editor\\n')\n    out_file.write(i1 + '# They can be used to access the objects as well\\n\\n')\n    out_file.write(i1 + 'ModelDic={}# Stores all the models and static geometry\\n')\n    out_file.write(i1 + 'ModelRefDic={}# Stores the paths to the models\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'ActorDic={}# Stores all the actors\\n')\n    out_file.write(i1 + 'ActorRefDic={}# Stores the paths to the actors\\n')\n    out_file.write(i1 + 'ActorAnimsDic={}# Stores the animations for each actor\\n')\n    out_file.write(i1 + 'blendAnimDict={}# Stores all the blended animations\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'LightDict={}# Stores all the lights\\n')\n    out_file.write(i1 + 'LightTypes={}# Stores types for the lights\\n')\n    out_file.write(i1 + 'LightNodes={}# Stores the actual nodes for the lights\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'dummyDict={}# Stores dummies\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'collisionDict={}# Stores Collision information\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'curveDict={}# Stores Mopath information\\n')\n    out_file.write(i1 + 'curveIntervals=[]# Stores list of mopath intervals\\n')\n    out_file.write(i1 + 'curveRefColl=[]# Stores paths to mopaths\\n')\n    out_file.write(i1 + 'curveIntervalsDict={}# Stores mopath intervals\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'particleDict={}# Stores particles\\n')\n    out_file.write(i1 + 'particleNodes={}# Stores particle nodes\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '#Light Count\\n')\n    out_file.write(i1 + 'ambientCount=0\\n')\n    out_file.write(i1 + 'directionalCount=0\\n')\n    out_file.write(i1 + 'pointCount=0\\n')\n    out_file.write(i1 + 'spotCount=0\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + '#Lighting Attribute\\n')\n    out_file.write(i1 + 'lightAttrib = LightAttrib.makeAllOff()# Initialize lighting\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'CollisionHandler=CollisionHandlerEvent()# Setup a Collision Handler\\n')\n    out_file.write(i1 + '##########################################################################################################\\n')\n    out_file.write(i1 + '# Constructor: this is run first when you instantiate the SavedScene class\\n')\n    out_file.write(i1 + '##########################################################################################################\\n')\n    out_file.write(i1 + 'def __init__(self,loadmode=1,seParticleEffect=None,seParticles=None,executionpath=None):# loadmode 0 specifies that this file is being loaded by the scene editor and it passes its own versions of the particle fx modules\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'self.loadmode=loadmode\\n')\n    out_file.write(i2 + 'self.seParticleEffect=seParticleEffect\\n')\n    out_file.write(i2 + 'self.seParticles=seParticles\\n')\n    out_file.write(i2 + 'self.executionpath=executionpath\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'base.enableParticles()# Enable Particle effects\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'self.cTrav = CollisionTraverser() # Setup a traverser for collisions\\n')\n    out_file.write(i2 + 'base.cTrav = self.cTrav\\n')\n    out_file.write(i2 + 'self.CollisionHandler.setInPattern(\"enter%in\")# The message to be raised when something enters a collision node\\n')\n    out_file.write(i2 + 'self.CollisionHandler.setOutPattern(\"exit%in\")# The message to be raised when something exits a collision node\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the models\\n')\n    out_file.write(i2 + '# To access these models:\\n')\n    out_file.write(i2 + '# theScene.ModelDic[\"\\'Model_Name\"\\']\\n')\n    out_file.write(i2 + '# where theScene is the SavedScene class instance\\n')\n    out_file.write(i2 + '# Properties saved include:\\n')\n    out_file.write(i2 + '# Transformations\\n')\n    out_file.write(i2 + '# Alpha and color\\n')\n    out_file.write(i2 + '# Parent and child information\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for model in AllScene.ModelDic:\n        out_file.write('\\n')\n        modelS = str(model)\n        if 1:\n            out_file.write(i2 + \"# Loading model's egg file\\n\")\n            newpath = dirname + '/' + AllScene.ModelRefDic[model].getBasename()\n            newpathF = Filename(newpath)\n            newpathSpecific = newpathF.toOsSpecific()\n            fnamelist = []\n            modelData = EggData()\n            modelData.read(AllScene.ModelRefDic[model])\n            textures = EggTextureCollection()\n            textures.findUsedTextures(modelData)\n            for index in range(textures.getNumTextures()):\n                texture = textures.getTexture(index)\n                texfilename = texture.getFilename()\n                fnamelist.append(texfilename.getFullpath())\n                oldFilename = Filename(Filename(AllScene.ModelRefDic[model].getDirname()), texfilename)\n                if not oldFilename.isRegularFile():\n                    if texfilename.resolveFilename(getTexturePath(), ''):\n                        oldFilename = texfilename\n                oldtexpath = oldFilename.toOsSpecific()\n                newtexpath = dirname + '/' + texfilename.getBasename()\n                newtexpathF = Filename(newtexpath)\n                newtexpathSpecific = newtexpathF.toOsSpecific()\n                print('TEXTURE SAVER:: copying' + oldtexpath + ' to ' + newtexpathSpecific)\n                if oldtexpath != newtexpathSpecific:\n                    shutil.copyfile(oldtexpath, newtexpathSpecific)\n            oldModelpath = AllScene.ModelRefDic[model].toOsSpecific()\n            print('FILESAVER:: copying from ' + AllScene.ModelRefDic[model].toOsSpecific() + 'to' + newpathSpecific)\n            if oldModelpath != newpathSpecific:\n                shutil.copyfile(oldModelpath, newpathSpecific)\n            e = EggData()\n            e.read(AllScene.ModelRefDic[model])\n            etc = EggTextureCollection()\n            etc.extractTextures(e)\n            for index in range(len(fnamelist)):\n                print(fnamelist[index])\n                tex = etc.findFilename(Filename(fnamelist[index]))\n                fn = Filename(tex.getFilename())\n                fn.setDirname('')\n                tex.setFilename(fn)\n                e.writeEgg(Filename.fromOsSpecific(newpathSpecific))\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + modelS + \"=loader.loadModel('\" + self.savepath + '/' + AllScene.ModelRefDic[model].getBasename() + \"')\\n\")\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.' + modelS + \"=loader.loadModel(self.executionpath + '/\" + AllScene.ModelRefDic[model].getBasename() + \"')\\n\")\n            out_file.write('\\n')\n            out_file.write(i2 + '# Transforming the model\\n')\n            out_file.write(i2 + 'self.' + modelS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.ModelDic[model].getX(), AllScene.ModelDic[model].getY(), AllScene.ModelDic[model].getZ(), AllScene.ModelDic[model].getH(), AllScene.ModelDic[model].getP(), AllScene.ModelDic[model].getR(), AllScene.ModelDic[model].getSx(), AllScene.ModelDic[model].getSy(), AllScene.ModelDic[model].getSz()))\n            if AllScene.ModelDic[model].hasTransparency():\n                out_file.write('\\n')\n                out_file.write(i2 + '# Alpha\\n')\n                out_file.write(i2 + 'self.' + modelS + '.setTransparency(1)\\n')\n                clr = AllScene.ModelDic[model].getColor()\n                out_file.write(i2 + 'self.' + modelS + '.setColor(%.4f,%.4f,%.4f,%.4f)\\n' % (clr.getX(), clr.getY(), clr.getZ(), clr.getW()))\n            out_file.write('\\n')\n            out_file.write(i2 + '# Reparent To Render for now and later we update all the parentings\\n')\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(render)\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.ModelDic[\"Model_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + modelS + '.setTag(\"Metadata\",\"' + AllScene.ModelDic[model].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            out_file.write(i2 + \"self.ModelDic['\" + modelS + \"']=self.\" + AllScene.ModelDic[model].getName() + '\\n')\n            out_file.write(i2 + \"self.ModelRefDic['\" + modelS + \"']='\" + AllScene.ModelRefDic[model].getBasename() + \"'\\n\")\n            out_file.write(i2 + \"self.ModelDic['\" + modelS + \"'].setName('\" + modelS + \"')\\n\")\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the Dummy Objects\\n')\n    out_file.write(i2 + '# To access the dummies\\n')\n    out_file.write(i2 + \"# theScene.dummyDict['Dummy_Name']\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for dummy in AllScene.dummyDict:\n        out_file.write('\\n')\n        dummyS = str(dummy)\n        if 1:\n            out_file.write(i2 + 'self.' + dummyS + '=loader.loadModel(\"models/misc/sphere\")\\n')\n            out_file.write(i2 + '# Transforming the Dummy\\n')\n            out_file.write(i2 + 'self.' + dummyS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.dummyDict[dummy].getX(), AllScene.dummyDict[dummy].getY(), AllScene.dummyDict[dummy].getZ(), AllScene.dummyDict[dummy].getH(), AllScene.dummyDict[dummy].getP(), AllScene.dummyDict[dummy].getR(), AllScene.dummyDict[dummy].getSx(), AllScene.dummyDict[dummy].getSy(), AllScene.dummyDict[dummy].getSz()))\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"']=self.\" + AllScene.dummyDict[dummy].getName() + '\\n')\n            out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"'].setName('\" + dummyS + \"')\\n\")\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.dummyDict[\"Dummy_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + dummyS + '.setTag(\"Metadata\",\"' + AllScene.dummyDict[dummy].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for all the Actors and animations\\n')\n    out_file.write(i2 + '# To access the Actors\\n')\n    out_file.write(i2 + \"# theScene.ActorDic['Actor_Name']\\n\")\n    out_file.write(i2 + \"# theScene.ActorDic['Actor_Name'].play('Animation_Name')\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n')\n    for actor in AllScene.ActorDic:\n        out_file.write('\\n')\n        actorS = str(actor)\n        if 1:\n            newpath = dirname + '/' + AllScene.ActorRefDic[actor].getBasename()\n            newpathF = Filename(newpath)\n            newpathSpecific = newpathF.toOsSpecific()\n            actorfnamelist = []\n            actorData = EggData()\n            actorData.read(AllScene.ActorRefDic[actor])\n            textures = EggTextureCollection()\n            textures.findUsedTextures(actorData)\n            for index in range(textures.getNumTextures()):\n                texture = textures.getTexture(index)\n                texfilename = texture.getFilename()\n                actorfnamelist.append(texfilename.getFullpath())\n                oldFilename = Filename(Filename(AllScene.ActorRefDic[actor].getDirname()), texfilename)\n                if not oldFilename.isRegularFile():\n                    if texfilename.resolveFilename(getTexturePath(), ''):\n                        oldFilename = texfilename\n                oldtexpath = oldFilename.toOsSpecific()\n                newtexpath = dirname + '/' + texfilename.getBasename()\n                newtexpathF = Filename(newtexpath)\n                newtexpathSpecific = newtexpathF.toOsSpecific()\n                print('TEXTURE SAVER:: copying' + oldtexpath + ' to ' + newtexpathSpecific)\n                if oldtexpath != newtexpathSpecific:\n                    shutil.copyfile(oldtexpath, newtexpathSpecific)\n            oldActorpath = AllScene.ActorRefDic[actor].toOsSpecific()\n            print('FILESAVER:: copying from ' + AllScene.ActorRefDic[actor].toOsSpecific() + 'to' + newpathSpecific)\n            if oldActorpath != newpathSpecific:\n                shutil.copyfile(oldActorpath, newpathSpecific)\n            e = EggData()\n            e.read(AllScene.ActorRefDic[actor])\n            etc = EggTextureCollection()\n            etc.extractTextures(e)\n            for index in range(len(actorfnamelist)):\n                print(actorfnamelist[index])\n                tex = etc.findFilename(Filename(actorfnamelist[index]))\n                fn = Filename(tex.getFilename())\n                fn.setDirname('')\n                tex.setFilename(fn)\n                e.writeEgg(Filename.fromOsSpecific(newpathSpecific))\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + \"=Actor.Actor('\" + self.savepath + '/' + AllScene.ActorRefDic[actor].getBasename() + \"')\\n\")\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + \"=Actor.Actor(self.executionpath + '/\" + AllScene.ActorRefDic[actor].getBasename() + \"')\\n\")\n            out_file.write(i2 + '# Transforming the Actor\\n')\n            out_file.write(i2 + 'self.' + actorS + '.setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (AllScene.ActorDic[actor].getX(), AllScene.ActorDic[actor].getY(), AllScene.ActorDic[actor].getZ(), AllScene.ActorDic[actor].getH(), AllScene.ActorDic[actor].getP(), AllScene.ActorDic[actor].getR(), AllScene.ActorDic[actor].getSx(), AllScene.ActorDic[actor].getSy(), AllScene.ActorDic[actor].getSz()))\n            if AllScene.ActorDic[actor].hasTransparency():\n                out_file.write(i2 + '# Alpha\\n')\n                out_file.write(i2 + 'self.' + actorS + '.setTransparency(1)\\n')\n                clr = AllScene.ActorDic[actor].getColor()\n                out_file.write(i2 + 'self.' + actorS + '.setColor(%.4f,%.4f,%.4f,%.4f)\\n' % (clr.getX(), clr.getY(), clr.getZ(), clr.getW()))\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(render)\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Save Metadata...can be retrieved by doing theScene.ActorDic[\"Actor_Name\"].getTag(\"Metadata\")\\n')\n            out_file.write(i2 + 'self.' + actorS + '.setTag(\"Metadata\",\"' + AllScene.ActorDic[actor].getTag('Metadata') + '\")\\n')\n            out_file.write('\\n')\n            out_file.write(i2 + '# Fill in the dictionaries which are used by level Ed to reload state\\n')\n            ActorAnimations = AllScene.getAnimationDictFromActor(actor)\n            ActorAnimationsInvoke = {}\n            if ActorAnimations != {}:\n                for animation in ActorAnimations:\n                    if not animation is None:\n                        print('ACTOR ANIMATIONS:' + ActorAnimations[animation])\n                        oldAnimPath = Filename(ActorAnimations[animation])\n                        oldAnim = oldAnimPath.toOsSpecific()\n                        dirOS = Filename(dirname)\n                        newAnim = dirOS.toOsSpecific() + '\\\\' + oldAnimPath.getBasename()\n                        print('ACTOR ANIM SAVER:: Comparing' + oldAnim + 'and' + newAnim)\n                        if oldAnim != newAnim:\n                            shutil.copyfile(oldAnim, newAnim)\n                        newAnimF = Filename.fromOsSpecific(newAnim)\n                        ActorAnimationsInvoke[animation] = 'self.executionpath +' + '/' + newAnimF.getBasename()\n                        ActorAnimations[animation] = self.savepath + '/' + newAnimF.getBasename()\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.' + actorS + '.loadAnims(' + str(ActorAnimations) + ')\\n')\n            out_file.write(i2 + 'else:\\n')\n            theloadAnimString = str(ActorAnimationsInvoke)\n            print('LOAD ANIM STRING BEFORE' + theloadAnimString)\n            theloadAnimString = theloadAnimString.replace(\"'self.executionpath +\", \"self.executionpath + '\")\n            print('LOAD ANIM STRING AFTER' + theloadAnimString)\n            out_file.write(i2 + i1 + 'self.' + actorS + '.loadAnims(' + theloadAnimString + ')\\n')\n            out_file.write(i2 + \"self.ActorDic['\" + actorS + \"']=self.\" + AllScene.ActorDic[actor].getName() + '\\n')\n            out_file.write(i2 + \"self.ActorRefDic['\" + actorS + \"']='\" + AllScene.ActorRefDic[actor].getBasename() + \"'\\n\")\n            out_file.write(i2 + \"self.ActorDic['\" + actorS + \"'].setName('\" + actorS + \"')\\n\")\n            if actor in AllScene.blendAnimDict:\n                out_file.write(i2 + 'self.blendAnimDict[\"' + actorS + '\"]=' + str(AllScene.blendAnimDict[actor]) + '\\n')\n            out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for setting up Collision Nodes\\n')\n    out_file.write(i2 + '# To use collision detection:\\n')\n    out_file.write(i2 + '# You must set up your own bitmasking and event handlers, the traverser \"cTrav\" is created for you at the top\\n')\n    out_file.write(i2 + '# The collision nodes are stored in collisionDict\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for collnode in AllScene.collisionDict:\n        collnodeS = str(collnode)\n        solid = AllScene.collisionDict[collnode].node().getSolid(0)\n        nodetype = solid.getType().getName()\n        if nodetype == 'CollisionSphere':\n            out_file.write(i2 + 'collSolid=CollisionSphere(%.3f,%.3f,%.3f,%.3f)\\n' % (solid.getCenter().getX(), solid.getCenter().getY(), solid.getCenter().getZ(), solid.getRadius()))\n            pass\n        elif nodetype == 'CollisionPolygon':\n            ax = AllScene.collisionDict[collnode].getTag('A_X')\n            ay = AllScene.collisionDict[collnode].getTag('A_Y')\n            az = AllScene.collisionDict[collnode].getTag('A_Z')\n            bx = AllScene.collisionDict[collnode].getTag('B_X')\n            by = AllScene.collisionDict[collnode].getTag('B_Y')\n            bz = AllScene.collisionDict[collnode].getTag('B_Z')\n            cx = AllScene.collisionDict[collnode].getTag('C_X')\n            cy = AllScene.collisionDict[collnode].getTag('C_Y')\n            cz = AllScene.collisionDict[collnode].getTag('C_Z')\n            out_file.write(i2 + 'pointA =  Point3(' + ax + ',' + ay + ',' + az + ')\\n')\n            out_file.write(i2 + 'pointB =  Point3(' + bx + ',' + by + ',' + bz + ')\\n')\n            out_file.write(i2 + 'pointC =  Point3(' + cx + ',' + cy + ',' + cz + ')\\n')\n            out_file.write(i2 + 'collSolid=CollisionPolygon(pointA, pointB, pointC)\\n')\n            pass\n        elif nodetype == 'CollisionSegment':\n            A = AllScene.collisionDict[collnode].node().getSolid(0).getPointA()\n            B = AllScene.collisionDict[collnode].node().getSolid(0).getPointB()\n            out_file.write(i2 + 'pointA =  Point3(%.3f,%.3f,%.3f)\\n' % (A.getX(), A.getY(), A.getZ()))\n            out_file.write(i2 + 'pointB =  Point3(%.3f,%.3f,%.3f)\\n' % (B.getX(), B.getY(), B.getZ()))\n            out_file.write(i2 + 'collSolid=CollisionSegment()\\n')\n            out_file.write(i2 + 'collSolid.setPointA(pointA)\\n')\n            out_file.write(i2 + 'collSolid.setFromLens(base.cam.node(),Point2(-1,1))\\n')\n            out_file.write(i2 + 'collSolid.setPointB(pointB)\\n')\n            pass\n        elif nodetype == 'CollisionRay':\n            P = AllScene.collisionDict[collnode].node().getSolid(0).getOrigin()\n            V = AllScene.collisionDict[collnode].node().getSolid(0).getDirection()\n            out_file.write(i2 + 'point=Point3(%.3f,%.3f,%.3f)\\n' % (P.getX(), P.getY(), P.getZ()))\n            out_file.write(i2 + 'vector=Vec3(%.3f,%.3f,%.3f)\\n' % (V.getX(), V.getY(), V.getZ()))\n            out_file.write(i2 + 'collSolid=CollisionRay()\\n')\n            out_file.write(i2 + 'collSolid.setOrigin(point)\\n')\n            out_file.write(i2 + 'collSolid.setDirection(vector)\\n')\n            pass\n        else:\n            print('Invalid Collision Node: ' + nodetype)\n        out_file.write('\\n')\n        out_file.write(i2 + 'self.' + collnodeS + '_Node' + '=CollisionNode(\"' + collnodeS + '\")\\n')\n        out_file.write(i2 + 'self.' + collnodeS + '_Node' + '.addSolid(collSolid)\\n')\n        out_file.write(i2 + 'base.cTrav.addCollider(self.' + collnodeS + '_Node,self.CollisionHandler)\\n')\n        out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Code for Lighting\\n')\n    out_file.write(i2 + '# To manipulated lights:\\n')\n    out_file.write(i2 + \"# Manipulate the light node in theScene.LightNodes['Light_Name']\\n\")\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    LightList = AllScene.lightManager.getLightNodeList()\n    for light in LightList:\n        type = light.getType()\n        if type == 'ambient':\n            out_file.write(i2 + '# Ambient Light\\n')\n            out_file.write(i2 + 'self.ambientCount += 1\\n')\n            out_file.write(i2 + \"alight = AmbientLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'directional':\n            out_file.write(i2 + '# Directional Light\\n')\n            out_file.write(i2 + 'self.directionalCount += 1\\n')\n            out_file.write(i2 + \"alight = DirectionalLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setHpr(Vec3(' + str(light.getH()) + ',' + str(light.getP()) + ',' + str(light.getR()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'point':\n            out_file.write(i2 + '# Point Light\\n')\n            out_file.write(i2 + 'self.pointCount += 1\\n')\n            out_file.write(i2 + \"alight = PointLight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setAttenuation(Vec3(' + str(light.getAttenuation().getX()) + ',' + str(light.getAttenuation().getY()) + ',' + str(light.getAttenuation().getZ()) + '))\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        elif type == 'spot':\n            out_file.write(i2 + '# Spot Light\\n')\n            out_file.write(i2 + 'self.spotCount += 1\\n')\n            out_file.write(i2 + \"alight = Spotlight('\" + light.getName() + \"')\\n\")\n            out_file.write(i2 + 'alight.setColor(VBase4(' + str(light.getLightColor().getX()) + ',' + str(light.getLightColor().getY()) + ',' + str(light.getLightColor().getZ()) + ',' + str(light.getLightColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alens = PerspectiveLens()\\n')\n            out_file.write(i2 + 'alight.setLens(alens)\\n')\n            out_file.write(i2 + 'alight.setSpecularColor(Vec4(' + str(light.getSpecColor().getX()) + ',' + str(light.getSpecColor().getY()) + ',' + str(light.getSpecColor().getZ()) + ',' + str(light.getSpecColor().getW()) + '))\\n')\n            out_file.write(i2 + 'alight.setAttenuation(Vec3(' + str(light.getAttenuation().getX()) + ',' + str(light.getAttenuation().getY()) + ',' + str(light.getAttenuation().getZ()) + '))\\n')\n            out_file.write(i2 + 'alight.setExponent(' + str(light.getExponent()) + ')\\n')\n            out_file.write(i2 + 'self.lightAttrib=self.lightAttrib.addLight(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '= render.attachNewNode(alight)\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setTag(\"Metadata\",\"' + light.getTag('Metadata') + '\")\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setPos(Point3(' + str(light.getX()) + ',' + str(light.getY()) + ',' + str(light.getZ()) + '))\\n')\n            out_file.write(i2 + 'self.' + light.getName() + '.setHpr(Vec3(' + str(light.getH()) + ',' + str(light.getP()) + ',' + str(light.getR()) + '))\\n')\n            out_file.write(i2 + \"self.LightDict['\" + light.getName() + \"']=alight\\n\")\n            out_file.write(i2 + \"self.LightTypes['\" + light.getName() + \"']='\" + type + \"'\\n\")\n            out_file.write(i2 + \"self.LightNodes['\" + light.getName() + \"']=self.\" + light.getName() + '\\n')\n            out_file.write('\\n')\n        else:\n            out_file.write(i2 + \"print 'Invalid light type'\")\n            out_file.write(i2 + 'return None')\n        out_file.write('\\n')\n    out_file.write(i2 + '# Enable Ligthing\\n')\n    out_file.write(i2 + 'render.node().setAttrib(self.lightAttrib)\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '# Load Particle Effects. The parameters to this function are to allow us to use our modified versions of the Particle Effects modules when loading this file with the level editor\\n')\n    out_file.write(i2 + 'self.starteffects(self.loadmode,self.seParticleEffect,self.seParticles)\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '# Save Camera Settings\\n')\n    out_file.write(i2 + 'camera.setX(' + str(camera.getX()) + ')\\n')\n    out_file.write(i2 + 'camera.setY(' + str(camera.getY()) + ')\\n')\n    out_file.write(i2 + 'camera.setZ(' + str(camera.getZ()) + ')\\n')\n    out_file.write(i2 + 'camera.setH(' + str(camera.getH()) + ')\\n')\n    out_file.write(i2 + 'camera.setP(' + str(camera.getP()) + ')\\n')\n    out_file.write(i2 + 'camera.setR(' + str(camera.getR()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setNear(' + str(camera.getChild(0).node().getLens().getNear()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFar(' + str(camera.getChild(0).node().getLens().getFar()) + ')\\n')\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFov(VBase2(%.5f,%.5f))\\n' % (camera.getChild(0).node().getLens().getHfov(), camera.getChild(0).node().getLens().getVfov()))\n    FilmSize = camera.getChild(0).node().getLens().getFilmSize()\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFilmSize(%.3f,%.3f)\\n' % (FilmSize.getX(), FilmSize.getY()))\n    out_file.write(i2 + 'camera.getChild(0).node().getLens().setFocalLength(' + str(camera.getChild(0).node().getLens().getFocalLength()) + ')\\n')\n    out_file.write(i2 + 'camera.setTag(\"Metadata\",\"' + camera.getTag('Metadata') + '\")\\n')\n    out_file.write(i2 + 'camera.reparentTo(render)\\n')\n    out_file.write(i2 + 'base.disableMouse()\\n')\n    self.bgColor = base.getBackgroundColor()\n    out_file.write(i2 + 'base.setBackgroundColor(%.3f,%.3f,%.3f)\\n' % (self.bgColor.getX(), self.bgColor.getY(), self.bgColor.getZ()))\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Motion Paths\\n')\n    out_file.write(i2 + '# Using Mopaths:\\n')\n    out_file.write(i2 + '# theScene.curveIntervals[0].start() or .loop() will play curve with index 0\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for node in AllScene.curveDict:\n        curveCollection = AllScene.curveDict[node]\n        curvenumber = 0\n        for curve in curveCollection:\n            filestring = dirname + '\\\\' + str(node) + '_curve_' + str(curvenumber) + '.egg'\n            f = Filename.fromOsSpecific(filestring)\n            filestring = f.getBasename()\n            curve.writeEgg(f)\n            out_file.write(i2 + 'm=Mopath.Mopath()\\n')\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'm.loadFile(\"' + self.savepath + '/' + filestring + '\")\\n')\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'm.loadFile(self.executionpath + \"/' + filestring + '\")\\n')\n            out_file.write(i2 + 'mp=MopathInterval(m,self.' + str(node) + ')\\n')\n            out_file.write(i2 + 'self.curveIntervals.append(mp)\\n')\n            out_file.write(i2 + 'if(self.loadmode==1):\\n')\n            out_file.write(i2 + i1 + 'self.curveRefColl.append(\"' + self.savepath + '/' + filestring + '\")\\n')\n            out_file.write(i2 + 'else:\\n')\n            out_file.write(i2 + i1 + 'self.curveRefColl.append(self.executionpath + \"/' + filestring + '\")\\n')\n            curvenumber = curvenumber + 1\n        out_file.write(i2 + 'self.curveIntervalsDict[\"' + str(node) + '\"]=self.curveIntervals\\n')\n        out_file.write(i2 + 'self.curveDict[\"' + str(node) + '\"]=self.curveRefColl\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Reparenting\\n')\n    out_file.write(i2 + '# A final pass is done on setting all the scenegraph hierarchy after all objects are laoded\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for model in AllScene.ModelDic:\n        modelS = str(model)\n        parent = AllScene.ModelDic[model].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + modelS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.ModelDic['\" + modelS + \"']=self.\" + AllScene.ModelDic[model].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for dummy in AllScene.dummyDict:\n        dummyS = str(dummy)\n        parent = AllScene.dummyDict[dummy].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + dummyS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.dummyDict['\" + dummyS + \"']=self.\" + AllScene.dummyDict[dummy].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for actor in AllScene.ActorDic:\n        actorS = str(actor)\n        parent = AllScene.ActorDic[actor].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(' + parent + ')\\n')\n        elif parent in AllScene.particleDict:\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(self.' + parent + '.getEffect())\\n')\n        else:\n            out_file.write(i2 + 'self.' + actorS + '.reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + \"self.ActorDic['\" + actorS + \"']=self.\" + AllScene.ActorDic[actor].getName() + '\\n')\n        out_file.write(i2 + '\\n')\n    for collnode in AllScene.collisionDict:\n        collnodeS = str(collnode)\n        solid = AllScene.collisionDict[collnode].node().getSolid(0)\n        nodetype = solid.getType().getName()\n        parentname = AllScene.collisionDict[collnode].getParent().getName()\n        if parentname == 'render' or parentname == 'camera':\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=' + parentname + '.attachNewNode(self.' + collnodeS + '_Node)\\n')\n        elif parentname in AllScene.particleDict:\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=self.' + parentname + 'getEffect().attachNewNode(self.' + collnodeS + '_Node)\\n')\n        else:\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"]=self.' + parentname + '.attachNewNode(self.' + collnodeS + '_Node)\\n')\n        dictelem = AllScene.collisionDict[collnode]\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setPosHprScale(%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)\\n' % (dictelem.getX(), dictelem.getY(), dictelem.getZ(), dictelem.getH(), dictelem.getP(), dictelem.getR(), dictelem.getSx(), dictelem.getSy(), dictelem.getSz()))\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\"Metadata\",\"' + AllScene.collisionDict[collnode].getTag('Metadata') + '\")\\n')\n        out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].show()\\n')\n        if nodetype == 'CollisionPolygon':\n            ax = float(AllScene.collisionDict[collnode].getTag('A_X'))\n            ay = float(AllScene.collisionDict[collnode].getTag('A_Y'))\n            az = float(AllScene.collisionDict[collnode].getTag('A_Z'))\n            bx = float(AllScene.collisionDict[collnode].getTag('B_X'))\n            by = float(AllScene.collisionDict[collnode].getTag('B_Y'))\n            bz = float(AllScene.collisionDict[collnode].getTag('B_Z'))\n            cx = float(AllScene.collisionDict[collnode].getTag('C_X'))\n            cy = float(AllScene.collisionDict[collnode].getTag('C_Y'))\n            cz = float(AllScene.collisionDict[collnode].getTag('C_Z'))\n            out_file.write(i2 + 'pointA=Point3(%.3f,%.3f,%.3f)\\n' % (ax, ay, az))\n            out_file.write(i2 + 'pointB=Point3(%.3f,%.3f,%.3f)\\n' % (bx, by, bz))\n            out_file.write(i2 + 'pointC=Point3(%.3f,%.3f,%.3f)\\n' % (cx, cy, cz))\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_X\\',\\'%f\\'%pointA.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_Y\\',\\'%f\\'%pointA.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'A_Z\\',\\'%f\\'%pointA.getZ())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_X\\',\\'%f\\'%pointB.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_Y\\',\\'%f\\'%pointB.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'B_Z\\',\\'%f\\'%pointB.getZ())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_X\\',\\'%f\\'%pointC.getX())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_Y\\',\\'%f\\'%pointC.getY())\\n')\n            out_file.write(i2 + 'self.collisionDict[\"' + collnodeS + '\"].setTag(\\'C_Z\\',\\'%f\\'%pointC.getZ())\\n')\n        out_file.write(i2 + '\\n')\n    for effect in AllScene.particleDict:\n        parent = AllScene.particleNodes[effect].getParent().getName()\n        if parent == 'render' or parent == 'camera':\n            out_file.write(i2 + 'self.particleDict[\"' + str(effect) + '\"].reparentTo(' + parent + ')\\n')\n        else:\n            out_file.write(i2 + 'self.particleDict[\"' + str(effect) + '\"].reparentTo(self.' + parent + ')\\n')\n        out_file.write(i2 + '\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Particle Effects\\n')\n    out_file.write(i2 + '# Using Particles:\\n')\n    out_file.write(i2 + '# theScene.enableeffect(\"Effect_Name\")\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write(i1 + 'def starteffects(self,mode,seParticleEffect=None,seParticles=None):\\n')\n    for effect in AllScene.particleDict:\n        effectS = str(effect)\n        out_file.write(i2 + 'self.' + effectS + '=' + effectS + '(mode,seParticleEffect,seParticles)\\n')\n        out_file.write(i2 + 'effect=self.' + effectS + '.getEffect()\\n')\n        out_file.write(i2 + 'self.particleDict[\"' + effectS + '\"]=effect\\n')\n        out_file.write(i2 + 'effect.reparentTo(render)\\n')\n        thenode = AllScene.particleNodes[effect]\n        out_file.write(i2 + 'self.particleDict[\"' + effectS + '\"].setPosHprScale(%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f)\\n' % (thenode.getX(), thenode.getY(), thenode.getZ(), thenode.getH(), thenode.getP(), thenode.getR(), thenode.getSx(), thenode.getSy(), thenode.getSz()))\n        out_file.write('\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def enableeffect(self,effect_name):\\n')\n    out_file.write(i2 + 'self.particleDict[effect_name].enable()\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def disableeffect(self,effect_name):\\n')\n    out_file.write(i2 + 'self.particleDict[effect_name].disable()\\n')\n    out_file.write(i2 + 'return\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Animation Blending\\n')\n    out_file.write(i2 + '# Using blending:\\n')\n    out_file.write(i2 + '# theScene.playBlendAnim(actor,blendname)\\n')\n    out_file.write(i2 + '# theScene.stopBlendAnim(actor,blendname)\\n')\n    out_file.write(i2 + '# theScene.changeBlendAnim(actor,blendname,blend_amount)\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write(i1 + 'def playBlendAnim(self,actor,blendName,loop=0):\\n')\n    out_file.write(i2 + 'actor.enableBlend()\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'actor.setControlEffect(blendList[0],blendList[2])\\n')\n    out_file.write(i2 + 'actor.setControlEffect(blendList[1],1.0-blendList[2])\\n')\n    out_file.write(i2 + 'if(loop):\\n')\n    out_file.write(i2 + i1 + 'actor.loop(blendList[0])\\n')\n    out_file.write(i2 + i1 + 'actor.loop(blendList[1])\\n')\n    out_file.write(i2 + 'else:\\n')\n    out_file.write(i2 + i1 + 'actor.start(blendList[0])\\n')\n    out_file.write(i2 + i1 + 'actor.start(blendList[1])\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def stopBlendAnim(self,actor,blendName):\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'actor.stop(blendList[0])\\n')\n    out_file.write(i2 + 'actor.stop(blendList[1])\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def changeBlending(self,actor,blendName,blending):\\n')\n    out_file.write(i2 + 'blendDicts=self.blendAnimDict[actor.getName()]\\n')\n    out_file.write(i2 + 'blendList=blendDicts[blendName]\\n')\n    out_file.write(i2 + 'blendList[2]=blending\\n')\n    out_file.write(i2 + 'self.blendAnimDict[actor.getName()]={blendName:[blendList[0],blendList[1],blending]}\\n')\n    out_file.write('\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Hide and Show Methods\\n')\n    out_file.write(i2 + '# These will help you hide/show dummies, collision solids, effect nodes etc.\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideDummies(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for dummy in self.dummyDict:\\n')\n    out_file.write(i2 + i1 + 'self.dummyDict[dummy].reparentTo(hidden)\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideCollSolids(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for collSolid in self.collisionDict:\\n')\n    out_file.write(i2 + i1 + 'self.collisionDict[collSolid].hide()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def hideEffectNodes(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for effectnode in self.particleNodes:\\n')\n    out_file.write(i2 + i1 + 'self.particleNodes[effectnode].hide()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showDummies(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for dummy in self.dummyDict:\\n')\n    out_file.write(i2 + i1 + 'self.dummyDict[dummy].reparentTo(hidden)\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showCollSolids(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for collSolid in self.collisionDict:\\n')\n    out_file.write(i2 + i1 + 'self.collisionDict[collSolid].show()\\n')\n    out_file.write('\\n')\n    out_file.write(i1 + 'def showEffectNodes(self):\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + 'for effectnode in self.particleNodes:\\n')\n    out_file.write(i2 + i1 + 'self.particleNodes[effectnode].show()\\n\\n')\n    out_file.write('\\n')\n    out_file.write(i2 + '##########################################################################################################\\n')\n    out_file.write(i2 + '# Particle Effects\\n')\n    out_file.write(i2 + '# This is where effect parameters are saved in a class\\n')\n    out_file.write(i2 + '# The class is then instantiated in the starteffects method and appended to the dictionaries\\n')\n    out_file.write(i2 + '##########################################################################################################\\n\\n')\n    for effect in AllScene.particleDict:\n        out_file.write('\\n\\n')\n        out_file.write('class ' + str(effect) + ':\\n')\n        out_file.write(i1 + 'def __init__(self,mode=1,seParticleEffect=None,seParticles=None):\\n')\n        out_file.write(i2 + 'if(mode==0):\\n')\n        out_file.write(i2 + i1 + 'self.effect=seParticleEffect.ParticleEffect()\\n')\n        out_file.write(i2 + 'else:\\n')\n        out_file.write(i2 + i1 + 'self.effect=ParticleEffect.ParticleEffect()\\n')\n        AllScene.particleDict[effect].AppendConfig(out_file)\n        out_file.write('\\n\\n')\n        out_file.write(i1 + 'def starteffect(self):\\n')\n        out_file.write(i2 + 'pass\\n')\n        out_file.write('\\n\\n')\n        out_file.write(i1 + 'def stopeffect(self):\\n')\n        out_file.write(i2 + 'pass\\n\\n')\n        out_file.write(i1 + 'def getEffect(self):\\n')\n        out_file.write(i2 + 'return self.effect\\n\\n')\n    out_file.close()"
        ]
    }
]