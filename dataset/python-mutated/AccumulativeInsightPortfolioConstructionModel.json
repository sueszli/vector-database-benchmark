[
    {
        "func_name": "__init__",
        "original": "def __init__(self, rebalance=None, portfolioBias=PortfolioBias.LongShort, percent=0.03):\n    \"\"\"Initialize a new instance of AccumulativeInsightPortfolioConstructionModel\n        Args:\n            rebalance: Rebalancing parameter. If it is a timedelta, date rules or Resolution, it will be converted into a function.\n                              If None will be ignored.\n                              The function returns the next expected rebalance time for a given algorithm UTC DateTime.\n                              The function returns null if unknown, in which case the function will be called again in the\n                              next loop. Returning current time will trigger rebalance.\n            portfolioBias: Specifies the bias of the portfolio (Short, Long/Short, Long)\n            percent: percent of portfolio to allocate to each position\"\"\"\n    super().__init__(rebalance)\n    self.portfolioBias = portfolioBias\n    self.percent = abs(percent)\n    self.sign = lambda x: -1 if x < 0 else 1 if x > 0 else 0",
        "mutated": [
            "def __init__(self, rebalance=None, portfolioBias=PortfolioBias.LongShort, percent=0.03):\n    if False:\n        i = 10\n    'Initialize a new instance of AccumulativeInsightPortfolioConstructionModel\\n        Args:\\n            rebalance: Rebalancing parameter. If it is a timedelta, date rules or Resolution, it will be converted into a function.\\n                              If None will be ignored.\\n                              The function returns the next expected rebalance time for a given algorithm UTC DateTime.\\n                              The function returns null if unknown, in which case the function will be called again in the\\n                              next loop. Returning current time will trigger rebalance.\\n            portfolioBias: Specifies the bias of the portfolio (Short, Long/Short, Long)\\n            percent: percent of portfolio to allocate to each position'\n    super().__init__(rebalance)\n    self.portfolioBias = portfolioBias\n    self.percent = abs(percent)\n    self.sign = lambda x: -1 if x < 0 else 1 if x > 0 else 0",
            "def __init__(self, rebalance=None, portfolioBias=PortfolioBias.LongShort, percent=0.03):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialize a new instance of AccumulativeInsightPortfolioConstructionModel\\n        Args:\\n            rebalance: Rebalancing parameter. If it is a timedelta, date rules or Resolution, it will be converted into a function.\\n                              If None will be ignored.\\n                              The function returns the next expected rebalance time for a given algorithm UTC DateTime.\\n                              The function returns null if unknown, in which case the function will be called again in the\\n                              next loop. Returning current time will trigger rebalance.\\n            portfolioBias: Specifies the bias of the portfolio (Short, Long/Short, Long)\\n            percent: percent of portfolio to allocate to each position'\n    super().__init__(rebalance)\n    self.portfolioBias = portfolioBias\n    self.percent = abs(percent)\n    self.sign = lambda x: -1 if x < 0 else 1 if x > 0 else 0",
            "def __init__(self, rebalance=None, portfolioBias=PortfolioBias.LongShort, percent=0.03):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialize a new instance of AccumulativeInsightPortfolioConstructionModel\\n        Args:\\n            rebalance: Rebalancing parameter. If it is a timedelta, date rules or Resolution, it will be converted into a function.\\n                              If None will be ignored.\\n                              The function returns the next expected rebalance time for a given algorithm UTC DateTime.\\n                              The function returns null if unknown, in which case the function will be called again in the\\n                              next loop. Returning current time will trigger rebalance.\\n            portfolioBias: Specifies the bias of the portfolio (Short, Long/Short, Long)\\n            percent: percent of portfolio to allocate to each position'\n    super().__init__(rebalance)\n    self.portfolioBias = portfolioBias\n    self.percent = abs(percent)\n    self.sign = lambda x: -1 if x < 0 else 1 if x > 0 else 0",
            "def __init__(self, rebalance=None, portfolioBias=PortfolioBias.LongShort, percent=0.03):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialize a new instance of AccumulativeInsightPortfolioConstructionModel\\n        Args:\\n            rebalance: Rebalancing parameter. If it is a timedelta, date rules or Resolution, it will be converted into a function.\\n                              If None will be ignored.\\n                              The function returns the next expected rebalance time for a given algorithm UTC DateTime.\\n                              The function returns null if unknown, in which case the function will be called again in the\\n                              next loop. Returning current time will trigger rebalance.\\n            portfolioBias: Specifies the bias of the portfolio (Short, Long/Short, Long)\\n            percent: percent of portfolio to allocate to each position'\n    super().__init__(rebalance)\n    self.portfolioBias = portfolioBias\n    self.percent = abs(percent)\n    self.sign = lambda x: -1 if x < 0 else 1 if x > 0 else 0",
            "def __init__(self, rebalance=None, portfolioBias=PortfolioBias.LongShort, percent=0.03):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialize a new instance of AccumulativeInsightPortfolioConstructionModel\\n        Args:\\n            rebalance: Rebalancing parameter. If it is a timedelta, date rules or Resolution, it will be converted into a function.\\n                              If None will be ignored.\\n                              The function returns the next expected rebalance time for a given algorithm UTC DateTime.\\n                              The function returns null if unknown, in which case the function will be called again in the\\n                              next loop. Returning current time will trigger rebalance.\\n            portfolioBias: Specifies the bias of the portfolio (Short, Long/Short, Long)\\n            percent: percent of portfolio to allocate to each position'\n    super().__init__(rebalance)\n    self.portfolioBias = portfolioBias\n    self.percent = abs(percent)\n    self.sign = lambda x: -1 if x < 0 else 1 if x > 0 else 0"
        ]
    },
    {
        "func_name": "DetermineTargetPercent",
        "original": "def DetermineTargetPercent(self, activeInsights):\n    \"\"\"Will determine the target percent for each insight\n        Args:\n            activeInsights: The active insights to generate a target for\"\"\"\n    percentPerSymbol = {}\n    insights = sorted(self.Algorithm.Insights.GetActiveInsights(self.currentUtcTime), key=lambda insight: insight.GeneratedTimeUtc)\n    for insight in insights:\n        targetPercent = 0\n        if insight.Symbol in percentPerSymbol:\n            targetPercent = percentPerSymbol[insight.Symbol]\n            if insight.Direction == InsightDirection.Flat:\n                if abs(targetPercent) < self.percent:\n                    targetPercent = 0\n                else:\n                    targetPercent += -self.percent if targetPercent > 0 else self.percent\n        targetPercent += self.percent * insight.Direction\n        if self.portfolioBias != PortfolioBias.LongShort and self.sign(targetPercent) != self.portfolioBias:\n            targetPercent = 0\n        percentPerSymbol[insight.Symbol] = targetPercent\n    return dict(((insight, percentPerSymbol[insight.Symbol]) for insight in activeInsights))",
        "mutated": [
            "def DetermineTargetPercent(self, activeInsights):\n    if False:\n        i = 10\n    'Will determine the target percent for each insight\\n        Args:\\n            activeInsights: The active insights to generate a target for'\n    percentPerSymbol = {}\n    insights = sorted(self.Algorithm.Insights.GetActiveInsights(self.currentUtcTime), key=lambda insight: insight.GeneratedTimeUtc)\n    for insight in insights:\n        targetPercent = 0\n        if insight.Symbol in percentPerSymbol:\n            targetPercent = percentPerSymbol[insight.Symbol]\n            if insight.Direction == InsightDirection.Flat:\n                if abs(targetPercent) < self.percent:\n                    targetPercent = 0\n                else:\n                    targetPercent += -self.percent if targetPercent > 0 else self.percent\n        targetPercent += self.percent * insight.Direction\n        if self.portfolioBias != PortfolioBias.LongShort and self.sign(targetPercent) != self.portfolioBias:\n            targetPercent = 0\n        percentPerSymbol[insight.Symbol] = targetPercent\n    return dict(((insight, percentPerSymbol[insight.Symbol]) for insight in activeInsights))",
            "def DetermineTargetPercent(self, activeInsights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Will determine the target percent for each insight\\n        Args:\\n            activeInsights: The active insights to generate a target for'\n    percentPerSymbol = {}\n    insights = sorted(self.Algorithm.Insights.GetActiveInsights(self.currentUtcTime), key=lambda insight: insight.GeneratedTimeUtc)\n    for insight in insights:\n        targetPercent = 0\n        if insight.Symbol in percentPerSymbol:\n            targetPercent = percentPerSymbol[insight.Symbol]\n            if insight.Direction == InsightDirection.Flat:\n                if abs(targetPercent) < self.percent:\n                    targetPercent = 0\n                else:\n                    targetPercent += -self.percent if targetPercent > 0 else self.percent\n        targetPercent += self.percent * insight.Direction\n        if self.portfolioBias != PortfolioBias.LongShort and self.sign(targetPercent) != self.portfolioBias:\n            targetPercent = 0\n        percentPerSymbol[insight.Symbol] = targetPercent\n    return dict(((insight, percentPerSymbol[insight.Symbol]) for insight in activeInsights))",
            "def DetermineTargetPercent(self, activeInsights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Will determine the target percent for each insight\\n        Args:\\n            activeInsights: The active insights to generate a target for'\n    percentPerSymbol = {}\n    insights = sorted(self.Algorithm.Insights.GetActiveInsights(self.currentUtcTime), key=lambda insight: insight.GeneratedTimeUtc)\n    for insight in insights:\n        targetPercent = 0\n        if insight.Symbol in percentPerSymbol:\n            targetPercent = percentPerSymbol[insight.Symbol]\n            if insight.Direction == InsightDirection.Flat:\n                if abs(targetPercent) < self.percent:\n                    targetPercent = 0\n                else:\n                    targetPercent += -self.percent if targetPercent > 0 else self.percent\n        targetPercent += self.percent * insight.Direction\n        if self.portfolioBias != PortfolioBias.LongShort and self.sign(targetPercent) != self.portfolioBias:\n            targetPercent = 0\n        percentPerSymbol[insight.Symbol] = targetPercent\n    return dict(((insight, percentPerSymbol[insight.Symbol]) for insight in activeInsights))",
            "def DetermineTargetPercent(self, activeInsights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Will determine the target percent for each insight\\n        Args:\\n            activeInsights: The active insights to generate a target for'\n    percentPerSymbol = {}\n    insights = sorted(self.Algorithm.Insights.GetActiveInsights(self.currentUtcTime), key=lambda insight: insight.GeneratedTimeUtc)\n    for insight in insights:\n        targetPercent = 0\n        if insight.Symbol in percentPerSymbol:\n            targetPercent = percentPerSymbol[insight.Symbol]\n            if insight.Direction == InsightDirection.Flat:\n                if abs(targetPercent) < self.percent:\n                    targetPercent = 0\n                else:\n                    targetPercent += -self.percent if targetPercent > 0 else self.percent\n        targetPercent += self.percent * insight.Direction\n        if self.portfolioBias != PortfolioBias.LongShort and self.sign(targetPercent) != self.portfolioBias:\n            targetPercent = 0\n        percentPerSymbol[insight.Symbol] = targetPercent\n    return dict(((insight, percentPerSymbol[insight.Symbol]) for insight in activeInsights))",
            "def DetermineTargetPercent(self, activeInsights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Will determine the target percent for each insight\\n        Args:\\n            activeInsights: The active insights to generate a target for'\n    percentPerSymbol = {}\n    insights = sorted(self.Algorithm.Insights.GetActiveInsights(self.currentUtcTime), key=lambda insight: insight.GeneratedTimeUtc)\n    for insight in insights:\n        targetPercent = 0\n        if insight.Symbol in percentPerSymbol:\n            targetPercent = percentPerSymbol[insight.Symbol]\n            if insight.Direction == InsightDirection.Flat:\n                if abs(targetPercent) < self.percent:\n                    targetPercent = 0\n                else:\n                    targetPercent += -self.percent if targetPercent > 0 else self.percent\n        targetPercent += self.percent * insight.Direction\n        if self.portfolioBias != PortfolioBias.LongShort and self.sign(targetPercent) != self.portfolioBias:\n            targetPercent = 0\n        percentPerSymbol[insight.Symbol] = targetPercent\n    return dict(((insight, percentPerSymbol[insight.Symbol]) for insight in activeInsights))"
        ]
    },
    {
        "func_name": "CreateTargets",
        "original": "def CreateTargets(self, algorithm, insights):\n    \"\"\"Create portfolio targets from the specified insights\n        Args:\n            algorithm: The algorithm instance\n            insights: The insights to create portfolio targets from\n        Returns:\n            An enumerable of portfolio targets to be sent to the execution model\"\"\"\n    self.currentUtcTime = algorithm.UtcTime\n    return super().CreateTargets(algorithm, insights)",
        "mutated": [
            "def CreateTargets(self, algorithm, insights):\n    if False:\n        i = 10\n    'Create portfolio targets from the specified insights\\n        Args:\\n            algorithm: The algorithm instance\\n            insights: The insights to create portfolio targets from\\n        Returns:\\n            An enumerable of portfolio targets to be sent to the execution model'\n    self.currentUtcTime = algorithm.UtcTime\n    return super().CreateTargets(algorithm, insights)",
            "def CreateTargets(self, algorithm, insights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create portfolio targets from the specified insights\\n        Args:\\n            algorithm: The algorithm instance\\n            insights: The insights to create portfolio targets from\\n        Returns:\\n            An enumerable of portfolio targets to be sent to the execution model'\n    self.currentUtcTime = algorithm.UtcTime\n    return super().CreateTargets(algorithm, insights)",
            "def CreateTargets(self, algorithm, insights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create portfolio targets from the specified insights\\n        Args:\\n            algorithm: The algorithm instance\\n            insights: The insights to create portfolio targets from\\n        Returns:\\n            An enumerable of portfolio targets to be sent to the execution model'\n    self.currentUtcTime = algorithm.UtcTime\n    return super().CreateTargets(algorithm, insights)",
            "def CreateTargets(self, algorithm, insights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create portfolio targets from the specified insights\\n        Args:\\n            algorithm: The algorithm instance\\n            insights: The insights to create portfolio targets from\\n        Returns:\\n            An enumerable of portfolio targets to be sent to the execution model'\n    self.currentUtcTime = algorithm.UtcTime\n    return super().CreateTargets(algorithm, insights)",
            "def CreateTargets(self, algorithm, insights):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create portfolio targets from the specified insights\\n        Args:\\n            algorithm: The algorithm instance\\n            insights: The insights to create portfolio targets from\\n        Returns:\\n            An enumerable of portfolio targets to be sent to the execution model'\n    self.currentUtcTime = algorithm.UtcTime\n    return super().CreateTargets(algorithm, insights)"
        ]
    }
]