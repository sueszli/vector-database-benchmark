[
    {
        "func_name": "integrate",
        "original": "def integrate(depth_file_names, color_file_names, intrinsic, extrinsics, config):\n    if os.path.exists(config.path_npz):\n        print(f'Voxel block grid npz file {config.path_npz} found, trying to load...')\n        vbg = o3d.t.geometry.VoxelBlockGrid.load(config.path_npz)\n        print('Loading finished.')\n        return vbg\n    print(f'Voxel block grid npz file {config.path_npz} not found, trying to integrate...')\n    n_files = len(depth_file_names)\n    device = o3d.core.Device(config.device)\n    voxel_size = 3.0 / 512\n    trunc = voxel_size * 4\n    res = 8\n    if config.integrate_color:\n        vbg = o3d.t.geometry.VoxelBlockGrid(('tsdf', 'weight', 'color'), (o3c.float32, o3c.float32, o3c.float32), (1, 1, 3), 3.0 / 512, 8, 100000, device)\n    else:\n        vbg = o3d.t.geometry.VoxelBlockGrid(('tsdf', 'weight'), (o3c.float32, o3c.float32), (1, 1), 3.0 / 512, 8, 100000, device)\n    start = time.time()\n    for i in tqdm(range(n_files)):\n        depth = o3d.t.io.read_image(depth_file_names[i]).to(device)\n        extrinsic = extrinsics[i]\n        start = time.time()\n        frustum_block_coords = vbg.compute_unique_block_coordinates(depth, intrinsic, extrinsic, config.depth_scale, config.depth_max)\n        vbg.hashmap().activate(frustum_block_coords)\n        (buf_indices, masks) = vbg.hashmap().find(frustum_block_coords)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        (voxel_coords, voxel_indices) = vbg.voxel_coordinates_and_flattened_indices(buf_indices)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        extrinsic_dev = extrinsic.to(device, o3c.float32)\n        xyz = extrinsic_dev[:3, :3] @ voxel_coords.T() + extrinsic_dev[:3, 3:]\n        intrinsic_dev = intrinsic.to(device, o3c.float32)\n        uvd = intrinsic_dev @ xyz\n        d = uvd[2]\n        u = (uvd[0] / d).round().to(o3c.int64)\n        v = (uvd[1] / d).round().to(o3c.int64)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        mask_proj = (d > 0) & (u >= 0) & (v >= 0) & (u < depth.columns) & (v < depth.rows)\n        v_proj = v[mask_proj]\n        u_proj = u[mask_proj]\n        d_proj = d[mask_proj]\n        depth_readings = depth.as_tensor()[v_proj, u_proj, 0].to(o3c.float32) / config.depth_scale\n        sdf = depth_readings - d_proj\n        mask_inlier = (depth_readings > 0) & (depth_readings < config.depth_max) & (sdf >= -trunc)\n        sdf[sdf >= trunc] = trunc\n        sdf = sdf / trunc\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        weight = vbg.attribute('weight').reshape((-1, 1))\n        tsdf = vbg.attribute('tsdf').reshape((-1, 1))\n        valid_voxel_indices = voxel_indices[mask_proj][mask_inlier]\n        w = weight[valid_voxel_indices]\n        wp = w + 1\n        tsdf[valid_voxel_indices] = (tsdf[valid_voxel_indices] * w + sdf[mask_inlier].reshape(w.shape)) / wp\n        if config.integrate_color:\n            color = o3d.t.io.read_image(color_file_names[i]).to(device)\n            color_readings = color.as_tensor()[v_proj, u_proj].to(o3c.float32)\n            color = vbg.attribute('color').reshape((-1, 3))\n            color[valid_voxel_indices] = (color[valid_voxel_indices] * w + color_readings[mask_inlier]) / wp\n        weight[valid_voxel_indices] = wp\n        o3d.core.cuda.synchronize()\n        end = time.time()\n    print(f'Saving to {config.path_npz}...')\n    vbg.save(config.path_npz)\n    print('Saving finished')\n    return vbg",
        "mutated": [
            "def integrate(depth_file_names, color_file_names, intrinsic, extrinsics, config):\n    if False:\n        i = 10\n    if os.path.exists(config.path_npz):\n        print(f'Voxel block grid npz file {config.path_npz} found, trying to load...')\n        vbg = o3d.t.geometry.VoxelBlockGrid.load(config.path_npz)\n        print('Loading finished.')\n        return vbg\n    print(f'Voxel block grid npz file {config.path_npz} not found, trying to integrate...')\n    n_files = len(depth_file_names)\n    device = o3d.core.Device(config.device)\n    voxel_size = 3.0 / 512\n    trunc = voxel_size * 4\n    res = 8\n    if config.integrate_color:\n        vbg = o3d.t.geometry.VoxelBlockGrid(('tsdf', 'weight', 'color'), (o3c.float32, o3c.float32, o3c.float32), (1, 1, 3), 3.0 / 512, 8, 100000, device)\n    else:\n        vbg = o3d.t.geometry.VoxelBlockGrid(('tsdf', 'weight'), (o3c.float32, o3c.float32), (1, 1), 3.0 / 512, 8, 100000, device)\n    start = time.time()\n    for i in tqdm(range(n_files)):\n        depth = o3d.t.io.read_image(depth_file_names[i]).to(device)\n        extrinsic = extrinsics[i]\n        start = time.time()\n        frustum_block_coords = vbg.compute_unique_block_coordinates(depth, intrinsic, extrinsic, config.depth_scale, config.depth_max)\n        vbg.hashmap().activate(frustum_block_coords)\n        (buf_indices, masks) = vbg.hashmap().find(frustum_block_coords)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        (voxel_coords, voxel_indices) = vbg.voxel_coordinates_and_flattened_indices(buf_indices)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        extrinsic_dev = extrinsic.to(device, o3c.float32)\n        xyz = extrinsic_dev[:3, :3] @ voxel_coords.T() + extrinsic_dev[:3, 3:]\n        intrinsic_dev = intrinsic.to(device, o3c.float32)\n        uvd = intrinsic_dev @ xyz\n        d = uvd[2]\n        u = (uvd[0] / d).round().to(o3c.int64)\n        v = (uvd[1] / d).round().to(o3c.int64)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        mask_proj = (d > 0) & (u >= 0) & (v >= 0) & (u < depth.columns) & (v < depth.rows)\n        v_proj = v[mask_proj]\n        u_proj = u[mask_proj]\n        d_proj = d[mask_proj]\n        depth_readings = depth.as_tensor()[v_proj, u_proj, 0].to(o3c.float32) / config.depth_scale\n        sdf = depth_readings - d_proj\n        mask_inlier = (depth_readings > 0) & (depth_readings < config.depth_max) & (sdf >= -trunc)\n        sdf[sdf >= trunc] = trunc\n        sdf = sdf / trunc\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        weight = vbg.attribute('weight').reshape((-1, 1))\n        tsdf = vbg.attribute('tsdf').reshape((-1, 1))\n        valid_voxel_indices = voxel_indices[mask_proj][mask_inlier]\n        w = weight[valid_voxel_indices]\n        wp = w + 1\n        tsdf[valid_voxel_indices] = (tsdf[valid_voxel_indices] * w + sdf[mask_inlier].reshape(w.shape)) / wp\n        if config.integrate_color:\n            color = o3d.t.io.read_image(color_file_names[i]).to(device)\n            color_readings = color.as_tensor()[v_proj, u_proj].to(o3c.float32)\n            color = vbg.attribute('color').reshape((-1, 3))\n            color[valid_voxel_indices] = (color[valid_voxel_indices] * w + color_readings[mask_inlier]) / wp\n        weight[valid_voxel_indices] = wp\n        o3d.core.cuda.synchronize()\n        end = time.time()\n    print(f'Saving to {config.path_npz}...')\n    vbg.save(config.path_npz)\n    print('Saving finished')\n    return vbg",
            "def integrate(depth_file_names, color_file_names, intrinsic, extrinsics, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if os.path.exists(config.path_npz):\n        print(f'Voxel block grid npz file {config.path_npz} found, trying to load...')\n        vbg = o3d.t.geometry.VoxelBlockGrid.load(config.path_npz)\n        print('Loading finished.')\n        return vbg\n    print(f'Voxel block grid npz file {config.path_npz} not found, trying to integrate...')\n    n_files = len(depth_file_names)\n    device = o3d.core.Device(config.device)\n    voxel_size = 3.0 / 512\n    trunc = voxel_size * 4\n    res = 8\n    if config.integrate_color:\n        vbg = o3d.t.geometry.VoxelBlockGrid(('tsdf', 'weight', 'color'), (o3c.float32, o3c.float32, o3c.float32), (1, 1, 3), 3.0 / 512, 8, 100000, device)\n    else:\n        vbg = o3d.t.geometry.VoxelBlockGrid(('tsdf', 'weight'), (o3c.float32, o3c.float32), (1, 1), 3.0 / 512, 8, 100000, device)\n    start = time.time()\n    for i in tqdm(range(n_files)):\n        depth = o3d.t.io.read_image(depth_file_names[i]).to(device)\n        extrinsic = extrinsics[i]\n        start = time.time()\n        frustum_block_coords = vbg.compute_unique_block_coordinates(depth, intrinsic, extrinsic, config.depth_scale, config.depth_max)\n        vbg.hashmap().activate(frustum_block_coords)\n        (buf_indices, masks) = vbg.hashmap().find(frustum_block_coords)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        (voxel_coords, voxel_indices) = vbg.voxel_coordinates_and_flattened_indices(buf_indices)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        extrinsic_dev = extrinsic.to(device, o3c.float32)\n        xyz = extrinsic_dev[:3, :3] @ voxel_coords.T() + extrinsic_dev[:3, 3:]\n        intrinsic_dev = intrinsic.to(device, o3c.float32)\n        uvd = intrinsic_dev @ xyz\n        d = uvd[2]\n        u = (uvd[0] / d).round().to(o3c.int64)\n        v = (uvd[1] / d).round().to(o3c.int64)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        mask_proj = (d > 0) & (u >= 0) & (v >= 0) & (u < depth.columns) & (v < depth.rows)\n        v_proj = v[mask_proj]\n        u_proj = u[mask_proj]\n        d_proj = d[mask_proj]\n        depth_readings = depth.as_tensor()[v_proj, u_proj, 0].to(o3c.float32) / config.depth_scale\n        sdf = depth_readings - d_proj\n        mask_inlier = (depth_readings > 0) & (depth_readings < config.depth_max) & (sdf >= -trunc)\n        sdf[sdf >= trunc] = trunc\n        sdf = sdf / trunc\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        weight = vbg.attribute('weight').reshape((-1, 1))\n        tsdf = vbg.attribute('tsdf').reshape((-1, 1))\n        valid_voxel_indices = voxel_indices[mask_proj][mask_inlier]\n        w = weight[valid_voxel_indices]\n        wp = w + 1\n        tsdf[valid_voxel_indices] = (tsdf[valid_voxel_indices] * w + sdf[mask_inlier].reshape(w.shape)) / wp\n        if config.integrate_color:\n            color = o3d.t.io.read_image(color_file_names[i]).to(device)\n            color_readings = color.as_tensor()[v_proj, u_proj].to(o3c.float32)\n            color = vbg.attribute('color').reshape((-1, 3))\n            color[valid_voxel_indices] = (color[valid_voxel_indices] * w + color_readings[mask_inlier]) / wp\n        weight[valid_voxel_indices] = wp\n        o3d.core.cuda.synchronize()\n        end = time.time()\n    print(f'Saving to {config.path_npz}...')\n    vbg.save(config.path_npz)\n    print('Saving finished')\n    return vbg",
            "def integrate(depth_file_names, color_file_names, intrinsic, extrinsics, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if os.path.exists(config.path_npz):\n        print(f'Voxel block grid npz file {config.path_npz} found, trying to load...')\n        vbg = o3d.t.geometry.VoxelBlockGrid.load(config.path_npz)\n        print('Loading finished.')\n        return vbg\n    print(f'Voxel block grid npz file {config.path_npz} not found, trying to integrate...')\n    n_files = len(depth_file_names)\n    device = o3d.core.Device(config.device)\n    voxel_size = 3.0 / 512\n    trunc = voxel_size * 4\n    res = 8\n    if config.integrate_color:\n        vbg = o3d.t.geometry.VoxelBlockGrid(('tsdf', 'weight', 'color'), (o3c.float32, o3c.float32, o3c.float32), (1, 1, 3), 3.0 / 512, 8, 100000, device)\n    else:\n        vbg = o3d.t.geometry.VoxelBlockGrid(('tsdf', 'weight'), (o3c.float32, o3c.float32), (1, 1), 3.0 / 512, 8, 100000, device)\n    start = time.time()\n    for i in tqdm(range(n_files)):\n        depth = o3d.t.io.read_image(depth_file_names[i]).to(device)\n        extrinsic = extrinsics[i]\n        start = time.time()\n        frustum_block_coords = vbg.compute_unique_block_coordinates(depth, intrinsic, extrinsic, config.depth_scale, config.depth_max)\n        vbg.hashmap().activate(frustum_block_coords)\n        (buf_indices, masks) = vbg.hashmap().find(frustum_block_coords)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        (voxel_coords, voxel_indices) = vbg.voxel_coordinates_and_flattened_indices(buf_indices)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        extrinsic_dev = extrinsic.to(device, o3c.float32)\n        xyz = extrinsic_dev[:3, :3] @ voxel_coords.T() + extrinsic_dev[:3, 3:]\n        intrinsic_dev = intrinsic.to(device, o3c.float32)\n        uvd = intrinsic_dev @ xyz\n        d = uvd[2]\n        u = (uvd[0] / d).round().to(o3c.int64)\n        v = (uvd[1] / d).round().to(o3c.int64)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        mask_proj = (d > 0) & (u >= 0) & (v >= 0) & (u < depth.columns) & (v < depth.rows)\n        v_proj = v[mask_proj]\n        u_proj = u[mask_proj]\n        d_proj = d[mask_proj]\n        depth_readings = depth.as_tensor()[v_proj, u_proj, 0].to(o3c.float32) / config.depth_scale\n        sdf = depth_readings - d_proj\n        mask_inlier = (depth_readings > 0) & (depth_readings < config.depth_max) & (sdf >= -trunc)\n        sdf[sdf >= trunc] = trunc\n        sdf = sdf / trunc\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        weight = vbg.attribute('weight').reshape((-1, 1))\n        tsdf = vbg.attribute('tsdf').reshape((-1, 1))\n        valid_voxel_indices = voxel_indices[mask_proj][mask_inlier]\n        w = weight[valid_voxel_indices]\n        wp = w + 1\n        tsdf[valid_voxel_indices] = (tsdf[valid_voxel_indices] * w + sdf[mask_inlier].reshape(w.shape)) / wp\n        if config.integrate_color:\n            color = o3d.t.io.read_image(color_file_names[i]).to(device)\n            color_readings = color.as_tensor()[v_proj, u_proj].to(o3c.float32)\n            color = vbg.attribute('color').reshape((-1, 3))\n            color[valid_voxel_indices] = (color[valid_voxel_indices] * w + color_readings[mask_inlier]) / wp\n        weight[valid_voxel_indices] = wp\n        o3d.core.cuda.synchronize()\n        end = time.time()\n    print(f'Saving to {config.path_npz}...')\n    vbg.save(config.path_npz)\n    print('Saving finished')\n    return vbg",
            "def integrate(depth_file_names, color_file_names, intrinsic, extrinsics, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if os.path.exists(config.path_npz):\n        print(f'Voxel block grid npz file {config.path_npz} found, trying to load...')\n        vbg = o3d.t.geometry.VoxelBlockGrid.load(config.path_npz)\n        print('Loading finished.')\n        return vbg\n    print(f'Voxel block grid npz file {config.path_npz} not found, trying to integrate...')\n    n_files = len(depth_file_names)\n    device = o3d.core.Device(config.device)\n    voxel_size = 3.0 / 512\n    trunc = voxel_size * 4\n    res = 8\n    if config.integrate_color:\n        vbg = o3d.t.geometry.VoxelBlockGrid(('tsdf', 'weight', 'color'), (o3c.float32, o3c.float32, o3c.float32), (1, 1, 3), 3.0 / 512, 8, 100000, device)\n    else:\n        vbg = o3d.t.geometry.VoxelBlockGrid(('tsdf', 'weight'), (o3c.float32, o3c.float32), (1, 1), 3.0 / 512, 8, 100000, device)\n    start = time.time()\n    for i in tqdm(range(n_files)):\n        depth = o3d.t.io.read_image(depth_file_names[i]).to(device)\n        extrinsic = extrinsics[i]\n        start = time.time()\n        frustum_block_coords = vbg.compute_unique_block_coordinates(depth, intrinsic, extrinsic, config.depth_scale, config.depth_max)\n        vbg.hashmap().activate(frustum_block_coords)\n        (buf_indices, masks) = vbg.hashmap().find(frustum_block_coords)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        (voxel_coords, voxel_indices) = vbg.voxel_coordinates_and_flattened_indices(buf_indices)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        extrinsic_dev = extrinsic.to(device, o3c.float32)\n        xyz = extrinsic_dev[:3, :3] @ voxel_coords.T() + extrinsic_dev[:3, 3:]\n        intrinsic_dev = intrinsic.to(device, o3c.float32)\n        uvd = intrinsic_dev @ xyz\n        d = uvd[2]\n        u = (uvd[0] / d).round().to(o3c.int64)\n        v = (uvd[1] / d).round().to(o3c.int64)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        mask_proj = (d > 0) & (u >= 0) & (v >= 0) & (u < depth.columns) & (v < depth.rows)\n        v_proj = v[mask_proj]\n        u_proj = u[mask_proj]\n        d_proj = d[mask_proj]\n        depth_readings = depth.as_tensor()[v_proj, u_proj, 0].to(o3c.float32) / config.depth_scale\n        sdf = depth_readings - d_proj\n        mask_inlier = (depth_readings > 0) & (depth_readings < config.depth_max) & (sdf >= -trunc)\n        sdf[sdf >= trunc] = trunc\n        sdf = sdf / trunc\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        weight = vbg.attribute('weight').reshape((-1, 1))\n        tsdf = vbg.attribute('tsdf').reshape((-1, 1))\n        valid_voxel_indices = voxel_indices[mask_proj][mask_inlier]\n        w = weight[valid_voxel_indices]\n        wp = w + 1\n        tsdf[valid_voxel_indices] = (tsdf[valid_voxel_indices] * w + sdf[mask_inlier].reshape(w.shape)) / wp\n        if config.integrate_color:\n            color = o3d.t.io.read_image(color_file_names[i]).to(device)\n            color_readings = color.as_tensor()[v_proj, u_proj].to(o3c.float32)\n            color = vbg.attribute('color').reshape((-1, 3))\n            color[valid_voxel_indices] = (color[valid_voxel_indices] * w + color_readings[mask_inlier]) / wp\n        weight[valid_voxel_indices] = wp\n        o3d.core.cuda.synchronize()\n        end = time.time()\n    print(f'Saving to {config.path_npz}...')\n    vbg.save(config.path_npz)\n    print('Saving finished')\n    return vbg",
            "def integrate(depth_file_names, color_file_names, intrinsic, extrinsics, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if os.path.exists(config.path_npz):\n        print(f'Voxel block grid npz file {config.path_npz} found, trying to load...')\n        vbg = o3d.t.geometry.VoxelBlockGrid.load(config.path_npz)\n        print('Loading finished.')\n        return vbg\n    print(f'Voxel block grid npz file {config.path_npz} not found, trying to integrate...')\n    n_files = len(depth_file_names)\n    device = o3d.core.Device(config.device)\n    voxel_size = 3.0 / 512\n    trunc = voxel_size * 4\n    res = 8\n    if config.integrate_color:\n        vbg = o3d.t.geometry.VoxelBlockGrid(('tsdf', 'weight', 'color'), (o3c.float32, o3c.float32, o3c.float32), (1, 1, 3), 3.0 / 512, 8, 100000, device)\n    else:\n        vbg = o3d.t.geometry.VoxelBlockGrid(('tsdf', 'weight'), (o3c.float32, o3c.float32), (1, 1), 3.0 / 512, 8, 100000, device)\n    start = time.time()\n    for i in tqdm(range(n_files)):\n        depth = o3d.t.io.read_image(depth_file_names[i]).to(device)\n        extrinsic = extrinsics[i]\n        start = time.time()\n        frustum_block_coords = vbg.compute_unique_block_coordinates(depth, intrinsic, extrinsic, config.depth_scale, config.depth_max)\n        vbg.hashmap().activate(frustum_block_coords)\n        (buf_indices, masks) = vbg.hashmap().find(frustum_block_coords)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        (voxel_coords, voxel_indices) = vbg.voxel_coordinates_and_flattened_indices(buf_indices)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        extrinsic_dev = extrinsic.to(device, o3c.float32)\n        xyz = extrinsic_dev[:3, :3] @ voxel_coords.T() + extrinsic_dev[:3, 3:]\n        intrinsic_dev = intrinsic.to(device, o3c.float32)\n        uvd = intrinsic_dev @ xyz\n        d = uvd[2]\n        u = (uvd[0] / d).round().to(o3c.int64)\n        v = (uvd[1] / d).round().to(o3c.int64)\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        mask_proj = (d > 0) & (u >= 0) & (v >= 0) & (u < depth.columns) & (v < depth.rows)\n        v_proj = v[mask_proj]\n        u_proj = u[mask_proj]\n        d_proj = d[mask_proj]\n        depth_readings = depth.as_tensor()[v_proj, u_proj, 0].to(o3c.float32) / config.depth_scale\n        sdf = depth_readings - d_proj\n        mask_inlier = (depth_readings > 0) & (depth_readings < config.depth_max) & (sdf >= -trunc)\n        sdf[sdf >= trunc] = trunc\n        sdf = sdf / trunc\n        o3d.core.cuda.synchronize()\n        end = time.time()\n        start = time.time()\n        weight = vbg.attribute('weight').reshape((-1, 1))\n        tsdf = vbg.attribute('tsdf').reshape((-1, 1))\n        valid_voxel_indices = voxel_indices[mask_proj][mask_inlier]\n        w = weight[valid_voxel_indices]\n        wp = w + 1\n        tsdf[valid_voxel_indices] = (tsdf[valid_voxel_indices] * w + sdf[mask_inlier].reshape(w.shape)) / wp\n        if config.integrate_color:\n            color = o3d.t.io.read_image(color_file_names[i]).to(device)\n            color_readings = color.as_tensor()[v_proj, u_proj].to(o3c.float32)\n            color = vbg.attribute('color').reshape((-1, 3))\n            color[valid_voxel_indices] = (color[valid_voxel_indices] * w + color_readings[mask_inlier]) / wp\n        weight[valid_voxel_indices] = wp\n        o3d.core.cuda.synchronize()\n        end = time.time()\n    print(f'Saving to {config.path_npz}...')\n    vbg.save(config.path_npz)\n    print('Saving finished')\n    return vbg"
        ]
    }
]