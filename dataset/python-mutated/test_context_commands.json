[
    {
        "func_name": "test_context_disasm_show_fd_filepath",
        "original": "def test_context_disasm_show_fd_filepath(start_binary):\n    \"\"\"\n    Tests context disasm command and whether it shows properly opened fd filepath\n    \"\"\"\n    start_binary(USE_FDS_BINARY)\n    gdb.execute('break main')\n    gdb.execute('continue')\n    gdb.execute('nextcall')\n    out = pwndbg.commands.context.context_disasm()\n    assert '[ DISASM / x86-64 / set emulate on ]' in out[0]\n    call_read_line_idx = out.index(next((line for line in out if '<read@plt>' in line)))\n    lines_after_call_read = out[call_read_line_idx:]\n    (line_call_read, line_fd, line_buf, line_nbytes, *_rest) = lines_after_call_read\n    assert 'call   read@plt' in line_call_read\n    line_fd = line_fd.strip()\n    assert re.match('fd:\\\\s+0x1 \\\\((/dev/pts/\\\\d+|/tmp/par.+\\\\.par(?: \\\\(deleted\\\\))?|pipe:\\\\[\\\\d+\\\\])\\\\)', line_fd)\n    line_buf = line_buf.strip()\n    assert re.match('buf:\\\\s+0x[0-9a-f]+ \u25c2\u2014 0x0', line_buf)\n    line_nbytes = line_nbytes.strip()\n    assert re.match('nbytes:\\\\s+0x0', line_nbytes)\n    gdb.execute('nextcall')\n    gdb.execute('nextcall')\n    out = pwndbg.commands.context.context_disasm()\n    assert '[ DISASM / x86-64 / set emulate on ]' in out[0]\n    call_read_line_idx = out.index(next((line for line in out if '<read@plt>' in line)))\n    lines_after_call_read = out[call_read_line_idx:]\n    (line_call_read, line_fd, line_buf, line_nbytes, *_rest) = lines_after_call_read\n    line_fd = line_fd.strip()\n    assert re.match('fd:\\\\s+0x3 \\\\([a-z/]*pwndbg/tests/gdb-tests/tests/binaries/use-fds.out\\\\)', line_fd)\n    line_buf = line_buf.strip()\n    assert re.match('buf:\\\\s+0x[0-9a-f]+ \u25c2\u2014 0x0', line_buf)\n    line_nbytes = line_nbytes.strip()\n    assert re.match('nbytes:\\\\s+0x10', line_nbytes)",
        "mutated": [
            "def test_context_disasm_show_fd_filepath(start_binary):\n    if False:\n        i = 10\n    '\\n    Tests context disasm command and whether it shows properly opened fd filepath\\n    '\n    start_binary(USE_FDS_BINARY)\n    gdb.execute('break main')\n    gdb.execute('continue')\n    gdb.execute('nextcall')\n    out = pwndbg.commands.context.context_disasm()\n    assert '[ DISASM / x86-64 / set emulate on ]' in out[0]\n    call_read_line_idx = out.index(next((line for line in out if '<read@plt>' in line)))\n    lines_after_call_read = out[call_read_line_idx:]\n    (line_call_read, line_fd, line_buf, line_nbytes, *_rest) = lines_after_call_read\n    assert 'call   read@plt' in line_call_read\n    line_fd = line_fd.strip()\n    assert re.match('fd:\\\\s+0x1 \\\\((/dev/pts/\\\\d+|/tmp/par.+\\\\.par(?: \\\\(deleted\\\\))?|pipe:\\\\[\\\\d+\\\\])\\\\)', line_fd)\n    line_buf = line_buf.strip()\n    assert re.match('buf:\\\\s+0x[0-9a-f]+ \u25c2\u2014 0x0', line_buf)\n    line_nbytes = line_nbytes.strip()\n    assert re.match('nbytes:\\\\s+0x0', line_nbytes)\n    gdb.execute('nextcall')\n    gdb.execute('nextcall')\n    out = pwndbg.commands.context.context_disasm()\n    assert '[ DISASM / x86-64 / set emulate on ]' in out[0]\n    call_read_line_idx = out.index(next((line for line in out if '<read@plt>' in line)))\n    lines_after_call_read = out[call_read_line_idx:]\n    (line_call_read, line_fd, line_buf, line_nbytes, *_rest) = lines_after_call_read\n    line_fd = line_fd.strip()\n    assert re.match('fd:\\\\s+0x3 \\\\([a-z/]*pwndbg/tests/gdb-tests/tests/binaries/use-fds.out\\\\)', line_fd)\n    line_buf = line_buf.strip()\n    assert re.match('buf:\\\\s+0x[0-9a-f]+ \u25c2\u2014 0x0', line_buf)\n    line_nbytes = line_nbytes.strip()\n    assert re.match('nbytes:\\\\s+0x10', line_nbytes)",
            "def test_context_disasm_show_fd_filepath(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Tests context disasm command and whether it shows properly opened fd filepath\\n    '\n    start_binary(USE_FDS_BINARY)\n    gdb.execute('break main')\n    gdb.execute('continue')\n    gdb.execute('nextcall')\n    out = pwndbg.commands.context.context_disasm()\n    assert '[ DISASM / x86-64 / set emulate on ]' in out[0]\n    call_read_line_idx = out.index(next((line for line in out if '<read@plt>' in line)))\n    lines_after_call_read = out[call_read_line_idx:]\n    (line_call_read, line_fd, line_buf, line_nbytes, *_rest) = lines_after_call_read\n    assert 'call   read@plt' in line_call_read\n    line_fd = line_fd.strip()\n    assert re.match('fd:\\\\s+0x1 \\\\((/dev/pts/\\\\d+|/tmp/par.+\\\\.par(?: \\\\(deleted\\\\))?|pipe:\\\\[\\\\d+\\\\])\\\\)', line_fd)\n    line_buf = line_buf.strip()\n    assert re.match('buf:\\\\s+0x[0-9a-f]+ \u25c2\u2014 0x0', line_buf)\n    line_nbytes = line_nbytes.strip()\n    assert re.match('nbytes:\\\\s+0x0', line_nbytes)\n    gdb.execute('nextcall')\n    gdb.execute('nextcall')\n    out = pwndbg.commands.context.context_disasm()\n    assert '[ DISASM / x86-64 / set emulate on ]' in out[0]\n    call_read_line_idx = out.index(next((line for line in out if '<read@plt>' in line)))\n    lines_after_call_read = out[call_read_line_idx:]\n    (line_call_read, line_fd, line_buf, line_nbytes, *_rest) = lines_after_call_read\n    line_fd = line_fd.strip()\n    assert re.match('fd:\\\\s+0x3 \\\\([a-z/]*pwndbg/tests/gdb-tests/tests/binaries/use-fds.out\\\\)', line_fd)\n    line_buf = line_buf.strip()\n    assert re.match('buf:\\\\s+0x[0-9a-f]+ \u25c2\u2014 0x0', line_buf)\n    line_nbytes = line_nbytes.strip()\n    assert re.match('nbytes:\\\\s+0x10', line_nbytes)",
            "def test_context_disasm_show_fd_filepath(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Tests context disasm command and whether it shows properly opened fd filepath\\n    '\n    start_binary(USE_FDS_BINARY)\n    gdb.execute('break main')\n    gdb.execute('continue')\n    gdb.execute('nextcall')\n    out = pwndbg.commands.context.context_disasm()\n    assert '[ DISASM / x86-64 / set emulate on ]' in out[0]\n    call_read_line_idx = out.index(next((line for line in out if '<read@plt>' in line)))\n    lines_after_call_read = out[call_read_line_idx:]\n    (line_call_read, line_fd, line_buf, line_nbytes, *_rest) = lines_after_call_read\n    assert 'call   read@plt' in line_call_read\n    line_fd = line_fd.strip()\n    assert re.match('fd:\\\\s+0x1 \\\\((/dev/pts/\\\\d+|/tmp/par.+\\\\.par(?: \\\\(deleted\\\\))?|pipe:\\\\[\\\\d+\\\\])\\\\)', line_fd)\n    line_buf = line_buf.strip()\n    assert re.match('buf:\\\\s+0x[0-9a-f]+ \u25c2\u2014 0x0', line_buf)\n    line_nbytes = line_nbytes.strip()\n    assert re.match('nbytes:\\\\s+0x0', line_nbytes)\n    gdb.execute('nextcall')\n    gdb.execute('nextcall')\n    out = pwndbg.commands.context.context_disasm()\n    assert '[ DISASM / x86-64 / set emulate on ]' in out[0]\n    call_read_line_idx = out.index(next((line for line in out if '<read@plt>' in line)))\n    lines_after_call_read = out[call_read_line_idx:]\n    (line_call_read, line_fd, line_buf, line_nbytes, *_rest) = lines_after_call_read\n    line_fd = line_fd.strip()\n    assert re.match('fd:\\\\s+0x3 \\\\([a-z/]*pwndbg/tests/gdb-tests/tests/binaries/use-fds.out\\\\)', line_fd)\n    line_buf = line_buf.strip()\n    assert re.match('buf:\\\\s+0x[0-9a-f]+ \u25c2\u2014 0x0', line_buf)\n    line_nbytes = line_nbytes.strip()\n    assert re.match('nbytes:\\\\s+0x10', line_nbytes)",
            "def test_context_disasm_show_fd_filepath(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Tests context disasm command and whether it shows properly opened fd filepath\\n    '\n    start_binary(USE_FDS_BINARY)\n    gdb.execute('break main')\n    gdb.execute('continue')\n    gdb.execute('nextcall')\n    out = pwndbg.commands.context.context_disasm()\n    assert '[ DISASM / x86-64 / set emulate on ]' in out[0]\n    call_read_line_idx = out.index(next((line for line in out if '<read@plt>' in line)))\n    lines_after_call_read = out[call_read_line_idx:]\n    (line_call_read, line_fd, line_buf, line_nbytes, *_rest) = lines_after_call_read\n    assert 'call   read@plt' in line_call_read\n    line_fd = line_fd.strip()\n    assert re.match('fd:\\\\s+0x1 \\\\((/dev/pts/\\\\d+|/tmp/par.+\\\\.par(?: \\\\(deleted\\\\))?|pipe:\\\\[\\\\d+\\\\])\\\\)', line_fd)\n    line_buf = line_buf.strip()\n    assert re.match('buf:\\\\s+0x[0-9a-f]+ \u25c2\u2014 0x0', line_buf)\n    line_nbytes = line_nbytes.strip()\n    assert re.match('nbytes:\\\\s+0x0', line_nbytes)\n    gdb.execute('nextcall')\n    gdb.execute('nextcall')\n    out = pwndbg.commands.context.context_disasm()\n    assert '[ DISASM / x86-64 / set emulate on ]' in out[0]\n    call_read_line_idx = out.index(next((line for line in out if '<read@plt>' in line)))\n    lines_after_call_read = out[call_read_line_idx:]\n    (line_call_read, line_fd, line_buf, line_nbytes, *_rest) = lines_after_call_read\n    line_fd = line_fd.strip()\n    assert re.match('fd:\\\\s+0x3 \\\\([a-z/]*pwndbg/tests/gdb-tests/tests/binaries/use-fds.out\\\\)', line_fd)\n    line_buf = line_buf.strip()\n    assert re.match('buf:\\\\s+0x[0-9a-f]+ \u25c2\u2014 0x0', line_buf)\n    line_nbytes = line_nbytes.strip()\n    assert re.match('nbytes:\\\\s+0x10', line_nbytes)",
            "def test_context_disasm_show_fd_filepath(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Tests context disasm command and whether it shows properly opened fd filepath\\n    '\n    start_binary(USE_FDS_BINARY)\n    gdb.execute('break main')\n    gdb.execute('continue')\n    gdb.execute('nextcall')\n    out = pwndbg.commands.context.context_disasm()\n    assert '[ DISASM / x86-64 / set emulate on ]' in out[0]\n    call_read_line_idx = out.index(next((line for line in out if '<read@plt>' in line)))\n    lines_after_call_read = out[call_read_line_idx:]\n    (line_call_read, line_fd, line_buf, line_nbytes, *_rest) = lines_after_call_read\n    assert 'call   read@plt' in line_call_read\n    line_fd = line_fd.strip()\n    assert re.match('fd:\\\\s+0x1 \\\\((/dev/pts/\\\\d+|/tmp/par.+\\\\.par(?: \\\\(deleted\\\\))?|pipe:\\\\[\\\\d+\\\\])\\\\)', line_fd)\n    line_buf = line_buf.strip()\n    assert re.match('buf:\\\\s+0x[0-9a-f]+ \u25c2\u2014 0x0', line_buf)\n    line_nbytes = line_nbytes.strip()\n    assert re.match('nbytes:\\\\s+0x0', line_nbytes)\n    gdb.execute('nextcall')\n    gdb.execute('nextcall')\n    out = pwndbg.commands.context.context_disasm()\n    assert '[ DISASM / x86-64 / set emulate on ]' in out[0]\n    call_read_line_idx = out.index(next((line for line in out if '<read@plt>' in line)))\n    lines_after_call_read = out[call_read_line_idx:]\n    (line_call_read, line_fd, line_buf, line_nbytes, *_rest) = lines_after_call_read\n    line_fd = line_fd.strip()\n    assert re.match('fd:\\\\s+0x3 \\\\([a-z/]*pwndbg/tests/gdb-tests/tests/binaries/use-fds.out\\\\)', line_fd)\n    line_buf = line_buf.strip()\n    assert re.match('buf:\\\\s+0x[0-9a-f]+ \u25c2\u2014 0x0', line_buf)\n    line_nbytes = line_nbytes.strip()\n    assert re.match('nbytes:\\\\s+0x10', line_nbytes)"
        ]
    },
    {
        "func_name": "test_empty_context_sections",
        "original": "@pytest.mark.parametrize('sections', (\"''\", '\"\"', 'none', '-', ''))\ndef test_empty_context_sections(start_binary, sections):\n    start_binary(USE_FDS_BINARY)\n    default_ctx_sects = 'regs disasm code ghidra stack backtrace expressions threads'\n    assert pwndbg.gdblib.config.context_sections.value == default_ctx_sects\n    assert gdb.execute('context', to_string=True) != ''\n    gdb.execute(f'set context-sections {sections}', to_string=True)\n    assert pwndbg.gdblib.config.context_sections.value == ''\n    assert gdb.execute('context', to_string=True) == ''\n    gdb.execute(f'set context-sections {default_ctx_sects}')\n    assert pwndbg.gdblib.config.context_sections.value == default_ctx_sects\n    assert gdb.execute('context', to_string=True) != ''",
        "mutated": [
            "@pytest.mark.parametrize('sections', (\"''\", '\"\"', 'none', '-', ''))\ndef test_empty_context_sections(start_binary, sections):\n    if False:\n        i = 10\n    start_binary(USE_FDS_BINARY)\n    default_ctx_sects = 'regs disasm code ghidra stack backtrace expressions threads'\n    assert pwndbg.gdblib.config.context_sections.value == default_ctx_sects\n    assert gdb.execute('context', to_string=True) != ''\n    gdb.execute(f'set context-sections {sections}', to_string=True)\n    assert pwndbg.gdblib.config.context_sections.value == ''\n    assert gdb.execute('context', to_string=True) == ''\n    gdb.execute(f'set context-sections {default_ctx_sects}')\n    assert pwndbg.gdblib.config.context_sections.value == default_ctx_sects\n    assert gdb.execute('context', to_string=True) != ''",
            "@pytest.mark.parametrize('sections', (\"''\", '\"\"', 'none', '-', ''))\ndef test_empty_context_sections(start_binary, sections):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    start_binary(USE_FDS_BINARY)\n    default_ctx_sects = 'regs disasm code ghidra stack backtrace expressions threads'\n    assert pwndbg.gdblib.config.context_sections.value == default_ctx_sects\n    assert gdb.execute('context', to_string=True) != ''\n    gdb.execute(f'set context-sections {sections}', to_string=True)\n    assert pwndbg.gdblib.config.context_sections.value == ''\n    assert gdb.execute('context', to_string=True) == ''\n    gdb.execute(f'set context-sections {default_ctx_sects}')\n    assert pwndbg.gdblib.config.context_sections.value == default_ctx_sects\n    assert gdb.execute('context', to_string=True) != ''",
            "@pytest.mark.parametrize('sections', (\"''\", '\"\"', 'none', '-', ''))\ndef test_empty_context_sections(start_binary, sections):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    start_binary(USE_FDS_BINARY)\n    default_ctx_sects = 'regs disasm code ghidra stack backtrace expressions threads'\n    assert pwndbg.gdblib.config.context_sections.value == default_ctx_sects\n    assert gdb.execute('context', to_string=True) != ''\n    gdb.execute(f'set context-sections {sections}', to_string=True)\n    assert pwndbg.gdblib.config.context_sections.value == ''\n    assert gdb.execute('context', to_string=True) == ''\n    gdb.execute(f'set context-sections {default_ctx_sects}')\n    assert pwndbg.gdblib.config.context_sections.value == default_ctx_sects\n    assert gdb.execute('context', to_string=True) != ''",
            "@pytest.mark.parametrize('sections', (\"''\", '\"\"', 'none', '-', ''))\ndef test_empty_context_sections(start_binary, sections):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    start_binary(USE_FDS_BINARY)\n    default_ctx_sects = 'regs disasm code ghidra stack backtrace expressions threads'\n    assert pwndbg.gdblib.config.context_sections.value == default_ctx_sects\n    assert gdb.execute('context', to_string=True) != ''\n    gdb.execute(f'set context-sections {sections}', to_string=True)\n    assert pwndbg.gdblib.config.context_sections.value == ''\n    assert gdb.execute('context', to_string=True) == ''\n    gdb.execute(f'set context-sections {default_ctx_sects}')\n    assert pwndbg.gdblib.config.context_sections.value == default_ctx_sects\n    assert gdb.execute('context', to_string=True) != ''",
            "@pytest.mark.parametrize('sections', (\"''\", '\"\"', 'none', '-', ''))\ndef test_empty_context_sections(start_binary, sections):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    start_binary(USE_FDS_BINARY)\n    default_ctx_sects = 'regs disasm code ghidra stack backtrace expressions threads'\n    assert pwndbg.gdblib.config.context_sections.value == default_ctx_sects\n    assert gdb.execute('context', to_string=True) != ''\n    gdb.execute(f'set context-sections {sections}', to_string=True)\n    assert pwndbg.gdblib.config.context_sections.value == ''\n    assert gdb.execute('context', to_string=True) == ''\n    gdb.execute(f'set context-sections {default_ctx_sects}')\n    assert pwndbg.gdblib.config.context_sections.value == default_ctx_sects\n    assert gdb.execute('context', to_string=True) != ''"
        ]
    },
    {
        "func_name": "test_source_code_tabstop",
        "original": "def test_source_code_tabstop(start_binary):\n    start_binary(TABSTOP_BINARY)\n    gdb.execute('break tabstop.c:6')\n    gdb.execute('continue')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4         // test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6                 puts(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src\n    gdb.execute('set context-source-code-tabstop 2')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4   // test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6     puts(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src\n    gdb.execute('set context-source-code-tabstop 0')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4 \\t// test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6 \\t\\tputs(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src",
        "mutated": [
            "def test_source_code_tabstop(start_binary):\n    if False:\n        i = 10\n    start_binary(TABSTOP_BINARY)\n    gdb.execute('break tabstop.c:6')\n    gdb.execute('continue')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4         // test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6                 puts(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src\n    gdb.execute('set context-source-code-tabstop 2')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4   // test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6     puts(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src\n    gdb.execute('set context-source-code-tabstop 0')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4 \\t// test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6 \\t\\tputs(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src",
            "def test_source_code_tabstop(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    start_binary(TABSTOP_BINARY)\n    gdb.execute('break tabstop.c:6')\n    gdb.execute('continue')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4         // test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6                 puts(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src\n    gdb.execute('set context-source-code-tabstop 2')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4   // test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6     puts(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src\n    gdb.execute('set context-source-code-tabstop 0')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4 \\t// test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6 \\t\\tputs(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src",
            "def test_source_code_tabstop(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    start_binary(TABSTOP_BINARY)\n    gdb.execute('break tabstop.c:6')\n    gdb.execute('continue')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4         // test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6                 puts(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src\n    gdb.execute('set context-source-code-tabstop 2')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4   // test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6     puts(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src\n    gdb.execute('set context-source-code-tabstop 0')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4 \\t// test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6 \\t\\tputs(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src",
            "def test_source_code_tabstop(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    start_binary(TABSTOP_BINARY)\n    gdb.execute('break tabstop.c:6')\n    gdb.execute('continue')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4         // test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6                 puts(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src\n    gdb.execute('set context-source-code-tabstop 2')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4   // test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6     puts(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src\n    gdb.execute('set context-source-code-tabstop 0')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4 \\t// test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6 \\t\\tputs(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src",
            "def test_source_code_tabstop(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    start_binary(TABSTOP_BINARY)\n    gdb.execute('break tabstop.c:6')\n    gdb.execute('continue')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4         // test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6                 puts(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src\n    gdb.execute('set context-source-code-tabstop 2')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4   // test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6     puts(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src\n    gdb.execute('set context-source-code-tabstop 0')\n    src = gdb.execute('context code', to_string=True)\n    assert ' 1 #include <stdio.h>\\n' in src\n    assert ' 2 \\n' in src\n    assert ' 3 int main() {\\n' in src\n    assert ' 4 \\t// test mix indent\\n' in src\n    assert ' 5         do {\\n' in src\n    assert ' 6 \\t\\tputs(\"tab line\");\\n' in src\n    assert ' 7         } while (0);\\n' in src\n    assert ' 8         return 0;\\n' in src\n    assert ' 9 }\\n' in src\n    assert '10 \\n' in src"
        ]
    },
    {
        "func_name": "test_context_disasm_syscalls_args_display",
        "original": "def test_context_disasm_syscalls_args_display(start_binary):\n    start_binary(SYSCALLS_BINARY)\n    gdb.execute('nextsyscall')\n    dis = gdb.execute('context disasm', to_string=True)\n    assert dis == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n   0x400080 <_start>       mov    eax, 0\\n   0x400085 <_start+5>     mov    edi, 0x1337\\n   0x40008a <_start+10>    mov    esi, 0xdeadbeef\\n   0x40008f <_start+15>    mov    ecx, 0x10\\n \u25ba 0x400094 <_start+20>    syscall  <SYS_read>\\n        fd:        0x1337\\n        buf:       0xdeadbeef\\n        nbytes:    0x0\\n   0x400096 <_start+22>    mov    eax, 0xa\\n   0x40009b <_start+27>    int    0x80\\n   0x40009d                add    byte ptr [rax], al\\n   0x40009f                add    byte ptr [rax], al\\n   0x4000a1                add    byte ptr [rax], al\\n   0x4000a3                add    byte ptr [rax], al\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n'\n    gdb.execute('nextsyscall')\n    dis = gdb.execute('context disasm', to_string=True)\n    assert dis == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n   0x400085 <_start+5>     mov    edi, 0x1337\\n   0x40008a <_start+10>    mov    esi, 0xdeadbeef\\n   0x40008f <_start+15>    mov    ecx, 0x10\\n   0x400094 <_start+20>    syscall \\n   0x400096 <_start+22>    mov    eax, 0xa\\n \u25ba 0x40009b <_start+27>    int    0x80 <SYS_unlink>\\n        name:      0x1337\\n   0x40009d                add    byte ptr [rax], al\\n   0x40009f                add    byte ptr [rax], al\\n   0x4000a1                add    byte ptr [rax], al\\n   0x4000a3                add    byte ptr [rax], al\\n   0x4000a5                add    byte ptr [rax], al\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n'",
        "mutated": [
            "def test_context_disasm_syscalls_args_display(start_binary):\n    if False:\n        i = 10\n    start_binary(SYSCALLS_BINARY)\n    gdb.execute('nextsyscall')\n    dis = gdb.execute('context disasm', to_string=True)\n    assert dis == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n   0x400080 <_start>       mov    eax, 0\\n   0x400085 <_start+5>     mov    edi, 0x1337\\n   0x40008a <_start+10>    mov    esi, 0xdeadbeef\\n   0x40008f <_start+15>    mov    ecx, 0x10\\n \u25ba 0x400094 <_start+20>    syscall  <SYS_read>\\n        fd:        0x1337\\n        buf:       0xdeadbeef\\n        nbytes:    0x0\\n   0x400096 <_start+22>    mov    eax, 0xa\\n   0x40009b <_start+27>    int    0x80\\n   0x40009d                add    byte ptr [rax], al\\n   0x40009f                add    byte ptr [rax], al\\n   0x4000a1                add    byte ptr [rax], al\\n   0x4000a3                add    byte ptr [rax], al\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n'\n    gdb.execute('nextsyscall')\n    dis = gdb.execute('context disasm', to_string=True)\n    assert dis == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n   0x400085 <_start+5>     mov    edi, 0x1337\\n   0x40008a <_start+10>    mov    esi, 0xdeadbeef\\n   0x40008f <_start+15>    mov    ecx, 0x10\\n   0x400094 <_start+20>    syscall \\n   0x400096 <_start+22>    mov    eax, 0xa\\n \u25ba 0x40009b <_start+27>    int    0x80 <SYS_unlink>\\n        name:      0x1337\\n   0x40009d                add    byte ptr [rax], al\\n   0x40009f                add    byte ptr [rax], al\\n   0x4000a1                add    byte ptr [rax], al\\n   0x4000a3                add    byte ptr [rax], al\\n   0x4000a5                add    byte ptr [rax], al\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n'",
            "def test_context_disasm_syscalls_args_display(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    start_binary(SYSCALLS_BINARY)\n    gdb.execute('nextsyscall')\n    dis = gdb.execute('context disasm', to_string=True)\n    assert dis == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n   0x400080 <_start>       mov    eax, 0\\n   0x400085 <_start+5>     mov    edi, 0x1337\\n   0x40008a <_start+10>    mov    esi, 0xdeadbeef\\n   0x40008f <_start+15>    mov    ecx, 0x10\\n \u25ba 0x400094 <_start+20>    syscall  <SYS_read>\\n        fd:        0x1337\\n        buf:       0xdeadbeef\\n        nbytes:    0x0\\n   0x400096 <_start+22>    mov    eax, 0xa\\n   0x40009b <_start+27>    int    0x80\\n   0x40009d                add    byte ptr [rax], al\\n   0x40009f                add    byte ptr [rax], al\\n   0x4000a1                add    byte ptr [rax], al\\n   0x4000a3                add    byte ptr [rax], al\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n'\n    gdb.execute('nextsyscall')\n    dis = gdb.execute('context disasm', to_string=True)\n    assert dis == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n   0x400085 <_start+5>     mov    edi, 0x1337\\n   0x40008a <_start+10>    mov    esi, 0xdeadbeef\\n   0x40008f <_start+15>    mov    ecx, 0x10\\n   0x400094 <_start+20>    syscall \\n   0x400096 <_start+22>    mov    eax, 0xa\\n \u25ba 0x40009b <_start+27>    int    0x80 <SYS_unlink>\\n        name:      0x1337\\n   0x40009d                add    byte ptr [rax], al\\n   0x40009f                add    byte ptr [rax], al\\n   0x4000a1                add    byte ptr [rax], al\\n   0x4000a3                add    byte ptr [rax], al\\n   0x4000a5                add    byte ptr [rax], al\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n'",
            "def test_context_disasm_syscalls_args_display(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    start_binary(SYSCALLS_BINARY)\n    gdb.execute('nextsyscall')\n    dis = gdb.execute('context disasm', to_string=True)\n    assert dis == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n   0x400080 <_start>       mov    eax, 0\\n   0x400085 <_start+5>     mov    edi, 0x1337\\n   0x40008a <_start+10>    mov    esi, 0xdeadbeef\\n   0x40008f <_start+15>    mov    ecx, 0x10\\n \u25ba 0x400094 <_start+20>    syscall  <SYS_read>\\n        fd:        0x1337\\n        buf:       0xdeadbeef\\n        nbytes:    0x0\\n   0x400096 <_start+22>    mov    eax, 0xa\\n   0x40009b <_start+27>    int    0x80\\n   0x40009d                add    byte ptr [rax], al\\n   0x40009f                add    byte ptr [rax], al\\n   0x4000a1                add    byte ptr [rax], al\\n   0x4000a3                add    byte ptr [rax], al\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n'\n    gdb.execute('nextsyscall')\n    dis = gdb.execute('context disasm', to_string=True)\n    assert dis == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n   0x400085 <_start+5>     mov    edi, 0x1337\\n   0x40008a <_start+10>    mov    esi, 0xdeadbeef\\n   0x40008f <_start+15>    mov    ecx, 0x10\\n   0x400094 <_start+20>    syscall \\n   0x400096 <_start+22>    mov    eax, 0xa\\n \u25ba 0x40009b <_start+27>    int    0x80 <SYS_unlink>\\n        name:      0x1337\\n   0x40009d                add    byte ptr [rax], al\\n   0x40009f                add    byte ptr [rax], al\\n   0x4000a1                add    byte ptr [rax], al\\n   0x4000a3                add    byte ptr [rax], al\\n   0x4000a5                add    byte ptr [rax], al\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n'",
            "def test_context_disasm_syscalls_args_display(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    start_binary(SYSCALLS_BINARY)\n    gdb.execute('nextsyscall')\n    dis = gdb.execute('context disasm', to_string=True)\n    assert dis == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n   0x400080 <_start>       mov    eax, 0\\n   0x400085 <_start+5>     mov    edi, 0x1337\\n   0x40008a <_start+10>    mov    esi, 0xdeadbeef\\n   0x40008f <_start+15>    mov    ecx, 0x10\\n \u25ba 0x400094 <_start+20>    syscall  <SYS_read>\\n        fd:        0x1337\\n        buf:       0xdeadbeef\\n        nbytes:    0x0\\n   0x400096 <_start+22>    mov    eax, 0xa\\n   0x40009b <_start+27>    int    0x80\\n   0x40009d                add    byte ptr [rax], al\\n   0x40009f                add    byte ptr [rax], al\\n   0x4000a1                add    byte ptr [rax], al\\n   0x4000a3                add    byte ptr [rax], al\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n'\n    gdb.execute('nextsyscall')\n    dis = gdb.execute('context disasm', to_string=True)\n    assert dis == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n   0x400085 <_start+5>     mov    edi, 0x1337\\n   0x40008a <_start+10>    mov    esi, 0xdeadbeef\\n   0x40008f <_start+15>    mov    ecx, 0x10\\n   0x400094 <_start+20>    syscall \\n   0x400096 <_start+22>    mov    eax, 0xa\\n \u25ba 0x40009b <_start+27>    int    0x80 <SYS_unlink>\\n        name:      0x1337\\n   0x40009d                add    byte ptr [rax], al\\n   0x40009f                add    byte ptr [rax], al\\n   0x4000a1                add    byte ptr [rax], al\\n   0x4000a3                add    byte ptr [rax], al\\n   0x4000a5                add    byte ptr [rax], al\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n'",
            "def test_context_disasm_syscalls_args_display(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    start_binary(SYSCALLS_BINARY)\n    gdb.execute('nextsyscall')\n    dis = gdb.execute('context disasm', to_string=True)\n    assert dis == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n   0x400080 <_start>       mov    eax, 0\\n   0x400085 <_start+5>     mov    edi, 0x1337\\n   0x40008a <_start+10>    mov    esi, 0xdeadbeef\\n   0x40008f <_start+15>    mov    ecx, 0x10\\n \u25ba 0x400094 <_start+20>    syscall  <SYS_read>\\n        fd:        0x1337\\n        buf:       0xdeadbeef\\n        nbytes:    0x0\\n   0x400096 <_start+22>    mov    eax, 0xa\\n   0x40009b <_start+27>    int    0x80\\n   0x40009d                add    byte ptr [rax], al\\n   0x40009f                add    byte ptr [rax], al\\n   0x4000a1                add    byte ptr [rax], al\\n   0x4000a3                add    byte ptr [rax], al\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n'\n    gdb.execute('nextsyscall')\n    dis = gdb.execute('context disasm', to_string=True)\n    assert dis == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n   0x400085 <_start+5>     mov    edi, 0x1337\\n   0x40008a <_start+10>    mov    esi, 0xdeadbeef\\n   0x40008f <_start+15>    mov    ecx, 0x10\\n   0x400094 <_start+20>    syscall \\n   0x400096 <_start+22>    mov    eax, 0xa\\n \u25ba 0x40009b <_start+27>    int    0x80 <SYS_unlink>\\n        name:      0x1337\\n   0x40009d                add    byte ptr [rax], al\\n   0x40009f                add    byte ptr [rax], al\\n   0x4000a1                add    byte ptr [rax], al\\n   0x4000a3                add    byte ptr [rax], al\\n   0x4000a5                add    byte ptr [rax], al\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n'"
        ]
    },
    {
        "func_name": "test_context_backtrace_show_proper_symbol_names",
        "original": "def test_context_backtrace_show_proper_symbol_names(start_binary):\n    start_binary(MANGLING_BINARY)\n    gdb.execute('break A::foo')\n    gdb.execute('continue')\n    backtrace = gdb.execute('context backtrace', to_string=True).split('\\n')\n    assert backtrace[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert backtrace[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert re.match('.*0   0x[0-9a-f]+ A::foo\\\\(int, int\\\\)', backtrace[2])\n    assert re.match('.*1   0x[0-9a-f]+ A::call_foo\\\\(\\\\)\\\\+\\\\d+', backtrace[3])\n    assert re.match('.*2   0x[0-9a-f]+ main\\\\+\\\\d+', backtrace[4])\n    assert re.match('.*3   0x[0-9a-f]+ (__libc_start_main|__libc_start_call_main)\\\\+\\\\d+', backtrace[5])\n    assert backtrace[-2] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert backtrace[-1] == ''",
        "mutated": [
            "def test_context_backtrace_show_proper_symbol_names(start_binary):\n    if False:\n        i = 10\n    start_binary(MANGLING_BINARY)\n    gdb.execute('break A::foo')\n    gdb.execute('continue')\n    backtrace = gdb.execute('context backtrace', to_string=True).split('\\n')\n    assert backtrace[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert backtrace[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert re.match('.*0   0x[0-9a-f]+ A::foo\\\\(int, int\\\\)', backtrace[2])\n    assert re.match('.*1   0x[0-9a-f]+ A::call_foo\\\\(\\\\)\\\\+\\\\d+', backtrace[3])\n    assert re.match('.*2   0x[0-9a-f]+ main\\\\+\\\\d+', backtrace[4])\n    assert re.match('.*3   0x[0-9a-f]+ (__libc_start_main|__libc_start_call_main)\\\\+\\\\d+', backtrace[5])\n    assert backtrace[-2] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert backtrace[-1] == ''",
            "def test_context_backtrace_show_proper_symbol_names(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    start_binary(MANGLING_BINARY)\n    gdb.execute('break A::foo')\n    gdb.execute('continue')\n    backtrace = gdb.execute('context backtrace', to_string=True).split('\\n')\n    assert backtrace[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert backtrace[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert re.match('.*0   0x[0-9a-f]+ A::foo\\\\(int, int\\\\)', backtrace[2])\n    assert re.match('.*1   0x[0-9a-f]+ A::call_foo\\\\(\\\\)\\\\+\\\\d+', backtrace[3])\n    assert re.match('.*2   0x[0-9a-f]+ main\\\\+\\\\d+', backtrace[4])\n    assert re.match('.*3   0x[0-9a-f]+ (__libc_start_main|__libc_start_call_main)\\\\+\\\\d+', backtrace[5])\n    assert backtrace[-2] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert backtrace[-1] == ''",
            "def test_context_backtrace_show_proper_symbol_names(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    start_binary(MANGLING_BINARY)\n    gdb.execute('break A::foo')\n    gdb.execute('continue')\n    backtrace = gdb.execute('context backtrace', to_string=True).split('\\n')\n    assert backtrace[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert backtrace[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert re.match('.*0   0x[0-9a-f]+ A::foo\\\\(int, int\\\\)', backtrace[2])\n    assert re.match('.*1   0x[0-9a-f]+ A::call_foo\\\\(\\\\)\\\\+\\\\d+', backtrace[3])\n    assert re.match('.*2   0x[0-9a-f]+ main\\\\+\\\\d+', backtrace[4])\n    assert re.match('.*3   0x[0-9a-f]+ (__libc_start_main|__libc_start_call_main)\\\\+\\\\d+', backtrace[5])\n    assert backtrace[-2] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert backtrace[-1] == ''",
            "def test_context_backtrace_show_proper_symbol_names(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    start_binary(MANGLING_BINARY)\n    gdb.execute('break A::foo')\n    gdb.execute('continue')\n    backtrace = gdb.execute('context backtrace', to_string=True).split('\\n')\n    assert backtrace[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert backtrace[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert re.match('.*0   0x[0-9a-f]+ A::foo\\\\(int, int\\\\)', backtrace[2])\n    assert re.match('.*1   0x[0-9a-f]+ A::call_foo\\\\(\\\\)\\\\+\\\\d+', backtrace[3])\n    assert re.match('.*2   0x[0-9a-f]+ main\\\\+\\\\d+', backtrace[4])\n    assert re.match('.*3   0x[0-9a-f]+ (__libc_start_main|__libc_start_call_main)\\\\+\\\\d+', backtrace[5])\n    assert backtrace[-2] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert backtrace[-1] == ''",
            "def test_context_backtrace_show_proper_symbol_names(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    start_binary(MANGLING_BINARY)\n    gdb.execute('break A::foo')\n    gdb.execute('continue')\n    backtrace = gdb.execute('context backtrace', to_string=True).split('\\n')\n    assert backtrace[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert backtrace[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ BACKTRACE ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert re.match('.*0   0x[0-9a-f]+ A::foo\\\\(int, int\\\\)', backtrace[2])\n    assert re.match('.*1   0x[0-9a-f]+ A::call_foo\\\\(\\\\)\\\\+\\\\d+', backtrace[3])\n    assert re.match('.*2   0x[0-9a-f]+ main\\\\+\\\\d+', backtrace[4])\n    assert re.match('.*3   0x[0-9a-f]+ (__libc_start_main|__libc_start_call_main)\\\\+\\\\d+', backtrace[5])\n    assert backtrace[-2] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert backtrace[-1] == ''"
        ]
    },
    {
        "func_name": "assert_intel",
        "original": "def assert_intel(out):\n    assert 'mov    eax, 0' in out[2]\n    assert 'mov    edi, 0x1337' in out[3]\n    assert 'mov    esi, 0xdeadbeef' in out[4]\n    assert 'mov    ecx, 0x10' in out[5]\n    assert 'syscall' in out[6]",
        "mutated": [
            "def assert_intel(out):\n    if False:\n        i = 10\n    assert 'mov    eax, 0' in out[2]\n    assert 'mov    edi, 0x1337' in out[3]\n    assert 'mov    esi, 0xdeadbeef' in out[4]\n    assert 'mov    ecx, 0x10' in out[5]\n    assert 'syscall' in out[6]",
            "def assert_intel(out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert 'mov    eax, 0' in out[2]\n    assert 'mov    edi, 0x1337' in out[3]\n    assert 'mov    esi, 0xdeadbeef' in out[4]\n    assert 'mov    ecx, 0x10' in out[5]\n    assert 'syscall' in out[6]",
            "def assert_intel(out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert 'mov    eax, 0' in out[2]\n    assert 'mov    edi, 0x1337' in out[3]\n    assert 'mov    esi, 0xdeadbeef' in out[4]\n    assert 'mov    ecx, 0x10' in out[5]\n    assert 'syscall' in out[6]",
            "def assert_intel(out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert 'mov    eax, 0' in out[2]\n    assert 'mov    edi, 0x1337' in out[3]\n    assert 'mov    esi, 0xdeadbeef' in out[4]\n    assert 'mov    ecx, 0x10' in out[5]\n    assert 'syscall' in out[6]",
            "def assert_intel(out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert 'mov    eax, 0' in out[2]\n    assert 'mov    edi, 0x1337' in out[3]\n    assert 'mov    esi, 0xdeadbeef' in out[4]\n    assert 'mov    ecx, 0x10' in out[5]\n    assert 'syscall' in out[6]"
        ]
    },
    {
        "func_name": "assert_att",
        "original": "def assert_att(out):\n    assert 'mov    movl   $0, %eax' not in out[2]\n    assert 'mov    movl   $0x1337, %edi' not in out[3]\n    assert 'mov    movl   $0xdeadbeef, %esi' not in out[4]\n    assert 'mov    movl   $0x10, %ecx' not in out[5]\n    assert 'syscall' in out[6]",
        "mutated": [
            "def assert_att(out):\n    if False:\n        i = 10\n    assert 'mov    movl   $0, %eax' not in out[2]\n    assert 'mov    movl   $0x1337, %edi' not in out[3]\n    assert 'mov    movl   $0xdeadbeef, %esi' not in out[4]\n    assert 'mov    movl   $0x10, %ecx' not in out[5]\n    assert 'syscall' in out[6]",
            "def assert_att(out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert 'mov    movl   $0, %eax' not in out[2]\n    assert 'mov    movl   $0x1337, %edi' not in out[3]\n    assert 'mov    movl   $0xdeadbeef, %esi' not in out[4]\n    assert 'mov    movl   $0x10, %ecx' not in out[5]\n    assert 'syscall' in out[6]",
            "def assert_att(out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert 'mov    movl   $0, %eax' not in out[2]\n    assert 'mov    movl   $0x1337, %edi' not in out[3]\n    assert 'mov    movl   $0xdeadbeef, %esi' not in out[4]\n    assert 'mov    movl   $0x10, %ecx' not in out[5]\n    assert 'syscall' in out[6]",
            "def assert_att(out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert 'mov    movl   $0, %eax' not in out[2]\n    assert 'mov    movl   $0x1337, %edi' not in out[3]\n    assert 'mov    movl   $0xdeadbeef, %esi' not in out[4]\n    assert 'mov    movl   $0x10, %ecx' not in out[5]\n    assert 'syscall' in out[6]",
            "def assert_att(out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert 'mov    movl   $0, %eax' not in out[2]\n    assert 'mov    movl   $0x1337, %edi' not in out[3]\n    assert 'mov    movl   $0xdeadbeef, %esi' not in out[4]\n    assert 'mov    movl   $0x10, %ecx' not in out[5]\n    assert 'syscall' in out[6]"
        ]
    },
    {
        "func_name": "test_context_disasm_works_properly_with_disasm_flavor_switch",
        "original": "def test_context_disasm_works_properly_with_disasm_flavor_switch(start_binary):\n    start_binary(SYSCALLS_BINARY)\n\n    def assert_intel(out):\n        assert 'mov    eax, 0' in out[2]\n        assert 'mov    edi, 0x1337' in out[3]\n        assert 'mov    esi, 0xdeadbeef' in out[4]\n        assert 'mov    ecx, 0x10' in out[5]\n        assert 'syscall' in out[6]\n\n    def assert_att(out):\n        assert 'mov    movl   $0, %eax' not in out[2]\n        assert 'mov    movl   $0x1337, %edi' not in out[3]\n        assert 'mov    movl   $0xdeadbeef, %esi' not in out[4]\n        assert 'mov    movl   $0x10, %ecx' not in out[5]\n        assert 'syscall' in out[6]\n    out = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert out[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert out[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert_intel(out)\n    gdb.execute('set disassembly-flavor att')\n    assert out[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert out[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert_att(out)",
        "mutated": [
            "def test_context_disasm_works_properly_with_disasm_flavor_switch(start_binary):\n    if False:\n        i = 10\n    start_binary(SYSCALLS_BINARY)\n\n    def assert_intel(out):\n        assert 'mov    eax, 0' in out[2]\n        assert 'mov    edi, 0x1337' in out[3]\n        assert 'mov    esi, 0xdeadbeef' in out[4]\n        assert 'mov    ecx, 0x10' in out[5]\n        assert 'syscall' in out[6]\n\n    def assert_att(out):\n        assert 'mov    movl   $0, %eax' not in out[2]\n        assert 'mov    movl   $0x1337, %edi' not in out[3]\n        assert 'mov    movl   $0xdeadbeef, %esi' not in out[4]\n        assert 'mov    movl   $0x10, %ecx' not in out[5]\n        assert 'syscall' in out[6]\n    out = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert out[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert out[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert_intel(out)\n    gdb.execute('set disassembly-flavor att')\n    assert out[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert out[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert_att(out)",
            "def test_context_disasm_works_properly_with_disasm_flavor_switch(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    start_binary(SYSCALLS_BINARY)\n\n    def assert_intel(out):\n        assert 'mov    eax, 0' in out[2]\n        assert 'mov    edi, 0x1337' in out[3]\n        assert 'mov    esi, 0xdeadbeef' in out[4]\n        assert 'mov    ecx, 0x10' in out[5]\n        assert 'syscall' in out[6]\n\n    def assert_att(out):\n        assert 'mov    movl   $0, %eax' not in out[2]\n        assert 'mov    movl   $0x1337, %edi' not in out[3]\n        assert 'mov    movl   $0xdeadbeef, %esi' not in out[4]\n        assert 'mov    movl   $0x10, %ecx' not in out[5]\n        assert 'syscall' in out[6]\n    out = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert out[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert out[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert_intel(out)\n    gdb.execute('set disassembly-flavor att')\n    assert out[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert out[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert_att(out)",
            "def test_context_disasm_works_properly_with_disasm_flavor_switch(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    start_binary(SYSCALLS_BINARY)\n\n    def assert_intel(out):\n        assert 'mov    eax, 0' in out[2]\n        assert 'mov    edi, 0x1337' in out[3]\n        assert 'mov    esi, 0xdeadbeef' in out[4]\n        assert 'mov    ecx, 0x10' in out[5]\n        assert 'syscall' in out[6]\n\n    def assert_att(out):\n        assert 'mov    movl   $0, %eax' not in out[2]\n        assert 'mov    movl   $0x1337, %edi' not in out[3]\n        assert 'mov    movl   $0xdeadbeef, %esi' not in out[4]\n        assert 'mov    movl   $0x10, %ecx' not in out[5]\n        assert 'syscall' in out[6]\n    out = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert out[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert out[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert_intel(out)\n    gdb.execute('set disassembly-flavor att')\n    assert out[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert out[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert_att(out)",
            "def test_context_disasm_works_properly_with_disasm_flavor_switch(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    start_binary(SYSCALLS_BINARY)\n\n    def assert_intel(out):\n        assert 'mov    eax, 0' in out[2]\n        assert 'mov    edi, 0x1337' in out[3]\n        assert 'mov    esi, 0xdeadbeef' in out[4]\n        assert 'mov    ecx, 0x10' in out[5]\n        assert 'syscall' in out[6]\n\n    def assert_att(out):\n        assert 'mov    movl   $0, %eax' not in out[2]\n        assert 'mov    movl   $0x1337, %edi' not in out[3]\n        assert 'mov    movl   $0xdeadbeef, %esi' not in out[4]\n        assert 'mov    movl   $0x10, %ecx' not in out[5]\n        assert 'syscall' in out[6]\n    out = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert out[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert out[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert_intel(out)\n    gdb.execute('set disassembly-flavor att')\n    assert out[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert out[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert_att(out)",
            "def test_context_disasm_works_properly_with_disasm_flavor_switch(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    start_binary(SYSCALLS_BINARY)\n\n    def assert_intel(out):\n        assert 'mov    eax, 0' in out[2]\n        assert 'mov    edi, 0x1337' in out[3]\n        assert 'mov    esi, 0xdeadbeef' in out[4]\n        assert 'mov    ecx, 0x10' in out[5]\n        assert 'syscall' in out[6]\n\n    def assert_att(out):\n        assert 'mov    movl   $0, %eax' not in out[2]\n        assert 'mov    movl   $0x1337, %edi' not in out[3]\n        assert 'mov    movl   $0xdeadbeef, %esi' not in out[4]\n        assert 'mov    movl   $0x10, %ecx' not in out[5]\n        assert 'syscall' in out[6]\n    out = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert out[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert out[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert_intel(out)\n    gdb.execute('set disassembly-flavor att')\n    assert out[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert out[1] == '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500'\n    assert_att(out)"
        ]
    },
    {
        "func_name": "test_context_disasm_proper_render_on_mem_change_issue_1818",
        "original": "@pytest.mark.parametrize('patch_or_api', (True, False))\ndef test_context_disasm_proper_render_on_mem_change_issue_1818(start_binary, patch_or_api):\n    start_binary(SYSCALLS_BINARY)\n    old = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert old[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert 'mov    eax, 0' in old[2]\n    assert 'mov    edi, 0x1337' in old[3]\n    assert 'mov    esi, 0xdeadbeef' in old[4]\n    assert 'mov    ecx, 0x10' in old[5]\n    assert 'syscall' in old[6]\n    if patch_or_api:\n        gdb.execute('patch $rip nop;nop;nop;nop;nop', to_string=True)\n    else:\n        pwndbg.gdblib.memory.write(pwndbg.gdblib.regs.rip, b'\\x90' * 5)\n    new = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert new[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert 'nop' in new[2]\n    assert 'nop' in new[3]\n    assert 'nop' in new[4]\n    assert 'nop' in new[5]\n    assert 'nop' in new[6]\n    assert 'mov    edi, 0x1337' in new[7]\n    assert 'mov    esi, 0xdeadbeef' in new[8]\n    assert 'mov    ecx, 0x10' in new[9]\n    assert 'syscall' in new[10]",
        "mutated": [
            "@pytest.mark.parametrize('patch_or_api', (True, False))\ndef test_context_disasm_proper_render_on_mem_change_issue_1818(start_binary, patch_or_api):\n    if False:\n        i = 10\n    start_binary(SYSCALLS_BINARY)\n    old = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert old[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert 'mov    eax, 0' in old[2]\n    assert 'mov    edi, 0x1337' in old[3]\n    assert 'mov    esi, 0xdeadbeef' in old[4]\n    assert 'mov    ecx, 0x10' in old[5]\n    assert 'syscall' in old[6]\n    if patch_or_api:\n        gdb.execute('patch $rip nop;nop;nop;nop;nop', to_string=True)\n    else:\n        pwndbg.gdblib.memory.write(pwndbg.gdblib.regs.rip, b'\\x90' * 5)\n    new = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert new[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert 'nop' in new[2]\n    assert 'nop' in new[3]\n    assert 'nop' in new[4]\n    assert 'nop' in new[5]\n    assert 'nop' in new[6]\n    assert 'mov    edi, 0x1337' in new[7]\n    assert 'mov    esi, 0xdeadbeef' in new[8]\n    assert 'mov    ecx, 0x10' in new[9]\n    assert 'syscall' in new[10]",
            "@pytest.mark.parametrize('patch_or_api', (True, False))\ndef test_context_disasm_proper_render_on_mem_change_issue_1818(start_binary, patch_or_api):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    start_binary(SYSCALLS_BINARY)\n    old = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert old[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert 'mov    eax, 0' in old[2]\n    assert 'mov    edi, 0x1337' in old[3]\n    assert 'mov    esi, 0xdeadbeef' in old[4]\n    assert 'mov    ecx, 0x10' in old[5]\n    assert 'syscall' in old[6]\n    if patch_or_api:\n        gdb.execute('patch $rip nop;nop;nop;nop;nop', to_string=True)\n    else:\n        pwndbg.gdblib.memory.write(pwndbg.gdblib.regs.rip, b'\\x90' * 5)\n    new = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert new[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert 'nop' in new[2]\n    assert 'nop' in new[3]\n    assert 'nop' in new[4]\n    assert 'nop' in new[5]\n    assert 'nop' in new[6]\n    assert 'mov    edi, 0x1337' in new[7]\n    assert 'mov    esi, 0xdeadbeef' in new[8]\n    assert 'mov    ecx, 0x10' in new[9]\n    assert 'syscall' in new[10]",
            "@pytest.mark.parametrize('patch_or_api', (True, False))\ndef test_context_disasm_proper_render_on_mem_change_issue_1818(start_binary, patch_or_api):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    start_binary(SYSCALLS_BINARY)\n    old = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert old[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert 'mov    eax, 0' in old[2]\n    assert 'mov    edi, 0x1337' in old[3]\n    assert 'mov    esi, 0xdeadbeef' in old[4]\n    assert 'mov    ecx, 0x10' in old[5]\n    assert 'syscall' in old[6]\n    if patch_or_api:\n        gdb.execute('patch $rip nop;nop;nop;nop;nop', to_string=True)\n    else:\n        pwndbg.gdblib.memory.write(pwndbg.gdblib.regs.rip, b'\\x90' * 5)\n    new = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert new[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert 'nop' in new[2]\n    assert 'nop' in new[3]\n    assert 'nop' in new[4]\n    assert 'nop' in new[5]\n    assert 'nop' in new[6]\n    assert 'mov    edi, 0x1337' in new[7]\n    assert 'mov    esi, 0xdeadbeef' in new[8]\n    assert 'mov    ecx, 0x10' in new[9]\n    assert 'syscall' in new[10]",
            "@pytest.mark.parametrize('patch_or_api', (True, False))\ndef test_context_disasm_proper_render_on_mem_change_issue_1818(start_binary, patch_or_api):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    start_binary(SYSCALLS_BINARY)\n    old = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert old[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert 'mov    eax, 0' in old[2]\n    assert 'mov    edi, 0x1337' in old[3]\n    assert 'mov    esi, 0xdeadbeef' in old[4]\n    assert 'mov    ecx, 0x10' in old[5]\n    assert 'syscall' in old[6]\n    if patch_or_api:\n        gdb.execute('patch $rip nop;nop;nop;nop;nop', to_string=True)\n    else:\n        pwndbg.gdblib.memory.write(pwndbg.gdblib.regs.rip, b'\\x90' * 5)\n    new = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert new[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert 'nop' in new[2]\n    assert 'nop' in new[3]\n    assert 'nop' in new[4]\n    assert 'nop' in new[5]\n    assert 'nop' in new[6]\n    assert 'mov    edi, 0x1337' in new[7]\n    assert 'mov    esi, 0xdeadbeef' in new[8]\n    assert 'mov    ecx, 0x10' in new[9]\n    assert 'syscall' in new[10]",
            "@pytest.mark.parametrize('patch_or_api', (True, False))\ndef test_context_disasm_proper_render_on_mem_change_issue_1818(start_binary, patch_or_api):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    start_binary(SYSCALLS_BINARY)\n    old = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert old[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert 'mov    eax, 0' in old[2]\n    assert 'mov    edi, 0x1337' in old[3]\n    assert 'mov    esi, 0xdeadbeef' in old[4]\n    assert 'mov    ecx, 0x10' in old[5]\n    assert 'syscall' in old[6]\n    if patch_or_api:\n        gdb.execute('patch $rip nop;nop;nop;nop;nop', to_string=True)\n    else:\n        pwndbg.gdblib.memory.write(pwndbg.gdblib.regs.rip, b'\\x90' * 5)\n    new = gdb.execute('context disasm', to_string=True).split('\\n')\n    assert new[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    assert 'nop' in new[2]\n    assert 'nop' in new[3]\n    assert 'nop' in new[4]\n    assert 'nop' in new[5]\n    assert 'nop' in new[6]\n    assert 'mov    edi, 0x1337' in new[7]\n    assert 'mov    esi, 0xdeadbeef' in new[8]\n    assert 'mov    ecx, 0x10' in new[9]\n    assert 'syscall' in new[10]"
        ]
    }
]