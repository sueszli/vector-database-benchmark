[
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    kb.data.currentDb = ''\n    kb.data.cachedDbs = []\n    kb.data.cachedTables = {}\n    kb.data.cachedColumns = {}\n    kb.data.cachedCounts = {}\n    kb.data.dumpedTable = {}\n    kb.data.cachedStatements = []",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    kb.data.currentDb = ''\n    kb.data.cachedDbs = []\n    kb.data.cachedTables = {}\n    kb.data.cachedColumns = {}\n    kb.data.cachedCounts = {}\n    kb.data.dumpedTable = {}\n    kb.data.cachedStatements = []",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    kb.data.currentDb = ''\n    kb.data.cachedDbs = []\n    kb.data.cachedTables = {}\n    kb.data.cachedColumns = {}\n    kb.data.cachedCounts = {}\n    kb.data.dumpedTable = {}\n    kb.data.cachedStatements = []",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    kb.data.currentDb = ''\n    kb.data.cachedDbs = []\n    kb.data.cachedTables = {}\n    kb.data.cachedColumns = {}\n    kb.data.cachedCounts = {}\n    kb.data.dumpedTable = {}\n    kb.data.cachedStatements = []",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    kb.data.currentDb = ''\n    kb.data.cachedDbs = []\n    kb.data.cachedTables = {}\n    kb.data.cachedColumns = {}\n    kb.data.cachedCounts = {}\n    kb.data.dumpedTable = {}\n    kb.data.cachedStatements = []",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    kb.data.currentDb = ''\n    kb.data.cachedDbs = []\n    kb.data.cachedTables = {}\n    kb.data.cachedColumns = {}\n    kb.data.cachedCounts = {}\n    kb.data.dumpedTable = {}\n    kb.data.cachedStatements = []"
        ]
    },
    {
        "func_name": "getCurrentDb",
        "original": "def getCurrentDb(self):\n    infoMsg = 'fetching current database'\n    logger.info(infoMsg)\n    query = queries[Backend.getIdentifiedDbms()].current_db.query\n    if not kb.data.currentDb:\n        kb.data.currentDb = unArrayizeValue(inject.getValue(query, safeCharEncode=False))\n    if not kb.data.currentDb and Backend.isDbms(DBMS.VERTICA):\n        kb.data.currentDb = VERTICA_DEFAULT_SCHEMA\n    if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.PGSQL, DBMS.MONETDB, DBMS.DERBY, DBMS.VERTICA, DBMS.PRESTO, DBMS.MIMERSQL, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.CLICKHOUSE):\n        warnMsg = \"on %s you'll need to use \" % Backend.getIdentifiedDbms()\n        warnMsg += 'schema names for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        singleTimeWarnMessage(warnMsg)\n    elif Backend.getIdentifiedDbms() in (DBMS.ALTIBASE, DBMS.CUBRID):\n        warnMsg = \"on %s you'll need to use \" % Backend.getIdentifiedDbms()\n        warnMsg += 'user names for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        singleTimeWarnMessage(warnMsg)\n    return kb.data.currentDb",
        "mutated": [
            "def getCurrentDb(self):\n    if False:\n        i = 10\n    infoMsg = 'fetching current database'\n    logger.info(infoMsg)\n    query = queries[Backend.getIdentifiedDbms()].current_db.query\n    if not kb.data.currentDb:\n        kb.data.currentDb = unArrayizeValue(inject.getValue(query, safeCharEncode=False))\n    if not kb.data.currentDb and Backend.isDbms(DBMS.VERTICA):\n        kb.data.currentDb = VERTICA_DEFAULT_SCHEMA\n    if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.PGSQL, DBMS.MONETDB, DBMS.DERBY, DBMS.VERTICA, DBMS.PRESTO, DBMS.MIMERSQL, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.CLICKHOUSE):\n        warnMsg = \"on %s you'll need to use \" % Backend.getIdentifiedDbms()\n        warnMsg += 'schema names for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        singleTimeWarnMessage(warnMsg)\n    elif Backend.getIdentifiedDbms() in (DBMS.ALTIBASE, DBMS.CUBRID):\n        warnMsg = \"on %s you'll need to use \" % Backend.getIdentifiedDbms()\n        warnMsg += 'user names for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        singleTimeWarnMessage(warnMsg)\n    return kb.data.currentDb",
            "def getCurrentDb(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    infoMsg = 'fetching current database'\n    logger.info(infoMsg)\n    query = queries[Backend.getIdentifiedDbms()].current_db.query\n    if not kb.data.currentDb:\n        kb.data.currentDb = unArrayizeValue(inject.getValue(query, safeCharEncode=False))\n    if not kb.data.currentDb and Backend.isDbms(DBMS.VERTICA):\n        kb.data.currentDb = VERTICA_DEFAULT_SCHEMA\n    if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.PGSQL, DBMS.MONETDB, DBMS.DERBY, DBMS.VERTICA, DBMS.PRESTO, DBMS.MIMERSQL, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.CLICKHOUSE):\n        warnMsg = \"on %s you'll need to use \" % Backend.getIdentifiedDbms()\n        warnMsg += 'schema names for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        singleTimeWarnMessage(warnMsg)\n    elif Backend.getIdentifiedDbms() in (DBMS.ALTIBASE, DBMS.CUBRID):\n        warnMsg = \"on %s you'll need to use \" % Backend.getIdentifiedDbms()\n        warnMsg += 'user names for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        singleTimeWarnMessage(warnMsg)\n    return kb.data.currentDb",
            "def getCurrentDb(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    infoMsg = 'fetching current database'\n    logger.info(infoMsg)\n    query = queries[Backend.getIdentifiedDbms()].current_db.query\n    if not kb.data.currentDb:\n        kb.data.currentDb = unArrayizeValue(inject.getValue(query, safeCharEncode=False))\n    if not kb.data.currentDb and Backend.isDbms(DBMS.VERTICA):\n        kb.data.currentDb = VERTICA_DEFAULT_SCHEMA\n    if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.PGSQL, DBMS.MONETDB, DBMS.DERBY, DBMS.VERTICA, DBMS.PRESTO, DBMS.MIMERSQL, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.CLICKHOUSE):\n        warnMsg = \"on %s you'll need to use \" % Backend.getIdentifiedDbms()\n        warnMsg += 'schema names for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        singleTimeWarnMessage(warnMsg)\n    elif Backend.getIdentifiedDbms() in (DBMS.ALTIBASE, DBMS.CUBRID):\n        warnMsg = \"on %s you'll need to use \" % Backend.getIdentifiedDbms()\n        warnMsg += 'user names for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        singleTimeWarnMessage(warnMsg)\n    return kb.data.currentDb",
            "def getCurrentDb(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    infoMsg = 'fetching current database'\n    logger.info(infoMsg)\n    query = queries[Backend.getIdentifiedDbms()].current_db.query\n    if not kb.data.currentDb:\n        kb.data.currentDb = unArrayizeValue(inject.getValue(query, safeCharEncode=False))\n    if not kb.data.currentDb and Backend.isDbms(DBMS.VERTICA):\n        kb.data.currentDb = VERTICA_DEFAULT_SCHEMA\n    if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.PGSQL, DBMS.MONETDB, DBMS.DERBY, DBMS.VERTICA, DBMS.PRESTO, DBMS.MIMERSQL, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.CLICKHOUSE):\n        warnMsg = \"on %s you'll need to use \" % Backend.getIdentifiedDbms()\n        warnMsg += 'schema names for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        singleTimeWarnMessage(warnMsg)\n    elif Backend.getIdentifiedDbms() in (DBMS.ALTIBASE, DBMS.CUBRID):\n        warnMsg = \"on %s you'll need to use \" % Backend.getIdentifiedDbms()\n        warnMsg += 'user names for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        singleTimeWarnMessage(warnMsg)\n    return kb.data.currentDb",
            "def getCurrentDb(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    infoMsg = 'fetching current database'\n    logger.info(infoMsg)\n    query = queries[Backend.getIdentifiedDbms()].current_db.query\n    if not kb.data.currentDb:\n        kb.data.currentDb = unArrayizeValue(inject.getValue(query, safeCharEncode=False))\n    if not kb.data.currentDb and Backend.isDbms(DBMS.VERTICA):\n        kb.data.currentDb = VERTICA_DEFAULT_SCHEMA\n    if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.PGSQL, DBMS.MONETDB, DBMS.DERBY, DBMS.VERTICA, DBMS.PRESTO, DBMS.MIMERSQL, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.CLICKHOUSE):\n        warnMsg = \"on %s you'll need to use \" % Backend.getIdentifiedDbms()\n        warnMsg += 'schema names for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        singleTimeWarnMessage(warnMsg)\n    elif Backend.getIdentifiedDbms() in (DBMS.ALTIBASE, DBMS.CUBRID):\n        warnMsg = \"on %s you'll need to use \" % Backend.getIdentifiedDbms()\n        warnMsg += 'user names for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        singleTimeWarnMessage(warnMsg)\n    return kb.data.currentDb"
        ]
    },
    {
        "func_name": "getDbs",
        "original": "def getDbs(self):\n    if len(kb.data.cachedDbs) > 0:\n        return kb.data.cachedDbs\n    infoMsg = None\n    if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n        warnMsg = 'information_schema not available, '\n        warnMsg += 'back-end DBMS is MySQL < 5. database '\n        warnMsg += \"names will be fetched from 'mysql' database\"\n        logger.warning(warnMsg)\n    elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.PGSQL, DBMS.MONETDB, DBMS.DERBY, DBMS.VERTICA, DBMS.PRESTO, DBMS.MIMERSQL, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.CLICKHOUSE):\n        warnMsg = 'schema names are going to be used on %s ' % Backend.getIdentifiedDbms()\n        warnMsg += 'for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        logger.warning(warnMsg)\n        infoMsg = 'fetching database (schema) names'\n    elif Backend.getIdentifiedDbms() in (DBMS.ALTIBASE, DBMS.CUBRID):\n        warnMsg = 'user names are going to be used on %s ' % Backend.getIdentifiedDbms()\n        warnMsg += 'for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        logger.warning(warnMsg)\n        infoMsg = 'fetching database (user) names'\n    else:\n        infoMsg = 'fetching database names'\n    if infoMsg:\n        logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].dbs\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            query = rootQuery.inband.query2\n        else:\n            query = rootQuery.inband.query\n        values = inject.getValue(query, blind=False, time=False)\n        if not isNoneValue(values):\n            kb.data.cachedDbs = arrayizeValue(values)\n    if not kb.data.cachedDbs and isInferenceAvailable() and (not conf.direct):\n        infoMsg = 'fetching number of databases'\n        logger.info(infoMsg)\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            query = rootQuery.blind.count2\n        else:\n            query = rootQuery.blind.count\n        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n        if not isNumPosStrValue(count):\n            errMsg = 'unable to retrieve the number of databases'\n            logger.error(errMsg)\n        else:\n            plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n            indexRange = getLimitRange(count, plusOne=plusOne)\n            for index in indexRange:\n                if Backend.isDbms(DBMS.SYBASE):\n                    query = rootQuery.blind.query % (kb.data.cachedDbs[-1] if kb.data.cachedDbs else ' ')\n                elif Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n                    query = rootQuery.blind.query2 % index\n                else:\n                    query = rootQuery.blind.query % index\n                db = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                if not isNoneValue(db):\n                    kb.data.cachedDbs.append(safeSQLIdentificatorNaming(db))\n    if not kb.data.cachedDbs and Backend.isDbms(DBMS.MSSQL):\n        if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n            blinds = (False, True)\n        else:\n            blinds = (True,)\n        for blind in blinds:\n            count = 0\n            kb.data.cachedDbs = []\n            while True:\n                query = rootQuery.inband.query2 % count\n                value = unArrayizeValue(inject.getValue(query, blind=blind))\n                if not (value or '').strip():\n                    break\n                else:\n                    kb.data.cachedDbs.append(value)\n                    count += 1\n            if kb.data.cachedDbs:\n                break\n    if not kb.data.cachedDbs:\n        infoMsg = 'falling back to current database'\n        logger.info(infoMsg)\n        self.getCurrentDb()\n        if kb.data.currentDb:\n            kb.data.cachedDbs = [kb.data.currentDb]\n        else:\n            errMsg = 'unable to retrieve the database names'\n            raise SqlmapNoneDataException(errMsg)\n    else:\n        kb.data.cachedDbs.sort()\n    if kb.data.cachedDbs:\n        kb.data.cachedDbs = [_ for _ in set(flattenValue(kb.data.cachedDbs)) if _]\n    return kb.data.cachedDbs",
        "mutated": [
            "def getDbs(self):\n    if False:\n        i = 10\n    if len(kb.data.cachedDbs) > 0:\n        return kb.data.cachedDbs\n    infoMsg = None\n    if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n        warnMsg = 'information_schema not available, '\n        warnMsg += 'back-end DBMS is MySQL < 5. database '\n        warnMsg += \"names will be fetched from 'mysql' database\"\n        logger.warning(warnMsg)\n    elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.PGSQL, DBMS.MONETDB, DBMS.DERBY, DBMS.VERTICA, DBMS.PRESTO, DBMS.MIMERSQL, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.CLICKHOUSE):\n        warnMsg = 'schema names are going to be used on %s ' % Backend.getIdentifiedDbms()\n        warnMsg += 'for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        logger.warning(warnMsg)\n        infoMsg = 'fetching database (schema) names'\n    elif Backend.getIdentifiedDbms() in (DBMS.ALTIBASE, DBMS.CUBRID):\n        warnMsg = 'user names are going to be used on %s ' % Backend.getIdentifiedDbms()\n        warnMsg += 'for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        logger.warning(warnMsg)\n        infoMsg = 'fetching database (user) names'\n    else:\n        infoMsg = 'fetching database names'\n    if infoMsg:\n        logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].dbs\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            query = rootQuery.inband.query2\n        else:\n            query = rootQuery.inband.query\n        values = inject.getValue(query, blind=False, time=False)\n        if not isNoneValue(values):\n            kb.data.cachedDbs = arrayizeValue(values)\n    if not kb.data.cachedDbs and isInferenceAvailable() and (not conf.direct):\n        infoMsg = 'fetching number of databases'\n        logger.info(infoMsg)\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            query = rootQuery.blind.count2\n        else:\n            query = rootQuery.blind.count\n        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n        if not isNumPosStrValue(count):\n            errMsg = 'unable to retrieve the number of databases'\n            logger.error(errMsg)\n        else:\n            plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n            indexRange = getLimitRange(count, plusOne=plusOne)\n            for index in indexRange:\n                if Backend.isDbms(DBMS.SYBASE):\n                    query = rootQuery.blind.query % (kb.data.cachedDbs[-1] if kb.data.cachedDbs else ' ')\n                elif Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n                    query = rootQuery.blind.query2 % index\n                else:\n                    query = rootQuery.blind.query % index\n                db = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                if not isNoneValue(db):\n                    kb.data.cachedDbs.append(safeSQLIdentificatorNaming(db))\n    if not kb.data.cachedDbs and Backend.isDbms(DBMS.MSSQL):\n        if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n            blinds = (False, True)\n        else:\n            blinds = (True,)\n        for blind in blinds:\n            count = 0\n            kb.data.cachedDbs = []\n            while True:\n                query = rootQuery.inband.query2 % count\n                value = unArrayizeValue(inject.getValue(query, blind=blind))\n                if not (value or '').strip():\n                    break\n                else:\n                    kb.data.cachedDbs.append(value)\n                    count += 1\n            if kb.data.cachedDbs:\n                break\n    if not kb.data.cachedDbs:\n        infoMsg = 'falling back to current database'\n        logger.info(infoMsg)\n        self.getCurrentDb()\n        if kb.data.currentDb:\n            kb.data.cachedDbs = [kb.data.currentDb]\n        else:\n            errMsg = 'unable to retrieve the database names'\n            raise SqlmapNoneDataException(errMsg)\n    else:\n        kb.data.cachedDbs.sort()\n    if kb.data.cachedDbs:\n        kb.data.cachedDbs = [_ for _ in set(flattenValue(kb.data.cachedDbs)) if _]\n    return kb.data.cachedDbs",
            "def getDbs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if len(kb.data.cachedDbs) > 0:\n        return kb.data.cachedDbs\n    infoMsg = None\n    if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n        warnMsg = 'information_schema not available, '\n        warnMsg += 'back-end DBMS is MySQL < 5. database '\n        warnMsg += \"names will be fetched from 'mysql' database\"\n        logger.warning(warnMsg)\n    elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.PGSQL, DBMS.MONETDB, DBMS.DERBY, DBMS.VERTICA, DBMS.PRESTO, DBMS.MIMERSQL, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.CLICKHOUSE):\n        warnMsg = 'schema names are going to be used on %s ' % Backend.getIdentifiedDbms()\n        warnMsg += 'for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        logger.warning(warnMsg)\n        infoMsg = 'fetching database (schema) names'\n    elif Backend.getIdentifiedDbms() in (DBMS.ALTIBASE, DBMS.CUBRID):\n        warnMsg = 'user names are going to be used on %s ' % Backend.getIdentifiedDbms()\n        warnMsg += 'for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        logger.warning(warnMsg)\n        infoMsg = 'fetching database (user) names'\n    else:\n        infoMsg = 'fetching database names'\n    if infoMsg:\n        logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].dbs\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            query = rootQuery.inband.query2\n        else:\n            query = rootQuery.inband.query\n        values = inject.getValue(query, blind=False, time=False)\n        if not isNoneValue(values):\n            kb.data.cachedDbs = arrayizeValue(values)\n    if not kb.data.cachedDbs and isInferenceAvailable() and (not conf.direct):\n        infoMsg = 'fetching number of databases'\n        logger.info(infoMsg)\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            query = rootQuery.blind.count2\n        else:\n            query = rootQuery.blind.count\n        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n        if not isNumPosStrValue(count):\n            errMsg = 'unable to retrieve the number of databases'\n            logger.error(errMsg)\n        else:\n            plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n            indexRange = getLimitRange(count, plusOne=plusOne)\n            for index in indexRange:\n                if Backend.isDbms(DBMS.SYBASE):\n                    query = rootQuery.blind.query % (kb.data.cachedDbs[-1] if kb.data.cachedDbs else ' ')\n                elif Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n                    query = rootQuery.blind.query2 % index\n                else:\n                    query = rootQuery.blind.query % index\n                db = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                if not isNoneValue(db):\n                    kb.data.cachedDbs.append(safeSQLIdentificatorNaming(db))\n    if not kb.data.cachedDbs and Backend.isDbms(DBMS.MSSQL):\n        if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n            blinds = (False, True)\n        else:\n            blinds = (True,)\n        for blind in blinds:\n            count = 0\n            kb.data.cachedDbs = []\n            while True:\n                query = rootQuery.inband.query2 % count\n                value = unArrayizeValue(inject.getValue(query, blind=blind))\n                if not (value or '').strip():\n                    break\n                else:\n                    kb.data.cachedDbs.append(value)\n                    count += 1\n            if kb.data.cachedDbs:\n                break\n    if not kb.data.cachedDbs:\n        infoMsg = 'falling back to current database'\n        logger.info(infoMsg)\n        self.getCurrentDb()\n        if kb.data.currentDb:\n            kb.data.cachedDbs = [kb.data.currentDb]\n        else:\n            errMsg = 'unable to retrieve the database names'\n            raise SqlmapNoneDataException(errMsg)\n    else:\n        kb.data.cachedDbs.sort()\n    if kb.data.cachedDbs:\n        kb.data.cachedDbs = [_ for _ in set(flattenValue(kb.data.cachedDbs)) if _]\n    return kb.data.cachedDbs",
            "def getDbs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if len(kb.data.cachedDbs) > 0:\n        return kb.data.cachedDbs\n    infoMsg = None\n    if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n        warnMsg = 'information_schema not available, '\n        warnMsg += 'back-end DBMS is MySQL < 5. database '\n        warnMsg += \"names will be fetched from 'mysql' database\"\n        logger.warning(warnMsg)\n    elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.PGSQL, DBMS.MONETDB, DBMS.DERBY, DBMS.VERTICA, DBMS.PRESTO, DBMS.MIMERSQL, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.CLICKHOUSE):\n        warnMsg = 'schema names are going to be used on %s ' % Backend.getIdentifiedDbms()\n        warnMsg += 'for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        logger.warning(warnMsg)\n        infoMsg = 'fetching database (schema) names'\n    elif Backend.getIdentifiedDbms() in (DBMS.ALTIBASE, DBMS.CUBRID):\n        warnMsg = 'user names are going to be used on %s ' % Backend.getIdentifiedDbms()\n        warnMsg += 'for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        logger.warning(warnMsg)\n        infoMsg = 'fetching database (user) names'\n    else:\n        infoMsg = 'fetching database names'\n    if infoMsg:\n        logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].dbs\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            query = rootQuery.inband.query2\n        else:\n            query = rootQuery.inband.query\n        values = inject.getValue(query, blind=False, time=False)\n        if not isNoneValue(values):\n            kb.data.cachedDbs = arrayizeValue(values)\n    if not kb.data.cachedDbs and isInferenceAvailable() and (not conf.direct):\n        infoMsg = 'fetching number of databases'\n        logger.info(infoMsg)\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            query = rootQuery.blind.count2\n        else:\n            query = rootQuery.blind.count\n        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n        if not isNumPosStrValue(count):\n            errMsg = 'unable to retrieve the number of databases'\n            logger.error(errMsg)\n        else:\n            plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n            indexRange = getLimitRange(count, plusOne=plusOne)\n            for index in indexRange:\n                if Backend.isDbms(DBMS.SYBASE):\n                    query = rootQuery.blind.query % (kb.data.cachedDbs[-1] if kb.data.cachedDbs else ' ')\n                elif Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n                    query = rootQuery.blind.query2 % index\n                else:\n                    query = rootQuery.blind.query % index\n                db = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                if not isNoneValue(db):\n                    kb.data.cachedDbs.append(safeSQLIdentificatorNaming(db))\n    if not kb.data.cachedDbs and Backend.isDbms(DBMS.MSSQL):\n        if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n            blinds = (False, True)\n        else:\n            blinds = (True,)\n        for blind in blinds:\n            count = 0\n            kb.data.cachedDbs = []\n            while True:\n                query = rootQuery.inband.query2 % count\n                value = unArrayizeValue(inject.getValue(query, blind=blind))\n                if not (value or '').strip():\n                    break\n                else:\n                    kb.data.cachedDbs.append(value)\n                    count += 1\n            if kb.data.cachedDbs:\n                break\n    if not kb.data.cachedDbs:\n        infoMsg = 'falling back to current database'\n        logger.info(infoMsg)\n        self.getCurrentDb()\n        if kb.data.currentDb:\n            kb.data.cachedDbs = [kb.data.currentDb]\n        else:\n            errMsg = 'unable to retrieve the database names'\n            raise SqlmapNoneDataException(errMsg)\n    else:\n        kb.data.cachedDbs.sort()\n    if kb.data.cachedDbs:\n        kb.data.cachedDbs = [_ for _ in set(flattenValue(kb.data.cachedDbs)) if _]\n    return kb.data.cachedDbs",
            "def getDbs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if len(kb.data.cachedDbs) > 0:\n        return kb.data.cachedDbs\n    infoMsg = None\n    if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n        warnMsg = 'information_schema not available, '\n        warnMsg += 'back-end DBMS is MySQL < 5. database '\n        warnMsg += \"names will be fetched from 'mysql' database\"\n        logger.warning(warnMsg)\n    elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.PGSQL, DBMS.MONETDB, DBMS.DERBY, DBMS.VERTICA, DBMS.PRESTO, DBMS.MIMERSQL, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.CLICKHOUSE):\n        warnMsg = 'schema names are going to be used on %s ' % Backend.getIdentifiedDbms()\n        warnMsg += 'for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        logger.warning(warnMsg)\n        infoMsg = 'fetching database (schema) names'\n    elif Backend.getIdentifiedDbms() in (DBMS.ALTIBASE, DBMS.CUBRID):\n        warnMsg = 'user names are going to be used on %s ' % Backend.getIdentifiedDbms()\n        warnMsg += 'for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        logger.warning(warnMsg)\n        infoMsg = 'fetching database (user) names'\n    else:\n        infoMsg = 'fetching database names'\n    if infoMsg:\n        logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].dbs\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            query = rootQuery.inband.query2\n        else:\n            query = rootQuery.inband.query\n        values = inject.getValue(query, blind=False, time=False)\n        if not isNoneValue(values):\n            kb.data.cachedDbs = arrayizeValue(values)\n    if not kb.data.cachedDbs and isInferenceAvailable() and (not conf.direct):\n        infoMsg = 'fetching number of databases'\n        logger.info(infoMsg)\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            query = rootQuery.blind.count2\n        else:\n            query = rootQuery.blind.count\n        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n        if not isNumPosStrValue(count):\n            errMsg = 'unable to retrieve the number of databases'\n            logger.error(errMsg)\n        else:\n            plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n            indexRange = getLimitRange(count, plusOne=plusOne)\n            for index in indexRange:\n                if Backend.isDbms(DBMS.SYBASE):\n                    query = rootQuery.blind.query % (kb.data.cachedDbs[-1] if kb.data.cachedDbs else ' ')\n                elif Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n                    query = rootQuery.blind.query2 % index\n                else:\n                    query = rootQuery.blind.query % index\n                db = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                if not isNoneValue(db):\n                    kb.data.cachedDbs.append(safeSQLIdentificatorNaming(db))\n    if not kb.data.cachedDbs and Backend.isDbms(DBMS.MSSQL):\n        if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n            blinds = (False, True)\n        else:\n            blinds = (True,)\n        for blind in blinds:\n            count = 0\n            kb.data.cachedDbs = []\n            while True:\n                query = rootQuery.inband.query2 % count\n                value = unArrayizeValue(inject.getValue(query, blind=blind))\n                if not (value or '').strip():\n                    break\n                else:\n                    kb.data.cachedDbs.append(value)\n                    count += 1\n            if kb.data.cachedDbs:\n                break\n    if not kb.data.cachedDbs:\n        infoMsg = 'falling back to current database'\n        logger.info(infoMsg)\n        self.getCurrentDb()\n        if kb.data.currentDb:\n            kb.data.cachedDbs = [kb.data.currentDb]\n        else:\n            errMsg = 'unable to retrieve the database names'\n            raise SqlmapNoneDataException(errMsg)\n    else:\n        kb.data.cachedDbs.sort()\n    if kb.data.cachedDbs:\n        kb.data.cachedDbs = [_ for _ in set(flattenValue(kb.data.cachedDbs)) if _]\n    return kb.data.cachedDbs",
            "def getDbs(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if len(kb.data.cachedDbs) > 0:\n        return kb.data.cachedDbs\n    infoMsg = None\n    if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n        warnMsg = 'information_schema not available, '\n        warnMsg += 'back-end DBMS is MySQL < 5. database '\n        warnMsg += \"names will be fetched from 'mysql' database\"\n        logger.warning(warnMsg)\n    elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.PGSQL, DBMS.MONETDB, DBMS.DERBY, DBMS.VERTICA, DBMS.PRESTO, DBMS.MIMERSQL, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.CLICKHOUSE):\n        warnMsg = 'schema names are going to be used on %s ' % Backend.getIdentifiedDbms()\n        warnMsg += 'for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        logger.warning(warnMsg)\n        infoMsg = 'fetching database (schema) names'\n    elif Backend.getIdentifiedDbms() in (DBMS.ALTIBASE, DBMS.CUBRID):\n        warnMsg = 'user names are going to be used on %s ' % Backend.getIdentifiedDbms()\n        warnMsg += 'for enumeration as the counterpart to database '\n        warnMsg += 'names on other DBMSes'\n        logger.warning(warnMsg)\n        infoMsg = 'fetching database (user) names'\n    else:\n        infoMsg = 'fetching database names'\n    if infoMsg:\n        logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].dbs\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            query = rootQuery.inband.query2\n        else:\n            query = rootQuery.inband.query\n        values = inject.getValue(query, blind=False, time=False)\n        if not isNoneValue(values):\n            kb.data.cachedDbs = arrayizeValue(values)\n    if not kb.data.cachedDbs and isInferenceAvailable() and (not conf.direct):\n        infoMsg = 'fetching number of databases'\n        logger.info(infoMsg)\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            query = rootQuery.blind.count2\n        else:\n            query = rootQuery.blind.count\n        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n        if not isNumPosStrValue(count):\n            errMsg = 'unable to retrieve the number of databases'\n            logger.error(errMsg)\n        else:\n            plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n            indexRange = getLimitRange(count, plusOne=plusOne)\n            for index in indexRange:\n                if Backend.isDbms(DBMS.SYBASE):\n                    query = rootQuery.blind.query % (kb.data.cachedDbs[-1] if kb.data.cachedDbs else ' ')\n                elif Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n                    query = rootQuery.blind.query2 % index\n                else:\n                    query = rootQuery.blind.query % index\n                db = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                if not isNoneValue(db):\n                    kb.data.cachedDbs.append(safeSQLIdentificatorNaming(db))\n    if not kb.data.cachedDbs and Backend.isDbms(DBMS.MSSQL):\n        if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n            blinds = (False, True)\n        else:\n            blinds = (True,)\n        for blind in blinds:\n            count = 0\n            kb.data.cachedDbs = []\n            while True:\n                query = rootQuery.inband.query2 % count\n                value = unArrayizeValue(inject.getValue(query, blind=blind))\n                if not (value or '').strip():\n                    break\n                else:\n                    kb.data.cachedDbs.append(value)\n                    count += 1\n            if kb.data.cachedDbs:\n                break\n    if not kb.data.cachedDbs:\n        infoMsg = 'falling back to current database'\n        logger.info(infoMsg)\n        self.getCurrentDb()\n        if kb.data.currentDb:\n            kb.data.cachedDbs = [kb.data.currentDb]\n        else:\n            errMsg = 'unable to retrieve the database names'\n            raise SqlmapNoneDataException(errMsg)\n    else:\n        kb.data.cachedDbs.sort()\n    if kb.data.cachedDbs:\n        kb.data.cachedDbs = [_ for _ in set(flattenValue(kb.data.cachedDbs)) if _]\n    return kb.data.cachedDbs"
        ]
    },
    {
        "func_name": "getTables",
        "original": "def getTables(self, bruteForce=None):\n    if len(kb.data.cachedTables) > 0:\n        return kb.data.cachedTables\n    self.forceDbmsEnum()\n    if bruteForce is None:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            warnMsg = 'information_schema not available, '\n            warnMsg += 'back-end DBMS is MySQL < 5.0'\n            logger.warning(warnMsg)\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.MCKOI, DBMS.EXTREMEDB, DBMS.RAIMA):\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.ACCESS,):\n            try:\n                tables = self.getTables(False)\n            except SqlmapNoneDataException:\n                tables = None\n            if not tables:\n                warnMsg = 'cannot retrieve table names, '\n                warnMsg += 'back-end DBMS is %s' % Backend.getIdentifiedDbms()\n                logger.warning(warnMsg)\n                bruteForce = True\n            else:\n                return tables\n    if conf.db == CURRENT_DB:\n        conf.db = self.getCurrentDb()\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    if conf.db:\n        dbs = conf.db.split(',')\n    else:\n        dbs = self.getDbs()\n    dbs = [_ for _ in dbs if _ and _.strip()]\n    for db in dbs:\n        dbs[dbs.index(db)] = safeSQLIdentificatorNaming(db)\n    if bruteForce:\n        resumeAvailable = False\n        for (db, table) in kb.brute.tables:\n            if db == conf.db:\n                resumeAvailable = True\n                break\n        if resumeAvailable and (not conf.freshQueries):\n            for (db, table) in kb.brute.tables:\n                if db == conf.db:\n                    if conf.db not in kb.data.cachedTables:\n                        kb.data.cachedTables[conf.db] = [table]\n                    else:\n                        kb.data.cachedTables[conf.db].append(table)\n            return kb.data.cachedTables\n        message = 'do you want to use common table existence check? %s ' % ('[Y/n/q]' if Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB) else '[y/N/q]')\n        choice = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n        if choice == 'N':\n            return\n        elif choice == 'Q':\n            raise SqlmapUserQuitException\n        else:\n            return tableExists(paths.COMMON_TABLES)\n    infoMsg = 'fetching tables for database'\n    infoMsg += \"%s: '%s'\" % ('s' if len(dbs) > 1 else '', ', '.join((unsafeSQLIdentificatorNaming(unArrayizeValue(db)) for db in sorted(dbs))))\n    logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].tables\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        values = []\n        for (query, condition) in ((rootQuery.inband.query, getattr(rootQuery.inband, 'condition', None)), (getattr(rootQuery.inband, 'query2', None), getattr(rootQuery.inband, 'condition2', None))):\n            if not isNoneValue(values) or not query:\n                break\n            if condition:\n                if not Backend.isDbms(DBMS.SQLITE):\n                    query += ' WHERE %s' % condition\n                    if conf.excludeSysDbs:\n                        infoMsg = \"skipping system database%s '%s'\" % ('s' if len(self.excludeDbsList) > 1 else '', ', '.join((unsafeSQLIdentificatorNaming(db) for db in self.excludeDbsList)))\n                        logger.info(infoMsg)\n                        query += ' IN (%s)' % ','.join((\"'%s'\" % unsafeSQLIdentificatorNaming(db) for db in sorted(dbs) if db not in self.excludeDbsList))\n                    else:\n                        query += ' IN (%s)' % ','.join((\"'%s'\" % unsafeSQLIdentificatorNaming(db) for db in sorted(dbs)))\n                if len(dbs) < 2 and '%s,' % condition in query:\n                    query = query.replace('%s,' % condition, '', 1)\n            if query:\n                values = inject.getValue(query, blind=False, time=False)\n        if not isNoneValue(values):\n            values = [_ for _ in arrayizeValue(values) if _]\n            if len(values) > 0 and (not isListLike(values[0])):\n                values = [(dbs[0], _) for _ in values]\n            for (db, table) in filterPairValues(values):\n                table = unArrayizeValue(table)\n                if not isNoneValue(table):\n                    db = safeSQLIdentificatorNaming(db)\n                    table = safeSQLIdentificatorNaming(table, True)\n                    if conf.getComments:\n                        _ = queries[Backend.getIdentifiedDbms()].table_comment\n                        if hasattr(_, 'query'):\n                            if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                                query = _.query % (unsafeSQLIdentificatorNaming(db.upper()), unsafeSQLIdentificatorNaming(table.upper()))\n                            else:\n                                query = _.query % (unsafeSQLIdentificatorNaming(db), unsafeSQLIdentificatorNaming(table))\n                            comment = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                            if not isNoneValue(comment):\n                                infoMsg = \"retrieved comment '%s' for table '%s'\" % (comment, unsafeSQLIdentificatorNaming(table))\n                                if METADB_SUFFIX not in db:\n                                    infoMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                                logger.info(infoMsg)\n                        else:\n                            warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                            warnMsg += 'possible to get table comments'\n                            singleTimeWarnMessage(warnMsg)\n                    if db not in kb.data.cachedTables:\n                        kb.data.cachedTables[db] = [table]\n                    else:\n                        kb.data.cachedTables[db].append(table)\n    if not kb.data.cachedTables and isInferenceAvailable() and (not conf.direct):\n        for db in dbs:\n            if conf.excludeSysDbs and db in self.excludeDbsList:\n                infoMsg = \"skipping system database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                logger.info(infoMsg)\n                continue\n            if conf.exclude and re.search(conf.exclude, db, re.I) is not None:\n                infoMsg = \"skipping database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                singleTimeLogMessage(infoMsg)\n                continue\n            for (_query, _count) in ((rootQuery.blind.query, rootQuery.blind.count), (getattr(rootQuery.blind, 'query2', None), getattr(rootQuery.blind, 'count2', None))):\n                if _query is None:\n                    break\n                infoMsg = 'fetching number of tables for '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                logger.info(infoMsg)\n                if Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.FIREBIRD, DBMS.MAXDB, DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB):\n                    query = _count % unsafeSQLIdentificatorNaming(db)\n                else:\n                    query = _count\n                count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n                if count == 0:\n                    warnMsg = \"database '%s' \" % unsafeSQLIdentificatorNaming(db)\n                    warnMsg += 'appears to be empty'\n                    logger.warning(warnMsg)\n                    break\n                elif not isNumPosStrValue(count):\n                    warnMsg = 'unable to retrieve the number of '\n                    warnMsg += \"tables for database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                    singleTimeWarnMessage(warnMsg)\n                    continue\n                tables = []\n                plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n                indexRange = getLimitRange(count, plusOne=plusOne)\n                for index in indexRange:\n                    if Backend.isDbms(DBMS.SYBASE):\n                        query = _query % (db, kb.data.cachedTables[-1] if kb.data.cachedTables else ' ')\n                    elif Backend.getIdentifiedDbms() in (DBMS.MAXDB, DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB):\n                        query = _query % (kb.data.cachedTables[-1] if kb.data.cachedTables else ' ')\n                    elif Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.FIREBIRD):\n                        query = _query % index\n                    elif Backend.getIdentifiedDbms() in (DBMS.HSQLDB, DBMS.INFORMIX, DBMS.FRONTBASE, DBMS.VIRTUOSO):\n                        query = _query % (index, unsafeSQLIdentificatorNaming(db))\n                    else:\n                        query = _query % (unsafeSQLIdentificatorNaming(db), index)\n                    table = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                    if not isNoneValue(table):\n                        kb.hintValue = table\n                        table = safeSQLIdentificatorNaming(table, True)\n                        tables.append(table)\n                if tables:\n                    kb.data.cachedTables[db] = tables\n                    if conf.getComments:\n                        for table in tables:\n                            _ = queries[Backend.getIdentifiedDbms()].table_comment\n                            if hasattr(_, 'query'):\n                                if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                                    query = _.query % (unsafeSQLIdentificatorNaming(db.upper()), unsafeSQLIdentificatorNaming(table.upper()))\n                                else:\n                                    query = _.query % (unsafeSQLIdentificatorNaming(db), unsafeSQLIdentificatorNaming(table))\n                                comment = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                                if not isNoneValue(comment):\n                                    infoMsg = \"retrieved comment '%s' for table '%s'\" % (comment, unsafeSQLIdentificatorNaming(table))\n                                    if METADB_SUFFIX not in db:\n                                        infoMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                                    logger.info(infoMsg)\n                            else:\n                                warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                                warnMsg += 'possible to get table comments'\n                                singleTimeWarnMessage(warnMsg)\n                    break\n                else:\n                    warnMsg = 'unable to retrieve the table names '\n                    warnMsg += \"for database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                    logger.warning(warnMsg)\n    if isNoneValue(kb.data.cachedTables):\n        kb.data.cachedTables.clear()\n    if not kb.data.cachedTables:\n        errMsg = 'unable to retrieve the table names for any database'\n        if bruteForce is None:\n            logger.error(errMsg)\n            return self.getTables(bruteForce=True)\n        elif not conf.search:\n            raise SqlmapNoneDataException(errMsg)\n    else:\n        for (db, tables) in kb.data.cachedTables.items():\n            kb.data.cachedTables[db] = sorted(tables) if tables else tables\n    if kb.data.cachedTables:\n        for db in kb.data.cachedTables:\n            kb.data.cachedTables[db] = list(set(kb.data.cachedTables[db]))\n    return kb.data.cachedTables",
        "mutated": [
            "def getTables(self, bruteForce=None):\n    if False:\n        i = 10\n    if len(kb.data.cachedTables) > 0:\n        return kb.data.cachedTables\n    self.forceDbmsEnum()\n    if bruteForce is None:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            warnMsg = 'information_schema not available, '\n            warnMsg += 'back-end DBMS is MySQL < 5.0'\n            logger.warning(warnMsg)\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.MCKOI, DBMS.EXTREMEDB, DBMS.RAIMA):\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.ACCESS,):\n            try:\n                tables = self.getTables(False)\n            except SqlmapNoneDataException:\n                tables = None\n            if not tables:\n                warnMsg = 'cannot retrieve table names, '\n                warnMsg += 'back-end DBMS is %s' % Backend.getIdentifiedDbms()\n                logger.warning(warnMsg)\n                bruteForce = True\n            else:\n                return tables\n    if conf.db == CURRENT_DB:\n        conf.db = self.getCurrentDb()\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    if conf.db:\n        dbs = conf.db.split(',')\n    else:\n        dbs = self.getDbs()\n    dbs = [_ for _ in dbs if _ and _.strip()]\n    for db in dbs:\n        dbs[dbs.index(db)] = safeSQLIdentificatorNaming(db)\n    if bruteForce:\n        resumeAvailable = False\n        for (db, table) in kb.brute.tables:\n            if db == conf.db:\n                resumeAvailable = True\n                break\n        if resumeAvailable and (not conf.freshQueries):\n            for (db, table) in kb.brute.tables:\n                if db == conf.db:\n                    if conf.db not in kb.data.cachedTables:\n                        kb.data.cachedTables[conf.db] = [table]\n                    else:\n                        kb.data.cachedTables[conf.db].append(table)\n            return kb.data.cachedTables\n        message = 'do you want to use common table existence check? %s ' % ('[Y/n/q]' if Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB) else '[y/N/q]')\n        choice = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n        if choice == 'N':\n            return\n        elif choice == 'Q':\n            raise SqlmapUserQuitException\n        else:\n            return tableExists(paths.COMMON_TABLES)\n    infoMsg = 'fetching tables for database'\n    infoMsg += \"%s: '%s'\" % ('s' if len(dbs) > 1 else '', ', '.join((unsafeSQLIdentificatorNaming(unArrayizeValue(db)) for db in sorted(dbs))))\n    logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].tables\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        values = []\n        for (query, condition) in ((rootQuery.inband.query, getattr(rootQuery.inband, 'condition', None)), (getattr(rootQuery.inband, 'query2', None), getattr(rootQuery.inband, 'condition2', None))):\n            if not isNoneValue(values) or not query:\n                break\n            if condition:\n                if not Backend.isDbms(DBMS.SQLITE):\n                    query += ' WHERE %s' % condition\n                    if conf.excludeSysDbs:\n                        infoMsg = \"skipping system database%s '%s'\" % ('s' if len(self.excludeDbsList) > 1 else '', ', '.join((unsafeSQLIdentificatorNaming(db) for db in self.excludeDbsList)))\n                        logger.info(infoMsg)\n                        query += ' IN (%s)' % ','.join((\"'%s'\" % unsafeSQLIdentificatorNaming(db) for db in sorted(dbs) if db not in self.excludeDbsList))\n                    else:\n                        query += ' IN (%s)' % ','.join((\"'%s'\" % unsafeSQLIdentificatorNaming(db) for db in sorted(dbs)))\n                if len(dbs) < 2 and '%s,' % condition in query:\n                    query = query.replace('%s,' % condition, '', 1)\n            if query:\n                values = inject.getValue(query, blind=False, time=False)\n        if not isNoneValue(values):\n            values = [_ for _ in arrayizeValue(values) if _]\n            if len(values) > 0 and (not isListLike(values[0])):\n                values = [(dbs[0], _) for _ in values]\n            for (db, table) in filterPairValues(values):\n                table = unArrayizeValue(table)\n                if not isNoneValue(table):\n                    db = safeSQLIdentificatorNaming(db)\n                    table = safeSQLIdentificatorNaming(table, True)\n                    if conf.getComments:\n                        _ = queries[Backend.getIdentifiedDbms()].table_comment\n                        if hasattr(_, 'query'):\n                            if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                                query = _.query % (unsafeSQLIdentificatorNaming(db.upper()), unsafeSQLIdentificatorNaming(table.upper()))\n                            else:\n                                query = _.query % (unsafeSQLIdentificatorNaming(db), unsafeSQLIdentificatorNaming(table))\n                            comment = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                            if not isNoneValue(comment):\n                                infoMsg = \"retrieved comment '%s' for table '%s'\" % (comment, unsafeSQLIdentificatorNaming(table))\n                                if METADB_SUFFIX not in db:\n                                    infoMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                                logger.info(infoMsg)\n                        else:\n                            warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                            warnMsg += 'possible to get table comments'\n                            singleTimeWarnMessage(warnMsg)\n                    if db not in kb.data.cachedTables:\n                        kb.data.cachedTables[db] = [table]\n                    else:\n                        kb.data.cachedTables[db].append(table)\n    if not kb.data.cachedTables and isInferenceAvailable() and (not conf.direct):\n        for db in dbs:\n            if conf.excludeSysDbs and db in self.excludeDbsList:\n                infoMsg = \"skipping system database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                logger.info(infoMsg)\n                continue\n            if conf.exclude and re.search(conf.exclude, db, re.I) is not None:\n                infoMsg = \"skipping database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                singleTimeLogMessage(infoMsg)\n                continue\n            for (_query, _count) in ((rootQuery.blind.query, rootQuery.blind.count), (getattr(rootQuery.blind, 'query2', None), getattr(rootQuery.blind, 'count2', None))):\n                if _query is None:\n                    break\n                infoMsg = 'fetching number of tables for '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                logger.info(infoMsg)\n                if Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.FIREBIRD, DBMS.MAXDB, DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB):\n                    query = _count % unsafeSQLIdentificatorNaming(db)\n                else:\n                    query = _count\n                count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n                if count == 0:\n                    warnMsg = \"database '%s' \" % unsafeSQLIdentificatorNaming(db)\n                    warnMsg += 'appears to be empty'\n                    logger.warning(warnMsg)\n                    break\n                elif not isNumPosStrValue(count):\n                    warnMsg = 'unable to retrieve the number of '\n                    warnMsg += \"tables for database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                    singleTimeWarnMessage(warnMsg)\n                    continue\n                tables = []\n                plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n                indexRange = getLimitRange(count, plusOne=plusOne)\n                for index in indexRange:\n                    if Backend.isDbms(DBMS.SYBASE):\n                        query = _query % (db, kb.data.cachedTables[-1] if kb.data.cachedTables else ' ')\n                    elif Backend.getIdentifiedDbms() in (DBMS.MAXDB, DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB):\n                        query = _query % (kb.data.cachedTables[-1] if kb.data.cachedTables else ' ')\n                    elif Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.FIREBIRD):\n                        query = _query % index\n                    elif Backend.getIdentifiedDbms() in (DBMS.HSQLDB, DBMS.INFORMIX, DBMS.FRONTBASE, DBMS.VIRTUOSO):\n                        query = _query % (index, unsafeSQLIdentificatorNaming(db))\n                    else:\n                        query = _query % (unsafeSQLIdentificatorNaming(db), index)\n                    table = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                    if not isNoneValue(table):\n                        kb.hintValue = table\n                        table = safeSQLIdentificatorNaming(table, True)\n                        tables.append(table)\n                if tables:\n                    kb.data.cachedTables[db] = tables\n                    if conf.getComments:\n                        for table in tables:\n                            _ = queries[Backend.getIdentifiedDbms()].table_comment\n                            if hasattr(_, 'query'):\n                                if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                                    query = _.query % (unsafeSQLIdentificatorNaming(db.upper()), unsafeSQLIdentificatorNaming(table.upper()))\n                                else:\n                                    query = _.query % (unsafeSQLIdentificatorNaming(db), unsafeSQLIdentificatorNaming(table))\n                                comment = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                                if not isNoneValue(comment):\n                                    infoMsg = \"retrieved comment '%s' for table '%s'\" % (comment, unsafeSQLIdentificatorNaming(table))\n                                    if METADB_SUFFIX not in db:\n                                        infoMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                                    logger.info(infoMsg)\n                            else:\n                                warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                                warnMsg += 'possible to get table comments'\n                                singleTimeWarnMessage(warnMsg)\n                    break\n                else:\n                    warnMsg = 'unable to retrieve the table names '\n                    warnMsg += \"for database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                    logger.warning(warnMsg)\n    if isNoneValue(kb.data.cachedTables):\n        kb.data.cachedTables.clear()\n    if not kb.data.cachedTables:\n        errMsg = 'unable to retrieve the table names for any database'\n        if bruteForce is None:\n            logger.error(errMsg)\n            return self.getTables(bruteForce=True)\n        elif not conf.search:\n            raise SqlmapNoneDataException(errMsg)\n    else:\n        for (db, tables) in kb.data.cachedTables.items():\n            kb.data.cachedTables[db] = sorted(tables) if tables else tables\n    if kb.data.cachedTables:\n        for db in kb.data.cachedTables:\n            kb.data.cachedTables[db] = list(set(kb.data.cachedTables[db]))\n    return kb.data.cachedTables",
            "def getTables(self, bruteForce=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if len(kb.data.cachedTables) > 0:\n        return kb.data.cachedTables\n    self.forceDbmsEnum()\n    if bruteForce is None:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            warnMsg = 'information_schema not available, '\n            warnMsg += 'back-end DBMS is MySQL < 5.0'\n            logger.warning(warnMsg)\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.MCKOI, DBMS.EXTREMEDB, DBMS.RAIMA):\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.ACCESS,):\n            try:\n                tables = self.getTables(False)\n            except SqlmapNoneDataException:\n                tables = None\n            if not tables:\n                warnMsg = 'cannot retrieve table names, '\n                warnMsg += 'back-end DBMS is %s' % Backend.getIdentifiedDbms()\n                logger.warning(warnMsg)\n                bruteForce = True\n            else:\n                return tables\n    if conf.db == CURRENT_DB:\n        conf.db = self.getCurrentDb()\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    if conf.db:\n        dbs = conf.db.split(',')\n    else:\n        dbs = self.getDbs()\n    dbs = [_ for _ in dbs if _ and _.strip()]\n    for db in dbs:\n        dbs[dbs.index(db)] = safeSQLIdentificatorNaming(db)\n    if bruteForce:\n        resumeAvailable = False\n        for (db, table) in kb.brute.tables:\n            if db == conf.db:\n                resumeAvailable = True\n                break\n        if resumeAvailable and (not conf.freshQueries):\n            for (db, table) in kb.brute.tables:\n                if db == conf.db:\n                    if conf.db not in kb.data.cachedTables:\n                        kb.data.cachedTables[conf.db] = [table]\n                    else:\n                        kb.data.cachedTables[conf.db].append(table)\n            return kb.data.cachedTables\n        message = 'do you want to use common table existence check? %s ' % ('[Y/n/q]' if Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB) else '[y/N/q]')\n        choice = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n        if choice == 'N':\n            return\n        elif choice == 'Q':\n            raise SqlmapUserQuitException\n        else:\n            return tableExists(paths.COMMON_TABLES)\n    infoMsg = 'fetching tables for database'\n    infoMsg += \"%s: '%s'\" % ('s' if len(dbs) > 1 else '', ', '.join((unsafeSQLIdentificatorNaming(unArrayizeValue(db)) for db in sorted(dbs))))\n    logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].tables\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        values = []\n        for (query, condition) in ((rootQuery.inband.query, getattr(rootQuery.inband, 'condition', None)), (getattr(rootQuery.inband, 'query2', None), getattr(rootQuery.inband, 'condition2', None))):\n            if not isNoneValue(values) or not query:\n                break\n            if condition:\n                if not Backend.isDbms(DBMS.SQLITE):\n                    query += ' WHERE %s' % condition\n                    if conf.excludeSysDbs:\n                        infoMsg = \"skipping system database%s '%s'\" % ('s' if len(self.excludeDbsList) > 1 else '', ', '.join((unsafeSQLIdentificatorNaming(db) for db in self.excludeDbsList)))\n                        logger.info(infoMsg)\n                        query += ' IN (%s)' % ','.join((\"'%s'\" % unsafeSQLIdentificatorNaming(db) for db in sorted(dbs) if db not in self.excludeDbsList))\n                    else:\n                        query += ' IN (%s)' % ','.join((\"'%s'\" % unsafeSQLIdentificatorNaming(db) for db in sorted(dbs)))\n                if len(dbs) < 2 and '%s,' % condition in query:\n                    query = query.replace('%s,' % condition, '', 1)\n            if query:\n                values = inject.getValue(query, blind=False, time=False)\n        if not isNoneValue(values):\n            values = [_ for _ in arrayizeValue(values) if _]\n            if len(values) > 0 and (not isListLike(values[0])):\n                values = [(dbs[0], _) for _ in values]\n            for (db, table) in filterPairValues(values):\n                table = unArrayizeValue(table)\n                if not isNoneValue(table):\n                    db = safeSQLIdentificatorNaming(db)\n                    table = safeSQLIdentificatorNaming(table, True)\n                    if conf.getComments:\n                        _ = queries[Backend.getIdentifiedDbms()].table_comment\n                        if hasattr(_, 'query'):\n                            if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                                query = _.query % (unsafeSQLIdentificatorNaming(db.upper()), unsafeSQLIdentificatorNaming(table.upper()))\n                            else:\n                                query = _.query % (unsafeSQLIdentificatorNaming(db), unsafeSQLIdentificatorNaming(table))\n                            comment = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                            if not isNoneValue(comment):\n                                infoMsg = \"retrieved comment '%s' for table '%s'\" % (comment, unsafeSQLIdentificatorNaming(table))\n                                if METADB_SUFFIX not in db:\n                                    infoMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                                logger.info(infoMsg)\n                        else:\n                            warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                            warnMsg += 'possible to get table comments'\n                            singleTimeWarnMessage(warnMsg)\n                    if db not in kb.data.cachedTables:\n                        kb.data.cachedTables[db] = [table]\n                    else:\n                        kb.data.cachedTables[db].append(table)\n    if not kb.data.cachedTables and isInferenceAvailable() and (not conf.direct):\n        for db in dbs:\n            if conf.excludeSysDbs and db in self.excludeDbsList:\n                infoMsg = \"skipping system database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                logger.info(infoMsg)\n                continue\n            if conf.exclude and re.search(conf.exclude, db, re.I) is not None:\n                infoMsg = \"skipping database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                singleTimeLogMessage(infoMsg)\n                continue\n            for (_query, _count) in ((rootQuery.blind.query, rootQuery.blind.count), (getattr(rootQuery.blind, 'query2', None), getattr(rootQuery.blind, 'count2', None))):\n                if _query is None:\n                    break\n                infoMsg = 'fetching number of tables for '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                logger.info(infoMsg)\n                if Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.FIREBIRD, DBMS.MAXDB, DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB):\n                    query = _count % unsafeSQLIdentificatorNaming(db)\n                else:\n                    query = _count\n                count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n                if count == 0:\n                    warnMsg = \"database '%s' \" % unsafeSQLIdentificatorNaming(db)\n                    warnMsg += 'appears to be empty'\n                    logger.warning(warnMsg)\n                    break\n                elif not isNumPosStrValue(count):\n                    warnMsg = 'unable to retrieve the number of '\n                    warnMsg += \"tables for database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                    singleTimeWarnMessage(warnMsg)\n                    continue\n                tables = []\n                plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n                indexRange = getLimitRange(count, plusOne=plusOne)\n                for index in indexRange:\n                    if Backend.isDbms(DBMS.SYBASE):\n                        query = _query % (db, kb.data.cachedTables[-1] if kb.data.cachedTables else ' ')\n                    elif Backend.getIdentifiedDbms() in (DBMS.MAXDB, DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB):\n                        query = _query % (kb.data.cachedTables[-1] if kb.data.cachedTables else ' ')\n                    elif Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.FIREBIRD):\n                        query = _query % index\n                    elif Backend.getIdentifiedDbms() in (DBMS.HSQLDB, DBMS.INFORMIX, DBMS.FRONTBASE, DBMS.VIRTUOSO):\n                        query = _query % (index, unsafeSQLIdentificatorNaming(db))\n                    else:\n                        query = _query % (unsafeSQLIdentificatorNaming(db), index)\n                    table = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                    if not isNoneValue(table):\n                        kb.hintValue = table\n                        table = safeSQLIdentificatorNaming(table, True)\n                        tables.append(table)\n                if tables:\n                    kb.data.cachedTables[db] = tables\n                    if conf.getComments:\n                        for table in tables:\n                            _ = queries[Backend.getIdentifiedDbms()].table_comment\n                            if hasattr(_, 'query'):\n                                if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                                    query = _.query % (unsafeSQLIdentificatorNaming(db.upper()), unsafeSQLIdentificatorNaming(table.upper()))\n                                else:\n                                    query = _.query % (unsafeSQLIdentificatorNaming(db), unsafeSQLIdentificatorNaming(table))\n                                comment = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                                if not isNoneValue(comment):\n                                    infoMsg = \"retrieved comment '%s' for table '%s'\" % (comment, unsafeSQLIdentificatorNaming(table))\n                                    if METADB_SUFFIX not in db:\n                                        infoMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                                    logger.info(infoMsg)\n                            else:\n                                warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                                warnMsg += 'possible to get table comments'\n                                singleTimeWarnMessage(warnMsg)\n                    break\n                else:\n                    warnMsg = 'unable to retrieve the table names '\n                    warnMsg += \"for database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                    logger.warning(warnMsg)\n    if isNoneValue(kb.data.cachedTables):\n        kb.data.cachedTables.clear()\n    if not kb.data.cachedTables:\n        errMsg = 'unable to retrieve the table names for any database'\n        if bruteForce is None:\n            logger.error(errMsg)\n            return self.getTables(bruteForce=True)\n        elif not conf.search:\n            raise SqlmapNoneDataException(errMsg)\n    else:\n        for (db, tables) in kb.data.cachedTables.items():\n            kb.data.cachedTables[db] = sorted(tables) if tables else tables\n    if kb.data.cachedTables:\n        for db in kb.data.cachedTables:\n            kb.data.cachedTables[db] = list(set(kb.data.cachedTables[db]))\n    return kb.data.cachedTables",
            "def getTables(self, bruteForce=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if len(kb.data.cachedTables) > 0:\n        return kb.data.cachedTables\n    self.forceDbmsEnum()\n    if bruteForce is None:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            warnMsg = 'information_schema not available, '\n            warnMsg += 'back-end DBMS is MySQL < 5.0'\n            logger.warning(warnMsg)\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.MCKOI, DBMS.EXTREMEDB, DBMS.RAIMA):\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.ACCESS,):\n            try:\n                tables = self.getTables(False)\n            except SqlmapNoneDataException:\n                tables = None\n            if not tables:\n                warnMsg = 'cannot retrieve table names, '\n                warnMsg += 'back-end DBMS is %s' % Backend.getIdentifiedDbms()\n                logger.warning(warnMsg)\n                bruteForce = True\n            else:\n                return tables\n    if conf.db == CURRENT_DB:\n        conf.db = self.getCurrentDb()\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    if conf.db:\n        dbs = conf.db.split(',')\n    else:\n        dbs = self.getDbs()\n    dbs = [_ for _ in dbs if _ and _.strip()]\n    for db in dbs:\n        dbs[dbs.index(db)] = safeSQLIdentificatorNaming(db)\n    if bruteForce:\n        resumeAvailable = False\n        for (db, table) in kb.brute.tables:\n            if db == conf.db:\n                resumeAvailable = True\n                break\n        if resumeAvailable and (not conf.freshQueries):\n            for (db, table) in kb.brute.tables:\n                if db == conf.db:\n                    if conf.db not in kb.data.cachedTables:\n                        kb.data.cachedTables[conf.db] = [table]\n                    else:\n                        kb.data.cachedTables[conf.db].append(table)\n            return kb.data.cachedTables\n        message = 'do you want to use common table existence check? %s ' % ('[Y/n/q]' if Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB) else '[y/N/q]')\n        choice = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n        if choice == 'N':\n            return\n        elif choice == 'Q':\n            raise SqlmapUserQuitException\n        else:\n            return tableExists(paths.COMMON_TABLES)\n    infoMsg = 'fetching tables for database'\n    infoMsg += \"%s: '%s'\" % ('s' if len(dbs) > 1 else '', ', '.join((unsafeSQLIdentificatorNaming(unArrayizeValue(db)) for db in sorted(dbs))))\n    logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].tables\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        values = []\n        for (query, condition) in ((rootQuery.inband.query, getattr(rootQuery.inband, 'condition', None)), (getattr(rootQuery.inband, 'query2', None), getattr(rootQuery.inband, 'condition2', None))):\n            if not isNoneValue(values) or not query:\n                break\n            if condition:\n                if not Backend.isDbms(DBMS.SQLITE):\n                    query += ' WHERE %s' % condition\n                    if conf.excludeSysDbs:\n                        infoMsg = \"skipping system database%s '%s'\" % ('s' if len(self.excludeDbsList) > 1 else '', ', '.join((unsafeSQLIdentificatorNaming(db) for db in self.excludeDbsList)))\n                        logger.info(infoMsg)\n                        query += ' IN (%s)' % ','.join((\"'%s'\" % unsafeSQLIdentificatorNaming(db) for db in sorted(dbs) if db not in self.excludeDbsList))\n                    else:\n                        query += ' IN (%s)' % ','.join((\"'%s'\" % unsafeSQLIdentificatorNaming(db) for db in sorted(dbs)))\n                if len(dbs) < 2 and '%s,' % condition in query:\n                    query = query.replace('%s,' % condition, '', 1)\n            if query:\n                values = inject.getValue(query, blind=False, time=False)\n        if not isNoneValue(values):\n            values = [_ for _ in arrayizeValue(values) if _]\n            if len(values) > 0 and (not isListLike(values[0])):\n                values = [(dbs[0], _) for _ in values]\n            for (db, table) in filterPairValues(values):\n                table = unArrayizeValue(table)\n                if not isNoneValue(table):\n                    db = safeSQLIdentificatorNaming(db)\n                    table = safeSQLIdentificatorNaming(table, True)\n                    if conf.getComments:\n                        _ = queries[Backend.getIdentifiedDbms()].table_comment\n                        if hasattr(_, 'query'):\n                            if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                                query = _.query % (unsafeSQLIdentificatorNaming(db.upper()), unsafeSQLIdentificatorNaming(table.upper()))\n                            else:\n                                query = _.query % (unsafeSQLIdentificatorNaming(db), unsafeSQLIdentificatorNaming(table))\n                            comment = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                            if not isNoneValue(comment):\n                                infoMsg = \"retrieved comment '%s' for table '%s'\" % (comment, unsafeSQLIdentificatorNaming(table))\n                                if METADB_SUFFIX not in db:\n                                    infoMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                                logger.info(infoMsg)\n                        else:\n                            warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                            warnMsg += 'possible to get table comments'\n                            singleTimeWarnMessage(warnMsg)\n                    if db not in kb.data.cachedTables:\n                        kb.data.cachedTables[db] = [table]\n                    else:\n                        kb.data.cachedTables[db].append(table)\n    if not kb.data.cachedTables and isInferenceAvailable() and (not conf.direct):\n        for db in dbs:\n            if conf.excludeSysDbs and db in self.excludeDbsList:\n                infoMsg = \"skipping system database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                logger.info(infoMsg)\n                continue\n            if conf.exclude and re.search(conf.exclude, db, re.I) is not None:\n                infoMsg = \"skipping database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                singleTimeLogMessage(infoMsg)\n                continue\n            for (_query, _count) in ((rootQuery.blind.query, rootQuery.blind.count), (getattr(rootQuery.blind, 'query2', None), getattr(rootQuery.blind, 'count2', None))):\n                if _query is None:\n                    break\n                infoMsg = 'fetching number of tables for '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                logger.info(infoMsg)\n                if Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.FIREBIRD, DBMS.MAXDB, DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB):\n                    query = _count % unsafeSQLIdentificatorNaming(db)\n                else:\n                    query = _count\n                count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n                if count == 0:\n                    warnMsg = \"database '%s' \" % unsafeSQLIdentificatorNaming(db)\n                    warnMsg += 'appears to be empty'\n                    logger.warning(warnMsg)\n                    break\n                elif not isNumPosStrValue(count):\n                    warnMsg = 'unable to retrieve the number of '\n                    warnMsg += \"tables for database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                    singleTimeWarnMessage(warnMsg)\n                    continue\n                tables = []\n                plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n                indexRange = getLimitRange(count, plusOne=plusOne)\n                for index in indexRange:\n                    if Backend.isDbms(DBMS.SYBASE):\n                        query = _query % (db, kb.data.cachedTables[-1] if kb.data.cachedTables else ' ')\n                    elif Backend.getIdentifiedDbms() in (DBMS.MAXDB, DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB):\n                        query = _query % (kb.data.cachedTables[-1] if kb.data.cachedTables else ' ')\n                    elif Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.FIREBIRD):\n                        query = _query % index\n                    elif Backend.getIdentifiedDbms() in (DBMS.HSQLDB, DBMS.INFORMIX, DBMS.FRONTBASE, DBMS.VIRTUOSO):\n                        query = _query % (index, unsafeSQLIdentificatorNaming(db))\n                    else:\n                        query = _query % (unsafeSQLIdentificatorNaming(db), index)\n                    table = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                    if not isNoneValue(table):\n                        kb.hintValue = table\n                        table = safeSQLIdentificatorNaming(table, True)\n                        tables.append(table)\n                if tables:\n                    kb.data.cachedTables[db] = tables\n                    if conf.getComments:\n                        for table in tables:\n                            _ = queries[Backend.getIdentifiedDbms()].table_comment\n                            if hasattr(_, 'query'):\n                                if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                                    query = _.query % (unsafeSQLIdentificatorNaming(db.upper()), unsafeSQLIdentificatorNaming(table.upper()))\n                                else:\n                                    query = _.query % (unsafeSQLIdentificatorNaming(db), unsafeSQLIdentificatorNaming(table))\n                                comment = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                                if not isNoneValue(comment):\n                                    infoMsg = \"retrieved comment '%s' for table '%s'\" % (comment, unsafeSQLIdentificatorNaming(table))\n                                    if METADB_SUFFIX not in db:\n                                        infoMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                                    logger.info(infoMsg)\n                            else:\n                                warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                                warnMsg += 'possible to get table comments'\n                                singleTimeWarnMessage(warnMsg)\n                    break\n                else:\n                    warnMsg = 'unable to retrieve the table names '\n                    warnMsg += \"for database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                    logger.warning(warnMsg)\n    if isNoneValue(kb.data.cachedTables):\n        kb.data.cachedTables.clear()\n    if not kb.data.cachedTables:\n        errMsg = 'unable to retrieve the table names for any database'\n        if bruteForce is None:\n            logger.error(errMsg)\n            return self.getTables(bruteForce=True)\n        elif not conf.search:\n            raise SqlmapNoneDataException(errMsg)\n    else:\n        for (db, tables) in kb.data.cachedTables.items():\n            kb.data.cachedTables[db] = sorted(tables) if tables else tables\n    if kb.data.cachedTables:\n        for db in kb.data.cachedTables:\n            kb.data.cachedTables[db] = list(set(kb.data.cachedTables[db]))\n    return kb.data.cachedTables",
            "def getTables(self, bruteForce=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if len(kb.data.cachedTables) > 0:\n        return kb.data.cachedTables\n    self.forceDbmsEnum()\n    if bruteForce is None:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            warnMsg = 'information_schema not available, '\n            warnMsg += 'back-end DBMS is MySQL < 5.0'\n            logger.warning(warnMsg)\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.MCKOI, DBMS.EXTREMEDB, DBMS.RAIMA):\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.ACCESS,):\n            try:\n                tables = self.getTables(False)\n            except SqlmapNoneDataException:\n                tables = None\n            if not tables:\n                warnMsg = 'cannot retrieve table names, '\n                warnMsg += 'back-end DBMS is %s' % Backend.getIdentifiedDbms()\n                logger.warning(warnMsg)\n                bruteForce = True\n            else:\n                return tables\n    if conf.db == CURRENT_DB:\n        conf.db = self.getCurrentDb()\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    if conf.db:\n        dbs = conf.db.split(',')\n    else:\n        dbs = self.getDbs()\n    dbs = [_ for _ in dbs if _ and _.strip()]\n    for db in dbs:\n        dbs[dbs.index(db)] = safeSQLIdentificatorNaming(db)\n    if bruteForce:\n        resumeAvailable = False\n        for (db, table) in kb.brute.tables:\n            if db == conf.db:\n                resumeAvailable = True\n                break\n        if resumeAvailable and (not conf.freshQueries):\n            for (db, table) in kb.brute.tables:\n                if db == conf.db:\n                    if conf.db not in kb.data.cachedTables:\n                        kb.data.cachedTables[conf.db] = [table]\n                    else:\n                        kb.data.cachedTables[conf.db].append(table)\n            return kb.data.cachedTables\n        message = 'do you want to use common table existence check? %s ' % ('[Y/n/q]' if Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB) else '[y/N/q]')\n        choice = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n        if choice == 'N':\n            return\n        elif choice == 'Q':\n            raise SqlmapUserQuitException\n        else:\n            return tableExists(paths.COMMON_TABLES)\n    infoMsg = 'fetching tables for database'\n    infoMsg += \"%s: '%s'\" % ('s' if len(dbs) > 1 else '', ', '.join((unsafeSQLIdentificatorNaming(unArrayizeValue(db)) for db in sorted(dbs))))\n    logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].tables\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        values = []\n        for (query, condition) in ((rootQuery.inband.query, getattr(rootQuery.inband, 'condition', None)), (getattr(rootQuery.inband, 'query2', None), getattr(rootQuery.inband, 'condition2', None))):\n            if not isNoneValue(values) or not query:\n                break\n            if condition:\n                if not Backend.isDbms(DBMS.SQLITE):\n                    query += ' WHERE %s' % condition\n                    if conf.excludeSysDbs:\n                        infoMsg = \"skipping system database%s '%s'\" % ('s' if len(self.excludeDbsList) > 1 else '', ', '.join((unsafeSQLIdentificatorNaming(db) for db in self.excludeDbsList)))\n                        logger.info(infoMsg)\n                        query += ' IN (%s)' % ','.join((\"'%s'\" % unsafeSQLIdentificatorNaming(db) for db in sorted(dbs) if db not in self.excludeDbsList))\n                    else:\n                        query += ' IN (%s)' % ','.join((\"'%s'\" % unsafeSQLIdentificatorNaming(db) for db in sorted(dbs)))\n                if len(dbs) < 2 and '%s,' % condition in query:\n                    query = query.replace('%s,' % condition, '', 1)\n            if query:\n                values = inject.getValue(query, blind=False, time=False)\n        if not isNoneValue(values):\n            values = [_ for _ in arrayizeValue(values) if _]\n            if len(values) > 0 and (not isListLike(values[0])):\n                values = [(dbs[0], _) for _ in values]\n            for (db, table) in filterPairValues(values):\n                table = unArrayizeValue(table)\n                if not isNoneValue(table):\n                    db = safeSQLIdentificatorNaming(db)\n                    table = safeSQLIdentificatorNaming(table, True)\n                    if conf.getComments:\n                        _ = queries[Backend.getIdentifiedDbms()].table_comment\n                        if hasattr(_, 'query'):\n                            if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                                query = _.query % (unsafeSQLIdentificatorNaming(db.upper()), unsafeSQLIdentificatorNaming(table.upper()))\n                            else:\n                                query = _.query % (unsafeSQLIdentificatorNaming(db), unsafeSQLIdentificatorNaming(table))\n                            comment = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                            if not isNoneValue(comment):\n                                infoMsg = \"retrieved comment '%s' for table '%s'\" % (comment, unsafeSQLIdentificatorNaming(table))\n                                if METADB_SUFFIX not in db:\n                                    infoMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                                logger.info(infoMsg)\n                        else:\n                            warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                            warnMsg += 'possible to get table comments'\n                            singleTimeWarnMessage(warnMsg)\n                    if db not in kb.data.cachedTables:\n                        kb.data.cachedTables[db] = [table]\n                    else:\n                        kb.data.cachedTables[db].append(table)\n    if not kb.data.cachedTables and isInferenceAvailable() and (not conf.direct):\n        for db in dbs:\n            if conf.excludeSysDbs and db in self.excludeDbsList:\n                infoMsg = \"skipping system database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                logger.info(infoMsg)\n                continue\n            if conf.exclude and re.search(conf.exclude, db, re.I) is not None:\n                infoMsg = \"skipping database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                singleTimeLogMessage(infoMsg)\n                continue\n            for (_query, _count) in ((rootQuery.blind.query, rootQuery.blind.count), (getattr(rootQuery.blind, 'query2', None), getattr(rootQuery.blind, 'count2', None))):\n                if _query is None:\n                    break\n                infoMsg = 'fetching number of tables for '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                logger.info(infoMsg)\n                if Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.FIREBIRD, DBMS.MAXDB, DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB):\n                    query = _count % unsafeSQLIdentificatorNaming(db)\n                else:\n                    query = _count\n                count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n                if count == 0:\n                    warnMsg = \"database '%s' \" % unsafeSQLIdentificatorNaming(db)\n                    warnMsg += 'appears to be empty'\n                    logger.warning(warnMsg)\n                    break\n                elif not isNumPosStrValue(count):\n                    warnMsg = 'unable to retrieve the number of '\n                    warnMsg += \"tables for database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                    singleTimeWarnMessage(warnMsg)\n                    continue\n                tables = []\n                plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n                indexRange = getLimitRange(count, plusOne=plusOne)\n                for index in indexRange:\n                    if Backend.isDbms(DBMS.SYBASE):\n                        query = _query % (db, kb.data.cachedTables[-1] if kb.data.cachedTables else ' ')\n                    elif Backend.getIdentifiedDbms() in (DBMS.MAXDB, DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB):\n                        query = _query % (kb.data.cachedTables[-1] if kb.data.cachedTables else ' ')\n                    elif Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.FIREBIRD):\n                        query = _query % index\n                    elif Backend.getIdentifiedDbms() in (DBMS.HSQLDB, DBMS.INFORMIX, DBMS.FRONTBASE, DBMS.VIRTUOSO):\n                        query = _query % (index, unsafeSQLIdentificatorNaming(db))\n                    else:\n                        query = _query % (unsafeSQLIdentificatorNaming(db), index)\n                    table = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                    if not isNoneValue(table):\n                        kb.hintValue = table\n                        table = safeSQLIdentificatorNaming(table, True)\n                        tables.append(table)\n                if tables:\n                    kb.data.cachedTables[db] = tables\n                    if conf.getComments:\n                        for table in tables:\n                            _ = queries[Backend.getIdentifiedDbms()].table_comment\n                            if hasattr(_, 'query'):\n                                if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                                    query = _.query % (unsafeSQLIdentificatorNaming(db.upper()), unsafeSQLIdentificatorNaming(table.upper()))\n                                else:\n                                    query = _.query % (unsafeSQLIdentificatorNaming(db), unsafeSQLIdentificatorNaming(table))\n                                comment = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                                if not isNoneValue(comment):\n                                    infoMsg = \"retrieved comment '%s' for table '%s'\" % (comment, unsafeSQLIdentificatorNaming(table))\n                                    if METADB_SUFFIX not in db:\n                                        infoMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                                    logger.info(infoMsg)\n                            else:\n                                warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                                warnMsg += 'possible to get table comments'\n                                singleTimeWarnMessage(warnMsg)\n                    break\n                else:\n                    warnMsg = 'unable to retrieve the table names '\n                    warnMsg += \"for database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                    logger.warning(warnMsg)\n    if isNoneValue(kb.data.cachedTables):\n        kb.data.cachedTables.clear()\n    if not kb.data.cachedTables:\n        errMsg = 'unable to retrieve the table names for any database'\n        if bruteForce is None:\n            logger.error(errMsg)\n            return self.getTables(bruteForce=True)\n        elif not conf.search:\n            raise SqlmapNoneDataException(errMsg)\n    else:\n        for (db, tables) in kb.data.cachedTables.items():\n            kb.data.cachedTables[db] = sorted(tables) if tables else tables\n    if kb.data.cachedTables:\n        for db in kb.data.cachedTables:\n            kb.data.cachedTables[db] = list(set(kb.data.cachedTables[db]))\n    return kb.data.cachedTables",
            "def getTables(self, bruteForce=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if len(kb.data.cachedTables) > 0:\n        return kb.data.cachedTables\n    self.forceDbmsEnum()\n    if bruteForce is None:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            warnMsg = 'information_schema not available, '\n            warnMsg += 'back-end DBMS is MySQL < 5.0'\n            logger.warning(warnMsg)\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.MCKOI, DBMS.EXTREMEDB, DBMS.RAIMA):\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.ACCESS,):\n            try:\n                tables = self.getTables(False)\n            except SqlmapNoneDataException:\n                tables = None\n            if not tables:\n                warnMsg = 'cannot retrieve table names, '\n                warnMsg += 'back-end DBMS is %s' % Backend.getIdentifiedDbms()\n                logger.warning(warnMsg)\n                bruteForce = True\n            else:\n                return tables\n    if conf.db == CURRENT_DB:\n        conf.db = self.getCurrentDb()\n    if conf.db and Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        conf.db = conf.db.upper()\n    if conf.db:\n        dbs = conf.db.split(',')\n    else:\n        dbs = self.getDbs()\n    dbs = [_ for _ in dbs if _ and _.strip()]\n    for db in dbs:\n        dbs[dbs.index(db)] = safeSQLIdentificatorNaming(db)\n    if bruteForce:\n        resumeAvailable = False\n        for (db, table) in kb.brute.tables:\n            if db == conf.db:\n                resumeAvailable = True\n                break\n        if resumeAvailable and (not conf.freshQueries):\n            for (db, table) in kb.brute.tables:\n                if db == conf.db:\n                    if conf.db not in kb.data.cachedTables:\n                        kb.data.cachedTables[conf.db] = [table]\n                    else:\n                        kb.data.cachedTables[conf.db].append(table)\n            return kb.data.cachedTables\n        message = 'do you want to use common table existence check? %s ' % ('[Y/n/q]' if Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB) else '[y/N/q]')\n        choice = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n        if choice == 'N':\n            return\n        elif choice == 'Q':\n            raise SqlmapUserQuitException\n        else:\n            return tableExists(paths.COMMON_TABLES)\n    infoMsg = 'fetching tables for database'\n    infoMsg += \"%s: '%s'\" % ('s' if len(dbs) > 1 else '', ', '.join((unsafeSQLIdentificatorNaming(unArrayizeValue(db)) for db in sorted(dbs))))\n    logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].tables\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        values = []\n        for (query, condition) in ((rootQuery.inband.query, getattr(rootQuery.inband, 'condition', None)), (getattr(rootQuery.inband, 'query2', None), getattr(rootQuery.inband, 'condition2', None))):\n            if not isNoneValue(values) or not query:\n                break\n            if condition:\n                if not Backend.isDbms(DBMS.SQLITE):\n                    query += ' WHERE %s' % condition\n                    if conf.excludeSysDbs:\n                        infoMsg = \"skipping system database%s '%s'\" % ('s' if len(self.excludeDbsList) > 1 else '', ', '.join((unsafeSQLIdentificatorNaming(db) for db in self.excludeDbsList)))\n                        logger.info(infoMsg)\n                        query += ' IN (%s)' % ','.join((\"'%s'\" % unsafeSQLIdentificatorNaming(db) for db in sorted(dbs) if db not in self.excludeDbsList))\n                    else:\n                        query += ' IN (%s)' % ','.join((\"'%s'\" % unsafeSQLIdentificatorNaming(db) for db in sorted(dbs)))\n                if len(dbs) < 2 and '%s,' % condition in query:\n                    query = query.replace('%s,' % condition, '', 1)\n            if query:\n                values = inject.getValue(query, blind=False, time=False)\n        if not isNoneValue(values):\n            values = [_ for _ in arrayizeValue(values) if _]\n            if len(values) > 0 and (not isListLike(values[0])):\n                values = [(dbs[0], _) for _ in values]\n            for (db, table) in filterPairValues(values):\n                table = unArrayizeValue(table)\n                if not isNoneValue(table):\n                    db = safeSQLIdentificatorNaming(db)\n                    table = safeSQLIdentificatorNaming(table, True)\n                    if conf.getComments:\n                        _ = queries[Backend.getIdentifiedDbms()].table_comment\n                        if hasattr(_, 'query'):\n                            if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                                query = _.query % (unsafeSQLIdentificatorNaming(db.upper()), unsafeSQLIdentificatorNaming(table.upper()))\n                            else:\n                                query = _.query % (unsafeSQLIdentificatorNaming(db), unsafeSQLIdentificatorNaming(table))\n                            comment = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                            if not isNoneValue(comment):\n                                infoMsg = \"retrieved comment '%s' for table '%s'\" % (comment, unsafeSQLIdentificatorNaming(table))\n                                if METADB_SUFFIX not in db:\n                                    infoMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                                logger.info(infoMsg)\n                        else:\n                            warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                            warnMsg += 'possible to get table comments'\n                            singleTimeWarnMessage(warnMsg)\n                    if db not in kb.data.cachedTables:\n                        kb.data.cachedTables[db] = [table]\n                    else:\n                        kb.data.cachedTables[db].append(table)\n    if not kb.data.cachedTables and isInferenceAvailable() and (not conf.direct):\n        for db in dbs:\n            if conf.excludeSysDbs and db in self.excludeDbsList:\n                infoMsg = \"skipping system database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                logger.info(infoMsg)\n                continue\n            if conf.exclude and re.search(conf.exclude, db, re.I) is not None:\n                infoMsg = \"skipping database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                singleTimeLogMessage(infoMsg)\n                continue\n            for (_query, _count) in ((rootQuery.blind.query, rootQuery.blind.count), (getattr(rootQuery.blind, 'query2', None), getattr(rootQuery.blind, 'count2', None))):\n                if _query is None:\n                    break\n                infoMsg = 'fetching number of tables for '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                logger.info(infoMsg)\n                if Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.FIREBIRD, DBMS.MAXDB, DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB):\n                    query = _count % unsafeSQLIdentificatorNaming(db)\n                else:\n                    query = _count\n                count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n                if count == 0:\n                    warnMsg = \"database '%s' \" % unsafeSQLIdentificatorNaming(db)\n                    warnMsg += 'appears to be empty'\n                    logger.warning(warnMsg)\n                    break\n                elif not isNumPosStrValue(count):\n                    warnMsg = 'unable to retrieve the number of '\n                    warnMsg += \"tables for database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                    singleTimeWarnMessage(warnMsg)\n                    continue\n                tables = []\n                plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n                indexRange = getLimitRange(count, plusOne=plusOne)\n                for index in indexRange:\n                    if Backend.isDbms(DBMS.SYBASE):\n                        query = _query % (db, kb.data.cachedTables[-1] if kb.data.cachedTables else ' ')\n                    elif Backend.getIdentifiedDbms() in (DBMS.MAXDB, DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB):\n                        query = _query % (kb.data.cachedTables[-1] if kb.data.cachedTables else ' ')\n                    elif Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.FIREBIRD):\n                        query = _query % index\n                    elif Backend.getIdentifiedDbms() in (DBMS.HSQLDB, DBMS.INFORMIX, DBMS.FRONTBASE, DBMS.VIRTUOSO):\n                        query = _query % (index, unsafeSQLIdentificatorNaming(db))\n                    else:\n                        query = _query % (unsafeSQLIdentificatorNaming(db), index)\n                    table = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                    if not isNoneValue(table):\n                        kb.hintValue = table\n                        table = safeSQLIdentificatorNaming(table, True)\n                        tables.append(table)\n                if tables:\n                    kb.data.cachedTables[db] = tables\n                    if conf.getComments:\n                        for table in tables:\n                            _ = queries[Backend.getIdentifiedDbms()].table_comment\n                            if hasattr(_, 'query'):\n                                if Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                                    query = _.query % (unsafeSQLIdentificatorNaming(db.upper()), unsafeSQLIdentificatorNaming(table.upper()))\n                                else:\n                                    query = _.query % (unsafeSQLIdentificatorNaming(db), unsafeSQLIdentificatorNaming(table))\n                                comment = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                                if not isNoneValue(comment):\n                                    infoMsg = \"retrieved comment '%s' for table '%s'\" % (comment, unsafeSQLIdentificatorNaming(table))\n                                    if METADB_SUFFIX not in db:\n                                        infoMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                                    logger.info(infoMsg)\n                            else:\n                                warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                                warnMsg += 'possible to get table comments'\n                                singleTimeWarnMessage(warnMsg)\n                    break\n                else:\n                    warnMsg = 'unable to retrieve the table names '\n                    warnMsg += \"for database '%s'\" % unsafeSQLIdentificatorNaming(db)\n                    logger.warning(warnMsg)\n    if isNoneValue(kb.data.cachedTables):\n        kb.data.cachedTables.clear()\n    if not kb.data.cachedTables:\n        errMsg = 'unable to retrieve the table names for any database'\n        if bruteForce is None:\n            logger.error(errMsg)\n            return self.getTables(bruteForce=True)\n        elif not conf.search:\n            raise SqlmapNoneDataException(errMsg)\n    else:\n        for (db, tables) in kb.data.cachedTables.items():\n            kb.data.cachedTables[db] = sorted(tables) if tables else tables\n    if kb.data.cachedTables:\n        for db in kb.data.cachedTables:\n            kb.data.cachedTables[db] = list(set(kb.data.cachedTables[db]))\n    return kb.data.cachedTables"
        ]
    },
    {
        "func_name": "getColumns",
        "original": "def getColumns(self, onlyColNames=False, colTuple=None, bruteForce=None, dumpMode=False):\n    self.forceDbmsEnum()\n    if conf.db is None or conf.db == CURRENT_DB:\n        if conf.db is None:\n            warnMsg = 'missing database parameter. sqlmap is going '\n            warnMsg += 'to use the current database to enumerate '\n            warnMsg += 'table(s) columns'\n            logger.warning(warnMsg)\n        conf.db = self.getCurrentDb()\n        if not conf.db:\n            errMsg = 'unable to retrieve the current '\n            errMsg += 'database name'\n            raise SqlmapNoneDataException(errMsg)\n    elif conf.db is not None:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.db = conf.db.upper()\n        if ',' in conf.db:\n            errMsg = 'only one database name is allowed when enumerating '\n            errMsg += \"the tables' columns\"\n            raise SqlmapMissingMandatoryOptionException(errMsg)\n    conf.db = safeSQLIdentificatorNaming(conf.db)\n    if conf.col:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.col = conf.col.upper()\n        colList = conf.col.split(',')\n    else:\n        colList = []\n    if conf.exclude:\n        colList = [_ for _ in colList if re.search(conf.exclude, _, re.I) is None]\n    for col in colList:\n        colList[colList.index(col)] = safeSQLIdentificatorNaming(col)\n    colList = [_ for _ in colList if _]\n    if conf.tbl:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.tbl = conf.tbl.upper()\n        tblList = conf.tbl.split(',')\n    else:\n        self.getTables()\n        if len(kb.data.cachedTables) > 0:\n            if conf.db in kb.data.cachedTables:\n                tblList = kb.data.cachedTables[conf.db]\n            else:\n                tblList = list(six.itervalues(kb.data.cachedTables))\n            if tblList and isListLike(tblList[0]):\n                tblList = tblList[0]\n            tblList = list(tblList)\n        elif not conf.search:\n            errMsg = 'unable to retrieve the tables'\n            if METADB_SUFFIX not in conf.db:\n                errMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n            raise SqlmapNoneDataException(errMsg)\n        else:\n            return kb.data.cachedColumns\n    if conf.exclude:\n        tblList = [_ for _ in tblList if re.search(conf.exclude, _, re.I) is None]\n    tblList = filterNone((safeSQLIdentificatorNaming(_, True) for _ in tblList))\n    if bruteForce is None:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            warnMsg = 'information_schema not available, '\n            warnMsg += 'back-end DBMS is MySQL < 5.0'\n            logger.warning(warnMsg)\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB, DBMS.RAIMA):\n            warnMsg = 'cannot retrieve column names, '\n            warnMsg += 'back-end DBMS is %s' % Backend.getIdentifiedDbms()\n            singleTimeWarnMessage(warnMsg)\n            bruteForce = True\n    if bruteForce:\n        resumeAvailable = False\n        for tbl in tblList:\n            for (db, table, colName, colType) in kb.brute.columns:\n                if db == conf.db and table == tbl:\n                    resumeAvailable = True\n                    break\n        if resumeAvailable and (not (conf.freshQueries and (not colList))):\n            columns = {}\n            for column in colList:\n                columns[column] = None\n            for tbl in tblList:\n                for (db, table, colName, colType) in kb.brute.columns:\n                    if db == conf.db and table == tbl:\n                        columns[colName] = colType\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = {safeSQLIdentificatorNaming(tbl, True): columns}\n            return kb.data.cachedColumns\n        if kb.choices.columnExists is None:\n            message = 'do you want to use common column existence check? %s' % ('[Y/n/q]' if Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB) else '[y/N/q]')\n            kb.choices.columnExists = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n        if kb.choices.columnExists == 'N':\n            if dumpMode and colList:\n                kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = {safeSQLIdentificatorNaming(tbl, True): dict(((_, None) for _ in colList))}\n                return kb.data.cachedColumns\n            else:\n                return None\n        elif kb.choices.columnExists == 'Q':\n            raise SqlmapUserQuitException\n        else:\n            return columnExists(paths.COMMON_COLUMNS)\n    rootQuery = queries[Backend.getIdentifiedDbms()].columns\n    condition = rootQuery.blind.condition if 'condition' in rootQuery.blind else None\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        for tbl in tblList:\n            if conf.db is not None and len(kb.data.cachedColumns) > 0 and (conf.db in kb.data.cachedColumns) and (tbl in kb.data.cachedColumns[conf.db]):\n                infoMsg = 'fetched table columns from '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                return {conf.db: kb.data.cachedColumns[conf.db]}\n            infoMsg = 'fetching columns '\n            condQuery = ''\n            if len(colList) > 0:\n                if colTuple:\n                    (_, colCondParam) = colTuple\n                    infoMsg += \"LIKE '%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                else:\n                    colCondParam = \"='%s'\"\n                    infoMsg += \"'%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                condQueryStr = '%%s%s' % colCondParam\n                condQuery = ' AND (%s)' % ' OR '.join((condQueryStr % (condition, unsafeSQLIdentificatorNaming(col)) for col in sorted(colList)))\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.MONETDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                query = rootQuery.inband.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                query += condQuery\n                if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                    query = re.sub('column_type', 'data_type', query, flags=re.I)\n            elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                query = rootQuery.inband.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                query += condQuery\n            elif Backend.isDbms(DBMS.MSSQL):\n                query = rootQuery.inband.query % (conf.db, conf.db, conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                query += condQuery.replace('[DB]', conf.db)\n            elif Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.FIREBIRD):\n                query = rootQuery.inband.query % unsafeSQLIdentificatorNaming(tbl)\n            elif Backend.isDbms(DBMS.INFORMIX):\n                query = rootQuery.inband.query % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                query += condQuery\n            if dumpMode and colList:\n                values = [(_,) for _ in colList]\n            else:\n                infoMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                if METADB_SUFFIX not in conf.db:\n                    infoMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                values = None\n                if values is None:\n                    values = inject.getValue(query, blind=False, time=False)\n                    if values and isinstance(values[0], six.string_types):\n                        values = [values]\n            if Backend.isDbms(DBMS.MSSQL) and isNoneValue(values):\n                (index, values) = (1, [])\n                while True:\n                    query = rootQuery.inband.query2 % (conf.db, unsafeSQLIdentificatorNaming(tbl), index)\n                    value = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                    if isNoneValue(value) or value == ' ':\n                        break\n                    else:\n                        values.append((value,))\n                        index += 1\n            if Backend.isDbms(DBMS.SQLITE):\n                if dumpMode and colList:\n                    if conf.db not in kb.data.cachedColumns:\n                        kb.data.cachedColumns[conf.db] = {}\n                    kb.data.cachedColumns[conf.db][safeSQLIdentificatorNaming(conf.tbl, True)] = dict(((_, None) for _ in colList))\n                else:\n                    parseSqliteTableSchema(unArrayizeValue(values))\n            elif not isNoneValue(values):\n                table = {}\n                columns = {}\n                for columnData in values:\n                    if not isNoneValue(columnData):\n                        columnData = [unArrayizeValue(_) for _ in columnData]\n                        name = safeSQLIdentificatorNaming(columnData[0])\n                        if name:\n                            if conf.getComments:\n                                _ = queries[Backend.getIdentifiedDbms()].column_comment\n                                if hasattr(_, 'query'):\n                                    if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                                        query = _.query % (unsafeSQLIdentificatorNaming(conf.db.upper()), unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(name.upper()))\n                                    else:\n                                        query = _.query % (unsafeSQLIdentificatorNaming(conf.db), unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(name))\n                                    comment = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                                    if not isNoneValue(comment):\n                                        infoMsg = \"retrieved comment '%s' for column '%s'\" % (comment, name)\n                                        logger.info(infoMsg)\n                                else:\n                                    warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                                    warnMsg += 'possible to get column comments'\n                                    singleTimeWarnMessage(warnMsg)\n                            if len(columnData) == 1:\n                                columns[name] = None\n                            else:\n                                key = int(columnData[1]) if isinstance(columnData[1], six.string_types) and columnData[1].isdigit() else columnData[1]\n                                if Backend.isDbms(DBMS.FIREBIRD):\n                                    columnData[1] = FIREBIRD_TYPES.get(key, columnData[1])\n                                elif Backend.isDbms(DBMS.ALTIBASE):\n                                    columnData[1] = ALTIBASE_TYPES.get(key, columnData[1])\n                                elif Backend.isDbms(DBMS.INFORMIX):\n                                    notNull = False\n                                    if isinstance(key, int) and key > 255:\n                                        key -= 256\n                                        notNull = True\n                                    columnData[1] = INFORMIX_TYPES.get(key, columnData[1])\n                                    if notNull:\n                                        columnData[1] = '%s NOT NULL' % columnData[1]\n                                columns[name] = columnData[1]\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    table[safeSQLIdentificatorNaming(tbl, True)] = columns\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = table\n    elif isInferenceAvailable() and (not conf.direct):\n        for tbl in tblList:\n            if conf.db is not None and len(kb.data.cachedColumns) > 0 and (conf.db in kb.data.cachedColumns) and (tbl in kb.data.cachedColumns[conf.db]):\n                infoMsg = 'fetched table columns from '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                return {conf.db: kb.data.cachedColumns[conf.db]}\n            infoMsg = 'fetching columns '\n            condQuery = ''\n            if len(colList) > 0:\n                if colTuple:\n                    (_, colCondParam) = colTuple\n                    infoMsg += \"LIKE '%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                else:\n                    colCondParam = \"='%s'\"\n                    infoMsg += \"'%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                condQueryStr = '%%s%s' % colCondParam\n                condQuery = ' AND (%s)' % ' OR '.join((condQueryStr % (condition, unsafeSQLIdentificatorNaming(col)) for col in sorted(colList)))\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.MONETDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                query = rootQuery.blind.count % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                query += condQuery\n            elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                query = rootQuery.blind.count % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                query += condQuery\n            elif Backend.isDbms(DBMS.MSSQL):\n                query = rootQuery.blind.count % (conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                query += condQuery.replace('[DB]', conf.db)\n            elif Backend.isDbms(DBMS.FIREBIRD):\n                query = rootQuery.blind.count % unsafeSQLIdentificatorNaming(tbl)\n                query += condQuery\n            elif Backend.isDbms(DBMS.INFORMIX):\n                query = rootQuery.blind.count % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                query += condQuery\n            elif Backend.isDbms(DBMS.SQLITE):\n                if dumpMode and colList:\n                    if conf.db not in kb.data.cachedColumns:\n                        kb.data.cachedColumns[conf.db] = {}\n                    kb.data.cachedColumns[conf.db][safeSQLIdentificatorNaming(conf.tbl, True)] = dict(((_, None) for _ in colList))\n                else:\n                    query = rootQuery.blind.query % unsafeSQLIdentificatorNaming(tbl)\n                    value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                    parseSqliteTableSchema(unArrayizeValue(value))\n                return kb.data.cachedColumns\n            table = {}\n            columns = {}\n            if dumpMode and colList:\n                count = 0\n                for value in colList:\n                    columns[safeSQLIdentificatorNaming(value)] = None\n            else:\n                infoMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                if METADB_SUFFIX not in conf.db:\n                    infoMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n                if not isNumPosStrValue(count):\n                    if Backend.isDbms(DBMS.MSSQL):\n                        (count, index, values) = (0, 1, [])\n                        while True:\n                            query = rootQuery.blind.query3 % (conf.db, unsafeSQLIdentificatorNaming(tbl), index)\n                            value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                            if isNoneValue(value) or value == ' ':\n                                break\n                            else:\n                                columns[safeSQLIdentificatorNaming(value)] = None\n                                index += 1\n                    if not columns:\n                        errMsg = 'unable to retrieve the %scolumns ' % ('number of ' if not Backend.isDbms(DBMS.MSSQL) else '')\n                        errMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                        if METADB_SUFFIX not in conf.db:\n                            errMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                        logger.error(errMsg)\n                        continue\n            for index in getLimitRange(count):\n                if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.H2):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                    query = query.replace(' ORDER BY ', '%s ORDER BY ' % condQuery)\n                    field = None\n                elif Backend.isDbms(DBMS.MIMERSQL):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                    query = query.replace(' ORDER BY ', '%s ORDER BY ' % condQuery)\n                    field = None\n                elif Backend.getIdentifiedDbms() in (DBMS.MONETDB, DBMS.CLICKHOUSE):\n                    query = safeStringFormat(rootQuery.blind.query, (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db), index))\n                    field = None\n                elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.MSSQL):\n                    query = rootQuery.blind.query.replace(\"'%s'\", \"'%s'\" % unsafeSQLIdentificatorNaming(tbl).split('.')[-1]).replace('%s', conf.db).replace('%d', str(index))\n                    query += condQuery.replace('[DB]', conf.db)\n                    field = condition.replace('[DB]', conf.db)\n                elif Backend.isDbms(DBMS.FIREBIRD):\n                    query = rootQuery.blind.query % unsafeSQLIdentificatorNaming(tbl)\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.INFORMIX):\n                    query = rootQuery.blind.query % (index, conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                    query += condQuery\n                    field = condition\n                query = agent.limitQuery(index, query, field, field)\n                column = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                if not isNoneValue(column):\n                    if conf.getComments:\n                        _ = queries[Backend.getIdentifiedDbms()].column_comment\n                        if hasattr(_, 'query'):\n                            if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                                query = _.query % (unsafeSQLIdentificatorNaming(conf.db.upper()), unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(column.upper()))\n                            else:\n                                query = _.query % (unsafeSQLIdentificatorNaming(conf.db), unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(column))\n                            comment = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                            if not isNoneValue(comment):\n                                infoMsg = \"retrieved comment '%s' for column '%s'\" % (comment, column)\n                                logger.info(infoMsg)\n                        else:\n                            warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                            warnMsg += 'possible to get column comments'\n                            singleTimeWarnMessage(warnMsg)\n                    if not onlyColNames:\n                        if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl), column, unsafeSQLIdentificatorNaming(conf.db))\n                        elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl.upper()), column, unsafeSQLIdentificatorNaming(conf.db.upper()))\n                        elif Backend.isDbms(DBMS.MSSQL):\n                            query = rootQuery.blind.query2 % (conf.db, conf.db, conf.db, conf.db, column, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                        elif Backend.isDbms(DBMS.FIREBIRD):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl), column)\n                        elif Backend.isDbms(DBMS.INFORMIX):\n                            query = rootQuery.blind.query2 % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl), column)\n                        elif Backend.isDbms(DBMS.MONETDB):\n                            query = rootQuery.blind.query2 % (column, unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                        colType = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                        key = int(colType) if hasattr(colType, 'isdigit') and colType.isdigit() else colType\n                        if Backend.isDbms(DBMS.FIREBIRD):\n                            colType = FIREBIRD_TYPES.get(key, colType)\n                        elif Backend.isDbms(DBMS.INFORMIX):\n                            notNull = False\n                            if isinstance(key, int) and key > 255:\n                                key -= 256\n                                notNull = True\n                            colType = INFORMIX_TYPES.get(key, colType)\n                            if notNull:\n                                colType = '%s NOT NULL' % colType\n                        column = safeSQLIdentificatorNaming(column)\n                        columns[column] = colType\n                    else:\n                        column = safeSQLIdentificatorNaming(column)\n                        columns[column] = None\n            if columns:\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    table[safeSQLIdentificatorNaming(tbl, True)] = columns\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = table\n    if not kb.data.cachedColumns:\n        warnMsg = 'unable to retrieve column names for '\n        warnMsg += \"table '%s' \" % unsafeSQLIdentificatorNaming(unArrayizeValue(tblList)) if len(tblList) == 1 else 'any table '\n        if METADB_SUFFIX not in conf.db:\n            warnMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n        logger.warning(warnMsg)\n        if bruteForce is None:\n            return self.getColumns(onlyColNames=onlyColNames, colTuple=colTuple, bruteForce=True)\n    return kb.data.cachedColumns",
        "mutated": [
            "def getColumns(self, onlyColNames=False, colTuple=None, bruteForce=None, dumpMode=False):\n    if False:\n        i = 10\n    self.forceDbmsEnum()\n    if conf.db is None or conf.db == CURRENT_DB:\n        if conf.db is None:\n            warnMsg = 'missing database parameter. sqlmap is going '\n            warnMsg += 'to use the current database to enumerate '\n            warnMsg += 'table(s) columns'\n            logger.warning(warnMsg)\n        conf.db = self.getCurrentDb()\n        if not conf.db:\n            errMsg = 'unable to retrieve the current '\n            errMsg += 'database name'\n            raise SqlmapNoneDataException(errMsg)\n    elif conf.db is not None:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.db = conf.db.upper()\n        if ',' in conf.db:\n            errMsg = 'only one database name is allowed when enumerating '\n            errMsg += \"the tables' columns\"\n            raise SqlmapMissingMandatoryOptionException(errMsg)\n    conf.db = safeSQLIdentificatorNaming(conf.db)\n    if conf.col:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.col = conf.col.upper()\n        colList = conf.col.split(',')\n    else:\n        colList = []\n    if conf.exclude:\n        colList = [_ for _ in colList if re.search(conf.exclude, _, re.I) is None]\n    for col in colList:\n        colList[colList.index(col)] = safeSQLIdentificatorNaming(col)\n    colList = [_ for _ in colList if _]\n    if conf.tbl:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.tbl = conf.tbl.upper()\n        tblList = conf.tbl.split(',')\n    else:\n        self.getTables()\n        if len(kb.data.cachedTables) > 0:\n            if conf.db in kb.data.cachedTables:\n                tblList = kb.data.cachedTables[conf.db]\n            else:\n                tblList = list(six.itervalues(kb.data.cachedTables))\n            if tblList and isListLike(tblList[0]):\n                tblList = tblList[0]\n            tblList = list(tblList)\n        elif not conf.search:\n            errMsg = 'unable to retrieve the tables'\n            if METADB_SUFFIX not in conf.db:\n                errMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n            raise SqlmapNoneDataException(errMsg)\n        else:\n            return kb.data.cachedColumns\n    if conf.exclude:\n        tblList = [_ for _ in tblList if re.search(conf.exclude, _, re.I) is None]\n    tblList = filterNone((safeSQLIdentificatorNaming(_, True) for _ in tblList))\n    if bruteForce is None:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            warnMsg = 'information_schema not available, '\n            warnMsg += 'back-end DBMS is MySQL < 5.0'\n            logger.warning(warnMsg)\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB, DBMS.RAIMA):\n            warnMsg = 'cannot retrieve column names, '\n            warnMsg += 'back-end DBMS is %s' % Backend.getIdentifiedDbms()\n            singleTimeWarnMessage(warnMsg)\n            bruteForce = True\n    if bruteForce:\n        resumeAvailable = False\n        for tbl in tblList:\n            for (db, table, colName, colType) in kb.brute.columns:\n                if db == conf.db and table == tbl:\n                    resumeAvailable = True\n                    break\n        if resumeAvailable and (not (conf.freshQueries and (not colList))):\n            columns = {}\n            for column in colList:\n                columns[column] = None\n            for tbl in tblList:\n                for (db, table, colName, colType) in kb.brute.columns:\n                    if db == conf.db and table == tbl:\n                        columns[colName] = colType\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = {safeSQLIdentificatorNaming(tbl, True): columns}\n            return kb.data.cachedColumns\n        if kb.choices.columnExists is None:\n            message = 'do you want to use common column existence check? %s' % ('[Y/n/q]' if Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB) else '[y/N/q]')\n            kb.choices.columnExists = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n        if kb.choices.columnExists == 'N':\n            if dumpMode and colList:\n                kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = {safeSQLIdentificatorNaming(tbl, True): dict(((_, None) for _ in colList))}\n                return kb.data.cachedColumns\n            else:\n                return None\n        elif kb.choices.columnExists == 'Q':\n            raise SqlmapUserQuitException\n        else:\n            return columnExists(paths.COMMON_COLUMNS)\n    rootQuery = queries[Backend.getIdentifiedDbms()].columns\n    condition = rootQuery.blind.condition if 'condition' in rootQuery.blind else None\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        for tbl in tblList:\n            if conf.db is not None and len(kb.data.cachedColumns) > 0 and (conf.db in kb.data.cachedColumns) and (tbl in kb.data.cachedColumns[conf.db]):\n                infoMsg = 'fetched table columns from '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                return {conf.db: kb.data.cachedColumns[conf.db]}\n            infoMsg = 'fetching columns '\n            condQuery = ''\n            if len(colList) > 0:\n                if colTuple:\n                    (_, colCondParam) = colTuple\n                    infoMsg += \"LIKE '%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                else:\n                    colCondParam = \"='%s'\"\n                    infoMsg += \"'%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                condQueryStr = '%%s%s' % colCondParam\n                condQuery = ' AND (%s)' % ' OR '.join((condQueryStr % (condition, unsafeSQLIdentificatorNaming(col)) for col in sorted(colList)))\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.MONETDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                query = rootQuery.inband.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                query += condQuery\n                if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                    query = re.sub('column_type', 'data_type', query, flags=re.I)\n            elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                query = rootQuery.inband.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                query += condQuery\n            elif Backend.isDbms(DBMS.MSSQL):\n                query = rootQuery.inband.query % (conf.db, conf.db, conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                query += condQuery.replace('[DB]', conf.db)\n            elif Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.FIREBIRD):\n                query = rootQuery.inband.query % unsafeSQLIdentificatorNaming(tbl)\n            elif Backend.isDbms(DBMS.INFORMIX):\n                query = rootQuery.inband.query % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                query += condQuery\n            if dumpMode and colList:\n                values = [(_,) for _ in colList]\n            else:\n                infoMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                if METADB_SUFFIX not in conf.db:\n                    infoMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                values = None\n                if values is None:\n                    values = inject.getValue(query, blind=False, time=False)\n                    if values and isinstance(values[0], six.string_types):\n                        values = [values]\n            if Backend.isDbms(DBMS.MSSQL) and isNoneValue(values):\n                (index, values) = (1, [])\n                while True:\n                    query = rootQuery.inband.query2 % (conf.db, unsafeSQLIdentificatorNaming(tbl), index)\n                    value = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                    if isNoneValue(value) or value == ' ':\n                        break\n                    else:\n                        values.append((value,))\n                        index += 1\n            if Backend.isDbms(DBMS.SQLITE):\n                if dumpMode and colList:\n                    if conf.db not in kb.data.cachedColumns:\n                        kb.data.cachedColumns[conf.db] = {}\n                    kb.data.cachedColumns[conf.db][safeSQLIdentificatorNaming(conf.tbl, True)] = dict(((_, None) for _ in colList))\n                else:\n                    parseSqliteTableSchema(unArrayizeValue(values))\n            elif not isNoneValue(values):\n                table = {}\n                columns = {}\n                for columnData in values:\n                    if not isNoneValue(columnData):\n                        columnData = [unArrayizeValue(_) for _ in columnData]\n                        name = safeSQLIdentificatorNaming(columnData[0])\n                        if name:\n                            if conf.getComments:\n                                _ = queries[Backend.getIdentifiedDbms()].column_comment\n                                if hasattr(_, 'query'):\n                                    if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                                        query = _.query % (unsafeSQLIdentificatorNaming(conf.db.upper()), unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(name.upper()))\n                                    else:\n                                        query = _.query % (unsafeSQLIdentificatorNaming(conf.db), unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(name))\n                                    comment = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                                    if not isNoneValue(comment):\n                                        infoMsg = \"retrieved comment '%s' for column '%s'\" % (comment, name)\n                                        logger.info(infoMsg)\n                                else:\n                                    warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                                    warnMsg += 'possible to get column comments'\n                                    singleTimeWarnMessage(warnMsg)\n                            if len(columnData) == 1:\n                                columns[name] = None\n                            else:\n                                key = int(columnData[1]) if isinstance(columnData[1], six.string_types) and columnData[1].isdigit() else columnData[1]\n                                if Backend.isDbms(DBMS.FIREBIRD):\n                                    columnData[1] = FIREBIRD_TYPES.get(key, columnData[1])\n                                elif Backend.isDbms(DBMS.ALTIBASE):\n                                    columnData[1] = ALTIBASE_TYPES.get(key, columnData[1])\n                                elif Backend.isDbms(DBMS.INFORMIX):\n                                    notNull = False\n                                    if isinstance(key, int) and key > 255:\n                                        key -= 256\n                                        notNull = True\n                                    columnData[1] = INFORMIX_TYPES.get(key, columnData[1])\n                                    if notNull:\n                                        columnData[1] = '%s NOT NULL' % columnData[1]\n                                columns[name] = columnData[1]\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    table[safeSQLIdentificatorNaming(tbl, True)] = columns\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = table\n    elif isInferenceAvailable() and (not conf.direct):\n        for tbl in tblList:\n            if conf.db is not None and len(kb.data.cachedColumns) > 0 and (conf.db in kb.data.cachedColumns) and (tbl in kb.data.cachedColumns[conf.db]):\n                infoMsg = 'fetched table columns from '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                return {conf.db: kb.data.cachedColumns[conf.db]}\n            infoMsg = 'fetching columns '\n            condQuery = ''\n            if len(colList) > 0:\n                if colTuple:\n                    (_, colCondParam) = colTuple\n                    infoMsg += \"LIKE '%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                else:\n                    colCondParam = \"='%s'\"\n                    infoMsg += \"'%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                condQueryStr = '%%s%s' % colCondParam\n                condQuery = ' AND (%s)' % ' OR '.join((condQueryStr % (condition, unsafeSQLIdentificatorNaming(col)) for col in sorted(colList)))\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.MONETDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                query = rootQuery.blind.count % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                query += condQuery\n            elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                query = rootQuery.blind.count % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                query += condQuery\n            elif Backend.isDbms(DBMS.MSSQL):\n                query = rootQuery.blind.count % (conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                query += condQuery.replace('[DB]', conf.db)\n            elif Backend.isDbms(DBMS.FIREBIRD):\n                query = rootQuery.blind.count % unsafeSQLIdentificatorNaming(tbl)\n                query += condQuery\n            elif Backend.isDbms(DBMS.INFORMIX):\n                query = rootQuery.blind.count % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                query += condQuery\n            elif Backend.isDbms(DBMS.SQLITE):\n                if dumpMode and colList:\n                    if conf.db not in kb.data.cachedColumns:\n                        kb.data.cachedColumns[conf.db] = {}\n                    kb.data.cachedColumns[conf.db][safeSQLIdentificatorNaming(conf.tbl, True)] = dict(((_, None) for _ in colList))\n                else:\n                    query = rootQuery.blind.query % unsafeSQLIdentificatorNaming(tbl)\n                    value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                    parseSqliteTableSchema(unArrayizeValue(value))\n                return kb.data.cachedColumns\n            table = {}\n            columns = {}\n            if dumpMode and colList:\n                count = 0\n                for value in colList:\n                    columns[safeSQLIdentificatorNaming(value)] = None\n            else:\n                infoMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                if METADB_SUFFIX not in conf.db:\n                    infoMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n                if not isNumPosStrValue(count):\n                    if Backend.isDbms(DBMS.MSSQL):\n                        (count, index, values) = (0, 1, [])\n                        while True:\n                            query = rootQuery.blind.query3 % (conf.db, unsafeSQLIdentificatorNaming(tbl), index)\n                            value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                            if isNoneValue(value) or value == ' ':\n                                break\n                            else:\n                                columns[safeSQLIdentificatorNaming(value)] = None\n                                index += 1\n                    if not columns:\n                        errMsg = 'unable to retrieve the %scolumns ' % ('number of ' if not Backend.isDbms(DBMS.MSSQL) else '')\n                        errMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                        if METADB_SUFFIX not in conf.db:\n                            errMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                        logger.error(errMsg)\n                        continue\n            for index in getLimitRange(count):\n                if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.H2):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                    query = query.replace(' ORDER BY ', '%s ORDER BY ' % condQuery)\n                    field = None\n                elif Backend.isDbms(DBMS.MIMERSQL):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                    query = query.replace(' ORDER BY ', '%s ORDER BY ' % condQuery)\n                    field = None\n                elif Backend.getIdentifiedDbms() in (DBMS.MONETDB, DBMS.CLICKHOUSE):\n                    query = safeStringFormat(rootQuery.blind.query, (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db), index))\n                    field = None\n                elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.MSSQL):\n                    query = rootQuery.blind.query.replace(\"'%s'\", \"'%s'\" % unsafeSQLIdentificatorNaming(tbl).split('.')[-1]).replace('%s', conf.db).replace('%d', str(index))\n                    query += condQuery.replace('[DB]', conf.db)\n                    field = condition.replace('[DB]', conf.db)\n                elif Backend.isDbms(DBMS.FIREBIRD):\n                    query = rootQuery.blind.query % unsafeSQLIdentificatorNaming(tbl)\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.INFORMIX):\n                    query = rootQuery.blind.query % (index, conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                    query += condQuery\n                    field = condition\n                query = agent.limitQuery(index, query, field, field)\n                column = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                if not isNoneValue(column):\n                    if conf.getComments:\n                        _ = queries[Backend.getIdentifiedDbms()].column_comment\n                        if hasattr(_, 'query'):\n                            if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                                query = _.query % (unsafeSQLIdentificatorNaming(conf.db.upper()), unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(column.upper()))\n                            else:\n                                query = _.query % (unsafeSQLIdentificatorNaming(conf.db), unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(column))\n                            comment = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                            if not isNoneValue(comment):\n                                infoMsg = \"retrieved comment '%s' for column '%s'\" % (comment, column)\n                                logger.info(infoMsg)\n                        else:\n                            warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                            warnMsg += 'possible to get column comments'\n                            singleTimeWarnMessage(warnMsg)\n                    if not onlyColNames:\n                        if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl), column, unsafeSQLIdentificatorNaming(conf.db))\n                        elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl.upper()), column, unsafeSQLIdentificatorNaming(conf.db.upper()))\n                        elif Backend.isDbms(DBMS.MSSQL):\n                            query = rootQuery.blind.query2 % (conf.db, conf.db, conf.db, conf.db, column, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                        elif Backend.isDbms(DBMS.FIREBIRD):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl), column)\n                        elif Backend.isDbms(DBMS.INFORMIX):\n                            query = rootQuery.blind.query2 % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl), column)\n                        elif Backend.isDbms(DBMS.MONETDB):\n                            query = rootQuery.blind.query2 % (column, unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                        colType = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                        key = int(colType) if hasattr(colType, 'isdigit') and colType.isdigit() else colType\n                        if Backend.isDbms(DBMS.FIREBIRD):\n                            colType = FIREBIRD_TYPES.get(key, colType)\n                        elif Backend.isDbms(DBMS.INFORMIX):\n                            notNull = False\n                            if isinstance(key, int) and key > 255:\n                                key -= 256\n                                notNull = True\n                            colType = INFORMIX_TYPES.get(key, colType)\n                            if notNull:\n                                colType = '%s NOT NULL' % colType\n                        column = safeSQLIdentificatorNaming(column)\n                        columns[column] = colType\n                    else:\n                        column = safeSQLIdentificatorNaming(column)\n                        columns[column] = None\n            if columns:\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    table[safeSQLIdentificatorNaming(tbl, True)] = columns\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = table\n    if not kb.data.cachedColumns:\n        warnMsg = 'unable to retrieve column names for '\n        warnMsg += \"table '%s' \" % unsafeSQLIdentificatorNaming(unArrayizeValue(tblList)) if len(tblList) == 1 else 'any table '\n        if METADB_SUFFIX not in conf.db:\n            warnMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n        logger.warning(warnMsg)\n        if bruteForce is None:\n            return self.getColumns(onlyColNames=onlyColNames, colTuple=colTuple, bruteForce=True)\n    return kb.data.cachedColumns",
            "def getColumns(self, onlyColNames=False, colTuple=None, bruteForce=None, dumpMode=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.forceDbmsEnum()\n    if conf.db is None or conf.db == CURRENT_DB:\n        if conf.db is None:\n            warnMsg = 'missing database parameter. sqlmap is going '\n            warnMsg += 'to use the current database to enumerate '\n            warnMsg += 'table(s) columns'\n            logger.warning(warnMsg)\n        conf.db = self.getCurrentDb()\n        if not conf.db:\n            errMsg = 'unable to retrieve the current '\n            errMsg += 'database name'\n            raise SqlmapNoneDataException(errMsg)\n    elif conf.db is not None:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.db = conf.db.upper()\n        if ',' in conf.db:\n            errMsg = 'only one database name is allowed when enumerating '\n            errMsg += \"the tables' columns\"\n            raise SqlmapMissingMandatoryOptionException(errMsg)\n    conf.db = safeSQLIdentificatorNaming(conf.db)\n    if conf.col:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.col = conf.col.upper()\n        colList = conf.col.split(',')\n    else:\n        colList = []\n    if conf.exclude:\n        colList = [_ for _ in colList if re.search(conf.exclude, _, re.I) is None]\n    for col in colList:\n        colList[colList.index(col)] = safeSQLIdentificatorNaming(col)\n    colList = [_ for _ in colList if _]\n    if conf.tbl:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.tbl = conf.tbl.upper()\n        tblList = conf.tbl.split(',')\n    else:\n        self.getTables()\n        if len(kb.data.cachedTables) > 0:\n            if conf.db in kb.data.cachedTables:\n                tblList = kb.data.cachedTables[conf.db]\n            else:\n                tblList = list(six.itervalues(kb.data.cachedTables))\n            if tblList and isListLike(tblList[0]):\n                tblList = tblList[0]\n            tblList = list(tblList)\n        elif not conf.search:\n            errMsg = 'unable to retrieve the tables'\n            if METADB_SUFFIX not in conf.db:\n                errMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n            raise SqlmapNoneDataException(errMsg)\n        else:\n            return kb.data.cachedColumns\n    if conf.exclude:\n        tblList = [_ for _ in tblList if re.search(conf.exclude, _, re.I) is None]\n    tblList = filterNone((safeSQLIdentificatorNaming(_, True) for _ in tblList))\n    if bruteForce is None:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            warnMsg = 'information_schema not available, '\n            warnMsg += 'back-end DBMS is MySQL < 5.0'\n            logger.warning(warnMsg)\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB, DBMS.RAIMA):\n            warnMsg = 'cannot retrieve column names, '\n            warnMsg += 'back-end DBMS is %s' % Backend.getIdentifiedDbms()\n            singleTimeWarnMessage(warnMsg)\n            bruteForce = True\n    if bruteForce:\n        resumeAvailable = False\n        for tbl in tblList:\n            for (db, table, colName, colType) in kb.brute.columns:\n                if db == conf.db and table == tbl:\n                    resumeAvailable = True\n                    break\n        if resumeAvailable and (not (conf.freshQueries and (not colList))):\n            columns = {}\n            for column in colList:\n                columns[column] = None\n            for tbl in tblList:\n                for (db, table, colName, colType) in kb.brute.columns:\n                    if db == conf.db and table == tbl:\n                        columns[colName] = colType\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = {safeSQLIdentificatorNaming(tbl, True): columns}\n            return kb.data.cachedColumns\n        if kb.choices.columnExists is None:\n            message = 'do you want to use common column existence check? %s' % ('[Y/n/q]' if Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB) else '[y/N/q]')\n            kb.choices.columnExists = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n        if kb.choices.columnExists == 'N':\n            if dumpMode and colList:\n                kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = {safeSQLIdentificatorNaming(tbl, True): dict(((_, None) for _ in colList))}\n                return kb.data.cachedColumns\n            else:\n                return None\n        elif kb.choices.columnExists == 'Q':\n            raise SqlmapUserQuitException\n        else:\n            return columnExists(paths.COMMON_COLUMNS)\n    rootQuery = queries[Backend.getIdentifiedDbms()].columns\n    condition = rootQuery.blind.condition if 'condition' in rootQuery.blind else None\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        for tbl in tblList:\n            if conf.db is not None and len(kb.data.cachedColumns) > 0 and (conf.db in kb.data.cachedColumns) and (tbl in kb.data.cachedColumns[conf.db]):\n                infoMsg = 'fetched table columns from '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                return {conf.db: kb.data.cachedColumns[conf.db]}\n            infoMsg = 'fetching columns '\n            condQuery = ''\n            if len(colList) > 0:\n                if colTuple:\n                    (_, colCondParam) = colTuple\n                    infoMsg += \"LIKE '%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                else:\n                    colCondParam = \"='%s'\"\n                    infoMsg += \"'%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                condQueryStr = '%%s%s' % colCondParam\n                condQuery = ' AND (%s)' % ' OR '.join((condQueryStr % (condition, unsafeSQLIdentificatorNaming(col)) for col in sorted(colList)))\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.MONETDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                query = rootQuery.inband.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                query += condQuery\n                if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                    query = re.sub('column_type', 'data_type', query, flags=re.I)\n            elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                query = rootQuery.inband.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                query += condQuery\n            elif Backend.isDbms(DBMS.MSSQL):\n                query = rootQuery.inband.query % (conf.db, conf.db, conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                query += condQuery.replace('[DB]', conf.db)\n            elif Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.FIREBIRD):\n                query = rootQuery.inband.query % unsafeSQLIdentificatorNaming(tbl)\n            elif Backend.isDbms(DBMS.INFORMIX):\n                query = rootQuery.inband.query % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                query += condQuery\n            if dumpMode and colList:\n                values = [(_,) for _ in colList]\n            else:\n                infoMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                if METADB_SUFFIX not in conf.db:\n                    infoMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                values = None\n                if values is None:\n                    values = inject.getValue(query, blind=False, time=False)\n                    if values and isinstance(values[0], six.string_types):\n                        values = [values]\n            if Backend.isDbms(DBMS.MSSQL) and isNoneValue(values):\n                (index, values) = (1, [])\n                while True:\n                    query = rootQuery.inband.query2 % (conf.db, unsafeSQLIdentificatorNaming(tbl), index)\n                    value = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                    if isNoneValue(value) or value == ' ':\n                        break\n                    else:\n                        values.append((value,))\n                        index += 1\n            if Backend.isDbms(DBMS.SQLITE):\n                if dumpMode and colList:\n                    if conf.db not in kb.data.cachedColumns:\n                        kb.data.cachedColumns[conf.db] = {}\n                    kb.data.cachedColumns[conf.db][safeSQLIdentificatorNaming(conf.tbl, True)] = dict(((_, None) for _ in colList))\n                else:\n                    parseSqliteTableSchema(unArrayizeValue(values))\n            elif not isNoneValue(values):\n                table = {}\n                columns = {}\n                for columnData in values:\n                    if not isNoneValue(columnData):\n                        columnData = [unArrayizeValue(_) for _ in columnData]\n                        name = safeSQLIdentificatorNaming(columnData[0])\n                        if name:\n                            if conf.getComments:\n                                _ = queries[Backend.getIdentifiedDbms()].column_comment\n                                if hasattr(_, 'query'):\n                                    if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                                        query = _.query % (unsafeSQLIdentificatorNaming(conf.db.upper()), unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(name.upper()))\n                                    else:\n                                        query = _.query % (unsafeSQLIdentificatorNaming(conf.db), unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(name))\n                                    comment = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                                    if not isNoneValue(comment):\n                                        infoMsg = \"retrieved comment '%s' for column '%s'\" % (comment, name)\n                                        logger.info(infoMsg)\n                                else:\n                                    warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                                    warnMsg += 'possible to get column comments'\n                                    singleTimeWarnMessage(warnMsg)\n                            if len(columnData) == 1:\n                                columns[name] = None\n                            else:\n                                key = int(columnData[1]) if isinstance(columnData[1], six.string_types) and columnData[1].isdigit() else columnData[1]\n                                if Backend.isDbms(DBMS.FIREBIRD):\n                                    columnData[1] = FIREBIRD_TYPES.get(key, columnData[1])\n                                elif Backend.isDbms(DBMS.ALTIBASE):\n                                    columnData[1] = ALTIBASE_TYPES.get(key, columnData[1])\n                                elif Backend.isDbms(DBMS.INFORMIX):\n                                    notNull = False\n                                    if isinstance(key, int) and key > 255:\n                                        key -= 256\n                                        notNull = True\n                                    columnData[1] = INFORMIX_TYPES.get(key, columnData[1])\n                                    if notNull:\n                                        columnData[1] = '%s NOT NULL' % columnData[1]\n                                columns[name] = columnData[1]\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    table[safeSQLIdentificatorNaming(tbl, True)] = columns\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = table\n    elif isInferenceAvailable() and (not conf.direct):\n        for tbl in tblList:\n            if conf.db is not None and len(kb.data.cachedColumns) > 0 and (conf.db in kb.data.cachedColumns) and (tbl in kb.data.cachedColumns[conf.db]):\n                infoMsg = 'fetched table columns from '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                return {conf.db: kb.data.cachedColumns[conf.db]}\n            infoMsg = 'fetching columns '\n            condQuery = ''\n            if len(colList) > 0:\n                if colTuple:\n                    (_, colCondParam) = colTuple\n                    infoMsg += \"LIKE '%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                else:\n                    colCondParam = \"='%s'\"\n                    infoMsg += \"'%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                condQueryStr = '%%s%s' % colCondParam\n                condQuery = ' AND (%s)' % ' OR '.join((condQueryStr % (condition, unsafeSQLIdentificatorNaming(col)) for col in sorted(colList)))\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.MONETDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                query = rootQuery.blind.count % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                query += condQuery\n            elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                query = rootQuery.blind.count % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                query += condQuery\n            elif Backend.isDbms(DBMS.MSSQL):\n                query = rootQuery.blind.count % (conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                query += condQuery.replace('[DB]', conf.db)\n            elif Backend.isDbms(DBMS.FIREBIRD):\n                query = rootQuery.blind.count % unsafeSQLIdentificatorNaming(tbl)\n                query += condQuery\n            elif Backend.isDbms(DBMS.INFORMIX):\n                query = rootQuery.blind.count % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                query += condQuery\n            elif Backend.isDbms(DBMS.SQLITE):\n                if dumpMode and colList:\n                    if conf.db not in kb.data.cachedColumns:\n                        kb.data.cachedColumns[conf.db] = {}\n                    kb.data.cachedColumns[conf.db][safeSQLIdentificatorNaming(conf.tbl, True)] = dict(((_, None) for _ in colList))\n                else:\n                    query = rootQuery.blind.query % unsafeSQLIdentificatorNaming(tbl)\n                    value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                    parseSqliteTableSchema(unArrayizeValue(value))\n                return kb.data.cachedColumns\n            table = {}\n            columns = {}\n            if dumpMode and colList:\n                count = 0\n                for value in colList:\n                    columns[safeSQLIdentificatorNaming(value)] = None\n            else:\n                infoMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                if METADB_SUFFIX not in conf.db:\n                    infoMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n                if not isNumPosStrValue(count):\n                    if Backend.isDbms(DBMS.MSSQL):\n                        (count, index, values) = (0, 1, [])\n                        while True:\n                            query = rootQuery.blind.query3 % (conf.db, unsafeSQLIdentificatorNaming(tbl), index)\n                            value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                            if isNoneValue(value) or value == ' ':\n                                break\n                            else:\n                                columns[safeSQLIdentificatorNaming(value)] = None\n                                index += 1\n                    if not columns:\n                        errMsg = 'unable to retrieve the %scolumns ' % ('number of ' if not Backend.isDbms(DBMS.MSSQL) else '')\n                        errMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                        if METADB_SUFFIX not in conf.db:\n                            errMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                        logger.error(errMsg)\n                        continue\n            for index in getLimitRange(count):\n                if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.H2):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                    query = query.replace(' ORDER BY ', '%s ORDER BY ' % condQuery)\n                    field = None\n                elif Backend.isDbms(DBMS.MIMERSQL):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                    query = query.replace(' ORDER BY ', '%s ORDER BY ' % condQuery)\n                    field = None\n                elif Backend.getIdentifiedDbms() in (DBMS.MONETDB, DBMS.CLICKHOUSE):\n                    query = safeStringFormat(rootQuery.blind.query, (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db), index))\n                    field = None\n                elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.MSSQL):\n                    query = rootQuery.blind.query.replace(\"'%s'\", \"'%s'\" % unsafeSQLIdentificatorNaming(tbl).split('.')[-1]).replace('%s', conf.db).replace('%d', str(index))\n                    query += condQuery.replace('[DB]', conf.db)\n                    field = condition.replace('[DB]', conf.db)\n                elif Backend.isDbms(DBMS.FIREBIRD):\n                    query = rootQuery.blind.query % unsafeSQLIdentificatorNaming(tbl)\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.INFORMIX):\n                    query = rootQuery.blind.query % (index, conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                    query += condQuery\n                    field = condition\n                query = agent.limitQuery(index, query, field, field)\n                column = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                if not isNoneValue(column):\n                    if conf.getComments:\n                        _ = queries[Backend.getIdentifiedDbms()].column_comment\n                        if hasattr(_, 'query'):\n                            if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                                query = _.query % (unsafeSQLIdentificatorNaming(conf.db.upper()), unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(column.upper()))\n                            else:\n                                query = _.query % (unsafeSQLIdentificatorNaming(conf.db), unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(column))\n                            comment = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                            if not isNoneValue(comment):\n                                infoMsg = \"retrieved comment '%s' for column '%s'\" % (comment, column)\n                                logger.info(infoMsg)\n                        else:\n                            warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                            warnMsg += 'possible to get column comments'\n                            singleTimeWarnMessage(warnMsg)\n                    if not onlyColNames:\n                        if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl), column, unsafeSQLIdentificatorNaming(conf.db))\n                        elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl.upper()), column, unsafeSQLIdentificatorNaming(conf.db.upper()))\n                        elif Backend.isDbms(DBMS.MSSQL):\n                            query = rootQuery.blind.query2 % (conf.db, conf.db, conf.db, conf.db, column, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                        elif Backend.isDbms(DBMS.FIREBIRD):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl), column)\n                        elif Backend.isDbms(DBMS.INFORMIX):\n                            query = rootQuery.blind.query2 % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl), column)\n                        elif Backend.isDbms(DBMS.MONETDB):\n                            query = rootQuery.blind.query2 % (column, unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                        colType = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                        key = int(colType) if hasattr(colType, 'isdigit') and colType.isdigit() else colType\n                        if Backend.isDbms(DBMS.FIREBIRD):\n                            colType = FIREBIRD_TYPES.get(key, colType)\n                        elif Backend.isDbms(DBMS.INFORMIX):\n                            notNull = False\n                            if isinstance(key, int) and key > 255:\n                                key -= 256\n                                notNull = True\n                            colType = INFORMIX_TYPES.get(key, colType)\n                            if notNull:\n                                colType = '%s NOT NULL' % colType\n                        column = safeSQLIdentificatorNaming(column)\n                        columns[column] = colType\n                    else:\n                        column = safeSQLIdentificatorNaming(column)\n                        columns[column] = None\n            if columns:\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    table[safeSQLIdentificatorNaming(tbl, True)] = columns\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = table\n    if not kb.data.cachedColumns:\n        warnMsg = 'unable to retrieve column names for '\n        warnMsg += \"table '%s' \" % unsafeSQLIdentificatorNaming(unArrayizeValue(tblList)) if len(tblList) == 1 else 'any table '\n        if METADB_SUFFIX not in conf.db:\n            warnMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n        logger.warning(warnMsg)\n        if bruteForce is None:\n            return self.getColumns(onlyColNames=onlyColNames, colTuple=colTuple, bruteForce=True)\n    return kb.data.cachedColumns",
            "def getColumns(self, onlyColNames=False, colTuple=None, bruteForce=None, dumpMode=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.forceDbmsEnum()\n    if conf.db is None or conf.db == CURRENT_DB:\n        if conf.db is None:\n            warnMsg = 'missing database parameter. sqlmap is going '\n            warnMsg += 'to use the current database to enumerate '\n            warnMsg += 'table(s) columns'\n            logger.warning(warnMsg)\n        conf.db = self.getCurrentDb()\n        if not conf.db:\n            errMsg = 'unable to retrieve the current '\n            errMsg += 'database name'\n            raise SqlmapNoneDataException(errMsg)\n    elif conf.db is not None:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.db = conf.db.upper()\n        if ',' in conf.db:\n            errMsg = 'only one database name is allowed when enumerating '\n            errMsg += \"the tables' columns\"\n            raise SqlmapMissingMandatoryOptionException(errMsg)\n    conf.db = safeSQLIdentificatorNaming(conf.db)\n    if conf.col:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.col = conf.col.upper()\n        colList = conf.col.split(',')\n    else:\n        colList = []\n    if conf.exclude:\n        colList = [_ for _ in colList if re.search(conf.exclude, _, re.I) is None]\n    for col in colList:\n        colList[colList.index(col)] = safeSQLIdentificatorNaming(col)\n    colList = [_ for _ in colList if _]\n    if conf.tbl:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.tbl = conf.tbl.upper()\n        tblList = conf.tbl.split(',')\n    else:\n        self.getTables()\n        if len(kb.data.cachedTables) > 0:\n            if conf.db in kb.data.cachedTables:\n                tblList = kb.data.cachedTables[conf.db]\n            else:\n                tblList = list(six.itervalues(kb.data.cachedTables))\n            if tblList and isListLike(tblList[0]):\n                tblList = tblList[0]\n            tblList = list(tblList)\n        elif not conf.search:\n            errMsg = 'unable to retrieve the tables'\n            if METADB_SUFFIX not in conf.db:\n                errMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n            raise SqlmapNoneDataException(errMsg)\n        else:\n            return kb.data.cachedColumns\n    if conf.exclude:\n        tblList = [_ for _ in tblList if re.search(conf.exclude, _, re.I) is None]\n    tblList = filterNone((safeSQLIdentificatorNaming(_, True) for _ in tblList))\n    if bruteForce is None:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            warnMsg = 'information_schema not available, '\n            warnMsg += 'back-end DBMS is MySQL < 5.0'\n            logger.warning(warnMsg)\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB, DBMS.RAIMA):\n            warnMsg = 'cannot retrieve column names, '\n            warnMsg += 'back-end DBMS is %s' % Backend.getIdentifiedDbms()\n            singleTimeWarnMessage(warnMsg)\n            bruteForce = True\n    if bruteForce:\n        resumeAvailable = False\n        for tbl in tblList:\n            for (db, table, colName, colType) in kb.brute.columns:\n                if db == conf.db and table == tbl:\n                    resumeAvailable = True\n                    break\n        if resumeAvailable and (not (conf.freshQueries and (not colList))):\n            columns = {}\n            for column in colList:\n                columns[column] = None\n            for tbl in tblList:\n                for (db, table, colName, colType) in kb.brute.columns:\n                    if db == conf.db and table == tbl:\n                        columns[colName] = colType\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = {safeSQLIdentificatorNaming(tbl, True): columns}\n            return kb.data.cachedColumns\n        if kb.choices.columnExists is None:\n            message = 'do you want to use common column existence check? %s' % ('[Y/n/q]' if Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB) else '[y/N/q]')\n            kb.choices.columnExists = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n        if kb.choices.columnExists == 'N':\n            if dumpMode and colList:\n                kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = {safeSQLIdentificatorNaming(tbl, True): dict(((_, None) for _ in colList))}\n                return kb.data.cachedColumns\n            else:\n                return None\n        elif kb.choices.columnExists == 'Q':\n            raise SqlmapUserQuitException\n        else:\n            return columnExists(paths.COMMON_COLUMNS)\n    rootQuery = queries[Backend.getIdentifiedDbms()].columns\n    condition = rootQuery.blind.condition if 'condition' in rootQuery.blind else None\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        for tbl in tblList:\n            if conf.db is not None and len(kb.data.cachedColumns) > 0 and (conf.db in kb.data.cachedColumns) and (tbl in kb.data.cachedColumns[conf.db]):\n                infoMsg = 'fetched table columns from '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                return {conf.db: kb.data.cachedColumns[conf.db]}\n            infoMsg = 'fetching columns '\n            condQuery = ''\n            if len(colList) > 0:\n                if colTuple:\n                    (_, colCondParam) = colTuple\n                    infoMsg += \"LIKE '%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                else:\n                    colCondParam = \"='%s'\"\n                    infoMsg += \"'%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                condQueryStr = '%%s%s' % colCondParam\n                condQuery = ' AND (%s)' % ' OR '.join((condQueryStr % (condition, unsafeSQLIdentificatorNaming(col)) for col in sorted(colList)))\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.MONETDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                query = rootQuery.inband.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                query += condQuery\n                if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                    query = re.sub('column_type', 'data_type', query, flags=re.I)\n            elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                query = rootQuery.inband.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                query += condQuery\n            elif Backend.isDbms(DBMS.MSSQL):\n                query = rootQuery.inband.query % (conf.db, conf.db, conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                query += condQuery.replace('[DB]', conf.db)\n            elif Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.FIREBIRD):\n                query = rootQuery.inband.query % unsafeSQLIdentificatorNaming(tbl)\n            elif Backend.isDbms(DBMS.INFORMIX):\n                query = rootQuery.inband.query % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                query += condQuery\n            if dumpMode and colList:\n                values = [(_,) for _ in colList]\n            else:\n                infoMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                if METADB_SUFFIX not in conf.db:\n                    infoMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                values = None\n                if values is None:\n                    values = inject.getValue(query, blind=False, time=False)\n                    if values and isinstance(values[0], six.string_types):\n                        values = [values]\n            if Backend.isDbms(DBMS.MSSQL) and isNoneValue(values):\n                (index, values) = (1, [])\n                while True:\n                    query = rootQuery.inband.query2 % (conf.db, unsafeSQLIdentificatorNaming(tbl), index)\n                    value = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                    if isNoneValue(value) or value == ' ':\n                        break\n                    else:\n                        values.append((value,))\n                        index += 1\n            if Backend.isDbms(DBMS.SQLITE):\n                if dumpMode and colList:\n                    if conf.db not in kb.data.cachedColumns:\n                        kb.data.cachedColumns[conf.db] = {}\n                    kb.data.cachedColumns[conf.db][safeSQLIdentificatorNaming(conf.tbl, True)] = dict(((_, None) for _ in colList))\n                else:\n                    parseSqliteTableSchema(unArrayizeValue(values))\n            elif not isNoneValue(values):\n                table = {}\n                columns = {}\n                for columnData in values:\n                    if not isNoneValue(columnData):\n                        columnData = [unArrayizeValue(_) for _ in columnData]\n                        name = safeSQLIdentificatorNaming(columnData[0])\n                        if name:\n                            if conf.getComments:\n                                _ = queries[Backend.getIdentifiedDbms()].column_comment\n                                if hasattr(_, 'query'):\n                                    if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                                        query = _.query % (unsafeSQLIdentificatorNaming(conf.db.upper()), unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(name.upper()))\n                                    else:\n                                        query = _.query % (unsafeSQLIdentificatorNaming(conf.db), unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(name))\n                                    comment = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                                    if not isNoneValue(comment):\n                                        infoMsg = \"retrieved comment '%s' for column '%s'\" % (comment, name)\n                                        logger.info(infoMsg)\n                                else:\n                                    warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                                    warnMsg += 'possible to get column comments'\n                                    singleTimeWarnMessage(warnMsg)\n                            if len(columnData) == 1:\n                                columns[name] = None\n                            else:\n                                key = int(columnData[1]) if isinstance(columnData[1], six.string_types) and columnData[1].isdigit() else columnData[1]\n                                if Backend.isDbms(DBMS.FIREBIRD):\n                                    columnData[1] = FIREBIRD_TYPES.get(key, columnData[1])\n                                elif Backend.isDbms(DBMS.ALTIBASE):\n                                    columnData[1] = ALTIBASE_TYPES.get(key, columnData[1])\n                                elif Backend.isDbms(DBMS.INFORMIX):\n                                    notNull = False\n                                    if isinstance(key, int) and key > 255:\n                                        key -= 256\n                                        notNull = True\n                                    columnData[1] = INFORMIX_TYPES.get(key, columnData[1])\n                                    if notNull:\n                                        columnData[1] = '%s NOT NULL' % columnData[1]\n                                columns[name] = columnData[1]\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    table[safeSQLIdentificatorNaming(tbl, True)] = columns\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = table\n    elif isInferenceAvailable() and (not conf.direct):\n        for tbl in tblList:\n            if conf.db is not None and len(kb.data.cachedColumns) > 0 and (conf.db in kb.data.cachedColumns) and (tbl in kb.data.cachedColumns[conf.db]):\n                infoMsg = 'fetched table columns from '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                return {conf.db: kb.data.cachedColumns[conf.db]}\n            infoMsg = 'fetching columns '\n            condQuery = ''\n            if len(colList) > 0:\n                if colTuple:\n                    (_, colCondParam) = colTuple\n                    infoMsg += \"LIKE '%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                else:\n                    colCondParam = \"='%s'\"\n                    infoMsg += \"'%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                condQueryStr = '%%s%s' % colCondParam\n                condQuery = ' AND (%s)' % ' OR '.join((condQueryStr % (condition, unsafeSQLIdentificatorNaming(col)) for col in sorted(colList)))\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.MONETDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                query = rootQuery.blind.count % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                query += condQuery\n            elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                query = rootQuery.blind.count % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                query += condQuery\n            elif Backend.isDbms(DBMS.MSSQL):\n                query = rootQuery.blind.count % (conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                query += condQuery.replace('[DB]', conf.db)\n            elif Backend.isDbms(DBMS.FIREBIRD):\n                query = rootQuery.blind.count % unsafeSQLIdentificatorNaming(tbl)\n                query += condQuery\n            elif Backend.isDbms(DBMS.INFORMIX):\n                query = rootQuery.blind.count % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                query += condQuery\n            elif Backend.isDbms(DBMS.SQLITE):\n                if dumpMode and colList:\n                    if conf.db not in kb.data.cachedColumns:\n                        kb.data.cachedColumns[conf.db] = {}\n                    kb.data.cachedColumns[conf.db][safeSQLIdentificatorNaming(conf.tbl, True)] = dict(((_, None) for _ in colList))\n                else:\n                    query = rootQuery.blind.query % unsafeSQLIdentificatorNaming(tbl)\n                    value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                    parseSqliteTableSchema(unArrayizeValue(value))\n                return kb.data.cachedColumns\n            table = {}\n            columns = {}\n            if dumpMode and colList:\n                count = 0\n                for value in colList:\n                    columns[safeSQLIdentificatorNaming(value)] = None\n            else:\n                infoMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                if METADB_SUFFIX not in conf.db:\n                    infoMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n                if not isNumPosStrValue(count):\n                    if Backend.isDbms(DBMS.MSSQL):\n                        (count, index, values) = (0, 1, [])\n                        while True:\n                            query = rootQuery.blind.query3 % (conf.db, unsafeSQLIdentificatorNaming(tbl), index)\n                            value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                            if isNoneValue(value) or value == ' ':\n                                break\n                            else:\n                                columns[safeSQLIdentificatorNaming(value)] = None\n                                index += 1\n                    if not columns:\n                        errMsg = 'unable to retrieve the %scolumns ' % ('number of ' if not Backend.isDbms(DBMS.MSSQL) else '')\n                        errMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                        if METADB_SUFFIX not in conf.db:\n                            errMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                        logger.error(errMsg)\n                        continue\n            for index in getLimitRange(count):\n                if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.H2):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                    query = query.replace(' ORDER BY ', '%s ORDER BY ' % condQuery)\n                    field = None\n                elif Backend.isDbms(DBMS.MIMERSQL):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                    query = query.replace(' ORDER BY ', '%s ORDER BY ' % condQuery)\n                    field = None\n                elif Backend.getIdentifiedDbms() in (DBMS.MONETDB, DBMS.CLICKHOUSE):\n                    query = safeStringFormat(rootQuery.blind.query, (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db), index))\n                    field = None\n                elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.MSSQL):\n                    query = rootQuery.blind.query.replace(\"'%s'\", \"'%s'\" % unsafeSQLIdentificatorNaming(tbl).split('.')[-1]).replace('%s', conf.db).replace('%d', str(index))\n                    query += condQuery.replace('[DB]', conf.db)\n                    field = condition.replace('[DB]', conf.db)\n                elif Backend.isDbms(DBMS.FIREBIRD):\n                    query = rootQuery.blind.query % unsafeSQLIdentificatorNaming(tbl)\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.INFORMIX):\n                    query = rootQuery.blind.query % (index, conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                    query += condQuery\n                    field = condition\n                query = agent.limitQuery(index, query, field, field)\n                column = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                if not isNoneValue(column):\n                    if conf.getComments:\n                        _ = queries[Backend.getIdentifiedDbms()].column_comment\n                        if hasattr(_, 'query'):\n                            if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                                query = _.query % (unsafeSQLIdentificatorNaming(conf.db.upper()), unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(column.upper()))\n                            else:\n                                query = _.query % (unsafeSQLIdentificatorNaming(conf.db), unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(column))\n                            comment = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                            if not isNoneValue(comment):\n                                infoMsg = \"retrieved comment '%s' for column '%s'\" % (comment, column)\n                                logger.info(infoMsg)\n                        else:\n                            warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                            warnMsg += 'possible to get column comments'\n                            singleTimeWarnMessage(warnMsg)\n                    if not onlyColNames:\n                        if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl), column, unsafeSQLIdentificatorNaming(conf.db))\n                        elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl.upper()), column, unsafeSQLIdentificatorNaming(conf.db.upper()))\n                        elif Backend.isDbms(DBMS.MSSQL):\n                            query = rootQuery.blind.query2 % (conf.db, conf.db, conf.db, conf.db, column, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                        elif Backend.isDbms(DBMS.FIREBIRD):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl), column)\n                        elif Backend.isDbms(DBMS.INFORMIX):\n                            query = rootQuery.blind.query2 % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl), column)\n                        elif Backend.isDbms(DBMS.MONETDB):\n                            query = rootQuery.blind.query2 % (column, unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                        colType = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                        key = int(colType) if hasattr(colType, 'isdigit') and colType.isdigit() else colType\n                        if Backend.isDbms(DBMS.FIREBIRD):\n                            colType = FIREBIRD_TYPES.get(key, colType)\n                        elif Backend.isDbms(DBMS.INFORMIX):\n                            notNull = False\n                            if isinstance(key, int) and key > 255:\n                                key -= 256\n                                notNull = True\n                            colType = INFORMIX_TYPES.get(key, colType)\n                            if notNull:\n                                colType = '%s NOT NULL' % colType\n                        column = safeSQLIdentificatorNaming(column)\n                        columns[column] = colType\n                    else:\n                        column = safeSQLIdentificatorNaming(column)\n                        columns[column] = None\n            if columns:\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    table[safeSQLIdentificatorNaming(tbl, True)] = columns\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = table\n    if not kb.data.cachedColumns:\n        warnMsg = 'unable to retrieve column names for '\n        warnMsg += \"table '%s' \" % unsafeSQLIdentificatorNaming(unArrayizeValue(tblList)) if len(tblList) == 1 else 'any table '\n        if METADB_SUFFIX not in conf.db:\n            warnMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n        logger.warning(warnMsg)\n        if bruteForce is None:\n            return self.getColumns(onlyColNames=onlyColNames, colTuple=colTuple, bruteForce=True)\n    return kb.data.cachedColumns",
            "def getColumns(self, onlyColNames=False, colTuple=None, bruteForce=None, dumpMode=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.forceDbmsEnum()\n    if conf.db is None or conf.db == CURRENT_DB:\n        if conf.db is None:\n            warnMsg = 'missing database parameter. sqlmap is going '\n            warnMsg += 'to use the current database to enumerate '\n            warnMsg += 'table(s) columns'\n            logger.warning(warnMsg)\n        conf.db = self.getCurrentDb()\n        if not conf.db:\n            errMsg = 'unable to retrieve the current '\n            errMsg += 'database name'\n            raise SqlmapNoneDataException(errMsg)\n    elif conf.db is not None:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.db = conf.db.upper()\n        if ',' in conf.db:\n            errMsg = 'only one database name is allowed when enumerating '\n            errMsg += \"the tables' columns\"\n            raise SqlmapMissingMandatoryOptionException(errMsg)\n    conf.db = safeSQLIdentificatorNaming(conf.db)\n    if conf.col:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.col = conf.col.upper()\n        colList = conf.col.split(',')\n    else:\n        colList = []\n    if conf.exclude:\n        colList = [_ for _ in colList if re.search(conf.exclude, _, re.I) is None]\n    for col in colList:\n        colList[colList.index(col)] = safeSQLIdentificatorNaming(col)\n    colList = [_ for _ in colList if _]\n    if conf.tbl:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.tbl = conf.tbl.upper()\n        tblList = conf.tbl.split(',')\n    else:\n        self.getTables()\n        if len(kb.data.cachedTables) > 0:\n            if conf.db in kb.data.cachedTables:\n                tblList = kb.data.cachedTables[conf.db]\n            else:\n                tblList = list(six.itervalues(kb.data.cachedTables))\n            if tblList and isListLike(tblList[0]):\n                tblList = tblList[0]\n            tblList = list(tblList)\n        elif not conf.search:\n            errMsg = 'unable to retrieve the tables'\n            if METADB_SUFFIX not in conf.db:\n                errMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n            raise SqlmapNoneDataException(errMsg)\n        else:\n            return kb.data.cachedColumns\n    if conf.exclude:\n        tblList = [_ for _ in tblList if re.search(conf.exclude, _, re.I) is None]\n    tblList = filterNone((safeSQLIdentificatorNaming(_, True) for _ in tblList))\n    if bruteForce is None:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            warnMsg = 'information_schema not available, '\n            warnMsg += 'back-end DBMS is MySQL < 5.0'\n            logger.warning(warnMsg)\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB, DBMS.RAIMA):\n            warnMsg = 'cannot retrieve column names, '\n            warnMsg += 'back-end DBMS is %s' % Backend.getIdentifiedDbms()\n            singleTimeWarnMessage(warnMsg)\n            bruteForce = True\n    if bruteForce:\n        resumeAvailable = False\n        for tbl in tblList:\n            for (db, table, colName, colType) in kb.brute.columns:\n                if db == conf.db and table == tbl:\n                    resumeAvailable = True\n                    break\n        if resumeAvailable and (not (conf.freshQueries and (not colList))):\n            columns = {}\n            for column in colList:\n                columns[column] = None\n            for tbl in tblList:\n                for (db, table, colName, colType) in kb.brute.columns:\n                    if db == conf.db and table == tbl:\n                        columns[colName] = colType\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = {safeSQLIdentificatorNaming(tbl, True): columns}\n            return kb.data.cachedColumns\n        if kb.choices.columnExists is None:\n            message = 'do you want to use common column existence check? %s' % ('[Y/n/q]' if Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB) else '[y/N/q]')\n            kb.choices.columnExists = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n        if kb.choices.columnExists == 'N':\n            if dumpMode and colList:\n                kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = {safeSQLIdentificatorNaming(tbl, True): dict(((_, None) for _ in colList))}\n                return kb.data.cachedColumns\n            else:\n                return None\n        elif kb.choices.columnExists == 'Q':\n            raise SqlmapUserQuitException\n        else:\n            return columnExists(paths.COMMON_COLUMNS)\n    rootQuery = queries[Backend.getIdentifiedDbms()].columns\n    condition = rootQuery.blind.condition if 'condition' in rootQuery.blind else None\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        for tbl in tblList:\n            if conf.db is not None and len(kb.data.cachedColumns) > 0 and (conf.db in kb.data.cachedColumns) and (tbl in kb.data.cachedColumns[conf.db]):\n                infoMsg = 'fetched table columns from '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                return {conf.db: kb.data.cachedColumns[conf.db]}\n            infoMsg = 'fetching columns '\n            condQuery = ''\n            if len(colList) > 0:\n                if colTuple:\n                    (_, colCondParam) = colTuple\n                    infoMsg += \"LIKE '%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                else:\n                    colCondParam = \"='%s'\"\n                    infoMsg += \"'%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                condQueryStr = '%%s%s' % colCondParam\n                condQuery = ' AND (%s)' % ' OR '.join((condQueryStr % (condition, unsafeSQLIdentificatorNaming(col)) for col in sorted(colList)))\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.MONETDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                query = rootQuery.inband.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                query += condQuery\n                if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                    query = re.sub('column_type', 'data_type', query, flags=re.I)\n            elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                query = rootQuery.inband.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                query += condQuery\n            elif Backend.isDbms(DBMS.MSSQL):\n                query = rootQuery.inband.query % (conf.db, conf.db, conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                query += condQuery.replace('[DB]', conf.db)\n            elif Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.FIREBIRD):\n                query = rootQuery.inband.query % unsafeSQLIdentificatorNaming(tbl)\n            elif Backend.isDbms(DBMS.INFORMIX):\n                query = rootQuery.inband.query % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                query += condQuery\n            if dumpMode and colList:\n                values = [(_,) for _ in colList]\n            else:\n                infoMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                if METADB_SUFFIX not in conf.db:\n                    infoMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                values = None\n                if values is None:\n                    values = inject.getValue(query, blind=False, time=False)\n                    if values and isinstance(values[0], six.string_types):\n                        values = [values]\n            if Backend.isDbms(DBMS.MSSQL) and isNoneValue(values):\n                (index, values) = (1, [])\n                while True:\n                    query = rootQuery.inband.query2 % (conf.db, unsafeSQLIdentificatorNaming(tbl), index)\n                    value = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                    if isNoneValue(value) or value == ' ':\n                        break\n                    else:\n                        values.append((value,))\n                        index += 1\n            if Backend.isDbms(DBMS.SQLITE):\n                if dumpMode and colList:\n                    if conf.db not in kb.data.cachedColumns:\n                        kb.data.cachedColumns[conf.db] = {}\n                    kb.data.cachedColumns[conf.db][safeSQLIdentificatorNaming(conf.tbl, True)] = dict(((_, None) for _ in colList))\n                else:\n                    parseSqliteTableSchema(unArrayizeValue(values))\n            elif not isNoneValue(values):\n                table = {}\n                columns = {}\n                for columnData in values:\n                    if not isNoneValue(columnData):\n                        columnData = [unArrayizeValue(_) for _ in columnData]\n                        name = safeSQLIdentificatorNaming(columnData[0])\n                        if name:\n                            if conf.getComments:\n                                _ = queries[Backend.getIdentifiedDbms()].column_comment\n                                if hasattr(_, 'query'):\n                                    if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                                        query = _.query % (unsafeSQLIdentificatorNaming(conf.db.upper()), unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(name.upper()))\n                                    else:\n                                        query = _.query % (unsafeSQLIdentificatorNaming(conf.db), unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(name))\n                                    comment = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                                    if not isNoneValue(comment):\n                                        infoMsg = \"retrieved comment '%s' for column '%s'\" % (comment, name)\n                                        logger.info(infoMsg)\n                                else:\n                                    warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                                    warnMsg += 'possible to get column comments'\n                                    singleTimeWarnMessage(warnMsg)\n                            if len(columnData) == 1:\n                                columns[name] = None\n                            else:\n                                key = int(columnData[1]) if isinstance(columnData[1], six.string_types) and columnData[1].isdigit() else columnData[1]\n                                if Backend.isDbms(DBMS.FIREBIRD):\n                                    columnData[1] = FIREBIRD_TYPES.get(key, columnData[1])\n                                elif Backend.isDbms(DBMS.ALTIBASE):\n                                    columnData[1] = ALTIBASE_TYPES.get(key, columnData[1])\n                                elif Backend.isDbms(DBMS.INFORMIX):\n                                    notNull = False\n                                    if isinstance(key, int) and key > 255:\n                                        key -= 256\n                                        notNull = True\n                                    columnData[1] = INFORMIX_TYPES.get(key, columnData[1])\n                                    if notNull:\n                                        columnData[1] = '%s NOT NULL' % columnData[1]\n                                columns[name] = columnData[1]\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    table[safeSQLIdentificatorNaming(tbl, True)] = columns\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = table\n    elif isInferenceAvailable() and (not conf.direct):\n        for tbl in tblList:\n            if conf.db is not None and len(kb.data.cachedColumns) > 0 and (conf.db in kb.data.cachedColumns) and (tbl in kb.data.cachedColumns[conf.db]):\n                infoMsg = 'fetched table columns from '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                return {conf.db: kb.data.cachedColumns[conf.db]}\n            infoMsg = 'fetching columns '\n            condQuery = ''\n            if len(colList) > 0:\n                if colTuple:\n                    (_, colCondParam) = colTuple\n                    infoMsg += \"LIKE '%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                else:\n                    colCondParam = \"='%s'\"\n                    infoMsg += \"'%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                condQueryStr = '%%s%s' % colCondParam\n                condQuery = ' AND (%s)' % ' OR '.join((condQueryStr % (condition, unsafeSQLIdentificatorNaming(col)) for col in sorted(colList)))\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.MONETDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                query = rootQuery.blind.count % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                query += condQuery\n            elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                query = rootQuery.blind.count % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                query += condQuery\n            elif Backend.isDbms(DBMS.MSSQL):\n                query = rootQuery.blind.count % (conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                query += condQuery.replace('[DB]', conf.db)\n            elif Backend.isDbms(DBMS.FIREBIRD):\n                query = rootQuery.blind.count % unsafeSQLIdentificatorNaming(tbl)\n                query += condQuery\n            elif Backend.isDbms(DBMS.INFORMIX):\n                query = rootQuery.blind.count % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                query += condQuery\n            elif Backend.isDbms(DBMS.SQLITE):\n                if dumpMode and colList:\n                    if conf.db not in kb.data.cachedColumns:\n                        kb.data.cachedColumns[conf.db] = {}\n                    kb.data.cachedColumns[conf.db][safeSQLIdentificatorNaming(conf.tbl, True)] = dict(((_, None) for _ in colList))\n                else:\n                    query = rootQuery.blind.query % unsafeSQLIdentificatorNaming(tbl)\n                    value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                    parseSqliteTableSchema(unArrayizeValue(value))\n                return kb.data.cachedColumns\n            table = {}\n            columns = {}\n            if dumpMode and colList:\n                count = 0\n                for value in colList:\n                    columns[safeSQLIdentificatorNaming(value)] = None\n            else:\n                infoMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                if METADB_SUFFIX not in conf.db:\n                    infoMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n                if not isNumPosStrValue(count):\n                    if Backend.isDbms(DBMS.MSSQL):\n                        (count, index, values) = (0, 1, [])\n                        while True:\n                            query = rootQuery.blind.query3 % (conf.db, unsafeSQLIdentificatorNaming(tbl), index)\n                            value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                            if isNoneValue(value) or value == ' ':\n                                break\n                            else:\n                                columns[safeSQLIdentificatorNaming(value)] = None\n                                index += 1\n                    if not columns:\n                        errMsg = 'unable to retrieve the %scolumns ' % ('number of ' if not Backend.isDbms(DBMS.MSSQL) else '')\n                        errMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                        if METADB_SUFFIX not in conf.db:\n                            errMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                        logger.error(errMsg)\n                        continue\n            for index in getLimitRange(count):\n                if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.H2):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                    query = query.replace(' ORDER BY ', '%s ORDER BY ' % condQuery)\n                    field = None\n                elif Backend.isDbms(DBMS.MIMERSQL):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                    query = query.replace(' ORDER BY ', '%s ORDER BY ' % condQuery)\n                    field = None\n                elif Backend.getIdentifiedDbms() in (DBMS.MONETDB, DBMS.CLICKHOUSE):\n                    query = safeStringFormat(rootQuery.blind.query, (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db), index))\n                    field = None\n                elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.MSSQL):\n                    query = rootQuery.blind.query.replace(\"'%s'\", \"'%s'\" % unsafeSQLIdentificatorNaming(tbl).split('.')[-1]).replace('%s', conf.db).replace('%d', str(index))\n                    query += condQuery.replace('[DB]', conf.db)\n                    field = condition.replace('[DB]', conf.db)\n                elif Backend.isDbms(DBMS.FIREBIRD):\n                    query = rootQuery.blind.query % unsafeSQLIdentificatorNaming(tbl)\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.INFORMIX):\n                    query = rootQuery.blind.query % (index, conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                    query += condQuery\n                    field = condition\n                query = agent.limitQuery(index, query, field, field)\n                column = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                if not isNoneValue(column):\n                    if conf.getComments:\n                        _ = queries[Backend.getIdentifiedDbms()].column_comment\n                        if hasattr(_, 'query'):\n                            if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                                query = _.query % (unsafeSQLIdentificatorNaming(conf.db.upper()), unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(column.upper()))\n                            else:\n                                query = _.query % (unsafeSQLIdentificatorNaming(conf.db), unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(column))\n                            comment = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                            if not isNoneValue(comment):\n                                infoMsg = \"retrieved comment '%s' for column '%s'\" % (comment, column)\n                                logger.info(infoMsg)\n                        else:\n                            warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                            warnMsg += 'possible to get column comments'\n                            singleTimeWarnMessage(warnMsg)\n                    if not onlyColNames:\n                        if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl), column, unsafeSQLIdentificatorNaming(conf.db))\n                        elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl.upper()), column, unsafeSQLIdentificatorNaming(conf.db.upper()))\n                        elif Backend.isDbms(DBMS.MSSQL):\n                            query = rootQuery.blind.query2 % (conf.db, conf.db, conf.db, conf.db, column, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                        elif Backend.isDbms(DBMS.FIREBIRD):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl), column)\n                        elif Backend.isDbms(DBMS.INFORMIX):\n                            query = rootQuery.blind.query2 % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl), column)\n                        elif Backend.isDbms(DBMS.MONETDB):\n                            query = rootQuery.blind.query2 % (column, unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                        colType = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                        key = int(colType) if hasattr(colType, 'isdigit') and colType.isdigit() else colType\n                        if Backend.isDbms(DBMS.FIREBIRD):\n                            colType = FIREBIRD_TYPES.get(key, colType)\n                        elif Backend.isDbms(DBMS.INFORMIX):\n                            notNull = False\n                            if isinstance(key, int) and key > 255:\n                                key -= 256\n                                notNull = True\n                            colType = INFORMIX_TYPES.get(key, colType)\n                            if notNull:\n                                colType = '%s NOT NULL' % colType\n                        column = safeSQLIdentificatorNaming(column)\n                        columns[column] = colType\n                    else:\n                        column = safeSQLIdentificatorNaming(column)\n                        columns[column] = None\n            if columns:\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    table[safeSQLIdentificatorNaming(tbl, True)] = columns\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = table\n    if not kb.data.cachedColumns:\n        warnMsg = 'unable to retrieve column names for '\n        warnMsg += \"table '%s' \" % unsafeSQLIdentificatorNaming(unArrayizeValue(tblList)) if len(tblList) == 1 else 'any table '\n        if METADB_SUFFIX not in conf.db:\n            warnMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n        logger.warning(warnMsg)\n        if bruteForce is None:\n            return self.getColumns(onlyColNames=onlyColNames, colTuple=colTuple, bruteForce=True)\n    return kb.data.cachedColumns",
            "def getColumns(self, onlyColNames=False, colTuple=None, bruteForce=None, dumpMode=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.forceDbmsEnum()\n    if conf.db is None or conf.db == CURRENT_DB:\n        if conf.db is None:\n            warnMsg = 'missing database parameter. sqlmap is going '\n            warnMsg += 'to use the current database to enumerate '\n            warnMsg += 'table(s) columns'\n            logger.warning(warnMsg)\n        conf.db = self.getCurrentDb()\n        if not conf.db:\n            errMsg = 'unable to retrieve the current '\n            errMsg += 'database name'\n            raise SqlmapNoneDataException(errMsg)\n    elif conf.db is not None:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.db = conf.db.upper()\n        if ',' in conf.db:\n            errMsg = 'only one database name is allowed when enumerating '\n            errMsg += \"the tables' columns\"\n            raise SqlmapMissingMandatoryOptionException(errMsg)\n    conf.db = safeSQLIdentificatorNaming(conf.db)\n    if conf.col:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.col = conf.col.upper()\n        colList = conf.col.split(',')\n    else:\n        colList = []\n    if conf.exclude:\n        colList = [_ for _ in colList if re.search(conf.exclude, _, re.I) is None]\n    for col in colList:\n        colList[colList.index(col)] = safeSQLIdentificatorNaming(col)\n    colList = [_ for _ in colList if _]\n    if conf.tbl:\n        if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n            conf.tbl = conf.tbl.upper()\n        tblList = conf.tbl.split(',')\n    else:\n        self.getTables()\n        if len(kb.data.cachedTables) > 0:\n            if conf.db in kb.data.cachedTables:\n                tblList = kb.data.cachedTables[conf.db]\n            else:\n                tblList = list(six.itervalues(kb.data.cachedTables))\n            if tblList and isListLike(tblList[0]):\n                tblList = tblList[0]\n            tblList = list(tblList)\n        elif not conf.search:\n            errMsg = 'unable to retrieve the tables'\n            if METADB_SUFFIX not in conf.db:\n                errMsg += \" in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n            raise SqlmapNoneDataException(errMsg)\n        else:\n            return kb.data.cachedColumns\n    if conf.exclude:\n        tblList = [_ for _ in tblList if re.search(conf.exclude, _, re.I) is None]\n    tblList = filterNone((safeSQLIdentificatorNaming(_, True) for _ in tblList))\n    if bruteForce is None:\n        if Backend.isDbms(DBMS.MYSQL) and (not kb.data.has_information_schema):\n            warnMsg = 'information_schema not available, '\n            warnMsg += 'back-end DBMS is MySQL < 5.0'\n            logger.warning(warnMsg)\n            bruteForce = True\n        elif Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB, DBMS.RAIMA):\n            warnMsg = 'cannot retrieve column names, '\n            warnMsg += 'back-end DBMS is %s' % Backend.getIdentifiedDbms()\n            singleTimeWarnMessage(warnMsg)\n            bruteForce = True\n    if bruteForce:\n        resumeAvailable = False\n        for tbl in tblList:\n            for (db, table, colName, colType) in kb.brute.columns:\n                if db == conf.db and table == tbl:\n                    resumeAvailable = True\n                    break\n        if resumeAvailable and (not (conf.freshQueries and (not colList))):\n            columns = {}\n            for column in colList:\n                columns[column] = None\n            for tbl in tblList:\n                for (db, table, colName, colType) in kb.brute.columns:\n                    if db == conf.db and table == tbl:\n                        columns[colName] = colType\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = {safeSQLIdentificatorNaming(tbl, True): columns}\n            return kb.data.cachedColumns\n        if kb.choices.columnExists is None:\n            message = 'do you want to use common column existence check? %s' % ('[Y/n/q]' if Backend.getIdentifiedDbms() in (DBMS.ACCESS, DBMS.MCKOI, DBMS.EXTREMEDB) else '[y/N/q]')\n            kb.choices.columnExists = readInput(message, default='Y' if 'Y' in message else 'N').upper()\n        if kb.choices.columnExists == 'N':\n            if dumpMode and colList:\n                kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = {safeSQLIdentificatorNaming(tbl, True): dict(((_, None) for _ in colList))}\n                return kb.data.cachedColumns\n            else:\n                return None\n        elif kb.choices.columnExists == 'Q':\n            raise SqlmapUserQuitException\n        else:\n            return columnExists(paths.COMMON_COLUMNS)\n    rootQuery = queries[Backend.getIdentifiedDbms()].columns\n    condition = rootQuery.blind.condition if 'condition' in rootQuery.blind else None\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        for tbl in tblList:\n            if conf.db is not None and len(kb.data.cachedColumns) > 0 and (conf.db in kb.data.cachedColumns) and (tbl in kb.data.cachedColumns[conf.db]):\n                infoMsg = 'fetched table columns from '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                return {conf.db: kb.data.cachedColumns[conf.db]}\n            infoMsg = 'fetching columns '\n            condQuery = ''\n            if len(colList) > 0:\n                if colTuple:\n                    (_, colCondParam) = colTuple\n                    infoMsg += \"LIKE '%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                else:\n                    colCondParam = \"='%s'\"\n                    infoMsg += \"'%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                condQueryStr = '%%s%s' % colCondParam\n                condQuery = ' AND (%s)' % ' OR '.join((condQueryStr % (condition, unsafeSQLIdentificatorNaming(col)) for col in sorted(colList)))\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.MONETDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                query = rootQuery.inband.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                query += condQuery\n                if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                    query = re.sub('column_type', 'data_type', query, flags=re.I)\n            elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                query = rootQuery.inband.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                query += condQuery\n            elif Backend.isDbms(DBMS.MSSQL):\n                query = rootQuery.inband.query % (conf.db, conf.db, conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                query += condQuery.replace('[DB]', conf.db)\n            elif Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.FIREBIRD):\n                query = rootQuery.inband.query % unsafeSQLIdentificatorNaming(tbl)\n            elif Backend.isDbms(DBMS.INFORMIX):\n                query = rootQuery.inband.query % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                query += condQuery\n            if dumpMode and colList:\n                values = [(_,) for _ in colList]\n            else:\n                infoMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                if METADB_SUFFIX not in conf.db:\n                    infoMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                values = None\n                if values is None:\n                    values = inject.getValue(query, blind=False, time=False)\n                    if values and isinstance(values[0], six.string_types):\n                        values = [values]\n            if Backend.isDbms(DBMS.MSSQL) and isNoneValue(values):\n                (index, values) = (1, [])\n                while True:\n                    query = rootQuery.inband.query2 % (conf.db, unsafeSQLIdentificatorNaming(tbl), index)\n                    value = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                    if isNoneValue(value) or value == ' ':\n                        break\n                    else:\n                        values.append((value,))\n                        index += 1\n            if Backend.isDbms(DBMS.SQLITE):\n                if dumpMode and colList:\n                    if conf.db not in kb.data.cachedColumns:\n                        kb.data.cachedColumns[conf.db] = {}\n                    kb.data.cachedColumns[conf.db][safeSQLIdentificatorNaming(conf.tbl, True)] = dict(((_, None) for _ in colList))\n                else:\n                    parseSqliteTableSchema(unArrayizeValue(values))\n            elif not isNoneValue(values):\n                table = {}\n                columns = {}\n                for columnData in values:\n                    if not isNoneValue(columnData):\n                        columnData = [unArrayizeValue(_) for _ in columnData]\n                        name = safeSQLIdentificatorNaming(columnData[0])\n                        if name:\n                            if conf.getComments:\n                                _ = queries[Backend.getIdentifiedDbms()].column_comment\n                                if hasattr(_, 'query'):\n                                    if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                                        query = _.query % (unsafeSQLIdentificatorNaming(conf.db.upper()), unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(name.upper()))\n                                    else:\n                                        query = _.query % (unsafeSQLIdentificatorNaming(conf.db), unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(name))\n                                    comment = unArrayizeValue(inject.getValue(query, blind=False, time=False))\n                                    if not isNoneValue(comment):\n                                        infoMsg = \"retrieved comment '%s' for column '%s'\" % (comment, name)\n                                        logger.info(infoMsg)\n                                else:\n                                    warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                                    warnMsg += 'possible to get column comments'\n                                    singleTimeWarnMessage(warnMsg)\n                            if len(columnData) == 1:\n                                columns[name] = None\n                            else:\n                                key = int(columnData[1]) if isinstance(columnData[1], six.string_types) and columnData[1].isdigit() else columnData[1]\n                                if Backend.isDbms(DBMS.FIREBIRD):\n                                    columnData[1] = FIREBIRD_TYPES.get(key, columnData[1])\n                                elif Backend.isDbms(DBMS.ALTIBASE):\n                                    columnData[1] = ALTIBASE_TYPES.get(key, columnData[1])\n                                elif Backend.isDbms(DBMS.INFORMIX):\n                                    notNull = False\n                                    if isinstance(key, int) and key > 255:\n                                        key -= 256\n                                        notNull = True\n                                    columnData[1] = INFORMIX_TYPES.get(key, columnData[1])\n                                    if notNull:\n                                        columnData[1] = '%s NOT NULL' % columnData[1]\n                                columns[name] = columnData[1]\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    table[safeSQLIdentificatorNaming(tbl, True)] = columns\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = table\n    elif isInferenceAvailable() and (not conf.direct):\n        for tbl in tblList:\n            if conf.db is not None and len(kb.data.cachedColumns) > 0 and (conf.db in kb.data.cachedColumns) and (tbl in kb.data.cachedColumns[conf.db]):\n                infoMsg = 'fetched table columns from '\n                infoMsg += \"database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                return {conf.db: kb.data.cachedColumns[conf.db]}\n            infoMsg = 'fetching columns '\n            condQuery = ''\n            if len(colList) > 0:\n                if colTuple:\n                    (_, colCondParam) = colTuple\n                    infoMsg += \"LIKE '%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                else:\n                    colCondParam = \"='%s'\"\n                    infoMsg += \"'%s' \" % ', '.join((unsafeSQLIdentificatorNaming(col) for col in sorted(colList)))\n                condQueryStr = '%%s%s' % colCondParam\n                condQuery = ' AND (%s)' % ' OR '.join((condQueryStr % (condition, unsafeSQLIdentificatorNaming(col)) for col in sorted(colList)))\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.MONETDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                query = rootQuery.blind.count % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                query += condQuery\n            elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                query = rootQuery.blind.count % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                query += condQuery\n            elif Backend.isDbms(DBMS.MSSQL):\n                query = rootQuery.blind.count % (conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                query += condQuery.replace('[DB]', conf.db)\n            elif Backend.isDbms(DBMS.FIREBIRD):\n                query = rootQuery.blind.count % unsafeSQLIdentificatorNaming(tbl)\n                query += condQuery\n            elif Backend.isDbms(DBMS.INFORMIX):\n                query = rootQuery.blind.count % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                query += condQuery\n            elif Backend.isDbms(DBMS.SQLITE):\n                if dumpMode and colList:\n                    if conf.db not in kb.data.cachedColumns:\n                        kb.data.cachedColumns[conf.db] = {}\n                    kb.data.cachedColumns[conf.db][safeSQLIdentificatorNaming(conf.tbl, True)] = dict(((_, None) for _ in colList))\n                else:\n                    query = rootQuery.blind.query % unsafeSQLIdentificatorNaming(tbl)\n                    value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                    parseSqliteTableSchema(unArrayizeValue(value))\n                return kb.data.cachedColumns\n            table = {}\n            columns = {}\n            if dumpMode and colList:\n                count = 0\n                for value in colList:\n                    columns[safeSQLIdentificatorNaming(value)] = None\n            else:\n                infoMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                if METADB_SUFFIX not in conf.db:\n                    infoMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                logger.info(infoMsg)\n                count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n                if not isNumPosStrValue(count):\n                    if Backend.isDbms(DBMS.MSSQL):\n                        (count, index, values) = (0, 1, [])\n                        while True:\n                            query = rootQuery.blind.query3 % (conf.db, unsafeSQLIdentificatorNaming(tbl), index)\n                            value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                            if isNoneValue(value) or value == ' ':\n                                break\n                            else:\n                                columns[safeSQLIdentificatorNaming(value)] = None\n                                index += 1\n                    if not columns:\n                        errMsg = 'unable to retrieve the %scolumns ' % ('number of ' if not Backend.isDbms(DBMS.MSSQL) else '')\n                        errMsg += \"for table '%s' \" % unsafeSQLIdentificatorNaming(tbl)\n                        if METADB_SUFFIX not in conf.db:\n                            errMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n                        logger.error(errMsg)\n                        continue\n            for index in getLimitRange(count):\n                if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CUBRID, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.H2):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                    query = query.replace(' ORDER BY ', '%s ORDER BY ' % condQuery)\n                    field = None\n                elif Backend.isDbms(DBMS.MIMERSQL):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                    query = query.replace(' ORDER BY ', '%s ORDER BY ' % condQuery)\n                    field = None\n                elif Backend.getIdentifiedDbms() in (DBMS.MONETDB, DBMS.CLICKHOUSE):\n                    query = safeStringFormat(rootQuery.blind.query, (unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db), index))\n                    field = None\n                elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE):\n                    query = rootQuery.blind.query % (unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(conf.db.upper()))\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.MSSQL):\n                    query = rootQuery.blind.query.replace(\"'%s'\", \"'%s'\" % unsafeSQLIdentificatorNaming(tbl).split('.')[-1]).replace('%s', conf.db).replace('%d', str(index))\n                    query += condQuery.replace('[DB]', conf.db)\n                    field = condition.replace('[DB]', conf.db)\n                elif Backend.isDbms(DBMS.FIREBIRD):\n                    query = rootQuery.blind.query % unsafeSQLIdentificatorNaming(tbl)\n                    query += condQuery\n                    field = None\n                elif Backend.isDbms(DBMS.INFORMIX):\n                    query = rootQuery.blind.query % (index, conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl))\n                    query += condQuery\n                    field = condition\n                query = agent.limitQuery(index, query, field, field)\n                column = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                if not isNoneValue(column):\n                    if conf.getComments:\n                        _ = queries[Backend.getIdentifiedDbms()].column_comment\n                        if hasattr(_, 'query'):\n                            if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n                                query = _.query % (unsafeSQLIdentificatorNaming(conf.db.upper()), unsafeSQLIdentificatorNaming(tbl.upper()), unsafeSQLIdentificatorNaming(column.upper()))\n                            else:\n                                query = _.query % (unsafeSQLIdentificatorNaming(conf.db), unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(column))\n                            comment = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                            if not isNoneValue(comment):\n                                infoMsg = \"retrieved comment '%s' for column '%s'\" % (comment, column)\n                                logger.info(infoMsg)\n                        else:\n                            warnMsg = 'on %s it is not ' % Backend.getIdentifiedDbms()\n                            warnMsg += 'possible to get column comments'\n                            singleTimeWarnMessage(warnMsg)\n                    if not onlyColNames:\n                        if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL, DBMS.HSQLDB, DBMS.H2, DBMS.VERTICA, DBMS.PRESTO, DBMS.CRATEDB, DBMS.CACHE, DBMS.FRONTBASE, DBMS.VIRTUOSO, DBMS.CLICKHOUSE):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl), column, unsafeSQLIdentificatorNaming(conf.db))\n                        elif Backend.getIdentifiedDbms() in (DBMS.ORACLE, DBMS.DB2, DBMS.DERBY, DBMS.ALTIBASE, DBMS.MIMERSQL):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl.upper()), column, unsafeSQLIdentificatorNaming(conf.db.upper()))\n                        elif Backend.isDbms(DBMS.MSSQL):\n                            query = rootQuery.blind.query2 % (conf.db, conf.db, conf.db, conf.db, column, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl).split('.')[-1])\n                        elif Backend.isDbms(DBMS.FIREBIRD):\n                            query = rootQuery.blind.query2 % (unsafeSQLIdentificatorNaming(tbl), column)\n                        elif Backend.isDbms(DBMS.INFORMIX):\n                            query = rootQuery.blind.query2 % (conf.db, conf.db, conf.db, conf.db, conf.db, unsafeSQLIdentificatorNaming(tbl), column)\n                        elif Backend.isDbms(DBMS.MONETDB):\n                            query = rootQuery.blind.query2 % (column, unsafeSQLIdentificatorNaming(tbl), unsafeSQLIdentificatorNaming(conf.db))\n                        colType = unArrayizeValue(inject.getValue(query, union=False, error=False))\n                        key = int(colType) if hasattr(colType, 'isdigit') and colType.isdigit() else colType\n                        if Backend.isDbms(DBMS.FIREBIRD):\n                            colType = FIREBIRD_TYPES.get(key, colType)\n                        elif Backend.isDbms(DBMS.INFORMIX):\n                            notNull = False\n                            if isinstance(key, int) and key > 255:\n                                key -= 256\n                                notNull = True\n                            colType = INFORMIX_TYPES.get(key, colType)\n                            if notNull:\n                                colType = '%s NOT NULL' % colType\n                        column = safeSQLIdentificatorNaming(column)\n                        columns[column] = colType\n                    else:\n                        column = safeSQLIdentificatorNaming(column)\n                        columns[column] = None\n            if columns:\n                if conf.db in kb.data.cachedColumns:\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)][safeSQLIdentificatorNaming(tbl, True)] = columns\n                else:\n                    table[safeSQLIdentificatorNaming(tbl, True)] = columns\n                    kb.data.cachedColumns[safeSQLIdentificatorNaming(conf.db)] = table\n    if not kb.data.cachedColumns:\n        warnMsg = 'unable to retrieve column names for '\n        warnMsg += \"table '%s' \" % unsafeSQLIdentificatorNaming(unArrayizeValue(tblList)) if len(tblList) == 1 else 'any table '\n        if METADB_SUFFIX not in conf.db:\n            warnMsg += \"in database '%s'\" % unsafeSQLIdentificatorNaming(conf.db)\n        logger.warning(warnMsg)\n        if bruteForce is None:\n            return self.getColumns(onlyColNames=onlyColNames, colTuple=colTuple, bruteForce=True)\n    return kb.data.cachedColumns"
        ]
    },
    {
        "func_name": "getSchema",
        "original": "@stackedmethod\ndef getSchema(self):\n    infoMsg = 'enumerating database management system schema'\n    logger.info(infoMsg)\n    try:\n        pushValue(conf.db)\n        pushValue(conf.tbl)\n        pushValue(conf.col)\n        kb.data.cachedTables = {}\n        kb.data.cachedColumns = {}\n        self.getTables()\n        infoMsg = 'fetched tables: '\n        infoMsg += ', '.join(['%s' % ', '.join((\"'%s%s%s'\" % (unsafeSQLIdentificatorNaming(db), '..' if Backend.isDbms(DBMS.MSSQL) or Backend.isDbms(DBMS.SYBASE) else '.', unsafeSQLIdentificatorNaming(_)) for _ in tbl)) for (db, tbl) in kb.data.cachedTables.items()])\n        logger.info(infoMsg)\n        for (db, tables) in kb.data.cachedTables.items():\n            for tbl in tables:\n                conf.db = db\n                conf.tbl = tbl\n                self.getColumns()\n    finally:\n        conf.col = popValue()\n        conf.tbl = popValue()\n        conf.db = popValue()\n    return kb.data.cachedColumns",
        "mutated": [
            "@stackedmethod\ndef getSchema(self):\n    if False:\n        i = 10\n    infoMsg = 'enumerating database management system schema'\n    logger.info(infoMsg)\n    try:\n        pushValue(conf.db)\n        pushValue(conf.tbl)\n        pushValue(conf.col)\n        kb.data.cachedTables = {}\n        kb.data.cachedColumns = {}\n        self.getTables()\n        infoMsg = 'fetched tables: '\n        infoMsg += ', '.join(['%s' % ', '.join((\"'%s%s%s'\" % (unsafeSQLIdentificatorNaming(db), '..' if Backend.isDbms(DBMS.MSSQL) or Backend.isDbms(DBMS.SYBASE) else '.', unsafeSQLIdentificatorNaming(_)) for _ in tbl)) for (db, tbl) in kb.data.cachedTables.items()])\n        logger.info(infoMsg)\n        for (db, tables) in kb.data.cachedTables.items():\n            for tbl in tables:\n                conf.db = db\n                conf.tbl = tbl\n                self.getColumns()\n    finally:\n        conf.col = popValue()\n        conf.tbl = popValue()\n        conf.db = popValue()\n    return kb.data.cachedColumns",
            "@stackedmethod\ndef getSchema(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    infoMsg = 'enumerating database management system schema'\n    logger.info(infoMsg)\n    try:\n        pushValue(conf.db)\n        pushValue(conf.tbl)\n        pushValue(conf.col)\n        kb.data.cachedTables = {}\n        kb.data.cachedColumns = {}\n        self.getTables()\n        infoMsg = 'fetched tables: '\n        infoMsg += ', '.join(['%s' % ', '.join((\"'%s%s%s'\" % (unsafeSQLIdentificatorNaming(db), '..' if Backend.isDbms(DBMS.MSSQL) or Backend.isDbms(DBMS.SYBASE) else '.', unsafeSQLIdentificatorNaming(_)) for _ in tbl)) for (db, tbl) in kb.data.cachedTables.items()])\n        logger.info(infoMsg)\n        for (db, tables) in kb.data.cachedTables.items():\n            for tbl in tables:\n                conf.db = db\n                conf.tbl = tbl\n                self.getColumns()\n    finally:\n        conf.col = popValue()\n        conf.tbl = popValue()\n        conf.db = popValue()\n    return kb.data.cachedColumns",
            "@stackedmethod\ndef getSchema(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    infoMsg = 'enumerating database management system schema'\n    logger.info(infoMsg)\n    try:\n        pushValue(conf.db)\n        pushValue(conf.tbl)\n        pushValue(conf.col)\n        kb.data.cachedTables = {}\n        kb.data.cachedColumns = {}\n        self.getTables()\n        infoMsg = 'fetched tables: '\n        infoMsg += ', '.join(['%s' % ', '.join((\"'%s%s%s'\" % (unsafeSQLIdentificatorNaming(db), '..' if Backend.isDbms(DBMS.MSSQL) or Backend.isDbms(DBMS.SYBASE) else '.', unsafeSQLIdentificatorNaming(_)) for _ in tbl)) for (db, tbl) in kb.data.cachedTables.items()])\n        logger.info(infoMsg)\n        for (db, tables) in kb.data.cachedTables.items():\n            for tbl in tables:\n                conf.db = db\n                conf.tbl = tbl\n                self.getColumns()\n    finally:\n        conf.col = popValue()\n        conf.tbl = popValue()\n        conf.db = popValue()\n    return kb.data.cachedColumns",
            "@stackedmethod\ndef getSchema(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    infoMsg = 'enumerating database management system schema'\n    logger.info(infoMsg)\n    try:\n        pushValue(conf.db)\n        pushValue(conf.tbl)\n        pushValue(conf.col)\n        kb.data.cachedTables = {}\n        kb.data.cachedColumns = {}\n        self.getTables()\n        infoMsg = 'fetched tables: '\n        infoMsg += ', '.join(['%s' % ', '.join((\"'%s%s%s'\" % (unsafeSQLIdentificatorNaming(db), '..' if Backend.isDbms(DBMS.MSSQL) or Backend.isDbms(DBMS.SYBASE) else '.', unsafeSQLIdentificatorNaming(_)) for _ in tbl)) for (db, tbl) in kb.data.cachedTables.items()])\n        logger.info(infoMsg)\n        for (db, tables) in kb.data.cachedTables.items():\n            for tbl in tables:\n                conf.db = db\n                conf.tbl = tbl\n                self.getColumns()\n    finally:\n        conf.col = popValue()\n        conf.tbl = popValue()\n        conf.db = popValue()\n    return kb.data.cachedColumns",
            "@stackedmethod\ndef getSchema(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    infoMsg = 'enumerating database management system schema'\n    logger.info(infoMsg)\n    try:\n        pushValue(conf.db)\n        pushValue(conf.tbl)\n        pushValue(conf.col)\n        kb.data.cachedTables = {}\n        kb.data.cachedColumns = {}\n        self.getTables()\n        infoMsg = 'fetched tables: '\n        infoMsg += ', '.join(['%s' % ', '.join((\"'%s%s%s'\" % (unsafeSQLIdentificatorNaming(db), '..' if Backend.isDbms(DBMS.MSSQL) or Backend.isDbms(DBMS.SYBASE) else '.', unsafeSQLIdentificatorNaming(_)) for _ in tbl)) for (db, tbl) in kb.data.cachedTables.items()])\n        logger.info(infoMsg)\n        for (db, tables) in kb.data.cachedTables.items():\n            for tbl in tables:\n                conf.db = db\n                conf.tbl = tbl\n                self.getColumns()\n    finally:\n        conf.col = popValue()\n        conf.tbl = popValue()\n        conf.db = popValue()\n    return kb.data.cachedColumns"
        ]
    },
    {
        "func_name": "_tableGetCount",
        "original": "def _tableGetCount(self, db, table):\n    if not db or not table:\n        return None\n    if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        db = db.upper()\n        table = table.upper()\n    if Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD, DBMS.MCKOI, DBMS.EXTREMEDB):\n        query = 'SELECT %s FROM %s' % (queries[Backend.getIdentifiedDbms()].count.query % '*', safeSQLIdentificatorNaming(table, True))\n    else:\n        query = 'SELECT %s FROM %s.%s' % (queries[Backend.getIdentifiedDbms()].count.query % '*', safeSQLIdentificatorNaming(db), safeSQLIdentificatorNaming(table, True))\n    query = agent.whereQuery(query)\n    count = inject.getValue(query, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n    if isNumPosStrValue(count):\n        if safeSQLIdentificatorNaming(db) not in kb.data.cachedCounts:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)] = {}\n        if int(count) in kb.data.cachedCounts[safeSQLIdentificatorNaming(db)]:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)][int(count)].append(safeSQLIdentificatorNaming(table, True))\n        else:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)][int(count)] = [safeSQLIdentificatorNaming(table, True)]",
        "mutated": [
            "def _tableGetCount(self, db, table):\n    if False:\n        i = 10\n    if not db or not table:\n        return None\n    if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        db = db.upper()\n        table = table.upper()\n    if Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD, DBMS.MCKOI, DBMS.EXTREMEDB):\n        query = 'SELECT %s FROM %s' % (queries[Backend.getIdentifiedDbms()].count.query % '*', safeSQLIdentificatorNaming(table, True))\n    else:\n        query = 'SELECT %s FROM %s.%s' % (queries[Backend.getIdentifiedDbms()].count.query % '*', safeSQLIdentificatorNaming(db), safeSQLIdentificatorNaming(table, True))\n    query = agent.whereQuery(query)\n    count = inject.getValue(query, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n    if isNumPosStrValue(count):\n        if safeSQLIdentificatorNaming(db) not in kb.data.cachedCounts:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)] = {}\n        if int(count) in kb.data.cachedCounts[safeSQLIdentificatorNaming(db)]:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)][int(count)].append(safeSQLIdentificatorNaming(table, True))\n        else:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)][int(count)] = [safeSQLIdentificatorNaming(table, True)]",
            "def _tableGetCount(self, db, table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not db or not table:\n        return None\n    if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        db = db.upper()\n        table = table.upper()\n    if Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD, DBMS.MCKOI, DBMS.EXTREMEDB):\n        query = 'SELECT %s FROM %s' % (queries[Backend.getIdentifiedDbms()].count.query % '*', safeSQLIdentificatorNaming(table, True))\n    else:\n        query = 'SELECT %s FROM %s.%s' % (queries[Backend.getIdentifiedDbms()].count.query % '*', safeSQLIdentificatorNaming(db), safeSQLIdentificatorNaming(table, True))\n    query = agent.whereQuery(query)\n    count = inject.getValue(query, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n    if isNumPosStrValue(count):\n        if safeSQLIdentificatorNaming(db) not in kb.data.cachedCounts:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)] = {}\n        if int(count) in kb.data.cachedCounts[safeSQLIdentificatorNaming(db)]:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)][int(count)].append(safeSQLIdentificatorNaming(table, True))\n        else:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)][int(count)] = [safeSQLIdentificatorNaming(table, True)]",
            "def _tableGetCount(self, db, table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not db or not table:\n        return None\n    if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        db = db.upper()\n        table = table.upper()\n    if Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD, DBMS.MCKOI, DBMS.EXTREMEDB):\n        query = 'SELECT %s FROM %s' % (queries[Backend.getIdentifiedDbms()].count.query % '*', safeSQLIdentificatorNaming(table, True))\n    else:\n        query = 'SELECT %s FROM %s.%s' % (queries[Backend.getIdentifiedDbms()].count.query % '*', safeSQLIdentificatorNaming(db), safeSQLIdentificatorNaming(table, True))\n    query = agent.whereQuery(query)\n    count = inject.getValue(query, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n    if isNumPosStrValue(count):\n        if safeSQLIdentificatorNaming(db) not in kb.data.cachedCounts:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)] = {}\n        if int(count) in kb.data.cachedCounts[safeSQLIdentificatorNaming(db)]:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)][int(count)].append(safeSQLIdentificatorNaming(table, True))\n        else:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)][int(count)] = [safeSQLIdentificatorNaming(table, True)]",
            "def _tableGetCount(self, db, table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not db or not table:\n        return None\n    if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        db = db.upper()\n        table = table.upper()\n    if Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD, DBMS.MCKOI, DBMS.EXTREMEDB):\n        query = 'SELECT %s FROM %s' % (queries[Backend.getIdentifiedDbms()].count.query % '*', safeSQLIdentificatorNaming(table, True))\n    else:\n        query = 'SELECT %s FROM %s.%s' % (queries[Backend.getIdentifiedDbms()].count.query % '*', safeSQLIdentificatorNaming(db), safeSQLIdentificatorNaming(table, True))\n    query = agent.whereQuery(query)\n    count = inject.getValue(query, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n    if isNumPosStrValue(count):\n        if safeSQLIdentificatorNaming(db) not in kb.data.cachedCounts:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)] = {}\n        if int(count) in kb.data.cachedCounts[safeSQLIdentificatorNaming(db)]:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)][int(count)].append(safeSQLIdentificatorNaming(table, True))\n        else:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)][int(count)] = [safeSQLIdentificatorNaming(table, True)]",
            "def _tableGetCount(self, db, table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not db or not table:\n        return None\n    if Backend.getIdentifiedDbms() in UPPER_CASE_DBMSES:\n        db = db.upper()\n        table = table.upper()\n    if Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD, DBMS.MCKOI, DBMS.EXTREMEDB):\n        query = 'SELECT %s FROM %s' % (queries[Backend.getIdentifiedDbms()].count.query % '*', safeSQLIdentificatorNaming(table, True))\n    else:\n        query = 'SELECT %s FROM %s.%s' % (queries[Backend.getIdentifiedDbms()].count.query % '*', safeSQLIdentificatorNaming(db), safeSQLIdentificatorNaming(table, True))\n    query = agent.whereQuery(query)\n    count = inject.getValue(query, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n    if isNumPosStrValue(count):\n        if safeSQLIdentificatorNaming(db) not in kb.data.cachedCounts:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)] = {}\n        if int(count) in kb.data.cachedCounts[safeSQLIdentificatorNaming(db)]:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)][int(count)].append(safeSQLIdentificatorNaming(table, True))\n        else:\n            kb.data.cachedCounts[safeSQLIdentificatorNaming(db)][int(count)] = [safeSQLIdentificatorNaming(table, True)]"
        ]
    },
    {
        "func_name": "getCount",
        "original": "def getCount(self):\n    if not conf.tbl:\n        warnMsg = 'missing table parameter, sqlmap will retrieve '\n        warnMsg += 'the number of entries for all database '\n        warnMsg += \"management system databases' tables\"\n        logger.warning(warnMsg)\n    elif '.' in conf.tbl:\n        if not conf.db:\n            (conf.db, conf.tbl) = conf.tbl.split('.', 1)\n    if conf.tbl is not None and conf.db is None and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD, DBMS.MCKOI, DBMS.EXTREMEDB)):\n        warnMsg = 'missing database parameter. sqlmap is going to '\n        warnMsg += 'use the current database to retrieve the '\n        warnMsg += \"number of entries for table '%s'\" % unsafeSQLIdentificatorNaming(conf.tbl)\n        logger.warning(warnMsg)\n        conf.db = self.getCurrentDb()\n    self.forceDbmsEnum()\n    if conf.tbl:\n        for table in conf.tbl.split(','):\n            self._tableGetCount(conf.db, table)\n    else:\n        self.getTables()\n        for (db, tables) in kb.data.cachedTables.items():\n            for table in tables:\n                self._tableGetCount(db, table)\n    return kb.data.cachedCounts",
        "mutated": [
            "def getCount(self):\n    if False:\n        i = 10\n    if not conf.tbl:\n        warnMsg = 'missing table parameter, sqlmap will retrieve '\n        warnMsg += 'the number of entries for all database '\n        warnMsg += \"management system databases' tables\"\n        logger.warning(warnMsg)\n    elif '.' in conf.tbl:\n        if not conf.db:\n            (conf.db, conf.tbl) = conf.tbl.split('.', 1)\n    if conf.tbl is not None and conf.db is None and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD, DBMS.MCKOI, DBMS.EXTREMEDB)):\n        warnMsg = 'missing database parameter. sqlmap is going to '\n        warnMsg += 'use the current database to retrieve the '\n        warnMsg += \"number of entries for table '%s'\" % unsafeSQLIdentificatorNaming(conf.tbl)\n        logger.warning(warnMsg)\n        conf.db = self.getCurrentDb()\n    self.forceDbmsEnum()\n    if conf.tbl:\n        for table in conf.tbl.split(','):\n            self._tableGetCount(conf.db, table)\n    else:\n        self.getTables()\n        for (db, tables) in kb.data.cachedTables.items():\n            for table in tables:\n                self._tableGetCount(db, table)\n    return kb.data.cachedCounts",
            "def getCount(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not conf.tbl:\n        warnMsg = 'missing table parameter, sqlmap will retrieve '\n        warnMsg += 'the number of entries for all database '\n        warnMsg += \"management system databases' tables\"\n        logger.warning(warnMsg)\n    elif '.' in conf.tbl:\n        if not conf.db:\n            (conf.db, conf.tbl) = conf.tbl.split('.', 1)\n    if conf.tbl is not None and conf.db is None and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD, DBMS.MCKOI, DBMS.EXTREMEDB)):\n        warnMsg = 'missing database parameter. sqlmap is going to '\n        warnMsg += 'use the current database to retrieve the '\n        warnMsg += \"number of entries for table '%s'\" % unsafeSQLIdentificatorNaming(conf.tbl)\n        logger.warning(warnMsg)\n        conf.db = self.getCurrentDb()\n    self.forceDbmsEnum()\n    if conf.tbl:\n        for table in conf.tbl.split(','):\n            self._tableGetCount(conf.db, table)\n    else:\n        self.getTables()\n        for (db, tables) in kb.data.cachedTables.items():\n            for table in tables:\n                self._tableGetCount(db, table)\n    return kb.data.cachedCounts",
            "def getCount(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not conf.tbl:\n        warnMsg = 'missing table parameter, sqlmap will retrieve '\n        warnMsg += 'the number of entries for all database '\n        warnMsg += \"management system databases' tables\"\n        logger.warning(warnMsg)\n    elif '.' in conf.tbl:\n        if not conf.db:\n            (conf.db, conf.tbl) = conf.tbl.split('.', 1)\n    if conf.tbl is not None and conf.db is None and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD, DBMS.MCKOI, DBMS.EXTREMEDB)):\n        warnMsg = 'missing database parameter. sqlmap is going to '\n        warnMsg += 'use the current database to retrieve the '\n        warnMsg += \"number of entries for table '%s'\" % unsafeSQLIdentificatorNaming(conf.tbl)\n        logger.warning(warnMsg)\n        conf.db = self.getCurrentDb()\n    self.forceDbmsEnum()\n    if conf.tbl:\n        for table in conf.tbl.split(','):\n            self._tableGetCount(conf.db, table)\n    else:\n        self.getTables()\n        for (db, tables) in kb.data.cachedTables.items():\n            for table in tables:\n                self._tableGetCount(db, table)\n    return kb.data.cachedCounts",
            "def getCount(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not conf.tbl:\n        warnMsg = 'missing table parameter, sqlmap will retrieve '\n        warnMsg += 'the number of entries for all database '\n        warnMsg += \"management system databases' tables\"\n        logger.warning(warnMsg)\n    elif '.' in conf.tbl:\n        if not conf.db:\n            (conf.db, conf.tbl) = conf.tbl.split('.', 1)\n    if conf.tbl is not None and conf.db is None and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD, DBMS.MCKOI, DBMS.EXTREMEDB)):\n        warnMsg = 'missing database parameter. sqlmap is going to '\n        warnMsg += 'use the current database to retrieve the '\n        warnMsg += \"number of entries for table '%s'\" % unsafeSQLIdentificatorNaming(conf.tbl)\n        logger.warning(warnMsg)\n        conf.db = self.getCurrentDb()\n    self.forceDbmsEnum()\n    if conf.tbl:\n        for table in conf.tbl.split(','):\n            self._tableGetCount(conf.db, table)\n    else:\n        self.getTables()\n        for (db, tables) in kb.data.cachedTables.items():\n            for table in tables:\n                self._tableGetCount(db, table)\n    return kb.data.cachedCounts",
            "def getCount(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not conf.tbl:\n        warnMsg = 'missing table parameter, sqlmap will retrieve '\n        warnMsg += 'the number of entries for all database '\n        warnMsg += \"management system databases' tables\"\n        logger.warning(warnMsg)\n    elif '.' in conf.tbl:\n        if not conf.db:\n            (conf.db, conf.tbl) = conf.tbl.split('.', 1)\n    if conf.tbl is not None and conf.db is None and (Backend.getIdentifiedDbms() not in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD, DBMS.MCKOI, DBMS.EXTREMEDB)):\n        warnMsg = 'missing database parameter. sqlmap is going to '\n        warnMsg += 'use the current database to retrieve the '\n        warnMsg += \"number of entries for table '%s'\" % unsafeSQLIdentificatorNaming(conf.tbl)\n        logger.warning(warnMsg)\n        conf.db = self.getCurrentDb()\n    self.forceDbmsEnum()\n    if conf.tbl:\n        for table in conf.tbl.split(','):\n            self._tableGetCount(conf.db, table)\n    else:\n        self.getTables()\n        for (db, tables) in kb.data.cachedTables.items():\n            for table in tables:\n                self._tableGetCount(db, table)\n    return kb.data.cachedCounts"
        ]
    },
    {
        "func_name": "getStatements",
        "original": "def getStatements(self):\n    infoMsg = 'fetching SQL statements'\n    logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].statements\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n            query = rootQuery.inband.query2\n        else:\n            query = rootQuery.inband.query\n        while True:\n            values = inject.getValue(query, blind=False, time=False)\n            if not isNoneValue(values):\n                kb.data.cachedStatements = []\n                for value in arrayizeValue(values):\n                    value = (unArrayizeValue(value) or '').strip()\n                    if not isNoneValue(value):\n                        kb.data.cachedStatements.append(value.strip())\n            elif Backend.isDbms(DBMS.PGSQL) and 'current_query' not in query:\n                query = query.replace('query', 'current_query')\n                continue\n            break\n    if not kb.data.cachedStatements and isInferenceAvailable() and (not conf.direct):\n        infoMsg = 'fetching number of statements'\n        logger.info(infoMsg)\n        query = rootQuery.blind.count\n        if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n            query = re.sub('INFORMATION_SCHEMA', 'DATA_DICTIONARY', query, flags=re.I)\n        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n        if count == 0:\n            return kb.data.cachedStatements\n        elif not isNumPosStrValue(count):\n            errMsg = 'unable to retrieve the number of statements'\n            raise SqlmapNoneDataException(errMsg)\n        plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n        indexRange = getLimitRange(count, plusOne=plusOne)\n        for index in indexRange:\n            value = None\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):\n                query = rootQuery.blind.query3 % index\n                identifier = unArrayizeValue(inject.getValue(query, union=False, error=False, expected=EXPECTED.INT))\n                if not isNoneValue(identifier):\n                    query = rootQuery.blind.query2 % identifier\n                    value = unArrayizeValue(inject.getValue(query, union=False, error=False, expected=EXPECTED.INT))\n            if isNoneValue(value):\n                query = rootQuery.blind.query % index\n                if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                    query = re.sub('INFORMATION_SCHEMA', 'DATA_DICTIONARY', query, flags=re.I)\n                value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n            if not isNoneValue(value):\n                kb.data.cachedStatements.append(value)\n    if not kb.data.cachedStatements:\n        errMsg = 'unable to retrieve the statements'\n        logger.error(errMsg)\n    else:\n        kb.data.cachedStatements = [_.replace(REFLECTED_VALUE_MARKER, '<payload>') for _ in kb.data.cachedStatements]\n    return kb.data.cachedStatements",
        "mutated": [
            "def getStatements(self):\n    if False:\n        i = 10\n    infoMsg = 'fetching SQL statements'\n    logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].statements\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n            query = rootQuery.inband.query2\n        else:\n            query = rootQuery.inband.query\n        while True:\n            values = inject.getValue(query, blind=False, time=False)\n            if not isNoneValue(values):\n                kb.data.cachedStatements = []\n                for value in arrayizeValue(values):\n                    value = (unArrayizeValue(value) or '').strip()\n                    if not isNoneValue(value):\n                        kb.data.cachedStatements.append(value.strip())\n            elif Backend.isDbms(DBMS.PGSQL) and 'current_query' not in query:\n                query = query.replace('query', 'current_query')\n                continue\n            break\n    if not kb.data.cachedStatements and isInferenceAvailable() and (not conf.direct):\n        infoMsg = 'fetching number of statements'\n        logger.info(infoMsg)\n        query = rootQuery.blind.count\n        if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n            query = re.sub('INFORMATION_SCHEMA', 'DATA_DICTIONARY', query, flags=re.I)\n        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n        if count == 0:\n            return kb.data.cachedStatements\n        elif not isNumPosStrValue(count):\n            errMsg = 'unable to retrieve the number of statements'\n            raise SqlmapNoneDataException(errMsg)\n        plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n        indexRange = getLimitRange(count, plusOne=plusOne)\n        for index in indexRange:\n            value = None\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):\n                query = rootQuery.blind.query3 % index\n                identifier = unArrayizeValue(inject.getValue(query, union=False, error=False, expected=EXPECTED.INT))\n                if not isNoneValue(identifier):\n                    query = rootQuery.blind.query2 % identifier\n                    value = unArrayizeValue(inject.getValue(query, union=False, error=False, expected=EXPECTED.INT))\n            if isNoneValue(value):\n                query = rootQuery.blind.query % index\n                if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                    query = re.sub('INFORMATION_SCHEMA', 'DATA_DICTIONARY', query, flags=re.I)\n                value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n            if not isNoneValue(value):\n                kb.data.cachedStatements.append(value)\n    if not kb.data.cachedStatements:\n        errMsg = 'unable to retrieve the statements'\n        logger.error(errMsg)\n    else:\n        kb.data.cachedStatements = [_.replace(REFLECTED_VALUE_MARKER, '<payload>') for _ in kb.data.cachedStatements]\n    return kb.data.cachedStatements",
            "def getStatements(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    infoMsg = 'fetching SQL statements'\n    logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].statements\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n            query = rootQuery.inband.query2\n        else:\n            query = rootQuery.inband.query\n        while True:\n            values = inject.getValue(query, blind=False, time=False)\n            if not isNoneValue(values):\n                kb.data.cachedStatements = []\n                for value in arrayizeValue(values):\n                    value = (unArrayizeValue(value) or '').strip()\n                    if not isNoneValue(value):\n                        kb.data.cachedStatements.append(value.strip())\n            elif Backend.isDbms(DBMS.PGSQL) and 'current_query' not in query:\n                query = query.replace('query', 'current_query')\n                continue\n            break\n    if not kb.data.cachedStatements and isInferenceAvailable() and (not conf.direct):\n        infoMsg = 'fetching number of statements'\n        logger.info(infoMsg)\n        query = rootQuery.blind.count\n        if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n            query = re.sub('INFORMATION_SCHEMA', 'DATA_DICTIONARY', query, flags=re.I)\n        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n        if count == 0:\n            return kb.data.cachedStatements\n        elif not isNumPosStrValue(count):\n            errMsg = 'unable to retrieve the number of statements'\n            raise SqlmapNoneDataException(errMsg)\n        plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n        indexRange = getLimitRange(count, plusOne=plusOne)\n        for index in indexRange:\n            value = None\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):\n                query = rootQuery.blind.query3 % index\n                identifier = unArrayizeValue(inject.getValue(query, union=False, error=False, expected=EXPECTED.INT))\n                if not isNoneValue(identifier):\n                    query = rootQuery.blind.query2 % identifier\n                    value = unArrayizeValue(inject.getValue(query, union=False, error=False, expected=EXPECTED.INT))\n            if isNoneValue(value):\n                query = rootQuery.blind.query % index\n                if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                    query = re.sub('INFORMATION_SCHEMA', 'DATA_DICTIONARY', query, flags=re.I)\n                value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n            if not isNoneValue(value):\n                kb.data.cachedStatements.append(value)\n    if not kb.data.cachedStatements:\n        errMsg = 'unable to retrieve the statements'\n        logger.error(errMsg)\n    else:\n        kb.data.cachedStatements = [_.replace(REFLECTED_VALUE_MARKER, '<payload>') for _ in kb.data.cachedStatements]\n    return kb.data.cachedStatements",
            "def getStatements(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    infoMsg = 'fetching SQL statements'\n    logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].statements\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n            query = rootQuery.inband.query2\n        else:\n            query = rootQuery.inband.query\n        while True:\n            values = inject.getValue(query, blind=False, time=False)\n            if not isNoneValue(values):\n                kb.data.cachedStatements = []\n                for value in arrayizeValue(values):\n                    value = (unArrayizeValue(value) or '').strip()\n                    if not isNoneValue(value):\n                        kb.data.cachedStatements.append(value.strip())\n            elif Backend.isDbms(DBMS.PGSQL) and 'current_query' not in query:\n                query = query.replace('query', 'current_query')\n                continue\n            break\n    if not kb.data.cachedStatements and isInferenceAvailable() and (not conf.direct):\n        infoMsg = 'fetching number of statements'\n        logger.info(infoMsg)\n        query = rootQuery.blind.count\n        if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n            query = re.sub('INFORMATION_SCHEMA', 'DATA_DICTIONARY', query, flags=re.I)\n        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n        if count == 0:\n            return kb.data.cachedStatements\n        elif not isNumPosStrValue(count):\n            errMsg = 'unable to retrieve the number of statements'\n            raise SqlmapNoneDataException(errMsg)\n        plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n        indexRange = getLimitRange(count, plusOne=plusOne)\n        for index in indexRange:\n            value = None\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):\n                query = rootQuery.blind.query3 % index\n                identifier = unArrayizeValue(inject.getValue(query, union=False, error=False, expected=EXPECTED.INT))\n                if not isNoneValue(identifier):\n                    query = rootQuery.blind.query2 % identifier\n                    value = unArrayizeValue(inject.getValue(query, union=False, error=False, expected=EXPECTED.INT))\n            if isNoneValue(value):\n                query = rootQuery.blind.query % index\n                if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                    query = re.sub('INFORMATION_SCHEMA', 'DATA_DICTIONARY', query, flags=re.I)\n                value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n            if not isNoneValue(value):\n                kb.data.cachedStatements.append(value)\n    if not kb.data.cachedStatements:\n        errMsg = 'unable to retrieve the statements'\n        logger.error(errMsg)\n    else:\n        kb.data.cachedStatements = [_.replace(REFLECTED_VALUE_MARKER, '<payload>') for _ in kb.data.cachedStatements]\n    return kb.data.cachedStatements",
            "def getStatements(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    infoMsg = 'fetching SQL statements'\n    logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].statements\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n            query = rootQuery.inband.query2\n        else:\n            query = rootQuery.inband.query\n        while True:\n            values = inject.getValue(query, blind=False, time=False)\n            if not isNoneValue(values):\n                kb.data.cachedStatements = []\n                for value in arrayizeValue(values):\n                    value = (unArrayizeValue(value) or '').strip()\n                    if not isNoneValue(value):\n                        kb.data.cachedStatements.append(value.strip())\n            elif Backend.isDbms(DBMS.PGSQL) and 'current_query' not in query:\n                query = query.replace('query', 'current_query')\n                continue\n            break\n    if not kb.data.cachedStatements and isInferenceAvailable() and (not conf.direct):\n        infoMsg = 'fetching number of statements'\n        logger.info(infoMsg)\n        query = rootQuery.blind.count\n        if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n            query = re.sub('INFORMATION_SCHEMA', 'DATA_DICTIONARY', query, flags=re.I)\n        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n        if count == 0:\n            return kb.data.cachedStatements\n        elif not isNumPosStrValue(count):\n            errMsg = 'unable to retrieve the number of statements'\n            raise SqlmapNoneDataException(errMsg)\n        plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n        indexRange = getLimitRange(count, plusOne=plusOne)\n        for index in indexRange:\n            value = None\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):\n                query = rootQuery.blind.query3 % index\n                identifier = unArrayizeValue(inject.getValue(query, union=False, error=False, expected=EXPECTED.INT))\n                if not isNoneValue(identifier):\n                    query = rootQuery.blind.query2 % identifier\n                    value = unArrayizeValue(inject.getValue(query, union=False, error=False, expected=EXPECTED.INT))\n            if isNoneValue(value):\n                query = rootQuery.blind.query % index\n                if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                    query = re.sub('INFORMATION_SCHEMA', 'DATA_DICTIONARY', query, flags=re.I)\n                value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n            if not isNoneValue(value):\n                kb.data.cachedStatements.append(value)\n    if not kb.data.cachedStatements:\n        errMsg = 'unable to retrieve the statements'\n        logger.error(errMsg)\n    else:\n        kb.data.cachedStatements = [_.replace(REFLECTED_VALUE_MARKER, '<payload>') for _ in kb.data.cachedStatements]\n    return kb.data.cachedStatements",
            "def getStatements(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    infoMsg = 'fetching SQL statements'\n    logger.info(infoMsg)\n    rootQuery = queries[Backend.getIdentifiedDbms()].statements\n    if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n        if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n            query = rootQuery.inband.query2\n        else:\n            query = rootQuery.inband.query\n        while True:\n            values = inject.getValue(query, blind=False, time=False)\n            if not isNoneValue(values):\n                kb.data.cachedStatements = []\n                for value in arrayizeValue(values):\n                    value = (unArrayizeValue(value) or '').strip()\n                    if not isNoneValue(value):\n                        kb.data.cachedStatements.append(value.strip())\n            elif Backend.isDbms(DBMS.PGSQL) and 'current_query' not in query:\n                query = query.replace('query', 'current_query')\n                continue\n            break\n    if not kb.data.cachedStatements and isInferenceAvailable() and (not conf.direct):\n        infoMsg = 'fetching number of statements'\n        logger.info(infoMsg)\n        query = rootQuery.blind.count\n        if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n            query = re.sub('INFORMATION_SCHEMA', 'DATA_DICTIONARY', query, flags=re.I)\n        count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n        if count == 0:\n            return kb.data.cachedStatements\n        elif not isNumPosStrValue(count):\n            errMsg = 'unable to retrieve the number of statements'\n            raise SqlmapNoneDataException(errMsg)\n        plusOne = Backend.getIdentifiedDbms() in PLUS_ONE_DBMSES\n        indexRange = getLimitRange(count, plusOne=plusOne)\n        for index in indexRange:\n            value = None\n            if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):\n                query = rootQuery.blind.query3 % index\n                identifier = unArrayizeValue(inject.getValue(query, union=False, error=False, expected=EXPECTED.INT))\n                if not isNoneValue(identifier):\n                    query = rootQuery.blind.query2 % identifier\n                    value = unArrayizeValue(inject.getValue(query, union=False, error=False, expected=EXPECTED.INT))\n            if isNoneValue(value):\n                query = rootQuery.blind.query % index\n                if Backend.isDbms(DBMS.MYSQL) and Backend.isFork(FORK.DRIZZLE):\n                    query = re.sub('INFORMATION_SCHEMA', 'DATA_DICTIONARY', query, flags=re.I)\n                value = unArrayizeValue(inject.getValue(query, union=False, error=False))\n            if not isNoneValue(value):\n                kb.data.cachedStatements.append(value)\n    if not kb.data.cachedStatements:\n        errMsg = 'unable to retrieve the statements'\n        logger.error(errMsg)\n    else:\n        kb.data.cachedStatements = [_.replace(REFLECTED_VALUE_MARKER, '<payload>') for _ in kb.data.cachedStatements]\n    return kb.data.cachedStatements"
        ]
    }
]