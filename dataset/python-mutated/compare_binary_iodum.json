[
    {
        "func_name": "load_tensor_binary",
        "original": "def load_tensor_binary(fobj):\n    \"\"\"Load a tensor dumped by the :class:`BinaryOprIODump` plugin; the actual\n    tensor value dump is implemented by ``mgb::debug::dump_tensor``.\n\n    Args:\n      fobj: file object, or a string that contains the file name.\n\n    Returns:\n      tuple ``(tensor_value, tensor_name)``.\n    \"\"\"\n    if isinstance(fobj, str):\n        with open(fobj, 'rb') as fin:\n            return load_tensor_binary(fin)\n    DTYPE_LIST = {0: np.float32, 1: np.uint8, 2: np.int8, 3: np.int16, 4: np.int32, 8: None, 9: np.float16, 13: np.uint16, 100000: np.uint8, 100001: np.int32, 100002: np.int8}\n    header_fmt = struct.Struct('III')\n    (name_len, dtype, max_ndim) = header_fmt.unpack(fobj.read(header_fmt.size))\n    assert DTYPE_LIST[dtype] is not None, 'Cannot load this tensor: dtype Byte is unsupported.'\n    shape = list(struct.unpack('I' * max_ndim, fobj.read(max_ndim * 4)))\n    while shape[-1] == 0:\n        shape.pop(-1)\n    name = fobj.read(name_len).decode('ascii')\n    return (np.fromfile(fobj, dtype=DTYPE_LIST[dtype]).reshape(shape), name)",
        "mutated": [
            "def load_tensor_binary(fobj):\n    if False:\n        i = 10\n    'Load a tensor dumped by the :class:`BinaryOprIODump` plugin; the actual\\n    tensor value dump is implemented by ``mgb::debug::dump_tensor``.\\n\\n    Args:\\n      fobj: file object, or a string that contains the file name.\\n\\n    Returns:\\n      tuple ``(tensor_value, tensor_name)``.\\n    '\n    if isinstance(fobj, str):\n        with open(fobj, 'rb') as fin:\n            return load_tensor_binary(fin)\n    DTYPE_LIST = {0: np.float32, 1: np.uint8, 2: np.int8, 3: np.int16, 4: np.int32, 8: None, 9: np.float16, 13: np.uint16, 100000: np.uint8, 100001: np.int32, 100002: np.int8}\n    header_fmt = struct.Struct('III')\n    (name_len, dtype, max_ndim) = header_fmt.unpack(fobj.read(header_fmt.size))\n    assert DTYPE_LIST[dtype] is not None, 'Cannot load this tensor: dtype Byte is unsupported.'\n    shape = list(struct.unpack('I' * max_ndim, fobj.read(max_ndim * 4)))\n    while shape[-1] == 0:\n        shape.pop(-1)\n    name = fobj.read(name_len).decode('ascii')\n    return (np.fromfile(fobj, dtype=DTYPE_LIST[dtype]).reshape(shape), name)",
            "def load_tensor_binary(fobj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Load a tensor dumped by the :class:`BinaryOprIODump` plugin; the actual\\n    tensor value dump is implemented by ``mgb::debug::dump_tensor``.\\n\\n    Args:\\n      fobj: file object, or a string that contains the file name.\\n\\n    Returns:\\n      tuple ``(tensor_value, tensor_name)``.\\n    '\n    if isinstance(fobj, str):\n        with open(fobj, 'rb') as fin:\n            return load_tensor_binary(fin)\n    DTYPE_LIST = {0: np.float32, 1: np.uint8, 2: np.int8, 3: np.int16, 4: np.int32, 8: None, 9: np.float16, 13: np.uint16, 100000: np.uint8, 100001: np.int32, 100002: np.int8}\n    header_fmt = struct.Struct('III')\n    (name_len, dtype, max_ndim) = header_fmt.unpack(fobj.read(header_fmt.size))\n    assert DTYPE_LIST[dtype] is not None, 'Cannot load this tensor: dtype Byte is unsupported.'\n    shape = list(struct.unpack('I' * max_ndim, fobj.read(max_ndim * 4)))\n    while shape[-1] == 0:\n        shape.pop(-1)\n    name = fobj.read(name_len).decode('ascii')\n    return (np.fromfile(fobj, dtype=DTYPE_LIST[dtype]).reshape(shape), name)",
            "def load_tensor_binary(fobj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Load a tensor dumped by the :class:`BinaryOprIODump` plugin; the actual\\n    tensor value dump is implemented by ``mgb::debug::dump_tensor``.\\n\\n    Args:\\n      fobj: file object, or a string that contains the file name.\\n\\n    Returns:\\n      tuple ``(tensor_value, tensor_name)``.\\n    '\n    if isinstance(fobj, str):\n        with open(fobj, 'rb') as fin:\n            return load_tensor_binary(fin)\n    DTYPE_LIST = {0: np.float32, 1: np.uint8, 2: np.int8, 3: np.int16, 4: np.int32, 8: None, 9: np.float16, 13: np.uint16, 100000: np.uint8, 100001: np.int32, 100002: np.int8}\n    header_fmt = struct.Struct('III')\n    (name_len, dtype, max_ndim) = header_fmt.unpack(fobj.read(header_fmt.size))\n    assert DTYPE_LIST[dtype] is not None, 'Cannot load this tensor: dtype Byte is unsupported.'\n    shape = list(struct.unpack('I' * max_ndim, fobj.read(max_ndim * 4)))\n    while shape[-1] == 0:\n        shape.pop(-1)\n    name = fobj.read(name_len).decode('ascii')\n    return (np.fromfile(fobj, dtype=DTYPE_LIST[dtype]).reshape(shape), name)",
            "def load_tensor_binary(fobj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Load a tensor dumped by the :class:`BinaryOprIODump` plugin; the actual\\n    tensor value dump is implemented by ``mgb::debug::dump_tensor``.\\n\\n    Args:\\n      fobj: file object, or a string that contains the file name.\\n\\n    Returns:\\n      tuple ``(tensor_value, tensor_name)``.\\n    '\n    if isinstance(fobj, str):\n        with open(fobj, 'rb') as fin:\n            return load_tensor_binary(fin)\n    DTYPE_LIST = {0: np.float32, 1: np.uint8, 2: np.int8, 3: np.int16, 4: np.int32, 8: None, 9: np.float16, 13: np.uint16, 100000: np.uint8, 100001: np.int32, 100002: np.int8}\n    header_fmt = struct.Struct('III')\n    (name_len, dtype, max_ndim) = header_fmt.unpack(fobj.read(header_fmt.size))\n    assert DTYPE_LIST[dtype] is not None, 'Cannot load this tensor: dtype Byte is unsupported.'\n    shape = list(struct.unpack('I' * max_ndim, fobj.read(max_ndim * 4)))\n    while shape[-1] == 0:\n        shape.pop(-1)\n    name = fobj.read(name_len).decode('ascii')\n    return (np.fromfile(fobj, dtype=DTYPE_LIST[dtype]).reshape(shape), name)",
            "def load_tensor_binary(fobj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Load a tensor dumped by the :class:`BinaryOprIODump` plugin; the actual\\n    tensor value dump is implemented by ``mgb::debug::dump_tensor``.\\n\\n    Args:\\n      fobj: file object, or a string that contains the file name.\\n\\n    Returns:\\n      tuple ``(tensor_value, tensor_name)``.\\n    '\n    if isinstance(fobj, str):\n        with open(fobj, 'rb') as fin:\n            return load_tensor_binary(fin)\n    DTYPE_LIST = {0: np.float32, 1: np.uint8, 2: np.int8, 3: np.int16, 4: np.int32, 8: None, 9: np.float16, 13: np.uint16, 100000: np.uint8, 100001: np.int32, 100002: np.int8}\n    header_fmt = struct.Struct('III')\n    (name_len, dtype, max_ndim) = header_fmt.unpack(fobj.read(header_fmt.size))\n    assert DTYPE_LIST[dtype] is not None, 'Cannot load this tensor: dtype Byte is unsupported.'\n    shape = list(struct.unpack('I' * max_ndim, fobj.read(max_ndim * 4)))\n    while shape[-1] == 0:\n        shape.pop(-1)\n    name = fobj.read(name_len).decode('ascii')\n    return (np.fromfile(fobj, dtype=DTYPE_LIST[dtype]).reshape(shape), name)"
        ]
    },
    {
        "func_name": "check",
        "original": "def check(v0, v1, name, max_err):\n    v0 = np.ascontiguousarray(v0, dtype=np.float32)\n    v1 = np.ascontiguousarray(v1, dtype=np.float32)\n    assert np.isfinite(v0.sum()) and np.isfinite(v1.sum()), '{} not finite: sum={} vs sum={}'.format(name, v0.sum(), v1.sum())\n    assert v0.shape == v1.shape, '{} shape mismatch: {} vs {}'.format(name, v0.shape, v1.shape)\n    vdiv = np.max([np.abs(v0), np.abs(v1), np.ones_like(v0)], axis=0)\n    err = np.abs(v0 - v1) / vdiv\n    rst = err > max_err\n    if rst.sum():\n        idx = tuple((i[0] for i in np.nonzero(rst)))\n        raise AssertionError('{} not equal: shape={} nonequal_idx={} v0={} v1={} err={}'.format(name, v0.shape, idx, v0[idx], v1[idx], err[idx]))",
        "mutated": [
            "def check(v0, v1, name, max_err):\n    if False:\n        i = 10\n    v0 = np.ascontiguousarray(v0, dtype=np.float32)\n    v1 = np.ascontiguousarray(v1, dtype=np.float32)\n    assert np.isfinite(v0.sum()) and np.isfinite(v1.sum()), '{} not finite: sum={} vs sum={}'.format(name, v0.sum(), v1.sum())\n    assert v0.shape == v1.shape, '{} shape mismatch: {} vs {}'.format(name, v0.shape, v1.shape)\n    vdiv = np.max([np.abs(v0), np.abs(v1), np.ones_like(v0)], axis=0)\n    err = np.abs(v0 - v1) / vdiv\n    rst = err > max_err\n    if rst.sum():\n        idx = tuple((i[0] for i in np.nonzero(rst)))\n        raise AssertionError('{} not equal: shape={} nonequal_idx={} v0={} v1={} err={}'.format(name, v0.shape, idx, v0[idx], v1[idx], err[idx]))",
            "def check(v0, v1, name, max_err):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    v0 = np.ascontiguousarray(v0, dtype=np.float32)\n    v1 = np.ascontiguousarray(v1, dtype=np.float32)\n    assert np.isfinite(v0.sum()) and np.isfinite(v1.sum()), '{} not finite: sum={} vs sum={}'.format(name, v0.sum(), v1.sum())\n    assert v0.shape == v1.shape, '{} shape mismatch: {} vs {}'.format(name, v0.shape, v1.shape)\n    vdiv = np.max([np.abs(v0), np.abs(v1), np.ones_like(v0)], axis=0)\n    err = np.abs(v0 - v1) / vdiv\n    rst = err > max_err\n    if rst.sum():\n        idx = tuple((i[0] for i in np.nonzero(rst)))\n        raise AssertionError('{} not equal: shape={} nonequal_idx={} v0={} v1={} err={}'.format(name, v0.shape, idx, v0[idx], v1[idx], err[idx]))",
            "def check(v0, v1, name, max_err):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    v0 = np.ascontiguousarray(v0, dtype=np.float32)\n    v1 = np.ascontiguousarray(v1, dtype=np.float32)\n    assert np.isfinite(v0.sum()) and np.isfinite(v1.sum()), '{} not finite: sum={} vs sum={}'.format(name, v0.sum(), v1.sum())\n    assert v0.shape == v1.shape, '{} shape mismatch: {} vs {}'.format(name, v0.shape, v1.shape)\n    vdiv = np.max([np.abs(v0), np.abs(v1), np.ones_like(v0)], axis=0)\n    err = np.abs(v0 - v1) / vdiv\n    rst = err > max_err\n    if rst.sum():\n        idx = tuple((i[0] for i in np.nonzero(rst)))\n        raise AssertionError('{} not equal: shape={} nonequal_idx={} v0={} v1={} err={}'.format(name, v0.shape, idx, v0[idx], v1[idx], err[idx]))",
            "def check(v0, v1, name, max_err):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    v0 = np.ascontiguousarray(v0, dtype=np.float32)\n    v1 = np.ascontiguousarray(v1, dtype=np.float32)\n    assert np.isfinite(v0.sum()) and np.isfinite(v1.sum()), '{} not finite: sum={} vs sum={}'.format(name, v0.sum(), v1.sum())\n    assert v0.shape == v1.shape, '{} shape mismatch: {} vs {}'.format(name, v0.shape, v1.shape)\n    vdiv = np.max([np.abs(v0), np.abs(v1), np.ones_like(v0)], axis=0)\n    err = np.abs(v0 - v1) / vdiv\n    rst = err > max_err\n    if rst.sum():\n        idx = tuple((i[0] for i in np.nonzero(rst)))\n        raise AssertionError('{} not equal: shape={} nonequal_idx={} v0={} v1={} err={}'.format(name, v0.shape, idx, v0[idx], v1[idx], err[idx]))",
            "def check(v0, v1, name, max_err):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    v0 = np.ascontiguousarray(v0, dtype=np.float32)\n    v1 = np.ascontiguousarray(v1, dtype=np.float32)\n    assert np.isfinite(v0.sum()) and np.isfinite(v1.sum()), '{} not finite: sum={} vs sum={}'.format(name, v0.sum(), v1.sum())\n    assert v0.shape == v1.shape, '{} shape mismatch: {} vs {}'.format(name, v0.shape, v1.shape)\n    vdiv = np.max([np.abs(v0), np.abs(v1), np.ones_like(v0)], axis=0)\n    err = np.abs(v0 - v1) / vdiv\n    rst = err > max_err\n    if rst.sum():\n        idx = tuple((i[0] for i in np.nonzero(rst)))\n        raise AssertionError('{} not equal: shape={} nonequal_idx={} v0={} v1={} err={}'.format(name, v0.shape, idx, v0[idx], v1[idx], err[idx]))"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    parser = argparse.ArgumentParser(description='compare tensor dumps generated BinaryOprIODump plugin, it can compare two dirs or two single files', formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('input0', help='dirname or filename')\n    parser.add_argument('input1', help='dirname or filename')\n    parser.add_argument('-e', '--max-err', type=float, default=0.001, help='max allowed error')\n    parser.add_argument('-s', '--stop-on-error', action='store_true', help='do not compare ')\n    args = parser.parse_args()\n    files0 = set()\n    files1 = set()\n    if os.path.isdir(args.input0):\n        assert os.path.isdir(args.input1)\n        name0 = set()\n        name1 = set()\n        for i in os.listdir(args.input0):\n            files0.add(str(Path(args.input0) / i))\n            name0.add(i)\n        for i in os.listdir(args.input1):\n            files1.add(str(Path(args.input1) / i))\n            name1.add(i)\n        assert name0 == name1, 'dir files mismatch: a-b={} b-a={}'.format(name0 - name1, name1 - name0)\n    else:\n        files0.add(args.input0)\n        files1.add(args.input1)\n    files0 = sorted(files0)\n    files1 = sorted(files1)\n    for (i, j) in zip(files0, files1):\n        (val0, name0) = load_tensor_binary(i)\n        (val1, name1) = load_tensor_binary(j)\n        name = '{}: \\n{}\\n{}\\n'.format(i, '\\n  '.join(textwrap.wrap(name0)), '\\n  '.join(textwrap.wrap(name1)))\n        try:\n            check(val0, val1, name, args.max_err)\n        except Exception as exc:\n            if args.stop_on_error:\n                raise exc\n            print(exc)",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    parser = argparse.ArgumentParser(description='compare tensor dumps generated BinaryOprIODump plugin, it can compare two dirs or two single files', formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('input0', help='dirname or filename')\n    parser.add_argument('input1', help='dirname or filename')\n    parser.add_argument('-e', '--max-err', type=float, default=0.001, help='max allowed error')\n    parser.add_argument('-s', '--stop-on-error', action='store_true', help='do not compare ')\n    args = parser.parse_args()\n    files0 = set()\n    files1 = set()\n    if os.path.isdir(args.input0):\n        assert os.path.isdir(args.input1)\n        name0 = set()\n        name1 = set()\n        for i in os.listdir(args.input0):\n            files0.add(str(Path(args.input0) / i))\n            name0.add(i)\n        for i in os.listdir(args.input1):\n            files1.add(str(Path(args.input1) / i))\n            name1.add(i)\n        assert name0 == name1, 'dir files mismatch: a-b={} b-a={}'.format(name0 - name1, name1 - name0)\n    else:\n        files0.add(args.input0)\n        files1.add(args.input1)\n    files0 = sorted(files0)\n    files1 = sorted(files1)\n    for (i, j) in zip(files0, files1):\n        (val0, name0) = load_tensor_binary(i)\n        (val1, name1) = load_tensor_binary(j)\n        name = '{}: \\n{}\\n{}\\n'.format(i, '\\n  '.join(textwrap.wrap(name0)), '\\n  '.join(textwrap.wrap(name1)))\n        try:\n            check(val0, val1, name, args.max_err)\n        except Exception as exc:\n            if args.stop_on_error:\n                raise exc\n            print(exc)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = argparse.ArgumentParser(description='compare tensor dumps generated BinaryOprIODump plugin, it can compare two dirs or two single files', formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('input0', help='dirname or filename')\n    parser.add_argument('input1', help='dirname or filename')\n    parser.add_argument('-e', '--max-err', type=float, default=0.001, help='max allowed error')\n    parser.add_argument('-s', '--stop-on-error', action='store_true', help='do not compare ')\n    args = parser.parse_args()\n    files0 = set()\n    files1 = set()\n    if os.path.isdir(args.input0):\n        assert os.path.isdir(args.input1)\n        name0 = set()\n        name1 = set()\n        for i in os.listdir(args.input0):\n            files0.add(str(Path(args.input0) / i))\n            name0.add(i)\n        for i in os.listdir(args.input1):\n            files1.add(str(Path(args.input1) / i))\n            name1.add(i)\n        assert name0 == name1, 'dir files mismatch: a-b={} b-a={}'.format(name0 - name1, name1 - name0)\n    else:\n        files0.add(args.input0)\n        files1.add(args.input1)\n    files0 = sorted(files0)\n    files1 = sorted(files1)\n    for (i, j) in zip(files0, files1):\n        (val0, name0) = load_tensor_binary(i)\n        (val1, name1) = load_tensor_binary(j)\n        name = '{}: \\n{}\\n{}\\n'.format(i, '\\n  '.join(textwrap.wrap(name0)), '\\n  '.join(textwrap.wrap(name1)))\n        try:\n            check(val0, val1, name, args.max_err)\n        except Exception as exc:\n            if args.stop_on_error:\n                raise exc\n            print(exc)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = argparse.ArgumentParser(description='compare tensor dumps generated BinaryOprIODump plugin, it can compare two dirs or two single files', formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('input0', help='dirname or filename')\n    parser.add_argument('input1', help='dirname or filename')\n    parser.add_argument('-e', '--max-err', type=float, default=0.001, help='max allowed error')\n    parser.add_argument('-s', '--stop-on-error', action='store_true', help='do not compare ')\n    args = parser.parse_args()\n    files0 = set()\n    files1 = set()\n    if os.path.isdir(args.input0):\n        assert os.path.isdir(args.input1)\n        name0 = set()\n        name1 = set()\n        for i in os.listdir(args.input0):\n            files0.add(str(Path(args.input0) / i))\n            name0.add(i)\n        for i in os.listdir(args.input1):\n            files1.add(str(Path(args.input1) / i))\n            name1.add(i)\n        assert name0 == name1, 'dir files mismatch: a-b={} b-a={}'.format(name0 - name1, name1 - name0)\n    else:\n        files0.add(args.input0)\n        files1.add(args.input1)\n    files0 = sorted(files0)\n    files1 = sorted(files1)\n    for (i, j) in zip(files0, files1):\n        (val0, name0) = load_tensor_binary(i)\n        (val1, name1) = load_tensor_binary(j)\n        name = '{}: \\n{}\\n{}\\n'.format(i, '\\n  '.join(textwrap.wrap(name0)), '\\n  '.join(textwrap.wrap(name1)))\n        try:\n            check(val0, val1, name, args.max_err)\n        except Exception as exc:\n            if args.stop_on_error:\n                raise exc\n            print(exc)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = argparse.ArgumentParser(description='compare tensor dumps generated BinaryOprIODump plugin, it can compare two dirs or two single files', formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('input0', help='dirname or filename')\n    parser.add_argument('input1', help='dirname or filename')\n    parser.add_argument('-e', '--max-err', type=float, default=0.001, help='max allowed error')\n    parser.add_argument('-s', '--stop-on-error', action='store_true', help='do not compare ')\n    args = parser.parse_args()\n    files0 = set()\n    files1 = set()\n    if os.path.isdir(args.input0):\n        assert os.path.isdir(args.input1)\n        name0 = set()\n        name1 = set()\n        for i in os.listdir(args.input0):\n            files0.add(str(Path(args.input0) / i))\n            name0.add(i)\n        for i in os.listdir(args.input1):\n            files1.add(str(Path(args.input1) / i))\n            name1.add(i)\n        assert name0 == name1, 'dir files mismatch: a-b={} b-a={}'.format(name0 - name1, name1 - name0)\n    else:\n        files0.add(args.input0)\n        files1.add(args.input1)\n    files0 = sorted(files0)\n    files1 = sorted(files1)\n    for (i, j) in zip(files0, files1):\n        (val0, name0) = load_tensor_binary(i)\n        (val1, name1) = load_tensor_binary(j)\n        name = '{}: \\n{}\\n{}\\n'.format(i, '\\n  '.join(textwrap.wrap(name0)), '\\n  '.join(textwrap.wrap(name1)))\n        try:\n            check(val0, val1, name, args.max_err)\n        except Exception as exc:\n            if args.stop_on_error:\n                raise exc\n            print(exc)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = argparse.ArgumentParser(description='compare tensor dumps generated BinaryOprIODump plugin, it can compare two dirs or two single files', formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('input0', help='dirname or filename')\n    parser.add_argument('input1', help='dirname or filename')\n    parser.add_argument('-e', '--max-err', type=float, default=0.001, help='max allowed error')\n    parser.add_argument('-s', '--stop-on-error', action='store_true', help='do not compare ')\n    args = parser.parse_args()\n    files0 = set()\n    files1 = set()\n    if os.path.isdir(args.input0):\n        assert os.path.isdir(args.input1)\n        name0 = set()\n        name1 = set()\n        for i in os.listdir(args.input0):\n            files0.add(str(Path(args.input0) / i))\n            name0.add(i)\n        for i in os.listdir(args.input1):\n            files1.add(str(Path(args.input1) / i))\n            name1.add(i)\n        assert name0 == name1, 'dir files mismatch: a-b={} b-a={}'.format(name0 - name1, name1 - name0)\n    else:\n        files0.add(args.input0)\n        files1.add(args.input1)\n    files0 = sorted(files0)\n    files1 = sorted(files1)\n    for (i, j) in zip(files0, files1):\n        (val0, name0) = load_tensor_binary(i)\n        (val1, name1) = load_tensor_binary(j)\n        name = '{}: \\n{}\\n{}\\n'.format(i, '\\n  '.join(textwrap.wrap(name0)), '\\n  '.join(textwrap.wrap(name1)))\n        try:\n            check(val0, val1, name, args.max_err)\n        except Exception as exc:\n            if args.stop_on_error:\n                raise exc\n            print(exc)"
        ]
    }
]