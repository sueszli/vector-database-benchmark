[
    {
        "func_name": "pjmap_append",
        "original": "def pjmap_append(pytorch_func_name, pytorch_args, jittor_func_module, jittor_func_name, jittor_args, extras=None, links=None, delete=None):\n    \"\"\" adding map to pjmap for converting new function, example: convert AvgPool2d to Pool\n    args:\n        * `pytorch_func_name`: Pytorch function name\n        * `pytorch_args`: Pytorch parameter list\n        * `jittor_func_module`: to which module the Jittor function belongs\n        * `jittor_func_name`: Jittor function name\n        * `jittor_args`: Jittor parameter list\n        * `extras`: parameter assignment\n        * `links`: connection parameters\n        * `delete`: delete parameters\n\n    example:\n        from jittor.utils.pytorch_converter import pjmap_append\n        pjmap_append(pytorch_func_name='AvgPool2d', \n                    pytorch_args='kernel_size, stride=None, padding=0, dilation=1, return_indices=False',\n                    jittor_func_module='nn',\n                    jittor_func_name='Pool',\n                    jittor_args='kernel_size, stride=None, padding=0, dilation=None, return_indices=None, ceil_mode=False, op=\"maximum\"',\n                    extras={\"op\": \"'mean'\"}) \n    \"\"\"\n    if links == None:\n        links = {}\n    if extras == None:\n        extras = {}\n    if delete == None:\n        delete = []\n    assert isinstance(links, dict)\n    assert isinstance(extras, dict)\n    assert isinstance(delete, list)\n    pjmap[pytorch_func_name] = {'pytorch': {'args': pytorch_args}, 'jittor': {'module': jittor_func_module, 'name': jittor_func_name, 'args': jittor_args}, 'links': links, 'extras': extras, 'delete': delete}",
        "mutated": [
            "def pjmap_append(pytorch_func_name, pytorch_args, jittor_func_module, jittor_func_name, jittor_args, extras=None, links=None, delete=None):\n    if False:\n        i = 10\n    ' adding map to pjmap for converting new function, example: convert AvgPool2d to Pool\\n    args:\\n        * `pytorch_func_name`: Pytorch function name\\n        * `pytorch_args`: Pytorch parameter list\\n        * `jittor_func_module`: to which module the Jittor function belongs\\n        * `jittor_func_name`: Jittor function name\\n        * `jittor_args`: Jittor parameter list\\n        * `extras`: parameter assignment\\n        * `links`: connection parameters\\n        * `delete`: delete parameters\\n\\n    example:\\n        from jittor.utils.pytorch_converter import pjmap_append\\n        pjmap_append(pytorch_func_name=\\'AvgPool2d\\', \\n                    pytorch_args=\\'kernel_size, stride=None, padding=0, dilation=1, return_indices=False\\',\\n                    jittor_func_module=\\'nn\\',\\n                    jittor_func_name=\\'Pool\\',\\n                    jittor_args=\\'kernel_size, stride=None, padding=0, dilation=None, return_indices=None, ceil_mode=False, op=\"maximum\"\\',\\n                    extras={\"op\": \"\\'mean\\'\"}) \\n    '\n    if links == None:\n        links = {}\n    if extras == None:\n        extras = {}\n    if delete == None:\n        delete = []\n    assert isinstance(links, dict)\n    assert isinstance(extras, dict)\n    assert isinstance(delete, list)\n    pjmap[pytorch_func_name] = {'pytorch': {'args': pytorch_args}, 'jittor': {'module': jittor_func_module, 'name': jittor_func_name, 'args': jittor_args}, 'links': links, 'extras': extras, 'delete': delete}",
            "def pjmap_append(pytorch_func_name, pytorch_args, jittor_func_module, jittor_func_name, jittor_args, extras=None, links=None, delete=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' adding map to pjmap for converting new function, example: convert AvgPool2d to Pool\\n    args:\\n        * `pytorch_func_name`: Pytorch function name\\n        * `pytorch_args`: Pytorch parameter list\\n        * `jittor_func_module`: to which module the Jittor function belongs\\n        * `jittor_func_name`: Jittor function name\\n        * `jittor_args`: Jittor parameter list\\n        * `extras`: parameter assignment\\n        * `links`: connection parameters\\n        * `delete`: delete parameters\\n\\n    example:\\n        from jittor.utils.pytorch_converter import pjmap_append\\n        pjmap_append(pytorch_func_name=\\'AvgPool2d\\', \\n                    pytorch_args=\\'kernel_size, stride=None, padding=0, dilation=1, return_indices=False\\',\\n                    jittor_func_module=\\'nn\\',\\n                    jittor_func_name=\\'Pool\\',\\n                    jittor_args=\\'kernel_size, stride=None, padding=0, dilation=None, return_indices=None, ceil_mode=False, op=\"maximum\"\\',\\n                    extras={\"op\": \"\\'mean\\'\"}) \\n    '\n    if links == None:\n        links = {}\n    if extras == None:\n        extras = {}\n    if delete == None:\n        delete = []\n    assert isinstance(links, dict)\n    assert isinstance(extras, dict)\n    assert isinstance(delete, list)\n    pjmap[pytorch_func_name] = {'pytorch': {'args': pytorch_args}, 'jittor': {'module': jittor_func_module, 'name': jittor_func_name, 'args': jittor_args}, 'links': links, 'extras': extras, 'delete': delete}",
            "def pjmap_append(pytorch_func_name, pytorch_args, jittor_func_module, jittor_func_name, jittor_args, extras=None, links=None, delete=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' adding map to pjmap for converting new function, example: convert AvgPool2d to Pool\\n    args:\\n        * `pytorch_func_name`: Pytorch function name\\n        * `pytorch_args`: Pytorch parameter list\\n        * `jittor_func_module`: to which module the Jittor function belongs\\n        * `jittor_func_name`: Jittor function name\\n        * `jittor_args`: Jittor parameter list\\n        * `extras`: parameter assignment\\n        * `links`: connection parameters\\n        * `delete`: delete parameters\\n\\n    example:\\n        from jittor.utils.pytorch_converter import pjmap_append\\n        pjmap_append(pytorch_func_name=\\'AvgPool2d\\', \\n                    pytorch_args=\\'kernel_size, stride=None, padding=0, dilation=1, return_indices=False\\',\\n                    jittor_func_module=\\'nn\\',\\n                    jittor_func_name=\\'Pool\\',\\n                    jittor_args=\\'kernel_size, stride=None, padding=0, dilation=None, return_indices=None, ceil_mode=False, op=\"maximum\"\\',\\n                    extras={\"op\": \"\\'mean\\'\"}) \\n    '\n    if links == None:\n        links = {}\n    if extras == None:\n        extras = {}\n    if delete == None:\n        delete = []\n    assert isinstance(links, dict)\n    assert isinstance(extras, dict)\n    assert isinstance(delete, list)\n    pjmap[pytorch_func_name] = {'pytorch': {'args': pytorch_args}, 'jittor': {'module': jittor_func_module, 'name': jittor_func_name, 'args': jittor_args}, 'links': links, 'extras': extras, 'delete': delete}",
            "def pjmap_append(pytorch_func_name, pytorch_args, jittor_func_module, jittor_func_name, jittor_args, extras=None, links=None, delete=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' adding map to pjmap for converting new function, example: convert AvgPool2d to Pool\\n    args:\\n        * `pytorch_func_name`: Pytorch function name\\n        * `pytorch_args`: Pytorch parameter list\\n        * `jittor_func_module`: to which module the Jittor function belongs\\n        * `jittor_func_name`: Jittor function name\\n        * `jittor_args`: Jittor parameter list\\n        * `extras`: parameter assignment\\n        * `links`: connection parameters\\n        * `delete`: delete parameters\\n\\n    example:\\n        from jittor.utils.pytorch_converter import pjmap_append\\n        pjmap_append(pytorch_func_name=\\'AvgPool2d\\', \\n                    pytorch_args=\\'kernel_size, stride=None, padding=0, dilation=1, return_indices=False\\',\\n                    jittor_func_module=\\'nn\\',\\n                    jittor_func_name=\\'Pool\\',\\n                    jittor_args=\\'kernel_size, stride=None, padding=0, dilation=None, return_indices=None, ceil_mode=False, op=\"maximum\"\\',\\n                    extras={\"op\": \"\\'mean\\'\"}) \\n    '\n    if links == None:\n        links = {}\n    if extras == None:\n        extras = {}\n    if delete == None:\n        delete = []\n    assert isinstance(links, dict)\n    assert isinstance(extras, dict)\n    assert isinstance(delete, list)\n    pjmap[pytorch_func_name] = {'pytorch': {'args': pytorch_args}, 'jittor': {'module': jittor_func_module, 'name': jittor_func_name, 'args': jittor_args}, 'links': links, 'extras': extras, 'delete': delete}",
            "def pjmap_append(pytorch_func_name, pytorch_args, jittor_func_module, jittor_func_name, jittor_args, extras=None, links=None, delete=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' adding map to pjmap for converting new function, example: convert AvgPool2d to Pool\\n    args:\\n        * `pytorch_func_name`: Pytorch function name\\n        * `pytorch_args`: Pytorch parameter list\\n        * `jittor_func_module`: to which module the Jittor function belongs\\n        * `jittor_func_name`: Jittor function name\\n        * `jittor_args`: Jittor parameter list\\n        * `extras`: parameter assignment\\n        * `links`: connection parameters\\n        * `delete`: delete parameters\\n\\n    example:\\n        from jittor.utils.pytorch_converter import pjmap_append\\n        pjmap_append(pytorch_func_name=\\'AvgPool2d\\', \\n                    pytorch_args=\\'kernel_size, stride=None, padding=0, dilation=1, return_indices=False\\',\\n                    jittor_func_module=\\'nn\\',\\n                    jittor_func_name=\\'Pool\\',\\n                    jittor_args=\\'kernel_size, stride=None, padding=0, dilation=None, return_indices=None, ceil_mode=False, op=\"maximum\"\\',\\n                    extras={\"op\": \"\\'mean\\'\"}) \\n    '\n    if links == None:\n        links = {}\n    if extras == None:\n        extras = {}\n    if delete == None:\n        delete = []\n    assert isinstance(links, dict)\n    assert isinstance(extras, dict)\n    assert isinstance(delete, list)\n    pjmap[pytorch_func_name] = {'pytorch': {'args': pytorch_args}, 'jittor': {'module': jittor_func_module, 'name': jittor_func_name, 'args': jittor_args}, 'links': links, 'extras': extras, 'delete': delete}"
        ]
    },
    {
        "func_name": "raise_unsupport",
        "original": "def raise_unsupport(name, ori_src):\n    ret = f\"raise RuntimeError('''original source: <{ori_src.strip()}>, {name} is not supported in Jittor yet. We will appreciate it if you provide an implementation of {name} and make pull request at https://github.com/Jittor/jittor.''')\"\n    print(ret + '\\n')\n    ret = ast.parse(ret).body[0]\n    return ret",
        "mutated": [
            "def raise_unsupport(name, ori_src):\n    if False:\n        i = 10\n    ret = f\"raise RuntimeError('''original source: <{ori_src.strip()}>, {name} is not supported in Jittor yet. We will appreciate it if you provide an implementation of {name} and make pull request at https://github.com/Jittor/jittor.''')\"\n    print(ret + '\\n')\n    ret = ast.parse(ret).body[0]\n    return ret",
            "def raise_unsupport(name, ori_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ret = f\"raise RuntimeError('''original source: <{ori_src.strip()}>, {name} is not supported in Jittor yet. We will appreciate it if you provide an implementation of {name} and make pull request at https://github.com/Jittor/jittor.''')\"\n    print(ret + '\\n')\n    ret = ast.parse(ret).body[0]\n    return ret",
            "def raise_unsupport(name, ori_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ret = f\"raise RuntimeError('''original source: <{ori_src.strip()}>, {name} is not supported in Jittor yet. We will appreciate it if you provide an implementation of {name} and make pull request at https://github.com/Jittor/jittor.''')\"\n    print(ret + '\\n')\n    ret = ast.parse(ret).body[0]\n    return ret",
            "def raise_unsupport(name, ori_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ret = f\"raise RuntimeError('''original source: <{ori_src.strip()}>, {name} is not supported in Jittor yet. We will appreciate it if you provide an implementation of {name} and make pull request at https://github.com/Jittor/jittor.''')\"\n    print(ret + '\\n')\n    ret = ast.parse(ret).body[0]\n    return ret",
            "def raise_unsupport(name, ori_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ret = f\"raise RuntimeError('''original source: <{ori_src.strip()}>, {name} is not supported in Jittor yet. We will appreciate it if you provide an implementation of {name} and make pull request at https://github.com/Jittor/jittor.''')\"\n    print(ret + '\\n')\n    ret = ast.parse(ret).body[0]\n    return ret"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, ex_pjmap):\n    import copy\n    self.pjmap = copy.deepcopy(pjmap)\n    if ex_pjmap:\n        self.pjmap.update(ex_pjmap)\n    self.unsupport_ops = set(unsupport_ops)\n    support_ops = {}\n    for key in self.pjmap.keys():\n        module = self.pjmap[key]['jittor']['module']\n        name = self.pjmap[key]['jittor']['name']\n        if module == 'nn':\n            support_ops[key] = name\n        if key in self.unsupport_ops:\n            self.unsupport_ops.remove(key)\n    self.support_ops = support_ops\n    self.import_flag = []",
        "mutated": [
            "def __init__(self, ex_pjmap):\n    if False:\n        i = 10\n    import copy\n    self.pjmap = copy.deepcopy(pjmap)\n    if ex_pjmap:\n        self.pjmap.update(ex_pjmap)\n    self.unsupport_ops = set(unsupport_ops)\n    support_ops = {}\n    for key in self.pjmap.keys():\n        module = self.pjmap[key]['jittor']['module']\n        name = self.pjmap[key]['jittor']['name']\n        if module == 'nn':\n            support_ops[key] = name\n        if key in self.unsupport_ops:\n            self.unsupport_ops.remove(key)\n    self.support_ops = support_ops\n    self.import_flag = []",
            "def __init__(self, ex_pjmap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    import copy\n    self.pjmap = copy.deepcopy(pjmap)\n    if ex_pjmap:\n        self.pjmap.update(ex_pjmap)\n    self.unsupport_ops = set(unsupport_ops)\n    support_ops = {}\n    for key in self.pjmap.keys():\n        module = self.pjmap[key]['jittor']['module']\n        name = self.pjmap[key]['jittor']['name']\n        if module == 'nn':\n            support_ops[key] = name\n        if key in self.unsupport_ops:\n            self.unsupport_ops.remove(key)\n    self.support_ops = support_ops\n    self.import_flag = []",
            "def __init__(self, ex_pjmap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    import copy\n    self.pjmap = copy.deepcopy(pjmap)\n    if ex_pjmap:\n        self.pjmap.update(ex_pjmap)\n    self.unsupport_ops = set(unsupport_ops)\n    support_ops = {}\n    for key in self.pjmap.keys():\n        module = self.pjmap[key]['jittor']['module']\n        name = self.pjmap[key]['jittor']['name']\n        if module == 'nn':\n            support_ops[key] = name\n        if key in self.unsupport_ops:\n            self.unsupport_ops.remove(key)\n    self.support_ops = support_ops\n    self.import_flag = []",
            "def __init__(self, ex_pjmap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    import copy\n    self.pjmap = copy.deepcopy(pjmap)\n    if ex_pjmap:\n        self.pjmap.update(ex_pjmap)\n    self.unsupport_ops = set(unsupport_ops)\n    support_ops = {}\n    for key in self.pjmap.keys():\n        module = self.pjmap[key]['jittor']['module']\n        name = self.pjmap[key]['jittor']['name']\n        if module == 'nn':\n            support_ops[key] = name\n        if key in self.unsupport_ops:\n            self.unsupport_ops.remove(key)\n    self.support_ops = support_ops\n    self.import_flag = []",
            "def __init__(self, ex_pjmap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    import copy\n    self.pjmap = copy.deepcopy(pjmap)\n    if ex_pjmap:\n        self.pjmap.update(ex_pjmap)\n    self.unsupport_ops = set(unsupport_ops)\n    support_ops = {}\n    for key in self.pjmap.keys():\n        module = self.pjmap[key]['jittor']['module']\n        name = self.pjmap[key]['jittor']['name']\n        if module == 'nn':\n            support_ops[key] = name\n        if key in self.unsupport_ops:\n            self.unsupport_ops.remove(key)\n    self.support_ops = support_ops\n    self.import_flag = []"
        ]
    },
    {
        "func_name": "replace",
        "original": "def replace(self, a):\n    if hasattr(a, 'attr') and a.attr in self.unsupport_ops:\n        ori_src = astunparse.unparse(a)\n        return raise_unsupport(a.attr, ori_src)\n    if hasattr(a, 'id') and a.id in self.unsupport_ops:\n        ori_src = astunparse.unparse(a)\n        return raise_unsupport(a.id, ori_src)\n    if hasattr(a, 'attr'):\n        if a.attr in self.support_ops.keys():\n            a.attr = self.support_ops[a.attr]\n    if hasattr(a, 'id'):\n        if a.id in self.support_ops.keys():\n            a.id = self.support_ops[a.id]\n    return None",
        "mutated": [
            "def replace(self, a):\n    if False:\n        i = 10\n    if hasattr(a, 'attr') and a.attr in self.unsupport_ops:\n        ori_src = astunparse.unparse(a)\n        return raise_unsupport(a.attr, ori_src)\n    if hasattr(a, 'id') and a.id in self.unsupport_ops:\n        ori_src = astunparse.unparse(a)\n        return raise_unsupport(a.id, ori_src)\n    if hasattr(a, 'attr'):\n        if a.attr in self.support_ops.keys():\n            a.attr = self.support_ops[a.attr]\n    if hasattr(a, 'id'):\n        if a.id in self.support_ops.keys():\n            a.id = self.support_ops[a.id]\n    return None",
            "def replace(self, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if hasattr(a, 'attr') and a.attr in self.unsupport_ops:\n        ori_src = astunparse.unparse(a)\n        return raise_unsupport(a.attr, ori_src)\n    if hasattr(a, 'id') and a.id in self.unsupport_ops:\n        ori_src = astunparse.unparse(a)\n        return raise_unsupport(a.id, ori_src)\n    if hasattr(a, 'attr'):\n        if a.attr in self.support_ops.keys():\n            a.attr = self.support_ops[a.attr]\n    if hasattr(a, 'id'):\n        if a.id in self.support_ops.keys():\n            a.id = self.support_ops[a.id]\n    return None",
            "def replace(self, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if hasattr(a, 'attr') and a.attr in self.unsupport_ops:\n        ori_src = astunparse.unparse(a)\n        return raise_unsupport(a.attr, ori_src)\n    if hasattr(a, 'id') and a.id in self.unsupport_ops:\n        ori_src = astunparse.unparse(a)\n        return raise_unsupport(a.id, ori_src)\n    if hasattr(a, 'attr'):\n        if a.attr in self.support_ops.keys():\n            a.attr = self.support_ops[a.attr]\n    if hasattr(a, 'id'):\n        if a.id in self.support_ops.keys():\n            a.id = self.support_ops[a.id]\n    return None",
            "def replace(self, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if hasattr(a, 'attr') and a.attr in self.unsupport_ops:\n        ori_src = astunparse.unparse(a)\n        return raise_unsupport(a.attr, ori_src)\n    if hasattr(a, 'id') and a.id in self.unsupport_ops:\n        ori_src = astunparse.unparse(a)\n        return raise_unsupport(a.id, ori_src)\n    if hasattr(a, 'attr'):\n        if a.attr in self.support_ops.keys():\n            a.attr = self.support_ops[a.attr]\n    if hasattr(a, 'id'):\n        if a.id in self.support_ops.keys():\n            a.id = self.support_ops[a.id]\n    return None",
            "def replace(self, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if hasattr(a, 'attr') and a.attr in self.unsupport_ops:\n        ori_src = astunparse.unparse(a)\n        return raise_unsupport(a.attr, ori_src)\n    if hasattr(a, 'id') and a.id in self.unsupport_ops:\n        ori_src = astunparse.unparse(a)\n        return raise_unsupport(a.id, ori_src)\n    if hasattr(a, 'attr'):\n        if a.attr in self.support_ops.keys():\n            a.attr = self.support_ops[a.attr]\n    if hasattr(a, 'id'):\n        if a.id in self.support_ops.keys():\n            a.id = self.support_ops[a.id]\n    return None"
        ]
    },
    {
        "func_name": "convert_",
        "original": "def convert_(self, prefix, func_name, ags, kws, ori_src):\n    info = self.pjmap[func_name]\n    p_prefix = info['pytorch']['prefix'] if 'prefix' in info['pytorch'].keys() else None\n    if p_prefix is not None and prefix in p_prefix:\n        p_ags = info['pytorch']['args_prefix']\n        j_ags = info['jittor']['args_prefix']\n    else:\n        p_ags = info['pytorch']['args']\n        j_ags = info['jittor']['args']\n    if 'delete' in info.keys():\n        delete = info['delete']\n    else:\n        delete = None\n    j_prefix = info['jittor']['prefix'] if 'prefix' in info['jittor'].keys() else None\n    j_module = info['jittor']['module']\n    j_name = info['jittor']['name']\n    links = info['links']\n    extras = info['extras']\n    jj_ags = []\n    jj_kws = {}\n    pp_ags = []\n    pp_kws = {}\n    if j_ags == '' and p_ags == '':\n        if p_prefix is None:\n            return f'{j_module}.{j_name}()'\n        elif prefix in p_prefix:\n            return f'{j_prefix}.{j_name}()'\n        else:\n            return f'{prefix}.{j_name}()'\n    else:\n        j_ags = j_ags.replace(' ', '').split(',')\n        for j_ag in j_ags:\n            if '=' in j_ag:\n                (k, v) = j_ag.split('=')\n                jj_kws[k] = v\n            else:\n                jj_ags.append(j_ag)\n        p_ags = p_ags.replace(' ', '').split(',')\n        for p_ag in p_ags:\n            if '=' in p_ag:\n                (k, v) = p_ag.split('=')\n                pp_kws[k] = v\n            else:\n                pp_ags.append(p_ag)\n        if len(jj_ags) == 0 and len(pp_ags) != 0:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {pp_ags[0]}''')\"\n    if delete is not None:\n        for d in delete:\n            if d in pp_ags:\n                jj_ags.append(d)\n            if d in pp_kws.keys():\n                jj_kws[d] = None\n    if len(pp_ags) > len(ags) + len(kws):\n        return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>, There are needed {len(pp_ags) + len(list(pp_kws.keys()))} args in Pytorch {func_name} function, but you only provide {len(ags) + len(kws)}''')\"\n    ags_ = []\n    for i in range(len(pp_ags)):\n        if i < len(ags):\n            if '*' in pp_ags[i]:\n                ags_.append('(' + ', '.join(ags[i:]) + ')')\n                ags = ags_\n                break\n            else:\n                ags_.append(ags[i])\n        else:\n            break\n    if len(pp_ags) + len(list(pp_kws.keys())) < len(ags) + len(kws):\n        return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>,There are only {len(pp_ags) + len(list(pp_kws.keys()))} args in Pytorch {func_name} function, but you provide {len(ags) + len(kws)}''')\"\n    j_ags_flag = np.zeros(len(jj_ags))\n    j_ags_values = {}\n    j_kws_values = {}\n    for (i, ag) in enumerate(ags):\n        if len(pp_ags) == 0:\n            ag_name = list(pp_kws.keys())[i]\n        elif i < len(pp_ags):\n            ag_name = pp_ags[i]\n        elif i >= len(pp_ags) and i - len(pp_ags) <= len(list(pp_kws.keys())):\n            ag_name = list(pp_kws.keys())[i - len(pp_ags)]\n        else:\n            return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>,The args number is not matc{func_name} in Jittor has no Attribute {ag_name}''')\"\n        if ag_name in links.keys():\n            ag_name = links[ag_name]\n        if ag_name in jj_ags:\n            j_ags_flag[jj_ags.index(ag_name)] = 1\n            j_ags_values[str(jj_ags.index(ag_name))] = ag\n        elif ag_name in jj_kws.keys():\n            j_kws_values[ag_name] = ag\n        else:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {ag_name}''')\"\n    for (i, kw) in enumerate(kws):\n        (kw_name, kw_value) = kw.split('=')\n        if kw_name in links.keys():\n            kw_name = links[kw_name]\n        if kw_name in jj_ags:\n            j_ags_flag[jj_ags.index(kw_name)] = 1\n            j_ags_values[str(jj_ags.index(kw_name))] = kw_value\n        elif kw_name in jj_kws.keys():\n            j_kws_values[kw_name] = kw_value\n        else:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {kw_name}''')\"\n    len_jj_ags = len(jj_ags) if len(jj_ags) == 0 or jj_ags[0] != '' else 0\n    if j_ags_flag.sum() < len_jj_ags:\n        missing_args = []\n        for i in range(len(jj_ags)):\n            if j_ags_flag[i] == 0:\n                missing_args.append(jj_ags[i])\n        return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, the needed args of {func_name} in Jittor is {', '.join(jj_ags)}, so you need to give value of {', '.join(missing_args)}.''')\"\n    if extras:\n        for k in extras.keys():\n            if k in jj_ags:\n                j_ags_values[str(jj_ags.index(k))] = extras[k]\n            elif k in jj_kws.keys():\n                j_kws_values[k] = extras[k]\n            else:\n                return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, there is not attribute named {k} in Jittor {func_name}, you should delete it in {func_name} extras.''')\"\n    if delete is not None:\n        for d in delete:\n            if d in j_ags_values:\n                del j_ags_values[d]\n            if d in j_kws_values.keys():\n                j_kws_values.pop(d)\n    j_ags_ = [j_ags_values[str(i)] for i in range(len(list(j_ags_values.keys())))]\n    j_kws_ = [key + '=' + j_kws_values[key] for key in j_kws_values.keys()]\n    j_func = f\"{j_module}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    if p_prefix is None:\n        return f\"{j_module}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    elif prefix in p_prefix:\n        return f\"{j_prefix}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    else:\n        return f\"{prefix}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    return j_func",
        "mutated": [
            "def convert_(self, prefix, func_name, ags, kws, ori_src):\n    if False:\n        i = 10\n    info = self.pjmap[func_name]\n    p_prefix = info['pytorch']['prefix'] if 'prefix' in info['pytorch'].keys() else None\n    if p_prefix is not None and prefix in p_prefix:\n        p_ags = info['pytorch']['args_prefix']\n        j_ags = info['jittor']['args_prefix']\n    else:\n        p_ags = info['pytorch']['args']\n        j_ags = info['jittor']['args']\n    if 'delete' in info.keys():\n        delete = info['delete']\n    else:\n        delete = None\n    j_prefix = info['jittor']['prefix'] if 'prefix' in info['jittor'].keys() else None\n    j_module = info['jittor']['module']\n    j_name = info['jittor']['name']\n    links = info['links']\n    extras = info['extras']\n    jj_ags = []\n    jj_kws = {}\n    pp_ags = []\n    pp_kws = {}\n    if j_ags == '' and p_ags == '':\n        if p_prefix is None:\n            return f'{j_module}.{j_name}()'\n        elif prefix in p_prefix:\n            return f'{j_prefix}.{j_name}()'\n        else:\n            return f'{prefix}.{j_name}()'\n    else:\n        j_ags = j_ags.replace(' ', '').split(',')\n        for j_ag in j_ags:\n            if '=' in j_ag:\n                (k, v) = j_ag.split('=')\n                jj_kws[k] = v\n            else:\n                jj_ags.append(j_ag)\n        p_ags = p_ags.replace(' ', '').split(',')\n        for p_ag in p_ags:\n            if '=' in p_ag:\n                (k, v) = p_ag.split('=')\n                pp_kws[k] = v\n            else:\n                pp_ags.append(p_ag)\n        if len(jj_ags) == 0 and len(pp_ags) != 0:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {pp_ags[0]}''')\"\n    if delete is not None:\n        for d in delete:\n            if d in pp_ags:\n                jj_ags.append(d)\n            if d in pp_kws.keys():\n                jj_kws[d] = None\n    if len(pp_ags) > len(ags) + len(kws):\n        return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>, There are needed {len(pp_ags) + len(list(pp_kws.keys()))} args in Pytorch {func_name} function, but you only provide {len(ags) + len(kws)}''')\"\n    ags_ = []\n    for i in range(len(pp_ags)):\n        if i < len(ags):\n            if '*' in pp_ags[i]:\n                ags_.append('(' + ', '.join(ags[i:]) + ')')\n                ags = ags_\n                break\n            else:\n                ags_.append(ags[i])\n        else:\n            break\n    if len(pp_ags) + len(list(pp_kws.keys())) < len(ags) + len(kws):\n        return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>,There are only {len(pp_ags) + len(list(pp_kws.keys()))} args in Pytorch {func_name} function, but you provide {len(ags) + len(kws)}''')\"\n    j_ags_flag = np.zeros(len(jj_ags))\n    j_ags_values = {}\n    j_kws_values = {}\n    for (i, ag) in enumerate(ags):\n        if len(pp_ags) == 0:\n            ag_name = list(pp_kws.keys())[i]\n        elif i < len(pp_ags):\n            ag_name = pp_ags[i]\n        elif i >= len(pp_ags) and i - len(pp_ags) <= len(list(pp_kws.keys())):\n            ag_name = list(pp_kws.keys())[i - len(pp_ags)]\n        else:\n            return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>,The args number is not matc{func_name} in Jittor has no Attribute {ag_name}''')\"\n        if ag_name in links.keys():\n            ag_name = links[ag_name]\n        if ag_name in jj_ags:\n            j_ags_flag[jj_ags.index(ag_name)] = 1\n            j_ags_values[str(jj_ags.index(ag_name))] = ag\n        elif ag_name in jj_kws.keys():\n            j_kws_values[ag_name] = ag\n        else:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {ag_name}''')\"\n    for (i, kw) in enumerate(kws):\n        (kw_name, kw_value) = kw.split('=')\n        if kw_name in links.keys():\n            kw_name = links[kw_name]\n        if kw_name in jj_ags:\n            j_ags_flag[jj_ags.index(kw_name)] = 1\n            j_ags_values[str(jj_ags.index(kw_name))] = kw_value\n        elif kw_name in jj_kws.keys():\n            j_kws_values[kw_name] = kw_value\n        else:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {kw_name}''')\"\n    len_jj_ags = len(jj_ags) if len(jj_ags) == 0 or jj_ags[0] != '' else 0\n    if j_ags_flag.sum() < len_jj_ags:\n        missing_args = []\n        for i in range(len(jj_ags)):\n            if j_ags_flag[i] == 0:\n                missing_args.append(jj_ags[i])\n        return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, the needed args of {func_name} in Jittor is {', '.join(jj_ags)}, so you need to give value of {', '.join(missing_args)}.''')\"\n    if extras:\n        for k in extras.keys():\n            if k in jj_ags:\n                j_ags_values[str(jj_ags.index(k))] = extras[k]\n            elif k in jj_kws.keys():\n                j_kws_values[k] = extras[k]\n            else:\n                return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, there is not attribute named {k} in Jittor {func_name}, you should delete it in {func_name} extras.''')\"\n    if delete is not None:\n        for d in delete:\n            if d in j_ags_values:\n                del j_ags_values[d]\n            if d in j_kws_values.keys():\n                j_kws_values.pop(d)\n    j_ags_ = [j_ags_values[str(i)] for i in range(len(list(j_ags_values.keys())))]\n    j_kws_ = [key + '=' + j_kws_values[key] for key in j_kws_values.keys()]\n    j_func = f\"{j_module}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    if p_prefix is None:\n        return f\"{j_module}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    elif prefix in p_prefix:\n        return f\"{j_prefix}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    else:\n        return f\"{prefix}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    return j_func",
            "def convert_(self, prefix, func_name, ags, kws, ori_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    info = self.pjmap[func_name]\n    p_prefix = info['pytorch']['prefix'] if 'prefix' in info['pytorch'].keys() else None\n    if p_prefix is not None and prefix in p_prefix:\n        p_ags = info['pytorch']['args_prefix']\n        j_ags = info['jittor']['args_prefix']\n    else:\n        p_ags = info['pytorch']['args']\n        j_ags = info['jittor']['args']\n    if 'delete' in info.keys():\n        delete = info['delete']\n    else:\n        delete = None\n    j_prefix = info['jittor']['prefix'] if 'prefix' in info['jittor'].keys() else None\n    j_module = info['jittor']['module']\n    j_name = info['jittor']['name']\n    links = info['links']\n    extras = info['extras']\n    jj_ags = []\n    jj_kws = {}\n    pp_ags = []\n    pp_kws = {}\n    if j_ags == '' and p_ags == '':\n        if p_prefix is None:\n            return f'{j_module}.{j_name}()'\n        elif prefix in p_prefix:\n            return f'{j_prefix}.{j_name}()'\n        else:\n            return f'{prefix}.{j_name}()'\n    else:\n        j_ags = j_ags.replace(' ', '').split(',')\n        for j_ag in j_ags:\n            if '=' in j_ag:\n                (k, v) = j_ag.split('=')\n                jj_kws[k] = v\n            else:\n                jj_ags.append(j_ag)\n        p_ags = p_ags.replace(' ', '').split(',')\n        for p_ag in p_ags:\n            if '=' in p_ag:\n                (k, v) = p_ag.split('=')\n                pp_kws[k] = v\n            else:\n                pp_ags.append(p_ag)\n        if len(jj_ags) == 0 and len(pp_ags) != 0:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {pp_ags[0]}''')\"\n    if delete is not None:\n        for d in delete:\n            if d in pp_ags:\n                jj_ags.append(d)\n            if d in pp_kws.keys():\n                jj_kws[d] = None\n    if len(pp_ags) > len(ags) + len(kws):\n        return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>, There are needed {len(pp_ags) + len(list(pp_kws.keys()))} args in Pytorch {func_name} function, but you only provide {len(ags) + len(kws)}''')\"\n    ags_ = []\n    for i in range(len(pp_ags)):\n        if i < len(ags):\n            if '*' in pp_ags[i]:\n                ags_.append('(' + ', '.join(ags[i:]) + ')')\n                ags = ags_\n                break\n            else:\n                ags_.append(ags[i])\n        else:\n            break\n    if len(pp_ags) + len(list(pp_kws.keys())) < len(ags) + len(kws):\n        return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>,There are only {len(pp_ags) + len(list(pp_kws.keys()))} args in Pytorch {func_name} function, but you provide {len(ags) + len(kws)}''')\"\n    j_ags_flag = np.zeros(len(jj_ags))\n    j_ags_values = {}\n    j_kws_values = {}\n    for (i, ag) in enumerate(ags):\n        if len(pp_ags) == 0:\n            ag_name = list(pp_kws.keys())[i]\n        elif i < len(pp_ags):\n            ag_name = pp_ags[i]\n        elif i >= len(pp_ags) and i - len(pp_ags) <= len(list(pp_kws.keys())):\n            ag_name = list(pp_kws.keys())[i - len(pp_ags)]\n        else:\n            return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>,The args number is not matc{func_name} in Jittor has no Attribute {ag_name}''')\"\n        if ag_name in links.keys():\n            ag_name = links[ag_name]\n        if ag_name in jj_ags:\n            j_ags_flag[jj_ags.index(ag_name)] = 1\n            j_ags_values[str(jj_ags.index(ag_name))] = ag\n        elif ag_name in jj_kws.keys():\n            j_kws_values[ag_name] = ag\n        else:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {ag_name}''')\"\n    for (i, kw) in enumerate(kws):\n        (kw_name, kw_value) = kw.split('=')\n        if kw_name in links.keys():\n            kw_name = links[kw_name]\n        if kw_name in jj_ags:\n            j_ags_flag[jj_ags.index(kw_name)] = 1\n            j_ags_values[str(jj_ags.index(kw_name))] = kw_value\n        elif kw_name in jj_kws.keys():\n            j_kws_values[kw_name] = kw_value\n        else:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {kw_name}''')\"\n    len_jj_ags = len(jj_ags) if len(jj_ags) == 0 or jj_ags[0] != '' else 0\n    if j_ags_flag.sum() < len_jj_ags:\n        missing_args = []\n        for i in range(len(jj_ags)):\n            if j_ags_flag[i] == 0:\n                missing_args.append(jj_ags[i])\n        return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, the needed args of {func_name} in Jittor is {', '.join(jj_ags)}, so you need to give value of {', '.join(missing_args)}.''')\"\n    if extras:\n        for k in extras.keys():\n            if k in jj_ags:\n                j_ags_values[str(jj_ags.index(k))] = extras[k]\n            elif k in jj_kws.keys():\n                j_kws_values[k] = extras[k]\n            else:\n                return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, there is not attribute named {k} in Jittor {func_name}, you should delete it in {func_name} extras.''')\"\n    if delete is not None:\n        for d in delete:\n            if d in j_ags_values:\n                del j_ags_values[d]\n            if d in j_kws_values.keys():\n                j_kws_values.pop(d)\n    j_ags_ = [j_ags_values[str(i)] for i in range(len(list(j_ags_values.keys())))]\n    j_kws_ = [key + '=' + j_kws_values[key] for key in j_kws_values.keys()]\n    j_func = f\"{j_module}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    if p_prefix is None:\n        return f\"{j_module}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    elif prefix in p_prefix:\n        return f\"{j_prefix}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    else:\n        return f\"{prefix}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    return j_func",
            "def convert_(self, prefix, func_name, ags, kws, ori_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    info = self.pjmap[func_name]\n    p_prefix = info['pytorch']['prefix'] if 'prefix' in info['pytorch'].keys() else None\n    if p_prefix is not None and prefix in p_prefix:\n        p_ags = info['pytorch']['args_prefix']\n        j_ags = info['jittor']['args_prefix']\n    else:\n        p_ags = info['pytorch']['args']\n        j_ags = info['jittor']['args']\n    if 'delete' in info.keys():\n        delete = info['delete']\n    else:\n        delete = None\n    j_prefix = info['jittor']['prefix'] if 'prefix' in info['jittor'].keys() else None\n    j_module = info['jittor']['module']\n    j_name = info['jittor']['name']\n    links = info['links']\n    extras = info['extras']\n    jj_ags = []\n    jj_kws = {}\n    pp_ags = []\n    pp_kws = {}\n    if j_ags == '' and p_ags == '':\n        if p_prefix is None:\n            return f'{j_module}.{j_name}()'\n        elif prefix in p_prefix:\n            return f'{j_prefix}.{j_name}()'\n        else:\n            return f'{prefix}.{j_name}()'\n    else:\n        j_ags = j_ags.replace(' ', '').split(',')\n        for j_ag in j_ags:\n            if '=' in j_ag:\n                (k, v) = j_ag.split('=')\n                jj_kws[k] = v\n            else:\n                jj_ags.append(j_ag)\n        p_ags = p_ags.replace(' ', '').split(',')\n        for p_ag in p_ags:\n            if '=' in p_ag:\n                (k, v) = p_ag.split('=')\n                pp_kws[k] = v\n            else:\n                pp_ags.append(p_ag)\n        if len(jj_ags) == 0 and len(pp_ags) != 0:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {pp_ags[0]}''')\"\n    if delete is not None:\n        for d in delete:\n            if d in pp_ags:\n                jj_ags.append(d)\n            if d in pp_kws.keys():\n                jj_kws[d] = None\n    if len(pp_ags) > len(ags) + len(kws):\n        return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>, There are needed {len(pp_ags) + len(list(pp_kws.keys()))} args in Pytorch {func_name} function, but you only provide {len(ags) + len(kws)}''')\"\n    ags_ = []\n    for i in range(len(pp_ags)):\n        if i < len(ags):\n            if '*' in pp_ags[i]:\n                ags_.append('(' + ', '.join(ags[i:]) + ')')\n                ags = ags_\n                break\n            else:\n                ags_.append(ags[i])\n        else:\n            break\n    if len(pp_ags) + len(list(pp_kws.keys())) < len(ags) + len(kws):\n        return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>,There are only {len(pp_ags) + len(list(pp_kws.keys()))} args in Pytorch {func_name} function, but you provide {len(ags) + len(kws)}''')\"\n    j_ags_flag = np.zeros(len(jj_ags))\n    j_ags_values = {}\n    j_kws_values = {}\n    for (i, ag) in enumerate(ags):\n        if len(pp_ags) == 0:\n            ag_name = list(pp_kws.keys())[i]\n        elif i < len(pp_ags):\n            ag_name = pp_ags[i]\n        elif i >= len(pp_ags) and i - len(pp_ags) <= len(list(pp_kws.keys())):\n            ag_name = list(pp_kws.keys())[i - len(pp_ags)]\n        else:\n            return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>,The args number is not matc{func_name} in Jittor has no Attribute {ag_name}''')\"\n        if ag_name in links.keys():\n            ag_name = links[ag_name]\n        if ag_name in jj_ags:\n            j_ags_flag[jj_ags.index(ag_name)] = 1\n            j_ags_values[str(jj_ags.index(ag_name))] = ag\n        elif ag_name in jj_kws.keys():\n            j_kws_values[ag_name] = ag\n        else:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {ag_name}''')\"\n    for (i, kw) in enumerate(kws):\n        (kw_name, kw_value) = kw.split('=')\n        if kw_name in links.keys():\n            kw_name = links[kw_name]\n        if kw_name in jj_ags:\n            j_ags_flag[jj_ags.index(kw_name)] = 1\n            j_ags_values[str(jj_ags.index(kw_name))] = kw_value\n        elif kw_name in jj_kws.keys():\n            j_kws_values[kw_name] = kw_value\n        else:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {kw_name}''')\"\n    len_jj_ags = len(jj_ags) if len(jj_ags) == 0 or jj_ags[0] != '' else 0\n    if j_ags_flag.sum() < len_jj_ags:\n        missing_args = []\n        for i in range(len(jj_ags)):\n            if j_ags_flag[i] == 0:\n                missing_args.append(jj_ags[i])\n        return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, the needed args of {func_name} in Jittor is {', '.join(jj_ags)}, so you need to give value of {', '.join(missing_args)}.''')\"\n    if extras:\n        for k in extras.keys():\n            if k in jj_ags:\n                j_ags_values[str(jj_ags.index(k))] = extras[k]\n            elif k in jj_kws.keys():\n                j_kws_values[k] = extras[k]\n            else:\n                return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, there is not attribute named {k} in Jittor {func_name}, you should delete it in {func_name} extras.''')\"\n    if delete is not None:\n        for d in delete:\n            if d in j_ags_values:\n                del j_ags_values[d]\n            if d in j_kws_values.keys():\n                j_kws_values.pop(d)\n    j_ags_ = [j_ags_values[str(i)] for i in range(len(list(j_ags_values.keys())))]\n    j_kws_ = [key + '=' + j_kws_values[key] for key in j_kws_values.keys()]\n    j_func = f\"{j_module}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    if p_prefix is None:\n        return f\"{j_module}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    elif prefix in p_prefix:\n        return f\"{j_prefix}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    else:\n        return f\"{prefix}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    return j_func",
            "def convert_(self, prefix, func_name, ags, kws, ori_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    info = self.pjmap[func_name]\n    p_prefix = info['pytorch']['prefix'] if 'prefix' in info['pytorch'].keys() else None\n    if p_prefix is not None and prefix in p_prefix:\n        p_ags = info['pytorch']['args_prefix']\n        j_ags = info['jittor']['args_prefix']\n    else:\n        p_ags = info['pytorch']['args']\n        j_ags = info['jittor']['args']\n    if 'delete' in info.keys():\n        delete = info['delete']\n    else:\n        delete = None\n    j_prefix = info['jittor']['prefix'] if 'prefix' in info['jittor'].keys() else None\n    j_module = info['jittor']['module']\n    j_name = info['jittor']['name']\n    links = info['links']\n    extras = info['extras']\n    jj_ags = []\n    jj_kws = {}\n    pp_ags = []\n    pp_kws = {}\n    if j_ags == '' and p_ags == '':\n        if p_prefix is None:\n            return f'{j_module}.{j_name}()'\n        elif prefix in p_prefix:\n            return f'{j_prefix}.{j_name}()'\n        else:\n            return f'{prefix}.{j_name}()'\n    else:\n        j_ags = j_ags.replace(' ', '').split(',')\n        for j_ag in j_ags:\n            if '=' in j_ag:\n                (k, v) = j_ag.split('=')\n                jj_kws[k] = v\n            else:\n                jj_ags.append(j_ag)\n        p_ags = p_ags.replace(' ', '').split(',')\n        for p_ag in p_ags:\n            if '=' in p_ag:\n                (k, v) = p_ag.split('=')\n                pp_kws[k] = v\n            else:\n                pp_ags.append(p_ag)\n        if len(jj_ags) == 0 and len(pp_ags) != 0:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {pp_ags[0]}''')\"\n    if delete is not None:\n        for d in delete:\n            if d in pp_ags:\n                jj_ags.append(d)\n            if d in pp_kws.keys():\n                jj_kws[d] = None\n    if len(pp_ags) > len(ags) + len(kws):\n        return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>, There are needed {len(pp_ags) + len(list(pp_kws.keys()))} args in Pytorch {func_name} function, but you only provide {len(ags) + len(kws)}''')\"\n    ags_ = []\n    for i in range(len(pp_ags)):\n        if i < len(ags):\n            if '*' in pp_ags[i]:\n                ags_.append('(' + ', '.join(ags[i:]) + ')')\n                ags = ags_\n                break\n            else:\n                ags_.append(ags[i])\n        else:\n            break\n    if len(pp_ags) + len(list(pp_kws.keys())) < len(ags) + len(kws):\n        return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>,There are only {len(pp_ags) + len(list(pp_kws.keys()))} args in Pytorch {func_name} function, but you provide {len(ags) + len(kws)}''')\"\n    j_ags_flag = np.zeros(len(jj_ags))\n    j_ags_values = {}\n    j_kws_values = {}\n    for (i, ag) in enumerate(ags):\n        if len(pp_ags) == 0:\n            ag_name = list(pp_kws.keys())[i]\n        elif i < len(pp_ags):\n            ag_name = pp_ags[i]\n        elif i >= len(pp_ags) and i - len(pp_ags) <= len(list(pp_kws.keys())):\n            ag_name = list(pp_kws.keys())[i - len(pp_ags)]\n        else:\n            return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>,The args number is not matc{func_name} in Jittor has no Attribute {ag_name}''')\"\n        if ag_name in links.keys():\n            ag_name = links[ag_name]\n        if ag_name in jj_ags:\n            j_ags_flag[jj_ags.index(ag_name)] = 1\n            j_ags_values[str(jj_ags.index(ag_name))] = ag\n        elif ag_name in jj_kws.keys():\n            j_kws_values[ag_name] = ag\n        else:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {ag_name}''')\"\n    for (i, kw) in enumerate(kws):\n        (kw_name, kw_value) = kw.split('=')\n        if kw_name in links.keys():\n            kw_name = links[kw_name]\n        if kw_name in jj_ags:\n            j_ags_flag[jj_ags.index(kw_name)] = 1\n            j_ags_values[str(jj_ags.index(kw_name))] = kw_value\n        elif kw_name in jj_kws.keys():\n            j_kws_values[kw_name] = kw_value\n        else:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {kw_name}''')\"\n    len_jj_ags = len(jj_ags) if len(jj_ags) == 0 or jj_ags[0] != '' else 0\n    if j_ags_flag.sum() < len_jj_ags:\n        missing_args = []\n        for i in range(len(jj_ags)):\n            if j_ags_flag[i] == 0:\n                missing_args.append(jj_ags[i])\n        return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, the needed args of {func_name} in Jittor is {', '.join(jj_ags)}, so you need to give value of {', '.join(missing_args)}.''')\"\n    if extras:\n        for k in extras.keys():\n            if k in jj_ags:\n                j_ags_values[str(jj_ags.index(k))] = extras[k]\n            elif k in jj_kws.keys():\n                j_kws_values[k] = extras[k]\n            else:\n                return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, there is not attribute named {k} in Jittor {func_name}, you should delete it in {func_name} extras.''')\"\n    if delete is not None:\n        for d in delete:\n            if d in j_ags_values:\n                del j_ags_values[d]\n            if d in j_kws_values.keys():\n                j_kws_values.pop(d)\n    j_ags_ = [j_ags_values[str(i)] for i in range(len(list(j_ags_values.keys())))]\n    j_kws_ = [key + '=' + j_kws_values[key] for key in j_kws_values.keys()]\n    j_func = f\"{j_module}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    if p_prefix is None:\n        return f\"{j_module}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    elif prefix in p_prefix:\n        return f\"{j_prefix}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    else:\n        return f\"{prefix}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    return j_func",
            "def convert_(self, prefix, func_name, ags, kws, ori_src):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    info = self.pjmap[func_name]\n    p_prefix = info['pytorch']['prefix'] if 'prefix' in info['pytorch'].keys() else None\n    if p_prefix is not None and prefix in p_prefix:\n        p_ags = info['pytorch']['args_prefix']\n        j_ags = info['jittor']['args_prefix']\n    else:\n        p_ags = info['pytorch']['args']\n        j_ags = info['jittor']['args']\n    if 'delete' in info.keys():\n        delete = info['delete']\n    else:\n        delete = None\n    j_prefix = info['jittor']['prefix'] if 'prefix' in info['jittor'].keys() else None\n    j_module = info['jittor']['module']\n    j_name = info['jittor']['name']\n    links = info['links']\n    extras = info['extras']\n    jj_ags = []\n    jj_kws = {}\n    pp_ags = []\n    pp_kws = {}\n    if j_ags == '' and p_ags == '':\n        if p_prefix is None:\n            return f'{j_module}.{j_name}()'\n        elif prefix in p_prefix:\n            return f'{j_prefix}.{j_name}()'\n        else:\n            return f'{prefix}.{j_name}()'\n    else:\n        j_ags = j_ags.replace(' ', '').split(',')\n        for j_ag in j_ags:\n            if '=' in j_ag:\n                (k, v) = j_ag.split('=')\n                jj_kws[k] = v\n            else:\n                jj_ags.append(j_ag)\n        p_ags = p_ags.replace(' ', '').split(',')\n        for p_ag in p_ags:\n            if '=' in p_ag:\n                (k, v) = p_ag.split('=')\n                pp_kws[k] = v\n            else:\n                pp_ags.append(p_ag)\n        if len(jj_ags) == 0 and len(pp_ags) != 0:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {pp_ags[0]}''')\"\n    if delete is not None:\n        for d in delete:\n            if d in pp_ags:\n                jj_ags.append(d)\n            if d in pp_kws.keys():\n                jj_kws[d] = None\n    if len(pp_ags) > len(ags) + len(kws):\n        return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>, There are needed {len(pp_ags) + len(list(pp_kws.keys()))} args in Pytorch {func_name} function, but you only provide {len(ags) + len(kws)}''')\"\n    ags_ = []\n    for i in range(len(pp_ags)):\n        if i < len(ags):\n            if '*' in pp_ags[i]:\n                ags_.append('(' + ', '.join(ags[i:]) + ')')\n                ags = ags_\n                break\n            else:\n                ags_.append(ags[i])\n        else:\n            break\n    if len(pp_ags) + len(list(pp_kws.keys())) < len(ags) + len(kws):\n        return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>,There are only {len(pp_ags) + len(list(pp_kws.keys()))} args in Pytorch {func_name} function, but you provide {len(ags) + len(kws)}''')\"\n    j_ags_flag = np.zeros(len(jj_ags))\n    j_ags_values = {}\n    j_kws_values = {}\n    for (i, ag) in enumerate(ags):\n        if len(pp_ags) == 0:\n            ag_name = list(pp_kws.keys())[i]\n        elif i < len(pp_ags):\n            ag_name = pp_ags[i]\n        elif i >= len(pp_ags) and i - len(pp_ags) <= len(list(pp_kws.keys())):\n            ag_name = list(pp_kws.keys())[i - len(pp_ags)]\n        else:\n            return f\"raise RuntimeError('''origin source: <{ori_src.strip()}>,The args number is not matc{func_name} in Jittor has no Attribute {ag_name}''')\"\n        if ag_name in links.keys():\n            ag_name = links[ag_name]\n        if ag_name in jj_ags:\n            j_ags_flag[jj_ags.index(ag_name)] = 1\n            j_ags_values[str(jj_ags.index(ag_name))] = ag\n        elif ag_name in jj_kws.keys():\n            j_kws_values[ag_name] = ag\n        else:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {ag_name}''')\"\n    for (i, kw) in enumerate(kws):\n        (kw_name, kw_value) = kw.split('=')\n        if kw_name in links.keys():\n            kw_name = links[kw_name]\n        if kw_name in jj_ags:\n            j_ags_flag[jj_ags.index(kw_name)] = 1\n            j_ags_values[str(jj_ags.index(kw_name))] = kw_value\n        elif kw_name in jj_kws.keys():\n            j_kws_values[kw_name] = kw_value\n        else:\n            return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, {func_name} in Jittor has no Attribute {kw_name}''')\"\n    len_jj_ags = len(jj_ags) if len(jj_ags) == 0 or jj_ags[0] != '' else 0\n    if j_ags_flag.sum() < len_jj_ags:\n        missing_args = []\n        for i in range(len(jj_ags)):\n            if j_ags_flag[i] == 0:\n                missing_args.append(jj_ags[i])\n        return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, the needed args of {func_name} in Jittor is {', '.join(jj_ags)}, so you need to give value of {', '.join(missing_args)}.''')\"\n    if extras:\n        for k in extras.keys():\n            if k in jj_ags:\n                j_ags_values[str(jj_ags.index(k))] = extras[k]\n            elif k in jj_kws.keys():\n                j_kws_values[k] = extras[k]\n            else:\n                return f\"raise AttributeError('''origin source: <{ori_src.strip()}>, there is not attribute named {k} in Jittor {func_name}, you should delete it in {func_name} extras.''')\"\n    if delete is not None:\n        for d in delete:\n            if d in j_ags_values:\n                del j_ags_values[d]\n            if d in j_kws_values.keys():\n                j_kws_values.pop(d)\n    j_ags_ = [j_ags_values[str(i)] for i in range(len(list(j_ags_values.keys())))]\n    j_kws_ = [key + '=' + j_kws_values[key] for key in j_kws_values.keys()]\n    j_func = f\"{j_module}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    if p_prefix is None:\n        return f\"{j_module}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    elif prefix in p_prefix:\n        return f\"{j_prefix}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    else:\n        return f\"{prefix}.{j_name}({', '.join(j_ags_ + j_kws_)})\"\n    return j_func"
        ]
    },
    {
        "func_name": "dfs",
        "original": "def dfs(self, a):\n    if isinstance(a, ast.Import):\n        if 'torch' in astunparse.unparse(a) and 'init' in astunparse.unparse(a):\n            self.import_flag.append('init')\n            return ast.parse('from jittor import init').body[0]\n        if 'torch' in astunparse.unparse(a) and a.names[0].asname == 'nn':\n            self.import_flag.append('nn')\n            return ast.parse('from jittor import nn').body[0]\n        if 'torch' in a.names[0].name:\n            return 'delete'\n    elif isinstance(a, ast.ImportFrom):\n        if 'torch' in a.module:\n            return 'delete'\n    elif isinstance(a, ast.Call):\n        for (idx, ag) in enumerate(a.args):\n            ret = self.dfs(ag)\n            if ret is not None:\n                a.args[idx] = ret\n        for (idx, kw) in enumerate(a.keywords):\n            ret = self.dfs(kw)\n            if ret is not None:\n                a.keywords[idx] = ret\n        ori_src = astunparse.unparse(a)\n        func = astunparse.unparse(a.func).strip('\\n').split('.')\n        prefix = '.'.join(func[0:-1])\n        func_name = func[-1]\n        if func_name in self.unsupport_ops:\n            ret = raise_unsupport(func_name, ori_src)\n            return ret\n        if func_name in self.pjmap:\n            ags = [astunparse.unparse(ag).strip('\\n') for ag in a.args]\n            kws = [astunparse.unparse(kw).strip('\\n') for kw in a.keywords]\n            ret = self.convert_(prefix, func_name, ags, kws, ori_src)\n            ret_tmp = ret\n            ret = ast.parse(ret).body[0]\n            if hasattr(ret, 'value'):\n                return ret.value\n            else:\n                print(ret_tmp + '\\n')\n                return ret\n        if '.load_state_dict' in astunparse.unparse(a.func):\n            a.func.attr = 'load_parameters'\n        if astunparse.unparse(a.func).strip('\\n').endswith('.size'):\n            ags = [astunparse.unparse(ag).strip('\\n') for ag in a.args]\n            if len(ags) != 0:\n                con = astunparse.unparse(a.func).split('.size')[0] + '.shape[' + ','.join(ags) + ']'\n            else:\n                con = astunparse.unparse(a.func).replace('size', 'shape')\n            return ast.parse(con).body[0].value\n    elif isinstance(a, ast.Expr):\n        pass\n    elif isinstance(a, ast.Attribute) or isinstance(a, ast.Name):\n        ret = self.replace(a)\n        if ret is not None:\n            print(ret)\n            return ret\n    elif isinstance(a, ast.FunctionDef):\n        if a.name == 'forward':\n            a.name = 'execute'\n    if hasattr(a, '__dict__'):\n        for k in a.__dict__.keys():\n            if isinstance(a.__dict__[k], list):\n                delete_flag = []\n                for (i, a_) in enumerate(a.__dict__[k]):\n                    ret = self.dfs(a_)\n                    if ret == 'delete':\n                        delete_flag.append(True)\n                        continue\n                    if ret is not None:\n                        a.__dict__[k][i] = ret\n                    delete_flag.append(False)\n                tmp = [a_ for (i, a_) in enumerate(a.__dict__[k]) if delete_flag[i] == False]\n                a.__dict__[k] = tmp\n            else:\n                ret = self.dfs(a.__dict__[k])\n                if ret is not None:\n                    a.__dict__[k] = ret",
        "mutated": [
            "def dfs(self, a):\n    if False:\n        i = 10\n    if isinstance(a, ast.Import):\n        if 'torch' in astunparse.unparse(a) and 'init' in astunparse.unparse(a):\n            self.import_flag.append('init')\n            return ast.parse('from jittor import init').body[0]\n        if 'torch' in astunparse.unparse(a) and a.names[0].asname == 'nn':\n            self.import_flag.append('nn')\n            return ast.parse('from jittor import nn').body[0]\n        if 'torch' in a.names[0].name:\n            return 'delete'\n    elif isinstance(a, ast.ImportFrom):\n        if 'torch' in a.module:\n            return 'delete'\n    elif isinstance(a, ast.Call):\n        for (idx, ag) in enumerate(a.args):\n            ret = self.dfs(ag)\n            if ret is not None:\n                a.args[idx] = ret\n        for (idx, kw) in enumerate(a.keywords):\n            ret = self.dfs(kw)\n            if ret is not None:\n                a.keywords[idx] = ret\n        ori_src = astunparse.unparse(a)\n        func = astunparse.unparse(a.func).strip('\\n').split('.')\n        prefix = '.'.join(func[0:-1])\n        func_name = func[-1]\n        if func_name in self.unsupport_ops:\n            ret = raise_unsupport(func_name, ori_src)\n            return ret\n        if func_name in self.pjmap:\n            ags = [astunparse.unparse(ag).strip('\\n') for ag in a.args]\n            kws = [astunparse.unparse(kw).strip('\\n') for kw in a.keywords]\n            ret = self.convert_(prefix, func_name, ags, kws, ori_src)\n            ret_tmp = ret\n            ret = ast.parse(ret).body[0]\n            if hasattr(ret, 'value'):\n                return ret.value\n            else:\n                print(ret_tmp + '\\n')\n                return ret\n        if '.load_state_dict' in astunparse.unparse(a.func):\n            a.func.attr = 'load_parameters'\n        if astunparse.unparse(a.func).strip('\\n').endswith('.size'):\n            ags = [astunparse.unparse(ag).strip('\\n') for ag in a.args]\n            if len(ags) != 0:\n                con = astunparse.unparse(a.func).split('.size')[0] + '.shape[' + ','.join(ags) + ']'\n            else:\n                con = astunparse.unparse(a.func).replace('size', 'shape')\n            return ast.parse(con).body[0].value\n    elif isinstance(a, ast.Expr):\n        pass\n    elif isinstance(a, ast.Attribute) or isinstance(a, ast.Name):\n        ret = self.replace(a)\n        if ret is not None:\n            print(ret)\n            return ret\n    elif isinstance(a, ast.FunctionDef):\n        if a.name == 'forward':\n            a.name = 'execute'\n    if hasattr(a, '__dict__'):\n        for k in a.__dict__.keys():\n            if isinstance(a.__dict__[k], list):\n                delete_flag = []\n                for (i, a_) in enumerate(a.__dict__[k]):\n                    ret = self.dfs(a_)\n                    if ret == 'delete':\n                        delete_flag.append(True)\n                        continue\n                    if ret is not None:\n                        a.__dict__[k][i] = ret\n                    delete_flag.append(False)\n                tmp = [a_ for (i, a_) in enumerate(a.__dict__[k]) if delete_flag[i] == False]\n                a.__dict__[k] = tmp\n            else:\n                ret = self.dfs(a.__dict__[k])\n                if ret is not None:\n                    a.__dict__[k] = ret",
            "def dfs(self, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(a, ast.Import):\n        if 'torch' in astunparse.unparse(a) and 'init' in astunparse.unparse(a):\n            self.import_flag.append('init')\n            return ast.parse('from jittor import init').body[0]\n        if 'torch' in astunparse.unparse(a) and a.names[0].asname == 'nn':\n            self.import_flag.append('nn')\n            return ast.parse('from jittor import nn').body[0]\n        if 'torch' in a.names[0].name:\n            return 'delete'\n    elif isinstance(a, ast.ImportFrom):\n        if 'torch' in a.module:\n            return 'delete'\n    elif isinstance(a, ast.Call):\n        for (idx, ag) in enumerate(a.args):\n            ret = self.dfs(ag)\n            if ret is not None:\n                a.args[idx] = ret\n        for (idx, kw) in enumerate(a.keywords):\n            ret = self.dfs(kw)\n            if ret is not None:\n                a.keywords[idx] = ret\n        ori_src = astunparse.unparse(a)\n        func = astunparse.unparse(a.func).strip('\\n').split('.')\n        prefix = '.'.join(func[0:-1])\n        func_name = func[-1]\n        if func_name in self.unsupport_ops:\n            ret = raise_unsupport(func_name, ori_src)\n            return ret\n        if func_name in self.pjmap:\n            ags = [astunparse.unparse(ag).strip('\\n') for ag in a.args]\n            kws = [astunparse.unparse(kw).strip('\\n') for kw in a.keywords]\n            ret = self.convert_(prefix, func_name, ags, kws, ori_src)\n            ret_tmp = ret\n            ret = ast.parse(ret).body[0]\n            if hasattr(ret, 'value'):\n                return ret.value\n            else:\n                print(ret_tmp + '\\n')\n                return ret\n        if '.load_state_dict' in astunparse.unparse(a.func):\n            a.func.attr = 'load_parameters'\n        if astunparse.unparse(a.func).strip('\\n').endswith('.size'):\n            ags = [astunparse.unparse(ag).strip('\\n') for ag in a.args]\n            if len(ags) != 0:\n                con = astunparse.unparse(a.func).split('.size')[0] + '.shape[' + ','.join(ags) + ']'\n            else:\n                con = astunparse.unparse(a.func).replace('size', 'shape')\n            return ast.parse(con).body[0].value\n    elif isinstance(a, ast.Expr):\n        pass\n    elif isinstance(a, ast.Attribute) or isinstance(a, ast.Name):\n        ret = self.replace(a)\n        if ret is not None:\n            print(ret)\n            return ret\n    elif isinstance(a, ast.FunctionDef):\n        if a.name == 'forward':\n            a.name = 'execute'\n    if hasattr(a, '__dict__'):\n        for k in a.__dict__.keys():\n            if isinstance(a.__dict__[k], list):\n                delete_flag = []\n                for (i, a_) in enumerate(a.__dict__[k]):\n                    ret = self.dfs(a_)\n                    if ret == 'delete':\n                        delete_flag.append(True)\n                        continue\n                    if ret is not None:\n                        a.__dict__[k][i] = ret\n                    delete_flag.append(False)\n                tmp = [a_ for (i, a_) in enumerate(a.__dict__[k]) if delete_flag[i] == False]\n                a.__dict__[k] = tmp\n            else:\n                ret = self.dfs(a.__dict__[k])\n                if ret is not None:\n                    a.__dict__[k] = ret",
            "def dfs(self, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(a, ast.Import):\n        if 'torch' in astunparse.unparse(a) and 'init' in astunparse.unparse(a):\n            self.import_flag.append('init')\n            return ast.parse('from jittor import init').body[0]\n        if 'torch' in astunparse.unparse(a) and a.names[0].asname == 'nn':\n            self.import_flag.append('nn')\n            return ast.parse('from jittor import nn').body[0]\n        if 'torch' in a.names[0].name:\n            return 'delete'\n    elif isinstance(a, ast.ImportFrom):\n        if 'torch' in a.module:\n            return 'delete'\n    elif isinstance(a, ast.Call):\n        for (idx, ag) in enumerate(a.args):\n            ret = self.dfs(ag)\n            if ret is not None:\n                a.args[idx] = ret\n        for (idx, kw) in enumerate(a.keywords):\n            ret = self.dfs(kw)\n            if ret is not None:\n                a.keywords[idx] = ret\n        ori_src = astunparse.unparse(a)\n        func = astunparse.unparse(a.func).strip('\\n').split('.')\n        prefix = '.'.join(func[0:-1])\n        func_name = func[-1]\n        if func_name in self.unsupport_ops:\n            ret = raise_unsupport(func_name, ori_src)\n            return ret\n        if func_name in self.pjmap:\n            ags = [astunparse.unparse(ag).strip('\\n') for ag in a.args]\n            kws = [astunparse.unparse(kw).strip('\\n') for kw in a.keywords]\n            ret = self.convert_(prefix, func_name, ags, kws, ori_src)\n            ret_tmp = ret\n            ret = ast.parse(ret).body[0]\n            if hasattr(ret, 'value'):\n                return ret.value\n            else:\n                print(ret_tmp + '\\n')\n                return ret\n        if '.load_state_dict' in astunparse.unparse(a.func):\n            a.func.attr = 'load_parameters'\n        if astunparse.unparse(a.func).strip('\\n').endswith('.size'):\n            ags = [astunparse.unparse(ag).strip('\\n') for ag in a.args]\n            if len(ags) != 0:\n                con = astunparse.unparse(a.func).split('.size')[0] + '.shape[' + ','.join(ags) + ']'\n            else:\n                con = astunparse.unparse(a.func).replace('size', 'shape')\n            return ast.parse(con).body[0].value\n    elif isinstance(a, ast.Expr):\n        pass\n    elif isinstance(a, ast.Attribute) or isinstance(a, ast.Name):\n        ret = self.replace(a)\n        if ret is not None:\n            print(ret)\n            return ret\n    elif isinstance(a, ast.FunctionDef):\n        if a.name == 'forward':\n            a.name = 'execute'\n    if hasattr(a, '__dict__'):\n        for k in a.__dict__.keys():\n            if isinstance(a.__dict__[k], list):\n                delete_flag = []\n                for (i, a_) in enumerate(a.__dict__[k]):\n                    ret = self.dfs(a_)\n                    if ret == 'delete':\n                        delete_flag.append(True)\n                        continue\n                    if ret is not None:\n                        a.__dict__[k][i] = ret\n                    delete_flag.append(False)\n                tmp = [a_ for (i, a_) in enumerate(a.__dict__[k]) if delete_flag[i] == False]\n                a.__dict__[k] = tmp\n            else:\n                ret = self.dfs(a.__dict__[k])\n                if ret is not None:\n                    a.__dict__[k] = ret",
            "def dfs(self, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(a, ast.Import):\n        if 'torch' in astunparse.unparse(a) and 'init' in astunparse.unparse(a):\n            self.import_flag.append('init')\n            return ast.parse('from jittor import init').body[0]\n        if 'torch' in astunparse.unparse(a) and a.names[0].asname == 'nn':\n            self.import_flag.append('nn')\n            return ast.parse('from jittor import nn').body[0]\n        if 'torch' in a.names[0].name:\n            return 'delete'\n    elif isinstance(a, ast.ImportFrom):\n        if 'torch' in a.module:\n            return 'delete'\n    elif isinstance(a, ast.Call):\n        for (idx, ag) in enumerate(a.args):\n            ret = self.dfs(ag)\n            if ret is not None:\n                a.args[idx] = ret\n        for (idx, kw) in enumerate(a.keywords):\n            ret = self.dfs(kw)\n            if ret is not None:\n                a.keywords[idx] = ret\n        ori_src = astunparse.unparse(a)\n        func = astunparse.unparse(a.func).strip('\\n').split('.')\n        prefix = '.'.join(func[0:-1])\n        func_name = func[-1]\n        if func_name in self.unsupport_ops:\n            ret = raise_unsupport(func_name, ori_src)\n            return ret\n        if func_name in self.pjmap:\n            ags = [astunparse.unparse(ag).strip('\\n') for ag in a.args]\n            kws = [astunparse.unparse(kw).strip('\\n') for kw in a.keywords]\n            ret = self.convert_(prefix, func_name, ags, kws, ori_src)\n            ret_tmp = ret\n            ret = ast.parse(ret).body[0]\n            if hasattr(ret, 'value'):\n                return ret.value\n            else:\n                print(ret_tmp + '\\n')\n                return ret\n        if '.load_state_dict' in astunparse.unparse(a.func):\n            a.func.attr = 'load_parameters'\n        if astunparse.unparse(a.func).strip('\\n').endswith('.size'):\n            ags = [astunparse.unparse(ag).strip('\\n') for ag in a.args]\n            if len(ags) != 0:\n                con = astunparse.unparse(a.func).split('.size')[0] + '.shape[' + ','.join(ags) + ']'\n            else:\n                con = astunparse.unparse(a.func).replace('size', 'shape')\n            return ast.parse(con).body[0].value\n    elif isinstance(a, ast.Expr):\n        pass\n    elif isinstance(a, ast.Attribute) or isinstance(a, ast.Name):\n        ret = self.replace(a)\n        if ret is not None:\n            print(ret)\n            return ret\n    elif isinstance(a, ast.FunctionDef):\n        if a.name == 'forward':\n            a.name = 'execute'\n    if hasattr(a, '__dict__'):\n        for k in a.__dict__.keys():\n            if isinstance(a.__dict__[k], list):\n                delete_flag = []\n                for (i, a_) in enumerate(a.__dict__[k]):\n                    ret = self.dfs(a_)\n                    if ret == 'delete':\n                        delete_flag.append(True)\n                        continue\n                    if ret is not None:\n                        a.__dict__[k][i] = ret\n                    delete_flag.append(False)\n                tmp = [a_ for (i, a_) in enumerate(a.__dict__[k]) if delete_flag[i] == False]\n                a.__dict__[k] = tmp\n            else:\n                ret = self.dfs(a.__dict__[k])\n                if ret is not None:\n                    a.__dict__[k] = ret",
            "def dfs(self, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(a, ast.Import):\n        if 'torch' in astunparse.unparse(a) and 'init' in astunparse.unparse(a):\n            self.import_flag.append('init')\n            return ast.parse('from jittor import init').body[0]\n        if 'torch' in astunparse.unparse(a) and a.names[0].asname == 'nn':\n            self.import_flag.append('nn')\n            return ast.parse('from jittor import nn').body[0]\n        if 'torch' in a.names[0].name:\n            return 'delete'\n    elif isinstance(a, ast.ImportFrom):\n        if 'torch' in a.module:\n            return 'delete'\n    elif isinstance(a, ast.Call):\n        for (idx, ag) in enumerate(a.args):\n            ret = self.dfs(ag)\n            if ret is not None:\n                a.args[idx] = ret\n        for (idx, kw) in enumerate(a.keywords):\n            ret = self.dfs(kw)\n            if ret is not None:\n                a.keywords[idx] = ret\n        ori_src = astunparse.unparse(a)\n        func = astunparse.unparse(a.func).strip('\\n').split('.')\n        prefix = '.'.join(func[0:-1])\n        func_name = func[-1]\n        if func_name in self.unsupport_ops:\n            ret = raise_unsupport(func_name, ori_src)\n            return ret\n        if func_name in self.pjmap:\n            ags = [astunparse.unparse(ag).strip('\\n') for ag in a.args]\n            kws = [astunparse.unparse(kw).strip('\\n') for kw in a.keywords]\n            ret = self.convert_(prefix, func_name, ags, kws, ori_src)\n            ret_tmp = ret\n            ret = ast.parse(ret).body[0]\n            if hasattr(ret, 'value'):\n                return ret.value\n            else:\n                print(ret_tmp + '\\n')\n                return ret\n        if '.load_state_dict' in astunparse.unparse(a.func):\n            a.func.attr = 'load_parameters'\n        if astunparse.unparse(a.func).strip('\\n').endswith('.size'):\n            ags = [astunparse.unparse(ag).strip('\\n') for ag in a.args]\n            if len(ags) != 0:\n                con = astunparse.unparse(a.func).split('.size')[0] + '.shape[' + ','.join(ags) + ']'\n            else:\n                con = astunparse.unparse(a.func).replace('size', 'shape')\n            return ast.parse(con).body[0].value\n    elif isinstance(a, ast.Expr):\n        pass\n    elif isinstance(a, ast.Attribute) or isinstance(a, ast.Name):\n        ret = self.replace(a)\n        if ret is not None:\n            print(ret)\n            return ret\n    elif isinstance(a, ast.FunctionDef):\n        if a.name == 'forward':\n            a.name = 'execute'\n    if hasattr(a, '__dict__'):\n        for k in a.__dict__.keys():\n            if isinstance(a.__dict__[k], list):\n                delete_flag = []\n                for (i, a_) in enumerate(a.__dict__[k]):\n                    ret = self.dfs(a_)\n                    if ret == 'delete':\n                        delete_flag.append(True)\n                        continue\n                    if ret is not None:\n                        a.__dict__[k][i] = ret\n                    delete_flag.append(False)\n                tmp = [a_ for (i, a_) in enumerate(a.__dict__[k]) if delete_flag[i] == False]\n                a.__dict__[k] = tmp\n            else:\n                ret = self.dfs(a.__dict__[k])\n                if ret is not None:\n                    a.__dict__[k] = ret"
        ]
    },
    {
        "func_name": "convert",
        "original": "def convert(code, ex_pjmaps=None):\n    ''' Model code converter, example:\n\n    from jittor.utils.pytorch_converter import convert\n    pytorch_code = \"\"\"\n    class Model(nn.Module):\n        def __init__(self):\n            super().__init__()\n            self.conv1 = nn.Conv2d(1, 10, 3)\n            self.conv2 = nn.Conv2d(10, 32, 3)\n            self.fc = nn.Linear(1200, 100)\n        \n        def forward(self, x):\n            x = self.conv1(x)\n            x = self.conv2(x)\n            x = x.view(x.size(0), -1)\n            x = self.fc(x)\n            return x\n    \"\"\"\n    jittor_code = convert(pytorch_code)\n    print(\"## Generate Jittor code:\", jittor_code)\n    exec(jittor_code)\n    model = Model()\n    print(\"## Jittor model:\", model)\n    '''\n    a = ast.parse(code)\n    converter = Converter(ex_pjmaps)\n    converter.dfs(a)\n    a.body.insert(0, ast.parse('import jittor as jt').body[0])\n    if 'init' not in converter.import_flag:\n        a.body.insert(1, ast.parse('from jittor import init').body[0])\n    if 'nn' not in converter.import_flag:\n        a.body.insert(2, ast.parse('from jittor import nn').body[0])\n    return astunparse.unparse(a)",
        "mutated": [
            "def convert(code, ex_pjmaps=None):\n    if False:\n        i = 10\n    ' Model code converter, example:\\n\\n    from jittor.utils.pytorch_converter import convert\\n    pytorch_code = \"\"\"\\n    class Model(nn.Module):\\n        def __init__(self):\\n            super().__init__()\\n            self.conv1 = nn.Conv2d(1, 10, 3)\\n            self.conv2 = nn.Conv2d(10, 32, 3)\\n            self.fc = nn.Linear(1200, 100)\\n        \\n        def forward(self, x):\\n            x = self.conv1(x)\\n            x = self.conv2(x)\\n            x = x.view(x.size(0), -1)\\n            x = self.fc(x)\\n            return x\\n    \"\"\"\\n    jittor_code = convert(pytorch_code)\\n    print(\"## Generate Jittor code:\", jittor_code)\\n    exec(jittor_code)\\n    model = Model()\\n    print(\"## Jittor model:\", model)\\n    '\n    a = ast.parse(code)\n    converter = Converter(ex_pjmaps)\n    converter.dfs(a)\n    a.body.insert(0, ast.parse('import jittor as jt').body[0])\n    if 'init' not in converter.import_flag:\n        a.body.insert(1, ast.parse('from jittor import init').body[0])\n    if 'nn' not in converter.import_flag:\n        a.body.insert(2, ast.parse('from jittor import nn').body[0])\n    return astunparse.unparse(a)",
            "def convert(code, ex_pjmaps=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Model code converter, example:\\n\\n    from jittor.utils.pytorch_converter import convert\\n    pytorch_code = \"\"\"\\n    class Model(nn.Module):\\n        def __init__(self):\\n            super().__init__()\\n            self.conv1 = nn.Conv2d(1, 10, 3)\\n            self.conv2 = nn.Conv2d(10, 32, 3)\\n            self.fc = nn.Linear(1200, 100)\\n        \\n        def forward(self, x):\\n            x = self.conv1(x)\\n            x = self.conv2(x)\\n            x = x.view(x.size(0), -1)\\n            x = self.fc(x)\\n            return x\\n    \"\"\"\\n    jittor_code = convert(pytorch_code)\\n    print(\"## Generate Jittor code:\", jittor_code)\\n    exec(jittor_code)\\n    model = Model()\\n    print(\"## Jittor model:\", model)\\n    '\n    a = ast.parse(code)\n    converter = Converter(ex_pjmaps)\n    converter.dfs(a)\n    a.body.insert(0, ast.parse('import jittor as jt').body[0])\n    if 'init' not in converter.import_flag:\n        a.body.insert(1, ast.parse('from jittor import init').body[0])\n    if 'nn' not in converter.import_flag:\n        a.body.insert(2, ast.parse('from jittor import nn').body[0])\n    return astunparse.unparse(a)",
            "def convert(code, ex_pjmaps=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Model code converter, example:\\n\\n    from jittor.utils.pytorch_converter import convert\\n    pytorch_code = \"\"\"\\n    class Model(nn.Module):\\n        def __init__(self):\\n            super().__init__()\\n            self.conv1 = nn.Conv2d(1, 10, 3)\\n            self.conv2 = nn.Conv2d(10, 32, 3)\\n            self.fc = nn.Linear(1200, 100)\\n        \\n        def forward(self, x):\\n            x = self.conv1(x)\\n            x = self.conv2(x)\\n            x = x.view(x.size(0), -1)\\n            x = self.fc(x)\\n            return x\\n    \"\"\"\\n    jittor_code = convert(pytorch_code)\\n    print(\"## Generate Jittor code:\", jittor_code)\\n    exec(jittor_code)\\n    model = Model()\\n    print(\"## Jittor model:\", model)\\n    '\n    a = ast.parse(code)\n    converter = Converter(ex_pjmaps)\n    converter.dfs(a)\n    a.body.insert(0, ast.parse('import jittor as jt').body[0])\n    if 'init' not in converter.import_flag:\n        a.body.insert(1, ast.parse('from jittor import init').body[0])\n    if 'nn' not in converter.import_flag:\n        a.body.insert(2, ast.parse('from jittor import nn').body[0])\n    return astunparse.unparse(a)",
            "def convert(code, ex_pjmaps=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Model code converter, example:\\n\\n    from jittor.utils.pytorch_converter import convert\\n    pytorch_code = \"\"\"\\n    class Model(nn.Module):\\n        def __init__(self):\\n            super().__init__()\\n            self.conv1 = nn.Conv2d(1, 10, 3)\\n            self.conv2 = nn.Conv2d(10, 32, 3)\\n            self.fc = nn.Linear(1200, 100)\\n        \\n        def forward(self, x):\\n            x = self.conv1(x)\\n            x = self.conv2(x)\\n            x = x.view(x.size(0), -1)\\n            x = self.fc(x)\\n            return x\\n    \"\"\"\\n    jittor_code = convert(pytorch_code)\\n    print(\"## Generate Jittor code:\", jittor_code)\\n    exec(jittor_code)\\n    model = Model()\\n    print(\"## Jittor model:\", model)\\n    '\n    a = ast.parse(code)\n    converter = Converter(ex_pjmaps)\n    converter.dfs(a)\n    a.body.insert(0, ast.parse('import jittor as jt').body[0])\n    if 'init' not in converter.import_flag:\n        a.body.insert(1, ast.parse('from jittor import init').body[0])\n    if 'nn' not in converter.import_flag:\n        a.body.insert(2, ast.parse('from jittor import nn').body[0])\n    return astunparse.unparse(a)",
            "def convert(code, ex_pjmaps=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Model code converter, example:\\n\\n    from jittor.utils.pytorch_converter import convert\\n    pytorch_code = \"\"\"\\n    class Model(nn.Module):\\n        def __init__(self):\\n            super().__init__()\\n            self.conv1 = nn.Conv2d(1, 10, 3)\\n            self.conv2 = nn.Conv2d(10, 32, 3)\\n            self.fc = nn.Linear(1200, 100)\\n        \\n        def forward(self, x):\\n            x = self.conv1(x)\\n            x = self.conv2(x)\\n            x = x.view(x.size(0), -1)\\n            x = self.fc(x)\\n            return x\\n    \"\"\"\\n    jittor_code = convert(pytorch_code)\\n    print(\"## Generate Jittor code:\", jittor_code)\\n    exec(jittor_code)\\n    model = Model()\\n    print(\"## Jittor model:\", model)\\n    '\n    a = ast.parse(code)\n    converter = Converter(ex_pjmaps)\n    converter.dfs(a)\n    a.body.insert(0, ast.parse('import jittor as jt').body[0])\n    if 'init' not in converter.import_flag:\n        a.body.insert(1, ast.parse('from jittor import init').body[0])\n    if 'nn' not in converter.import_flag:\n        a.body.insert(2, ast.parse('from jittor import nn').body[0])\n    return astunparse.unparse(a)"
        ]
    }
]