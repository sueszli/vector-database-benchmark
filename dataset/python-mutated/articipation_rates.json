[
    {
        "func_name": "get_all_participation_rates",
        "original": "def get_all_participation_rates(data, param, fault_names):\n    \"\"\"\n    data : list (MFDs_to_pkl in main code)\n    \"\"\"\n    fault_names = data[1]\n    mfd_singles = data[2]\n    mfd_total = [0 for _ in mfd_singles[0]]\n    for i in range(len(mfd_singles)):\n        mfd_total = [x + y for (x, y) in zip(mfd_total, mfd_singles[i])]\n    mfd_multi = data[4]\n    for i in range(len(mfd_multi)):\n        mfd_total = [x + y for (x, y) in zip(mfd_total, mfd_multi[i])]\n    involved_faults = data[5]\n    ruptures = {}\n    with open(param['dirpath'] + param['main']['rupture_file'], newline='') as csvfile:\n        spamreader = csv.reader(csvfile, delimiter='\\t', quotechar='|')\n        next(spamreader)\n        rup_id = 0\n        for row in spamreader:\n            ruptures.update({rup_id: [str(i) for i in row[0].split(' ')[:-1]]})\n            rup_id += 1\n    \"\\n    # get the properties of the faults\\n    prop_file = open(path + '../../LOG/ModelMultiFaultsTest_prop.pkl','rb')\\n    #prop_file = open(path + '../../LOG/DOM_v1_prop.pkl','rb')\\n    f_prop = pickle.load(prop_file)\\n    \"\n    dict_p_rates = {}\n    all_non_zero_rups = []\n    for fault_name in fault_names:\n        \"\\n        fault_id = None\\n        for fid in f_prop.keys():\\n            if f_prop[fid]['name'] == fault_name :\\n                fault_id = fid\\n        \"\n        fault_id = fault_names.index(fault_name)\n        p_rate = [0 for _ in mfd_total]\n        p_rate = [x + y for (x, y) in zip(p_rate, mfd_singles[fault_id])]\n        i_sc = 0\n        non_zero_rups = 0\n        for involved_faults_i in involved_faults:\n            if fault_id in list(involved_faults_i[0]):\n                p_rate = [sum(x) for x in zip(p_rate, mfd_multi[i_sc])]\n                if sum(mfd_multi[i_sc]) != 0.0:\n                    non_zero_rups += 1\n            i_sc += 1\n        dict_p_rates.update({fault_name: p_rate})\n        all_non_zero_rups.append(non_zero_rups)\n    return (dict_p_rates, mfd_total, all_non_zero_rups)",
        "mutated": [
            "def get_all_participation_rates(data, param, fault_names):\n    if False:\n        i = 10\n    '\\n    data : list (MFDs_to_pkl in main code)\\n    '\n    fault_names = data[1]\n    mfd_singles = data[2]\n    mfd_total = [0 for _ in mfd_singles[0]]\n    for i in range(len(mfd_singles)):\n        mfd_total = [x + y for (x, y) in zip(mfd_total, mfd_singles[i])]\n    mfd_multi = data[4]\n    for i in range(len(mfd_multi)):\n        mfd_total = [x + y for (x, y) in zip(mfd_total, mfd_multi[i])]\n    involved_faults = data[5]\n    ruptures = {}\n    with open(param['dirpath'] + param['main']['rupture_file'], newline='') as csvfile:\n        spamreader = csv.reader(csvfile, delimiter='\\t', quotechar='|')\n        next(spamreader)\n        rup_id = 0\n        for row in spamreader:\n            ruptures.update({rup_id: [str(i) for i in row[0].split(' ')[:-1]]})\n            rup_id += 1\n    \"\\n    # get the properties of the faults\\n    prop_file = open(path + '../../LOG/ModelMultiFaultsTest_prop.pkl','rb')\\n    #prop_file = open(path + '../../LOG/DOM_v1_prop.pkl','rb')\\n    f_prop = pickle.load(prop_file)\\n    \"\n    dict_p_rates = {}\n    all_non_zero_rups = []\n    for fault_name in fault_names:\n        \"\\n        fault_id = None\\n        for fid in f_prop.keys():\\n            if f_prop[fid]['name'] == fault_name :\\n                fault_id = fid\\n        \"\n        fault_id = fault_names.index(fault_name)\n        p_rate = [0 for _ in mfd_total]\n        p_rate = [x + y for (x, y) in zip(p_rate, mfd_singles[fault_id])]\n        i_sc = 0\n        non_zero_rups = 0\n        for involved_faults_i in involved_faults:\n            if fault_id in list(involved_faults_i[0]):\n                p_rate = [sum(x) for x in zip(p_rate, mfd_multi[i_sc])]\n                if sum(mfd_multi[i_sc]) != 0.0:\n                    non_zero_rups += 1\n            i_sc += 1\n        dict_p_rates.update({fault_name: p_rate})\n        all_non_zero_rups.append(non_zero_rups)\n    return (dict_p_rates, mfd_total, all_non_zero_rups)",
            "def get_all_participation_rates(data, param, fault_names):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    data : list (MFDs_to_pkl in main code)\\n    '\n    fault_names = data[1]\n    mfd_singles = data[2]\n    mfd_total = [0 for _ in mfd_singles[0]]\n    for i in range(len(mfd_singles)):\n        mfd_total = [x + y for (x, y) in zip(mfd_total, mfd_singles[i])]\n    mfd_multi = data[4]\n    for i in range(len(mfd_multi)):\n        mfd_total = [x + y for (x, y) in zip(mfd_total, mfd_multi[i])]\n    involved_faults = data[5]\n    ruptures = {}\n    with open(param['dirpath'] + param['main']['rupture_file'], newline='') as csvfile:\n        spamreader = csv.reader(csvfile, delimiter='\\t', quotechar='|')\n        next(spamreader)\n        rup_id = 0\n        for row in spamreader:\n            ruptures.update({rup_id: [str(i) for i in row[0].split(' ')[:-1]]})\n            rup_id += 1\n    \"\\n    # get the properties of the faults\\n    prop_file = open(path + '../../LOG/ModelMultiFaultsTest_prop.pkl','rb')\\n    #prop_file = open(path + '../../LOG/DOM_v1_prop.pkl','rb')\\n    f_prop = pickle.load(prop_file)\\n    \"\n    dict_p_rates = {}\n    all_non_zero_rups = []\n    for fault_name in fault_names:\n        \"\\n        fault_id = None\\n        for fid in f_prop.keys():\\n            if f_prop[fid]['name'] == fault_name :\\n                fault_id = fid\\n        \"\n        fault_id = fault_names.index(fault_name)\n        p_rate = [0 for _ in mfd_total]\n        p_rate = [x + y for (x, y) in zip(p_rate, mfd_singles[fault_id])]\n        i_sc = 0\n        non_zero_rups = 0\n        for involved_faults_i in involved_faults:\n            if fault_id in list(involved_faults_i[0]):\n                p_rate = [sum(x) for x in zip(p_rate, mfd_multi[i_sc])]\n                if sum(mfd_multi[i_sc]) != 0.0:\n                    non_zero_rups += 1\n            i_sc += 1\n        dict_p_rates.update({fault_name: p_rate})\n        all_non_zero_rups.append(non_zero_rups)\n    return (dict_p_rates, mfd_total, all_non_zero_rups)",
            "def get_all_participation_rates(data, param, fault_names):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    data : list (MFDs_to_pkl in main code)\\n    '\n    fault_names = data[1]\n    mfd_singles = data[2]\n    mfd_total = [0 for _ in mfd_singles[0]]\n    for i in range(len(mfd_singles)):\n        mfd_total = [x + y for (x, y) in zip(mfd_total, mfd_singles[i])]\n    mfd_multi = data[4]\n    for i in range(len(mfd_multi)):\n        mfd_total = [x + y for (x, y) in zip(mfd_total, mfd_multi[i])]\n    involved_faults = data[5]\n    ruptures = {}\n    with open(param['dirpath'] + param['main']['rupture_file'], newline='') as csvfile:\n        spamreader = csv.reader(csvfile, delimiter='\\t', quotechar='|')\n        next(spamreader)\n        rup_id = 0\n        for row in spamreader:\n            ruptures.update({rup_id: [str(i) for i in row[0].split(' ')[:-1]]})\n            rup_id += 1\n    \"\\n    # get the properties of the faults\\n    prop_file = open(path + '../../LOG/ModelMultiFaultsTest_prop.pkl','rb')\\n    #prop_file = open(path + '../../LOG/DOM_v1_prop.pkl','rb')\\n    f_prop = pickle.load(prop_file)\\n    \"\n    dict_p_rates = {}\n    all_non_zero_rups = []\n    for fault_name in fault_names:\n        \"\\n        fault_id = None\\n        for fid in f_prop.keys():\\n            if f_prop[fid]['name'] == fault_name :\\n                fault_id = fid\\n        \"\n        fault_id = fault_names.index(fault_name)\n        p_rate = [0 for _ in mfd_total]\n        p_rate = [x + y for (x, y) in zip(p_rate, mfd_singles[fault_id])]\n        i_sc = 0\n        non_zero_rups = 0\n        for involved_faults_i in involved_faults:\n            if fault_id in list(involved_faults_i[0]):\n                p_rate = [sum(x) for x in zip(p_rate, mfd_multi[i_sc])]\n                if sum(mfd_multi[i_sc]) != 0.0:\n                    non_zero_rups += 1\n            i_sc += 1\n        dict_p_rates.update({fault_name: p_rate})\n        all_non_zero_rups.append(non_zero_rups)\n    return (dict_p_rates, mfd_total, all_non_zero_rups)",
            "def get_all_participation_rates(data, param, fault_names):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    data : list (MFDs_to_pkl in main code)\\n    '\n    fault_names = data[1]\n    mfd_singles = data[2]\n    mfd_total = [0 for _ in mfd_singles[0]]\n    for i in range(len(mfd_singles)):\n        mfd_total = [x + y for (x, y) in zip(mfd_total, mfd_singles[i])]\n    mfd_multi = data[4]\n    for i in range(len(mfd_multi)):\n        mfd_total = [x + y for (x, y) in zip(mfd_total, mfd_multi[i])]\n    involved_faults = data[5]\n    ruptures = {}\n    with open(param['dirpath'] + param['main']['rupture_file'], newline='') as csvfile:\n        spamreader = csv.reader(csvfile, delimiter='\\t', quotechar='|')\n        next(spamreader)\n        rup_id = 0\n        for row in spamreader:\n            ruptures.update({rup_id: [str(i) for i in row[0].split(' ')[:-1]]})\n            rup_id += 1\n    \"\\n    # get the properties of the faults\\n    prop_file = open(path + '../../LOG/ModelMultiFaultsTest_prop.pkl','rb')\\n    #prop_file = open(path + '../../LOG/DOM_v1_prop.pkl','rb')\\n    f_prop = pickle.load(prop_file)\\n    \"\n    dict_p_rates = {}\n    all_non_zero_rups = []\n    for fault_name in fault_names:\n        \"\\n        fault_id = None\\n        for fid in f_prop.keys():\\n            if f_prop[fid]['name'] == fault_name :\\n                fault_id = fid\\n        \"\n        fault_id = fault_names.index(fault_name)\n        p_rate = [0 for _ in mfd_total]\n        p_rate = [x + y for (x, y) in zip(p_rate, mfd_singles[fault_id])]\n        i_sc = 0\n        non_zero_rups = 0\n        for involved_faults_i in involved_faults:\n            if fault_id in list(involved_faults_i[0]):\n                p_rate = [sum(x) for x in zip(p_rate, mfd_multi[i_sc])]\n                if sum(mfd_multi[i_sc]) != 0.0:\n                    non_zero_rups += 1\n            i_sc += 1\n        dict_p_rates.update({fault_name: p_rate})\n        all_non_zero_rups.append(non_zero_rups)\n    return (dict_p_rates, mfd_total, all_non_zero_rups)",
            "def get_all_participation_rates(data, param, fault_names):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    data : list (MFDs_to_pkl in main code)\\n    '\n    fault_names = data[1]\n    mfd_singles = data[2]\n    mfd_total = [0 for _ in mfd_singles[0]]\n    for i in range(len(mfd_singles)):\n        mfd_total = [x + y for (x, y) in zip(mfd_total, mfd_singles[i])]\n    mfd_multi = data[4]\n    for i in range(len(mfd_multi)):\n        mfd_total = [x + y for (x, y) in zip(mfd_total, mfd_multi[i])]\n    involved_faults = data[5]\n    ruptures = {}\n    with open(param['dirpath'] + param['main']['rupture_file'], newline='') as csvfile:\n        spamreader = csv.reader(csvfile, delimiter='\\t', quotechar='|')\n        next(spamreader)\n        rup_id = 0\n        for row in spamreader:\n            ruptures.update({rup_id: [str(i) for i in row[0].split(' ')[:-1]]})\n            rup_id += 1\n    \"\\n    # get the properties of the faults\\n    prop_file = open(path + '../../LOG/ModelMultiFaultsTest_prop.pkl','rb')\\n    #prop_file = open(path + '../../LOG/DOM_v1_prop.pkl','rb')\\n    f_prop = pickle.load(prop_file)\\n    \"\n    dict_p_rates = {}\n    all_non_zero_rups = []\n    for fault_name in fault_names:\n        \"\\n        fault_id = None\\n        for fid in f_prop.keys():\\n            if f_prop[fid]['name'] == fault_name :\\n                fault_id = fid\\n        \"\n        fault_id = fault_names.index(fault_name)\n        p_rate = [0 for _ in mfd_total]\n        p_rate = [x + y for (x, y) in zip(p_rate, mfd_singles[fault_id])]\n        i_sc = 0\n        non_zero_rups = 0\n        for involved_faults_i in involved_faults:\n            if fault_id in list(involved_faults_i[0]):\n                p_rate = [sum(x) for x in zip(p_rate, mfd_multi[i_sc])]\n                if sum(mfd_multi[i_sc]) != 0.0:\n                    non_zero_rups += 1\n            i_sc += 1\n        dict_p_rates.update({fault_name: p_rate})\n        all_non_zero_rups.append(non_zero_rups)\n    return (dict_p_rates, mfd_total, all_non_zero_rups)"
        ]
    },
    {
        "func_name": "get_bin_mag",
        "original": "def get_bin_mag(mfd_total, Mmin):\n    bin_mag = []\n    for i in range(len(mfd_total)):\n        bin_mag.append(Mmin + 0.1 * i)\n    return bin_mag",
        "mutated": [
            "def get_bin_mag(mfd_total, Mmin):\n    if False:\n        i = 10\n    bin_mag = []\n    for i in range(len(mfd_total)):\n        bin_mag.append(Mmin + 0.1 * i)\n    return bin_mag",
            "def get_bin_mag(mfd_total, Mmin):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    bin_mag = []\n    for i in range(len(mfd_total)):\n        bin_mag.append(Mmin + 0.1 * i)\n    return bin_mag",
            "def get_bin_mag(mfd_total, Mmin):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    bin_mag = []\n    for i in range(len(mfd_total)):\n        bin_mag.append(Mmin + 0.1 * i)\n    return bin_mag",
            "def get_bin_mag(mfd_total, Mmin):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    bin_mag = []\n    for i in range(len(mfd_total)):\n        bin_mag.append(Mmin + 0.1 * i)\n    return bin_mag",
            "def get_bin_mag(mfd_total, Mmin):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    bin_mag = []\n    for i in range(len(mfd_total)):\n        bin_mag.append(Mmin + 0.1 * i)\n    return bin_mag"
        ]
    },
    {
        "func_name": "extract_rates",
        "original": "def extract_rates(fault_name, dict_p_rates):\n    incremental_rate = dict_p_rates[fault_name]\n    cumulative_rate = [sum(incremental_rate[i:]) for i in range(len(incremental_rate))]\n    return (incremental_rate, cumulative_rate)",
        "mutated": [
            "def extract_rates(fault_name, dict_p_rates):\n    if False:\n        i = 10\n    incremental_rate = dict_p_rates[fault_name]\n    cumulative_rate = [sum(incremental_rate[i:]) for i in range(len(incremental_rate))]\n    return (incremental_rate, cumulative_rate)",
            "def extract_rates(fault_name, dict_p_rates):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    incremental_rate = dict_p_rates[fault_name]\n    cumulative_rate = [sum(incremental_rate[i:]) for i in range(len(incremental_rate))]\n    return (incremental_rate, cumulative_rate)",
            "def extract_rates(fault_name, dict_p_rates):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    incremental_rate = dict_p_rates[fault_name]\n    cumulative_rate = [sum(incremental_rate[i:]) for i in range(len(incremental_rate))]\n    return (incremental_rate, cumulative_rate)",
            "def extract_rates(fault_name, dict_p_rates):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    incremental_rate = dict_p_rates[fault_name]\n    cumulative_rate = [sum(incremental_rate[i:]) for i in range(len(incremental_rate))]\n    return (incremental_rate, cumulative_rate)",
            "def extract_rates(fault_name, dict_p_rates):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    incremental_rate = dict_p_rates[fault_name]\n    cumulative_rate = [sum(incremental_rate[i:]) for i in range(len(incremental_rate))]\n    return (incremental_rate, cumulative_rate)"
        ]
    },
    {
        "func_name": "plot_participation_rates",
        "original": "def plot_participation_rates(bin_mag, incremental_rate, cumulative_rate, fault_name, ptf):\n    \"\"\"\n    ptf : path to fig\n    \"\"\"\n    plt.scatter(bin_mag, incremental_rate, c='k', label='incremental rates')\n    plt.plot(bin_mag, cumulative_rate, c='k', label='cumulative rates')\n    plt.title(fault_name)\n    plt.yscale('log')\n    plt.legend()\n    plt.xlabel('magnitude')\n    plt.ylabel('annual earthquake rate')\n    plt.gcf().set_dpi(120)\n    plt.savefig(ptf)\n    plt.close()",
        "mutated": [
            "def plot_participation_rates(bin_mag, incremental_rate, cumulative_rate, fault_name, ptf):\n    if False:\n        i = 10\n    '\\n    ptf : path to fig\\n    '\n    plt.scatter(bin_mag, incremental_rate, c='k', label='incremental rates')\n    plt.plot(bin_mag, cumulative_rate, c='k', label='cumulative rates')\n    plt.title(fault_name)\n    plt.yscale('log')\n    plt.legend()\n    plt.xlabel('magnitude')\n    plt.ylabel('annual earthquake rate')\n    plt.gcf().set_dpi(120)\n    plt.savefig(ptf)\n    plt.close()",
            "def plot_participation_rates(bin_mag, incremental_rate, cumulative_rate, fault_name, ptf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    ptf : path to fig\\n    '\n    plt.scatter(bin_mag, incremental_rate, c='k', label='incremental rates')\n    plt.plot(bin_mag, cumulative_rate, c='k', label='cumulative rates')\n    plt.title(fault_name)\n    plt.yscale('log')\n    plt.legend()\n    plt.xlabel('magnitude')\n    plt.ylabel('annual earthquake rate')\n    plt.gcf().set_dpi(120)\n    plt.savefig(ptf)\n    plt.close()",
            "def plot_participation_rates(bin_mag, incremental_rate, cumulative_rate, fault_name, ptf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    ptf : path to fig\\n    '\n    plt.scatter(bin_mag, incremental_rate, c='k', label='incremental rates')\n    plt.plot(bin_mag, cumulative_rate, c='k', label='cumulative rates')\n    plt.title(fault_name)\n    plt.yscale('log')\n    plt.legend()\n    plt.xlabel('magnitude')\n    plt.ylabel('annual earthquake rate')\n    plt.gcf().set_dpi(120)\n    plt.savefig(ptf)\n    plt.close()",
            "def plot_participation_rates(bin_mag, incremental_rate, cumulative_rate, fault_name, ptf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    ptf : path to fig\\n    '\n    plt.scatter(bin_mag, incremental_rate, c='k', label='incremental rates')\n    plt.plot(bin_mag, cumulative_rate, c='k', label='cumulative rates')\n    plt.title(fault_name)\n    plt.yscale('log')\n    plt.legend()\n    plt.xlabel('magnitude')\n    plt.ylabel('annual earthquake rate')\n    plt.gcf().set_dpi(120)\n    plt.savefig(ptf)\n    plt.close()",
            "def plot_participation_rates(bin_mag, incremental_rate, cumulative_rate, fault_name, ptf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    ptf : path to fig\\n    '\n    plt.scatter(bin_mag, incremental_rate, c='k', label='incremental rates')\n    plt.plot(bin_mag, cumulative_rate, c='k', label='cumulative rates')\n    plt.title(fault_name)\n    plt.yscale('log')\n    plt.legend()\n    plt.xlabel('magnitude')\n    plt.ylabel('annual earthquake rate')\n    plt.gcf().set_dpi(120)\n    plt.savefig(ptf)\n    plt.close()"
        ]
    }
]