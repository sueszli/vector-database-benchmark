[
    {
        "func_name": "_get_dtype",
        "original": "def _get_dtype(dtype):\n    \"\"\"Return np.complex128 for complex dtypes, np.float64 otherwise.\"\"\"\n    if np.issubdtype(dtype, np.complexfloating):\n        return np.complex128\n    else:\n        return np.float64",
        "mutated": [
            "def _get_dtype(dtype):\n    if False:\n        i = 10\n    'Return np.complex128 for complex dtypes, np.float64 otherwise.'\n    if np.issubdtype(dtype, np.complexfloating):\n        return np.complex128\n    else:\n        return np.float64",
            "def _get_dtype(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return np.complex128 for complex dtypes, np.float64 otherwise.'\n    if np.issubdtype(dtype, np.complexfloating):\n        return np.complex128\n    else:\n        return np.float64",
            "def _get_dtype(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return np.complex128 for complex dtypes, np.float64 otherwise.'\n    if np.issubdtype(dtype, np.complexfloating):\n        return np.complex128\n    else:\n        return np.float64",
            "def _get_dtype(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return np.complex128 for complex dtypes, np.float64 otherwise.'\n    if np.issubdtype(dtype, np.complexfloating):\n        return np.complex128\n    else:\n        return np.float64",
            "def _get_dtype(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return np.complex128 for complex dtypes, np.float64 otherwise.'\n    if np.issubdtype(dtype, np.complexfloating):\n        return np.complex128\n    else:\n        return np.float64"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, t, c, k, *, extrapolate=None):\n    ndim = len(t)\n    try:\n        len(k)\n    except TypeError:\n        k = (k,) * ndim\n    if len(k) != ndim:\n        raise ValueError(f'len(t) = {len(t)!r} != len(k) = {len(k)!r}.')\n    self.k = tuple((operator.index(ki) for ki in k))\n    self.t = tuple((np.ascontiguousarray(ti, dtype=float) for ti in t))\n    self.c = np.asarray(c)\n    if extrapolate is None:\n        extrapolate = True\n    self.extrapolate = bool(extrapolate)\n    self.c = np.asarray(c)\n    for d in range(ndim):\n        td = self.t[d]\n        kd = self.k[d]\n        n = td.shape[0] - kd - 1\n        if kd < 0:\n            raise ValueError(f'Spline degree in dimension {d} cannot be negative.')\n        if td.ndim != 1:\n            raise ValueError(f'Knot vector in dimension {d} must be one-dimensional.')\n        if n < kd + 1:\n            raise ValueError(f'Need at least {2 * kd + 2} knots for degree {kd} in dimension {d}.')\n        if (np.diff(td) < 0).any():\n            raise ValueError(f'Knots in dimension {d} must be in a non-decreasing order.')\n        if len(np.unique(td[kd:n + 1])) < 2:\n            raise ValueError(f'Need at least two internal knots in dimension {d}.')\n        if not np.isfinite(td).all():\n            raise ValueError(f'Knots in dimension {d} should not have nans or infs.')\n        if self.c.ndim < ndim:\n            raise ValueError(f'Coefficients must be at least {d}-dimensional.')\n        if self.c.shape[d] != n:\n            raise ValueError(f'Knots, coefficients and degree in dimension {d} are inconsistent: got {self.c.shape[d]} coefficients for {len(td)} knots, need at least {n} for k={k}.')\n    dt = _get_dtype(self.c.dtype)\n    self.c = np.ascontiguousarray(self.c, dtype=dt)",
        "mutated": [
            "def __init__(self, t, c, k, *, extrapolate=None):\n    if False:\n        i = 10\n    ndim = len(t)\n    try:\n        len(k)\n    except TypeError:\n        k = (k,) * ndim\n    if len(k) != ndim:\n        raise ValueError(f'len(t) = {len(t)!r} != len(k) = {len(k)!r}.')\n    self.k = tuple((operator.index(ki) for ki in k))\n    self.t = tuple((np.ascontiguousarray(ti, dtype=float) for ti in t))\n    self.c = np.asarray(c)\n    if extrapolate is None:\n        extrapolate = True\n    self.extrapolate = bool(extrapolate)\n    self.c = np.asarray(c)\n    for d in range(ndim):\n        td = self.t[d]\n        kd = self.k[d]\n        n = td.shape[0] - kd - 1\n        if kd < 0:\n            raise ValueError(f'Spline degree in dimension {d} cannot be negative.')\n        if td.ndim != 1:\n            raise ValueError(f'Knot vector in dimension {d} must be one-dimensional.')\n        if n < kd + 1:\n            raise ValueError(f'Need at least {2 * kd + 2} knots for degree {kd} in dimension {d}.')\n        if (np.diff(td) < 0).any():\n            raise ValueError(f'Knots in dimension {d} must be in a non-decreasing order.')\n        if len(np.unique(td[kd:n + 1])) < 2:\n            raise ValueError(f'Need at least two internal knots in dimension {d}.')\n        if not np.isfinite(td).all():\n            raise ValueError(f'Knots in dimension {d} should not have nans or infs.')\n        if self.c.ndim < ndim:\n            raise ValueError(f'Coefficients must be at least {d}-dimensional.')\n        if self.c.shape[d] != n:\n            raise ValueError(f'Knots, coefficients and degree in dimension {d} are inconsistent: got {self.c.shape[d]} coefficients for {len(td)} knots, need at least {n} for k={k}.')\n    dt = _get_dtype(self.c.dtype)\n    self.c = np.ascontiguousarray(self.c, dtype=dt)",
            "def __init__(self, t, c, k, *, extrapolate=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ndim = len(t)\n    try:\n        len(k)\n    except TypeError:\n        k = (k,) * ndim\n    if len(k) != ndim:\n        raise ValueError(f'len(t) = {len(t)!r} != len(k) = {len(k)!r}.')\n    self.k = tuple((operator.index(ki) for ki in k))\n    self.t = tuple((np.ascontiguousarray(ti, dtype=float) for ti in t))\n    self.c = np.asarray(c)\n    if extrapolate is None:\n        extrapolate = True\n    self.extrapolate = bool(extrapolate)\n    self.c = np.asarray(c)\n    for d in range(ndim):\n        td = self.t[d]\n        kd = self.k[d]\n        n = td.shape[0] - kd - 1\n        if kd < 0:\n            raise ValueError(f'Spline degree in dimension {d} cannot be negative.')\n        if td.ndim != 1:\n            raise ValueError(f'Knot vector in dimension {d} must be one-dimensional.')\n        if n < kd + 1:\n            raise ValueError(f'Need at least {2 * kd + 2} knots for degree {kd} in dimension {d}.')\n        if (np.diff(td) < 0).any():\n            raise ValueError(f'Knots in dimension {d} must be in a non-decreasing order.')\n        if len(np.unique(td[kd:n + 1])) < 2:\n            raise ValueError(f'Need at least two internal knots in dimension {d}.')\n        if not np.isfinite(td).all():\n            raise ValueError(f'Knots in dimension {d} should not have nans or infs.')\n        if self.c.ndim < ndim:\n            raise ValueError(f'Coefficients must be at least {d}-dimensional.')\n        if self.c.shape[d] != n:\n            raise ValueError(f'Knots, coefficients and degree in dimension {d} are inconsistent: got {self.c.shape[d]} coefficients for {len(td)} knots, need at least {n} for k={k}.')\n    dt = _get_dtype(self.c.dtype)\n    self.c = np.ascontiguousarray(self.c, dtype=dt)",
            "def __init__(self, t, c, k, *, extrapolate=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ndim = len(t)\n    try:\n        len(k)\n    except TypeError:\n        k = (k,) * ndim\n    if len(k) != ndim:\n        raise ValueError(f'len(t) = {len(t)!r} != len(k) = {len(k)!r}.')\n    self.k = tuple((operator.index(ki) for ki in k))\n    self.t = tuple((np.ascontiguousarray(ti, dtype=float) for ti in t))\n    self.c = np.asarray(c)\n    if extrapolate is None:\n        extrapolate = True\n    self.extrapolate = bool(extrapolate)\n    self.c = np.asarray(c)\n    for d in range(ndim):\n        td = self.t[d]\n        kd = self.k[d]\n        n = td.shape[0] - kd - 1\n        if kd < 0:\n            raise ValueError(f'Spline degree in dimension {d} cannot be negative.')\n        if td.ndim != 1:\n            raise ValueError(f'Knot vector in dimension {d} must be one-dimensional.')\n        if n < kd + 1:\n            raise ValueError(f'Need at least {2 * kd + 2} knots for degree {kd} in dimension {d}.')\n        if (np.diff(td) < 0).any():\n            raise ValueError(f'Knots in dimension {d} must be in a non-decreasing order.')\n        if len(np.unique(td[kd:n + 1])) < 2:\n            raise ValueError(f'Need at least two internal knots in dimension {d}.')\n        if not np.isfinite(td).all():\n            raise ValueError(f'Knots in dimension {d} should not have nans or infs.')\n        if self.c.ndim < ndim:\n            raise ValueError(f'Coefficients must be at least {d}-dimensional.')\n        if self.c.shape[d] != n:\n            raise ValueError(f'Knots, coefficients and degree in dimension {d} are inconsistent: got {self.c.shape[d]} coefficients for {len(td)} knots, need at least {n} for k={k}.')\n    dt = _get_dtype(self.c.dtype)\n    self.c = np.ascontiguousarray(self.c, dtype=dt)",
            "def __init__(self, t, c, k, *, extrapolate=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ndim = len(t)\n    try:\n        len(k)\n    except TypeError:\n        k = (k,) * ndim\n    if len(k) != ndim:\n        raise ValueError(f'len(t) = {len(t)!r} != len(k) = {len(k)!r}.')\n    self.k = tuple((operator.index(ki) for ki in k))\n    self.t = tuple((np.ascontiguousarray(ti, dtype=float) for ti in t))\n    self.c = np.asarray(c)\n    if extrapolate is None:\n        extrapolate = True\n    self.extrapolate = bool(extrapolate)\n    self.c = np.asarray(c)\n    for d in range(ndim):\n        td = self.t[d]\n        kd = self.k[d]\n        n = td.shape[0] - kd - 1\n        if kd < 0:\n            raise ValueError(f'Spline degree in dimension {d} cannot be negative.')\n        if td.ndim != 1:\n            raise ValueError(f'Knot vector in dimension {d} must be one-dimensional.')\n        if n < kd + 1:\n            raise ValueError(f'Need at least {2 * kd + 2} knots for degree {kd} in dimension {d}.')\n        if (np.diff(td) < 0).any():\n            raise ValueError(f'Knots in dimension {d} must be in a non-decreasing order.')\n        if len(np.unique(td[kd:n + 1])) < 2:\n            raise ValueError(f'Need at least two internal knots in dimension {d}.')\n        if not np.isfinite(td).all():\n            raise ValueError(f'Knots in dimension {d} should not have nans or infs.')\n        if self.c.ndim < ndim:\n            raise ValueError(f'Coefficients must be at least {d}-dimensional.')\n        if self.c.shape[d] != n:\n            raise ValueError(f'Knots, coefficients and degree in dimension {d} are inconsistent: got {self.c.shape[d]} coefficients for {len(td)} knots, need at least {n} for k={k}.')\n    dt = _get_dtype(self.c.dtype)\n    self.c = np.ascontiguousarray(self.c, dtype=dt)",
            "def __init__(self, t, c, k, *, extrapolate=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ndim = len(t)\n    try:\n        len(k)\n    except TypeError:\n        k = (k,) * ndim\n    if len(k) != ndim:\n        raise ValueError(f'len(t) = {len(t)!r} != len(k) = {len(k)!r}.')\n    self.k = tuple((operator.index(ki) for ki in k))\n    self.t = tuple((np.ascontiguousarray(ti, dtype=float) for ti in t))\n    self.c = np.asarray(c)\n    if extrapolate is None:\n        extrapolate = True\n    self.extrapolate = bool(extrapolate)\n    self.c = np.asarray(c)\n    for d in range(ndim):\n        td = self.t[d]\n        kd = self.k[d]\n        n = td.shape[0] - kd - 1\n        if kd < 0:\n            raise ValueError(f'Spline degree in dimension {d} cannot be negative.')\n        if td.ndim != 1:\n            raise ValueError(f'Knot vector in dimension {d} must be one-dimensional.')\n        if n < kd + 1:\n            raise ValueError(f'Need at least {2 * kd + 2} knots for degree {kd} in dimension {d}.')\n        if (np.diff(td) < 0).any():\n            raise ValueError(f'Knots in dimension {d} must be in a non-decreasing order.')\n        if len(np.unique(td[kd:n + 1])) < 2:\n            raise ValueError(f'Need at least two internal knots in dimension {d}.')\n        if not np.isfinite(td).all():\n            raise ValueError(f'Knots in dimension {d} should not have nans or infs.')\n        if self.c.ndim < ndim:\n            raise ValueError(f'Coefficients must be at least {d}-dimensional.')\n        if self.c.shape[d] != n:\n            raise ValueError(f'Knots, coefficients and degree in dimension {d} are inconsistent: got {self.c.shape[d]} coefficients for {len(td)} knots, need at least {n} for k={k}.')\n    dt = _get_dtype(self.c.dtype)\n    self.c = np.ascontiguousarray(self.c, dtype=dt)"
        ]
    },
    {
        "func_name": "__call__",
        "original": "def __call__(self, xi, *, nu=None, extrapolate=None):\n    \"\"\"Evaluate the tensor product b-spline at ``xi``.\n\n        Parameters\n        ----------\n        xi : array_like, shape(..., ndim)\n            The coordinates to evaluate the interpolator at.\n            This can be a list or tuple of ndim-dimensional points\n            or an array with the shape (num_points, ndim).\n        nu : array_like, optional, shape (ndim,)\n            Orders of derivatives to evaluate. Each must be non-negative. Defaults to the zeroth derivivative.\n        extrapolate : bool, optional\n            Whether to exrapolate based on first and last intervals in each\n            dimension, or return `nan`. Default is to ``self.extrapolate``.\n\n        Returns\n        -------\n        values : ndarray, shape ``xi.shape[:-1] + self.c.shape[ndim:]``\n            Interpolated values at ``xi``\n        \"\"\"\n    ndim = len(self.t)\n    if extrapolate is None:\n        extrapolate = self.extrapolate\n    extrapolate = bool(extrapolate)\n    if nu is None:\n        nu = np.zeros((ndim,), dtype=np.intc)\n    else:\n        nu = np.asarray(nu, dtype=np.intc)\n        if nu.ndim != 1 or nu.shape[0] != ndim:\n            raise ValueError('invalid number of derivative orders nu')\n    xi = np.asarray(xi, dtype=float)\n    xi_shape = xi.shape\n    xi = xi.reshape(-1, xi_shape[-1])\n    xi = np.ascontiguousarray(xi)\n    if xi_shape[-1] != ndim:\n        raise ValueError(f'Shapes: xi.shape={xi_shape} and ndim={ndim}')\n    _k = np.asarray(self.k)\n    len_t = [len(ti) for ti in self.t]\n    _t = np.empty((ndim, max(len_t)), dtype=float)\n    _t.fill(np.nan)\n    for d in range(ndim):\n        _t[d, :len(self.t[d])] = self.t[d]\n    shape = tuple((kd + 1 for kd in self.k))\n    indices = np.unravel_index(np.arange(prod(shape)), shape)\n    _indices_k1d = np.asarray(indices, dtype=np.intp).T\n    c1 = self.c.reshape(self.c.shape[:ndim] + (-1,))\n    c1r = c1.ravel()\n    _strides_c1 = np.asarray([s // c1.dtype.itemsize for s in c1.strides], dtype=np.intp)\n    num_c_tr = c1.shape[-1]\n    out = np.empty(xi.shape[:-1] + (num_c_tr,), dtype=c1.dtype)\n    _bspl.evaluate_ndbspline(xi, _t, _k, nu, extrapolate, c1r, num_c_tr, _strides_c1, _indices_k1d, out)\n    return out.reshape(xi_shape[:-1] + self.c.shape[ndim:])",
        "mutated": [
            "def __call__(self, xi, *, nu=None, extrapolate=None):\n    if False:\n        i = 10\n    'Evaluate the tensor product b-spline at ``xi``.\\n\\n        Parameters\\n        ----------\\n        xi : array_like, shape(..., ndim)\\n            The coordinates to evaluate the interpolator at.\\n            This can be a list or tuple of ndim-dimensional points\\n            or an array with the shape (num_points, ndim).\\n        nu : array_like, optional, shape (ndim,)\\n            Orders of derivatives to evaluate. Each must be non-negative. Defaults to the zeroth derivivative.\\n        extrapolate : bool, optional\\n            Whether to exrapolate based on first and last intervals in each\\n            dimension, or return `nan`. Default is to ``self.extrapolate``.\\n\\n        Returns\\n        -------\\n        values : ndarray, shape ``xi.shape[:-1] + self.c.shape[ndim:]``\\n            Interpolated values at ``xi``\\n        '\n    ndim = len(self.t)\n    if extrapolate is None:\n        extrapolate = self.extrapolate\n    extrapolate = bool(extrapolate)\n    if nu is None:\n        nu = np.zeros((ndim,), dtype=np.intc)\n    else:\n        nu = np.asarray(nu, dtype=np.intc)\n        if nu.ndim != 1 or nu.shape[0] != ndim:\n            raise ValueError('invalid number of derivative orders nu')\n    xi = np.asarray(xi, dtype=float)\n    xi_shape = xi.shape\n    xi = xi.reshape(-1, xi_shape[-1])\n    xi = np.ascontiguousarray(xi)\n    if xi_shape[-1] != ndim:\n        raise ValueError(f'Shapes: xi.shape={xi_shape} and ndim={ndim}')\n    _k = np.asarray(self.k)\n    len_t = [len(ti) for ti in self.t]\n    _t = np.empty((ndim, max(len_t)), dtype=float)\n    _t.fill(np.nan)\n    for d in range(ndim):\n        _t[d, :len(self.t[d])] = self.t[d]\n    shape = tuple((kd + 1 for kd in self.k))\n    indices = np.unravel_index(np.arange(prod(shape)), shape)\n    _indices_k1d = np.asarray(indices, dtype=np.intp).T\n    c1 = self.c.reshape(self.c.shape[:ndim] + (-1,))\n    c1r = c1.ravel()\n    _strides_c1 = np.asarray([s // c1.dtype.itemsize for s in c1.strides], dtype=np.intp)\n    num_c_tr = c1.shape[-1]\n    out = np.empty(xi.shape[:-1] + (num_c_tr,), dtype=c1.dtype)\n    _bspl.evaluate_ndbspline(xi, _t, _k, nu, extrapolate, c1r, num_c_tr, _strides_c1, _indices_k1d, out)\n    return out.reshape(xi_shape[:-1] + self.c.shape[ndim:])",
            "def __call__(self, xi, *, nu=None, extrapolate=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Evaluate the tensor product b-spline at ``xi``.\\n\\n        Parameters\\n        ----------\\n        xi : array_like, shape(..., ndim)\\n            The coordinates to evaluate the interpolator at.\\n            This can be a list or tuple of ndim-dimensional points\\n            or an array with the shape (num_points, ndim).\\n        nu : array_like, optional, shape (ndim,)\\n            Orders of derivatives to evaluate. Each must be non-negative. Defaults to the zeroth derivivative.\\n        extrapolate : bool, optional\\n            Whether to exrapolate based on first and last intervals in each\\n            dimension, or return `nan`. Default is to ``self.extrapolate``.\\n\\n        Returns\\n        -------\\n        values : ndarray, shape ``xi.shape[:-1] + self.c.shape[ndim:]``\\n            Interpolated values at ``xi``\\n        '\n    ndim = len(self.t)\n    if extrapolate is None:\n        extrapolate = self.extrapolate\n    extrapolate = bool(extrapolate)\n    if nu is None:\n        nu = np.zeros((ndim,), dtype=np.intc)\n    else:\n        nu = np.asarray(nu, dtype=np.intc)\n        if nu.ndim != 1 or nu.shape[0] != ndim:\n            raise ValueError('invalid number of derivative orders nu')\n    xi = np.asarray(xi, dtype=float)\n    xi_shape = xi.shape\n    xi = xi.reshape(-1, xi_shape[-1])\n    xi = np.ascontiguousarray(xi)\n    if xi_shape[-1] != ndim:\n        raise ValueError(f'Shapes: xi.shape={xi_shape} and ndim={ndim}')\n    _k = np.asarray(self.k)\n    len_t = [len(ti) for ti in self.t]\n    _t = np.empty((ndim, max(len_t)), dtype=float)\n    _t.fill(np.nan)\n    for d in range(ndim):\n        _t[d, :len(self.t[d])] = self.t[d]\n    shape = tuple((kd + 1 for kd in self.k))\n    indices = np.unravel_index(np.arange(prod(shape)), shape)\n    _indices_k1d = np.asarray(indices, dtype=np.intp).T\n    c1 = self.c.reshape(self.c.shape[:ndim] + (-1,))\n    c1r = c1.ravel()\n    _strides_c1 = np.asarray([s // c1.dtype.itemsize for s in c1.strides], dtype=np.intp)\n    num_c_tr = c1.shape[-1]\n    out = np.empty(xi.shape[:-1] + (num_c_tr,), dtype=c1.dtype)\n    _bspl.evaluate_ndbspline(xi, _t, _k, nu, extrapolate, c1r, num_c_tr, _strides_c1, _indices_k1d, out)\n    return out.reshape(xi_shape[:-1] + self.c.shape[ndim:])",
            "def __call__(self, xi, *, nu=None, extrapolate=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Evaluate the tensor product b-spline at ``xi``.\\n\\n        Parameters\\n        ----------\\n        xi : array_like, shape(..., ndim)\\n            The coordinates to evaluate the interpolator at.\\n            This can be a list or tuple of ndim-dimensional points\\n            or an array with the shape (num_points, ndim).\\n        nu : array_like, optional, shape (ndim,)\\n            Orders of derivatives to evaluate. Each must be non-negative. Defaults to the zeroth derivivative.\\n        extrapolate : bool, optional\\n            Whether to exrapolate based on first and last intervals in each\\n            dimension, or return `nan`. Default is to ``self.extrapolate``.\\n\\n        Returns\\n        -------\\n        values : ndarray, shape ``xi.shape[:-1] + self.c.shape[ndim:]``\\n            Interpolated values at ``xi``\\n        '\n    ndim = len(self.t)\n    if extrapolate is None:\n        extrapolate = self.extrapolate\n    extrapolate = bool(extrapolate)\n    if nu is None:\n        nu = np.zeros((ndim,), dtype=np.intc)\n    else:\n        nu = np.asarray(nu, dtype=np.intc)\n        if nu.ndim != 1 or nu.shape[0] != ndim:\n            raise ValueError('invalid number of derivative orders nu')\n    xi = np.asarray(xi, dtype=float)\n    xi_shape = xi.shape\n    xi = xi.reshape(-1, xi_shape[-1])\n    xi = np.ascontiguousarray(xi)\n    if xi_shape[-1] != ndim:\n        raise ValueError(f'Shapes: xi.shape={xi_shape} and ndim={ndim}')\n    _k = np.asarray(self.k)\n    len_t = [len(ti) for ti in self.t]\n    _t = np.empty((ndim, max(len_t)), dtype=float)\n    _t.fill(np.nan)\n    for d in range(ndim):\n        _t[d, :len(self.t[d])] = self.t[d]\n    shape = tuple((kd + 1 for kd in self.k))\n    indices = np.unravel_index(np.arange(prod(shape)), shape)\n    _indices_k1d = np.asarray(indices, dtype=np.intp).T\n    c1 = self.c.reshape(self.c.shape[:ndim] + (-1,))\n    c1r = c1.ravel()\n    _strides_c1 = np.asarray([s // c1.dtype.itemsize for s in c1.strides], dtype=np.intp)\n    num_c_tr = c1.shape[-1]\n    out = np.empty(xi.shape[:-1] + (num_c_tr,), dtype=c1.dtype)\n    _bspl.evaluate_ndbspline(xi, _t, _k, nu, extrapolate, c1r, num_c_tr, _strides_c1, _indices_k1d, out)\n    return out.reshape(xi_shape[:-1] + self.c.shape[ndim:])",
            "def __call__(self, xi, *, nu=None, extrapolate=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Evaluate the tensor product b-spline at ``xi``.\\n\\n        Parameters\\n        ----------\\n        xi : array_like, shape(..., ndim)\\n            The coordinates to evaluate the interpolator at.\\n            This can be a list or tuple of ndim-dimensional points\\n            or an array with the shape (num_points, ndim).\\n        nu : array_like, optional, shape (ndim,)\\n            Orders of derivatives to evaluate. Each must be non-negative. Defaults to the zeroth derivivative.\\n        extrapolate : bool, optional\\n            Whether to exrapolate based on first and last intervals in each\\n            dimension, or return `nan`. Default is to ``self.extrapolate``.\\n\\n        Returns\\n        -------\\n        values : ndarray, shape ``xi.shape[:-1] + self.c.shape[ndim:]``\\n            Interpolated values at ``xi``\\n        '\n    ndim = len(self.t)\n    if extrapolate is None:\n        extrapolate = self.extrapolate\n    extrapolate = bool(extrapolate)\n    if nu is None:\n        nu = np.zeros((ndim,), dtype=np.intc)\n    else:\n        nu = np.asarray(nu, dtype=np.intc)\n        if nu.ndim != 1 or nu.shape[0] != ndim:\n            raise ValueError('invalid number of derivative orders nu')\n    xi = np.asarray(xi, dtype=float)\n    xi_shape = xi.shape\n    xi = xi.reshape(-1, xi_shape[-1])\n    xi = np.ascontiguousarray(xi)\n    if xi_shape[-1] != ndim:\n        raise ValueError(f'Shapes: xi.shape={xi_shape} and ndim={ndim}')\n    _k = np.asarray(self.k)\n    len_t = [len(ti) for ti in self.t]\n    _t = np.empty((ndim, max(len_t)), dtype=float)\n    _t.fill(np.nan)\n    for d in range(ndim):\n        _t[d, :len(self.t[d])] = self.t[d]\n    shape = tuple((kd + 1 for kd in self.k))\n    indices = np.unravel_index(np.arange(prod(shape)), shape)\n    _indices_k1d = np.asarray(indices, dtype=np.intp).T\n    c1 = self.c.reshape(self.c.shape[:ndim] + (-1,))\n    c1r = c1.ravel()\n    _strides_c1 = np.asarray([s // c1.dtype.itemsize for s in c1.strides], dtype=np.intp)\n    num_c_tr = c1.shape[-1]\n    out = np.empty(xi.shape[:-1] + (num_c_tr,), dtype=c1.dtype)\n    _bspl.evaluate_ndbspline(xi, _t, _k, nu, extrapolate, c1r, num_c_tr, _strides_c1, _indices_k1d, out)\n    return out.reshape(xi_shape[:-1] + self.c.shape[ndim:])",
            "def __call__(self, xi, *, nu=None, extrapolate=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Evaluate the tensor product b-spline at ``xi``.\\n\\n        Parameters\\n        ----------\\n        xi : array_like, shape(..., ndim)\\n            The coordinates to evaluate the interpolator at.\\n            This can be a list or tuple of ndim-dimensional points\\n            or an array with the shape (num_points, ndim).\\n        nu : array_like, optional, shape (ndim,)\\n            Orders of derivatives to evaluate. Each must be non-negative. Defaults to the zeroth derivivative.\\n        extrapolate : bool, optional\\n            Whether to exrapolate based on first and last intervals in each\\n            dimension, or return `nan`. Default is to ``self.extrapolate``.\\n\\n        Returns\\n        -------\\n        values : ndarray, shape ``xi.shape[:-1] + self.c.shape[ndim:]``\\n            Interpolated values at ``xi``\\n        '\n    ndim = len(self.t)\n    if extrapolate is None:\n        extrapolate = self.extrapolate\n    extrapolate = bool(extrapolate)\n    if nu is None:\n        nu = np.zeros((ndim,), dtype=np.intc)\n    else:\n        nu = np.asarray(nu, dtype=np.intc)\n        if nu.ndim != 1 or nu.shape[0] != ndim:\n            raise ValueError('invalid number of derivative orders nu')\n    xi = np.asarray(xi, dtype=float)\n    xi_shape = xi.shape\n    xi = xi.reshape(-1, xi_shape[-1])\n    xi = np.ascontiguousarray(xi)\n    if xi_shape[-1] != ndim:\n        raise ValueError(f'Shapes: xi.shape={xi_shape} and ndim={ndim}')\n    _k = np.asarray(self.k)\n    len_t = [len(ti) for ti in self.t]\n    _t = np.empty((ndim, max(len_t)), dtype=float)\n    _t.fill(np.nan)\n    for d in range(ndim):\n        _t[d, :len(self.t[d])] = self.t[d]\n    shape = tuple((kd + 1 for kd in self.k))\n    indices = np.unravel_index(np.arange(prod(shape)), shape)\n    _indices_k1d = np.asarray(indices, dtype=np.intp).T\n    c1 = self.c.reshape(self.c.shape[:ndim] + (-1,))\n    c1r = c1.ravel()\n    _strides_c1 = np.asarray([s // c1.dtype.itemsize for s in c1.strides], dtype=np.intp)\n    num_c_tr = c1.shape[-1]\n    out = np.empty(xi.shape[:-1] + (num_c_tr,), dtype=c1.dtype)\n    _bspl.evaluate_ndbspline(xi, _t, _k, nu, extrapolate, c1r, num_c_tr, _strides_c1, _indices_k1d, out)\n    return out.reshape(xi_shape[:-1] + self.c.shape[ndim:])"
        ]
    }
]