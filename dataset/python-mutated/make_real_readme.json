[
    {
        "func_name": "get_line_number",
        "original": "def get_line_number(python_obj):\n    return inspect.getsourcelines(python_obj)[1]",
        "mutated": [
            "def get_line_number(python_obj):\n    if False:\n        i = 10\n    return inspect.getsourcelines(python_obj)[1]",
            "def get_line_number(python_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return inspect.getsourcelines(python_obj)[1]",
            "def get_line_number(python_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return inspect.getsourcelines(python_obj)[1]",
            "def get_line_number(python_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return inspect.getsourcelines(python_obj)[1]",
            "def get_line_number(python_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return inspect.getsourcelines(python_obj)[1]"
        ]
    },
    {
        "func_name": "get_return_part",
        "original": "def get_return_part(code: str, line_break=None):\n    \"\"\" Find \":return:\" part in given \"doc string\".\"\"\"\n    if not line_break:\n        line_break = ''\n    if ':return:' not in code:\n        return ('', '')\n    only_return = code[code.index(':return:') + len(':return:'):].strip().replace('\\n', line_break)\n    if ':rtype' in only_return:\n        only_return = only_return.split(':rtype')[0].strip()\n    return_TYPE = ''\n    if ':rtype' in code:\n        rcode = code.strip()\n        return_TYPE = rcode[rcode.index(':rtype:') + len(':rtype:'):].strip()\n    return (only_return, return_TYPE)",
        "mutated": [
            "def get_return_part(code: str, line_break=None):\n    if False:\n        i = 10\n    ' Find \":return:\" part in given \"doc string\".'\n    if not line_break:\n        line_break = ''\n    if ':return:' not in code:\n        return ('', '')\n    only_return = code[code.index(':return:') + len(':return:'):].strip().replace('\\n', line_break)\n    if ':rtype' in only_return:\n        only_return = only_return.split(':rtype')[0].strip()\n    return_TYPE = ''\n    if ':rtype' in code:\n        rcode = code.strip()\n        return_TYPE = rcode[rcode.index(':rtype:') + len(':rtype:'):].strip()\n    return (only_return, return_TYPE)",
            "def get_return_part(code: str, line_break=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Find \":return:\" part in given \"doc string\".'\n    if not line_break:\n        line_break = ''\n    if ':return:' not in code:\n        return ('', '')\n    only_return = code[code.index(':return:') + len(':return:'):].strip().replace('\\n', line_break)\n    if ':rtype' in only_return:\n        only_return = only_return.split(':rtype')[0].strip()\n    return_TYPE = ''\n    if ':rtype' in code:\n        rcode = code.strip()\n        return_TYPE = rcode[rcode.index(':rtype:') + len(':rtype:'):].strip()\n    return (only_return, return_TYPE)",
            "def get_return_part(code: str, line_break=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Find \":return:\" part in given \"doc string\".'\n    if not line_break:\n        line_break = ''\n    if ':return:' not in code:\n        return ('', '')\n    only_return = code[code.index(':return:') + len(':return:'):].strip().replace('\\n', line_break)\n    if ':rtype' in only_return:\n        only_return = only_return.split(':rtype')[0].strip()\n    return_TYPE = ''\n    if ':rtype' in code:\n        rcode = code.strip()\n        return_TYPE = rcode[rcode.index(':rtype:') + len(':rtype:'):].strip()\n    return (only_return, return_TYPE)",
            "def get_return_part(code: str, line_break=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Find \":return:\" part in given \"doc string\".'\n    if not line_break:\n        line_break = ''\n    if ':return:' not in code:\n        return ('', '')\n    only_return = code[code.index(':return:') + len(':return:'):].strip().replace('\\n', line_break)\n    if ':rtype' in only_return:\n        only_return = only_return.split(':rtype')[0].strip()\n    return_TYPE = ''\n    if ':rtype' in code:\n        rcode = code.strip()\n        return_TYPE = rcode[rcode.index(':rtype:') + len(':rtype:'):].strip()\n    return (only_return, return_TYPE)",
            "def get_return_part(code: str, line_break=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Find \":return:\" part in given \"doc string\".'\n    if not line_break:\n        line_break = ''\n    if ':return:' not in code:\n        return ('', '')\n    only_return = code[code.index(':return:') + len(':return:'):].strip().replace('\\n', line_break)\n    if ':rtype' in only_return:\n        only_return = only_return.split(':rtype')[0].strip()\n    return_TYPE = ''\n    if ':rtype' in code:\n        rcode = code.strip()\n        return_TYPE = rcode[rcode.index(':rtype:') + len(':rtype:'):].strip()\n    return (only_return, return_TYPE)"
        ]
    },
    {
        "func_name": "special_cases",
        "original": "def special_cases(function_name, function_obj, sig, doc_string, line_break=None):\n    (doca, params_names) = (doc_string.strip(), list(dict(sig).keys()))\n    only_self = 'self' in params_names and len(params_names) == 1\n    \"\\n    # TEMPLATE1\\n\\n        def Get(self):\\n           ''' '''\\n    # TEMPLATE2 -return -param\\n        def Get(self):\\n            '''\\n            blah blah blah\\n            '''\\n    # TEMPLATE3  +return -param\\n        def Get(self):\\n            ''' \\n            blah blah blah\\n            :return: blah-blah\\n            '''\\n    \"\n    if is_propery(function_obj):\n        if only_self and (not doca):\n            return special_case(ok=True, just_text=f'\\n\\n#### property: {function_name}\\n\\n', sig='', table='')\n        elif only_self and doca and (':param' not in doca) and (':return:' not in doca):\n            return special_case(ok=True, just_text=f'\\n\\n#### property: {function_name}\\n{get_doc_desc(doca, function_obj)}\\n\\n', sig='', table='')\n        elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n            (return_part, return_part_type) = get_return_part(doca, line_break=line_break)\n            desc = get_doc_desc(doca, function_obj)\n            a_table = TABLE_Only_table_RETURN_TEMPLATE.replace('$', return_part) + '\\n\\n'\n            if return_part_type:\n                a_table = a_table.replace('<type>', return_part_type)\n            return special_case(ok=True, just_text='', sig=f'\\n\\n#### property: {function_name}\\n{desc}\\n\\n', table=a_table)\n    \"\\n        # TEMPLATE1\\n\\n            def Get(self):\\n               ''' '''\\n        # TEMPLATE2 -return -param\\n            def Get(self):\\n                '''\\n                blah blah blah\\n                '''\\n        # TEMPLATE3  +return -param\\n            def Get(self):\\n                ''' \\n                blah blah blah\\n                :return: blah-blah\\n                '''\\n        # TEMPLATE4  -return +param\\n            def SetFocus(self, elem):\\n                ''' \\n                blah blah blah\\n                :param elem: qwerty\\n                '''\\n    \"\n    if only_self and (not doca):\n        return special_case(ok=True, just_text=f'\\n\\n```python\\n{function_name}()\\n```\\n\\n', sig='', table='')\n    elif only_self and doca and (':param' not in doca) and (':return:' not in doca):\n        return special_case(ok=True, just_text=f'\\n\\n{doca}\\n\\n```python\\n{function_name}()\\n```\\n\\n', sig='', table='')\n    elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n        (return_part, return_part_type) = get_return_part(doca, line_break=line_break)\n        desc = get_doc_desc(doca, function_obj)\n        a_table = TABLE_Only_table_RETURN_TEMPLATE.replace('$', return_part) + '\\n\\n'\n        if return_part_type:\n            a_table = a_table.replace('<type>', return_part_type)\n        return special_case(ok=True, just_text='', sig=f'\\n\\n{desc}\\n\\n`{function_name}()`\\n\\n', table=a_table)\n    elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n        return special_case(ok=False, just_text='', sig='', table='')\n    return special_case(ok=False, just_text='', sig='', table='')",
        "mutated": [
            "def special_cases(function_name, function_obj, sig, doc_string, line_break=None):\n    if False:\n        i = 10\n    (doca, params_names) = (doc_string.strip(), list(dict(sig).keys()))\n    only_self = 'self' in params_names and len(params_names) == 1\n    \"\\n    # TEMPLATE1\\n\\n        def Get(self):\\n           ''' '''\\n    # TEMPLATE2 -return -param\\n        def Get(self):\\n            '''\\n            blah blah blah\\n            '''\\n    # TEMPLATE3  +return -param\\n        def Get(self):\\n            ''' \\n            blah blah blah\\n            :return: blah-blah\\n            '''\\n    \"\n    if is_propery(function_obj):\n        if only_self and (not doca):\n            return special_case(ok=True, just_text=f'\\n\\n#### property: {function_name}\\n\\n', sig='', table='')\n        elif only_self and doca and (':param' not in doca) and (':return:' not in doca):\n            return special_case(ok=True, just_text=f'\\n\\n#### property: {function_name}\\n{get_doc_desc(doca, function_obj)}\\n\\n', sig='', table='')\n        elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n            (return_part, return_part_type) = get_return_part(doca, line_break=line_break)\n            desc = get_doc_desc(doca, function_obj)\n            a_table = TABLE_Only_table_RETURN_TEMPLATE.replace('$', return_part) + '\\n\\n'\n            if return_part_type:\n                a_table = a_table.replace('<type>', return_part_type)\n            return special_case(ok=True, just_text='', sig=f'\\n\\n#### property: {function_name}\\n{desc}\\n\\n', table=a_table)\n    \"\\n        # TEMPLATE1\\n\\n            def Get(self):\\n               ''' '''\\n        # TEMPLATE2 -return -param\\n            def Get(self):\\n                '''\\n                blah blah blah\\n                '''\\n        # TEMPLATE3  +return -param\\n            def Get(self):\\n                ''' \\n                blah blah blah\\n                :return: blah-blah\\n                '''\\n        # TEMPLATE4  -return +param\\n            def SetFocus(self, elem):\\n                ''' \\n                blah blah blah\\n                :param elem: qwerty\\n                '''\\n    \"\n    if only_self and (not doca):\n        return special_case(ok=True, just_text=f'\\n\\n```python\\n{function_name}()\\n```\\n\\n', sig='', table='')\n    elif only_self and doca and (':param' not in doca) and (':return:' not in doca):\n        return special_case(ok=True, just_text=f'\\n\\n{doca}\\n\\n```python\\n{function_name}()\\n```\\n\\n', sig='', table='')\n    elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n        (return_part, return_part_type) = get_return_part(doca, line_break=line_break)\n        desc = get_doc_desc(doca, function_obj)\n        a_table = TABLE_Only_table_RETURN_TEMPLATE.replace('$', return_part) + '\\n\\n'\n        if return_part_type:\n            a_table = a_table.replace('<type>', return_part_type)\n        return special_case(ok=True, just_text='', sig=f'\\n\\n{desc}\\n\\n`{function_name}()`\\n\\n', table=a_table)\n    elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n        return special_case(ok=False, just_text='', sig='', table='')\n    return special_case(ok=False, just_text='', sig='', table='')",
            "def special_cases(function_name, function_obj, sig, doc_string, line_break=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (doca, params_names) = (doc_string.strip(), list(dict(sig).keys()))\n    only_self = 'self' in params_names and len(params_names) == 1\n    \"\\n    # TEMPLATE1\\n\\n        def Get(self):\\n           ''' '''\\n    # TEMPLATE2 -return -param\\n        def Get(self):\\n            '''\\n            blah blah blah\\n            '''\\n    # TEMPLATE3  +return -param\\n        def Get(self):\\n            ''' \\n            blah blah blah\\n            :return: blah-blah\\n            '''\\n    \"\n    if is_propery(function_obj):\n        if only_self and (not doca):\n            return special_case(ok=True, just_text=f'\\n\\n#### property: {function_name}\\n\\n', sig='', table='')\n        elif only_self and doca and (':param' not in doca) and (':return:' not in doca):\n            return special_case(ok=True, just_text=f'\\n\\n#### property: {function_name}\\n{get_doc_desc(doca, function_obj)}\\n\\n', sig='', table='')\n        elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n            (return_part, return_part_type) = get_return_part(doca, line_break=line_break)\n            desc = get_doc_desc(doca, function_obj)\n            a_table = TABLE_Only_table_RETURN_TEMPLATE.replace('$', return_part) + '\\n\\n'\n            if return_part_type:\n                a_table = a_table.replace('<type>', return_part_type)\n            return special_case(ok=True, just_text='', sig=f'\\n\\n#### property: {function_name}\\n{desc}\\n\\n', table=a_table)\n    \"\\n        # TEMPLATE1\\n\\n            def Get(self):\\n               ''' '''\\n        # TEMPLATE2 -return -param\\n            def Get(self):\\n                '''\\n                blah blah blah\\n                '''\\n        # TEMPLATE3  +return -param\\n            def Get(self):\\n                ''' \\n                blah blah blah\\n                :return: blah-blah\\n                '''\\n        # TEMPLATE4  -return +param\\n            def SetFocus(self, elem):\\n                ''' \\n                blah blah blah\\n                :param elem: qwerty\\n                '''\\n    \"\n    if only_self and (not doca):\n        return special_case(ok=True, just_text=f'\\n\\n```python\\n{function_name}()\\n```\\n\\n', sig='', table='')\n    elif only_self and doca and (':param' not in doca) and (':return:' not in doca):\n        return special_case(ok=True, just_text=f'\\n\\n{doca}\\n\\n```python\\n{function_name}()\\n```\\n\\n', sig='', table='')\n    elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n        (return_part, return_part_type) = get_return_part(doca, line_break=line_break)\n        desc = get_doc_desc(doca, function_obj)\n        a_table = TABLE_Only_table_RETURN_TEMPLATE.replace('$', return_part) + '\\n\\n'\n        if return_part_type:\n            a_table = a_table.replace('<type>', return_part_type)\n        return special_case(ok=True, just_text='', sig=f'\\n\\n{desc}\\n\\n`{function_name}()`\\n\\n', table=a_table)\n    elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n        return special_case(ok=False, just_text='', sig='', table='')\n    return special_case(ok=False, just_text='', sig='', table='')",
            "def special_cases(function_name, function_obj, sig, doc_string, line_break=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (doca, params_names) = (doc_string.strip(), list(dict(sig).keys()))\n    only_self = 'self' in params_names and len(params_names) == 1\n    \"\\n    # TEMPLATE1\\n\\n        def Get(self):\\n           ''' '''\\n    # TEMPLATE2 -return -param\\n        def Get(self):\\n            '''\\n            blah blah blah\\n            '''\\n    # TEMPLATE3  +return -param\\n        def Get(self):\\n            ''' \\n            blah blah blah\\n            :return: blah-blah\\n            '''\\n    \"\n    if is_propery(function_obj):\n        if only_self and (not doca):\n            return special_case(ok=True, just_text=f'\\n\\n#### property: {function_name}\\n\\n', sig='', table='')\n        elif only_self and doca and (':param' not in doca) and (':return:' not in doca):\n            return special_case(ok=True, just_text=f'\\n\\n#### property: {function_name}\\n{get_doc_desc(doca, function_obj)}\\n\\n', sig='', table='')\n        elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n            (return_part, return_part_type) = get_return_part(doca, line_break=line_break)\n            desc = get_doc_desc(doca, function_obj)\n            a_table = TABLE_Only_table_RETURN_TEMPLATE.replace('$', return_part) + '\\n\\n'\n            if return_part_type:\n                a_table = a_table.replace('<type>', return_part_type)\n            return special_case(ok=True, just_text='', sig=f'\\n\\n#### property: {function_name}\\n{desc}\\n\\n', table=a_table)\n    \"\\n        # TEMPLATE1\\n\\n            def Get(self):\\n               ''' '''\\n        # TEMPLATE2 -return -param\\n            def Get(self):\\n                '''\\n                blah blah blah\\n                '''\\n        # TEMPLATE3  +return -param\\n            def Get(self):\\n                ''' \\n                blah blah blah\\n                :return: blah-blah\\n                '''\\n        # TEMPLATE4  -return +param\\n            def SetFocus(self, elem):\\n                ''' \\n                blah blah blah\\n                :param elem: qwerty\\n                '''\\n    \"\n    if only_self and (not doca):\n        return special_case(ok=True, just_text=f'\\n\\n```python\\n{function_name}()\\n```\\n\\n', sig='', table='')\n    elif only_self and doca and (':param' not in doca) and (':return:' not in doca):\n        return special_case(ok=True, just_text=f'\\n\\n{doca}\\n\\n```python\\n{function_name}()\\n```\\n\\n', sig='', table='')\n    elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n        (return_part, return_part_type) = get_return_part(doca, line_break=line_break)\n        desc = get_doc_desc(doca, function_obj)\n        a_table = TABLE_Only_table_RETURN_TEMPLATE.replace('$', return_part) + '\\n\\n'\n        if return_part_type:\n            a_table = a_table.replace('<type>', return_part_type)\n        return special_case(ok=True, just_text='', sig=f'\\n\\n{desc}\\n\\n`{function_name}()`\\n\\n', table=a_table)\n    elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n        return special_case(ok=False, just_text='', sig='', table='')\n    return special_case(ok=False, just_text='', sig='', table='')",
            "def special_cases(function_name, function_obj, sig, doc_string, line_break=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (doca, params_names) = (doc_string.strip(), list(dict(sig).keys()))\n    only_self = 'self' in params_names and len(params_names) == 1\n    \"\\n    # TEMPLATE1\\n\\n        def Get(self):\\n           ''' '''\\n    # TEMPLATE2 -return -param\\n        def Get(self):\\n            '''\\n            blah blah blah\\n            '''\\n    # TEMPLATE3  +return -param\\n        def Get(self):\\n            ''' \\n            blah blah blah\\n            :return: blah-blah\\n            '''\\n    \"\n    if is_propery(function_obj):\n        if only_self and (not doca):\n            return special_case(ok=True, just_text=f'\\n\\n#### property: {function_name}\\n\\n', sig='', table='')\n        elif only_self and doca and (':param' not in doca) and (':return:' not in doca):\n            return special_case(ok=True, just_text=f'\\n\\n#### property: {function_name}\\n{get_doc_desc(doca, function_obj)}\\n\\n', sig='', table='')\n        elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n            (return_part, return_part_type) = get_return_part(doca, line_break=line_break)\n            desc = get_doc_desc(doca, function_obj)\n            a_table = TABLE_Only_table_RETURN_TEMPLATE.replace('$', return_part) + '\\n\\n'\n            if return_part_type:\n                a_table = a_table.replace('<type>', return_part_type)\n            return special_case(ok=True, just_text='', sig=f'\\n\\n#### property: {function_name}\\n{desc}\\n\\n', table=a_table)\n    \"\\n        # TEMPLATE1\\n\\n            def Get(self):\\n               ''' '''\\n        # TEMPLATE2 -return -param\\n            def Get(self):\\n                '''\\n                blah blah blah\\n                '''\\n        # TEMPLATE3  +return -param\\n            def Get(self):\\n                ''' \\n                blah blah blah\\n                :return: blah-blah\\n                '''\\n        # TEMPLATE4  -return +param\\n            def SetFocus(self, elem):\\n                ''' \\n                blah blah blah\\n                :param elem: qwerty\\n                '''\\n    \"\n    if only_self and (not doca):\n        return special_case(ok=True, just_text=f'\\n\\n```python\\n{function_name}()\\n```\\n\\n', sig='', table='')\n    elif only_self and doca and (':param' not in doca) and (':return:' not in doca):\n        return special_case(ok=True, just_text=f'\\n\\n{doca}\\n\\n```python\\n{function_name}()\\n```\\n\\n', sig='', table='')\n    elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n        (return_part, return_part_type) = get_return_part(doca, line_break=line_break)\n        desc = get_doc_desc(doca, function_obj)\n        a_table = TABLE_Only_table_RETURN_TEMPLATE.replace('$', return_part) + '\\n\\n'\n        if return_part_type:\n            a_table = a_table.replace('<type>', return_part_type)\n        return special_case(ok=True, just_text='', sig=f'\\n\\n{desc}\\n\\n`{function_name}()`\\n\\n', table=a_table)\n    elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n        return special_case(ok=False, just_text='', sig='', table='')\n    return special_case(ok=False, just_text='', sig='', table='')",
            "def special_cases(function_name, function_obj, sig, doc_string, line_break=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (doca, params_names) = (doc_string.strip(), list(dict(sig).keys()))\n    only_self = 'self' in params_names and len(params_names) == 1\n    \"\\n    # TEMPLATE1\\n\\n        def Get(self):\\n           ''' '''\\n    # TEMPLATE2 -return -param\\n        def Get(self):\\n            '''\\n            blah blah blah\\n            '''\\n    # TEMPLATE3  +return -param\\n        def Get(self):\\n            ''' \\n            blah blah blah\\n            :return: blah-blah\\n            '''\\n    \"\n    if is_propery(function_obj):\n        if only_self and (not doca):\n            return special_case(ok=True, just_text=f'\\n\\n#### property: {function_name}\\n\\n', sig='', table='')\n        elif only_self and doca and (':param' not in doca) and (':return:' not in doca):\n            return special_case(ok=True, just_text=f'\\n\\n#### property: {function_name}\\n{get_doc_desc(doca, function_obj)}\\n\\n', sig='', table='')\n        elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n            (return_part, return_part_type) = get_return_part(doca, line_break=line_break)\n            desc = get_doc_desc(doca, function_obj)\n            a_table = TABLE_Only_table_RETURN_TEMPLATE.replace('$', return_part) + '\\n\\n'\n            if return_part_type:\n                a_table = a_table.replace('<type>', return_part_type)\n            return special_case(ok=True, just_text='', sig=f'\\n\\n#### property: {function_name}\\n{desc}\\n\\n', table=a_table)\n    \"\\n        # TEMPLATE1\\n\\n            def Get(self):\\n               ''' '''\\n        # TEMPLATE2 -return -param\\n            def Get(self):\\n                '''\\n                blah blah blah\\n                '''\\n        # TEMPLATE3  +return -param\\n            def Get(self):\\n                ''' \\n                blah blah blah\\n                :return: blah-blah\\n                '''\\n        # TEMPLATE4  -return +param\\n            def SetFocus(self, elem):\\n                ''' \\n                blah blah blah\\n                :param elem: qwerty\\n                '''\\n    \"\n    if only_self and (not doca):\n        return special_case(ok=True, just_text=f'\\n\\n```python\\n{function_name}()\\n```\\n\\n', sig='', table='')\n    elif only_self and doca and (':param' not in doca) and (':return:' not in doca):\n        return special_case(ok=True, just_text=f'\\n\\n{doca}\\n\\n```python\\n{function_name}()\\n```\\n\\n', sig='', table='')\n    elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n        (return_part, return_part_type) = get_return_part(doca, line_break=line_break)\n        desc = get_doc_desc(doca, function_obj)\n        a_table = TABLE_Only_table_RETURN_TEMPLATE.replace('$', return_part) + '\\n\\n'\n        if return_part_type:\n            a_table = a_table.replace('<type>', return_part_type)\n        return special_case(ok=True, just_text='', sig=f'\\n\\n{desc}\\n\\n`{function_name}()`\\n\\n', table=a_table)\n    elif only_self and doca and (':param' not in doca) and (':return:' in doca):\n        return special_case(ok=False, just_text='', sig='', table='')\n    return special_case(ok=False, just_text='', sig='', table='')"
        ]
    },
    {
        "func_name": "get_doc_desc",
        "original": "def get_doc_desc(doc, original_obj):\n    return_in = ':return' in doc\n    param_in = ':param' in doc\n    if return_in and param_in and (doc.index(':return') < doc.index(':param')):\n        logging.error(f'BS. You need to FIX IT. PROBLEM \":return:\" BEFORE \":param:\" in \"{original_obj.__name__}\"')\n    if ':param' in doc:\n        doc = doc[:doc.index(':param')]\n    if ':return' in doc:\n        doc = doc[:doc.index(':return:')]\n    if ':param' in doc:\n        doc = doc[:doc.index(':param')]\n    if ':return' in doc:\n        doc = doc[:doc.index(':return:')]\n    desc = doc.strip().replace('    ', '')\n    return f'\\n{desc}' if desc else ''",
        "mutated": [
            "def get_doc_desc(doc, original_obj):\n    if False:\n        i = 10\n    return_in = ':return' in doc\n    param_in = ':param' in doc\n    if return_in and param_in and (doc.index(':return') < doc.index(':param')):\n        logging.error(f'BS. You need to FIX IT. PROBLEM \":return:\" BEFORE \":param:\" in \"{original_obj.__name__}\"')\n    if ':param' in doc:\n        doc = doc[:doc.index(':param')]\n    if ':return' in doc:\n        doc = doc[:doc.index(':return:')]\n    if ':param' in doc:\n        doc = doc[:doc.index(':param')]\n    if ':return' in doc:\n        doc = doc[:doc.index(':return:')]\n    desc = doc.strip().replace('    ', '')\n    return f'\\n{desc}' if desc else ''",
            "def get_doc_desc(doc, original_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return_in = ':return' in doc\n    param_in = ':param' in doc\n    if return_in and param_in and (doc.index(':return') < doc.index(':param')):\n        logging.error(f'BS. You need to FIX IT. PROBLEM \":return:\" BEFORE \":param:\" in \"{original_obj.__name__}\"')\n    if ':param' in doc:\n        doc = doc[:doc.index(':param')]\n    if ':return' in doc:\n        doc = doc[:doc.index(':return:')]\n    if ':param' in doc:\n        doc = doc[:doc.index(':param')]\n    if ':return' in doc:\n        doc = doc[:doc.index(':return:')]\n    desc = doc.strip().replace('    ', '')\n    return f'\\n{desc}' if desc else ''",
            "def get_doc_desc(doc, original_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return_in = ':return' in doc\n    param_in = ':param' in doc\n    if return_in and param_in and (doc.index(':return') < doc.index(':param')):\n        logging.error(f'BS. You need to FIX IT. PROBLEM \":return:\" BEFORE \":param:\" in \"{original_obj.__name__}\"')\n    if ':param' in doc:\n        doc = doc[:doc.index(':param')]\n    if ':return' in doc:\n        doc = doc[:doc.index(':return:')]\n    if ':param' in doc:\n        doc = doc[:doc.index(':param')]\n    if ':return' in doc:\n        doc = doc[:doc.index(':return:')]\n    desc = doc.strip().replace('    ', '')\n    return f'\\n{desc}' if desc else ''",
            "def get_doc_desc(doc, original_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return_in = ':return' in doc\n    param_in = ':param' in doc\n    if return_in and param_in and (doc.index(':return') < doc.index(':param')):\n        logging.error(f'BS. You need to FIX IT. PROBLEM \":return:\" BEFORE \":param:\" in \"{original_obj.__name__}\"')\n    if ':param' in doc:\n        doc = doc[:doc.index(':param')]\n    if ':return' in doc:\n        doc = doc[:doc.index(':return:')]\n    if ':param' in doc:\n        doc = doc[:doc.index(':param')]\n    if ':return' in doc:\n        doc = doc[:doc.index(':return:')]\n    desc = doc.strip().replace('    ', '')\n    return f'\\n{desc}' if desc else ''",
            "def get_doc_desc(doc, original_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return_in = ':return' in doc\n    param_in = ':param' in doc\n    if return_in and param_in and (doc.index(':return') < doc.index(':param')):\n        logging.error(f'BS. You need to FIX IT. PROBLEM \":return:\" BEFORE \":param:\" in \"{original_obj.__name__}\"')\n    if ':param' in doc:\n        doc = doc[:doc.index(':param')]\n    if ':return' in doc:\n        doc = doc[:doc.index(':return:')]\n    if ':param' in doc:\n        doc = doc[:doc.index(':param')]\n    if ':return' in doc:\n        doc = doc[:doc.index(':return:')]\n    desc = doc.strip().replace('    ', '')\n    return f'\\n{desc}' if desc else ''"
        ]
    },
    {
        "func_name": "is_propery",
        "original": "def is_propery(func):\n    return isdatadescriptor(func) and (not isfunction(func))",
        "mutated": [
            "def is_propery(func):\n    if False:\n        i = 10\n    return isdatadescriptor(func) and (not isfunction(func))",
            "def is_propery(func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return isdatadescriptor(func) and (not isfunction(func))",
            "def is_propery(func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return isdatadescriptor(func) and (not isfunction(func))",
            "def is_propery(func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return isdatadescriptor(func) and (not isfunction(func))",
            "def is_propery(func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return isdatadescriptor(func) and (not isfunction(func))"
        ]
    },
    {
        "func_name": "replace_re",
        "original": "def replace_re(i, a=' ', z=' '):\n    return re.sub(a, z, i, flags=re.MULTILINE).strip()",
        "mutated": [
            "def replace_re(i, a=' ', z=' '):\n    if False:\n        i = 10\n    return re.sub(a, z, i, flags=re.MULTILINE).strip()",
            "def replace_re(i, a=' ', z=' '):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return re.sub(a, z, i, flags=re.MULTILINE).strip()",
            "def replace_re(i, a=' ', z=' '):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return re.sub(a, z, i, flags=re.MULTILINE).strip()",
            "def replace_re(i, a=' ', z=' '):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return re.sub(a, z, i, flags=re.MULTILINE).strip()",
            "def replace_re(i, a=' ', z=' '):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return re.sub(a, z, i, flags=re.MULTILINE).strip()"
        ]
    },
    {
        "func_name": "process_type",
        "original": "def process_type(txt):\n    \"\"\"\n            striping brackets () from txt:\n            Example:\n            (str)                       -> str\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\n            \"\"\"\n    final_txt = ''\n    if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n        final_txt = txt.rstrip(')').lstrip('(')\n    else:\n        final_txt = txt\n    if ') or (' in final_txt:\n        final_txt = final_txt.replace(') or (', ' OR ')\n    if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n        final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n    return final_txt",
        "mutated": [
            "def process_type(txt):\n    if False:\n        i = 10\n    '\\n            striping brackets () from txt:\\n            Example:\\n            (str)                       -> str\\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\\n            '\n    final_txt = ''\n    if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n        final_txt = txt.rstrip(')').lstrip('(')\n    else:\n        final_txt = txt\n    if ') or (' in final_txt:\n        final_txt = final_txt.replace(') or (', ' OR ')\n    if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n        final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n    return final_txt",
            "def process_type(txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n            striping brackets () from txt:\\n            Example:\\n            (str)                       -> str\\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\\n            '\n    final_txt = ''\n    if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n        final_txt = txt.rstrip(')').lstrip('(')\n    else:\n        final_txt = txt\n    if ') or (' in final_txt:\n        final_txt = final_txt.replace(') or (', ' OR ')\n    if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n        final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n    return final_txt",
            "def process_type(txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n            striping brackets () from txt:\\n            Example:\\n            (str)                       -> str\\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\\n            '\n    final_txt = ''\n    if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n        final_txt = txt.rstrip(')').lstrip('(')\n    else:\n        final_txt = txt\n    if ') or (' in final_txt:\n        final_txt = final_txt.replace(') or (', ' OR ')\n    if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n        final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n    return final_txt",
            "def process_type(txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n            striping brackets () from txt:\\n            Example:\\n            (str)                       -> str\\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\\n            '\n    final_txt = ''\n    if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n        final_txt = txt.rstrip(')').lstrip('(')\n    else:\n        final_txt = txt\n    if ') or (' in final_txt:\n        final_txt = final_txt.replace(') or (', ' OR ')\n    if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n        final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n    return final_txt",
            "def process_type(txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n            striping brackets () from txt:\\n            Example:\\n            (str)                       -> str\\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\\n            '\n    final_txt = ''\n    if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n        final_txt = txt.rstrip(')').lstrip('(')\n    else:\n        final_txt = txt\n    if ') or (' in final_txt:\n        final_txt = final_txt.replace(') or (', ' OR ')\n    if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n        final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n    return final_txt"
        ]
    },
    {
        "func_name": "make_md_table_from_docstring",
        "original": "def make_md_table_from_docstring(docstring, a_original_obj):\n    row_n_type_regex = re.compile(':param ([\\\\s\\\\S]*?):([\\\\s\\\\S]*?):type [\\\\s\\\\S]*?:([\\\\d\\\\D]*?)\\\\n', flags=re.M | re.DOTALL)\n    'replace WITH regex'\n\n    def replace_re(i, a=' ', z=' '):\n        return re.sub(a, z, i, flags=re.MULTILINE).strip()\n\n    def process_type(txt):\n        \"\"\"\n            striping brackets () from txt:\n            Example:\n            (str)                       -> str\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\n            \"\"\"\n        final_txt = ''\n        if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n            final_txt = txt.rstrip(')').lstrip('(')\n        else:\n            final_txt = txt\n        if ') or (' in final_txt:\n            final_txt = final_txt.replace(') or (', ' OR ')\n        if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n            final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n        return final_txt\n    trips = [triplet(i.group(1), replace_re(i.group(2), '\\\\s{2,}', ' '), process_type(i.group(3).strip())) for (index, i) in enumerate(re.finditer(row_n_type_regex, docstring + ' \\n'))]\n    if not trips and ':return:' not in docstring:\n        raise Exception('no _TRIPs found!')\n    (max_type_width, max_name_width) = (40, 40)\n    try:\n        if trips:\n            (max_type_width, max_name_width) = (max([len(i.atype) for i in trips]), max([len(i.name) for i in trips]))\n    except Exception as e:\n        logger.debug(f'just ALERT ------ bug with max_type_width, max_name_width variables: {a_original_obj.__name__}')\n    row_template = f'| {{: ^{max_type_width}}} | {{: ^{max_name_width}}} | {{}} |'\n    rows = []\n    for some_triplet in trips:\n        if '|' in some_triplet.atype:\n            good_atype = some_triplet.atype.replace('|', 'or')\n        else:\n            good_atype = some_triplet.atype\n        good_atype = good_atype.replace(' OR ', ' or ').replace('\\\\or', 'or')\n        rows.append(row_template.format(good_atype, some_triplet.name, some_triplet.value))\n    row_n_type_regex = re.compile(':param ([\\\\d\\\\w\\\\*\\\\s]+):([\\\\d\\\\D]*?):type [\\\\w\\\\d]+:([\\\\d\\\\D].*?)\\\\n', flags=re.M | re.DOTALL)\n    try:\n        regex_pattern = re.compile(':return:\\\\s*(.*?)\\\\n\\\\s*:rtype:\\\\s*(.*?)\\\\n', flags=re.M | re.DOTALL)\n        a_doc = docstring + ' \\n'\n        aa = list(re.finditer(regex_pattern, a_doc))[0]\n        (text, atype) = (aa.group(1).strip(), aa.group(2).strip())\n        if text.strip():\n            if '|' in atype:\n                atype_no_pipes = atype.replace('|', 'or')\n                rows.append(f'| {atype_no_pipes} | **RETURN** | {text}')\n            else:\n                rows.append(f'| {atype} | **RETURN** | {text}')\n    except Exception as e:\n        pass\n    header = '\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n'\n    md_table = header + '\\n'.join(rows)\n    return md_table",
        "mutated": [
            "def make_md_table_from_docstring(docstring, a_original_obj):\n    if False:\n        i = 10\n    row_n_type_regex = re.compile(':param ([\\\\s\\\\S]*?):([\\\\s\\\\S]*?):type [\\\\s\\\\S]*?:([\\\\d\\\\D]*?)\\\\n', flags=re.M | re.DOTALL)\n    'replace WITH regex'\n\n    def replace_re(i, a=' ', z=' '):\n        return re.sub(a, z, i, flags=re.MULTILINE).strip()\n\n    def process_type(txt):\n        \"\"\"\n            striping brackets () from txt:\n            Example:\n            (str)                       -> str\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\n            \"\"\"\n        final_txt = ''\n        if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n            final_txt = txt.rstrip(')').lstrip('(')\n        else:\n            final_txt = txt\n        if ') or (' in final_txt:\n            final_txt = final_txt.replace(') or (', ' OR ')\n        if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n            final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n        return final_txt\n    trips = [triplet(i.group(1), replace_re(i.group(2), '\\\\s{2,}', ' '), process_type(i.group(3).strip())) for (index, i) in enumerate(re.finditer(row_n_type_regex, docstring + ' \\n'))]\n    if not trips and ':return:' not in docstring:\n        raise Exception('no _TRIPs found!')\n    (max_type_width, max_name_width) = (40, 40)\n    try:\n        if trips:\n            (max_type_width, max_name_width) = (max([len(i.atype) for i in trips]), max([len(i.name) for i in trips]))\n    except Exception as e:\n        logger.debug(f'just ALERT ------ bug with max_type_width, max_name_width variables: {a_original_obj.__name__}')\n    row_template = f'| {{: ^{max_type_width}}} | {{: ^{max_name_width}}} | {{}} |'\n    rows = []\n    for some_triplet in trips:\n        if '|' in some_triplet.atype:\n            good_atype = some_triplet.atype.replace('|', 'or')\n        else:\n            good_atype = some_triplet.atype\n        good_atype = good_atype.replace(' OR ', ' or ').replace('\\\\or', 'or')\n        rows.append(row_template.format(good_atype, some_triplet.name, some_triplet.value))\n    row_n_type_regex = re.compile(':param ([\\\\d\\\\w\\\\*\\\\s]+):([\\\\d\\\\D]*?):type [\\\\w\\\\d]+:([\\\\d\\\\D].*?)\\\\n', flags=re.M | re.DOTALL)\n    try:\n        regex_pattern = re.compile(':return:\\\\s*(.*?)\\\\n\\\\s*:rtype:\\\\s*(.*?)\\\\n', flags=re.M | re.DOTALL)\n        a_doc = docstring + ' \\n'\n        aa = list(re.finditer(regex_pattern, a_doc))[0]\n        (text, atype) = (aa.group(1).strip(), aa.group(2).strip())\n        if text.strip():\n            if '|' in atype:\n                atype_no_pipes = atype.replace('|', 'or')\n                rows.append(f'| {atype_no_pipes} | **RETURN** | {text}')\n            else:\n                rows.append(f'| {atype} | **RETURN** | {text}')\n    except Exception as e:\n        pass\n    header = '\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n'\n    md_table = header + '\\n'.join(rows)\n    return md_table",
            "def make_md_table_from_docstring(docstring, a_original_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    row_n_type_regex = re.compile(':param ([\\\\s\\\\S]*?):([\\\\s\\\\S]*?):type [\\\\s\\\\S]*?:([\\\\d\\\\D]*?)\\\\n', flags=re.M | re.DOTALL)\n    'replace WITH regex'\n\n    def replace_re(i, a=' ', z=' '):\n        return re.sub(a, z, i, flags=re.MULTILINE).strip()\n\n    def process_type(txt):\n        \"\"\"\n            striping brackets () from txt:\n            Example:\n            (str)                       -> str\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\n            \"\"\"\n        final_txt = ''\n        if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n            final_txt = txt.rstrip(')').lstrip('(')\n        else:\n            final_txt = txt\n        if ') or (' in final_txt:\n            final_txt = final_txt.replace(') or (', ' OR ')\n        if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n            final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n        return final_txt\n    trips = [triplet(i.group(1), replace_re(i.group(2), '\\\\s{2,}', ' '), process_type(i.group(3).strip())) for (index, i) in enumerate(re.finditer(row_n_type_regex, docstring + ' \\n'))]\n    if not trips and ':return:' not in docstring:\n        raise Exception('no _TRIPs found!')\n    (max_type_width, max_name_width) = (40, 40)\n    try:\n        if trips:\n            (max_type_width, max_name_width) = (max([len(i.atype) for i in trips]), max([len(i.name) for i in trips]))\n    except Exception as e:\n        logger.debug(f'just ALERT ------ bug with max_type_width, max_name_width variables: {a_original_obj.__name__}')\n    row_template = f'| {{: ^{max_type_width}}} | {{: ^{max_name_width}}} | {{}} |'\n    rows = []\n    for some_triplet in trips:\n        if '|' in some_triplet.atype:\n            good_atype = some_triplet.atype.replace('|', 'or')\n        else:\n            good_atype = some_triplet.atype\n        good_atype = good_atype.replace(' OR ', ' or ').replace('\\\\or', 'or')\n        rows.append(row_template.format(good_atype, some_triplet.name, some_triplet.value))\n    row_n_type_regex = re.compile(':param ([\\\\d\\\\w\\\\*\\\\s]+):([\\\\d\\\\D]*?):type [\\\\w\\\\d]+:([\\\\d\\\\D].*?)\\\\n', flags=re.M | re.DOTALL)\n    try:\n        regex_pattern = re.compile(':return:\\\\s*(.*?)\\\\n\\\\s*:rtype:\\\\s*(.*?)\\\\n', flags=re.M | re.DOTALL)\n        a_doc = docstring + ' \\n'\n        aa = list(re.finditer(regex_pattern, a_doc))[0]\n        (text, atype) = (aa.group(1).strip(), aa.group(2).strip())\n        if text.strip():\n            if '|' in atype:\n                atype_no_pipes = atype.replace('|', 'or')\n                rows.append(f'| {atype_no_pipes} | **RETURN** | {text}')\n            else:\n                rows.append(f'| {atype} | **RETURN** | {text}')\n    except Exception as e:\n        pass\n    header = '\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n'\n    md_table = header + '\\n'.join(rows)\n    return md_table",
            "def make_md_table_from_docstring(docstring, a_original_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    row_n_type_regex = re.compile(':param ([\\\\s\\\\S]*?):([\\\\s\\\\S]*?):type [\\\\s\\\\S]*?:([\\\\d\\\\D]*?)\\\\n', flags=re.M | re.DOTALL)\n    'replace WITH regex'\n\n    def replace_re(i, a=' ', z=' '):\n        return re.sub(a, z, i, flags=re.MULTILINE).strip()\n\n    def process_type(txt):\n        \"\"\"\n            striping brackets () from txt:\n            Example:\n            (str)                       -> str\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\n            \"\"\"\n        final_txt = ''\n        if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n            final_txt = txt.rstrip(')').lstrip('(')\n        else:\n            final_txt = txt\n        if ') or (' in final_txt:\n            final_txt = final_txt.replace(') or (', ' OR ')\n        if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n            final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n        return final_txt\n    trips = [triplet(i.group(1), replace_re(i.group(2), '\\\\s{2,}', ' '), process_type(i.group(3).strip())) for (index, i) in enumerate(re.finditer(row_n_type_regex, docstring + ' \\n'))]\n    if not trips and ':return:' not in docstring:\n        raise Exception('no _TRIPs found!')\n    (max_type_width, max_name_width) = (40, 40)\n    try:\n        if trips:\n            (max_type_width, max_name_width) = (max([len(i.atype) for i in trips]), max([len(i.name) for i in trips]))\n    except Exception as e:\n        logger.debug(f'just ALERT ------ bug with max_type_width, max_name_width variables: {a_original_obj.__name__}')\n    row_template = f'| {{: ^{max_type_width}}} | {{: ^{max_name_width}}} | {{}} |'\n    rows = []\n    for some_triplet in trips:\n        if '|' in some_triplet.atype:\n            good_atype = some_triplet.atype.replace('|', 'or')\n        else:\n            good_atype = some_triplet.atype\n        good_atype = good_atype.replace(' OR ', ' or ').replace('\\\\or', 'or')\n        rows.append(row_template.format(good_atype, some_triplet.name, some_triplet.value))\n    row_n_type_regex = re.compile(':param ([\\\\d\\\\w\\\\*\\\\s]+):([\\\\d\\\\D]*?):type [\\\\w\\\\d]+:([\\\\d\\\\D].*?)\\\\n', flags=re.M | re.DOTALL)\n    try:\n        regex_pattern = re.compile(':return:\\\\s*(.*?)\\\\n\\\\s*:rtype:\\\\s*(.*?)\\\\n', flags=re.M | re.DOTALL)\n        a_doc = docstring + ' \\n'\n        aa = list(re.finditer(regex_pattern, a_doc))[0]\n        (text, atype) = (aa.group(1).strip(), aa.group(2).strip())\n        if text.strip():\n            if '|' in atype:\n                atype_no_pipes = atype.replace('|', 'or')\n                rows.append(f'| {atype_no_pipes} | **RETURN** | {text}')\n            else:\n                rows.append(f'| {atype} | **RETURN** | {text}')\n    except Exception as e:\n        pass\n    header = '\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n'\n    md_table = header + '\\n'.join(rows)\n    return md_table",
            "def make_md_table_from_docstring(docstring, a_original_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    row_n_type_regex = re.compile(':param ([\\\\s\\\\S]*?):([\\\\s\\\\S]*?):type [\\\\s\\\\S]*?:([\\\\d\\\\D]*?)\\\\n', flags=re.M | re.DOTALL)\n    'replace WITH regex'\n\n    def replace_re(i, a=' ', z=' '):\n        return re.sub(a, z, i, flags=re.MULTILINE).strip()\n\n    def process_type(txt):\n        \"\"\"\n            striping brackets () from txt:\n            Example:\n            (str)                       -> str\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\n            \"\"\"\n        final_txt = ''\n        if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n            final_txt = txt.rstrip(')').lstrip('(')\n        else:\n            final_txt = txt\n        if ') or (' in final_txt:\n            final_txt = final_txt.replace(') or (', ' OR ')\n        if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n            final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n        return final_txt\n    trips = [triplet(i.group(1), replace_re(i.group(2), '\\\\s{2,}', ' '), process_type(i.group(3).strip())) for (index, i) in enumerate(re.finditer(row_n_type_regex, docstring + ' \\n'))]\n    if not trips and ':return:' not in docstring:\n        raise Exception('no _TRIPs found!')\n    (max_type_width, max_name_width) = (40, 40)\n    try:\n        if trips:\n            (max_type_width, max_name_width) = (max([len(i.atype) for i in trips]), max([len(i.name) for i in trips]))\n    except Exception as e:\n        logger.debug(f'just ALERT ------ bug with max_type_width, max_name_width variables: {a_original_obj.__name__}')\n    row_template = f'| {{: ^{max_type_width}}} | {{: ^{max_name_width}}} | {{}} |'\n    rows = []\n    for some_triplet in trips:\n        if '|' in some_triplet.atype:\n            good_atype = some_triplet.atype.replace('|', 'or')\n        else:\n            good_atype = some_triplet.atype\n        good_atype = good_atype.replace(' OR ', ' or ').replace('\\\\or', 'or')\n        rows.append(row_template.format(good_atype, some_triplet.name, some_triplet.value))\n    row_n_type_regex = re.compile(':param ([\\\\d\\\\w\\\\*\\\\s]+):([\\\\d\\\\D]*?):type [\\\\w\\\\d]+:([\\\\d\\\\D].*?)\\\\n', flags=re.M | re.DOTALL)\n    try:\n        regex_pattern = re.compile(':return:\\\\s*(.*?)\\\\n\\\\s*:rtype:\\\\s*(.*?)\\\\n', flags=re.M | re.DOTALL)\n        a_doc = docstring + ' \\n'\n        aa = list(re.finditer(regex_pattern, a_doc))[0]\n        (text, atype) = (aa.group(1).strip(), aa.group(2).strip())\n        if text.strip():\n            if '|' in atype:\n                atype_no_pipes = atype.replace('|', 'or')\n                rows.append(f'| {atype_no_pipes} | **RETURN** | {text}')\n            else:\n                rows.append(f'| {atype} | **RETURN** | {text}')\n    except Exception as e:\n        pass\n    header = '\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n'\n    md_table = header + '\\n'.join(rows)\n    return md_table",
            "def make_md_table_from_docstring(docstring, a_original_obj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    row_n_type_regex = re.compile(':param ([\\\\s\\\\S]*?):([\\\\s\\\\S]*?):type [\\\\s\\\\S]*?:([\\\\d\\\\D]*?)\\\\n', flags=re.M | re.DOTALL)\n    'replace WITH regex'\n\n    def replace_re(i, a=' ', z=' '):\n        return re.sub(a, z, i, flags=re.MULTILINE).strip()\n\n    def process_type(txt):\n        \"\"\"\n            striping brackets () from txt:\n            Example:\n            (str)                       -> str\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\n            \"\"\"\n        final_txt = ''\n        if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n            final_txt = txt.rstrip(')').lstrip('(')\n        else:\n            final_txt = txt\n        if ') or (' in final_txt:\n            final_txt = final_txt.replace(') or (', ' OR ')\n        if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n            final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n        return final_txt\n    trips = [triplet(i.group(1), replace_re(i.group(2), '\\\\s{2,}', ' '), process_type(i.group(3).strip())) for (index, i) in enumerate(re.finditer(row_n_type_regex, docstring + ' \\n'))]\n    if not trips and ':return:' not in docstring:\n        raise Exception('no _TRIPs found!')\n    (max_type_width, max_name_width) = (40, 40)\n    try:\n        if trips:\n            (max_type_width, max_name_width) = (max([len(i.atype) for i in trips]), max([len(i.name) for i in trips]))\n    except Exception as e:\n        logger.debug(f'just ALERT ------ bug with max_type_width, max_name_width variables: {a_original_obj.__name__}')\n    row_template = f'| {{: ^{max_type_width}}} | {{: ^{max_name_width}}} | {{}} |'\n    rows = []\n    for some_triplet in trips:\n        if '|' in some_triplet.atype:\n            good_atype = some_triplet.atype.replace('|', 'or')\n        else:\n            good_atype = some_triplet.atype\n        good_atype = good_atype.replace(' OR ', ' or ').replace('\\\\or', 'or')\n        rows.append(row_template.format(good_atype, some_triplet.name, some_triplet.value))\n    row_n_type_regex = re.compile(':param ([\\\\d\\\\w\\\\*\\\\s]+):([\\\\d\\\\D]*?):type [\\\\w\\\\d]+:([\\\\d\\\\D].*?)\\\\n', flags=re.M | re.DOTALL)\n    try:\n        regex_pattern = re.compile(':return:\\\\s*(.*?)\\\\n\\\\s*:rtype:\\\\s*(.*?)\\\\n', flags=re.M | re.DOTALL)\n        a_doc = docstring + ' \\n'\n        aa = list(re.finditer(regex_pattern, a_doc))[0]\n        (text, atype) = (aa.group(1).strip(), aa.group(2).strip())\n        if text.strip():\n            if '|' in atype:\n                atype_no_pipes = atype.replace('|', 'or')\n                rows.append(f'| {atype_no_pipes} | **RETURN** | {text}')\n            else:\n                rows.append(f'| {atype} | **RETURN** | {text}')\n    except Exception as e:\n        pass\n    header = '\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n'\n    md_table = header + '\\n'.join(rows)\n    return md_table"
        ]
    },
    {
        "func_name": "get_sig_table_parts",
        "original": "def get_sig_table_parts(function_obj, function_name, doc_string, logger=None, is_method=False, line_break=None, insert_md_section_for__class_methods=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    \"\"\"\n        Convert python object \"function + __doc__\"\n            to\n            \"method call + params table\"    in MARKDOWN\n    \"\"\"\n    doc_string = doc_string.strip()\n    try:\n        rows = []\n        sig = {'self': None} if is_propery(function_obj) else signature(function_obj).parameters\n    except Exception as e:\n        if logger:\n            logger.error(f'''PROBLEM WITH \"{function_obj}\" \"{function_name}\":\\nit's signature is BS. Ok, I will just return '' for 'signature' and 'param_table'\\nOR BETTER - delete it from the 2_readme.md.\\n======''')\n        return ('', '')\n    if not is_propery(function_obj):\n        for key in sig:\n            val = sig[key].default\n            if 'self' == str(key):\n                continue\n            elif key == 'args':\n                rows.append('args=*<1 or N object>')\n            elif val == _empty:\n                rows.append(key)\n            elif val == None:\n                rows.append(f'{key} = None')\n            elif type(val) in (int, float):\n                rows.append(f'{key} = {val}')\n            elif type(val) is str:\n                rows.append(f'{key} = \"{val}\"')\n            elif type(val) is tuple:\n                rows.append(f'{key} = {val}')\n            elif type(val) is bool:\n                rows.append(f'{key} = {val}')\n            elif type(val) is bytes:\n                rows.append(f'{key} = ...')\n            else:\n                raise Exception(f'IDK this type -> {(key, val)}')\n    sig_content = f',\\n{TAB_char}'.join(rows) if len(rows) > 2 else f', '.join(rows) if rows else ''\n    sign = '\\n\\n{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n    if is_method:\n        if insert_md_section_for__class_methods:\n            sign = '\\n\\n{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n        else:\n            sign = '{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n    result = special_cases(function_name, function_obj, sig, doc_string, line_break=line_break)\n    if result.ok:\n        if result.just_text:\n            return (result.just_text, '')\n        else:\n            return (result.sig, result.table)\n    (return_guy, return_guy_type) = get_return_part(doc_string, line_break=line_break)\n    if not return_guy:\n        md_return = return_guy = ''\n    else:\n        md_return = TABLE_RETURN_TEMPLATE.format(return_guy.strip())\n\n    def make_md_table_from_docstring(docstring, a_original_obj):\n        row_n_type_regex = re.compile(':param ([\\\\s\\\\S]*?):([\\\\s\\\\S]*?):type [\\\\s\\\\S]*?:([\\\\d\\\\D]*?)\\\\n', flags=re.M | re.DOTALL)\n        'replace WITH regex'\n\n        def replace_re(i, a=' ', z=' '):\n            return re.sub(a, z, i, flags=re.MULTILINE).strip()\n\n        def process_type(txt):\n            \"\"\"\n            striping brackets () from txt:\n            Example:\n            (str)                       -> str\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\n            \"\"\"\n            final_txt = ''\n            if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n                final_txt = txt.rstrip(')').lstrip('(')\n            else:\n                final_txt = txt\n            if ') or (' in final_txt:\n                final_txt = final_txt.replace(') or (', ' OR ')\n            if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n                final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n            return final_txt\n        trips = [triplet(i.group(1), replace_re(i.group(2), '\\\\s{2,}', ' '), process_type(i.group(3).strip())) for (index, i) in enumerate(re.finditer(row_n_type_regex, docstring + ' \\n'))]\n        if not trips and ':return:' not in docstring:\n            raise Exception('no _TRIPs found!')\n        (max_type_width, max_name_width) = (40, 40)\n        try:\n            if trips:\n                (max_type_width, max_name_width) = (max([len(i.atype) for i in trips]), max([len(i.name) for i in trips]))\n        except Exception as e:\n            logger.debug(f'just ALERT ------ bug with max_type_width, max_name_width variables: {a_original_obj.__name__}')\n        row_template = f'| {{: ^{max_type_width}}} | {{: ^{max_name_width}}} | {{}} |'\n        rows = []\n        for some_triplet in trips:\n            if '|' in some_triplet.atype:\n                good_atype = some_triplet.atype.replace('|', 'or')\n            else:\n                good_atype = some_triplet.atype\n            good_atype = good_atype.replace(' OR ', ' or ').replace('\\\\or', 'or')\n            rows.append(row_template.format(good_atype, some_triplet.name, some_triplet.value))\n        row_n_type_regex = re.compile(':param ([\\\\d\\\\w\\\\*\\\\s]+):([\\\\d\\\\D]*?):type [\\\\w\\\\d]+:([\\\\d\\\\D].*?)\\\\n', flags=re.M | re.DOTALL)\n        try:\n            regex_pattern = re.compile(':return:\\\\s*(.*?)\\\\n\\\\s*:rtype:\\\\s*(.*?)\\\\n', flags=re.M | re.DOTALL)\n            a_doc = docstring + ' \\n'\n            aa = list(re.finditer(regex_pattern, a_doc))[0]\n            (text, atype) = (aa.group(1).strip(), aa.group(2).strip())\n            if text.strip():\n                if '|' in atype:\n                    atype_no_pipes = atype.replace('|', 'or')\n                    rows.append(f'| {atype_no_pipes} | **RETURN** | {text}')\n                else:\n                    rows.append(f'| {atype} | **RETURN** | {text}')\n        except Exception as e:\n            pass\n        header = '\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n'\n        md_table = header + '\\n'.join(rows)\n        return md_table\n    try:\n        params_TABLE = md_table = make_md_table_from_docstring(doc_string, function_obj)\n    except Exception as e:\n        func_name_ = function_obj.__name__\n        if func_name_ not in ['unbind', 'theme_'] and (not func_name_.startswith('theme_')):\n            logger.warning(f'Warning=======    We got empty md_table for \"{func_name_}\"', metadata={'lineno': get_line_number(function_obj)})\n        params_TABLE = md_table = ''\n    if not md_table.strip():\n        params_TABLE = ''\n        if return_guy:\n            sign = sign[:-4] + f' -> {return_guy}\\n```\\n'\n    return (sign, params_TABLE)",
        "mutated": [
            "def get_sig_table_parts(function_obj, function_name, doc_string, logger=None, is_method=False, line_break=None, insert_md_section_for__class_methods=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    if False:\n        i = 10\n    '\\n        Convert python object \"function + __doc__\"\\n            to\\n            \"method call + params table\"    in MARKDOWN\\n    '\n    doc_string = doc_string.strip()\n    try:\n        rows = []\n        sig = {'self': None} if is_propery(function_obj) else signature(function_obj).parameters\n    except Exception as e:\n        if logger:\n            logger.error(f'''PROBLEM WITH \"{function_obj}\" \"{function_name}\":\\nit's signature is BS. Ok, I will just return '' for 'signature' and 'param_table'\\nOR BETTER - delete it from the 2_readme.md.\\n======''')\n        return ('', '')\n    if not is_propery(function_obj):\n        for key in sig:\n            val = sig[key].default\n            if 'self' == str(key):\n                continue\n            elif key == 'args':\n                rows.append('args=*<1 or N object>')\n            elif val == _empty:\n                rows.append(key)\n            elif val == None:\n                rows.append(f'{key} = None')\n            elif type(val) in (int, float):\n                rows.append(f'{key} = {val}')\n            elif type(val) is str:\n                rows.append(f'{key} = \"{val}\"')\n            elif type(val) is tuple:\n                rows.append(f'{key} = {val}')\n            elif type(val) is bool:\n                rows.append(f'{key} = {val}')\n            elif type(val) is bytes:\n                rows.append(f'{key} = ...')\n            else:\n                raise Exception(f'IDK this type -> {(key, val)}')\n    sig_content = f',\\n{TAB_char}'.join(rows) if len(rows) > 2 else f', '.join(rows) if rows else ''\n    sign = '\\n\\n{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n    if is_method:\n        if insert_md_section_for__class_methods:\n            sign = '\\n\\n{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n        else:\n            sign = '{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n    result = special_cases(function_name, function_obj, sig, doc_string, line_break=line_break)\n    if result.ok:\n        if result.just_text:\n            return (result.just_text, '')\n        else:\n            return (result.sig, result.table)\n    (return_guy, return_guy_type) = get_return_part(doc_string, line_break=line_break)\n    if not return_guy:\n        md_return = return_guy = ''\n    else:\n        md_return = TABLE_RETURN_TEMPLATE.format(return_guy.strip())\n\n    def make_md_table_from_docstring(docstring, a_original_obj):\n        row_n_type_regex = re.compile(':param ([\\\\s\\\\S]*?):([\\\\s\\\\S]*?):type [\\\\s\\\\S]*?:([\\\\d\\\\D]*?)\\\\n', flags=re.M | re.DOTALL)\n        'replace WITH regex'\n\n        def replace_re(i, a=' ', z=' '):\n            return re.sub(a, z, i, flags=re.MULTILINE).strip()\n\n        def process_type(txt):\n            \"\"\"\n            striping brackets () from txt:\n            Example:\n            (str)                       -> str\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\n            \"\"\"\n            final_txt = ''\n            if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n                final_txt = txt.rstrip(')').lstrip('(')\n            else:\n                final_txt = txt\n            if ') or (' in final_txt:\n                final_txt = final_txt.replace(') or (', ' OR ')\n            if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n                final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n            return final_txt\n        trips = [triplet(i.group(1), replace_re(i.group(2), '\\\\s{2,}', ' '), process_type(i.group(3).strip())) for (index, i) in enumerate(re.finditer(row_n_type_regex, docstring + ' \\n'))]\n        if not trips and ':return:' not in docstring:\n            raise Exception('no _TRIPs found!')\n        (max_type_width, max_name_width) = (40, 40)\n        try:\n            if trips:\n                (max_type_width, max_name_width) = (max([len(i.atype) for i in trips]), max([len(i.name) for i in trips]))\n        except Exception as e:\n            logger.debug(f'just ALERT ------ bug with max_type_width, max_name_width variables: {a_original_obj.__name__}')\n        row_template = f'| {{: ^{max_type_width}}} | {{: ^{max_name_width}}} | {{}} |'\n        rows = []\n        for some_triplet in trips:\n            if '|' in some_triplet.atype:\n                good_atype = some_triplet.atype.replace('|', 'or')\n            else:\n                good_atype = some_triplet.atype\n            good_atype = good_atype.replace(' OR ', ' or ').replace('\\\\or', 'or')\n            rows.append(row_template.format(good_atype, some_triplet.name, some_triplet.value))\n        row_n_type_regex = re.compile(':param ([\\\\d\\\\w\\\\*\\\\s]+):([\\\\d\\\\D]*?):type [\\\\w\\\\d]+:([\\\\d\\\\D].*?)\\\\n', flags=re.M | re.DOTALL)\n        try:\n            regex_pattern = re.compile(':return:\\\\s*(.*?)\\\\n\\\\s*:rtype:\\\\s*(.*?)\\\\n', flags=re.M | re.DOTALL)\n            a_doc = docstring + ' \\n'\n            aa = list(re.finditer(regex_pattern, a_doc))[0]\n            (text, atype) = (aa.group(1).strip(), aa.group(2).strip())\n            if text.strip():\n                if '|' in atype:\n                    atype_no_pipes = atype.replace('|', 'or')\n                    rows.append(f'| {atype_no_pipes} | **RETURN** | {text}')\n                else:\n                    rows.append(f'| {atype} | **RETURN** | {text}')\n        except Exception as e:\n            pass\n        header = '\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n'\n        md_table = header + '\\n'.join(rows)\n        return md_table\n    try:\n        params_TABLE = md_table = make_md_table_from_docstring(doc_string, function_obj)\n    except Exception as e:\n        func_name_ = function_obj.__name__\n        if func_name_ not in ['unbind', 'theme_'] and (not func_name_.startswith('theme_')):\n            logger.warning(f'Warning=======    We got empty md_table for \"{func_name_}\"', metadata={'lineno': get_line_number(function_obj)})\n        params_TABLE = md_table = ''\n    if not md_table.strip():\n        params_TABLE = ''\n        if return_guy:\n            sign = sign[:-4] + f' -> {return_guy}\\n```\\n'\n    return (sign, params_TABLE)",
            "def get_sig_table_parts(function_obj, function_name, doc_string, logger=None, is_method=False, line_break=None, insert_md_section_for__class_methods=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Convert python object \"function + __doc__\"\\n            to\\n            \"method call + params table\"    in MARKDOWN\\n    '\n    doc_string = doc_string.strip()\n    try:\n        rows = []\n        sig = {'self': None} if is_propery(function_obj) else signature(function_obj).parameters\n    except Exception as e:\n        if logger:\n            logger.error(f'''PROBLEM WITH \"{function_obj}\" \"{function_name}\":\\nit's signature is BS. Ok, I will just return '' for 'signature' and 'param_table'\\nOR BETTER - delete it from the 2_readme.md.\\n======''')\n        return ('', '')\n    if not is_propery(function_obj):\n        for key in sig:\n            val = sig[key].default\n            if 'self' == str(key):\n                continue\n            elif key == 'args':\n                rows.append('args=*<1 or N object>')\n            elif val == _empty:\n                rows.append(key)\n            elif val == None:\n                rows.append(f'{key} = None')\n            elif type(val) in (int, float):\n                rows.append(f'{key} = {val}')\n            elif type(val) is str:\n                rows.append(f'{key} = \"{val}\"')\n            elif type(val) is tuple:\n                rows.append(f'{key} = {val}')\n            elif type(val) is bool:\n                rows.append(f'{key} = {val}')\n            elif type(val) is bytes:\n                rows.append(f'{key} = ...')\n            else:\n                raise Exception(f'IDK this type -> {(key, val)}')\n    sig_content = f',\\n{TAB_char}'.join(rows) if len(rows) > 2 else f', '.join(rows) if rows else ''\n    sign = '\\n\\n{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n    if is_method:\n        if insert_md_section_for__class_methods:\n            sign = '\\n\\n{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n        else:\n            sign = '{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n    result = special_cases(function_name, function_obj, sig, doc_string, line_break=line_break)\n    if result.ok:\n        if result.just_text:\n            return (result.just_text, '')\n        else:\n            return (result.sig, result.table)\n    (return_guy, return_guy_type) = get_return_part(doc_string, line_break=line_break)\n    if not return_guy:\n        md_return = return_guy = ''\n    else:\n        md_return = TABLE_RETURN_TEMPLATE.format(return_guy.strip())\n\n    def make_md_table_from_docstring(docstring, a_original_obj):\n        row_n_type_regex = re.compile(':param ([\\\\s\\\\S]*?):([\\\\s\\\\S]*?):type [\\\\s\\\\S]*?:([\\\\d\\\\D]*?)\\\\n', flags=re.M | re.DOTALL)\n        'replace WITH regex'\n\n        def replace_re(i, a=' ', z=' '):\n            return re.sub(a, z, i, flags=re.MULTILINE).strip()\n\n        def process_type(txt):\n            \"\"\"\n            striping brackets () from txt:\n            Example:\n            (str)                       -> str\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\n            \"\"\"\n            final_txt = ''\n            if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n                final_txt = txt.rstrip(')').lstrip('(')\n            else:\n                final_txt = txt\n            if ') or (' in final_txt:\n                final_txt = final_txt.replace(') or (', ' OR ')\n            if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n                final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n            return final_txt\n        trips = [triplet(i.group(1), replace_re(i.group(2), '\\\\s{2,}', ' '), process_type(i.group(3).strip())) for (index, i) in enumerate(re.finditer(row_n_type_regex, docstring + ' \\n'))]\n        if not trips and ':return:' not in docstring:\n            raise Exception('no _TRIPs found!')\n        (max_type_width, max_name_width) = (40, 40)\n        try:\n            if trips:\n                (max_type_width, max_name_width) = (max([len(i.atype) for i in trips]), max([len(i.name) for i in trips]))\n        except Exception as e:\n            logger.debug(f'just ALERT ------ bug with max_type_width, max_name_width variables: {a_original_obj.__name__}')\n        row_template = f'| {{: ^{max_type_width}}} | {{: ^{max_name_width}}} | {{}} |'\n        rows = []\n        for some_triplet in trips:\n            if '|' in some_triplet.atype:\n                good_atype = some_triplet.atype.replace('|', 'or')\n            else:\n                good_atype = some_triplet.atype\n            good_atype = good_atype.replace(' OR ', ' or ').replace('\\\\or', 'or')\n            rows.append(row_template.format(good_atype, some_triplet.name, some_triplet.value))\n        row_n_type_regex = re.compile(':param ([\\\\d\\\\w\\\\*\\\\s]+):([\\\\d\\\\D]*?):type [\\\\w\\\\d]+:([\\\\d\\\\D].*?)\\\\n', flags=re.M | re.DOTALL)\n        try:\n            regex_pattern = re.compile(':return:\\\\s*(.*?)\\\\n\\\\s*:rtype:\\\\s*(.*?)\\\\n', flags=re.M | re.DOTALL)\n            a_doc = docstring + ' \\n'\n            aa = list(re.finditer(regex_pattern, a_doc))[0]\n            (text, atype) = (aa.group(1).strip(), aa.group(2).strip())\n            if text.strip():\n                if '|' in atype:\n                    atype_no_pipes = atype.replace('|', 'or')\n                    rows.append(f'| {atype_no_pipes} | **RETURN** | {text}')\n                else:\n                    rows.append(f'| {atype} | **RETURN** | {text}')\n        except Exception as e:\n            pass\n        header = '\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n'\n        md_table = header + '\\n'.join(rows)\n        return md_table\n    try:\n        params_TABLE = md_table = make_md_table_from_docstring(doc_string, function_obj)\n    except Exception as e:\n        func_name_ = function_obj.__name__\n        if func_name_ not in ['unbind', 'theme_'] and (not func_name_.startswith('theme_')):\n            logger.warning(f'Warning=======    We got empty md_table for \"{func_name_}\"', metadata={'lineno': get_line_number(function_obj)})\n        params_TABLE = md_table = ''\n    if not md_table.strip():\n        params_TABLE = ''\n        if return_guy:\n            sign = sign[:-4] + f' -> {return_guy}\\n```\\n'\n    return (sign, params_TABLE)",
            "def get_sig_table_parts(function_obj, function_name, doc_string, logger=None, is_method=False, line_break=None, insert_md_section_for__class_methods=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Convert python object \"function + __doc__\"\\n            to\\n            \"method call + params table\"    in MARKDOWN\\n    '\n    doc_string = doc_string.strip()\n    try:\n        rows = []\n        sig = {'self': None} if is_propery(function_obj) else signature(function_obj).parameters\n    except Exception as e:\n        if logger:\n            logger.error(f'''PROBLEM WITH \"{function_obj}\" \"{function_name}\":\\nit's signature is BS. Ok, I will just return '' for 'signature' and 'param_table'\\nOR BETTER - delete it from the 2_readme.md.\\n======''')\n        return ('', '')\n    if not is_propery(function_obj):\n        for key in sig:\n            val = sig[key].default\n            if 'self' == str(key):\n                continue\n            elif key == 'args':\n                rows.append('args=*<1 or N object>')\n            elif val == _empty:\n                rows.append(key)\n            elif val == None:\n                rows.append(f'{key} = None')\n            elif type(val) in (int, float):\n                rows.append(f'{key} = {val}')\n            elif type(val) is str:\n                rows.append(f'{key} = \"{val}\"')\n            elif type(val) is tuple:\n                rows.append(f'{key} = {val}')\n            elif type(val) is bool:\n                rows.append(f'{key} = {val}')\n            elif type(val) is bytes:\n                rows.append(f'{key} = ...')\n            else:\n                raise Exception(f'IDK this type -> {(key, val)}')\n    sig_content = f',\\n{TAB_char}'.join(rows) if len(rows) > 2 else f', '.join(rows) if rows else ''\n    sign = '\\n\\n{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n    if is_method:\n        if insert_md_section_for__class_methods:\n            sign = '\\n\\n{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n        else:\n            sign = '{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n    result = special_cases(function_name, function_obj, sig, doc_string, line_break=line_break)\n    if result.ok:\n        if result.just_text:\n            return (result.just_text, '')\n        else:\n            return (result.sig, result.table)\n    (return_guy, return_guy_type) = get_return_part(doc_string, line_break=line_break)\n    if not return_guy:\n        md_return = return_guy = ''\n    else:\n        md_return = TABLE_RETURN_TEMPLATE.format(return_guy.strip())\n\n    def make_md_table_from_docstring(docstring, a_original_obj):\n        row_n_type_regex = re.compile(':param ([\\\\s\\\\S]*?):([\\\\s\\\\S]*?):type [\\\\s\\\\S]*?:([\\\\d\\\\D]*?)\\\\n', flags=re.M | re.DOTALL)\n        'replace WITH regex'\n\n        def replace_re(i, a=' ', z=' '):\n            return re.sub(a, z, i, flags=re.MULTILINE).strip()\n\n        def process_type(txt):\n            \"\"\"\n            striping brackets () from txt:\n            Example:\n            (str)                       -> str\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\n            \"\"\"\n            final_txt = ''\n            if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n                final_txt = txt.rstrip(')').lstrip('(')\n            else:\n                final_txt = txt\n            if ') or (' in final_txt:\n                final_txt = final_txt.replace(') or (', ' OR ')\n            if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n                final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n            return final_txt\n        trips = [triplet(i.group(1), replace_re(i.group(2), '\\\\s{2,}', ' '), process_type(i.group(3).strip())) for (index, i) in enumerate(re.finditer(row_n_type_regex, docstring + ' \\n'))]\n        if not trips and ':return:' not in docstring:\n            raise Exception('no _TRIPs found!')\n        (max_type_width, max_name_width) = (40, 40)\n        try:\n            if trips:\n                (max_type_width, max_name_width) = (max([len(i.atype) for i in trips]), max([len(i.name) for i in trips]))\n        except Exception as e:\n            logger.debug(f'just ALERT ------ bug with max_type_width, max_name_width variables: {a_original_obj.__name__}')\n        row_template = f'| {{: ^{max_type_width}}} | {{: ^{max_name_width}}} | {{}} |'\n        rows = []\n        for some_triplet in trips:\n            if '|' in some_triplet.atype:\n                good_atype = some_triplet.atype.replace('|', 'or')\n            else:\n                good_atype = some_triplet.atype\n            good_atype = good_atype.replace(' OR ', ' or ').replace('\\\\or', 'or')\n            rows.append(row_template.format(good_atype, some_triplet.name, some_triplet.value))\n        row_n_type_regex = re.compile(':param ([\\\\d\\\\w\\\\*\\\\s]+):([\\\\d\\\\D]*?):type [\\\\w\\\\d]+:([\\\\d\\\\D].*?)\\\\n', flags=re.M | re.DOTALL)\n        try:\n            regex_pattern = re.compile(':return:\\\\s*(.*?)\\\\n\\\\s*:rtype:\\\\s*(.*?)\\\\n', flags=re.M | re.DOTALL)\n            a_doc = docstring + ' \\n'\n            aa = list(re.finditer(regex_pattern, a_doc))[0]\n            (text, atype) = (aa.group(1).strip(), aa.group(2).strip())\n            if text.strip():\n                if '|' in atype:\n                    atype_no_pipes = atype.replace('|', 'or')\n                    rows.append(f'| {atype_no_pipes} | **RETURN** | {text}')\n                else:\n                    rows.append(f'| {atype} | **RETURN** | {text}')\n        except Exception as e:\n            pass\n        header = '\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n'\n        md_table = header + '\\n'.join(rows)\n        return md_table\n    try:\n        params_TABLE = md_table = make_md_table_from_docstring(doc_string, function_obj)\n    except Exception as e:\n        func_name_ = function_obj.__name__\n        if func_name_ not in ['unbind', 'theme_'] and (not func_name_.startswith('theme_')):\n            logger.warning(f'Warning=======    We got empty md_table for \"{func_name_}\"', metadata={'lineno': get_line_number(function_obj)})\n        params_TABLE = md_table = ''\n    if not md_table.strip():\n        params_TABLE = ''\n        if return_guy:\n            sign = sign[:-4] + f' -> {return_guy}\\n```\\n'\n    return (sign, params_TABLE)",
            "def get_sig_table_parts(function_obj, function_name, doc_string, logger=None, is_method=False, line_break=None, insert_md_section_for__class_methods=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Convert python object \"function + __doc__\"\\n            to\\n            \"method call + params table\"    in MARKDOWN\\n    '\n    doc_string = doc_string.strip()\n    try:\n        rows = []\n        sig = {'self': None} if is_propery(function_obj) else signature(function_obj).parameters\n    except Exception as e:\n        if logger:\n            logger.error(f'''PROBLEM WITH \"{function_obj}\" \"{function_name}\":\\nit's signature is BS. Ok, I will just return '' for 'signature' and 'param_table'\\nOR BETTER - delete it from the 2_readme.md.\\n======''')\n        return ('', '')\n    if not is_propery(function_obj):\n        for key in sig:\n            val = sig[key].default\n            if 'self' == str(key):\n                continue\n            elif key == 'args':\n                rows.append('args=*<1 or N object>')\n            elif val == _empty:\n                rows.append(key)\n            elif val == None:\n                rows.append(f'{key} = None')\n            elif type(val) in (int, float):\n                rows.append(f'{key} = {val}')\n            elif type(val) is str:\n                rows.append(f'{key} = \"{val}\"')\n            elif type(val) is tuple:\n                rows.append(f'{key} = {val}')\n            elif type(val) is bool:\n                rows.append(f'{key} = {val}')\n            elif type(val) is bytes:\n                rows.append(f'{key} = ...')\n            else:\n                raise Exception(f'IDK this type -> {(key, val)}')\n    sig_content = f',\\n{TAB_char}'.join(rows) if len(rows) > 2 else f', '.join(rows) if rows else ''\n    sign = '\\n\\n{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n    if is_method:\n        if insert_md_section_for__class_methods:\n            sign = '\\n\\n{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n        else:\n            sign = '{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n    result = special_cases(function_name, function_obj, sig, doc_string, line_break=line_break)\n    if result.ok:\n        if result.just_text:\n            return (result.just_text, '')\n        else:\n            return (result.sig, result.table)\n    (return_guy, return_guy_type) = get_return_part(doc_string, line_break=line_break)\n    if not return_guy:\n        md_return = return_guy = ''\n    else:\n        md_return = TABLE_RETURN_TEMPLATE.format(return_guy.strip())\n\n    def make_md_table_from_docstring(docstring, a_original_obj):\n        row_n_type_regex = re.compile(':param ([\\\\s\\\\S]*?):([\\\\s\\\\S]*?):type [\\\\s\\\\S]*?:([\\\\d\\\\D]*?)\\\\n', flags=re.M | re.DOTALL)\n        'replace WITH regex'\n\n        def replace_re(i, a=' ', z=' '):\n            return re.sub(a, z, i, flags=re.MULTILINE).strip()\n\n        def process_type(txt):\n            \"\"\"\n            striping brackets () from txt:\n            Example:\n            (str)                       -> str\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\n            \"\"\"\n            final_txt = ''\n            if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n                final_txt = txt.rstrip(')').lstrip('(')\n            else:\n                final_txt = txt\n            if ') or (' in final_txt:\n                final_txt = final_txt.replace(') or (', ' OR ')\n            if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n                final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n            return final_txt\n        trips = [triplet(i.group(1), replace_re(i.group(2), '\\\\s{2,}', ' '), process_type(i.group(3).strip())) for (index, i) in enumerate(re.finditer(row_n_type_regex, docstring + ' \\n'))]\n        if not trips and ':return:' not in docstring:\n            raise Exception('no _TRIPs found!')\n        (max_type_width, max_name_width) = (40, 40)\n        try:\n            if trips:\n                (max_type_width, max_name_width) = (max([len(i.atype) for i in trips]), max([len(i.name) for i in trips]))\n        except Exception as e:\n            logger.debug(f'just ALERT ------ bug with max_type_width, max_name_width variables: {a_original_obj.__name__}')\n        row_template = f'| {{: ^{max_type_width}}} | {{: ^{max_name_width}}} | {{}} |'\n        rows = []\n        for some_triplet in trips:\n            if '|' in some_triplet.atype:\n                good_atype = some_triplet.atype.replace('|', 'or')\n            else:\n                good_atype = some_triplet.atype\n            good_atype = good_atype.replace(' OR ', ' or ').replace('\\\\or', 'or')\n            rows.append(row_template.format(good_atype, some_triplet.name, some_triplet.value))\n        row_n_type_regex = re.compile(':param ([\\\\d\\\\w\\\\*\\\\s]+):([\\\\d\\\\D]*?):type [\\\\w\\\\d]+:([\\\\d\\\\D].*?)\\\\n', flags=re.M | re.DOTALL)\n        try:\n            regex_pattern = re.compile(':return:\\\\s*(.*?)\\\\n\\\\s*:rtype:\\\\s*(.*?)\\\\n', flags=re.M | re.DOTALL)\n            a_doc = docstring + ' \\n'\n            aa = list(re.finditer(regex_pattern, a_doc))[0]\n            (text, atype) = (aa.group(1).strip(), aa.group(2).strip())\n            if text.strip():\n                if '|' in atype:\n                    atype_no_pipes = atype.replace('|', 'or')\n                    rows.append(f'| {atype_no_pipes} | **RETURN** | {text}')\n                else:\n                    rows.append(f'| {atype} | **RETURN** | {text}')\n        except Exception as e:\n            pass\n        header = '\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n'\n        md_table = header + '\\n'.join(rows)\n        return md_table\n    try:\n        params_TABLE = md_table = make_md_table_from_docstring(doc_string, function_obj)\n    except Exception as e:\n        func_name_ = function_obj.__name__\n        if func_name_ not in ['unbind', 'theme_'] and (not func_name_.startswith('theme_')):\n            logger.warning(f'Warning=======    We got empty md_table for \"{func_name_}\"', metadata={'lineno': get_line_number(function_obj)})\n        params_TABLE = md_table = ''\n    if not md_table.strip():\n        params_TABLE = ''\n        if return_guy:\n            sign = sign[:-4] + f' -> {return_guy}\\n```\\n'\n    return (sign, params_TABLE)",
            "def get_sig_table_parts(function_obj, function_name, doc_string, logger=None, is_method=False, line_break=None, insert_md_section_for__class_methods=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Convert python object \"function + __doc__\"\\n            to\\n            \"method call + params table\"    in MARKDOWN\\n    '\n    doc_string = doc_string.strip()\n    try:\n        rows = []\n        sig = {'self': None} if is_propery(function_obj) else signature(function_obj).parameters\n    except Exception as e:\n        if logger:\n            logger.error(f'''PROBLEM WITH \"{function_obj}\" \"{function_name}\":\\nit's signature is BS. Ok, I will just return '' for 'signature' and 'param_table'\\nOR BETTER - delete it from the 2_readme.md.\\n======''')\n        return ('', '')\n    if not is_propery(function_obj):\n        for key in sig:\n            val = sig[key].default\n            if 'self' == str(key):\n                continue\n            elif key == 'args':\n                rows.append('args=*<1 or N object>')\n            elif val == _empty:\n                rows.append(key)\n            elif val == None:\n                rows.append(f'{key} = None')\n            elif type(val) in (int, float):\n                rows.append(f'{key} = {val}')\n            elif type(val) is str:\n                rows.append(f'{key} = \"{val}\"')\n            elif type(val) is tuple:\n                rows.append(f'{key} = {val}')\n            elif type(val) is bool:\n                rows.append(f'{key} = {val}')\n            elif type(val) is bytes:\n                rows.append(f'{key} = ...')\n            else:\n                raise Exception(f'IDK this type -> {(key, val)}')\n    sig_content = f',\\n{TAB_char}'.join(rows) if len(rows) > 2 else f', '.join(rows) if rows else ''\n    sign = '\\n\\n{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n    if is_method:\n        if insert_md_section_for__class_methods:\n            sign = '\\n\\n{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n        else:\n            sign = '{0}\\n\\n```\\n{1}({2})\\n```'.format(get_doc_desc(doc_string, function_obj), function_name, sig_content)\n    result = special_cases(function_name, function_obj, sig, doc_string, line_break=line_break)\n    if result.ok:\n        if result.just_text:\n            return (result.just_text, '')\n        else:\n            return (result.sig, result.table)\n    (return_guy, return_guy_type) = get_return_part(doc_string, line_break=line_break)\n    if not return_guy:\n        md_return = return_guy = ''\n    else:\n        md_return = TABLE_RETURN_TEMPLATE.format(return_guy.strip())\n\n    def make_md_table_from_docstring(docstring, a_original_obj):\n        row_n_type_regex = re.compile(':param ([\\\\s\\\\S]*?):([\\\\s\\\\S]*?):type [\\\\s\\\\S]*?:([\\\\d\\\\D]*?)\\\\n', flags=re.M | re.DOTALL)\n        'replace WITH regex'\n\n        def replace_re(i, a=' ', z=' '):\n            return re.sub(a, z, i, flags=re.MULTILINE).strip()\n\n        def process_type(txt):\n            \"\"\"\n            striping brackets () from txt:\n            Example:\n            (str)                       -> str\n            Union[str, Tuple[str, int]] -> Union[str, Tuple[str, int]]\n            \"\"\"\n            final_txt = ''\n            if re.compile('\\\\(\\\\s?\\\\w+\\\\s?\\\\)', flags=re.M | re.DOTALL).match(txt):\n                final_txt = txt.rstrip(')').lstrip('(')\n            else:\n                final_txt = txt\n            if ') or (' in final_txt:\n                final_txt = final_txt.replace(') or (', ' OR ')\n            if replace_pipe_bar_in_TYPE_TEXT_char and '|' in final_txt:\n                final_txt = final_txt.replace('|', replace_pipe_bar_in_TYPE_TEXT_char)\n            return final_txt\n        trips = [triplet(i.group(1), replace_re(i.group(2), '\\\\s{2,}', ' '), process_type(i.group(3).strip())) for (index, i) in enumerate(re.finditer(row_n_type_regex, docstring + ' \\n'))]\n        if not trips and ':return:' not in docstring:\n            raise Exception('no _TRIPs found!')\n        (max_type_width, max_name_width) = (40, 40)\n        try:\n            if trips:\n                (max_type_width, max_name_width) = (max([len(i.atype) for i in trips]), max([len(i.name) for i in trips]))\n        except Exception as e:\n            logger.debug(f'just ALERT ------ bug with max_type_width, max_name_width variables: {a_original_obj.__name__}')\n        row_template = f'| {{: ^{max_type_width}}} | {{: ^{max_name_width}}} | {{}} |'\n        rows = []\n        for some_triplet in trips:\n            if '|' in some_triplet.atype:\n                good_atype = some_triplet.atype.replace('|', 'or')\n            else:\n                good_atype = some_triplet.atype\n            good_atype = good_atype.replace(' OR ', ' or ').replace('\\\\or', 'or')\n            rows.append(row_template.format(good_atype, some_triplet.name, some_triplet.value))\n        row_n_type_regex = re.compile(':param ([\\\\d\\\\w\\\\*\\\\s]+):([\\\\d\\\\D]*?):type [\\\\w\\\\d]+:([\\\\d\\\\D].*?)\\\\n', flags=re.M | re.DOTALL)\n        try:\n            regex_pattern = re.compile(':return:\\\\s*(.*?)\\\\n\\\\s*:rtype:\\\\s*(.*?)\\\\n', flags=re.M | re.DOTALL)\n            a_doc = docstring + ' \\n'\n            aa = list(re.finditer(regex_pattern, a_doc))[0]\n            (text, atype) = (aa.group(1).strip(), aa.group(2).strip())\n            if text.strip():\n                if '|' in atype:\n                    atype_no_pipes = atype.replace('|', 'or')\n                    rows.append(f'| {atype_no_pipes} | **RETURN** | {text}')\n                else:\n                    rows.append(f'| {atype} | **RETURN** | {text}')\n        except Exception as e:\n            pass\n        header = '\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n'\n        md_table = header + '\\n'.join(rows)\n        return md_table\n    try:\n        params_TABLE = md_table = make_md_table_from_docstring(doc_string, function_obj)\n    except Exception as e:\n        func_name_ = function_obj.__name__\n        if func_name_ not in ['unbind', 'theme_'] and (not func_name_.startswith('theme_')):\n            logger.warning(f'Warning=======    We got empty md_table for \"{func_name_}\"', metadata={'lineno': get_line_number(function_obj)})\n        params_TABLE = md_table = ''\n    if not md_table.strip():\n        params_TABLE = ''\n        if return_guy:\n            sign = sign[:-4] + f' -> {return_guy}\\n```\\n'\n    return (sign, params_TABLE)"
        ]
    },
    {
        "func_name": "pad_n",
        "original": "def pad_n(text):\n    return f'\\n{text}\\n'",
        "mutated": [
            "def pad_n(text):\n    if False:\n        i = 10\n    return f'\\n{text}\\n'",
            "def pad_n(text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return f'\\n{text}\\n'",
            "def pad_n(text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return f'\\n{text}\\n'",
            "def pad_n(text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return f'\\n{text}\\n'",
            "def pad_n(text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return f'\\n{text}\\n'"
        ]
    },
    {
        "func_name": "render",
        "original": "def render(injection, logger=None, line_break=None, insert_md_section_for__class_methods=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    try:\n        if 'skip readme' in injection['function_object'].__doc__:\n            return ''\n    except Exception as e:\n        return ''\n    if injection['part1'] == 'func':\n        (sig, table) = get_sig_table_parts(function_obj=injection['function_object'], function_name=injection['part2'], insert_md_section_for__class_methods=insert_md_section_for__class_methods, doc_string=injection['function_object'].__doc__, logger=logger, line_break=line_break, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n    else:\n        function_name = injection['parent_class'].__name__ if injection['part2'] == '__init__' else injection['part2']\n        (sig, table) = get_sig_table_parts(function_obj=injection['function_object'], function_name=function_name, is_method=True, insert_md_section_for__class_methods=insert_md_section_for__class_methods, doc_string=injection['function_object'].__doc__, logger=logger, line_break=line_break, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n    if injection['number'] == '':\n        return pad_n(sig) + pad_n(table)\n    elif injection['number'] == '1':\n        return pad_n(sig)\n    elif injection['number'] == '2':\n        return pad_n(table)\n    elif logger:\n        logger.error(f'Error in processing {injection}')",
        "mutated": [
            "def render(injection, logger=None, line_break=None, insert_md_section_for__class_methods=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    if False:\n        i = 10\n    try:\n        if 'skip readme' in injection['function_object'].__doc__:\n            return ''\n    except Exception as e:\n        return ''\n    if injection['part1'] == 'func':\n        (sig, table) = get_sig_table_parts(function_obj=injection['function_object'], function_name=injection['part2'], insert_md_section_for__class_methods=insert_md_section_for__class_methods, doc_string=injection['function_object'].__doc__, logger=logger, line_break=line_break, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n    else:\n        function_name = injection['parent_class'].__name__ if injection['part2'] == '__init__' else injection['part2']\n        (sig, table) = get_sig_table_parts(function_obj=injection['function_object'], function_name=function_name, is_method=True, insert_md_section_for__class_methods=insert_md_section_for__class_methods, doc_string=injection['function_object'].__doc__, logger=logger, line_break=line_break, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n    if injection['number'] == '':\n        return pad_n(sig) + pad_n(table)\n    elif injection['number'] == '1':\n        return pad_n(sig)\n    elif injection['number'] == '2':\n        return pad_n(table)\n    elif logger:\n        logger.error(f'Error in processing {injection}')",
            "def render(injection, logger=None, line_break=None, insert_md_section_for__class_methods=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        if 'skip readme' in injection['function_object'].__doc__:\n            return ''\n    except Exception as e:\n        return ''\n    if injection['part1'] == 'func':\n        (sig, table) = get_sig_table_parts(function_obj=injection['function_object'], function_name=injection['part2'], insert_md_section_for__class_methods=insert_md_section_for__class_methods, doc_string=injection['function_object'].__doc__, logger=logger, line_break=line_break, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n    else:\n        function_name = injection['parent_class'].__name__ if injection['part2'] == '__init__' else injection['part2']\n        (sig, table) = get_sig_table_parts(function_obj=injection['function_object'], function_name=function_name, is_method=True, insert_md_section_for__class_methods=insert_md_section_for__class_methods, doc_string=injection['function_object'].__doc__, logger=logger, line_break=line_break, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n    if injection['number'] == '':\n        return pad_n(sig) + pad_n(table)\n    elif injection['number'] == '1':\n        return pad_n(sig)\n    elif injection['number'] == '2':\n        return pad_n(table)\n    elif logger:\n        logger.error(f'Error in processing {injection}')",
            "def render(injection, logger=None, line_break=None, insert_md_section_for__class_methods=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        if 'skip readme' in injection['function_object'].__doc__:\n            return ''\n    except Exception as e:\n        return ''\n    if injection['part1'] == 'func':\n        (sig, table) = get_sig_table_parts(function_obj=injection['function_object'], function_name=injection['part2'], insert_md_section_for__class_methods=insert_md_section_for__class_methods, doc_string=injection['function_object'].__doc__, logger=logger, line_break=line_break, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n    else:\n        function_name = injection['parent_class'].__name__ if injection['part2'] == '__init__' else injection['part2']\n        (sig, table) = get_sig_table_parts(function_obj=injection['function_object'], function_name=function_name, is_method=True, insert_md_section_for__class_methods=insert_md_section_for__class_methods, doc_string=injection['function_object'].__doc__, logger=logger, line_break=line_break, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n    if injection['number'] == '':\n        return pad_n(sig) + pad_n(table)\n    elif injection['number'] == '1':\n        return pad_n(sig)\n    elif injection['number'] == '2':\n        return pad_n(table)\n    elif logger:\n        logger.error(f'Error in processing {injection}')",
            "def render(injection, logger=None, line_break=None, insert_md_section_for__class_methods=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        if 'skip readme' in injection['function_object'].__doc__:\n            return ''\n    except Exception as e:\n        return ''\n    if injection['part1'] == 'func':\n        (sig, table) = get_sig_table_parts(function_obj=injection['function_object'], function_name=injection['part2'], insert_md_section_for__class_methods=insert_md_section_for__class_methods, doc_string=injection['function_object'].__doc__, logger=logger, line_break=line_break, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n    else:\n        function_name = injection['parent_class'].__name__ if injection['part2'] == '__init__' else injection['part2']\n        (sig, table) = get_sig_table_parts(function_obj=injection['function_object'], function_name=function_name, is_method=True, insert_md_section_for__class_methods=insert_md_section_for__class_methods, doc_string=injection['function_object'].__doc__, logger=logger, line_break=line_break, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n    if injection['number'] == '':\n        return pad_n(sig) + pad_n(table)\n    elif injection['number'] == '1':\n        return pad_n(sig)\n    elif injection['number'] == '2':\n        return pad_n(table)\n    elif logger:\n        logger.error(f'Error in processing {injection}')",
            "def render(injection, logger=None, line_break=None, insert_md_section_for__class_methods=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        if 'skip readme' in injection['function_object'].__doc__:\n            return ''\n    except Exception as e:\n        return ''\n    if injection['part1'] == 'func':\n        (sig, table) = get_sig_table_parts(function_obj=injection['function_object'], function_name=injection['part2'], insert_md_section_for__class_methods=insert_md_section_for__class_methods, doc_string=injection['function_object'].__doc__, logger=logger, line_break=line_break, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n    else:\n        function_name = injection['parent_class'].__name__ if injection['part2'] == '__init__' else injection['part2']\n        (sig, table) = get_sig_table_parts(function_obj=injection['function_object'], function_name=function_name, is_method=True, insert_md_section_for__class_methods=insert_md_section_for__class_methods, doc_string=injection['function_object'].__doc__, logger=logger, line_break=line_break, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n    if injection['number'] == '':\n        return pad_n(sig) + pad_n(table)\n    elif injection['number'] == '1':\n        return pad_n(sig)\n    elif injection['number'] == '2':\n        return pad_n(table)\n    elif logger:\n        logger.error(f'Error in processing {injection}')"
        ]
    },
    {
        "func_name": "readfile",
        "original": "def readfile(fname):\n    with open(fname, 'r', encoding='utf-8') as ff:\n        return ff.read()",
        "mutated": [
            "def readfile(fname):\n    if False:\n        i = 10\n    with open(fname, 'r', encoding='utf-8') as ff:\n        return ff.read()",
            "def readfile(fname):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with open(fname, 'r', encoding='utf-8') as ff:\n        return ff.read()",
            "def readfile(fname):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with open(fname, 'r', encoding='utf-8') as ff:\n        return ff.read()",
            "def readfile(fname):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with open(fname, 'r', encoding='utf-8') as ff:\n        return ff.read()",
            "def readfile(fname):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with open(fname, 'r', encoding='utf-8') as ff:\n        return ff.read()"
        ]
    },
    {
        "func_name": "valid_field",
        "original": "def valid_field(pair):\n    bad_fields = 'LOOK_AND_FEEL_TABLE copyright __builtins__ icon'.split(' ')\n    bad_prefix = 'TITLE_ TEXT_ ELEM_TYPE_ DEFAULT_ BUTTON_TYPE_ LISTBOX_SELECT METER_ POPUP_ THEME_'.split(' ')\n    (field_name, python_object) = pair\n    if type(python_object) is bytes:\n        return False\n    if field_name in bad_fields:\n        return False\n    if any([i for i in bad_prefix if field_name.startswith(i)]):\n        return False\n    return True",
        "mutated": [
            "def valid_field(pair):\n    if False:\n        i = 10\n    bad_fields = 'LOOK_AND_FEEL_TABLE copyright __builtins__ icon'.split(' ')\n    bad_prefix = 'TITLE_ TEXT_ ELEM_TYPE_ DEFAULT_ BUTTON_TYPE_ LISTBOX_SELECT METER_ POPUP_ THEME_'.split(' ')\n    (field_name, python_object) = pair\n    if type(python_object) is bytes:\n        return False\n    if field_name in bad_fields:\n        return False\n    if any([i for i in bad_prefix if field_name.startswith(i)]):\n        return False\n    return True",
            "def valid_field(pair):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    bad_fields = 'LOOK_AND_FEEL_TABLE copyright __builtins__ icon'.split(' ')\n    bad_prefix = 'TITLE_ TEXT_ ELEM_TYPE_ DEFAULT_ BUTTON_TYPE_ LISTBOX_SELECT METER_ POPUP_ THEME_'.split(' ')\n    (field_name, python_object) = pair\n    if type(python_object) is bytes:\n        return False\n    if field_name in bad_fields:\n        return False\n    if any([i for i in bad_prefix if field_name.startswith(i)]):\n        return False\n    return True",
            "def valid_field(pair):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    bad_fields = 'LOOK_AND_FEEL_TABLE copyright __builtins__ icon'.split(' ')\n    bad_prefix = 'TITLE_ TEXT_ ELEM_TYPE_ DEFAULT_ BUTTON_TYPE_ LISTBOX_SELECT METER_ POPUP_ THEME_'.split(' ')\n    (field_name, python_object) = pair\n    if type(python_object) is bytes:\n        return False\n    if field_name in bad_fields:\n        return False\n    if any([i for i in bad_prefix if field_name.startswith(i)]):\n        return False\n    return True",
            "def valid_field(pair):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    bad_fields = 'LOOK_AND_FEEL_TABLE copyright __builtins__ icon'.split(' ')\n    bad_prefix = 'TITLE_ TEXT_ ELEM_TYPE_ DEFAULT_ BUTTON_TYPE_ LISTBOX_SELECT METER_ POPUP_ THEME_'.split(' ')\n    (field_name, python_object) = pair\n    if type(python_object) is bytes:\n        return False\n    if field_name in bad_fields:\n        return False\n    if any([i for i in bad_prefix if field_name.startswith(i)]):\n        return False\n    return True",
            "def valid_field(pair):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    bad_fields = 'LOOK_AND_FEEL_TABLE copyright __builtins__ icon'.split(' ')\n    bad_prefix = 'TITLE_ TEXT_ ELEM_TYPE_ DEFAULT_ BUTTON_TYPE_ LISTBOX_SELECT METER_ POPUP_ THEME_'.split(' ')\n    (field_name, python_object) = pair\n    if type(python_object) is bytes:\n        return False\n    if field_name in bad_fields:\n        return False\n    if any([i for i in bad_prefix if field_name.startswith(i)]):\n        return False\n    return True"
        ]
    },
    {
        "func_name": "main",
        "original": "def main(do_full_readme=False, files_to_include: list=[], logger: object=None, output_name: str=None, delete_html_comments: bool=True, delete_x3_newlines: bool=True, allow_multiple_tags: bool=True, line_break: str=None, insert_md_section_for__class_methods: bool=True, remove_repeated_sections_classmethods: bool=False, output_repeated_tags: bool=False, main_md_file='markdown input files/2_readme.md', skip_dunder_method: bool=True, verbose=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    \"\"\"\n    Goal is:\n    1) load 1_.md 2_.md 3_.md 4_.md\n    2) get memes - classes and functions in PSG\n    3) find all tags in 2_\n    4) structure tags and REAL objects\n    5) replaces classes, functions.\n    6) join 1 big readme file\n\n    :param do_full_readme: (bool=True) if False - use only 2_readme.md\n    :param files_to_include: (list=[]) list of markdown files to include in output markdown\n    :param logger: (object=None) logger object from logging module\n    :param output_name: (str=None) base filename of output markdown file\n    :param delete_html_comments: (bool=True) flag for preprocessing input markwon text e.g. deleting every html tag, that is injection_point\n    :param delete_x3_newlines: (bool=True) flag for deleting '\\\\n\\\\n\\\\n' in final output makrdown text\n    :param allow_multiple_tags: (bool=True) flag for replacing every tag in \"input markdown text\"\n    :param line_break: (str=None) linebreak_character in \"return part\"\n    :param insert_md_section_for__class_methods: (bool=True) insert '###' sign to class_methods when outputing in markdown\n    :param remove_repeated_sections_classmethods: (bool=True)\n    :param output_repeated_tags: (bool=True) log REPEATED tags in file\n    :param skip_dunder_method: (bool=True) skip __something__ methods in classes\n    \"\"\"\n    if logger:\n        logger.info(f'STARTING')\n    readme = readfile(main_md_file)\n\n    def valid_field(pair):\n        bad_fields = 'LOOK_AND_FEEL_TABLE copyright __builtins__ icon'.split(' ')\n        bad_prefix = 'TITLE_ TEXT_ ELEM_TYPE_ DEFAULT_ BUTTON_TYPE_ LISTBOX_SELECT METER_ POPUP_ THEME_'.split(' ')\n        (field_name, python_object) = pair\n        if type(python_object) is bytes:\n            return False\n        if field_name in bad_fields:\n            return False\n        if any([i for i in bad_prefix if field_name.startswith(i)]):\n            return False\n        return True\n    if verbose:\n        timee(' psg_members ')\n    psg_members = [i for i in getmembers(PySimpleGUI) if valid_field(i)]\n    psg_funcs = [o for o in psg_members if isfunction(o[1])]\n    psg_classes = [o for o in psg_members if isclass(o[1])]\n    psg_classes_ = list(set([i[1] for i in psg_classes]))\n    psg_classes = list(zip([i.__name__ for i in psg_classes_], psg_classes_))\n    if verbose:\n        timee(' REMOVE HEADER ')\n    started_mark = '<!-- Start from here -->'\n    if started_mark in readme:\n        readme = readme.split('<!-- Start from here -->')[1]\n    if verbose:\n        timee(' find good tags ')\n    re_tags = re.compile('<!-- <\\\\+[a-zA-Z_]+[\\\\d\\\\w_]*\\\\.([a-zA-Z_]+[\\\\d\\\\w_]*)\\\\+> -->')\n    mark_points = [i for i in readme.split('\\n') if re_tags.match(i)]\n    special_dunder_methods = ['init', 'repr', 'str', 'next']\n    if skip_dunder_method:\n        re_bad_tags = re.compile('<!-- <\\\\+[a-zA-Z_]+[\\\\d\\\\w_]*\\\\.([_]+[\\\\d\\\\w_]*)\\\\+> -->')\n        for i in readme.split('\\n'):\n            if re_bad_tags.match(i.strip()):\n                if not [s_tag for s_tag in special_dunder_methods if s_tag in i.strip()]:\n                    readme = readme.replace(i, '\\n')\n    if verbose:\n        timee(' log repeated tags ')\n    if output_repeated_tags:\n        if not allow_multiple_tags and len(list(set(mark_points))) != len(mark_points):\n            mark_points_copy = mark_points[:]\n            [mark_points_copy.remove(x) for x in set(mark_points)]\n            if logger:\n                logger.error('You have repeated tags! \\n {0}'.format(','.join(mark_points_copy)))\n            return ''\n    injection_points = []\n    classes_method_tags = [j for j in mark_points if 'func.' not in j]\n    func_tags = [j for j in mark_points if 'func.' in j]\n    if verbose:\n        timee('# 0===0 functions 0===0')\n    for tag in func_tags:\n        try:\n            function_name = part2 = tag.split('.')[1].split('+')[0]\n            number = ''\n            if part2[0] in ['1', '2']:\n                (number, part2) = (part2[0], part2[1:])\n            founded_function = [func for (func_name, func) in psg_funcs if func_name == function_name]\n            if not founded_function:\n                if logger:\n                    logger.error(f'function \"{function_name}\" not found in PySimpleGUI')\n                continue\n            if len(founded_function) > 1:\n                if logger:\n                    logger.error(f'more than 1 function named \"{function_name}\" found in PySimpleGUI')\n                continue\n            injection_points.append({'tag': tag, 'function_object': founded_function[0], 'parent_class': None, 'part1': 'func', 'part2': part2, 'number': number})\n        except Exception as e:\n            if logger:\n                logger.error(f' General error in parsing function tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n            continue\n    if verbose:\n        timee('# 0===0 classes 0===0')\n    injection_points.append('now, classes.')\n    for tag in classes_method_tags:\n        try:\n            (class_name, method_name) = tag.split('.')\n            (class_name, method_name) = (part1, part2) = (class_name.split('+')[-1], method_name.split('+')[0])\n            number = ''\n            if part2[0] in ['1', '2']:\n                (number, method_name) = (part2[0], part2[1:])\n            founded_class = [a_class_obj for (a_class_name, a_class_obj) in psg_classes if a_class_name == class_name]\n            if not founded_class:\n                if logger:\n                    logger.error(f'skipping tag \"{tag}\", WHY: not found in PySimpleGUI')\n                continue\n            if len(founded_class) > 1:\n                if logger:\n                    logger.error(f'skipping tag \"{tag}\", WHY: found more than 1 class in PySimpleGUI')\n                continue\n            try:\n                if method_name != 'doc':\n                    founded_method = getattr(founded_class[0], method_name)\n                else:\n                    founded_method = None\n            except AttributeError as e:\n                if logger:\n                    logger.error(f'METHOD not found!: {str(e)}')\n                continue\n            except Exception as e:\n                if logger:\n                    logger.error(f' General error in parsing class_method tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n                continue\n            injection_points.append({'tag': tag, 'function_object': founded_method, 'parent_class': founded_class[0], 'part1': part1, 'part2': part2, 'number': number})\n        except Exception as e:\n            if logger:\n                logger.error(f' General error in parsing class_method tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n            continue\n    if verbose:\n        timee('bar_it = lambda x')\n    bar_it = lambda x: '\\n' + '=' * len(x) + f'\\nSTARTING TO INSERT markdown text into main_md_file\\n' + '=' * len(x) + '\\n'\n    success_tags = []\n    bad_tags = []\n    for injection in injection_points:\n        if injection == 'now, classes.':\n            logger.info(bar_it('STARTING TO INSERT markdown text into main_md_file'))\n            continue\n        if injection['part2'] == 'doc':\n            a_tag = injection['tag']\n            logger.info('a_tag = ' + a_tag.split('.')[0].split('+')[1])\n            doc_ = '' if not injection['parent_class'].__doc__ else injection['parent_class'].__doc__\n            readme = readme.replace(a_tag, doc_)\n        else:\n            if verbose:\n                timee('content = render')\n            content = render(injection, logger=logger, line_break=line_break, insert_md_section_for__class_methods=insert_md_section_for__class_methods, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n            if verbose:\n                timee('content = render end')\n            tag = injection['tag']\n            if content:\n                success_tags.append(f'{tag} - COMPLETE')\n            else:\n                bad_tags.append(f'{tag} - FAIL')\n            readme = readme.replace(tag, content)\n    if verbose:\n        timee('readme = readme.replace(bad_p')\n    bad_part = '\\n\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n\\n'\n    readme = readme.replace(bad_part, '\\n')\n    if logger:\n        success_tags_str = '\\n'.join(success_tags).strip()\n        bad_tags_str = '\\n'.join(bad_tags).strip()\n        good_message = f'DONE {len(success_tags)} TAGS:\\n' + '\\n'.join(success_tags) if success_tags_str else 'All tags are wrong//'\n        bad_message = f'FAIL WITH {len(bad_tags)} TAGS:\\n' + '\\n'.join(bad_tags) if bad_tags_str else 'No bad tags, YES!'\n        logger.info(good_message)\n        logger.info(bad_message)\n        bad_part = '\\n\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n\\n'\n        readme = readme.replace(bad_part, '\\n')\n    if verbose:\n        timee('files = []')\n    files = []\n    if 0 in files_to_include:\n        files.append(readfile('markdown input files/1_HEADER_top_part.md'))\n    if 1 in files_to_include:\n        files.append(readme)\n    if 2 in files_to_include:\n        files.append(readfile('markdown input files/3_FOOTER.md'))\n    if 3 in files_to_include:\n        files.append(readfile('markdown input files/4_Release_notes.md'))\n    Joined_MARKDOWN = '\\n\\n'.join(files) if do_full_readme or files else readme\n    if verbose:\n        timee('if output_name:')\n    if output_name:\n        with open(output_name, 'w', encoding='utf-8') as ff:\n            CURR_DT = datetime.today().strftime('<!-- CREATED: %Y-%m-%d %H.%M.%S -->\\n')\n            content = CURR_DT + Joined_MARKDOWN\n            if delete_html_comments:\n                if logger:\n                    logger.info('Deleting html comments')\n                filt_readme = re.sub('<!--([\\\\s\\\\S]*?)-->', '\\n', content, flags=re.MULTILINE)\n                for i in range(5):\n                    filt_readme = filt_readme.replace('\\n\\n\\n', '\\n\\n')\n                if '<!--stackedit_data:' in content:\n                    stackedit_text = content[content.index('<!--stackedit_data:'):]\n                    filt_readme += stackedit_text\n                content = filt_readme\n            if delete_x3_newlines:\n                content = re.sub('^[ ]+$', '', content, flags=re.MULTILINE)\n                content = re.sub('\\\\n{3,}', '\\n\\n', content, flags=re.MULTILINE)\n            if remove_repeated_sections_classmethods:\n                rega = re.compile('((\\\\#+\\\\s\\\\w+)\\\\n\\\\s){2}', flags=re.MULTILINE)\n                for (index, i) in enumerate(re.finditer(rega, content)):\n                    logger.info(f'{index} - > {i.group(0)}')\n                    logger.info(f'{index} - > {i.group(1)}')\n                    content = content.replace(i.group(0), i.group(1))\n            ff.write(content.strip())\n        if logger:\n            logger.info(f'ending. writing to a file///////////////')\n        return content\n    if logger:\n        logger.error(f'Error in main')\n    logger.save()",
        "mutated": [
            "def main(do_full_readme=False, files_to_include: list=[], logger: object=None, output_name: str=None, delete_html_comments: bool=True, delete_x3_newlines: bool=True, allow_multiple_tags: bool=True, line_break: str=None, insert_md_section_for__class_methods: bool=True, remove_repeated_sections_classmethods: bool=False, output_repeated_tags: bool=False, main_md_file='markdown input files/2_readme.md', skip_dunder_method: bool=True, verbose=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    if False:\n        i = 10\n    '\\n    Goal is:\\n    1) load 1_.md 2_.md 3_.md 4_.md\\n    2) get memes - classes and functions in PSG\\n    3) find all tags in 2_\\n    4) structure tags and REAL objects\\n    5) replaces classes, functions.\\n    6) join 1 big readme file\\n\\n    :param do_full_readme: (bool=True) if False - use only 2_readme.md\\n    :param files_to_include: (list=[]) list of markdown files to include in output markdown\\n    :param logger: (object=None) logger object from logging module\\n    :param output_name: (str=None) base filename of output markdown file\\n    :param delete_html_comments: (bool=True) flag for preprocessing input markwon text e.g. deleting every html tag, that is injection_point\\n    :param delete_x3_newlines: (bool=True) flag for deleting \\'\\\\n\\\\n\\\\n\\' in final output makrdown text\\n    :param allow_multiple_tags: (bool=True) flag for replacing every tag in \"input markdown text\"\\n    :param line_break: (str=None) linebreak_character in \"return part\"\\n    :param insert_md_section_for__class_methods: (bool=True) insert \\'###\\' sign to class_methods when outputing in markdown\\n    :param remove_repeated_sections_classmethods: (bool=True)\\n    :param output_repeated_tags: (bool=True) log REPEATED tags in file\\n    :param skip_dunder_method: (bool=True) skip __something__ methods in classes\\n    '\n    if logger:\n        logger.info(f'STARTING')\n    readme = readfile(main_md_file)\n\n    def valid_field(pair):\n        bad_fields = 'LOOK_AND_FEEL_TABLE copyright __builtins__ icon'.split(' ')\n        bad_prefix = 'TITLE_ TEXT_ ELEM_TYPE_ DEFAULT_ BUTTON_TYPE_ LISTBOX_SELECT METER_ POPUP_ THEME_'.split(' ')\n        (field_name, python_object) = pair\n        if type(python_object) is bytes:\n            return False\n        if field_name in bad_fields:\n            return False\n        if any([i for i in bad_prefix if field_name.startswith(i)]):\n            return False\n        return True\n    if verbose:\n        timee(' psg_members ')\n    psg_members = [i for i in getmembers(PySimpleGUI) if valid_field(i)]\n    psg_funcs = [o for o in psg_members if isfunction(o[1])]\n    psg_classes = [o for o in psg_members if isclass(o[1])]\n    psg_classes_ = list(set([i[1] for i in psg_classes]))\n    psg_classes = list(zip([i.__name__ for i in psg_classes_], psg_classes_))\n    if verbose:\n        timee(' REMOVE HEADER ')\n    started_mark = '<!-- Start from here -->'\n    if started_mark in readme:\n        readme = readme.split('<!-- Start from here -->')[1]\n    if verbose:\n        timee(' find good tags ')\n    re_tags = re.compile('<!-- <\\\\+[a-zA-Z_]+[\\\\d\\\\w_]*\\\\.([a-zA-Z_]+[\\\\d\\\\w_]*)\\\\+> -->')\n    mark_points = [i for i in readme.split('\\n') if re_tags.match(i)]\n    special_dunder_methods = ['init', 'repr', 'str', 'next']\n    if skip_dunder_method:\n        re_bad_tags = re.compile('<!-- <\\\\+[a-zA-Z_]+[\\\\d\\\\w_]*\\\\.([_]+[\\\\d\\\\w_]*)\\\\+> -->')\n        for i in readme.split('\\n'):\n            if re_bad_tags.match(i.strip()):\n                if not [s_tag for s_tag in special_dunder_methods if s_tag in i.strip()]:\n                    readme = readme.replace(i, '\\n')\n    if verbose:\n        timee(' log repeated tags ')\n    if output_repeated_tags:\n        if not allow_multiple_tags and len(list(set(mark_points))) != len(mark_points):\n            mark_points_copy = mark_points[:]\n            [mark_points_copy.remove(x) for x in set(mark_points)]\n            if logger:\n                logger.error('You have repeated tags! \\n {0}'.format(','.join(mark_points_copy)))\n            return ''\n    injection_points = []\n    classes_method_tags = [j for j in mark_points if 'func.' not in j]\n    func_tags = [j for j in mark_points if 'func.' in j]\n    if verbose:\n        timee('# 0===0 functions 0===0')\n    for tag in func_tags:\n        try:\n            function_name = part2 = tag.split('.')[1].split('+')[0]\n            number = ''\n            if part2[0] in ['1', '2']:\n                (number, part2) = (part2[0], part2[1:])\n            founded_function = [func for (func_name, func) in psg_funcs if func_name == function_name]\n            if not founded_function:\n                if logger:\n                    logger.error(f'function \"{function_name}\" not found in PySimpleGUI')\n                continue\n            if len(founded_function) > 1:\n                if logger:\n                    logger.error(f'more than 1 function named \"{function_name}\" found in PySimpleGUI')\n                continue\n            injection_points.append({'tag': tag, 'function_object': founded_function[0], 'parent_class': None, 'part1': 'func', 'part2': part2, 'number': number})\n        except Exception as e:\n            if logger:\n                logger.error(f' General error in parsing function tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n            continue\n    if verbose:\n        timee('# 0===0 classes 0===0')\n    injection_points.append('now, classes.')\n    for tag in classes_method_tags:\n        try:\n            (class_name, method_name) = tag.split('.')\n            (class_name, method_name) = (part1, part2) = (class_name.split('+')[-1], method_name.split('+')[0])\n            number = ''\n            if part2[0] in ['1', '2']:\n                (number, method_name) = (part2[0], part2[1:])\n            founded_class = [a_class_obj for (a_class_name, a_class_obj) in psg_classes if a_class_name == class_name]\n            if not founded_class:\n                if logger:\n                    logger.error(f'skipping tag \"{tag}\", WHY: not found in PySimpleGUI')\n                continue\n            if len(founded_class) > 1:\n                if logger:\n                    logger.error(f'skipping tag \"{tag}\", WHY: found more than 1 class in PySimpleGUI')\n                continue\n            try:\n                if method_name != 'doc':\n                    founded_method = getattr(founded_class[0], method_name)\n                else:\n                    founded_method = None\n            except AttributeError as e:\n                if logger:\n                    logger.error(f'METHOD not found!: {str(e)}')\n                continue\n            except Exception as e:\n                if logger:\n                    logger.error(f' General error in parsing class_method tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n                continue\n            injection_points.append({'tag': tag, 'function_object': founded_method, 'parent_class': founded_class[0], 'part1': part1, 'part2': part2, 'number': number})\n        except Exception as e:\n            if logger:\n                logger.error(f' General error in parsing class_method tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n            continue\n    if verbose:\n        timee('bar_it = lambda x')\n    bar_it = lambda x: '\\n' + '=' * len(x) + f'\\nSTARTING TO INSERT markdown text into main_md_file\\n' + '=' * len(x) + '\\n'\n    success_tags = []\n    bad_tags = []\n    for injection in injection_points:\n        if injection == 'now, classes.':\n            logger.info(bar_it('STARTING TO INSERT markdown text into main_md_file'))\n            continue\n        if injection['part2'] == 'doc':\n            a_tag = injection['tag']\n            logger.info('a_tag = ' + a_tag.split('.')[0].split('+')[1])\n            doc_ = '' if not injection['parent_class'].__doc__ else injection['parent_class'].__doc__\n            readme = readme.replace(a_tag, doc_)\n        else:\n            if verbose:\n                timee('content = render')\n            content = render(injection, logger=logger, line_break=line_break, insert_md_section_for__class_methods=insert_md_section_for__class_methods, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n            if verbose:\n                timee('content = render end')\n            tag = injection['tag']\n            if content:\n                success_tags.append(f'{tag} - COMPLETE')\n            else:\n                bad_tags.append(f'{tag} - FAIL')\n            readme = readme.replace(tag, content)\n    if verbose:\n        timee('readme = readme.replace(bad_p')\n    bad_part = '\\n\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n\\n'\n    readme = readme.replace(bad_part, '\\n')\n    if logger:\n        success_tags_str = '\\n'.join(success_tags).strip()\n        bad_tags_str = '\\n'.join(bad_tags).strip()\n        good_message = f'DONE {len(success_tags)} TAGS:\\n' + '\\n'.join(success_tags) if success_tags_str else 'All tags are wrong//'\n        bad_message = f'FAIL WITH {len(bad_tags)} TAGS:\\n' + '\\n'.join(bad_tags) if bad_tags_str else 'No bad tags, YES!'\n        logger.info(good_message)\n        logger.info(bad_message)\n        bad_part = '\\n\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n\\n'\n        readme = readme.replace(bad_part, '\\n')\n    if verbose:\n        timee('files = []')\n    files = []\n    if 0 in files_to_include:\n        files.append(readfile('markdown input files/1_HEADER_top_part.md'))\n    if 1 in files_to_include:\n        files.append(readme)\n    if 2 in files_to_include:\n        files.append(readfile('markdown input files/3_FOOTER.md'))\n    if 3 in files_to_include:\n        files.append(readfile('markdown input files/4_Release_notes.md'))\n    Joined_MARKDOWN = '\\n\\n'.join(files) if do_full_readme or files else readme\n    if verbose:\n        timee('if output_name:')\n    if output_name:\n        with open(output_name, 'w', encoding='utf-8') as ff:\n            CURR_DT = datetime.today().strftime('<!-- CREATED: %Y-%m-%d %H.%M.%S -->\\n')\n            content = CURR_DT + Joined_MARKDOWN\n            if delete_html_comments:\n                if logger:\n                    logger.info('Deleting html comments')\n                filt_readme = re.sub('<!--([\\\\s\\\\S]*?)-->', '\\n', content, flags=re.MULTILINE)\n                for i in range(5):\n                    filt_readme = filt_readme.replace('\\n\\n\\n', '\\n\\n')\n                if '<!--stackedit_data:' in content:\n                    stackedit_text = content[content.index('<!--stackedit_data:'):]\n                    filt_readme += stackedit_text\n                content = filt_readme\n            if delete_x3_newlines:\n                content = re.sub('^[ ]+$', '', content, flags=re.MULTILINE)\n                content = re.sub('\\\\n{3,}', '\\n\\n', content, flags=re.MULTILINE)\n            if remove_repeated_sections_classmethods:\n                rega = re.compile('((\\\\#+\\\\s\\\\w+)\\\\n\\\\s){2}', flags=re.MULTILINE)\n                for (index, i) in enumerate(re.finditer(rega, content)):\n                    logger.info(f'{index} - > {i.group(0)}')\n                    logger.info(f'{index} - > {i.group(1)}')\n                    content = content.replace(i.group(0), i.group(1))\n            ff.write(content.strip())\n        if logger:\n            logger.info(f'ending. writing to a file///////////////')\n        return content\n    if logger:\n        logger.error(f'Error in main')\n    logger.save()",
            "def main(do_full_readme=False, files_to_include: list=[], logger: object=None, output_name: str=None, delete_html_comments: bool=True, delete_x3_newlines: bool=True, allow_multiple_tags: bool=True, line_break: str=None, insert_md_section_for__class_methods: bool=True, remove_repeated_sections_classmethods: bool=False, output_repeated_tags: bool=False, main_md_file='markdown input files/2_readme.md', skip_dunder_method: bool=True, verbose=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Goal is:\\n    1) load 1_.md 2_.md 3_.md 4_.md\\n    2) get memes - classes and functions in PSG\\n    3) find all tags in 2_\\n    4) structure tags and REAL objects\\n    5) replaces classes, functions.\\n    6) join 1 big readme file\\n\\n    :param do_full_readme: (bool=True) if False - use only 2_readme.md\\n    :param files_to_include: (list=[]) list of markdown files to include in output markdown\\n    :param logger: (object=None) logger object from logging module\\n    :param output_name: (str=None) base filename of output markdown file\\n    :param delete_html_comments: (bool=True) flag for preprocessing input markwon text e.g. deleting every html tag, that is injection_point\\n    :param delete_x3_newlines: (bool=True) flag for deleting \\'\\\\n\\\\n\\\\n\\' in final output makrdown text\\n    :param allow_multiple_tags: (bool=True) flag for replacing every tag in \"input markdown text\"\\n    :param line_break: (str=None) linebreak_character in \"return part\"\\n    :param insert_md_section_for__class_methods: (bool=True) insert \\'###\\' sign to class_methods when outputing in markdown\\n    :param remove_repeated_sections_classmethods: (bool=True)\\n    :param output_repeated_tags: (bool=True) log REPEATED tags in file\\n    :param skip_dunder_method: (bool=True) skip __something__ methods in classes\\n    '\n    if logger:\n        logger.info(f'STARTING')\n    readme = readfile(main_md_file)\n\n    def valid_field(pair):\n        bad_fields = 'LOOK_AND_FEEL_TABLE copyright __builtins__ icon'.split(' ')\n        bad_prefix = 'TITLE_ TEXT_ ELEM_TYPE_ DEFAULT_ BUTTON_TYPE_ LISTBOX_SELECT METER_ POPUP_ THEME_'.split(' ')\n        (field_name, python_object) = pair\n        if type(python_object) is bytes:\n            return False\n        if field_name in bad_fields:\n            return False\n        if any([i for i in bad_prefix if field_name.startswith(i)]):\n            return False\n        return True\n    if verbose:\n        timee(' psg_members ')\n    psg_members = [i for i in getmembers(PySimpleGUI) if valid_field(i)]\n    psg_funcs = [o for o in psg_members if isfunction(o[1])]\n    psg_classes = [o for o in psg_members if isclass(o[1])]\n    psg_classes_ = list(set([i[1] for i in psg_classes]))\n    psg_classes = list(zip([i.__name__ for i in psg_classes_], psg_classes_))\n    if verbose:\n        timee(' REMOVE HEADER ')\n    started_mark = '<!-- Start from here -->'\n    if started_mark in readme:\n        readme = readme.split('<!-- Start from here -->')[1]\n    if verbose:\n        timee(' find good tags ')\n    re_tags = re.compile('<!-- <\\\\+[a-zA-Z_]+[\\\\d\\\\w_]*\\\\.([a-zA-Z_]+[\\\\d\\\\w_]*)\\\\+> -->')\n    mark_points = [i for i in readme.split('\\n') if re_tags.match(i)]\n    special_dunder_methods = ['init', 'repr', 'str', 'next']\n    if skip_dunder_method:\n        re_bad_tags = re.compile('<!-- <\\\\+[a-zA-Z_]+[\\\\d\\\\w_]*\\\\.([_]+[\\\\d\\\\w_]*)\\\\+> -->')\n        for i in readme.split('\\n'):\n            if re_bad_tags.match(i.strip()):\n                if not [s_tag for s_tag in special_dunder_methods if s_tag in i.strip()]:\n                    readme = readme.replace(i, '\\n')\n    if verbose:\n        timee(' log repeated tags ')\n    if output_repeated_tags:\n        if not allow_multiple_tags and len(list(set(mark_points))) != len(mark_points):\n            mark_points_copy = mark_points[:]\n            [mark_points_copy.remove(x) for x in set(mark_points)]\n            if logger:\n                logger.error('You have repeated tags! \\n {0}'.format(','.join(mark_points_copy)))\n            return ''\n    injection_points = []\n    classes_method_tags = [j for j in mark_points if 'func.' not in j]\n    func_tags = [j for j in mark_points if 'func.' in j]\n    if verbose:\n        timee('# 0===0 functions 0===0')\n    for tag in func_tags:\n        try:\n            function_name = part2 = tag.split('.')[1].split('+')[0]\n            number = ''\n            if part2[0] in ['1', '2']:\n                (number, part2) = (part2[0], part2[1:])\n            founded_function = [func for (func_name, func) in psg_funcs if func_name == function_name]\n            if not founded_function:\n                if logger:\n                    logger.error(f'function \"{function_name}\" not found in PySimpleGUI')\n                continue\n            if len(founded_function) > 1:\n                if logger:\n                    logger.error(f'more than 1 function named \"{function_name}\" found in PySimpleGUI')\n                continue\n            injection_points.append({'tag': tag, 'function_object': founded_function[0], 'parent_class': None, 'part1': 'func', 'part2': part2, 'number': number})\n        except Exception as e:\n            if logger:\n                logger.error(f' General error in parsing function tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n            continue\n    if verbose:\n        timee('# 0===0 classes 0===0')\n    injection_points.append('now, classes.')\n    for tag in classes_method_tags:\n        try:\n            (class_name, method_name) = tag.split('.')\n            (class_name, method_name) = (part1, part2) = (class_name.split('+')[-1], method_name.split('+')[0])\n            number = ''\n            if part2[0] in ['1', '2']:\n                (number, method_name) = (part2[0], part2[1:])\n            founded_class = [a_class_obj for (a_class_name, a_class_obj) in psg_classes if a_class_name == class_name]\n            if not founded_class:\n                if logger:\n                    logger.error(f'skipping tag \"{tag}\", WHY: not found in PySimpleGUI')\n                continue\n            if len(founded_class) > 1:\n                if logger:\n                    logger.error(f'skipping tag \"{tag}\", WHY: found more than 1 class in PySimpleGUI')\n                continue\n            try:\n                if method_name != 'doc':\n                    founded_method = getattr(founded_class[0], method_name)\n                else:\n                    founded_method = None\n            except AttributeError as e:\n                if logger:\n                    logger.error(f'METHOD not found!: {str(e)}')\n                continue\n            except Exception as e:\n                if logger:\n                    logger.error(f' General error in parsing class_method tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n                continue\n            injection_points.append({'tag': tag, 'function_object': founded_method, 'parent_class': founded_class[0], 'part1': part1, 'part2': part2, 'number': number})\n        except Exception as e:\n            if logger:\n                logger.error(f' General error in parsing class_method tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n            continue\n    if verbose:\n        timee('bar_it = lambda x')\n    bar_it = lambda x: '\\n' + '=' * len(x) + f'\\nSTARTING TO INSERT markdown text into main_md_file\\n' + '=' * len(x) + '\\n'\n    success_tags = []\n    bad_tags = []\n    for injection in injection_points:\n        if injection == 'now, classes.':\n            logger.info(bar_it('STARTING TO INSERT markdown text into main_md_file'))\n            continue\n        if injection['part2'] == 'doc':\n            a_tag = injection['tag']\n            logger.info('a_tag = ' + a_tag.split('.')[0].split('+')[1])\n            doc_ = '' if not injection['parent_class'].__doc__ else injection['parent_class'].__doc__\n            readme = readme.replace(a_tag, doc_)\n        else:\n            if verbose:\n                timee('content = render')\n            content = render(injection, logger=logger, line_break=line_break, insert_md_section_for__class_methods=insert_md_section_for__class_methods, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n            if verbose:\n                timee('content = render end')\n            tag = injection['tag']\n            if content:\n                success_tags.append(f'{tag} - COMPLETE')\n            else:\n                bad_tags.append(f'{tag} - FAIL')\n            readme = readme.replace(tag, content)\n    if verbose:\n        timee('readme = readme.replace(bad_p')\n    bad_part = '\\n\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n\\n'\n    readme = readme.replace(bad_part, '\\n')\n    if logger:\n        success_tags_str = '\\n'.join(success_tags).strip()\n        bad_tags_str = '\\n'.join(bad_tags).strip()\n        good_message = f'DONE {len(success_tags)} TAGS:\\n' + '\\n'.join(success_tags) if success_tags_str else 'All tags are wrong//'\n        bad_message = f'FAIL WITH {len(bad_tags)} TAGS:\\n' + '\\n'.join(bad_tags) if bad_tags_str else 'No bad tags, YES!'\n        logger.info(good_message)\n        logger.info(bad_message)\n        bad_part = '\\n\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n\\n'\n        readme = readme.replace(bad_part, '\\n')\n    if verbose:\n        timee('files = []')\n    files = []\n    if 0 in files_to_include:\n        files.append(readfile('markdown input files/1_HEADER_top_part.md'))\n    if 1 in files_to_include:\n        files.append(readme)\n    if 2 in files_to_include:\n        files.append(readfile('markdown input files/3_FOOTER.md'))\n    if 3 in files_to_include:\n        files.append(readfile('markdown input files/4_Release_notes.md'))\n    Joined_MARKDOWN = '\\n\\n'.join(files) if do_full_readme or files else readme\n    if verbose:\n        timee('if output_name:')\n    if output_name:\n        with open(output_name, 'w', encoding='utf-8') as ff:\n            CURR_DT = datetime.today().strftime('<!-- CREATED: %Y-%m-%d %H.%M.%S -->\\n')\n            content = CURR_DT + Joined_MARKDOWN\n            if delete_html_comments:\n                if logger:\n                    logger.info('Deleting html comments')\n                filt_readme = re.sub('<!--([\\\\s\\\\S]*?)-->', '\\n', content, flags=re.MULTILINE)\n                for i in range(5):\n                    filt_readme = filt_readme.replace('\\n\\n\\n', '\\n\\n')\n                if '<!--stackedit_data:' in content:\n                    stackedit_text = content[content.index('<!--stackedit_data:'):]\n                    filt_readme += stackedit_text\n                content = filt_readme\n            if delete_x3_newlines:\n                content = re.sub('^[ ]+$', '', content, flags=re.MULTILINE)\n                content = re.sub('\\\\n{3,}', '\\n\\n', content, flags=re.MULTILINE)\n            if remove_repeated_sections_classmethods:\n                rega = re.compile('((\\\\#+\\\\s\\\\w+)\\\\n\\\\s){2}', flags=re.MULTILINE)\n                for (index, i) in enumerate(re.finditer(rega, content)):\n                    logger.info(f'{index} - > {i.group(0)}')\n                    logger.info(f'{index} - > {i.group(1)}')\n                    content = content.replace(i.group(0), i.group(1))\n            ff.write(content.strip())\n        if logger:\n            logger.info(f'ending. writing to a file///////////////')\n        return content\n    if logger:\n        logger.error(f'Error in main')\n    logger.save()",
            "def main(do_full_readme=False, files_to_include: list=[], logger: object=None, output_name: str=None, delete_html_comments: bool=True, delete_x3_newlines: bool=True, allow_multiple_tags: bool=True, line_break: str=None, insert_md_section_for__class_methods: bool=True, remove_repeated_sections_classmethods: bool=False, output_repeated_tags: bool=False, main_md_file='markdown input files/2_readme.md', skip_dunder_method: bool=True, verbose=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Goal is:\\n    1) load 1_.md 2_.md 3_.md 4_.md\\n    2) get memes - classes and functions in PSG\\n    3) find all tags in 2_\\n    4) structure tags and REAL objects\\n    5) replaces classes, functions.\\n    6) join 1 big readme file\\n\\n    :param do_full_readme: (bool=True) if False - use only 2_readme.md\\n    :param files_to_include: (list=[]) list of markdown files to include in output markdown\\n    :param logger: (object=None) logger object from logging module\\n    :param output_name: (str=None) base filename of output markdown file\\n    :param delete_html_comments: (bool=True) flag for preprocessing input markwon text e.g. deleting every html tag, that is injection_point\\n    :param delete_x3_newlines: (bool=True) flag for deleting \\'\\\\n\\\\n\\\\n\\' in final output makrdown text\\n    :param allow_multiple_tags: (bool=True) flag for replacing every tag in \"input markdown text\"\\n    :param line_break: (str=None) linebreak_character in \"return part\"\\n    :param insert_md_section_for__class_methods: (bool=True) insert \\'###\\' sign to class_methods when outputing in markdown\\n    :param remove_repeated_sections_classmethods: (bool=True)\\n    :param output_repeated_tags: (bool=True) log REPEATED tags in file\\n    :param skip_dunder_method: (bool=True) skip __something__ methods in classes\\n    '\n    if logger:\n        logger.info(f'STARTING')\n    readme = readfile(main_md_file)\n\n    def valid_field(pair):\n        bad_fields = 'LOOK_AND_FEEL_TABLE copyright __builtins__ icon'.split(' ')\n        bad_prefix = 'TITLE_ TEXT_ ELEM_TYPE_ DEFAULT_ BUTTON_TYPE_ LISTBOX_SELECT METER_ POPUP_ THEME_'.split(' ')\n        (field_name, python_object) = pair\n        if type(python_object) is bytes:\n            return False\n        if field_name in bad_fields:\n            return False\n        if any([i for i in bad_prefix if field_name.startswith(i)]):\n            return False\n        return True\n    if verbose:\n        timee(' psg_members ')\n    psg_members = [i for i in getmembers(PySimpleGUI) if valid_field(i)]\n    psg_funcs = [o for o in psg_members if isfunction(o[1])]\n    psg_classes = [o for o in psg_members if isclass(o[1])]\n    psg_classes_ = list(set([i[1] for i in psg_classes]))\n    psg_classes = list(zip([i.__name__ for i in psg_classes_], psg_classes_))\n    if verbose:\n        timee(' REMOVE HEADER ')\n    started_mark = '<!-- Start from here -->'\n    if started_mark in readme:\n        readme = readme.split('<!-- Start from here -->')[1]\n    if verbose:\n        timee(' find good tags ')\n    re_tags = re.compile('<!-- <\\\\+[a-zA-Z_]+[\\\\d\\\\w_]*\\\\.([a-zA-Z_]+[\\\\d\\\\w_]*)\\\\+> -->')\n    mark_points = [i for i in readme.split('\\n') if re_tags.match(i)]\n    special_dunder_methods = ['init', 'repr', 'str', 'next']\n    if skip_dunder_method:\n        re_bad_tags = re.compile('<!-- <\\\\+[a-zA-Z_]+[\\\\d\\\\w_]*\\\\.([_]+[\\\\d\\\\w_]*)\\\\+> -->')\n        for i in readme.split('\\n'):\n            if re_bad_tags.match(i.strip()):\n                if not [s_tag for s_tag in special_dunder_methods if s_tag in i.strip()]:\n                    readme = readme.replace(i, '\\n')\n    if verbose:\n        timee(' log repeated tags ')\n    if output_repeated_tags:\n        if not allow_multiple_tags and len(list(set(mark_points))) != len(mark_points):\n            mark_points_copy = mark_points[:]\n            [mark_points_copy.remove(x) for x in set(mark_points)]\n            if logger:\n                logger.error('You have repeated tags! \\n {0}'.format(','.join(mark_points_copy)))\n            return ''\n    injection_points = []\n    classes_method_tags = [j for j in mark_points if 'func.' not in j]\n    func_tags = [j for j in mark_points if 'func.' in j]\n    if verbose:\n        timee('# 0===0 functions 0===0')\n    for tag in func_tags:\n        try:\n            function_name = part2 = tag.split('.')[1].split('+')[0]\n            number = ''\n            if part2[0] in ['1', '2']:\n                (number, part2) = (part2[0], part2[1:])\n            founded_function = [func for (func_name, func) in psg_funcs if func_name == function_name]\n            if not founded_function:\n                if logger:\n                    logger.error(f'function \"{function_name}\" not found in PySimpleGUI')\n                continue\n            if len(founded_function) > 1:\n                if logger:\n                    logger.error(f'more than 1 function named \"{function_name}\" found in PySimpleGUI')\n                continue\n            injection_points.append({'tag': tag, 'function_object': founded_function[0], 'parent_class': None, 'part1': 'func', 'part2': part2, 'number': number})\n        except Exception as e:\n            if logger:\n                logger.error(f' General error in parsing function tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n            continue\n    if verbose:\n        timee('# 0===0 classes 0===0')\n    injection_points.append('now, classes.')\n    for tag in classes_method_tags:\n        try:\n            (class_name, method_name) = tag.split('.')\n            (class_name, method_name) = (part1, part2) = (class_name.split('+')[-1], method_name.split('+')[0])\n            number = ''\n            if part2[0] in ['1', '2']:\n                (number, method_name) = (part2[0], part2[1:])\n            founded_class = [a_class_obj for (a_class_name, a_class_obj) in psg_classes if a_class_name == class_name]\n            if not founded_class:\n                if logger:\n                    logger.error(f'skipping tag \"{tag}\", WHY: not found in PySimpleGUI')\n                continue\n            if len(founded_class) > 1:\n                if logger:\n                    logger.error(f'skipping tag \"{tag}\", WHY: found more than 1 class in PySimpleGUI')\n                continue\n            try:\n                if method_name != 'doc':\n                    founded_method = getattr(founded_class[0], method_name)\n                else:\n                    founded_method = None\n            except AttributeError as e:\n                if logger:\n                    logger.error(f'METHOD not found!: {str(e)}')\n                continue\n            except Exception as e:\n                if logger:\n                    logger.error(f' General error in parsing class_method tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n                continue\n            injection_points.append({'tag': tag, 'function_object': founded_method, 'parent_class': founded_class[0], 'part1': part1, 'part2': part2, 'number': number})\n        except Exception as e:\n            if logger:\n                logger.error(f' General error in parsing class_method tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n            continue\n    if verbose:\n        timee('bar_it = lambda x')\n    bar_it = lambda x: '\\n' + '=' * len(x) + f'\\nSTARTING TO INSERT markdown text into main_md_file\\n' + '=' * len(x) + '\\n'\n    success_tags = []\n    bad_tags = []\n    for injection in injection_points:\n        if injection == 'now, classes.':\n            logger.info(bar_it('STARTING TO INSERT markdown text into main_md_file'))\n            continue\n        if injection['part2'] == 'doc':\n            a_tag = injection['tag']\n            logger.info('a_tag = ' + a_tag.split('.')[0].split('+')[1])\n            doc_ = '' if not injection['parent_class'].__doc__ else injection['parent_class'].__doc__\n            readme = readme.replace(a_tag, doc_)\n        else:\n            if verbose:\n                timee('content = render')\n            content = render(injection, logger=logger, line_break=line_break, insert_md_section_for__class_methods=insert_md_section_for__class_methods, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n            if verbose:\n                timee('content = render end')\n            tag = injection['tag']\n            if content:\n                success_tags.append(f'{tag} - COMPLETE')\n            else:\n                bad_tags.append(f'{tag} - FAIL')\n            readme = readme.replace(tag, content)\n    if verbose:\n        timee('readme = readme.replace(bad_p')\n    bad_part = '\\n\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n\\n'\n    readme = readme.replace(bad_part, '\\n')\n    if logger:\n        success_tags_str = '\\n'.join(success_tags).strip()\n        bad_tags_str = '\\n'.join(bad_tags).strip()\n        good_message = f'DONE {len(success_tags)} TAGS:\\n' + '\\n'.join(success_tags) if success_tags_str else 'All tags are wrong//'\n        bad_message = f'FAIL WITH {len(bad_tags)} TAGS:\\n' + '\\n'.join(bad_tags) if bad_tags_str else 'No bad tags, YES!'\n        logger.info(good_message)\n        logger.info(bad_message)\n        bad_part = '\\n\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n\\n'\n        readme = readme.replace(bad_part, '\\n')\n    if verbose:\n        timee('files = []')\n    files = []\n    if 0 in files_to_include:\n        files.append(readfile('markdown input files/1_HEADER_top_part.md'))\n    if 1 in files_to_include:\n        files.append(readme)\n    if 2 in files_to_include:\n        files.append(readfile('markdown input files/3_FOOTER.md'))\n    if 3 in files_to_include:\n        files.append(readfile('markdown input files/4_Release_notes.md'))\n    Joined_MARKDOWN = '\\n\\n'.join(files) if do_full_readme or files else readme\n    if verbose:\n        timee('if output_name:')\n    if output_name:\n        with open(output_name, 'w', encoding='utf-8') as ff:\n            CURR_DT = datetime.today().strftime('<!-- CREATED: %Y-%m-%d %H.%M.%S -->\\n')\n            content = CURR_DT + Joined_MARKDOWN\n            if delete_html_comments:\n                if logger:\n                    logger.info('Deleting html comments')\n                filt_readme = re.sub('<!--([\\\\s\\\\S]*?)-->', '\\n', content, flags=re.MULTILINE)\n                for i in range(5):\n                    filt_readme = filt_readme.replace('\\n\\n\\n', '\\n\\n')\n                if '<!--stackedit_data:' in content:\n                    stackedit_text = content[content.index('<!--stackedit_data:'):]\n                    filt_readme += stackedit_text\n                content = filt_readme\n            if delete_x3_newlines:\n                content = re.sub('^[ ]+$', '', content, flags=re.MULTILINE)\n                content = re.sub('\\\\n{3,}', '\\n\\n', content, flags=re.MULTILINE)\n            if remove_repeated_sections_classmethods:\n                rega = re.compile('((\\\\#+\\\\s\\\\w+)\\\\n\\\\s){2}', flags=re.MULTILINE)\n                for (index, i) in enumerate(re.finditer(rega, content)):\n                    logger.info(f'{index} - > {i.group(0)}')\n                    logger.info(f'{index} - > {i.group(1)}')\n                    content = content.replace(i.group(0), i.group(1))\n            ff.write(content.strip())\n        if logger:\n            logger.info(f'ending. writing to a file///////////////')\n        return content\n    if logger:\n        logger.error(f'Error in main')\n    logger.save()",
            "def main(do_full_readme=False, files_to_include: list=[], logger: object=None, output_name: str=None, delete_html_comments: bool=True, delete_x3_newlines: bool=True, allow_multiple_tags: bool=True, line_break: str=None, insert_md_section_for__class_methods: bool=True, remove_repeated_sections_classmethods: bool=False, output_repeated_tags: bool=False, main_md_file='markdown input files/2_readme.md', skip_dunder_method: bool=True, verbose=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Goal is:\\n    1) load 1_.md 2_.md 3_.md 4_.md\\n    2) get memes - classes and functions in PSG\\n    3) find all tags in 2_\\n    4) structure tags and REAL objects\\n    5) replaces classes, functions.\\n    6) join 1 big readme file\\n\\n    :param do_full_readme: (bool=True) if False - use only 2_readme.md\\n    :param files_to_include: (list=[]) list of markdown files to include in output markdown\\n    :param logger: (object=None) logger object from logging module\\n    :param output_name: (str=None) base filename of output markdown file\\n    :param delete_html_comments: (bool=True) flag for preprocessing input markwon text e.g. deleting every html tag, that is injection_point\\n    :param delete_x3_newlines: (bool=True) flag for deleting \\'\\\\n\\\\n\\\\n\\' in final output makrdown text\\n    :param allow_multiple_tags: (bool=True) flag for replacing every tag in \"input markdown text\"\\n    :param line_break: (str=None) linebreak_character in \"return part\"\\n    :param insert_md_section_for__class_methods: (bool=True) insert \\'###\\' sign to class_methods when outputing in markdown\\n    :param remove_repeated_sections_classmethods: (bool=True)\\n    :param output_repeated_tags: (bool=True) log REPEATED tags in file\\n    :param skip_dunder_method: (bool=True) skip __something__ methods in classes\\n    '\n    if logger:\n        logger.info(f'STARTING')\n    readme = readfile(main_md_file)\n\n    def valid_field(pair):\n        bad_fields = 'LOOK_AND_FEEL_TABLE copyright __builtins__ icon'.split(' ')\n        bad_prefix = 'TITLE_ TEXT_ ELEM_TYPE_ DEFAULT_ BUTTON_TYPE_ LISTBOX_SELECT METER_ POPUP_ THEME_'.split(' ')\n        (field_name, python_object) = pair\n        if type(python_object) is bytes:\n            return False\n        if field_name in bad_fields:\n            return False\n        if any([i for i in bad_prefix if field_name.startswith(i)]):\n            return False\n        return True\n    if verbose:\n        timee(' psg_members ')\n    psg_members = [i for i in getmembers(PySimpleGUI) if valid_field(i)]\n    psg_funcs = [o for o in psg_members if isfunction(o[1])]\n    psg_classes = [o for o in psg_members if isclass(o[1])]\n    psg_classes_ = list(set([i[1] for i in psg_classes]))\n    psg_classes = list(zip([i.__name__ for i in psg_classes_], psg_classes_))\n    if verbose:\n        timee(' REMOVE HEADER ')\n    started_mark = '<!-- Start from here -->'\n    if started_mark in readme:\n        readme = readme.split('<!-- Start from here -->')[1]\n    if verbose:\n        timee(' find good tags ')\n    re_tags = re.compile('<!-- <\\\\+[a-zA-Z_]+[\\\\d\\\\w_]*\\\\.([a-zA-Z_]+[\\\\d\\\\w_]*)\\\\+> -->')\n    mark_points = [i for i in readme.split('\\n') if re_tags.match(i)]\n    special_dunder_methods = ['init', 'repr', 'str', 'next']\n    if skip_dunder_method:\n        re_bad_tags = re.compile('<!-- <\\\\+[a-zA-Z_]+[\\\\d\\\\w_]*\\\\.([_]+[\\\\d\\\\w_]*)\\\\+> -->')\n        for i in readme.split('\\n'):\n            if re_bad_tags.match(i.strip()):\n                if not [s_tag for s_tag in special_dunder_methods if s_tag in i.strip()]:\n                    readme = readme.replace(i, '\\n')\n    if verbose:\n        timee(' log repeated tags ')\n    if output_repeated_tags:\n        if not allow_multiple_tags and len(list(set(mark_points))) != len(mark_points):\n            mark_points_copy = mark_points[:]\n            [mark_points_copy.remove(x) for x in set(mark_points)]\n            if logger:\n                logger.error('You have repeated tags! \\n {0}'.format(','.join(mark_points_copy)))\n            return ''\n    injection_points = []\n    classes_method_tags = [j for j in mark_points if 'func.' not in j]\n    func_tags = [j for j in mark_points if 'func.' in j]\n    if verbose:\n        timee('# 0===0 functions 0===0')\n    for tag in func_tags:\n        try:\n            function_name = part2 = tag.split('.')[1].split('+')[0]\n            number = ''\n            if part2[0] in ['1', '2']:\n                (number, part2) = (part2[0], part2[1:])\n            founded_function = [func for (func_name, func) in psg_funcs if func_name == function_name]\n            if not founded_function:\n                if logger:\n                    logger.error(f'function \"{function_name}\" not found in PySimpleGUI')\n                continue\n            if len(founded_function) > 1:\n                if logger:\n                    logger.error(f'more than 1 function named \"{function_name}\" found in PySimpleGUI')\n                continue\n            injection_points.append({'tag': tag, 'function_object': founded_function[0], 'parent_class': None, 'part1': 'func', 'part2': part2, 'number': number})\n        except Exception as e:\n            if logger:\n                logger.error(f' General error in parsing function tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n            continue\n    if verbose:\n        timee('# 0===0 classes 0===0')\n    injection_points.append('now, classes.')\n    for tag in classes_method_tags:\n        try:\n            (class_name, method_name) = tag.split('.')\n            (class_name, method_name) = (part1, part2) = (class_name.split('+')[-1], method_name.split('+')[0])\n            number = ''\n            if part2[0] in ['1', '2']:\n                (number, method_name) = (part2[0], part2[1:])\n            founded_class = [a_class_obj for (a_class_name, a_class_obj) in psg_classes if a_class_name == class_name]\n            if not founded_class:\n                if logger:\n                    logger.error(f'skipping tag \"{tag}\", WHY: not found in PySimpleGUI')\n                continue\n            if len(founded_class) > 1:\n                if logger:\n                    logger.error(f'skipping tag \"{tag}\", WHY: found more than 1 class in PySimpleGUI')\n                continue\n            try:\n                if method_name != 'doc':\n                    founded_method = getattr(founded_class[0], method_name)\n                else:\n                    founded_method = None\n            except AttributeError as e:\n                if logger:\n                    logger.error(f'METHOD not found!: {str(e)}')\n                continue\n            except Exception as e:\n                if logger:\n                    logger.error(f' General error in parsing class_method tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n                continue\n            injection_points.append({'tag': tag, 'function_object': founded_method, 'parent_class': founded_class[0], 'part1': part1, 'part2': part2, 'number': number})\n        except Exception as e:\n            if logger:\n                logger.error(f' General error in parsing class_method tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n            continue\n    if verbose:\n        timee('bar_it = lambda x')\n    bar_it = lambda x: '\\n' + '=' * len(x) + f'\\nSTARTING TO INSERT markdown text into main_md_file\\n' + '=' * len(x) + '\\n'\n    success_tags = []\n    bad_tags = []\n    for injection in injection_points:\n        if injection == 'now, classes.':\n            logger.info(bar_it('STARTING TO INSERT markdown text into main_md_file'))\n            continue\n        if injection['part2'] == 'doc':\n            a_tag = injection['tag']\n            logger.info('a_tag = ' + a_tag.split('.')[0].split('+')[1])\n            doc_ = '' if not injection['parent_class'].__doc__ else injection['parent_class'].__doc__\n            readme = readme.replace(a_tag, doc_)\n        else:\n            if verbose:\n                timee('content = render')\n            content = render(injection, logger=logger, line_break=line_break, insert_md_section_for__class_methods=insert_md_section_for__class_methods, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n            if verbose:\n                timee('content = render end')\n            tag = injection['tag']\n            if content:\n                success_tags.append(f'{tag} - COMPLETE')\n            else:\n                bad_tags.append(f'{tag} - FAIL')\n            readme = readme.replace(tag, content)\n    if verbose:\n        timee('readme = readme.replace(bad_p')\n    bad_part = '\\n\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n\\n'\n    readme = readme.replace(bad_part, '\\n')\n    if logger:\n        success_tags_str = '\\n'.join(success_tags).strip()\n        bad_tags_str = '\\n'.join(bad_tags).strip()\n        good_message = f'DONE {len(success_tags)} TAGS:\\n' + '\\n'.join(success_tags) if success_tags_str else 'All tags are wrong//'\n        bad_message = f'FAIL WITH {len(bad_tags)} TAGS:\\n' + '\\n'.join(bad_tags) if bad_tags_str else 'No bad tags, YES!'\n        logger.info(good_message)\n        logger.info(bad_message)\n        bad_part = '\\n\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n\\n'\n        readme = readme.replace(bad_part, '\\n')\n    if verbose:\n        timee('files = []')\n    files = []\n    if 0 in files_to_include:\n        files.append(readfile('markdown input files/1_HEADER_top_part.md'))\n    if 1 in files_to_include:\n        files.append(readme)\n    if 2 in files_to_include:\n        files.append(readfile('markdown input files/3_FOOTER.md'))\n    if 3 in files_to_include:\n        files.append(readfile('markdown input files/4_Release_notes.md'))\n    Joined_MARKDOWN = '\\n\\n'.join(files) if do_full_readme or files else readme\n    if verbose:\n        timee('if output_name:')\n    if output_name:\n        with open(output_name, 'w', encoding='utf-8') as ff:\n            CURR_DT = datetime.today().strftime('<!-- CREATED: %Y-%m-%d %H.%M.%S -->\\n')\n            content = CURR_DT + Joined_MARKDOWN\n            if delete_html_comments:\n                if logger:\n                    logger.info('Deleting html comments')\n                filt_readme = re.sub('<!--([\\\\s\\\\S]*?)-->', '\\n', content, flags=re.MULTILINE)\n                for i in range(5):\n                    filt_readme = filt_readme.replace('\\n\\n\\n', '\\n\\n')\n                if '<!--stackedit_data:' in content:\n                    stackedit_text = content[content.index('<!--stackedit_data:'):]\n                    filt_readme += stackedit_text\n                content = filt_readme\n            if delete_x3_newlines:\n                content = re.sub('^[ ]+$', '', content, flags=re.MULTILINE)\n                content = re.sub('\\\\n{3,}', '\\n\\n', content, flags=re.MULTILINE)\n            if remove_repeated_sections_classmethods:\n                rega = re.compile('((\\\\#+\\\\s\\\\w+)\\\\n\\\\s){2}', flags=re.MULTILINE)\n                for (index, i) in enumerate(re.finditer(rega, content)):\n                    logger.info(f'{index} - > {i.group(0)}')\n                    logger.info(f'{index} - > {i.group(1)}')\n                    content = content.replace(i.group(0), i.group(1))\n            ff.write(content.strip())\n        if logger:\n            logger.info(f'ending. writing to a file///////////////')\n        return content\n    if logger:\n        logger.error(f'Error in main')\n    logger.save()",
            "def main(do_full_readme=False, files_to_include: list=[], logger: object=None, output_name: str=None, delete_html_comments: bool=True, delete_x3_newlines: bool=True, allow_multiple_tags: bool=True, line_break: str=None, insert_md_section_for__class_methods: bool=True, remove_repeated_sections_classmethods: bool=False, output_repeated_tags: bool=False, main_md_file='markdown input files/2_readme.md', skip_dunder_method: bool=True, verbose=False, replace_pipe_bar_in_TYPE_TEXT_char=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Goal is:\\n    1) load 1_.md 2_.md 3_.md 4_.md\\n    2) get memes - classes and functions in PSG\\n    3) find all tags in 2_\\n    4) structure tags and REAL objects\\n    5) replaces classes, functions.\\n    6) join 1 big readme file\\n\\n    :param do_full_readme: (bool=True) if False - use only 2_readme.md\\n    :param files_to_include: (list=[]) list of markdown files to include in output markdown\\n    :param logger: (object=None) logger object from logging module\\n    :param output_name: (str=None) base filename of output markdown file\\n    :param delete_html_comments: (bool=True) flag for preprocessing input markwon text e.g. deleting every html tag, that is injection_point\\n    :param delete_x3_newlines: (bool=True) flag for deleting \\'\\\\n\\\\n\\\\n\\' in final output makrdown text\\n    :param allow_multiple_tags: (bool=True) flag for replacing every tag in \"input markdown text\"\\n    :param line_break: (str=None) linebreak_character in \"return part\"\\n    :param insert_md_section_for__class_methods: (bool=True) insert \\'###\\' sign to class_methods when outputing in markdown\\n    :param remove_repeated_sections_classmethods: (bool=True)\\n    :param output_repeated_tags: (bool=True) log REPEATED tags in file\\n    :param skip_dunder_method: (bool=True) skip __something__ methods in classes\\n    '\n    if logger:\n        logger.info(f'STARTING')\n    readme = readfile(main_md_file)\n\n    def valid_field(pair):\n        bad_fields = 'LOOK_AND_FEEL_TABLE copyright __builtins__ icon'.split(' ')\n        bad_prefix = 'TITLE_ TEXT_ ELEM_TYPE_ DEFAULT_ BUTTON_TYPE_ LISTBOX_SELECT METER_ POPUP_ THEME_'.split(' ')\n        (field_name, python_object) = pair\n        if type(python_object) is bytes:\n            return False\n        if field_name in bad_fields:\n            return False\n        if any([i for i in bad_prefix if field_name.startswith(i)]):\n            return False\n        return True\n    if verbose:\n        timee(' psg_members ')\n    psg_members = [i for i in getmembers(PySimpleGUI) if valid_field(i)]\n    psg_funcs = [o for o in psg_members if isfunction(o[1])]\n    psg_classes = [o for o in psg_members if isclass(o[1])]\n    psg_classes_ = list(set([i[1] for i in psg_classes]))\n    psg_classes = list(zip([i.__name__ for i in psg_classes_], psg_classes_))\n    if verbose:\n        timee(' REMOVE HEADER ')\n    started_mark = '<!-- Start from here -->'\n    if started_mark in readme:\n        readme = readme.split('<!-- Start from here -->')[1]\n    if verbose:\n        timee(' find good tags ')\n    re_tags = re.compile('<!-- <\\\\+[a-zA-Z_]+[\\\\d\\\\w_]*\\\\.([a-zA-Z_]+[\\\\d\\\\w_]*)\\\\+> -->')\n    mark_points = [i for i in readme.split('\\n') if re_tags.match(i)]\n    special_dunder_methods = ['init', 'repr', 'str', 'next']\n    if skip_dunder_method:\n        re_bad_tags = re.compile('<!-- <\\\\+[a-zA-Z_]+[\\\\d\\\\w_]*\\\\.([_]+[\\\\d\\\\w_]*)\\\\+> -->')\n        for i in readme.split('\\n'):\n            if re_bad_tags.match(i.strip()):\n                if not [s_tag for s_tag in special_dunder_methods if s_tag in i.strip()]:\n                    readme = readme.replace(i, '\\n')\n    if verbose:\n        timee(' log repeated tags ')\n    if output_repeated_tags:\n        if not allow_multiple_tags and len(list(set(mark_points))) != len(mark_points):\n            mark_points_copy = mark_points[:]\n            [mark_points_copy.remove(x) for x in set(mark_points)]\n            if logger:\n                logger.error('You have repeated tags! \\n {0}'.format(','.join(mark_points_copy)))\n            return ''\n    injection_points = []\n    classes_method_tags = [j for j in mark_points if 'func.' not in j]\n    func_tags = [j for j in mark_points if 'func.' in j]\n    if verbose:\n        timee('# 0===0 functions 0===0')\n    for tag in func_tags:\n        try:\n            function_name = part2 = tag.split('.')[1].split('+')[0]\n            number = ''\n            if part2[0] in ['1', '2']:\n                (number, part2) = (part2[0], part2[1:])\n            founded_function = [func for (func_name, func) in psg_funcs if func_name == function_name]\n            if not founded_function:\n                if logger:\n                    logger.error(f'function \"{function_name}\" not found in PySimpleGUI')\n                continue\n            if len(founded_function) > 1:\n                if logger:\n                    logger.error(f'more than 1 function named \"{function_name}\" found in PySimpleGUI')\n                continue\n            injection_points.append({'tag': tag, 'function_object': founded_function[0], 'parent_class': None, 'part1': 'func', 'part2': part2, 'number': number})\n        except Exception as e:\n            if logger:\n                logger.error(f' General error in parsing function tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n            continue\n    if verbose:\n        timee('# 0===0 classes 0===0')\n    injection_points.append('now, classes.')\n    for tag in classes_method_tags:\n        try:\n            (class_name, method_name) = tag.split('.')\n            (class_name, method_name) = (part1, part2) = (class_name.split('+')[-1], method_name.split('+')[0])\n            number = ''\n            if part2[0] in ['1', '2']:\n                (number, method_name) = (part2[0], part2[1:])\n            founded_class = [a_class_obj for (a_class_name, a_class_obj) in psg_classes if a_class_name == class_name]\n            if not founded_class:\n                if logger:\n                    logger.error(f'skipping tag \"{tag}\", WHY: not found in PySimpleGUI')\n                continue\n            if len(founded_class) > 1:\n                if logger:\n                    logger.error(f'skipping tag \"{tag}\", WHY: found more than 1 class in PySimpleGUI')\n                continue\n            try:\n                if method_name != 'doc':\n                    founded_method = getattr(founded_class[0], method_name)\n                else:\n                    founded_method = None\n            except AttributeError as e:\n                if logger:\n                    logger.error(f'METHOD not found!: {str(e)}')\n                continue\n            except Exception as e:\n                if logger:\n                    logger.error(f' General error in parsing class_method tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n                continue\n            injection_points.append({'tag': tag, 'function_object': founded_method, 'parent_class': founded_class[0], 'part1': part1, 'part2': part2, 'number': number})\n        except Exception as e:\n            if logger:\n                logger.error(f' General error in parsing class_method tag: tag = \"{tag}\"; error=\"{str(e)}\"')\n            continue\n    if verbose:\n        timee('bar_it = lambda x')\n    bar_it = lambda x: '\\n' + '=' * len(x) + f'\\nSTARTING TO INSERT markdown text into main_md_file\\n' + '=' * len(x) + '\\n'\n    success_tags = []\n    bad_tags = []\n    for injection in injection_points:\n        if injection == 'now, classes.':\n            logger.info(bar_it('STARTING TO INSERT markdown text into main_md_file'))\n            continue\n        if injection['part2'] == 'doc':\n            a_tag = injection['tag']\n            logger.info('a_tag = ' + a_tag.split('.')[0].split('+')[1])\n            doc_ = '' if not injection['parent_class'].__doc__ else injection['parent_class'].__doc__\n            readme = readme.replace(a_tag, doc_)\n        else:\n            if verbose:\n                timee('content = render')\n            content = render(injection, logger=logger, line_break=line_break, insert_md_section_for__class_methods=insert_md_section_for__class_methods, replace_pipe_bar_in_TYPE_TEXT_char=replace_pipe_bar_in_TYPE_TEXT_char)\n            if verbose:\n                timee('content = render end')\n            tag = injection['tag']\n            if content:\n                success_tags.append(f'{tag} - COMPLETE')\n            else:\n                bad_tags.append(f'{tag} - FAIL')\n            readme = readme.replace(tag, content)\n    if verbose:\n        timee('readme = readme.replace(bad_p')\n    bad_part = '\\n\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n\\n'\n    readme = readme.replace(bad_part, '\\n')\n    if logger:\n        success_tags_str = '\\n'.join(success_tags).strip()\n        bad_tags_str = '\\n'.join(bad_tags).strip()\n        good_message = f'DONE {len(success_tags)} TAGS:\\n' + '\\n'.join(success_tags) if success_tags_str else 'All tags are wrong//'\n        bad_message = f'FAIL WITH {len(bad_tags)} TAGS:\\n' + '\\n'.join(bad_tags) if bad_tags_str else 'No bad tags, YES!'\n        logger.info(good_message)\n        logger.info(bad_message)\n        bad_part = '\\n\\nParameter Descriptions:\\n\\n|Type|Name|Meaning|\\n|--|--|--|\\n\\n'\n        readme = readme.replace(bad_part, '\\n')\n    if verbose:\n        timee('files = []')\n    files = []\n    if 0 in files_to_include:\n        files.append(readfile('markdown input files/1_HEADER_top_part.md'))\n    if 1 in files_to_include:\n        files.append(readme)\n    if 2 in files_to_include:\n        files.append(readfile('markdown input files/3_FOOTER.md'))\n    if 3 in files_to_include:\n        files.append(readfile('markdown input files/4_Release_notes.md'))\n    Joined_MARKDOWN = '\\n\\n'.join(files) if do_full_readme or files else readme\n    if verbose:\n        timee('if output_name:')\n    if output_name:\n        with open(output_name, 'w', encoding='utf-8') as ff:\n            CURR_DT = datetime.today().strftime('<!-- CREATED: %Y-%m-%d %H.%M.%S -->\\n')\n            content = CURR_DT + Joined_MARKDOWN\n            if delete_html_comments:\n                if logger:\n                    logger.info('Deleting html comments')\n                filt_readme = re.sub('<!--([\\\\s\\\\S]*?)-->', '\\n', content, flags=re.MULTILINE)\n                for i in range(5):\n                    filt_readme = filt_readme.replace('\\n\\n\\n', '\\n\\n')\n                if '<!--stackedit_data:' in content:\n                    stackedit_text = content[content.index('<!--stackedit_data:'):]\n                    filt_readme += stackedit_text\n                content = filt_readme\n            if delete_x3_newlines:\n                content = re.sub('^[ ]+$', '', content, flags=re.MULTILINE)\n                content = re.sub('\\\\n{3,}', '\\n\\n', content, flags=re.MULTILINE)\n            if remove_repeated_sections_classmethods:\n                rega = re.compile('((\\\\#+\\\\s\\\\w+)\\\\n\\\\s){2}', flags=re.MULTILINE)\n                for (index, i) in enumerate(re.finditer(rega, content)):\n                    logger.info(f'{index} - > {i.group(0)}')\n                    logger.info(f'{index} - > {i.group(1)}')\n                    content = content.replace(i.group(0), i.group(1))\n            ff.write(content.strip())\n        if logger:\n            logger.info(f'ending. writing to a file///////////////')\n        return content\n    if logger:\n        logger.error(f'Error in main')\n    logger.save()"
        ]
    },
    {
        "func_name": "cli",
        "original": "@click.command()\n@click.option('-nol', '--no_log', is_flag=True, help='Disable log')\n@click.option('-rml', '--delete_log', is_flag=True, help='Delete log file after generating')\n@click.option('-rmh', '--delete_html_comments', is_flag=True, help='Delete html comment in the generated .md file')\n@click.option('-o', '--output_name', default='FINALreadme.md', type=click.Path(), help='Name for generated .md file')\n@click.option('-lo', '--log_file', default='LOGS.log', type=click.Path(), help='Name for log file')\ndef cli(no_log, delete_log, delete_html_comments, output_name, log_file):\n    logger = logging.getLogger(__name__)\n    if no_log:\n        logger.setLevel(logging.CRITICAL)\n    else:\n        logger.setLevel(logging.DEBUG)\n    my_file = logging.FileHandler(log_file, mode='w')\n    my_file.setLevel(logging.DEBUG)\n    formatter = logging.Formatter('%(asctime)s>%(levelname)s: %(message)s')\n    my_file.setFormatter(formatter)\n    logger.addHandler(my_file)\n    main(logger=logger, files_to_include=[0, 1, 2, 3], output_name=output_name, delete_html_comments=delete_html_comments)\n    if delete_log:\n        log_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), log_file)\n        if os.path.exists(log_file):\n            try:\n                os.remove(log_file)\n            except Exception as e:\n                logger.error(str(e))",
        "mutated": [
            "@click.command()\n@click.option('-nol', '--no_log', is_flag=True, help='Disable log')\n@click.option('-rml', '--delete_log', is_flag=True, help='Delete log file after generating')\n@click.option('-rmh', '--delete_html_comments', is_flag=True, help='Delete html comment in the generated .md file')\n@click.option('-o', '--output_name', default='FINALreadme.md', type=click.Path(), help='Name for generated .md file')\n@click.option('-lo', '--log_file', default='LOGS.log', type=click.Path(), help='Name for log file')\ndef cli(no_log, delete_log, delete_html_comments, output_name, log_file):\n    if False:\n        i = 10\n    logger = logging.getLogger(__name__)\n    if no_log:\n        logger.setLevel(logging.CRITICAL)\n    else:\n        logger.setLevel(logging.DEBUG)\n    my_file = logging.FileHandler(log_file, mode='w')\n    my_file.setLevel(logging.DEBUG)\n    formatter = logging.Formatter('%(asctime)s>%(levelname)s: %(message)s')\n    my_file.setFormatter(formatter)\n    logger.addHandler(my_file)\n    main(logger=logger, files_to_include=[0, 1, 2, 3], output_name=output_name, delete_html_comments=delete_html_comments)\n    if delete_log:\n        log_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), log_file)\n        if os.path.exists(log_file):\n            try:\n                os.remove(log_file)\n            except Exception as e:\n                logger.error(str(e))",
            "@click.command()\n@click.option('-nol', '--no_log', is_flag=True, help='Disable log')\n@click.option('-rml', '--delete_log', is_flag=True, help='Delete log file after generating')\n@click.option('-rmh', '--delete_html_comments', is_flag=True, help='Delete html comment in the generated .md file')\n@click.option('-o', '--output_name', default='FINALreadme.md', type=click.Path(), help='Name for generated .md file')\n@click.option('-lo', '--log_file', default='LOGS.log', type=click.Path(), help='Name for log file')\ndef cli(no_log, delete_log, delete_html_comments, output_name, log_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    logger = logging.getLogger(__name__)\n    if no_log:\n        logger.setLevel(logging.CRITICAL)\n    else:\n        logger.setLevel(logging.DEBUG)\n    my_file = logging.FileHandler(log_file, mode='w')\n    my_file.setLevel(logging.DEBUG)\n    formatter = logging.Formatter('%(asctime)s>%(levelname)s: %(message)s')\n    my_file.setFormatter(formatter)\n    logger.addHandler(my_file)\n    main(logger=logger, files_to_include=[0, 1, 2, 3], output_name=output_name, delete_html_comments=delete_html_comments)\n    if delete_log:\n        log_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), log_file)\n        if os.path.exists(log_file):\n            try:\n                os.remove(log_file)\n            except Exception as e:\n                logger.error(str(e))",
            "@click.command()\n@click.option('-nol', '--no_log', is_flag=True, help='Disable log')\n@click.option('-rml', '--delete_log', is_flag=True, help='Delete log file after generating')\n@click.option('-rmh', '--delete_html_comments', is_flag=True, help='Delete html comment in the generated .md file')\n@click.option('-o', '--output_name', default='FINALreadme.md', type=click.Path(), help='Name for generated .md file')\n@click.option('-lo', '--log_file', default='LOGS.log', type=click.Path(), help='Name for log file')\ndef cli(no_log, delete_log, delete_html_comments, output_name, log_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    logger = logging.getLogger(__name__)\n    if no_log:\n        logger.setLevel(logging.CRITICAL)\n    else:\n        logger.setLevel(logging.DEBUG)\n    my_file = logging.FileHandler(log_file, mode='w')\n    my_file.setLevel(logging.DEBUG)\n    formatter = logging.Formatter('%(asctime)s>%(levelname)s: %(message)s')\n    my_file.setFormatter(formatter)\n    logger.addHandler(my_file)\n    main(logger=logger, files_to_include=[0, 1, 2, 3], output_name=output_name, delete_html_comments=delete_html_comments)\n    if delete_log:\n        log_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), log_file)\n        if os.path.exists(log_file):\n            try:\n                os.remove(log_file)\n            except Exception as e:\n                logger.error(str(e))",
            "@click.command()\n@click.option('-nol', '--no_log', is_flag=True, help='Disable log')\n@click.option('-rml', '--delete_log', is_flag=True, help='Delete log file after generating')\n@click.option('-rmh', '--delete_html_comments', is_flag=True, help='Delete html comment in the generated .md file')\n@click.option('-o', '--output_name', default='FINALreadme.md', type=click.Path(), help='Name for generated .md file')\n@click.option('-lo', '--log_file', default='LOGS.log', type=click.Path(), help='Name for log file')\ndef cli(no_log, delete_log, delete_html_comments, output_name, log_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    logger = logging.getLogger(__name__)\n    if no_log:\n        logger.setLevel(logging.CRITICAL)\n    else:\n        logger.setLevel(logging.DEBUG)\n    my_file = logging.FileHandler(log_file, mode='w')\n    my_file.setLevel(logging.DEBUG)\n    formatter = logging.Formatter('%(asctime)s>%(levelname)s: %(message)s')\n    my_file.setFormatter(formatter)\n    logger.addHandler(my_file)\n    main(logger=logger, files_to_include=[0, 1, 2, 3], output_name=output_name, delete_html_comments=delete_html_comments)\n    if delete_log:\n        log_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), log_file)\n        if os.path.exists(log_file):\n            try:\n                os.remove(log_file)\n            except Exception as e:\n                logger.error(str(e))",
            "@click.command()\n@click.option('-nol', '--no_log', is_flag=True, help='Disable log')\n@click.option('-rml', '--delete_log', is_flag=True, help='Delete log file after generating')\n@click.option('-rmh', '--delete_html_comments', is_flag=True, help='Delete html comment in the generated .md file')\n@click.option('-o', '--output_name', default='FINALreadme.md', type=click.Path(), help='Name for generated .md file')\n@click.option('-lo', '--log_file', default='LOGS.log', type=click.Path(), help='Name for log file')\ndef cli(no_log, delete_log, delete_html_comments, output_name, log_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    logger = logging.getLogger(__name__)\n    if no_log:\n        logger.setLevel(logging.CRITICAL)\n    else:\n        logger.setLevel(logging.DEBUG)\n    my_file = logging.FileHandler(log_file, mode='w')\n    my_file.setLevel(logging.DEBUG)\n    formatter = logging.Formatter('%(asctime)s>%(levelname)s: %(message)s')\n    my_file.setFormatter(formatter)\n    logger.addHandler(my_file)\n    main(logger=logger, files_to_include=[0, 1, 2, 3], output_name=output_name, delete_html_comments=delete_html_comments)\n    if delete_log:\n        log_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), log_file)\n        if os.path.exists(log_file):\n            try:\n                os.remove(log_file)\n            except Exception as e:\n                logger.error(str(e))"
        ]
    }
]