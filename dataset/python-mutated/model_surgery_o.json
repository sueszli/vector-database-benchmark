[
    {
        "func_name": "surgery",
        "original": "def surgery(data_type, param_name, is_weight, tar_size, ckpt):\n    weight_name = param_name + ('.weight' if is_weight else '.bias')\n    pretrained_weight = ckpt['model'][weight_name]\n    prev_cls = pretrained_weight.size(0)\n    if 'cls_score' in param_name:\n        prev_cls -= 1\n    if is_weight:\n        feat_size = pretrained_weight.size(1)\n        new_weight = torch.rand((tar_size, feat_size))\n        torch.nn.init.normal_(new_weight, 0, 0.01)\n    else:\n        new_weight = torch.zeros(tar_size)\n    if data_type == 'coco':\n        for (idx, c) in enumerate(COCO_BASE_CLASSES):\n            if 'cls_score' in param_name:\n                new_weight[COCO_IDMAP[c]] = pretrained_weight[idx]\n            else:\n                new_weight[COCO_IDMAP[c] * 4:(COCO_IDMAP[c] + 1) * 4] = pretrained_weight[idx * 4:(idx + 1) * 4]\n    else:\n        new_weight[:prev_cls] = pretrained_weight[:prev_cls]\n    if 'cls_score' in param_name:\n        new_weight[-1] = pretrained_weight[-1]\n    ckpt['model'][weight_name] = new_weight",
        "mutated": [
            "def surgery(data_type, param_name, is_weight, tar_size, ckpt):\n    if False:\n        i = 10\n    weight_name = param_name + ('.weight' if is_weight else '.bias')\n    pretrained_weight = ckpt['model'][weight_name]\n    prev_cls = pretrained_weight.size(0)\n    if 'cls_score' in param_name:\n        prev_cls -= 1\n    if is_weight:\n        feat_size = pretrained_weight.size(1)\n        new_weight = torch.rand((tar_size, feat_size))\n        torch.nn.init.normal_(new_weight, 0, 0.01)\n    else:\n        new_weight = torch.zeros(tar_size)\n    if data_type == 'coco':\n        for (idx, c) in enumerate(COCO_BASE_CLASSES):\n            if 'cls_score' in param_name:\n                new_weight[COCO_IDMAP[c]] = pretrained_weight[idx]\n            else:\n                new_weight[COCO_IDMAP[c] * 4:(COCO_IDMAP[c] + 1) * 4] = pretrained_weight[idx * 4:(idx + 1) * 4]\n    else:\n        new_weight[:prev_cls] = pretrained_weight[:prev_cls]\n    if 'cls_score' in param_name:\n        new_weight[-1] = pretrained_weight[-1]\n    ckpt['model'][weight_name] = new_weight",
            "def surgery(data_type, param_name, is_weight, tar_size, ckpt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    weight_name = param_name + ('.weight' if is_weight else '.bias')\n    pretrained_weight = ckpt['model'][weight_name]\n    prev_cls = pretrained_weight.size(0)\n    if 'cls_score' in param_name:\n        prev_cls -= 1\n    if is_weight:\n        feat_size = pretrained_weight.size(1)\n        new_weight = torch.rand((tar_size, feat_size))\n        torch.nn.init.normal_(new_weight, 0, 0.01)\n    else:\n        new_weight = torch.zeros(tar_size)\n    if data_type == 'coco':\n        for (idx, c) in enumerate(COCO_BASE_CLASSES):\n            if 'cls_score' in param_name:\n                new_weight[COCO_IDMAP[c]] = pretrained_weight[idx]\n            else:\n                new_weight[COCO_IDMAP[c] * 4:(COCO_IDMAP[c] + 1) * 4] = pretrained_weight[idx * 4:(idx + 1) * 4]\n    else:\n        new_weight[:prev_cls] = pretrained_weight[:prev_cls]\n    if 'cls_score' in param_name:\n        new_weight[-1] = pretrained_weight[-1]\n    ckpt['model'][weight_name] = new_weight",
            "def surgery(data_type, param_name, is_weight, tar_size, ckpt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    weight_name = param_name + ('.weight' if is_weight else '.bias')\n    pretrained_weight = ckpt['model'][weight_name]\n    prev_cls = pretrained_weight.size(0)\n    if 'cls_score' in param_name:\n        prev_cls -= 1\n    if is_weight:\n        feat_size = pretrained_weight.size(1)\n        new_weight = torch.rand((tar_size, feat_size))\n        torch.nn.init.normal_(new_weight, 0, 0.01)\n    else:\n        new_weight = torch.zeros(tar_size)\n    if data_type == 'coco':\n        for (idx, c) in enumerate(COCO_BASE_CLASSES):\n            if 'cls_score' in param_name:\n                new_weight[COCO_IDMAP[c]] = pretrained_weight[idx]\n            else:\n                new_weight[COCO_IDMAP[c] * 4:(COCO_IDMAP[c] + 1) * 4] = pretrained_weight[idx * 4:(idx + 1) * 4]\n    else:\n        new_weight[:prev_cls] = pretrained_weight[:prev_cls]\n    if 'cls_score' in param_name:\n        new_weight[-1] = pretrained_weight[-1]\n    ckpt['model'][weight_name] = new_weight",
            "def surgery(data_type, param_name, is_weight, tar_size, ckpt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    weight_name = param_name + ('.weight' if is_weight else '.bias')\n    pretrained_weight = ckpt['model'][weight_name]\n    prev_cls = pretrained_weight.size(0)\n    if 'cls_score' in param_name:\n        prev_cls -= 1\n    if is_weight:\n        feat_size = pretrained_weight.size(1)\n        new_weight = torch.rand((tar_size, feat_size))\n        torch.nn.init.normal_(new_weight, 0, 0.01)\n    else:\n        new_weight = torch.zeros(tar_size)\n    if data_type == 'coco':\n        for (idx, c) in enumerate(COCO_BASE_CLASSES):\n            if 'cls_score' in param_name:\n                new_weight[COCO_IDMAP[c]] = pretrained_weight[idx]\n            else:\n                new_weight[COCO_IDMAP[c] * 4:(COCO_IDMAP[c] + 1) * 4] = pretrained_weight[idx * 4:(idx + 1) * 4]\n    else:\n        new_weight[:prev_cls] = pretrained_weight[:prev_cls]\n    if 'cls_score' in param_name:\n        new_weight[-1] = pretrained_weight[-1]\n    ckpt['model'][weight_name] = new_weight",
            "def surgery(data_type, param_name, is_weight, tar_size, ckpt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    weight_name = param_name + ('.weight' if is_weight else '.bias')\n    pretrained_weight = ckpt['model'][weight_name]\n    prev_cls = pretrained_weight.size(0)\n    if 'cls_score' in param_name:\n        prev_cls -= 1\n    if is_weight:\n        feat_size = pretrained_weight.size(1)\n        new_weight = torch.rand((tar_size, feat_size))\n        torch.nn.init.normal_(new_weight, 0, 0.01)\n    else:\n        new_weight = torch.zeros(tar_size)\n    if data_type == 'coco':\n        for (idx, c) in enumerate(COCO_BASE_CLASSES):\n            if 'cls_score' in param_name:\n                new_weight[COCO_IDMAP[c]] = pretrained_weight[idx]\n            else:\n                new_weight[COCO_IDMAP[c] * 4:(COCO_IDMAP[c] + 1) * 4] = pretrained_weight[idx * 4:(idx + 1) * 4]\n    else:\n        new_weight[:prev_cls] = pretrained_weight[:prev_cls]\n    if 'cls_score' in param_name:\n        new_weight[-1] = pretrained_weight[-1]\n    ckpt['model'][weight_name] = new_weight"
        ]
    },
    {
        "func_name": "model_surgery",
        "original": "def model_surgery(src_path, save_dir, data_type='pascal_voc', method='remove', params_name=['model.roi_heads.box_predictor.cls_score', 'model.roi_heads.box_predictor.bbox_pred']):\n    \"\"\"\n    Either remove the final layer weights for fine-tuning on novel dataset or\n    append randomly initialized weights for the novel classes.\n    \"\"\"\n    assert method in ['remove', 'randinit'], '{} not implemented'.format(method)\n    if data_type == 'coco':\n        TAR_SIZE = 80\n    elif data_type == 'pascal_voc':\n        TAR_SIZE = 20\n    else:\n        NotImplementedError('{} dataset does not supported'.format(data_type))\n    save_name = 'model_reset_' + ('remove' if method == 'remove' else 'surgery') + '.pth'\n    save_path = os.path.join(save_dir, save_name)\n    os.makedirs(save_dir, exist_ok=True)\n    ckpt = torch.load(src_path)\n    if 'scheduler' in ckpt:\n        del ckpt['scheduler']\n    if 'optimizer' in ckpt:\n        del ckpt['optimizer']\n    if 'iteration' in ckpt:\n        ckpt['iteration'] = 0\n    if method == 'remove':\n        for param_name in params_name:\n            del ckpt['model'][param_name + '.weight']\n            if param_name + '.bias' in ckpt['model']:\n                del ckpt['model'][param_name + '.bias']\n    elif method == 'randinit':\n        tar_sizes = [TAR_SIZE + 1, TAR_SIZE * 4]\n        for (idx, (param_name, tar_size)) in enumerate(zip(params_name, tar_sizes)):\n            surgery(data_type, param_name, True, tar_size, ckpt)\n            surgery(data_type, param_name, False, tar_size, ckpt)\n    else:\n        raise NotImplementedError\n    torch.save(ckpt, save_path)",
        "mutated": [
            "def model_surgery(src_path, save_dir, data_type='pascal_voc', method='remove', params_name=['model.roi_heads.box_predictor.cls_score', 'model.roi_heads.box_predictor.bbox_pred']):\n    if False:\n        i = 10\n    '\\n    Either remove the final layer weights for fine-tuning on novel dataset or\\n    append randomly initialized weights for the novel classes.\\n    '\n    assert method in ['remove', 'randinit'], '{} not implemented'.format(method)\n    if data_type == 'coco':\n        TAR_SIZE = 80\n    elif data_type == 'pascal_voc':\n        TAR_SIZE = 20\n    else:\n        NotImplementedError('{} dataset does not supported'.format(data_type))\n    save_name = 'model_reset_' + ('remove' if method == 'remove' else 'surgery') + '.pth'\n    save_path = os.path.join(save_dir, save_name)\n    os.makedirs(save_dir, exist_ok=True)\n    ckpt = torch.load(src_path)\n    if 'scheduler' in ckpt:\n        del ckpt['scheduler']\n    if 'optimizer' in ckpt:\n        del ckpt['optimizer']\n    if 'iteration' in ckpt:\n        ckpt['iteration'] = 0\n    if method == 'remove':\n        for param_name in params_name:\n            del ckpt['model'][param_name + '.weight']\n            if param_name + '.bias' in ckpt['model']:\n                del ckpt['model'][param_name + '.bias']\n    elif method == 'randinit':\n        tar_sizes = [TAR_SIZE + 1, TAR_SIZE * 4]\n        for (idx, (param_name, tar_size)) in enumerate(zip(params_name, tar_sizes)):\n            surgery(data_type, param_name, True, tar_size, ckpt)\n            surgery(data_type, param_name, False, tar_size, ckpt)\n    else:\n        raise NotImplementedError\n    torch.save(ckpt, save_path)",
            "def model_surgery(src_path, save_dir, data_type='pascal_voc', method='remove', params_name=['model.roi_heads.box_predictor.cls_score', 'model.roi_heads.box_predictor.bbox_pred']):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Either remove the final layer weights for fine-tuning on novel dataset or\\n    append randomly initialized weights for the novel classes.\\n    '\n    assert method in ['remove', 'randinit'], '{} not implemented'.format(method)\n    if data_type == 'coco':\n        TAR_SIZE = 80\n    elif data_type == 'pascal_voc':\n        TAR_SIZE = 20\n    else:\n        NotImplementedError('{} dataset does not supported'.format(data_type))\n    save_name = 'model_reset_' + ('remove' if method == 'remove' else 'surgery') + '.pth'\n    save_path = os.path.join(save_dir, save_name)\n    os.makedirs(save_dir, exist_ok=True)\n    ckpt = torch.load(src_path)\n    if 'scheduler' in ckpt:\n        del ckpt['scheduler']\n    if 'optimizer' in ckpt:\n        del ckpt['optimizer']\n    if 'iteration' in ckpt:\n        ckpt['iteration'] = 0\n    if method == 'remove':\n        for param_name in params_name:\n            del ckpt['model'][param_name + '.weight']\n            if param_name + '.bias' in ckpt['model']:\n                del ckpt['model'][param_name + '.bias']\n    elif method == 'randinit':\n        tar_sizes = [TAR_SIZE + 1, TAR_SIZE * 4]\n        for (idx, (param_name, tar_size)) in enumerate(zip(params_name, tar_sizes)):\n            surgery(data_type, param_name, True, tar_size, ckpt)\n            surgery(data_type, param_name, False, tar_size, ckpt)\n    else:\n        raise NotImplementedError\n    torch.save(ckpt, save_path)",
            "def model_surgery(src_path, save_dir, data_type='pascal_voc', method='remove', params_name=['model.roi_heads.box_predictor.cls_score', 'model.roi_heads.box_predictor.bbox_pred']):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Either remove the final layer weights for fine-tuning on novel dataset or\\n    append randomly initialized weights for the novel classes.\\n    '\n    assert method in ['remove', 'randinit'], '{} not implemented'.format(method)\n    if data_type == 'coco':\n        TAR_SIZE = 80\n    elif data_type == 'pascal_voc':\n        TAR_SIZE = 20\n    else:\n        NotImplementedError('{} dataset does not supported'.format(data_type))\n    save_name = 'model_reset_' + ('remove' if method == 'remove' else 'surgery') + '.pth'\n    save_path = os.path.join(save_dir, save_name)\n    os.makedirs(save_dir, exist_ok=True)\n    ckpt = torch.load(src_path)\n    if 'scheduler' in ckpt:\n        del ckpt['scheduler']\n    if 'optimizer' in ckpt:\n        del ckpt['optimizer']\n    if 'iteration' in ckpt:\n        ckpt['iteration'] = 0\n    if method == 'remove':\n        for param_name in params_name:\n            del ckpt['model'][param_name + '.weight']\n            if param_name + '.bias' in ckpt['model']:\n                del ckpt['model'][param_name + '.bias']\n    elif method == 'randinit':\n        tar_sizes = [TAR_SIZE + 1, TAR_SIZE * 4]\n        for (idx, (param_name, tar_size)) in enumerate(zip(params_name, tar_sizes)):\n            surgery(data_type, param_name, True, tar_size, ckpt)\n            surgery(data_type, param_name, False, tar_size, ckpt)\n    else:\n        raise NotImplementedError\n    torch.save(ckpt, save_path)",
            "def model_surgery(src_path, save_dir, data_type='pascal_voc', method='remove', params_name=['model.roi_heads.box_predictor.cls_score', 'model.roi_heads.box_predictor.bbox_pred']):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Either remove the final layer weights for fine-tuning on novel dataset or\\n    append randomly initialized weights for the novel classes.\\n    '\n    assert method in ['remove', 'randinit'], '{} not implemented'.format(method)\n    if data_type == 'coco':\n        TAR_SIZE = 80\n    elif data_type == 'pascal_voc':\n        TAR_SIZE = 20\n    else:\n        NotImplementedError('{} dataset does not supported'.format(data_type))\n    save_name = 'model_reset_' + ('remove' if method == 'remove' else 'surgery') + '.pth'\n    save_path = os.path.join(save_dir, save_name)\n    os.makedirs(save_dir, exist_ok=True)\n    ckpt = torch.load(src_path)\n    if 'scheduler' in ckpt:\n        del ckpt['scheduler']\n    if 'optimizer' in ckpt:\n        del ckpt['optimizer']\n    if 'iteration' in ckpt:\n        ckpt['iteration'] = 0\n    if method == 'remove':\n        for param_name in params_name:\n            del ckpt['model'][param_name + '.weight']\n            if param_name + '.bias' in ckpt['model']:\n                del ckpt['model'][param_name + '.bias']\n    elif method == 'randinit':\n        tar_sizes = [TAR_SIZE + 1, TAR_SIZE * 4]\n        for (idx, (param_name, tar_size)) in enumerate(zip(params_name, tar_sizes)):\n            surgery(data_type, param_name, True, tar_size, ckpt)\n            surgery(data_type, param_name, False, tar_size, ckpt)\n    else:\n        raise NotImplementedError\n    torch.save(ckpt, save_path)",
            "def model_surgery(src_path, save_dir, data_type='pascal_voc', method='remove', params_name=['model.roi_heads.box_predictor.cls_score', 'model.roi_heads.box_predictor.bbox_pred']):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Either remove the final layer weights for fine-tuning on novel dataset or\\n    append randomly initialized weights for the novel classes.\\n    '\n    assert method in ['remove', 'randinit'], '{} not implemented'.format(method)\n    if data_type == 'coco':\n        TAR_SIZE = 80\n    elif data_type == 'pascal_voc':\n        TAR_SIZE = 20\n    else:\n        NotImplementedError('{} dataset does not supported'.format(data_type))\n    save_name = 'model_reset_' + ('remove' if method == 'remove' else 'surgery') + '.pth'\n    save_path = os.path.join(save_dir, save_name)\n    os.makedirs(save_dir, exist_ok=True)\n    ckpt = torch.load(src_path)\n    if 'scheduler' in ckpt:\n        del ckpt['scheduler']\n    if 'optimizer' in ckpt:\n        del ckpt['optimizer']\n    if 'iteration' in ckpt:\n        ckpt['iteration'] = 0\n    if method == 'remove':\n        for param_name in params_name:\n            del ckpt['model'][param_name + '.weight']\n            if param_name + '.bias' in ckpt['model']:\n                del ckpt['model'][param_name + '.bias']\n    elif method == 'randinit':\n        tar_sizes = [TAR_SIZE + 1, TAR_SIZE * 4]\n        for (idx, (param_name, tar_size)) in enumerate(zip(params_name, tar_sizes)):\n            surgery(data_type, param_name, True, tar_size, ckpt)\n            surgery(data_type, param_name, False, tar_size, ckpt)\n    else:\n        raise NotImplementedError\n    torch.save(ckpt, save_path)"
        ]
    }
]