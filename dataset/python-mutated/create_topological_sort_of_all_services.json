[
    {
        "func_name": "dfs",
        "original": "def dfs(node: str, topo_sort_stack: List[str], adj_list: Dict[str, List[str]], visit_stack: List[str]) -> None:\n    \"\"\"Depth First Search starting with node.\n\n    Args:\n        node: str. The service name from which dfs will begin.\n        topo_sort_stack: list(str). Stores topological sort of services\n            in reveresed way.\n        adj_list: dict. Adjacency list of the graph formed with services\n            as nodes and dependencies as edges.\n        visit_stack: list(str). Keeps track of visited and unvisited nodes.\n    \"\"\"\n    visit_stack.append(node)\n    for pt in adj_list[node]:\n        if pt not in visit_stack:\n            dfs(pt, topo_sort_stack, adj_list, visit_stack)\n    topo_sort_stack.append(node)",
        "mutated": [
            "def dfs(node: str, topo_sort_stack: List[str], adj_list: Dict[str, List[str]], visit_stack: List[str]) -> None:\n    if False:\n        i = 10\n    'Depth First Search starting with node.\\n\\n    Args:\\n        node: str. The service name from which dfs will begin.\\n        topo_sort_stack: list(str). Stores topological sort of services\\n            in reveresed way.\\n        adj_list: dict. Adjacency list of the graph formed with services\\n            as nodes and dependencies as edges.\\n        visit_stack: list(str). Keeps track of visited and unvisited nodes.\\n    '\n    visit_stack.append(node)\n    for pt in adj_list[node]:\n        if pt not in visit_stack:\n            dfs(pt, topo_sort_stack, adj_list, visit_stack)\n    topo_sort_stack.append(node)",
            "def dfs(node: str, topo_sort_stack: List[str], adj_list: Dict[str, List[str]], visit_stack: List[str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Depth First Search starting with node.\\n\\n    Args:\\n        node: str. The service name from which dfs will begin.\\n        topo_sort_stack: list(str). Stores topological sort of services\\n            in reveresed way.\\n        adj_list: dict. Adjacency list of the graph formed with services\\n            as nodes and dependencies as edges.\\n        visit_stack: list(str). Keeps track of visited and unvisited nodes.\\n    '\n    visit_stack.append(node)\n    for pt in adj_list[node]:\n        if pt not in visit_stack:\n            dfs(pt, topo_sort_stack, adj_list, visit_stack)\n    topo_sort_stack.append(node)",
            "def dfs(node: str, topo_sort_stack: List[str], adj_list: Dict[str, List[str]], visit_stack: List[str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Depth First Search starting with node.\\n\\n    Args:\\n        node: str. The service name from which dfs will begin.\\n        topo_sort_stack: list(str). Stores topological sort of services\\n            in reveresed way.\\n        adj_list: dict. Adjacency list of the graph formed with services\\n            as nodes and dependencies as edges.\\n        visit_stack: list(str). Keeps track of visited and unvisited nodes.\\n    '\n    visit_stack.append(node)\n    for pt in adj_list[node]:\n        if pt not in visit_stack:\n            dfs(pt, topo_sort_stack, adj_list, visit_stack)\n    topo_sort_stack.append(node)",
            "def dfs(node: str, topo_sort_stack: List[str], adj_list: Dict[str, List[str]], visit_stack: List[str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Depth First Search starting with node.\\n\\n    Args:\\n        node: str. The service name from which dfs will begin.\\n        topo_sort_stack: list(str). Stores topological sort of services\\n            in reveresed way.\\n        adj_list: dict. Adjacency list of the graph formed with services\\n            as nodes and dependencies as edges.\\n        visit_stack: list(str). Keeps track of visited and unvisited nodes.\\n    '\n    visit_stack.append(node)\n    for pt in adj_list[node]:\n        if pt not in visit_stack:\n            dfs(pt, topo_sort_stack, adj_list, visit_stack)\n    topo_sort_stack.append(node)",
            "def dfs(node: str, topo_sort_stack: List[str], adj_list: Dict[str, List[str]], visit_stack: List[str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Depth First Search starting with node.\\n\\n    Args:\\n        node: str. The service name from which dfs will begin.\\n        topo_sort_stack: list(str). Stores topological sort of services\\n            in reveresed way.\\n        adj_list: dict. Adjacency list of the graph formed with services\\n            as nodes and dependencies as edges.\\n        visit_stack: list(str). Keeps track of visited and unvisited nodes.\\n    '\n    visit_stack.append(node)\n    for pt in adj_list[node]:\n        if pt not in visit_stack:\n            dfs(pt, topo_sort_stack, adj_list, visit_stack)\n    topo_sort_stack.append(node)"
        ]
    },
    {
        "func_name": "make_graph",
        "original": "def make_graph() -> Tuple[Dict[str, List[str]], List[str]]:\n    \"\"\"Creates an adjaceny list considering services as node and dependencies\n    as edges.\n\n    Returns:\n        tuple(dict, list(str)). Adjancency list of the graph formed with\n        services as nodes and dependencies as edges, list of all the services.\n    \"\"\"\n    adj_list = collections.defaultdict(list)\n    nodes_list = []\n    for dirname in DIRECTORY_NAMES:\n        for (root, _, filenames) in os.walk(dirname):\n            for filename in filenames:\n                if filename.endswith(SERVICE_FILES_SUFFICES):\n                    nodes_list.append(filename)\n                    filepath = os.path.join(root, filename)\n                    with utils.open_file(filepath, 'r') as f:\n                        file_lines = f.readlines()\n                    dep_lines = ''\n                    index = 0\n                    while index < len(file_lines):\n                        line = file_lines[index]\n                        if line.startswith('require'):\n                            while not line.endswith(';\\n'):\n                                dep_lines = dep_lines + line\n                                index += 1\n                                line = file_lines[index]\n                            dep_lines = dep_lines + line\n                            index += 1\n                        elif line.startswith('import'):\n                            while not line.endswith(';\\n'):\n                                index += 1\n                                line = file_lines[index]\n                                if \"'\" in line:\n                                    break\n                            dep_lines = dep_lines + ('require (' + line[line.find(\"'\"):line.rfind(\"'\") + 1] + ');\\n')\n                            index += 1\n                        else:\n                            index += 1\n                    parsed_script = esprima.parseScript(dep_lines, comment=True)\n                    parsed_nodes = parsed_script.body\n                    for parsed_node in parsed_nodes:\n                        assert parsed_node.type == 'ExpressionStatement'\n                        assert parsed_node.expression.callee.name == 'require'\n                        arguments = parsed_node.expression.arguments\n                        for argument in arguments:\n                            dep_path = argument.value\n                            if argument.operator == '+':\n                                dep_path = argument.left.value + argument.right.value\n                            if not dep_path.endswith('.ts'):\n                                dep_path = dep_path + '.ts'\n                            if dep_path.endswith(SERVICE_FILES_SUFFICES):\n                                dep_name = os.path.basename(dep_path)\n                                adj_list[dep_name].append(filename)\n    return (adj_list, nodes_list)",
        "mutated": [
            "def make_graph() -> Tuple[Dict[str, List[str]], List[str]]:\n    if False:\n        i = 10\n    'Creates an adjaceny list considering services as node and dependencies\\n    as edges.\\n\\n    Returns:\\n        tuple(dict, list(str)). Adjancency list of the graph formed with\\n        services as nodes and dependencies as edges, list of all the services.\\n    '\n    adj_list = collections.defaultdict(list)\n    nodes_list = []\n    for dirname in DIRECTORY_NAMES:\n        for (root, _, filenames) in os.walk(dirname):\n            for filename in filenames:\n                if filename.endswith(SERVICE_FILES_SUFFICES):\n                    nodes_list.append(filename)\n                    filepath = os.path.join(root, filename)\n                    with utils.open_file(filepath, 'r') as f:\n                        file_lines = f.readlines()\n                    dep_lines = ''\n                    index = 0\n                    while index < len(file_lines):\n                        line = file_lines[index]\n                        if line.startswith('require'):\n                            while not line.endswith(';\\n'):\n                                dep_lines = dep_lines + line\n                                index += 1\n                                line = file_lines[index]\n                            dep_lines = dep_lines + line\n                            index += 1\n                        elif line.startswith('import'):\n                            while not line.endswith(';\\n'):\n                                index += 1\n                                line = file_lines[index]\n                                if \"'\" in line:\n                                    break\n                            dep_lines = dep_lines + ('require (' + line[line.find(\"'\"):line.rfind(\"'\") + 1] + ');\\n')\n                            index += 1\n                        else:\n                            index += 1\n                    parsed_script = esprima.parseScript(dep_lines, comment=True)\n                    parsed_nodes = parsed_script.body\n                    for parsed_node in parsed_nodes:\n                        assert parsed_node.type == 'ExpressionStatement'\n                        assert parsed_node.expression.callee.name == 'require'\n                        arguments = parsed_node.expression.arguments\n                        for argument in arguments:\n                            dep_path = argument.value\n                            if argument.operator == '+':\n                                dep_path = argument.left.value + argument.right.value\n                            if not dep_path.endswith('.ts'):\n                                dep_path = dep_path + '.ts'\n                            if dep_path.endswith(SERVICE_FILES_SUFFICES):\n                                dep_name = os.path.basename(dep_path)\n                                adj_list[dep_name].append(filename)\n    return (adj_list, nodes_list)",
            "def make_graph() -> Tuple[Dict[str, List[str]], List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Creates an adjaceny list considering services as node and dependencies\\n    as edges.\\n\\n    Returns:\\n        tuple(dict, list(str)). Adjancency list of the graph formed with\\n        services as nodes and dependencies as edges, list of all the services.\\n    '\n    adj_list = collections.defaultdict(list)\n    nodes_list = []\n    for dirname in DIRECTORY_NAMES:\n        for (root, _, filenames) in os.walk(dirname):\n            for filename in filenames:\n                if filename.endswith(SERVICE_FILES_SUFFICES):\n                    nodes_list.append(filename)\n                    filepath = os.path.join(root, filename)\n                    with utils.open_file(filepath, 'r') as f:\n                        file_lines = f.readlines()\n                    dep_lines = ''\n                    index = 0\n                    while index < len(file_lines):\n                        line = file_lines[index]\n                        if line.startswith('require'):\n                            while not line.endswith(';\\n'):\n                                dep_lines = dep_lines + line\n                                index += 1\n                                line = file_lines[index]\n                            dep_lines = dep_lines + line\n                            index += 1\n                        elif line.startswith('import'):\n                            while not line.endswith(';\\n'):\n                                index += 1\n                                line = file_lines[index]\n                                if \"'\" in line:\n                                    break\n                            dep_lines = dep_lines + ('require (' + line[line.find(\"'\"):line.rfind(\"'\") + 1] + ');\\n')\n                            index += 1\n                        else:\n                            index += 1\n                    parsed_script = esprima.parseScript(dep_lines, comment=True)\n                    parsed_nodes = parsed_script.body\n                    for parsed_node in parsed_nodes:\n                        assert parsed_node.type == 'ExpressionStatement'\n                        assert parsed_node.expression.callee.name == 'require'\n                        arguments = parsed_node.expression.arguments\n                        for argument in arguments:\n                            dep_path = argument.value\n                            if argument.operator == '+':\n                                dep_path = argument.left.value + argument.right.value\n                            if not dep_path.endswith('.ts'):\n                                dep_path = dep_path + '.ts'\n                            if dep_path.endswith(SERVICE_FILES_SUFFICES):\n                                dep_name = os.path.basename(dep_path)\n                                adj_list[dep_name].append(filename)\n    return (adj_list, nodes_list)",
            "def make_graph() -> Tuple[Dict[str, List[str]], List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Creates an adjaceny list considering services as node and dependencies\\n    as edges.\\n\\n    Returns:\\n        tuple(dict, list(str)). Adjancency list of the graph formed with\\n        services as nodes and dependencies as edges, list of all the services.\\n    '\n    adj_list = collections.defaultdict(list)\n    nodes_list = []\n    for dirname in DIRECTORY_NAMES:\n        for (root, _, filenames) in os.walk(dirname):\n            for filename in filenames:\n                if filename.endswith(SERVICE_FILES_SUFFICES):\n                    nodes_list.append(filename)\n                    filepath = os.path.join(root, filename)\n                    with utils.open_file(filepath, 'r') as f:\n                        file_lines = f.readlines()\n                    dep_lines = ''\n                    index = 0\n                    while index < len(file_lines):\n                        line = file_lines[index]\n                        if line.startswith('require'):\n                            while not line.endswith(';\\n'):\n                                dep_lines = dep_lines + line\n                                index += 1\n                                line = file_lines[index]\n                            dep_lines = dep_lines + line\n                            index += 1\n                        elif line.startswith('import'):\n                            while not line.endswith(';\\n'):\n                                index += 1\n                                line = file_lines[index]\n                                if \"'\" in line:\n                                    break\n                            dep_lines = dep_lines + ('require (' + line[line.find(\"'\"):line.rfind(\"'\") + 1] + ');\\n')\n                            index += 1\n                        else:\n                            index += 1\n                    parsed_script = esprima.parseScript(dep_lines, comment=True)\n                    parsed_nodes = parsed_script.body\n                    for parsed_node in parsed_nodes:\n                        assert parsed_node.type == 'ExpressionStatement'\n                        assert parsed_node.expression.callee.name == 'require'\n                        arguments = parsed_node.expression.arguments\n                        for argument in arguments:\n                            dep_path = argument.value\n                            if argument.operator == '+':\n                                dep_path = argument.left.value + argument.right.value\n                            if not dep_path.endswith('.ts'):\n                                dep_path = dep_path + '.ts'\n                            if dep_path.endswith(SERVICE_FILES_SUFFICES):\n                                dep_name = os.path.basename(dep_path)\n                                adj_list[dep_name].append(filename)\n    return (adj_list, nodes_list)",
            "def make_graph() -> Tuple[Dict[str, List[str]], List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Creates an adjaceny list considering services as node and dependencies\\n    as edges.\\n\\n    Returns:\\n        tuple(dict, list(str)). Adjancency list of the graph formed with\\n        services as nodes and dependencies as edges, list of all the services.\\n    '\n    adj_list = collections.defaultdict(list)\n    nodes_list = []\n    for dirname in DIRECTORY_NAMES:\n        for (root, _, filenames) in os.walk(dirname):\n            for filename in filenames:\n                if filename.endswith(SERVICE_FILES_SUFFICES):\n                    nodes_list.append(filename)\n                    filepath = os.path.join(root, filename)\n                    with utils.open_file(filepath, 'r') as f:\n                        file_lines = f.readlines()\n                    dep_lines = ''\n                    index = 0\n                    while index < len(file_lines):\n                        line = file_lines[index]\n                        if line.startswith('require'):\n                            while not line.endswith(';\\n'):\n                                dep_lines = dep_lines + line\n                                index += 1\n                                line = file_lines[index]\n                            dep_lines = dep_lines + line\n                            index += 1\n                        elif line.startswith('import'):\n                            while not line.endswith(';\\n'):\n                                index += 1\n                                line = file_lines[index]\n                                if \"'\" in line:\n                                    break\n                            dep_lines = dep_lines + ('require (' + line[line.find(\"'\"):line.rfind(\"'\") + 1] + ');\\n')\n                            index += 1\n                        else:\n                            index += 1\n                    parsed_script = esprima.parseScript(dep_lines, comment=True)\n                    parsed_nodes = parsed_script.body\n                    for parsed_node in parsed_nodes:\n                        assert parsed_node.type == 'ExpressionStatement'\n                        assert parsed_node.expression.callee.name == 'require'\n                        arguments = parsed_node.expression.arguments\n                        for argument in arguments:\n                            dep_path = argument.value\n                            if argument.operator == '+':\n                                dep_path = argument.left.value + argument.right.value\n                            if not dep_path.endswith('.ts'):\n                                dep_path = dep_path + '.ts'\n                            if dep_path.endswith(SERVICE_FILES_SUFFICES):\n                                dep_name = os.path.basename(dep_path)\n                                adj_list[dep_name].append(filename)\n    return (adj_list, nodes_list)",
            "def make_graph() -> Tuple[Dict[str, List[str]], List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Creates an adjaceny list considering services as node and dependencies\\n    as edges.\\n\\n    Returns:\\n        tuple(dict, list(str)). Adjancency list of the graph formed with\\n        services as nodes and dependencies as edges, list of all the services.\\n    '\n    adj_list = collections.defaultdict(list)\n    nodes_list = []\n    for dirname in DIRECTORY_NAMES:\n        for (root, _, filenames) in os.walk(dirname):\n            for filename in filenames:\n                if filename.endswith(SERVICE_FILES_SUFFICES):\n                    nodes_list.append(filename)\n                    filepath = os.path.join(root, filename)\n                    with utils.open_file(filepath, 'r') as f:\n                        file_lines = f.readlines()\n                    dep_lines = ''\n                    index = 0\n                    while index < len(file_lines):\n                        line = file_lines[index]\n                        if line.startswith('require'):\n                            while not line.endswith(';\\n'):\n                                dep_lines = dep_lines + line\n                                index += 1\n                                line = file_lines[index]\n                            dep_lines = dep_lines + line\n                            index += 1\n                        elif line.startswith('import'):\n                            while not line.endswith(';\\n'):\n                                index += 1\n                                line = file_lines[index]\n                                if \"'\" in line:\n                                    break\n                            dep_lines = dep_lines + ('require (' + line[line.find(\"'\"):line.rfind(\"'\") + 1] + ');\\n')\n                            index += 1\n                        else:\n                            index += 1\n                    parsed_script = esprima.parseScript(dep_lines, comment=True)\n                    parsed_nodes = parsed_script.body\n                    for parsed_node in parsed_nodes:\n                        assert parsed_node.type == 'ExpressionStatement'\n                        assert parsed_node.expression.callee.name == 'require'\n                        arguments = parsed_node.expression.arguments\n                        for argument in arguments:\n                            dep_path = argument.value\n                            if argument.operator == '+':\n                                dep_path = argument.left.value + argument.right.value\n                            if not dep_path.endswith('.ts'):\n                                dep_path = dep_path + '.ts'\n                            if dep_path.endswith(SERVICE_FILES_SUFFICES):\n                                dep_name = os.path.basename(dep_path)\n                                adj_list[dep_name].append(filename)\n    return (adj_list, nodes_list)"
        ]
    },
    {
        "func_name": "main",
        "original": "def main() -> None:\n    \"\"\"Prints the topological order of the services based on the\n    dependencies.\n    \"\"\"\n    (adj_list, nodes_list) = make_graph()\n    visit_stack: List[str] = []\n    topo_sort_stack: List[str] = []\n    nodes_list.sort()\n    for unchecked_node in nodes_list:\n        if unchecked_node not in visit_stack:\n            dfs(unchecked_node, topo_sort_stack, adj_list, visit_stack)\n    topo_sort_stack.reverse()\n    for service in topo_sort_stack:\n        print(service)",
        "mutated": [
            "def main() -> None:\n    if False:\n        i = 10\n    'Prints the topological order of the services based on the\\n    dependencies.\\n    '\n    (adj_list, nodes_list) = make_graph()\n    visit_stack: List[str] = []\n    topo_sort_stack: List[str] = []\n    nodes_list.sort()\n    for unchecked_node in nodes_list:\n        if unchecked_node not in visit_stack:\n            dfs(unchecked_node, topo_sort_stack, adj_list, visit_stack)\n    topo_sort_stack.reverse()\n    for service in topo_sort_stack:\n        print(service)",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Prints the topological order of the services based on the\\n    dependencies.\\n    '\n    (adj_list, nodes_list) = make_graph()\n    visit_stack: List[str] = []\n    topo_sort_stack: List[str] = []\n    nodes_list.sort()\n    for unchecked_node in nodes_list:\n        if unchecked_node not in visit_stack:\n            dfs(unchecked_node, topo_sort_stack, adj_list, visit_stack)\n    topo_sort_stack.reverse()\n    for service in topo_sort_stack:\n        print(service)",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Prints the topological order of the services based on the\\n    dependencies.\\n    '\n    (adj_list, nodes_list) = make_graph()\n    visit_stack: List[str] = []\n    topo_sort_stack: List[str] = []\n    nodes_list.sort()\n    for unchecked_node in nodes_list:\n        if unchecked_node not in visit_stack:\n            dfs(unchecked_node, topo_sort_stack, adj_list, visit_stack)\n    topo_sort_stack.reverse()\n    for service in topo_sort_stack:\n        print(service)",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Prints the topological order of the services based on the\\n    dependencies.\\n    '\n    (adj_list, nodes_list) = make_graph()\n    visit_stack: List[str] = []\n    topo_sort_stack: List[str] = []\n    nodes_list.sort()\n    for unchecked_node in nodes_list:\n        if unchecked_node not in visit_stack:\n            dfs(unchecked_node, topo_sort_stack, adj_list, visit_stack)\n    topo_sort_stack.reverse()\n    for service in topo_sort_stack:\n        print(service)",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Prints the topological order of the services based on the\\n    dependencies.\\n    '\n    (adj_list, nodes_list) = make_graph()\n    visit_stack: List[str] = []\n    topo_sort_stack: List[str] = []\n    nodes_list.sort()\n    for unchecked_node in nodes_list:\n        if unchecked_node not in visit_stack:\n            dfs(unchecked_node, topo_sort_stack, adj_list, visit_stack)\n    topo_sort_stack.reverse()\n    for service in topo_sort_stack:\n        print(service)"
        ]
    }
]