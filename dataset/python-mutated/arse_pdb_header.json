[
    {
        "func_name": "_get_journal",
        "original": "def _get_journal(inl):\n    journal = ''\n    for line in inl:\n        if re.search('\\\\AJRNL', line):\n            journal += line[19:72].lower()\n    journal = re.sub('\\\\s\\\\s+', ' ', journal)\n    return journal",
        "mutated": [
            "def _get_journal(inl):\n    if False:\n        i = 10\n    journal = ''\n    for line in inl:\n        if re.search('\\\\AJRNL', line):\n            journal += line[19:72].lower()\n    journal = re.sub('\\\\s\\\\s+', ' ', journal)\n    return journal",
            "def _get_journal(inl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    journal = ''\n    for line in inl:\n        if re.search('\\\\AJRNL', line):\n            journal += line[19:72].lower()\n    journal = re.sub('\\\\s\\\\s+', ' ', journal)\n    return journal",
            "def _get_journal(inl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    journal = ''\n    for line in inl:\n        if re.search('\\\\AJRNL', line):\n            journal += line[19:72].lower()\n    journal = re.sub('\\\\s\\\\s+', ' ', journal)\n    return journal",
            "def _get_journal(inl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    journal = ''\n    for line in inl:\n        if re.search('\\\\AJRNL', line):\n            journal += line[19:72].lower()\n    journal = re.sub('\\\\s\\\\s+', ' ', journal)\n    return journal",
            "def _get_journal(inl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    journal = ''\n    for line in inl:\n        if re.search('\\\\AJRNL', line):\n            journal += line[19:72].lower()\n    journal = re.sub('\\\\s\\\\s+', ' ', journal)\n    return journal"
        ]
    },
    {
        "func_name": "_get_references",
        "original": "def _get_references(inl):\n    references = []\n    actref = ''\n    for line in inl:\n        if re.search('\\\\AREMARK   1', line):\n            if re.search('\\\\AREMARK   1 REFERENCE', line):\n                if actref != '':\n                    actref = re.sub('\\\\s\\\\s+', ' ', actref)\n                    if actref != ' ':\n                        references.append(actref)\n                    actref = ''\n            else:\n                actref += line[19:72].lower()\n    if actref != '':\n        actref = re.sub('\\\\s\\\\s+', ' ', actref)\n        if actref != ' ':\n            references.append(actref)\n    return references",
        "mutated": [
            "def _get_references(inl):\n    if False:\n        i = 10\n    references = []\n    actref = ''\n    for line in inl:\n        if re.search('\\\\AREMARK   1', line):\n            if re.search('\\\\AREMARK   1 REFERENCE', line):\n                if actref != '':\n                    actref = re.sub('\\\\s\\\\s+', ' ', actref)\n                    if actref != ' ':\n                        references.append(actref)\n                    actref = ''\n            else:\n                actref += line[19:72].lower()\n    if actref != '':\n        actref = re.sub('\\\\s\\\\s+', ' ', actref)\n        if actref != ' ':\n            references.append(actref)\n    return references",
            "def _get_references(inl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    references = []\n    actref = ''\n    for line in inl:\n        if re.search('\\\\AREMARK   1', line):\n            if re.search('\\\\AREMARK   1 REFERENCE', line):\n                if actref != '':\n                    actref = re.sub('\\\\s\\\\s+', ' ', actref)\n                    if actref != ' ':\n                        references.append(actref)\n                    actref = ''\n            else:\n                actref += line[19:72].lower()\n    if actref != '':\n        actref = re.sub('\\\\s\\\\s+', ' ', actref)\n        if actref != ' ':\n            references.append(actref)\n    return references",
            "def _get_references(inl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    references = []\n    actref = ''\n    for line in inl:\n        if re.search('\\\\AREMARK   1', line):\n            if re.search('\\\\AREMARK   1 REFERENCE', line):\n                if actref != '':\n                    actref = re.sub('\\\\s\\\\s+', ' ', actref)\n                    if actref != ' ':\n                        references.append(actref)\n                    actref = ''\n            else:\n                actref += line[19:72].lower()\n    if actref != '':\n        actref = re.sub('\\\\s\\\\s+', ' ', actref)\n        if actref != ' ':\n            references.append(actref)\n    return references",
            "def _get_references(inl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    references = []\n    actref = ''\n    for line in inl:\n        if re.search('\\\\AREMARK   1', line):\n            if re.search('\\\\AREMARK   1 REFERENCE', line):\n                if actref != '':\n                    actref = re.sub('\\\\s\\\\s+', ' ', actref)\n                    if actref != ' ':\n                        references.append(actref)\n                    actref = ''\n            else:\n                actref += line[19:72].lower()\n    if actref != '':\n        actref = re.sub('\\\\s\\\\s+', ' ', actref)\n        if actref != ' ':\n            references.append(actref)\n    return references",
            "def _get_references(inl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    references = []\n    actref = ''\n    for line in inl:\n        if re.search('\\\\AREMARK   1', line):\n            if re.search('\\\\AREMARK   1 REFERENCE', line):\n                if actref != '':\n                    actref = re.sub('\\\\s\\\\s+', ' ', actref)\n                    if actref != ' ':\n                        references.append(actref)\n                    actref = ''\n            else:\n                actref += line[19:72].lower()\n    if actref != '':\n        actref = re.sub('\\\\s\\\\s+', ' ', actref)\n        if actref != ' ':\n            references.append(actref)\n    return references"
        ]
    },
    {
        "func_name": "_format_date",
        "original": "def _format_date(pdb_date):\n    \"\"\"Convert dates from DD-Mon-YY to YYYY-MM-DD format (PRIVATE).\"\"\"\n    date = ''\n    year = int(pdb_date[7:])\n    if year < 50:\n        century = 2000\n    else:\n        century = 1900\n    date = str(century + year) + '-'\n    all_months = ['xxx', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    month = str(all_months.index(pdb_date[3:6]))\n    if len(month) == 1:\n        month = '0' + month\n    date = date + month + '-' + pdb_date[:2]\n    return date",
        "mutated": [
            "def _format_date(pdb_date):\n    if False:\n        i = 10\n    'Convert dates from DD-Mon-YY to YYYY-MM-DD format (PRIVATE).'\n    date = ''\n    year = int(pdb_date[7:])\n    if year < 50:\n        century = 2000\n    else:\n        century = 1900\n    date = str(century + year) + '-'\n    all_months = ['xxx', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    month = str(all_months.index(pdb_date[3:6]))\n    if len(month) == 1:\n        month = '0' + month\n    date = date + month + '-' + pdb_date[:2]\n    return date",
            "def _format_date(pdb_date):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert dates from DD-Mon-YY to YYYY-MM-DD format (PRIVATE).'\n    date = ''\n    year = int(pdb_date[7:])\n    if year < 50:\n        century = 2000\n    else:\n        century = 1900\n    date = str(century + year) + '-'\n    all_months = ['xxx', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    month = str(all_months.index(pdb_date[3:6]))\n    if len(month) == 1:\n        month = '0' + month\n    date = date + month + '-' + pdb_date[:2]\n    return date",
            "def _format_date(pdb_date):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert dates from DD-Mon-YY to YYYY-MM-DD format (PRIVATE).'\n    date = ''\n    year = int(pdb_date[7:])\n    if year < 50:\n        century = 2000\n    else:\n        century = 1900\n    date = str(century + year) + '-'\n    all_months = ['xxx', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    month = str(all_months.index(pdb_date[3:6]))\n    if len(month) == 1:\n        month = '0' + month\n    date = date + month + '-' + pdb_date[:2]\n    return date",
            "def _format_date(pdb_date):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert dates from DD-Mon-YY to YYYY-MM-DD format (PRIVATE).'\n    date = ''\n    year = int(pdb_date[7:])\n    if year < 50:\n        century = 2000\n    else:\n        century = 1900\n    date = str(century + year) + '-'\n    all_months = ['xxx', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    month = str(all_months.index(pdb_date[3:6]))\n    if len(month) == 1:\n        month = '0' + month\n    date = date + month + '-' + pdb_date[:2]\n    return date",
            "def _format_date(pdb_date):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert dates from DD-Mon-YY to YYYY-MM-DD format (PRIVATE).'\n    date = ''\n    year = int(pdb_date[7:])\n    if year < 50:\n        century = 2000\n    else:\n        century = 1900\n    date = str(century + year) + '-'\n    all_months = ['xxx', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    month = str(all_months.index(pdb_date[3:6]))\n    if len(month) == 1:\n        month = '0' + month\n    date = date + month + '-' + pdb_date[:2]\n    return date"
        ]
    },
    {
        "func_name": "_chop_end_codes",
        "original": "def _chop_end_codes(line):\n    \"\"\"Chops lines ending with  '     1CSA  14' and the like (PRIVATE).\"\"\"\n    return re.sub('\\\\s\\\\s\\\\s\\\\s+[\\\\w]{4}.\\\\s+\\\\d*\\\\Z', '', line)",
        "mutated": [
            "def _chop_end_codes(line):\n    if False:\n        i = 10\n    \"Chops lines ending with  '     1CSA  14' and the like (PRIVATE).\"\n    return re.sub('\\\\s\\\\s\\\\s\\\\s+[\\\\w]{4}.\\\\s+\\\\d*\\\\Z', '', line)",
            "def _chop_end_codes(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Chops lines ending with  '     1CSA  14' and the like (PRIVATE).\"\n    return re.sub('\\\\s\\\\s\\\\s\\\\s+[\\\\w]{4}.\\\\s+\\\\d*\\\\Z', '', line)",
            "def _chop_end_codes(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Chops lines ending with  '     1CSA  14' and the like (PRIVATE).\"\n    return re.sub('\\\\s\\\\s\\\\s\\\\s+[\\\\w]{4}.\\\\s+\\\\d*\\\\Z', '', line)",
            "def _chop_end_codes(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Chops lines ending with  '     1CSA  14' and the like (PRIVATE).\"\n    return re.sub('\\\\s\\\\s\\\\s\\\\s+[\\\\w]{4}.\\\\s+\\\\d*\\\\Z', '', line)",
            "def _chop_end_codes(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Chops lines ending with  '     1CSA  14' and the like (PRIVATE).\"\n    return re.sub('\\\\s\\\\s\\\\s\\\\s+[\\\\w]{4}.\\\\s+\\\\d*\\\\Z', '', line)"
        ]
    },
    {
        "func_name": "_chop_end_misc",
        "original": "def _chop_end_misc(line):\n    \"\"\"Chops lines ending with  '     14-JUL-97  1CSA' and the like (PRIVATE).\"\"\"\n    return re.sub('\\\\s+\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d\\\\s+[1-9][0-9A-Z]{3}\\\\s*\\\\Z', '', line)",
        "mutated": [
            "def _chop_end_misc(line):\n    if False:\n        i = 10\n    \"Chops lines ending with  '     14-JUL-97  1CSA' and the like (PRIVATE).\"\n    return re.sub('\\\\s+\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d\\\\s+[1-9][0-9A-Z]{3}\\\\s*\\\\Z', '', line)",
            "def _chop_end_misc(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Chops lines ending with  '     14-JUL-97  1CSA' and the like (PRIVATE).\"\n    return re.sub('\\\\s+\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d\\\\s+[1-9][0-9A-Z]{3}\\\\s*\\\\Z', '', line)",
            "def _chop_end_misc(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Chops lines ending with  '     14-JUL-97  1CSA' and the like (PRIVATE).\"\n    return re.sub('\\\\s+\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d\\\\s+[1-9][0-9A-Z]{3}\\\\s*\\\\Z', '', line)",
            "def _chop_end_misc(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Chops lines ending with  '     14-JUL-97  1CSA' and the like (PRIVATE).\"\n    return re.sub('\\\\s+\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d\\\\s+[1-9][0-9A-Z]{3}\\\\s*\\\\Z', '', line)",
            "def _chop_end_misc(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Chops lines ending with  '     14-JUL-97  1CSA' and the like (PRIVATE).\"\n    return re.sub('\\\\s+\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d\\\\s+[1-9][0-9A-Z]{3}\\\\s*\\\\Z', '', line)"
        ]
    },
    {
        "func_name": "_nice_case",
        "original": "def _nice_case(line):\n    \"\"\"Make A Lowercase String With Capitals (PRIVATE).\"\"\"\n    line_lower = line.lower()\n    s = ''\n    i = 0\n    nextCap = 1\n    while i < len(line_lower):\n        c = line_lower[i]\n        if c >= 'a' and c <= 'z' and nextCap:\n            c = c.upper()\n            nextCap = 0\n        elif c in ' .,;:\\t-_':\n            nextCap = 1\n        s += c\n        i += 1\n    return s",
        "mutated": [
            "def _nice_case(line):\n    if False:\n        i = 10\n    'Make A Lowercase String With Capitals (PRIVATE).'\n    line_lower = line.lower()\n    s = ''\n    i = 0\n    nextCap = 1\n    while i < len(line_lower):\n        c = line_lower[i]\n        if c >= 'a' and c <= 'z' and nextCap:\n            c = c.upper()\n            nextCap = 0\n        elif c in ' .,;:\\t-_':\n            nextCap = 1\n        s += c\n        i += 1\n    return s",
            "def _nice_case(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Make A Lowercase String With Capitals (PRIVATE).'\n    line_lower = line.lower()\n    s = ''\n    i = 0\n    nextCap = 1\n    while i < len(line_lower):\n        c = line_lower[i]\n        if c >= 'a' and c <= 'z' and nextCap:\n            c = c.upper()\n            nextCap = 0\n        elif c in ' .,;:\\t-_':\n            nextCap = 1\n        s += c\n        i += 1\n    return s",
            "def _nice_case(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Make A Lowercase String With Capitals (PRIVATE).'\n    line_lower = line.lower()\n    s = ''\n    i = 0\n    nextCap = 1\n    while i < len(line_lower):\n        c = line_lower[i]\n        if c >= 'a' and c <= 'z' and nextCap:\n            c = c.upper()\n            nextCap = 0\n        elif c in ' .,;:\\t-_':\n            nextCap = 1\n        s += c\n        i += 1\n    return s",
            "def _nice_case(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Make A Lowercase String With Capitals (PRIVATE).'\n    line_lower = line.lower()\n    s = ''\n    i = 0\n    nextCap = 1\n    while i < len(line_lower):\n        c = line_lower[i]\n        if c >= 'a' and c <= 'z' and nextCap:\n            c = c.upper()\n            nextCap = 0\n        elif c in ' .,;:\\t-_':\n            nextCap = 1\n        s += c\n        i += 1\n    return s",
            "def _nice_case(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Make A Lowercase String With Capitals (PRIVATE).'\n    line_lower = line.lower()\n    s = ''\n    i = 0\n    nextCap = 1\n    while i < len(line_lower):\n        c = line_lower[i]\n        if c >= 'a' and c <= 'z' and nextCap:\n            c = c.upper()\n            nextCap = 0\n        elif c in ' .,;:\\t-_':\n            nextCap = 1\n        s += c\n        i += 1\n    return s"
        ]
    },
    {
        "func_name": "parse_pdb_header",
        "original": "def parse_pdb_header(infile):\n    \"\"\"Return the header lines of a pdb file as a dictionary.\n\n    Dictionary keys are: head, deposition_date, release_date, structure_method,\n    resolution, structure_reference, journal_reference, author and\n    compound.\n    \"\"\"\n    header = []\n    with File.as_handle(infile) as f:\n        for line in f:\n            record_type = line[0:6]\n            if record_type in ('ATOM  ', 'HETATM', 'MODEL '):\n                break\n            else:\n                header.append(line)\n    return _parse_pdb_header_list(header)",
        "mutated": [
            "def parse_pdb_header(infile):\n    if False:\n        i = 10\n    'Return the header lines of a pdb file as a dictionary.\\n\\n    Dictionary keys are: head, deposition_date, release_date, structure_method,\\n    resolution, structure_reference, journal_reference, author and\\n    compound.\\n    '\n    header = []\n    with File.as_handle(infile) as f:\n        for line in f:\n            record_type = line[0:6]\n            if record_type in ('ATOM  ', 'HETATM', 'MODEL '):\n                break\n            else:\n                header.append(line)\n    return _parse_pdb_header_list(header)",
            "def parse_pdb_header(infile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the header lines of a pdb file as a dictionary.\\n\\n    Dictionary keys are: head, deposition_date, release_date, structure_method,\\n    resolution, structure_reference, journal_reference, author and\\n    compound.\\n    '\n    header = []\n    with File.as_handle(infile) as f:\n        for line in f:\n            record_type = line[0:6]\n            if record_type in ('ATOM  ', 'HETATM', 'MODEL '):\n                break\n            else:\n                header.append(line)\n    return _parse_pdb_header_list(header)",
            "def parse_pdb_header(infile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the header lines of a pdb file as a dictionary.\\n\\n    Dictionary keys are: head, deposition_date, release_date, structure_method,\\n    resolution, structure_reference, journal_reference, author and\\n    compound.\\n    '\n    header = []\n    with File.as_handle(infile) as f:\n        for line in f:\n            record_type = line[0:6]\n            if record_type in ('ATOM  ', 'HETATM', 'MODEL '):\n                break\n            else:\n                header.append(line)\n    return _parse_pdb_header_list(header)",
            "def parse_pdb_header(infile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the header lines of a pdb file as a dictionary.\\n\\n    Dictionary keys are: head, deposition_date, release_date, structure_method,\\n    resolution, structure_reference, journal_reference, author and\\n    compound.\\n    '\n    header = []\n    with File.as_handle(infile) as f:\n        for line in f:\n            record_type = line[0:6]\n            if record_type in ('ATOM  ', 'HETATM', 'MODEL '):\n                break\n            else:\n                header.append(line)\n    return _parse_pdb_header_list(header)",
            "def parse_pdb_header(infile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the header lines of a pdb file as a dictionary.\\n\\n    Dictionary keys are: head, deposition_date, release_date, structure_method,\\n    resolution, structure_reference, journal_reference, author and\\n    compound.\\n    '\n    header = []\n    with File.as_handle(infile) as f:\n        for line in f:\n            record_type = line[0:6]\n            if record_type in ('ATOM  ', 'HETATM', 'MODEL '):\n                break\n            else:\n                header.append(line)\n    return _parse_pdb_header_list(header)"
        ]
    },
    {
        "func_name": "_parse_remark_465",
        "original": "def _parse_remark_465(line):\n    \"\"\"Parse missing residue remarks.\n\n    Returns a dictionary describing the missing residue.\n    The specification for REMARK 465 at\n    http://www.wwpdb.org/documentation/file-format-content/format33/remarks2.html#REMARK%20465\n    only gives templates, but does not say they have to be followed.\n    So we assume that not all pdb-files with a REMARK 465 can be understood.\n\n    Returns a dictionary with the following keys:\n    \"model\", \"res_name\", \"chain\", \"ssseq\", \"insertion\"\n    \"\"\"\n    if line:\n        assert line[0] != ' ' and line[-1] not in '\\n ', 'line has to be stripped'\n    pattern = re.compile('\\n        (\\\\d+\\\\s[\\\\sA-Z][\\\\sA-Z][A-Z] |   # Either model number + residue name\\n            [A-Z]{1,3})               # Or only residue name with 1 (RNA) to 3 letters\\n        \\\\s ([A-Za-z0-9])              # A single character chain\\n        \\\\s+(-?\\\\d+[A-Za-z]?)$          # Residue number: A digit followed by an optional\\n                                      # insertion code (Hetero-flags make no sense in\\n                                      # context with missing res)\\n        ', re.VERBOSE)\n    match = pattern.match(line)\n    if match is None:\n        return None\n    residue = {}\n    if ' ' in match.group(1):\n        (model, residue['res_name']) = match.group(1).split()\n        residue['model'] = int(model)\n    else:\n        residue['model'] = None\n        residue['res_name'] = match.group(1)\n    residue['chain'] = match.group(2)\n    try:\n        residue['ssseq'] = int(match.group(3))\n    except ValueError:\n        residue['insertion'] = match.group(3)[-1]\n        residue['ssseq'] = int(match.group(3)[:-1])\n    else:\n        residue['insertion'] = None\n    return residue",
        "mutated": [
            "def _parse_remark_465(line):\n    if False:\n        i = 10\n    'Parse missing residue remarks.\\n\\n    Returns a dictionary describing the missing residue.\\n    The specification for REMARK 465 at\\n    http://www.wwpdb.org/documentation/file-format-content/format33/remarks2.html#REMARK%20465\\n    only gives templates, but does not say they have to be followed.\\n    So we assume that not all pdb-files with a REMARK 465 can be understood.\\n\\n    Returns a dictionary with the following keys:\\n    \"model\", \"res_name\", \"chain\", \"ssseq\", \"insertion\"\\n    '\n    if line:\n        assert line[0] != ' ' and line[-1] not in '\\n ', 'line has to be stripped'\n    pattern = re.compile('\\n        (\\\\d+\\\\s[\\\\sA-Z][\\\\sA-Z][A-Z] |   # Either model number + residue name\\n            [A-Z]{1,3})               # Or only residue name with 1 (RNA) to 3 letters\\n        \\\\s ([A-Za-z0-9])              # A single character chain\\n        \\\\s+(-?\\\\d+[A-Za-z]?)$          # Residue number: A digit followed by an optional\\n                                      # insertion code (Hetero-flags make no sense in\\n                                      # context with missing res)\\n        ', re.VERBOSE)\n    match = pattern.match(line)\n    if match is None:\n        return None\n    residue = {}\n    if ' ' in match.group(1):\n        (model, residue['res_name']) = match.group(1).split()\n        residue['model'] = int(model)\n    else:\n        residue['model'] = None\n        residue['res_name'] = match.group(1)\n    residue['chain'] = match.group(2)\n    try:\n        residue['ssseq'] = int(match.group(3))\n    except ValueError:\n        residue['insertion'] = match.group(3)[-1]\n        residue['ssseq'] = int(match.group(3)[:-1])\n    else:\n        residue['insertion'] = None\n    return residue",
            "def _parse_remark_465(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Parse missing residue remarks.\\n\\n    Returns a dictionary describing the missing residue.\\n    The specification for REMARK 465 at\\n    http://www.wwpdb.org/documentation/file-format-content/format33/remarks2.html#REMARK%20465\\n    only gives templates, but does not say they have to be followed.\\n    So we assume that not all pdb-files with a REMARK 465 can be understood.\\n\\n    Returns a dictionary with the following keys:\\n    \"model\", \"res_name\", \"chain\", \"ssseq\", \"insertion\"\\n    '\n    if line:\n        assert line[0] != ' ' and line[-1] not in '\\n ', 'line has to be stripped'\n    pattern = re.compile('\\n        (\\\\d+\\\\s[\\\\sA-Z][\\\\sA-Z][A-Z] |   # Either model number + residue name\\n            [A-Z]{1,3})               # Or only residue name with 1 (RNA) to 3 letters\\n        \\\\s ([A-Za-z0-9])              # A single character chain\\n        \\\\s+(-?\\\\d+[A-Za-z]?)$          # Residue number: A digit followed by an optional\\n                                      # insertion code (Hetero-flags make no sense in\\n                                      # context with missing res)\\n        ', re.VERBOSE)\n    match = pattern.match(line)\n    if match is None:\n        return None\n    residue = {}\n    if ' ' in match.group(1):\n        (model, residue['res_name']) = match.group(1).split()\n        residue['model'] = int(model)\n    else:\n        residue['model'] = None\n        residue['res_name'] = match.group(1)\n    residue['chain'] = match.group(2)\n    try:\n        residue['ssseq'] = int(match.group(3))\n    except ValueError:\n        residue['insertion'] = match.group(3)[-1]\n        residue['ssseq'] = int(match.group(3)[:-1])\n    else:\n        residue['insertion'] = None\n    return residue",
            "def _parse_remark_465(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Parse missing residue remarks.\\n\\n    Returns a dictionary describing the missing residue.\\n    The specification for REMARK 465 at\\n    http://www.wwpdb.org/documentation/file-format-content/format33/remarks2.html#REMARK%20465\\n    only gives templates, but does not say they have to be followed.\\n    So we assume that not all pdb-files with a REMARK 465 can be understood.\\n\\n    Returns a dictionary with the following keys:\\n    \"model\", \"res_name\", \"chain\", \"ssseq\", \"insertion\"\\n    '\n    if line:\n        assert line[0] != ' ' and line[-1] not in '\\n ', 'line has to be stripped'\n    pattern = re.compile('\\n        (\\\\d+\\\\s[\\\\sA-Z][\\\\sA-Z][A-Z] |   # Either model number + residue name\\n            [A-Z]{1,3})               # Or only residue name with 1 (RNA) to 3 letters\\n        \\\\s ([A-Za-z0-9])              # A single character chain\\n        \\\\s+(-?\\\\d+[A-Za-z]?)$          # Residue number: A digit followed by an optional\\n                                      # insertion code (Hetero-flags make no sense in\\n                                      # context with missing res)\\n        ', re.VERBOSE)\n    match = pattern.match(line)\n    if match is None:\n        return None\n    residue = {}\n    if ' ' in match.group(1):\n        (model, residue['res_name']) = match.group(1).split()\n        residue['model'] = int(model)\n    else:\n        residue['model'] = None\n        residue['res_name'] = match.group(1)\n    residue['chain'] = match.group(2)\n    try:\n        residue['ssseq'] = int(match.group(3))\n    except ValueError:\n        residue['insertion'] = match.group(3)[-1]\n        residue['ssseq'] = int(match.group(3)[:-1])\n    else:\n        residue['insertion'] = None\n    return residue",
            "def _parse_remark_465(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Parse missing residue remarks.\\n\\n    Returns a dictionary describing the missing residue.\\n    The specification for REMARK 465 at\\n    http://www.wwpdb.org/documentation/file-format-content/format33/remarks2.html#REMARK%20465\\n    only gives templates, but does not say they have to be followed.\\n    So we assume that not all pdb-files with a REMARK 465 can be understood.\\n\\n    Returns a dictionary with the following keys:\\n    \"model\", \"res_name\", \"chain\", \"ssseq\", \"insertion\"\\n    '\n    if line:\n        assert line[0] != ' ' and line[-1] not in '\\n ', 'line has to be stripped'\n    pattern = re.compile('\\n        (\\\\d+\\\\s[\\\\sA-Z][\\\\sA-Z][A-Z] |   # Either model number + residue name\\n            [A-Z]{1,3})               # Or only residue name with 1 (RNA) to 3 letters\\n        \\\\s ([A-Za-z0-9])              # A single character chain\\n        \\\\s+(-?\\\\d+[A-Za-z]?)$          # Residue number: A digit followed by an optional\\n                                      # insertion code (Hetero-flags make no sense in\\n                                      # context with missing res)\\n        ', re.VERBOSE)\n    match = pattern.match(line)\n    if match is None:\n        return None\n    residue = {}\n    if ' ' in match.group(1):\n        (model, residue['res_name']) = match.group(1).split()\n        residue['model'] = int(model)\n    else:\n        residue['model'] = None\n        residue['res_name'] = match.group(1)\n    residue['chain'] = match.group(2)\n    try:\n        residue['ssseq'] = int(match.group(3))\n    except ValueError:\n        residue['insertion'] = match.group(3)[-1]\n        residue['ssseq'] = int(match.group(3)[:-1])\n    else:\n        residue['insertion'] = None\n    return residue",
            "def _parse_remark_465(line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Parse missing residue remarks.\\n\\n    Returns a dictionary describing the missing residue.\\n    The specification for REMARK 465 at\\n    http://www.wwpdb.org/documentation/file-format-content/format33/remarks2.html#REMARK%20465\\n    only gives templates, but does not say they have to be followed.\\n    So we assume that not all pdb-files with a REMARK 465 can be understood.\\n\\n    Returns a dictionary with the following keys:\\n    \"model\", \"res_name\", \"chain\", \"ssseq\", \"insertion\"\\n    '\n    if line:\n        assert line[0] != ' ' and line[-1] not in '\\n ', 'line has to be stripped'\n    pattern = re.compile('\\n        (\\\\d+\\\\s[\\\\sA-Z][\\\\sA-Z][A-Z] |   # Either model number + residue name\\n            [A-Z]{1,3})               # Or only residue name with 1 (RNA) to 3 letters\\n        \\\\s ([A-Za-z0-9])              # A single character chain\\n        \\\\s+(-?\\\\d+[A-Za-z]?)$          # Residue number: A digit followed by an optional\\n                                      # insertion code (Hetero-flags make no sense in\\n                                      # context with missing res)\\n        ', re.VERBOSE)\n    match = pattern.match(line)\n    if match is None:\n        return None\n    residue = {}\n    if ' ' in match.group(1):\n        (model, residue['res_name']) = match.group(1).split()\n        residue['model'] = int(model)\n    else:\n        residue['model'] = None\n        residue['res_name'] = match.group(1)\n    residue['chain'] = match.group(2)\n    try:\n        residue['ssseq'] = int(match.group(3))\n    except ValueError:\n        residue['insertion'] = match.group(3)[-1]\n        residue['ssseq'] = int(match.group(3)[:-1])\n    else:\n        residue['insertion'] = None\n    return residue"
        ]
    },
    {
        "func_name": "_parse_pdb_header_list",
        "original": "def _parse_pdb_header_list(header):\n    pdbh_dict = {'name': '', 'head': '', 'idcode': '', 'deposition_date': '1909-01-08', 'release_date': '1909-01-08', 'structure_method': 'unknown', 'resolution': None, 'structure_reference': 'unknown', 'journal_reference': 'unknown', 'author': '', 'compound': {'1': {'misc': ''}}, 'source': {'1': {'misc': ''}}, 'has_missing_residues': False, 'missing_residues': []}\n    pdbh_dict['structure_reference'] = _get_references(header)\n    pdbh_dict['journal_reference'] = _get_journal(header)\n    comp_molid = '1'\n    last_comp_key = 'misc'\n    last_src_key = 'misc'\n    for hh in header:\n        h = re.sub('[\\\\s\\\\n\\\\r]*\\\\Z', '', hh)\n        key = h[:6].strip()\n        tail = h[10:].strip()\n        if key == 'TITLE':\n            name = _chop_end_codes(tail).lower()\n            pdbh_dict['name'] = ' '.join([pdbh_dict['name'], name]).strip()\n        elif key == 'HEADER':\n            rr = re.search('\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d', tail)\n            if rr is not None:\n                pdbh_dict['deposition_date'] = _format_date(_nice_case(rr.group()))\n            rr = re.search('\\\\s+([1-9][0-9A-Z]{3})\\\\s*\\\\Z', tail)\n            if rr is not None:\n                pdbh_dict['idcode'] = rr.group(1)\n            head = _chop_end_misc(tail).lower()\n            pdbh_dict['head'] = head\n        elif key == 'COMPND':\n            tt = re.sub('\\\\;\\\\s*\\\\Z', '', _chop_end_codes(tail)).lower()\n            rec = re.search('\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+', tt)\n            if rec:\n                pdbh_dict['compound'][comp_molid]['ec_number'] = rec.group()\n                tt = re.sub('\\\\((e\\\\.c\\\\.)*\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\)', '', tt)\n            tok = tt.split(':')\n            if len(tok) >= 2:\n                ckey = tok[0]\n                cval = re.sub('\\\\A\\\\s*', '', tok[1])\n                if ckey == 'mol_id':\n                    pdbh_dict['compound'][cval] = {'misc': ''}\n                    comp_molid = cval\n                    last_comp_key = 'misc'\n                else:\n                    pdbh_dict['compound'][comp_molid][ckey] = cval\n                    last_comp_key = ckey\n            else:\n                pdbh_dict['compound'][comp_molid][last_comp_key] += tok[0] + ' '\n        elif key == 'SOURCE':\n            tt = re.sub('\\\\;\\\\s*\\\\Z', '', _chop_end_codes(tail)).lower()\n            tok = tt.split(':')\n            if len(tok) >= 2:\n                ckey = tok[0]\n                cval = re.sub('\\\\A\\\\s*', '', tok[1])\n                if ckey == 'mol_id':\n                    pdbh_dict['source'][cval] = {'misc': ''}\n                    comp_molid = cval\n                    last_src_key = 'misc'\n                else:\n                    pdbh_dict['source'][comp_molid][ckey] = cval\n                    last_src_key = ckey\n            else:\n                pdbh_dict['source'][comp_molid][last_src_key] += tok[0] + ' '\n        elif key == 'KEYWDS':\n            kwd = _chop_end_codes(tail).lower()\n            if 'keywords' in pdbh_dict:\n                pdbh_dict['keywords'] += ' ' + kwd\n            else:\n                pdbh_dict['keywords'] = kwd\n        elif key == 'EXPDTA':\n            expd = _chop_end_codes(tail)\n            expd = re.sub('\\\\s\\\\s\\\\s\\\\s\\\\s\\\\s\\\\s.*\\\\Z', '', expd)\n            pdbh_dict['structure_method'] = expd.lower()\n        elif key == 'CAVEAT':\n            pass\n        elif key == 'REVDAT':\n            rr = re.search('\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d', tail)\n            if rr is not None:\n                pdbh_dict['release_date'] = _format_date(_nice_case(rr.group()))\n        elif key == 'JRNL':\n            if 'journal' in pdbh_dict:\n                pdbh_dict['journal'] += tail\n            else:\n                pdbh_dict['journal'] = tail\n        elif key == 'AUTHOR':\n            auth = _nice_case(_chop_end_codes(tail))\n            if 'author' in pdbh_dict:\n                pdbh_dict['author'] += auth\n            else:\n                pdbh_dict['author'] = auth\n        elif key == 'REMARK':\n            if re.search('REMARK   2 RESOLUTION.', hh):\n                r = _chop_end_codes(re.sub('REMARK   2 RESOLUTION.', '', hh))\n                r = re.sub('\\\\s+ANGSTROM.*', '', r)\n                try:\n                    pdbh_dict['resolution'] = float(r)\n                except ValueError:\n                    pdbh_dict['resolution'] = None\n            elif hh.startswith('REMARK 465'):\n                if tail:\n                    pdbh_dict['has_missing_residues'] = True\n                    missing_res_info = _parse_remark_465(tail)\n                    if missing_res_info:\n                        pdbh_dict['missing_residues'].append(missing_res_info)\n            elif hh.startswith('REMARK  99 ASTRAL'):\n                if tail:\n                    remark_99_keyval = tail.replace('ASTRAL ', '').split(': ')\n                    if isinstance(remark_99_keyval, list) and len(remark_99_keyval) == 2:\n                        if 'astral' not in pdbh_dict:\n                            pdbh_dict['astral'] = {remark_99_keyval[0]: remark_99_keyval[1]}\n                        else:\n                            pdbh_dict['astral'][remark_99_keyval[0]] = remark_99_keyval[1]\n        else:\n            pass\n    if pdbh_dict['structure_method'] == 'unknown':\n        res = pdbh_dict['resolution']\n        if res is not None and res > 0.0:\n            pdbh_dict['structure_method'] = 'x-ray diffraction'\n    return pdbh_dict",
        "mutated": [
            "def _parse_pdb_header_list(header):\n    if False:\n        i = 10\n    pdbh_dict = {'name': '', 'head': '', 'idcode': '', 'deposition_date': '1909-01-08', 'release_date': '1909-01-08', 'structure_method': 'unknown', 'resolution': None, 'structure_reference': 'unknown', 'journal_reference': 'unknown', 'author': '', 'compound': {'1': {'misc': ''}}, 'source': {'1': {'misc': ''}}, 'has_missing_residues': False, 'missing_residues': []}\n    pdbh_dict['structure_reference'] = _get_references(header)\n    pdbh_dict['journal_reference'] = _get_journal(header)\n    comp_molid = '1'\n    last_comp_key = 'misc'\n    last_src_key = 'misc'\n    for hh in header:\n        h = re.sub('[\\\\s\\\\n\\\\r]*\\\\Z', '', hh)\n        key = h[:6].strip()\n        tail = h[10:].strip()\n        if key == 'TITLE':\n            name = _chop_end_codes(tail).lower()\n            pdbh_dict['name'] = ' '.join([pdbh_dict['name'], name]).strip()\n        elif key == 'HEADER':\n            rr = re.search('\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d', tail)\n            if rr is not None:\n                pdbh_dict['deposition_date'] = _format_date(_nice_case(rr.group()))\n            rr = re.search('\\\\s+([1-9][0-9A-Z]{3})\\\\s*\\\\Z', tail)\n            if rr is not None:\n                pdbh_dict['idcode'] = rr.group(1)\n            head = _chop_end_misc(tail).lower()\n            pdbh_dict['head'] = head\n        elif key == 'COMPND':\n            tt = re.sub('\\\\;\\\\s*\\\\Z', '', _chop_end_codes(tail)).lower()\n            rec = re.search('\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+', tt)\n            if rec:\n                pdbh_dict['compound'][comp_molid]['ec_number'] = rec.group()\n                tt = re.sub('\\\\((e\\\\.c\\\\.)*\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\)', '', tt)\n            tok = tt.split(':')\n            if len(tok) >= 2:\n                ckey = tok[0]\n                cval = re.sub('\\\\A\\\\s*', '', tok[1])\n                if ckey == 'mol_id':\n                    pdbh_dict['compound'][cval] = {'misc': ''}\n                    comp_molid = cval\n                    last_comp_key = 'misc'\n                else:\n                    pdbh_dict['compound'][comp_molid][ckey] = cval\n                    last_comp_key = ckey\n            else:\n                pdbh_dict['compound'][comp_molid][last_comp_key] += tok[0] + ' '\n        elif key == 'SOURCE':\n            tt = re.sub('\\\\;\\\\s*\\\\Z', '', _chop_end_codes(tail)).lower()\n            tok = tt.split(':')\n            if len(tok) >= 2:\n                ckey = tok[0]\n                cval = re.sub('\\\\A\\\\s*', '', tok[1])\n                if ckey == 'mol_id':\n                    pdbh_dict['source'][cval] = {'misc': ''}\n                    comp_molid = cval\n                    last_src_key = 'misc'\n                else:\n                    pdbh_dict['source'][comp_molid][ckey] = cval\n                    last_src_key = ckey\n            else:\n                pdbh_dict['source'][comp_molid][last_src_key] += tok[0] + ' '\n        elif key == 'KEYWDS':\n            kwd = _chop_end_codes(tail).lower()\n            if 'keywords' in pdbh_dict:\n                pdbh_dict['keywords'] += ' ' + kwd\n            else:\n                pdbh_dict['keywords'] = kwd\n        elif key == 'EXPDTA':\n            expd = _chop_end_codes(tail)\n            expd = re.sub('\\\\s\\\\s\\\\s\\\\s\\\\s\\\\s\\\\s.*\\\\Z', '', expd)\n            pdbh_dict['structure_method'] = expd.lower()\n        elif key == 'CAVEAT':\n            pass\n        elif key == 'REVDAT':\n            rr = re.search('\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d', tail)\n            if rr is not None:\n                pdbh_dict['release_date'] = _format_date(_nice_case(rr.group()))\n        elif key == 'JRNL':\n            if 'journal' in pdbh_dict:\n                pdbh_dict['journal'] += tail\n            else:\n                pdbh_dict['journal'] = tail\n        elif key == 'AUTHOR':\n            auth = _nice_case(_chop_end_codes(tail))\n            if 'author' in pdbh_dict:\n                pdbh_dict['author'] += auth\n            else:\n                pdbh_dict['author'] = auth\n        elif key == 'REMARK':\n            if re.search('REMARK   2 RESOLUTION.', hh):\n                r = _chop_end_codes(re.sub('REMARK   2 RESOLUTION.', '', hh))\n                r = re.sub('\\\\s+ANGSTROM.*', '', r)\n                try:\n                    pdbh_dict['resolution'] = float(r)\n                except ValueError:\n                    pdbh_dict['resolution'] = None\n            elif hh.startswith('REMARK 465'):\n                if tail:\n                    pdbh_dict['has_missing_residues'] = True\n                    missing_res_info = _parse_remark_465(tail)\n                    if missing_res_info:\n                        pdbh_dict['missing_residues'].append(missing_res_info)\n            elif hh.startswith('REMARK  99 ASTRAL'):\n                if tail:\n                    remark_99_keyval = tail.replace('ASTRAL ', '').split(': ')\n                    if isinstance(remark_99_keyval, list) and len(remark_99_keyval) == 2:\n                        if 'astral' not in pdbh_dict:\n                            pdbh_dict['astral'] = {remark_99_keyval[0]: remark_99_keyval[1]}\n                        else:\n                            pdbh_dict['astral'][remark_99_keyval[0]] = remark_99_keyval[1]\n        else:\n            pass\n    if pdbh_dict['structure_method'] == 'unknown':\n        res = pdbh_dict['resolution']\n        if res is not None and res > 0.0:\n            pdbh_dict['structure_method'] = 'x-ray diffraction'\n    return pdbh_dict",
            "def _parse_pdb_header_list(header):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pdbh_dict = {'name': '', 'head': '', 'idcode': '', 'deposition_date': '1909-01-08', 'release_date': '1909-01-08', 'structure_method': 'unknown', 'resolution': None, 'structure_reference': 'unknown', 'journal_reference': 'unknown', 'author': '', 'compound': {'1': {'misc': ''}}, 'source': {'1': {'misc': ''}}, 'has_missing_residues': False, 'missing_residues': []}\n    pdbh_dict['structure_reference'] = _get_references(header)\n    pdbh_dict['journal_reference'] = _get_journal(header)\n    comp_molid = '1'\n    last_comp_key = 'misc'\n    last_src_key = 'misc'\n    for hh in header:\n        h = re.sub('[\\\\s\\\\n\\\\r]*\\\\Z', '', hh)\n        key = h[:6].strip()\n        tail = h[10:].strip()\n        if key == 'TITLE':\n            name = _chop_end_codes(tail).lower()\n            pdbh_dict['name'] = ' '.join([pdbh_dict['name'], name]).strip()\n        elif key == 'HEADER':\n            rr = re.search('\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d', tail)\n            if rr is not None:\n                pdbh_dict['deposition_date'] = _format_date(_nice_case(rr.group()))\n            rr = re.search('\\\\s+([1-9][0-9A-Z]{3})\\\\s*\\\\Z', tail)\n            if rr is not None:\n                pdbh_dict['idcode'] = rr.group(1)\n            head = _chop_end_misc(tail).lower()\n            pdbh_dict['head'] = head\n        elif key == 'COMPND':\n            tt = re.sub('\\\\;\\\\s*\\\\Z', '', _chop_end_codes(tail)).lower()\n            rec = re.search('\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+', tt)\n            if rec:\n                pdbh_dict['compound'][comp_molid]['ec_number'] = rec.group()\n                tt = re.sub('\\\\((e\\\\.c\\\\.)*\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\)', '', tt)\n            tok = tt.split(':')\n            if len(tok) >= 2:\n                ckey = tok[0]\n                cval = re.sub('\\\\A\\\\s*', '', tok[1])\n                if ckey == 'mol_id':\n                    pdbh_dict['compound'][cval] = {'misc': ''}\n                    comp_molid = cval\n                    last_comp_key = 'misc'\n                else:\n                    pdbh_dict['compound'][comp_molid][ckey] = cval\n                    last_comp_key = ckey\n            else:\n                pdbh_dict['compound'][comp_molid][last_comp_key] += tok[0] + ' '\n        elif key == 'SOURCE':\n            tt = re.sub('\\\\;\\\\s*\\\\Z', '', _chop_end_codes(tail)).lower()\n            tok = tt.split(':')\n            if len(tok) >= 2:\n                ckey = tok[0]\n                cval = re.sub('\\\\A\\\\s*', '', tok[1])\n                if ckey == 'mol_id':\n                    pdbh_dict['source'][cval] = {'misc': ''}\n                    comp_molid = cval\n                    last_src_key = 'misc'\n                else:\n                    pdbh_dict['source'][comp_molid][ckey] = cval\n                    last_src_key = ckey\n            else:\n                pdbh_dict['source'][comp_molid][last_src_key] += tok[0] + ' '\n        elif key == 'KEYWDS':\n            kwd = _chop_end_codes(tail).lower()\n            if 'keywords' in pdbh_dict:\n                pdbh_dict['keywords'] += ' ' + kwd\n            else:\n                pdbh_dict['keywords'] = kwd\n        elif key == 'EXPDTA':\n            expd = _chop_end_codes(tail)\n            expd = re.sub('\\\\s\\\\s\\\\s\\\\s\\\\s\\\\s\\\\s.*\\\\Z', '', expd)\n            pdbh_dict['structure_method'] = expd.lower()\n        elif key == 'CAVEAT':\n            pass\n        elif key == 'REVDAT':\n            rr = re.search('\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d', tail)\n            if rr is not None:\n                pdbh_dict['release_date'] = _format_date(_nice_case(rr.group()))\n        elif key == 'JRNL':\n            if 'journal' in pdbh_dict:\n                pdbh_dict['journal'] += tail\n            else:\n                pdbh_dict['journal'] = tail\n        elif key == 'AUTHOR':\n            auth = _nice_case(_chop_end_codes(tail))\n            if 'author' in pdbh_dict:\n                pdbh_dict['author'] += auth\n            else:\n                pdbh_dict['author'] = auth\n        elif key == 'REMARK':\n            if re.search('REMARK   2 RESOLUTION.', hh):\n                r = _chop_end_codes(re.sub('REMARK   2 RESOLUTION.', '', hh))\n                r = re.sub('\\\\s+ANGSTROM.*', '', r)\n                try:\n                    pdbh_dict['resolution'] = float(r)\n                except ValueError:\n                    pdbh_dict['resolution'] = None\n            elif hh.startswith('REMARK 465'):\n                if tail:\n                    pdbh_dict['has_missing_residues'] = True\n                    missing_res_info = _parse_remark_465(tail)\n                    if missing_res_info:\n                        pdbh_dict['missing_residues'].append(missing_res_info)\n            elif hh.startswith('REMARK  99 ASTRAL'):\n                if tail:\n                    remark_99_keyval = tail.replace('ASTRAL ', '').split(': ')\n                    if isinstance(remark_99_keyval, list) and len(remark_99_keyval) == 2:\n                        if 'astral' not in pdbh_dict:\n                            pdbh_dict['astral'] = {remark_99_keyval[0]: remark_99_keyval[1]}\n                        else:\n                            pdbh_dict['astral'][remark_99_keyval[0]] = remark_99_keyval[1]\n        else:\n            pass\n    if pdbh_dict['structure_method'] == 'unknown':\n        res = pdbh_dict['resolution']\n        if res is not None and res > 0.0:\n            pdbh_dict['structure_method'] = 'x-ray diffraction'\n    return pdbh_dict",
            "def _parse_pdb_header_list(header):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pdbh_dict = {'name': '', 'head': '', 'idcode': '', 'deposition_date': '1909-01-08', 'release_date': '1909-01-08', 'structure_method': 'unknown', 'resolution': None, 'structure_reference': 'unknown', 'journal_reference': 'unknown', 'author': '', 'compound': {'1': {'misc': ''}}, 'source': {'1': {'misc': ''}}, 'has_missing_residues': False, 'missing_residues': []}\n    pdbh_dict['structure_reference'] = _get_references(header)\n    pdbh_dict['journal_reference'] = _get_journal(header)\n    comp_molid = '1'\n    last_comp_key = 'misc'\n    last_src_key = 'misc'\n    for hh in header:\n        h = re.sub('[\\\\s\\\\n\\\\r]*\\\\Z', '', hh)\n        key = h[:6].strip()\n        tail = h[10:].strip()\n        if key == 'TITLE':\n            name = _chop_end_codes(tail).lower()\n            pdbh_dict['name'] = ' '.join([pdbh_dict['name'], name]).strip()\n        elif key == 'HEADER':\n            rr = re.search('\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d', tail)\n            if rr is not None:\n                pdbh_dict['deposition_date'] = _format_date(_nice_case(rr.group()))\n            rr = re.search('\\\\s+([1-9][0-9A-Z]{3})\\\\s*\\\\Z', tail)\n            if rr is not None:\n                pdbh_dict['idcode'] = rr.group(1)\n            head = _chop_end_misc(tail).lower()\n            pdbh_dict['head'] = head\n        elif key == 'COMPND':\n            tt = re.sub('\\\\;\\\\s*\\\\Z', '', _chop_end_codes(tail)).lower()\n            rec = re.search('\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+', tt)\n            if rec:\n                pdbh_dict['compound'][comp_molid]['ec_number'] = rec.group()\n                tt = re.sub('\\\\((e\\\\.c\\\\.)*\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\)', '', tt)\n            tok = tt.split(':')\n            if len(tok) >= 2:\n                ckey = tok[0]\n                cval = re.sub('\\\\A\\\\s*', '', tok[1])\n                if ckey == 'mol_id':\n                    pdbh_dict['compound'][cval] = {'misc': ''}\n                    comp_molid = cval\n                    last_comp_key = 'misc'\n                else:\n                    pdbh_dict['compound'][comp_molid][ckey] = cval\n                    last_comp_key = ckey\n            else:\n                pdbh_dict['compound'][comp_molid][last_comp_key] += tok[0] + ' '\n        elif key == 'SOURCE':\n            tt = re.sub('\\\\;\\\\s*\\\\Z', '', _chop_end_codes(tail)).lower()\n            tok = tt.split(':')\n            if len(tok) >= 2:\n                ckey = tok[0]\n                cval = re.sub('\\\\A\\\\s*', '', tok[1])\n                if ckey == 'mol_id':\n                    pdbh_dict['source'][cval] = {'misc': ''}\n                    comp_molid = cval\n                    last_src_key = 'misc'\n                else:\n                    pdbh_dict['source'][comp_molid][ckey] = cval\n                    last_src_key = ckey\n            else:\n                pdbh_dict['source'][comp_molid][last_src_key] += tok[0] + ' '\n        elif key == 'KEYWDS':\n            kwd = _chop_end_codes(tail).lower()\n            if 'keywords' in pdbh_dict:\n                pdbh_dict['keywords'] += ' ' + kwd\n            else:\n                pdbh_dict['keywords'] = kwd\n        elif key == 'EXPDTA':\n            expd = _chop_end_codes(tail)\n            expd = re.sub('\\\\s\\\\s\\\\s\\\\s\\\\s\\\\s\\\\s.*\\\\Z', '', expd)\n            pdbh_dict['structure_method'] = expd.lower()\n        elif key == 'CAVEAT':\n            pass\n        elif key == 'REVDAT':\n            rr = re.search('\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d', tail)\n            if rr is not None:\n                pdbh_dict['release_date'] = _format_date(_nice_case(rr.group()))\n        elif key == 'JRNL':\n            if 'journal' in pdbh_dict:\n                pdbh_dict['journal'] += tail\n            else:\n                pdbh_dict['journal'] = tail\n        elif key == 'AUTHOR':\n            auth = _nice_case(_chop_end_codes(tail))\n            if 'author' in pdbh_dict:\n                pdbh_dict['author'] += auth\n            else:\n                pdbh_dict['author'] = auth\n        elif key == 'REMARK':\n            if re.search('REMARK   2 RESOLUTION.', hh):\n                r = _chop_end_codes(re.sub('REMARK   2 RESOLUTION.', '', hh))\n                r = re.sub('\\\\s+ANGSTROM.*', '', r)\n                try:\n                    pdbh_dict['resolution'] = float(r)\n                except ValueError:\n                    pdbh_dict['resolution'] = None\n            elif hh.startswith('REMARK 465'):\n                if tail:\n                    pdbh_dict['has_missing_residues'] = True\n                    missing_res_info = _parse_remark_465(tail)\n                    if missing_res_info:\n                        pdbh_dict['missing_residues'].append(missing_res_info)\n            elif hh.startswith('REMARK  99 ASTRAL'):\n                if tail:\n                    remark_99_keyval = tail.replace('ASTRAL ', '').split(': ')\n                    if isinstance(remark_99_keyval, list) and len(remark_99_keyval) == 2:\n                        if 'astral' not in pdbh_dict:\n                            pdbh_dict['astral'] = {remark_99_keyval[0]: remark_99_keyval[1]}\n                        else:\n                            pdbh_dict['astral'][remark_99_keyval[0]] = remark_99_keyval[1]\n        else:\n            pass\n    if pdbh_dict['structure_method'] == 'unknown':\n        res = pdbh_dict['resolution']\n        if res is not None and res > 0.0:\n            pdbh_dict['structure_method'] = 'x-ray diffraction'\n    return pdbh_dict",
            "def _parse_pdb_header_list(header):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pdbh_dict = {'name': '', 'head': '', 'idcode': '', 'deposition_date': '1909-01-08', 'release_date': '1909-01-08', 'structure_method': 'unknown', 'resolution': None, 'structure_reference': 'unknown', 'journal_reference': 'unknown', 'author': '', 'compound': {'1': {'misc': ''}}, 'source': {'1': {'misc': ''}}, 'has_missing_residues': False, 'missing_residues': []}\n    pdbh_dict['structure_reference'] = _get_references(header)\n    pdbh_dict['journal_reference'] = _get_journal(header)\n    comp_molid = '1'\n    last_comp_key = 'misc'\n    last_src_key = 'misc'\n    for hh in header:\n        h = re.sub('[\\\\s\\\\n\\\\r]*\\\\Z', '', hh)\n        key = h[:6].strip()\n        tail = h[10:].strip()\n        if key == 'TITLE':\n            name = _chop_end_codes(tail).lower()\n            pdbh_dict['name'] = ' '.join([pdbh_dict['name'], name]).strip()\n        elif key == 'HEADER':\n            rr = re.search('\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d', tail)\n            if rr is not None:\n                pdbh_dict['deposition_date'] = _format_date(_nice_case(rr.group()))\n            rr = re.search('\\\\s+([1-9][0-9A-Z]{3})\\\\s*\\\\Z', tail)\n            if rr is not None:\n                pdbh_dict['idcode'] = rr.group(1)\n            head = _chop_end_misc(tail).lower()\n            pdbh_dict['head'] = head\n        elif key == 'COMPND':\n            tt = re.sub('\\\\;\\\\s*\\\\Z', '', _chop_end_codes(tail)).lower()\n            rec = re.search('\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+', tt)\n            if rec:\n                pdbh_dict['compound'][comp_molid]['ec_number'] = rec.group()\n                tt = re.sub('\\\\((e\\\\.c\\\\.)*\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\)', '', tt)\n            tok = tt.split(':')\n            if len(tok) >= 2:\n                ckey = tok[0]\n                cval = re.sub('\\\\A\\\\s*', '', tok[1])\n                if ckey == 'mol_id':\n                    pdbh_dict['compound'][cval] = {'misc': ''}\n                    comp_molid = cval\n                    last_comp_key = 'misc'\n                else:\n                    pdbh_dict['compound'][comp_molid][ckey] = cval\n                    last_comp_key = ckey\n            else:\n                pdbh_dict['compound'][comp_molid][last_comp_key] += tok[0] + ' '\n        elif key == 'SOURCE':\n            tt = re.sub('\\\\;\\\\s*\\\\Z', '', _chop_end_codes(tail)).lower()\n            tok = tt.split(':')\n            if len(tok) >= 2:\n                ckey = tok[0]\n                cval = re.sub('\\\\A\\\\s*', '', tok[1])\n                if ckey == 'mol_id':\n                    pdbh_dict['source'][cval] = {'misc': ''}\n                    comp_molid = cval\n                    last_src_key = 'misc'\n                else:\n                    pdbh_dict['source'][comp_molid][ckey] = cval\n                    last_src_key = ckey\n            else:\n                pdbh_dict['source'][comp_molid][last_src_key] += tok[0] + ' '\n        elif key == 'KEYWDS':\n            kwd = _chop_end_codes(tail).lower()\n            if 'keywords' in pdbh_dict:\n                pdbh_dict['keywords'] += ' ' + kwd\n            else:\n                pdbh_dict['keywords'] = kwd\n        elif key == 'EXPDTA':\n            expd = _chop_end_codes(tail)\n            expd = re.sub('\\\\s\\\\s\\\\s\\\\s\\\\s\\\\s\\\\s.*\\\\Z', '', expd)\n            pdbh_dict['structure_method'] = expd.lower()\n        elif key == 'CAVEAT':\n            pass\n        elif key == 'REVDAT':\n            rr = re.search('\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d', tail)\n            if rr is not None:\n                pdbh_dict['release_date'] = _format_date(_nice_case(rr.group()))\n        elif key == 'JRNL':\n            if 'journal' in pdbh_dict:\n                pdbh_dict['journal'] += tail\n            else:\n                pdbh_dict['journal'] = tail\n        elif key == 'AUTHOR':\n            auth = _nice_case(_chop_end_codes(tail))\n            if 'author' in pdbh_dict:\n                pdbh_dict['author'] += auth\n            else:\n                pdbh_dict['author'] = auth\n        elif key == 'REMARK':\n            if re.search('REMARK   2 RESOLUTION.', hh):\n                r = _chop_end_codes(re.sub('REMARK   2 RESOLUTION.', '', hh))\n                r = re.sub('\\\\s+ANGSTROM.*', '', r)\n                try:\n                    pdbh_dict['resolution'] = float(r)\n                except ValueError:\n                    pdbh_dict['resolution'] = None\n            elif hh.startswith('REMARK 465'):\n                if tail:\n                    pdbh_dict['has_missing_residues'] = True\n                    missing_res_info = _parse_remark_465(tail)\n                    if missing_res_info:\n                        pdbh_dict['missing_residues'].append(missing_res_info)\n            elif hh.startswith('REMARK  99 ASTRAL'):\n                if tail:\n                    remark_99_keyval = tail.replace('ASTRAL ', '').split(': ')\n                    if isinstance(remark_99_keyval, list) and len(remark_99_keyval) == 2:\n                        if 'astral' not in pdbh_dict:\n                            pdbh_dict['astral'] = {remark_99_keyval[0]: remark_99_keyval[1]}\n                        else:\n                            pdbh_dict['astral'][remark_99_keyval[0]] = remark_99_keyval[1]\n        else:\n            pass\n    if pdbh_dict['structure_method'] == 'unknown':\n        res = pdbh_dict['resolution']\n        if res is not None and res > 0.0:\n            pdbh_dict['structure_method'] = 'x-ray diffraction'\n    return pdbh_dict",
            "def _parse_pdb_header_list(header):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pdbh_dict = {'name': '', 'head': '', 'idcode': '', 'deposition_date': '1909-01-08', 'release_date': '1909-01-08', 'structure_method': 'unknown', 'resolution': None, 'structure_reference': 'unknown', 'journal_reference': 'unknown', 'author': '', 'compound': {'1': {'misc': ''}}, 'source': {'1': {'misc': ''}}, 'has_missing_residues': False, 'missing_residues': []}\n    pdbh_dict['structure_reference'] = _get_references(header)\n    pdbh_dict['journal_reference'] = _get_journal(header)\n    comp_molid = '1'\n    last_comp_key = 'misc'\n    last_src_key = 'misc'\n    for hh in header:\n        h = re.sub('[\\\\s\\\\n\\\\r]*\\\\Z', '', hh)\n        key = h[:6].strip()\n        tail = h[10:].strip()\n        if key == 'TITLE':\n            name = _chop_end_codes(tail).lower()\n            pdbh_dict['name'] = ' '.join([pdbh_dict['name'], name]).strip()\n        elif key == 'HEADER':\n            rr = re.search('\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d', tail)\n            if rr is not None:\n                pdbh_dict['deposition_date'] = _format_date(_nice_case(rr.group()))\n            rr = re.search('\\\\s+([1-9][0-9A-Z]{3})\\\\s*\\\\Z', tail)\n            if rr is not None:\n                pdbh_dict['idcode'] = rr.group(1)\n            head = _chop_end_misc(tail).lower()\n            pdbh_dict['head'] = head\n        elif key == 'COMPND':\n            tt = re.sub('\\\\;\\\\s*\\\\Z', '', _chop_end_codes(tail)).lower()\n            rec = re.search('\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+', tt)\n            if rec:\n                pdbh_dict['compound'][comp_molid]['ec_number'] = rec.group()\n                tt = re.sub('\\\\((e\\\\.c\\\\.)*\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\)', '', tt)\n            tok = tt.split(':')\n            if len(tok) >= 2:\n                ckey = tok[0]\n                cval = re.sub('\\\\A\\\\s*', '', tok[1])\n                if ckey == 'mol_id':\n                    pdbh_dict['compound'][cval] = {'misc': ''}\n                    comp_molid = cval\n                    last_comp_key = 'misc'\n                else:\n                    pdbh_dict['compound'][comp_molid][ckey] = cval\n                    last_comp_key = ckey\n            else:\n                pdbh_dict['compound'][comp_molid][last_comp_key] += tok[0] + ' '\n        elif key == 'SOURCE':\n            tt = re.sub('\\\\;\\\\s*\\\\Z', '', _chop_end_codes(tail)).lower()\n            tok = tt.split(':')\n            if len(tok) >= 2:\n                ckey = tok[0]\n                cval = re.sub('\\\\A\\\\s*', '', tok[1])\n                if ckey == 'mol_id':\n                    pdbh_dict['source'][cval] = {'misc': ''}\n                    comp_molid = cval\n                    last_src_key = 'misc'\n                else:\n                    pdbh_dict['source'][comp_molid][ckey] = cval\n                    last_src_key = ckey\n            else:\n                pdbh_dict['source'][comp_molid][last_src_key] += tok[0] + ' '\n        elif key == 'KEYWDS':\n            kwd = _chop_end_codes(tail).lower()\n            if 'keywords' in pdbh_dict:\n                pdbh_dict['keywords'] += ' ' + kwd\n            else:\n                pdbh_dict['keywords'] = kwd\n        elif key == 'EXPDTA':\n            expd = _chop_end_codes(tail)\n            expd = re.sub('\\\\s\\\\s\\\\s\\\\s\\\\s\\\\s\\\\s.*\\\\Z', '', expd)\n            pdbh_dict['structure_method'] = expd.lower()\n        elif key == 'CAVEAT':\n            pass\n        elif key == 'REVDAT':\n            rr = re.search('\\\\d\\\\d-\\\\w\\\\w\\\\w-\\\\d\\\\d', tail)\n            if rr is not None:\n                pdbh_dict['release_date'] = _format_date(_nice_case(rr.group()))\n        elif key == 'JRNL':\n            if 'journal' in pdbh_dict:\n                pdbh_dict['journal'] += tail\n            else:\n                pdbh_dict['journal'] = tail\n        elif key == 'AUTHOR':\n            auth = _nice_case(_chop_end_codes(tail))\n            if 'author' in pdbh_dict:\n                pdbh_dict['author'] += auth\n            else:\n                pdbh_dict['author'] = auth\n        elif key == 'REMARK':\n            if re.search('REMARK   2 RESOLUTION.', hh):\n                r = _chop_end_codes(re.sub('REMARK   2 RESOLUTION.', '', hh))\n                r = re.sub('\\\\s+ANGSTROM.*', '', r)\n                try:\n                    pdbh_dict['resolution'] = float(r)\n                except ValueError:\n                    pdbh_dict['resolution'] = None\n            elif hh.startswith('REMARK 465'):\n                if tail:\n                    pdbh_dict['has_missing_residues'] = True\n                    missing_res_info = _parse_remark_465(tail)\n                    if missing_res_info:\n                        pdbh_dict['missing_residues'].append(missing_res_info)\n            elif hh.startswith('REMARK  99 ASTRAL'):\n                if tail:\n                    remark_99_keyval = tail.replace('ASTRAL ', '').split(': ')\n                    if isinstance(remark_99_keyval, list) and len(remark_99_keyval) == 2:\n                        if 'astral' not in pdbh_dict:\n                            pdbh_dict['astral'] = {remark_99_keyval[0]: remark_99_keyval[1]}\n                        else:\n                            pdbh_dict['astral'][remark_99_keyval[0]] = remark_99_keyval[1]\n        else:\n            pass\n    if pdbh_dict['structure_method'] == 'unknown':\n        res = pdbh_dict['resolution']\n        if res is not None and res > 0.0:\n            pdbh_dict['structure_method'] = 'x-ray diffraction'\n    return pdbh_dict"
        ]
    }
]