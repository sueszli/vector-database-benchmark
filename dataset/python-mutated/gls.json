[
    {
        "func_name": "_check_arma_estimator_kwargs",
        "original": "def _check_arma_estimator_kwargs(kwargs, method):\n    if kwargs:\n        raise ValueError(f'arma_estimator_kwargs not supported for method {method}')",
        "mutated": [
            "def _check_arma_estimator_kwargs(kwargs, method):\n    if False:\n        i = 10\n    if kwargs:\n        raise ValueError(f'arma_estimator_kwargs not supported for method {method}')",
            "def _check_arma_estimator_kwargs(kwargs, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if kwargs:\n        raise ValueError(f'arma_estimator_kwargs not supported for method {method}')",
            "def _check_arma_estimator_kwargs(kwargs, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if kwargs:\n        raise ValueError(f'arma_estimator_kwargs not supported for method {method}')",
            "def _check_arma_estimator_kwargs(kwargs, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if kwargs:\n        raise ValueError(f'arma_estimator_kwargs not supported for method {method}')",
            "def _check_arma_estimator_kwargs(kwargs, method):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if kwargs:\n        raise ValueError(f'arma_estimator_kwargs not supported for method {method}')"
        ]
    },
    {
        "func_name": "gls",
        "original": "def gls(endog, exog=None, order=(0, 0, 0), seasonal_order=(0, 0, 0, 0), include_constant=None, n_iter=None, max_iter=50, tolerance=1e-08, arma_estimator='innovations_mle', arma_estimator_kwargs=None):\n    \"\"\"\n    Estimate ARMAX parameters by GLS.\n\n    Parameters\n    ----------\n    endog : array_like\n        Input time series array.\n    exog : array_like, optional\n        Array of exogenous regressors. If not included, then `include_constant`\n        must be True, and then `exog` will only include the constant column.\n    order : tuple, optional\n        The (p,d,q) order of the ARIMA model. Default is (0, 0, 0).\n    seasonal_order : tuple, optional\n        The (P,D,Q,s) order of the seasonal ARIMA model.\n        Default is (0, 0, 0, 0).\n    include_constant : bool, optional\n        Whether to add a constant term in `exog` if it's not already there.\n        The estimate of the constant will then appear as one of the `exog`\n        parameters. If `exog` is None, then the constant will represent the\n        mean of the process. Default is True if the specified model does not\n        include integration and False otherwise.\n    n_iter : int, optional\n        Optionally iterate feasible GSL a specific number of times. Default is\n        to iterate to convergence. If set, this argument overrides the\n        `max_iter` and `tolerance` arguments.\n    max_iter : int, optional\n        Maximum number of feasible GLS iterations. Default is 50. If `n_iter`\n        is set, it overrides this argument.\n    tolerance : float, optional\n        Tolerance for determining convergence of feasible GSL iterations. If\n        `iter` is set, this argument has no effect.\n        Default is 1e-8.\n    arma_estimator : str, optional\n        The estimator used for estimating the ARMA model. This option should\n        not generally be used, unless the default method is failing or is\n        otherwise unsuitable. Not all values will be valid, depending on the\n        specified model orders (`order` and `seasonal_order`). Possible values\n        are:\n        * 'innovations_mle' - can be used with any specification\n        * 'statespace' - can be used with any specification\n        * 'hannan_rissanen' - can be used with any ARMA non-seasonal model\n        * 'yule_walker' - only non-seasonal consecutive\n          autoregressive (AR) models\n        * 'burg' - only non-seasonal, consecutive autoregressive (AR) models\n        * 'innovations' - only non-seasonal, consecutive moving\n          average (MA) models.\n        The default is 'innovations_mle'.\n    arma_estimator_kwargs : dict, optional\n        Arguments to pass to the ARMA estimator.\n\n    Returns\n    -------\n    parameters : SARIMAXParams object\n        Contains the parameter estimates from the final iteration.\n    other_results : Bunch\n        Includes eight components: `spec`, `params`, `converged`,\n        `differences`, `iterations`, `arma_estimator`, 'arma_estimator_kwargs',\n        and `arma_results`.\n\n    Notes\n    -----\n    The primary reference is [1]_, section 6.6. In particular, the\n    implementation follows the iterative procedure described in section 6.6.2.\n    Construction of the transformed variables used to compute the GLS estimator\n    described in section 6.6.1 is done via an application of the innovations\n    algorithm (rather than explicit construction of the transformation matrix).\n\n    Note that if the specified model includes integration, both the `endog` and\n    `exog` series will be differenced prior to estimation and a warning will\n    be issued to alert the user.\n\n    References\n    ----------\n    .. [1] Brockwell, Peter J., and Richard A. Davis. 2016.\n       Introduction to Time Series and Forecasting. Springer.\n    \"\"\"\n    if n_iter is not None:\n        max_iter = n_iter\n        tolerance = np.inf\n    integrated = order[1] > 0 or seasonal_order[1] > 0\n    if include_constant is None:\n        include_constant = not integrated\n    elif include_constant and integrated:\n        raise ValueError('Cannot include a constant in an integrated model.')\n    if include_constant:\n        exog = np.ones_like(endog) if exog is None else add_constant(exog)\n    spec = SARIMAXSpecification(endog, exog=exog, order=order, seasonal_order=seasonal_order)\n    endog = spec.endog\n    exog = spec.exog\n    if spec.is_integrated:\n        warnings.warn('Provided `endog` and `exog` series have been differenced to eliminate integration prior to GLS parameter estimation.')\n        endog = diff(endog, k_diff=spec.diff, k_seasonal_diff=spec.seasonal_diff, seasonal_periods=spec.seasonal_periods)\n        exog = diff(exog, k_diff=spec.diff, k_seasonal_diff=spec.seasonal_diff, seasonal_periods=spec.seasonal_periods)\n    augmented = np.c_[endog, exog]\n    spec.validate_estimator(arma_estimator)\n    if arma_estimator_kwargs is None:\n        arma_estimator_kwargs = {}\n    mod_ols = OLS(endog, exog)\n    res_ols = mod_ols.fit()\n    exog_params = res_ols.params\n    resid = res_ols.resid\n    p = SARIMAXParams(spec=spec)\n    p.exog_params = exog_params\n    if spec.max_ar_order > 0:\n        p.ar_params = np.zeros(spec.k_ar_params)\n    if spec.max_seasonal_ar_order > 0:\n        p.seasonal_ar_params = np.zeros(spec.k_seasonal_ar_params)\n    if spec.max_ma_order > 0:\n        p.ma_params = np.zeros(spec.k_ma_params)\n    if spec.max_seasonal_ma_order > 0:\n        p.seasonal_ma_params = np.zeros(spec.k_seasonal_ma_params)\n    p.sigma2 = res_ols.scale\n    ar_params = p.ar_params\n    seasonal_ar_params = p.seasonal_ar_params\n    ma_params = p.ma_params\n    seasonal_ma_params = p.seasonal_ma_params\n    sigma2 = p.sigma2\n    arma_results = [None]\n    differences = [None]\n    parameters = [p]\n    converged = False if n_iter is None else None\n    i = 0\n\n    def _check_arma_estimator_kwargs(kwargs, method):\n        if kwargs:\n            raise ValueError(f'arma_estimator_kwargs not supported for method {method}')\n    for i in range(1, max_iter + 1):\n        prev = exog_params\n        if arma_estimator == 'yule_walker':\n            (p_arma, res_arma) = yule_walker(resid, ar_order=spec.ar_order, demean=False, **arma_estimator_kwargs)\n        elif arma_estimator == 'burg':\n            _check_arma_estimator_kwargs(arma_estimator_kwargs, 'burg')\n            (p_arma, res_arma) = burg(resid, ar_order=spec.ar_order, demean=False)\n        elif arma_estimator == 'innovations':\n            _check_arma_estimator_kwargs(arma_estimator_kwargs, 'innovations')\n            (out, res_arma) = innovations(resid, ma_order=spec.ma_order, demean=False)\n            p_arma = out[-1]\n        elif arma_estimator == 'hannan_rissanen':\n            (p_arma, res_arma) = hannan_rissanen(resid, ar_order=spec.ar_order, ma_order=spec.ma_order, demean=False, **arma_estimator_kwargs)\n        else:\n            start_params = None if i == 1 else np.r_[ar_params, ma_params, seasonal_ar_params, seasonal_ma_params, sigma2]\n            tmp_order = (spec.order[0], 0, spec.order[2])\n            tmp_seasonal_order = (spec.seasonal_order[0], 0, spec.seasonal_order[2], spec.seasonal_order[3])\n            if arma_estimator == 'innovations_mle':\n                (p_arma, res_arma) = innovations_mle(resid, order=tmp_order, seasonal_order=tmp_seasonal_order, demean=False, start_params=start_params, **arma_estimator_kwargs)\n            else:\n                (p_arma, res_arma) = statespace(resid, order=tmp_order, seasonal_order=tmp_seasonal_order, include_constant=False, start_params=start_params, **arma_estimator_kwargs)\n        ar_params = p_arma.ar_params\n        seasonal_ar_params = p_arma.seasonal_ar_params\n        ma_params = p_arma.ma_params\n        seasonal_ma_params = p_arma.seasonal_ma_params\n        sigma2 = p_arma.sigma2\n        arma_results.append(res_arma)\n        if not p_arma.is_stationary:\n            raise ValueError('Roots of the autoregressive parameters indicate that data isnon-stationary. GLS cannot be used with non-stationary parameters. You should consider differencing the model dataor applying a nonlinear transformation (e.g., natural log).')\n        (tmp, _) = arma_innovations.arma_innovations(augmented, ar_params=ar_params, ma_params=ma_params, normalize=True)\n        u = tmp[:, 0]\n        x = tmp[:, 1:]\n        mod_gls = OLS(u, x)\n        res_gls = mod_gls.fit()\n        exog_params = res_gls.params\n        resid = endog - np.dot(exog, exog_params)\n        p = SARIMAXParams(spec=spec)\n        p.exog_params = exog_params\n        if spec.max_ar_order > 0:\n            p.ar_params = ar_params\n        if spec.max_seasonal_ar_order > 0:\n            p.seasonal_ar_params = seasonal_ar_params\n        if spec.max_ma_order > 0:\n            p.ma_params = ma_params\n        if spec.max_seasonal_ma_order > 0:\n            p.seasonal_ma_params = seasonal_ma_params\n        p.sigma2 = sigma2\n        parameters.append(p)\n        difference = np.abs(exog_params - prev)\n        differences.append(difference)\n        if n_iter is None and np.all(difference < tolerance):\n            converged = True\n            break\n    else:\n        if n_iter is None:\n            warnings.warn('Feasible GLS failed to converge in %d iterations. Consider increasing the maximum number of iterations using the `max_iter` argument or reducing the required tolerance using the `tolerance` argument.' % max_iter)\n    p = parameters[-1]\n    other_results = Bunch({'spec': spec, 'params': parameters, 'converged': converged, 'differences': differences, 'iterations': i, 'arma_estimator': arma_estimator, 'arma_estimator_kwargs': arma_estimator_kwargs, 'arma_results': arma_results})\n    return (p, other_results)",
        "mutated": [
            "def gls(endog, exog=None, order=(0, 0, 0), seasonal_order=(0, 0, 0, 0), include_constant=None, n_iter=None, max_iter=50, tolerance=1e-08, arma_estimator='innovations_mle', arma_estimator_kwargs=None):\n    if False:\n        i = 10\n    \"\\n    Estimate ARMAX parameters by GLS.\\n\\n    Parameters\\n    ----------\\n    endog : array_like\\n        Input time series array.\\n    exog : array_like, optional\\n        Array of exogenous regressors. If not included, then `include_constant`\\n        must be True, and then `exog` will only include the constant column.\\n    order : tuple, optional\\n        The (p,d,q) order of the ARIMA model. Default is (0, 0, 0).\\n    seasonal_order : tuple, optional\\n        The (P,D,Q,s) order of the seasonal ARIMA model.\\n        Default is (0, 0, 0, 0).\\n    include_constant : bool, optional\\n        Whether to add a constant term in `exog` if it's not already there.\\n        The estimate of the constant will then appear as one of the `exog`\\n        parameters. If `exog` is None, then the constant will represent the\\n        mean of the process. Default is True if the specified model does not\\n        include integration and False otherwise.\\n    n_iter : int, optional\\n        Optionally iterate feasible GSL a specific number of times. Default is\\n        to iterate to convergence. If set, this argument overrides the\\n        `max_iter` and `tolerance` arguments.\\n    max_iter : int, optional\\n        Maximum number of feasible GLS iterations. Default is 50. If `n_iter`\\n        is set, it overrides this argument.\\n    tolerance : float, optional\\n        Tolerance for determining convergence of feasible GSL iterations. If\\n        `iter` is set, this argument has no effect.\\n        Default is 1e-8.\\n    arma_estimator : str, optional\\n        The estimator used for estimating the ARMA model. This option should\\n        not generally be used, unless the default method is failing or is\\n        otherwise unsuitable. Not all values will be valid, depending on the\\n        specified model orders (`order` and `seasonal_order`). Possible values\\n        are:\\n        * 'innovations_mle' - can be used with any specification\\n        * 'statespace' - can be used with any specification\\n        * 'hannan_rissanen' - can be used with any ARMA non-seasonal model\\n        * 'yule_walker' - only non-seasonal consecutive\\n          autoregressive (AR) models\\n        * 'burg' - only non-seasonal, consecutive autoregressive (AR) models\\n        * 'innovations' - only non-seasonal, consecutive moving\\n          average (MA) models.\\n        The default is 'innovations_mle'.\\n    arma_estimator_kwargs : dict, optional\\n        Arguments to pass to the ARMA estimator.\\n\\n    Returns\\n    -------\\n    parameters : SARIMAXParams object\\n        Contains the parameter estimates from the final iteration.\\n    other_results : Bunch\\n        Includes eight components: `spec`, `params`, `converged`,\\n        `differences`, `iterations`, `arma_estimator`, 'arma_estimator_kwargs',\\n        and `arma_results`.\\n\\n    Notes\\n    -----\\n    The primary reference is [1]_, section 6.6. In particular, the\\n    implementation follows the iterative procedure described in section 6.6.2.\\n    Construction of the transformed variables used to compute the GLS estimator\\n    described in section 6.6.1 is done via an application of the innovations\\n    algorithm (rather than explicit construction of the transformation matrix).\\n\\n    Note that if the specified model includes integration, both the `endog` and\\n    `exog` series will be differenced prior to estimation and a warning will\\n    be issued to alert the user.\\n\\n    References\\n    ----------\\n    .. [1] Brockwell, Peter J., and Richard A. Davis. 2016.\\n       Introduction to Time Series and Forecasting. Springer.\\n    \"\n    if n_iter is not None:\n        max_iter = n_iter\n        tolerance = np.inf\n    integrated = order[1] > 0 or seasonal_order[1] > 0\n    if include_constant is None:\n        include_constant = not integrated\n    elif include_constant and integrated:\n        raise ValueError('Cannot include a constant in an integrated model.')\n    if include_constant:\n        exog = np.ones_like(endog) if exog is None else add_constant(exog)\n    spec = SARIMAXSpecification(endog, exog=exog, order=order, seasonal_order=seasonal_order)\n    endog = spec.endog\n    exog = spec.exog\n    if spec.is_integrated:\n        warnings.warn('Provided `endog` and `exog` series have been differenced to eliminate integration prior to GLS parameter estimation.')\n        endog = diff(endog, k_diff=spec.diff, k_seasonal_diff=spec.seasonal_diff, seasonal_periods=spec.seasonal_periods)\n        exog = diff(exog, k_diff=spec.diff, k_seasonal_diff=spec.seasonal_diff, seasonal_periods=spec.seasonal_periods)\n    augmented = np.c_[endog, exog]\n    spec.validate_estimator(arma_estimator)\n    if arma_estimator_kwargs is None:\n        arma_estimator_kwargs = {}\n    mod_ols = OLS(endog, exog)\n    res_ols = mod_ols.fit()\n    exog_params = res_ols.params\n    resid = res_ols.resid\n    p = SARIMAXParams(spec=spec)\n    p.exog_params = exog_params\n    if spec.max_ar_order > 0:\n        p.ar_params = np.zeros(spec.k_ar_params)\n    if spec.max_seasonal_ar_order > 0:\n        p.seasonal_ar_params = np.zeros(spec.k_seasonal_ar_params)\n    if spec.max_ma_order > 0:\n        p.ma_params = np.zeros(spec.k_ma_params)\n    if spec.max_seasonal_ma_order > 0:\n        p.seasonal_ma_params = np.zeros(spec.k_seasonal_ma_params)\n    p.sigma2 = res_ols.scale\n    ar_params = p.ar_params\n    seasonal_ar_params = p.seasonal_ar_params\n    ma_params = p.ma_params\n    seasonal_ma_params = p.seasonal_ma_params\n    sigma2 = p.sigma2\n    arma_results = [None]\n    differences = [None]\n    parameters = [p]\n    converged = False if n_iter is None else None\n    i = 0\n\n    def _check_arma_estimator_kwargs(kwargs, method):\n        if kwargs:\n            raise ValueError(f'arma_estimator_kwargs not supported for method {method}')\n    for i in range(1, max_iter + 1):\n        prev = exog_params\n        if arma_estimator == 'yule_walker':\n            (p_arma, res_arma) = yule_walker(resid, ar_order=spec.ar_order, demean=False, **arma_estimator_kwargs)\n        elif arma_estimator == 'burg':\n            _check_arma_estimator_kwargs(arma_estimator_kwargs, 'burg')\n            (p_arma, res_arma) = burg(resid, ar_order=spec.ar_order, demean=False)\n        elif arma_estimator == 'innovations':\n            _check_arma_estimator_kwargs(arma_estimator_kwargs, 'innovations')\n            (out, res_arma) = innovations(resid, ma_order=spec.ma_order, demean=False)\n            p_arma = out[-1]\n        elif arma_estimator == 'hannan_rissanen':\n            (p_arma, res_arma) = hannan_rissanen(resid, ar_order=spec.ar_order, ma_order=spec.ma_order, demean=False, **arma_estimator_kwargs)\n        else:\n            start_params = None if i == 1 else np.r_[ar_params, ma_params, seasonal_ar_params, seasonal_ma_params, sigma2]\n            tmp_order = (spec.order[0], 0, spec.order[2])\n            tmp_seasonal_order = (spec.seasonal_order[0], 0, spec.seasonal_order[2], spec.seasonal_order[3])\n            if arma_estimator == 'innovations_mle':\n                (p_arma, res_arma) = innovations_mle(resid, order=tmp_order, seasonal_order=tmp_seasonal_order, demean=False, start_params=start_params, **arma_estimator_kwargs)\n            else:\n                (p_arma, res_arma) = statespace(resid, order=tmp_order, seasonal_order=tmp_seasonal_order, include_constant=False, start_params=start_params, **arma_estimator_kwargs)\n        ar_params = p_arma.ar_params\n        seasonal_ar_params = p_arma.seasonal_ar_params\n        ma_params = p_arma.ma_params\n        seasonal_ma_params = p_arma.seasonal_ma_params\n        sigma2 = p_arma.sigma2\n        arma_results.append(res_arma)\n        if not p_arma.is_stationary:\n            raise ValueError('Roots of the autoregressive parameters indicate that data isnon-stationary. GLS cannot be used with non-stationary parameters. You should consider differencing the model dataor applying a nonlinear transformation (e.g., natural log).')\n        (tmp, _) = arma_innovations.arma_innovations(augmented, ar_params=ar_params, ma_params=ma_params, normalize=True)\n        u = tmp[:, 0]\n        x = tmp[:, 1:]\n        mod_gls = OLS(u, x)\n        res_gls = mod_gls.fit()\n        exog_params = res_gls.params\n        resid = endog - np.dot(exog, exog_params)\n        p = SARIMAXParams(spec=spec)\n        p.exog_params = exog_params\n        if spec.max_ar_order > 0:\n            p.ar_params = ar_params\n        if spec.max_seasonal_ar_order > 0:\n            p.seasonal_ar_params = seasonal_ar_params\n        if spec.max_ma_order > 0:\n            p.ma_params = ma_params\n        if spec.max_seasonal_ma_order > 0:\n            p.seasonal_ma_params = seasonal_ma_params\n        p.sigma2 = sigma2\n        parameters.append(p)\n        difference = np.abs(exog_params - prev)\n        differences.append(difference)\n        if n_iter is None and np.all(difference < tolerance):\n            converged = True\n            break\n    else:\n        if n_iter is None:\n            warnings.warn('Feasible GLS failed to converge in %d iterations. Consider increasing the maximum number of iterations using the `max_iter` argument or reducing the required tolerance using the `tolerance` argument.' % max_iter)\n    p = parameters[-1]\n    other_results = Bunch({'spec': spec, 'params': parameters, 'converged': converged, 'differences': differences, 'iterations': i, 'arma_estimator': arma_estimator, 'arma_estimator_kwargs': arma_estimator_kwargs, 'arma_results': arma_results})\n    return (p, other_results)",
            "def gls(endog, exog=None, order=(0, 0, 0), seasonal_order=(0, 0, 0, 0), include_constant=None, n_iter=None, max_iter=50, tolerance=1e-08, arma_estimator='innovations_mle', arma_estimator_kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Estimate ARMAX parameters by GLS.\\n\\n    Parameters\\n    ----------\\n    endog : array_like\\n        Input time series array.\\n    exog : array_like, optional\\n        Array of exogenous regressors. If not included, then `include_constant`\\n        must be True, and then `exog` will only include the constant column.\\n    order : tuple, optional\\n        The (p,d,q) order of the ARIMA model. Default is (0, 0, 0).\\n    seasonal_order : tuple, optional\\n        The (P,D,Q,s) order of the seasonal ARIMA model.\\n        Default is (0, 0, 0, 0).\\n    include_constant : bool, optional\\n        Whether to add a constant term in `exog` if it's not already there.\\n        The estimate of the constant will then appear as one of the `exog`\\n        parameters. If `exog` is None, then the constant will represent the\\n        mean of the process. Default is True if the specified model does not\\n        include integration and False otherwise.\\n    n_iter : int, optional\\n        Optionally iterate feasible GSL a specific number of times. Default is\\n        to iterate to convergence. If set, this argument overrides the\\n        `max_iter` and `tolerance` arguments.\\n    max_iter : int, optional\\n        Maximum number of feasible GLS iterations. Default is 50. If `n_iter`\\n        is set, it overrides this argument.\\n    tolerance : float, optional\\n        Tolerance for determining convergence of feasible GSL iterations. If\\n        `iter` is set, this argument has no effect.\\n        Default is 1e-8.\\n    arma_estimator : str, optional\\n        The estimator used for estimating the ARMA model. This option should\\n        not generally be used, unless the default method is failing or is\\n        otherwise unsuitable. Not all values will be valid, depending on the\\n        specified model orders (`order` and `seasonal_order`). Possible values\\n        are:\\n        * 'innovations_mle' - can be used with any specification\\n        * 'statespace' - can be used with any specification\\n        * 'hannan_rissanen' - can be used with any ARMA non-seasonal model\\n        * 'yule_walker' - only non-seasonal consecutive\\n          autoregressive (AR) models\\n        * 'burg' - only non-seasonal, consecutive autoregressive (AR) models\\n        * 'innovations' - only non-seasonal, consecutive moving\\n          average (MA) models.\\n        The default is 'innovations_mle'.\\n    arma_estimator_kwargs : dict, optional\\n        Arguments to pass to the ARMA estimator.\\n\\n    Returns\\n    -------\\n    parameters : SARIMAXParams object\\n        Contains the parameter estimates from the final iteration.\\n    other_results : Bunch\\n        Includes eight components: `spec`, `params`, `converged`,\\n        `differences`, `iterations`, `arma_estimator`, 'arma_estimator_kwargs',\\n        and `arma_results`.\\n\\n    Notes\\n    -----\\n    The primary reference is [1]_, section 6.6. In particular, the\\n    implementation follows the iterative procedure described in section 6.6.2.\\n    Construction of the transformed variables used to compute the GLS estimator\\n    described in section 6.6.1 is done via an application of the innovations\\n    algorithm (rather than explicit construction of the transformation matrix).\\n\\n    Note that if the specified model includes integration, both the `endog` and\\n    `exog` series will be differenced prior to estimation and a warning will\\n    be issued to alert the user.\\n\\n    References\\n    ----------\\n    .. [1] Brockwell, Peter J., and Richard A. Davis. 2016.\\n       Introduction to Time Series and Forecasting. Springer.\\n    \"\n    if n_iter is not None:\n        max_iter = n_iter\n        tolerance = np.inf\n    integrated = order[1] > 0 or seasonal_order[1] > 0\n    if include_constant is None:\n        include_constant = not integrated\n    elif include_constant and integrated:\n        raise ValueError('Cannot include a constant in an integrated model.')\n    if include_constant:\n        exog = np.ones_like(endog) if exog is None else add_constant(exog)\n    spec = SARIMAXSpecification(endog, exog=exog, order=order, seasonal_order=seasonal_order)\n    endog = spec.endog\n    exog = spec.exog\n    if spec.is_integrated:\n        warnings.warn('Provided `endog` and `exog` series have been differenced to eliminate integration prior to GLS parameter estimation.')\n        endog = diff(endog, k_diff=spec.diff, k_seasonal_diff=spec.seasonal_diff, seasonal_periods=spec.seasonal_periods)\n        exog = diff(exog, k_diff=spec.diff, k_seasonal_diff=spec.seasonal_diff, seasonal_periods=spec.seasonal_periods)\n    augmented = np.c_[endog, exog]\n    spec.validate_estimator(arma_estimator)\n    if arma_estimator_kwargs is None:\n        arma_estimator_kwargs = {}\n    mod_ols = OLS(endog, exog)\n    res_ols = mod_ols.fit()\n    exog_params = res_ols.params\n    resid = res_ols.resid\n    p = SARIMAXParams(spec=spec)\n    p.exog_params = exog_params\n    if spec.max_ar_order > 0:\n        p.ar_params = np.zeros(spec.k_ar_params)\n    if spec.max_seasonal_ar_order > 0:\n        p.seasonal_ar_params = np.zeros(spec.k_seasonal_ar_params)\n    if spec.max_ma_order > 0:\n        p.ma_params = np.zeros(spec.k_ma_params)\n    if spec.max_seasonal_ma_order > 0:\n        p.seasonal_ma_params = np.zeros(spec.k_seasonal_ma_params)\n    p.sigma2 = res_ols.scale\n    ar_params = p.ar_params\n    seasonal_ar_params = p.seasonal_ar_params\n    ma_params = p.ma_params\n    seasonal_ma_params = p.seasonal_ma_params\n    sigma2 = p.sigma2\n    arma_results = [None]\n    differences = [None]\n    parameters = [p]\n    converged = False if n_iter is None else None\n    i = 0\n\n    def _check_arma_estimator_kwargs(kwargs, method):\n        if kwargs:\n            raise ValueError(f'arma_estimator_kwargs not supported for method {method}')\n    for i in range(1, max_iter + 1):\n        prev = exog_params\n        if arma_estimator == 'yule_walker':\n            (p_arma, res_arma) = yule_walker(resid, ar_order=spec.ar_order, demean=False, **arma_estimator_kwargs)\n        elif arma_estimator == 'burg':\n            _check_arma_estimator_kwargs(arma_estimator_kwargs, 'burg')\n            (p_arma, res_arma) = burg(resid, ar_order=spec.ar_order, demean=False)\n        elif arma_estimator == 'innovations':\n            _check_arma_estimator_kwargs(arma_estimator_kwargs, 'innovations')\n            (out, res_arma) = innovations(resid, ma_order=spec.ma_order, demean=False)\n            p_arma = out[-1]\n        elif arma_estimator == 'hannan_rissanen':\n            (p_arma, res_arma) = hannan_rissanen(resid, ar_order=spec.ar_order, ma_order=spec.ma_order, demean=False, **arma_estimator_kwargs)\n        else:\n            start_params = None if i == 1 else np.r_[ar_params, ma_params, seasonal_ar_params, seasonal_ma_params, sigma2]\n            tmp_order = (spec.order[0], 0, spec.order[2])\n            tmp_seasonal_order = (spec.seasonal_order[0], 0, spec.seasonal_order[2], spec.seasonal_order[3])\n            if arma_estimator == 'innovations_mle':\n                (p_arma, res_arma) = innovations_mle(resid, order=tmp_order, seasonal_order=tmp_seasonal_order, demean=False, start_params=start_params, **arma_estimator_kwargs)\n            else:\n                (p_arma, res_arma) = statespace(resid, order=tmp_order, seasonal_order=tmp_seasonal_order, include_constant=False, start_params=start_params, **arma_estimator_kwargs)\n        ar_params = p_arma.ar_params\n        seasonal_ar_params = p_arma.seasonal_ar_params\n        ma_params = p_arma.ma_params\n        seasonal_ma_params = p_arma.seasonal_ma_params\n        sigma2 = p_arma.sigma2\n        arma_results.append(res_arma)\n        if not p_arma.is_stationary:\n            raise ValueError('Roots of the autoregressive parameters indicate that data isnon-stationary. GLS cannot be used with non-stationary parameters. You should consider differencing the model dataor applying a nonlinear transformation (e.g., natural log).')\n        (tmp, _) = arma_innovations.arma_innovations(augmented, ar_params=ar_params, ma_params=ma_params, normalize=True)\n        u = tmp[:, 0]\n        x = tmp[:, 1:]\n        mod_gls = OLS(u, x)\n        res_gls = mod_gls.fit()\n        exog_params = res_gls.params\n        resid = endog - np.dot(exog, exog_params)\n        p = SARIMAXParams(spec=spec)\n        p.exog_params = exog_params\n        if spec.max_ar_order > 0:\n            p.ar_params = ar_params\n        if spec.max_seasonal_ar_order > 0:\n            p.seasonal_ar_params = seasonal_ar_params\n        if spec.max_ma_order > 0:\n            p.ma_params = ma_params\n        if spec.max_seasonal_ma_order > 0:\n            p.seasonal_ma_params = seasonal_ma_params\n        p.sigma2 = sigma2\n        parameters.append(p)\n        difference = np.abs(exog_params - prev)\n        differences.append(difference)\n        if n_iter is None and np.all(difference < tolerance):\n            converged = True\n            break\n    else:\n        if n_iter is None:\n            warnings.warn('Feasible GLS failed to converge in %d iterations. Consider increasing the maximum number of iterations using the `max_iter` argument or reducing the required tolerance using the `tolerance` argument.' % max_iter)\n    p = parameters[-1]\n    other_results = Bunch({'spec': spec, 'params': parameters, 'converged': converged, 'differences': differences, 'iterations': i, 'arma_estimator': arma_estimator, 'arma_estimator_kwargs': arma_estimator_kwargs, 'arma_results': arma_results})\n    return (p, other_results)",
            "def gls(endog, exog=None, order=(0, 0, 0), seasonal_order=(0, 0, 0, 0), include_constant=None, n_iter=None, max_iter=50, tolerance=1e-08, arma_estimator='innovations_mle', arma_estimator_kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Estimate ARMAX parameters by GLS.\\n\\n    Parameters\\n    ----------\\n    endog : array_like\\n        Input time series array.\\n    exog : array_like, optional\\n        Array of exogenous regressors. If not included, then `include_constant`\\n        must be True, and then `exog` will only include the constant column.\\n    order : tuple, optional\\n        The (p,d,q) order of the ARIMA model. Default is (0, 0, 0).\\n    seasonal_order : tuple, optional\\n        The (P,D,Q,s) order of the seasonal ARIMA model.\\n        Default is (0, 0, 0, 0).\\n    include_constant : bool, optional\\n        Whether to add a constant term in `exog` if it's not already there.\\n        The estimate of the constant will then appear as one of the `exog`\\n        parameters. If `exog` is None, then the constant will represent the\\n        mean of the process. Default is True if the specified model does not\\n        include integration and False otherwise.\\n    n_iter : int, optional\\n        Optionally iterate feasible GSL a specific number of times. Default is\\n        to iterate to convergence. If set, this argument overrides the\\n        `max_iter` and `tolerance` arguments.\\n    max_iter : int, optional\\n        Maximum number of feasible GLS iterations. Default is 50. If `n_iter`\\n        is set, it overrides this argument.\\n    tolerance : float, optional\\n        Tolerance for determining convergence of feasible GSL iterations. If\\n        `iter` is set, this argument has no effect.\\n        Default is 1e-8.\\n    arma_estimator : str, optional\\n        The estimator used for estimating the ARMA model. This option should\\n        not generally be used, unless the default method is failing or is\\n        otherwise unsuitable. Not all values will be valid, depending on the\\n        specified model orders (`order` and `seasonal_order`). Possible values\\n        are:\\n        * 'innovations_mle' - can be used with any specification\\n        * 'statespace' - can be used with any specification\\n        * 'hannan_rissanen' - can be used with any ARMA non-seasonal model\\n        * 'yule_walker' - only non-seasonal consecutive\\n          autoregressive (AR) models\\n        * 'burg' - only non-seasonal, consecutive autoregressive (AR) models\\n        * 'innovations' - only non-seasonal, consecutive moving\\n          average (MA) models.\\n        The default is 'innovations_mle'.\\n    arma_estimator_kwargs : dict, optional\\n        Arguments to pass to the ARMA estimator.\\n\\n    Returns\\n    -------\\n    parameters : SARIMAXParams object\\n        Contains the parameter estimates from the final iteration.\\n    other_results : Bunch\\n        Includes eight components: `spec`, `params`, `converged`,\\n        `differences`, `iterations`, `arma_estimator`, 'arma_estimator_kwargs',\\n        and `arma_results`.\\n\\n    Notes\\n    -----\\n    The primary reference is [1]_, section 6.6. In particular, the\\n    implementation follows the iterative procedure described in section 6.6.2.\\n    Construction of the transformed variables used to compute the GLS estimator\\n    described in section 6.6.1 is done via an application of the innovations\\n    algorithm (rather than explicit construction of the transformation matrix).\\n\\n    Note that if the specified model includes integration, both the `endog` and\\n    `exog` series will be differenced prior to estimation and a warning will\\n    be issued to alert the user.\\n\\n    References\\n    ----------\\n    .. [1] Brockwell, Peter J., and Richard A. Davis. 2016.\\n       Introduction to Time Series and Forecasting. Springer.\\n    \"\n    if n_iter is not None:\n        max_iter = n_iter\n        tolerance = np.inf\n    integrated = order[1] > 0 or seasonal_order[1] > 0\n    if include_constant is None:\n        include_constant = not integrated\n    elif include_constant and integrated:\n        raise ValueError('Cannot include a constant in an integrated model.')\n    if include_constant:\n        exog = np.ones_like(endog) if exog is None else add_constant(exog)\n    spec = SARIMAXSpecification(endog, exog=exog, order=order, seasonal_order=seasonal_order)\n    endog = spec.endog\n    exog = spec.exog\n    if spec.is_integrated:\n        warnings.warn('Provided `endog` and `exog` series have been differenced to eliminate integration prior to GLS parameter estimation.')\n        endog = diff(endog, k_diff=spec.diff, k_seasonal_diff=spec.seasonal_diff, seasonal_periods=spec.seasonal_periods)\n        exog = diff(exog, k_diff=spec.diff, k_seasonal_diff=spec.seasonal_diff, seasonal_periods=spec.seasonal_periods)\n    augmented = np.c_[endog, exog]\n    spec.validate_estimator(arma_estimator)\n    if arma_estimator_kwargs is None:\n        arma_estimator_kwargs = {}\n    mod_ols = OLS(endog, exog)\n    res_ols = mod_ols.fit()\n    exog_params = res_ols.params\n    resid = res_ols.resid\n    p = SARIMAXParams(spec=spec)\n    p.exog_params = exog_params\n    if spec.max_ar_order > 0:\n        p.ar_params = np.zeros(spec.k_ar_params)\n    if spec.max_seasonal_ar_order > 0:\n        p.seasonal_ar_params = np.zeros(spec.k_seasonal_ar_params)\n    if spec.max_ma_order > 0:\n        p.ma_params = np.zeros(spec.k_ma_params)\n    if spec.max_seasonal_ma_order > 0:\n        p.seasonal_ma_params = np.zeros(spec.k_seasonal_ma_params)\n    p.sigma2 = res_ols.scale\n    ar_params = p.ar_params\n    seasonal_ar_params = p.seasonal_ar_params\n    ma_params = p.ma_params\n    seasonal_ma_params = p.seasonal_ma_params\n    sigma2 = p.sigma2\n    arma_results = [None]\n    differences = [None]\n    parameters = [p]\n    converged = False if n_iter is None else None\n    i = 0\n\n    def _check_arma_estimator_kwargs(kwargs, method):\n        if kwargs:\n            raise ValueError(f'arma_estimator_kwargs not supported for method {method}')\n    for i in range(1, max_iter + 1):\n        prev = exog_params\n        if arma_estimator == 'yule_walker':\n            (p_arma, res_arma) = yule_walker(resid, ar_order=spec.ar_order, demean=False, **arma_estimator_kwargs)\n        elif arma_estimator == 'burg':\n            _check_arma_estimator_kwargs(arma_estimator_kwargs, 'burg')\n            (p_arma, res_arma) = burg(resid, ar_order=spec.ar_order, demean=False)\n        elif arma_estimator == 'innovations':\n            _check_arma_estimator_kwargs(arma_estimator_kwargs, 'innovations')\n            (out, res_arma) = innovations(resid, ma_order=spec.ma_order, demean=False)\n            p_arma = out[-1]\n        elif arma_estimator == 'hannan_rissanen':\n            (p_arma, res_arma) = hannan_rissanen(resid, ar_order=spec.ar_order, ma_order=spec.ma_order, demean=False, **arma_estimator_kwargs)\n        else:\n            start_params = None if i == 1 else np.r_[ar_params, ma_params, seasonal_ar_params, seasonal_ma_params, sigma2]\n            tmp_order = (spec.order[0], 0, spec.order[2])\n            tmp_seasonal_order = (spec.seasonal_order[0], 0, spec.seasonal_order[2], spec.seasonal_order[3])\n            if arma_estimator == 'innovations_mle':\n                (p_arma, res_arma) = innovations_mle(resid, order=tmp_order, seasonal_order=tmp_seasonal_order, demean=False, start_params=start_params, **arma_estimator_kwargs)\n            else:\n                (p_arma, res_arma) = statespace(resid, order=tmp_order, seasonal_order=tmp_seasonal_order, include_constant=False, start_params=start_params, **arma_estimator_kwargs)\n        ar_params = p_arma.ar_params\n        seasonal_ar_params = p_arma.seasonal_ar_params\n        ma_params = p_arma.ma_params\n        seasonal_ma_params = p_arma.seasonal_ma_params\n        sigma2 = p_arma.sigma2\n        arma_results.append(res_arma)\n        if not p_arma.is_stationary:\n            raise ValueError('Roots of the autoregressive parameters indicate that data isnon-stationary. GLS cannot be used with non-stationary parameters. You should consider differencing the model dataor applying a nonlinear transformation (e.g., natural log).')\n        (tmp, _) = arma_innovations.arma_innovations(augmented, ar_params=ar_params, ma_params=ma_params, normalize=True)\n        u = tmp[:, 0]\n        x = tmp[:, 1:]\n        mod_gls = OLS(u, x)\n        res_gls = mod_gls.fit()\n        exog_params = res_gls.params\n        resid = endog - np.dot(exog, exog_params)\n        p = SARIMAXParams(spec=spec)\n        p.exog_params = exog_params\n        if spec.max_ar_order > 0:\n            p.ar_params = ar_params\n        if spec.max_seasonal_ar_order > 0:\n            p.seasonal_ar_params = seasonal_ar_params\n        if spec.max_ma_order > 0:\n            p.ma_params = ma_params\n        if spec.max_seasonal_ma_order > 0:\n            p.seasonal_ma_params = seasonal_ma_params\n        p.sigma2 = sigma2\n        parameters.append(p)\n        difference = np.abs(exog_params - prev)\n        differences.append(difference)\n        if n_iter is None and np.all(difference < tolerance):\n            converged = True\n            break\n    else:\n        if n_iter is None:\n            warnings.warn('Feasible GLS failed to converge in %d iterations. Consider increasing the maximum number of iterations using the `max_iter` argument or reducing the required tolerance using the `tolerance` argument.' % max_iter)\n    p = parameters[-1]\n    other_results = Bunch({'spec': spec, 'params': parameters, 'converged': converged, 'differences': differences, 'iterations': i, 'arma_estimator': arma_estimator, 'arma_estimator_kwargs': arma_estimator_kwargs, 'arma_results': arma_results})\n    return (p, other_results)",
            "def gls(endog, exog=None, order=(0, 0, 0), seasonal_order=(0, 0, 0, 0), include_constant=None, n_iter=None, max_iter=50, tolerance=1e-08, arma_estimator='innovations_mle', arma_estimator_kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Estimate ARMAX parameters by GLS.\\n\\n    Parameters\\n    ----------\\n    endog : array_like\\n        Input time series array.\\n    exog : array_like, optional\\n        Array of exogenous regressors. If not included, then `include_constant`\\n        must be True, and then `exog` will only include the constant column.\\n    order : tuple, optional\\n        The (p,d,q) order of the ARIMA model. Default is (0, 0, 0).\\n    seasonal_order : tuple, optional\\n        The (P,D,Q,s) order of the seasonal ARIMA model.\\n        Default is (0, 0, 0, 0).\\n    include_constant : bool, optional\\n        Whether to add a constant term in `exog` if it's not already there.\\n        The estimate of the constant will then appear as one of the `exog`\\n        parameters. If `exog` is None, then the constant will represent the\\n        mean of the process. Default is True if the specified model does not\\n        include integration and False otherwise.\\n    n_iter : int, optional\\n        Optionally iterate feasible GSL a specific number of times. Default is\\n        to iterate to convergence. If set, this argument overrides the\\n        `max_iter` and `tolerance` arguments.\\n    max_iter : int, optional\\n        Maximum number of feasible GLS iterations. Default is 50. If `n_iter`\\n        is set, it overrides this argument.\\n    tolerance : float, optional\\n        Tolerance for determining convergence of feasible GSL iterations. If\\n        `iter` is set, this argument has no effect.\\n        Default is 1e-8.\\n    arma_estimator : str, optional\\n        The estimator used for estimating the ARMA model. This option should\\n        not generally be used, unless the default method is failing or is\\n        otherwise unsuitable. Not all values will be valid, depending on the\\n        specified model orders (`order` and `seasonal_order`). Possible values\\n        are:\\n        * 'innovations_mle' - can be used with any specification\\n        * 'statespace' - can be used with any specification\\n        * 'hannan_rissanen' - can be used with any ARMA non-seasonal model\\n        * 'yule_walker' - only non-seasonal consecutive\\n          autoregressive (AR) models\\n        * 'burg' - only non-seasonal, consecutive autoregressive (AR) models\\n        * 'innovations' - only non-seasonal, consecutive moving\\n          average (MA) models.\\n        The default is 'innovations_mle'.\\n    arma_estimator_kwargs : dict, optional\\n        Arguments to pass to the ARMA estimator.\\n\\n    Returns\\n    -------\\n    parameters : SARIMAXParams object\\n        Contains the parameter estimates from the final iteration.\\n    other_results : Bunch\\n        Includes eight components: `spec`, `params`, `converged`,\\n        `differences`, `iterations`, `arma_estimator`, 'arma_estimator_kwargs',\\n        and `arma_results`.\\n\\n    Notes\\n    -----\\n    The primary reference is [1]_, section 6.6. In particular, the\\n    implementation follows the iterative procedure described in section 6.6.2.\\n    Construction of the transformed variables used to compute the GLS estimator\\n    described in section 6.6.1 is done via an application of the innovations\\n    algorithm (rather than explicit construction of the transformation matrix).\\n\\n    Note that if the specified model includes integration, both the `endog` and\\n    `exog` series will be differenced prior to estimation and a warning will\\n    be issued to alert the user.\\n\\n    References\\n    ----------\\n    .. [1] Brockwell, Peter J., and Richard A. Davis. 2016.\\n       Introduction to Time Series and Forecasting. Springer.\\n    \"\n    if n_iter is not None:\n        max_iter = n_iter\n        tolerance = np.inf\n    integrated = order[1] > 0 or seasonal_order[1] > 0\n    if include_constant is None:\n        include_constant = not integrated\n    elif include_constant and integrated:\n        raise ValueError('Cannot include a constant in an integrated model.')\n    if include_constant:\n        exog = np.ones_like(endog) if exog is None else add_constant(exog)\n    spec = SARIMAXSpecification(endog, exog=exog, order=order, seasonal_order=seasonal_order)\n    endog = spec.endog\n    exog = spec.exog\n    if spec.is_integrated:\n        warnings.warn('Provided `endog` and `exog` series have been differenced to eliminate integration prior to GLS parameter estimation.')\n        endog = diff(endog, k_diff=spec.diff, k_seasonal_diff=spec.seasonal_diff, seasonal_periods=spec.seasonal_periods)\n        exog = diff(exog, k_diff=spec.diff, k_seasonal_diff=spec.seasonal_diff, seasonal_periods=spec.seasonal_periods)\n    augmented = np.c_[endog, exog]\n    spec.validate_estimator(arma_estimator)\n    if arma_estimator_kwargs is None:\n        arma_estimator_kwargs = {}\n    mod_ols = OLS(endog, exog)\n    res_ols = mod_ols.fit()\n    exog_params = res_ols.params\n    resid = res_ols.resid\n    p = SARIMAXParams(spec=spec)\n    p.exog_params = exog_params\n    if spec.max_ar_order > 0:\n        p.ar_params = np.zeros(spec.k_ar_params)\n    if spec.max_seasonal_ar_order > 0:\n        p.seasonal_ar_params = np.zeros(spec.k_seasonal_ar_params)\n    if spec.max_ma_order > 0:\n        p.ma_params = np.zeros(spec.k_ma_params)\n    if spec.max_seasonal_ma_order > 0:\n        p.seasonal_ma_params = np.zeros(spec.k_seasonal_ma_params)\n    p.sigma2 = res_ols.scale\n    ar_params = p.ar_params\n    seasonal_ar_params = p.seasonal_ar_params\n    ma_params = p.ma_params\n    seasonal_ma_params = p.seasonal_ma_params\n    sigma2 = p.sigma2\n    arma_results = [None]\n    differences = [None]\n    parameters = [p]\n    converged = False if n_iter is None else None\n    i = 0\n\n    def _check_arma_estimator_kwargs(kwargs, method):\n        if kwargs:\n            raise ValueError(f'arma_estimator_kwargs not supported for method {method}')\n    for i in range(1, max_iter + 1):\n        prev = exog_params\n        if arma_estimator == 'yule_walker':\n            (p_arma, res_arma) = yule_walker(resid, ar_order=spec.ar_order, demean=False, **arma_estimator_kwargs)\n        elif arma_estimator == 'burg':\n            _check_arma_estimator_kwargs(arma_estimator_kwargs, 'burg')\n            (p_arma, res_arma) = burg(resid, ar_order=spec.ar_order, demean=False)\n        elif arma_estimator == 'innovations':\n            _check_arma_estimator_kwargs(arma_estimator_kwargs, 'innovations')\n            (out, res_arma) = innovations(resid, ma_order=spec.ma_order, demean=False)\n            p_arma = out[-1]\n        elif arma_estimator == 'hannan_rissanen':\n            (p_arma, res_arma) = hannan_rissanen(resid, ar_order=spec.ar_order, ma_order=spec.ma_order, demean=False, **arma_estimator_kwargs)\n        else:\n            start_params = None if i == 1 else np.r_[ar_params, ma_params, seasonal_ar_params, seasonal_ma_params, sigma2]\n            tmp_order = (spec.order[0], 0, spec.order[2])\n            tmp_seasonal_order = (spec.seasonal_order[0], 0, spec.seasonal_order[2], spec.seasonal_order[3])\n            if arma_estimator == 'innovations_mle':\n                (p_arma, res_arma) = innovations_mle(resid, order=tmp_order, seasonal_order=tmp_seasonal_order, demean=False, start_params=start_params, **arma_estimator_kwargs)\n            else:\n                (p_arma, res_arma) = statespace(resid, order=tmp_order, seasonal_order=tmp_seasonal_order, include_constant=False, start_params=start_params, **arma_estimator_kwargs)\n        ar_params = p_arma.ar_params\n        seasonal_ar_params = p_arma.seasonal_ar_params\n        ma_params = p_arma.ma_params\n        seasonal_ma_params = p_arma.seasonal_ma_params\n        sigma2 = p_arma.sigma2\n        arma_results.append(res_arma)\n        if not p_arma.is_stationary:\n            raise ValueError('Roots of the autoregressive parameters indicate that data isnon-stationary. GLS cannot be used with non-stationary parameters. You should consider differencing the model dataor applying a nonlinear transformation (e.g., natural log).')\n        (tmp, _) = arma_innovations.arma_innovations(augmented, ar_params=ar_params, ma_params=ma_params, normalize=True)\n        u = tmp[:, 0]\n        x = tmp[:, 1:]\n        mod_gls = OLS(u, x)\n        res_gls = mod_gls.fit()\n        exog_params = res_gls.params\n        resid = endog - np.dot(exog, exog_params)\n        p = SARIMAXParams(spec=spec)\n        p.exog_params = exog_params\n        if spec.max_ar_order > 0:\n            p.ar_params = ar_params\n        if spec.max_seasonal_ar_order > 0:\n            p.seasonal_ar_params = seasonal_ar_params\n        if spec.max_ma_order > 0:\n            p.ma_params = ma_params\n        if spec.max_seasonal_ma_order > 0:\n            p.seasonal_ma_params = seasonal_ma_params\n        p.sigma2 = sigma2\n        parameters.append(p)\n        difference = np.abs(exog_params - prev)\n        differences.append(difference)\n        if n_iter is None and np.all(difference < tolerance):\n            converged = True\n            break\n    else:\n        if n_iter is None:\n            warnings.warn('Feasible GLS failed to converge in %d iterations. Consider increasing the maximum number of iterations using the `max_iter` argument or reducing the required tolerance using the `tolerance` argument.' % max_iter)\n    p = parameters[-1]\n    other_results = Bunch({'spec': spec, 'params': parameters, 'converged': converged, 'differences': differences, 'iterations': i, 'arma_estimator': arma_estimator, 'arma_estimator_kwargs': arma_estimator_kwargs, 'arma_results': arma_results})\n    return (p, other_results)",
            "def gls(endog, exog=None, order=(0, 0, 0), seasonal_order=(0, 0, 0, 0), include_constant=None, n_iter=None, max_iter=50, tolerance=1e-08, arma_estimator='innovations_mle', arma_estimator_kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Estimate ARMAX parameters by GLS.\\n\\n    Parameters\\n    ----------\\n    endog : array_like\\n        Input time series array.\\n    exog : array_like, optional\\n        Array of exogenous regressors. If not included, then `include_constant`\\n        must be True, and then `exog` will only include the constant column.\\n    order : tuple, optional\\n        The (p,d,q) order of the ARIMA model. Default is (0, 0, 0).\\n    seasonal_order : tuple, optional\\n        The (P,D,Q,s) order of the seasonal ARIMA model.\\n        Default is (0, 0, 0, 0).\\n    include_constant : bool, optional\\n        Whether to add a constant term in `exog` if it's not already there.\\n        The estimate of the constant will then appear as one of the `exog`\\n        parameters. If `exog` is None, then the constant will represent the\\n        mean of the process. Default is True if the specified model does not\\n        include integration and False otherwise.\\n    n_iter : int, optional\\n        Optionally iterate feasible GSL a specific number of times. Default is\\n        to iterate to convergence. If set, this argument overrides the\\n        `max_iter` and `tolerance` arguments.\\n    max_iter : int, optional\\n        Maximum number of feasible GLS iterations. Default is 50. If `n_iter`\\n        is set, it overrides this argument.\\n    tolerance : float, optional\\n        Tolerance for determining convergence of feasible GSL iterations. If\\n        `iter` is set, this argument has no effect.\\n        Default is 1e-8.\\n    arma_estimator : str, optional\\n        The estimator used for estimating the ARMA model. This option should\\n        not generally be used, unless the default method is failing or is\\n        otherwise unsuitable. Not all values will be valid, depending on the\\n        specified model orders (`order` and `seasonal_order`). Possible values\\n        are:\\n        * 'innovations_mle' - can be used with any specification\\n        * 'statespace' - can be used with any specification\\n        * 'hannan_rissanen' - can be used with any ARMA non-seasonal model\\n        * 'yule_walker' - only non-seasonal consecutive\\n          autoregressive (AR) models\\n        * 'burg' - only non-seasonal, consecutive autoregressive (AR) models\\n        * 'innovations' - only non-seasonal, consecutive moving\\n          average (MA) models.\\n        The default is 'innovations_mle'.\\n    arma_estimator_kwargs : dict, optional\\n        Arguments to pass to the ARMA estimator.\\n\\n    Returns\\n    -------\\n    parameters : SARIMAXParams object\\n        Contains the parameter estimates from the final iteration.\\n    other_results : Bunch\\n        Includes eight components: `spec`, `params`, `converged`,\\n        `differences`, `iterations`, `arma_estimator`, 'arma_estimator_kwargs',\\n        and `arma_results`.\\n\\n    Notes\\n    -----\\n    The primary reference is [1]_, section 6.6. In particular, the\\n    implementation follows the iterative procedure described in section 6.6.2.\\n    Construction of the transformed variables used to compute the GLS estimator\\n    described in section 6.6.1 is done via an application of the innovations\\n    algorithm (rather than explicit construction of the transformation matrix).\\n\\n    Note that if the specified model includes integration, both the `endog` and\\n    `exog` series will be differenced prior to estimation and a warning will\\n    be issued to alert the user.\\n\\n    References\\n    ----------\\n    .. [1] Brockwell, Peter J., and Richard A. Davis. 2016.\\n       Introduction to Time Series and Forecasting. Springer.\\n    \"\n    if n_iter is not None:\n        max_iter = n_iter\n        tolerance = np.inf\n    integrated = order[1] > 0 or seasonal_order[1] > 0\n    if include_constant is None:\n        include_constant = not integrated\n    elif include_constant and integrated:\n        raise ValueError('Cannot include a constant in an integrated model.')\n    if include_constant:\n        exog = np.ones_like(endog) if exog is None else add_constant(exog)\n    spec = SARIMAXSpecification(endog, exog=exog, order=order, seasonal_order=seasonal_order)\n    endog = spec.endog\n    exog = spec.exog\n    if spec.is_integrated:\n        warnings.warn('Provided `endog` and `exog` series have been differenced to eliminate integration prior to GLS parameter estimation.')\n        endog = diff(endog, k_diff=spec.diff, k_seasonal_diff=spec.seasonal_diff, seasonal_periods=spec.seasonal_periods)\n        exog = diff(exog, k_diff=spec.diff, k_seasonal_diff=spec.seasonal_diff, seasonal_periods=spec.seasonal_periods)\n    augmented = np.c_[endog, exog]\n    spec.validate_estimator(arma_estimator)\n    if arma_estimator_kwargs is None:\n        arma_estimator_kwargs = {}\n    mod_ols = OLS(endog, exog)\n    res_ols = mod_ols.fit()\n    exog_params = res_ols.params\n    resid = res_ols.resid\n    p = SARIMAXParams(spec=spec)\n    p.exog_params = exog_params\n    if spec.max_ar_order > 0:\n        p.ar_params = np.zeros(spec.k_ar_params)\n    if spec.max_seasonal_ar_order > 0:\n        p.seasonal_ar_params = np.zeros(spec.k_seasonal_ar_params)\n    if spec.max_ma_order > 0:\n        p.ma_params = np.zeros(spec.k_ma_params)\n    if spec.max_seasonal_ma_order > 0:\n        p.seasonal_ma_params = np.zeros(spec.k_seasonal_ma_params)\n    p.sigma2 = res_ols.scale\n    ar_params = p.ar_params\n    seasonal_ar_params = p.seasonal_ar_params\n    ma_params = p.ma_params\n    seasonal_ma_params = p.seasonal_ma_params\n    sigma2 = p.sigma2\n    arma_results = [None]\n    differences = [None]\n    parameters = [p]\n    converged = False if n_iter is None else None\n    i = 0\n\n    def _check_arma_estimator_kwargs(kwargs, method):\n        if kwargs:\n            raise ValueError(f'arma_estimator_kwargs not supported for method {method}')\n    for i in range(1, max_iter + 1):\n        prev = exog_params\n        if arma_estimator == 'yule_walker':\n            (p_arma, res_arma) = yule_walker(resid, ar_order=spec.ar_order, demean=False, **arma_estimator_kwargs)\n        elif arma_estimator == 'burg':\n            _check_arma_estimator_kwargs(arma_estimator_kwargs, 'burg')\n            (p_arma, res_arma) = burg(resid, ar_order=spec.ar_order, demean=False)\n        elif arma_estimator == 'innovations':\n            _check_arma_estimator_kwargs(arma_estimator_kwargs, 'innovations')\n            (out, res_arma) = innovations(resid, ma_order=spec.ma_order, demean=False)\n            p_arma = out[-1]\n        elif arma_estimator == 'hannan_rissanen':\n            (p_arma, res_arma) = hannan_rissanen(resid, ar_order=spec.ar_order, ma_order=spec.ma_order, demean=False, **arma_estimator_kwargs)\n        else:\n            start_params = None if i == 1 else np.r_[ar_params, ma_params, seasonal_ar_params, seasonal_ma_params, sigma2]\n            tmp_order = (spec.order[0], 0, spec.order[2])\n            tmp_seasonal_order = (spec.seasonal_order[0], 0, spec.seasonal_order[2], spec.seasonal_order[3])\n            if arma_estimator == 'innovations_mle':\n                (p_arma, res_arma) = innovations_mle(resid, order=tmp_order, seasonal_order=tmp_seasonal_order, demean=False, start_params=start_params, **arma_estimator_kwargs)\n            else:\n                (p_arma, res_arma) = statespace(resid, order=tmp_order, seasonal_order=tmp_seasonal_order, include_constant=False, start_params=start_params, **arma_estimator_kwargs)\n        ar_params = p_arma.ar_params\n        seasonal_ar_params = p_arma.seasonal_ar_params\n        ma_params = p_arma.ma_params\n        seasonal_ma_params = p_arma.seasonal_ma_params\n        sigma2 = p_arma.sigma2\n        arma_results.append(res_arma)\n        if not p_arma.is_stationary:\n            raise ValueError('Roots of the autoregressive parameters indicate that data isnon-stationary. GLS cannot be used with non-stationary parameters. You should consider differencing the model dataor applying a nonlinear transformation (e.g., natural log).')\n        (tmp, _) = arma_innovations.arma_innovations(augmented, ar_params=ar_params, ma_params=ma_params, normalize=True)\n        u = tmp[:, 0]\n        x = tmp[:, 1:]\n        mod_gls = OLS(u, x)\n        res_gls = mod_gls.fit()\n        exog_params = res_gls.params\n        resid = endog - np.dot(exog, exog_params)\n        p = SARIMAXParams(spec=spec)\n        p.exog_params = exog_params\n        if spec.max_ar_order > 0:\n            p.ar_params = ar_params\n        if spec.max_seasonal_ar_order > 0:\n            p.seasonal_ar_params = seasonal_ar_params\n        if spec.max_ma_order > 0:\n            p.ma_params = ma_params\n        if spec.max_seasonal_ma_order > 0:\n            p.seasonal_ma_params = seasonal_ma_params\n        p.sigma2 = sigma2\n        parameters.append(p)\n        difference = np.abs(exog_params - prev)\n        differences.append(difference)\n        if n_iter is None and np.all(difference < tolerance):\n            converged = True\n            break\n    else:\n        if n_iter is None:\n            warnings.warn('Feasible GLS failed to converge in %d iterations. Consider increasing the maximum number of iterations using the `max_iter` argument or reducing the required tolerance using the `tolerance` argument.' % max_iter)\n    p = parameters[-1]\n    other_results = Bunch({'spec': spec, 'params': parameters, 'converged': converged, 'differences': differences, 'iterations': i, 'arma_estimator': arma_estimator, 'arma_estimator_kwargs': arma_estimator_kwargs, 'arma_results': arma_results})\n    return (p, other_results)"
        ]
    }
]