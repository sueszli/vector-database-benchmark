[
    {
        "func_name": "run",
        "original": "def run(self, path_to_output, opts, db, notification=DummyReporter()):\n    from calibre.library.catalogs.epub_mobi_builder import CatalogBuilder\n    from calibre.utils.config import JSONConfig\n    from calibre.utils.logging import default_log as log\n    if hasattr(opts, 'preset') and opts.preset:\n        available_presets = JSONConfig('catalog_presets')\n        if opts.preset not in available_presets:\n            if available_presets:\n                print(_('Error: Preset \"%s\" not found.' % opts.preset))\n                print(_('Stored presets: %s' % ', '.join([p for p in sorted(available_presets.keys())])))\n            else:\n                print(_('Error: No stored presets.'))\n            return 1\n        for item in available_presets[opts.preset]:\n            if item not in ['exclusion_rules_tw', 'format', 'prefix_rules_tw']:\n                setattr(opts, item, available_presets[opts.preset][item])\n        opts.connected_device = {'is_device_connected': False, 'kind': None, 'name': None, 'save_template': None, 'serial': None, 'storage': None}\n        prs = []\n        for rule in opts.prefix_rules:\n            prs.append(tuple(rule))\n        opts.prefix_rules = tuple(prs)\n        ers = []\n        for rule in opts.exclusion_rules:\n            ers.append(tuple(rule))\n        opts.exclusion_rules = tuple(ers)\n    opts.log = log\n    opts.fmt = self.fmt = path_to_output.rpartition('.')[2]\n    opts.creator = '{}, {} {}, {}'.format(strftime('%A'), strftime('%B'), strftime('%d').lstrip('0'), strftime('%Y'))\n    opts.creator_sort_as = '{} {}'.format('calibre', strftime('%Y-%m-%d'))\n    opts.connected_kindle = False\n    op = opts.output_profile\n    if op is None:\n        op = 'default'\n    if opts.connected_device['name'] and 'kindle' in opts.connected_device['name'].lower():\n        opts.connected_kindle = True\n        if opts.connected_device['serial'] and opts.connected_device['serial'][:4] in ['B004', 'B005']:\n            op = 'kindle_dx'\n        else:\n            op = 'kindle'\n    opts.description_clip = 380 if op.endswith('dx') or 'kindle' not in op else 100\n    opts.author_clip = 100 if op.endswith('dx') or 'kindle' not in op else 60\n    opts.output_profile = op\n    opts.basename = 'Catalog'\n    opts.cli_environment = not hasattr(opts, 'sync')\n    opts.sort_descriptions_by_author = True\n    build_log = []\n    build_log.append(\"%s('%s'): Generating %s %sin %s environment, locale: '%s'\" % (self.name, current_library_name(), self.fmt, 'for %s ' % opts.output_profile if opts.output_profile else '', 'CLI' if opts.cli_environment else 'GUI', calibre_langcode_to_name(canonicalize_lang(get_lang()), localize=False)))\n    if opts.exclude_genre.strip() == '':\n        opts.exclude_genre = 'a^'\n        build_log.append(\" converting empty exclude_genre to 'a^'\")\n    if opts.connected_device['is_device_connected'] and opts.connected_device['kind'] == 'device':\n        if opts.connected_device['serial']:\n            build_log.append(\" connected_device: '%s' #%s%s \" % (opts.connected_device['name'], opts.connected_device['serial'][0:4], 'x' * (len(opts.connected_device['serial']) - 4)))\n            for storage in opts.connected_device['storage']:\n                if storage:\n                    build_log.append('  mount point: %s' % storage)\n        else:\n            build_log.append(\" connected_device: '%s'\" % opts.connected_device['name'])\n            try:\n                for storage in opts.connected_device['storage']:\n                    if storage:\n                        build_log.append('  mount point: %s' % storage)\n            except:\n                build_log.append('  (no mount points)')\n    else:\n        build_log.append(\" connected_device: '%s'\" % opts.connected_device['name'])\n    opts_dict = vars(opts)\n    if opts_dict['ids']:\n        build_log.append(' book count: %d' % len(opts_dict['ids']))\n    sections_list = []\n    if opts.generate_authors:\n        sections_list.append('Authors')\n    if opts.generate_titles:\n        sections_list.append('Titles')\n    if opts.generate_series:\n        sections_list.append('Series')\n    if opts.generate_genres:\n        sections_list.append('Genres')\n    if opts.generate_recently_added:\n        sections_list.append('Recently Added')\n    if opts.generate_descriptions:\n        sections_list.append('Descriptions')\n    if not sections_list:\n        if opts.cli_environment:\n            opts.log.warn('*** No Section switches specified, enabling all Sections ***')\n            opts.generate_authors = True\n            opts.generate_titles = True\n            opts.generate_series = True\n            opts.generate_genres = True\n            opts.generate_recently_added = True\n            opts.generate_descriptions = True\n            sections_list = ['Authors', 'Titles', 'Series', 'Genres', 'Recently Added', 'Descriptions']\n        else:\n            opts.log.warn('\\n*** No enabled Sections, terminating catalog generation ***')\n            return ['No Included Sections', \"No enabled Sections.\\nCheck E-book options tab\\n'Included sections'\\n\"]\n    if opts.fmt == 'mobi' and sections_list == ['Descriptions']:\n        warning = _(\"\\n*** Adding 'By authors' section required for MOBI output ***\")\n        opts.log.warn(warning)\n        sections_list.insert(0, 'Authors')\n        opts.generate_authors = True\n    opts.log(' Sections: %s' % ', '.join(sections_list))\n    opts.section_list = sections_list\n    try:\n        if float(opts.thumb_width) < float(self.THUMB_SMALLEST):\n            log.warning(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_SMALLEST}'\")\n            opts.thumb_width = self.THUMB_SMALLEST\n        if float(opts.thumb_width) > float(self.THUMB_LARGEST):\n            log.warning(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_LARGEST}'\")\n            opts.thumb_width = self.THUMB_LARGEST\n        opts.thumb_width = '%.2f' % float(opts.thumb_width)\n    except Exception:\n        log.error(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_SMALLEST}'\")\n        opts.thumb_width = '1.0'\n    if type(opts.prefix_rules) is not tuple:\n        try:\n            opts.prefix_rules = eval(opts.prefix_rules)\n        except:\n            log.error('malformed --prefix-rules: %s' % opts.prefix_rules)\n            raise\n        for rule in opts.prefix_rules:\n            if len(rule) != 4:\n                log.error('incorrect number of args for --prefix-rules: %s' % repr(rule))\n    if type(opts.exclusion_rules) is not tuple:\n        try:\n            opts.exclusion_rules = eval(opts.exclusion_rules)\n        except:\n            log.error('malformed --exclusion-rules: %s' % opts.exclusion_rules)\n            raise\n        for rule in opts.exclusion_rules:\n            if len(rule) != 3:\n                log.error('incorrect number of args for --exclusion-rules: %s' % repr(rule))\n    keys = sorted(opts_dict.keys())\n    build_log.append(' opts:')\n    for key in keys:\n        if key in ['catalog_title', 'author_clip', 'connected_kindle', 'creator', 'cross_reference_authors', 'description_clip', 'exclude_book_marker', 'exclude_genre', 'exclude_tags', 'exclusion_rules', 'fmt', 'genre_source_field', 'header_note_source_field', 'merge_comments_rule', 'output_profile', 'prefix_rules', 'preset', 'read_book_marker', 'search_text', 'sort_by', 'sort_descriptions_by_author', 'sync', 'thumb_width', 'use_existing_cover', 'wishlist_tag']:\n            build_log.append(f'  {key}: {repr(opts_dict[key])}')\n    if opts.verbose:\n        log('\\n'.join((line for line in build_log)))\n    opts.start_time = time.time()\n    self.opts = opts\n    if opts.verbose:\n        log.info(' Begin catalog source generation (%s)' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    catalog = CatalogBuilder(db, opts, self, report_progress=notification)\n    try:\n        catalog.build_sources()\n        if opts.verbose:\n            log.info(' Completed catalog source generation (%s)\\n' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    except (AuthorSortMismatchException, EmptyCatalogException) as e:\n        log.error(' *** Terminated catalog generation: %s ***' % e)\n    except:\n        log.error(' unhandled exception in catalog generator')\n        raise\n    else:\n        recommendations = []\n        recommendations.append(('remove_fake_margins', False, OptionRecommendation.HIGH))\n        recommendations.append(('comments', '', OptionRecommendation.HIGH))\n        '\\n            >>> Use to debug generated catalog code before pipeline conversion <<<\\n            '\n        GENERATE_DEBUG_EPUB = False\n        if GENERATE_DEBUG_EPUB:\n            catalog_debug_path = os.path.join(os.path.expanduser('~'), 'Desktop', 'Catalog debug')\n            setattr(opts, 'debug_pipeline', os.path.expanduser(catalog_debug_path))\n        dp = getattr(opts, 'debug_pipeline', None)\n        if dp is not None:\n            recommendations.append(('debug_pipeline', dp, OptionRecommendation.HIGH))\n        if opts.output_profile and opts.output_profile.startswith('kindle'):\n            recommendations.append(('output_profile', opts.output_profile, OptionRecommendation.HIGH))\n            recommendations.append(('book_producer', opts.output_profile, OptionRecommendation.HIGH))\n            if opts.fmt == 'mobi':\n                recommendations.append(('no_inline_toc', True, OptionRecommendation.HIGH))\n                recommendations.append(('verbose', 2, OptionRecommendation.HIGH))\n        cpath = None\n        existing_cover = False\n        try:\n            search_text = 'title:\"{}\" author:{}'.format(opts.catalog_title.replace('\"', '\\\\\"'), 'calibre')\n            matches = db.search(search_text, return_matches=True, sort_results=False)\n            if matches:\n                cpath = db.cover(matches[0], index_is_id=True, as_path=True)\n                if cpath and os.path.exists(cpath):\n                    existing_cover = True\n        except:\n            pass\n        if self.opts.use_existing_cover and (not existing_cover):\n            log.warning('no existing catalog cover found')\n        if self.opts.use_existing_cover and existing_cover:\n            recommendations.append(('cover', cpath, OptionRecommendation.HIGH))\n            log.info('using existing catalog cover')\n        else:\n            from calibre.ebooks.covers import calibre_cover2\n            log.info('replacing catalog cover')\n            new_cover_path = PersistentTemporaryFile(suffix='.jpg')\n            new_cover = calibre_cover2(opts.catalog_title, 'calibre')\n            new_cover_path.write(new_cover)\n            new_cover_path.close()\n            recommendations.append(('cover', new_cover_path.name, OptionRecommendation.HIGH))\n        from calibre.ebooks.conversion.plumber import Plumber\n        plumber = Plumber(os.path.join(catalog.catalog_path, opts.basename + '.opf'), path_to_output, log, report_progress=notification, abort_after_input_dump=False)\n        plumber.merge_ui_recommendations(recommendations)\n        plumber.run()\n        try:\n            os.remove(cpath)\n        except:\n            pass\n        if GENERATE_DEBUG_EPUB:\n            from calibre.ebooks.epub import initialize_container\n            from calibre.ebooks.tweak import zip_rebuilder\n            from calibre.utils.zipfile import ZipFile\n            input_path = os.path.join(catalog_debug_path, 'input')\n            epub_shell = os.path.join(catalog_debug_path, 'epub_shell.zip')\n            initialize_container(epub_shell, opf_name='content.opf')\n            with ZipFile(epub_shell, 'r') as zf:\n                zf.extractall(path=input_path)\n            os.remove(epub_shell)\n            zip_rebuilder(input_path, os.path.join(catalog_debug_path, 'input.epub'))\n        if opts.verbose:\n            log.info(' Catalog creation complete (%s)\\n' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    return catalog.error",
        "mutated": [
            "def run(self, path_to_output, opts, db, notification=DummyReporter()):\n    if False:\n        i = 10\n    from calibre.library.catalogs.epub_mobi_builder import CatalogBuilder\n    from calibre.utils.config import JSONConfig\n    from calibre.utils.logging import default_log as log\n    if hasattr(opts, 'preset') and opts.preset:\n        available_presets = JSONConfig('catalog_presets')\n        if opts.preset not in available_presets:\n            if available_presets:\n                print(_('Error: Preset \"%s\" not found.' % opts.preset))\n                print(_('Stored presets: %s' % ', '.join([p for p in sorted(available_presets.keys())])))\n            else:\n                print(_('Error: No stored presets.'))\n            return 1\n        for item in available_presets[opts.preset]:\n            if item not in ['exclusion_rules_tw', 'format', 'prefix_rules_tw']:\n                setattr(opts, item, available_presets[opts.preset][item])\n        opts.connected_device = {'is_device_connected': False, 'kind': None, 'name': None, 'save_template': None, 'serial': None, 'storage': None}\n        prs = []\n        for rule in opts.prefix_rules:\n            prs.append(tuple(rule))\n        opts.prefix_rules = tuple(prs)\n        ers = []\n        for rule in opts.exclusion_rules:\n            ers.append(tuple(rule))\n        opts.exclusion_rules = tuple(ers)\n    opts.log = log\n    opts.fmt = self.fmt = path_to_output.rpartition('.')[2]\n    opts.creator = '{}, {} {}, {}'.format(strftime('%A'), strftime('%B'), strftime('%d').lstrip('0'), strftime('%Y'))\n    opts.creator_sort_as = '{} {}'.format('calibre', strftime('%Y-%m-%d'))\n    opts.connected_kindle = False\n    op = opts.output_profile\n    if op is None:\n        op = 'default'\n    if opts.connected_device['name'] and 'kindle' in opts.connected_device['name'].lower():\n        opts.connected_kindle = True\n        if opts.connected_device['serial'] and opts.connected_device['serial'][:4] in ['B004', 'B005']:\n            op = 'kindle_dx'\n        else:\n            op = 'kindle'\n    opts.description_clip = 380 if op.endswith('dx') or 'kindle' not in op else 100\n    opts.author_clip = 100 if op.endswith('dx') or 'kindle' not in op else 60\n    opts.output_profile = op\n    opts.basename = 'Catalog'\n    opts.cli_environment = not hasattr(opts, 'sync')\n    opts.sort_descriptions_by_author = True\n    build_log = []\n    build_log.append(\"%s('%s'): Generating %s %sin %s environment, locale: '%s'\" % (self.name, current_library_name(), self.fmt, 'for %s ' % opts.output_profile if opts.output_profile else '', 'CLI' if opts.cli_environment else 'GUI', calibre_langcode_to_name(canonicalize_lang(get_lang()), localize=False)))\n    if opts.exclude_genre.strip() == '':\n        opts.exclude_genre = 'a^'\n        build_log.append(\" converting empty exclude_genre to 'a^'\")\n    if opts.connected_device['is_device_connected'] and opts.connected_device['kind'] == 'device':\n        if opts.connected_device['serial']:\n            build_log.append(\" connected_device: '%s' #%s%s \" % (opts.connected_device['name'], opts.connected_device['serial'][0:4], 'x' * (len(opts.connected_device['serial']) - 4)))\n            for storage in opts.connected_device['storage']:\n                if storage:\n                    build_log.append('  mount point: %s' % storage)\n        else:\n            build_log.append(\" connected_device: '%s'\" % opts.connected_device['name'])\n            try:\n                for storage in opts.connected_device['storage']:\n                    if storage:\n                        build_log.append('  mount point: %s' % storage)\n            except:\n                build_log.append('  (no mount points)')\n    else:\n        build_log.append(\" connected_device: '%s'\" % opts.connected_device['name'])\n    opts_dict = vars(opts)\n    if opts_dict['ids']:\n        build_log.append(' book count: %d' % len(opts_dict['ids']))\n    sections_list = []\n    if opts.generate_authors:\n        sections_list.append('Authors')\n    if opts.generate_titles:\n        sections_list.append('Titles')\n    if opts.generate_series:\n        sections_list.append('Series')\n    if opts.generate_genres:\n        sections_list.append('Genres')\n    if opts.generate_recently_added:\n        sections_list.append('Recently Added')\n    if opts.generate_descriptions:\n        sections_list.append('Descriptions')\n    if not sections_list:\n        if opts.cli_environment:\n            opts.log.warn('*** No Section switches specified, enabling all Sections ***')\n            opts.generate_authors = True\n            opts.generate_titles = True\n            opts.generate_series = True\n            opts.generate_genres = True\n            opts.generate_recently_added = True\n            opts.generate_descriptions = True\n            sections_list = ['Authors', 'Titles', 'Series', 'Genres', 'Recently Added', 'Descriptions']\n        else:\n            opts.log.warn('\\n*** No enabled Sections, terminating catalog generation ***')\n            return ['No Included Sections', \"No enabled Sections.\\nCheck E-book options tab\\n'Included sections'\\n\"]\n    if opts.fmt == 'mobi' and sections_list == ['Descriptions']:\n        warning = _(\"\\n*** Adding 'By authors' section required for MOBI output ***\")\n        opts.log.warn(warning)\n        sections_list.insert(0, 'Authors')\n        opts.generate_authors = True\n    opts.log(' Sections: %s' % ', '.join(sections_list))\n    opts.section_list = sections_list\n    try:\n        if float(opts.thumb_width) < float(self.THUMB_SMALLEST):\n            log.warning(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_SMALLEST}'\")\n            opts.thumb_width = self.THUMB_SMALLEST\n        if float(opts.thumb_width) > float(self.THUMB_LARGEST):\n            log.warning(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_LARGEST}'\")\n            opts.thumb_width = self.THUMB_LARGEST\n        opts.thumb_width = '%.2f' % float(opts.thumb_width)\n    except Exception:\n        log.error(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_SMALLEST}'\")\n        opts.thumb_width = '1.0'\n    if type(opts.prefix_rules) is not tuple:\n        try:\n            opts.prefix_rules = eval(opts.prefix_rules)\n        except:\n            log.error('malformed --prefix-rules: %s' % opts.prefix_rules)\n            raise\n        for rule in opts.prefix_rules:\n            if len(rule) != 4:\n                log.error('incorrect number of args for --prefix-rules: %s' % repr(rule))\n    if type(opts.exclusion_rules) is not tuple:\n        try:\n            opts.exclusion_rules = eval(opts.exclusion_rules)\n        except:\n            log.error('malformed --exclusion-rules: %s' % opts.exclusion_rules)\n            raise\n        for rule in opts.exclusion_rules:\n            if len(rule) != 3:\n                log.error('incorrect number of args for --exclusion-rules: %s' % repr(rule))\n    keys = sorted(opts_dict.keys())\n    build_log.append(' opts:')\n    for key in keys:\n        if key in ['catalog_title', 'author_clip', 'connected_kindle', 'creator', 'cross_reference_authors', 'description_clip', 'exclude_book_marker', 'exclude_genre', 'exclude_tags', 'exclusion_rules', 'fmt', 'genre_source_field', 'header_note_source_field', 'merge_comments_rule', 'output_profile', 'prefix_rules', 'preset', 'read_book_marker', 'search_text', 'sort_by', 'sort_descriptions_by_author', 'sync', 'thumb_width', 'use_existing_cover', 'wishlist_tag']:\n            build_log.append(f'  {key}: {repr(opts_dict[key])}')\n    if opts.verbose:\n        log('\\n'.join((line for line in build_log)))\n    opts.start_time = time.time()\n    self.opts = opts\n    if opts.verbose:\n        log.info(' Begin catalog source generation (%s)' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    catalog = CatalogBuilder(db, opts, self, report_progress=notification)\n    try:\n        catalog.build_sources()\n        if opts.verbose:\n            log.info(' Completed catalog source generation (%s)\\n' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    except (AuthorSortMismatchException, EmptyCatalogException) as e:\n        log.error(' *** Terminated catalog generation: %s ***' % e)\n    except:\n        log.error(' unhandled exception in catalog generator')\n        raise\n    else:\n        recommendations = []\n        recommendations.append(('remove_fake_margins', False, OptionRecommendation.HIGH))\n        recommendations.append(('comments', '', OptionRecommendation.HIGH))\n        '\\n            >>> Use to debug generated catalog code before pipeline conversion <<<\\n            '\n        GENERATE_DEBUG_EPUB = False\n        if GENERATE_DEBUG_EPUB:\n            catalog_debug_path = os.path.join(os.path.expanduser('~'), 'Desktop', 'Catalog debug')\n            setattr(opts, 'debug_pipeline', os.path.expanduser(catalog_debug_path))\n        dp = getattr(opts, 'debug_pipeline', None)\n        if dp is not None:\n            recommendations.append(('debug_pipeline', dp, OptionRecommendation.HIGH))\n        if opts.output_profile and opts.output_profile.startswith('kindle'):\n            recommendations.append(('output_profile', opts.output_profile, OptionRecommendation.HIGH))\n            recommendations.append(('book_producer', opts.output_profile, OptionRecommendation.HIGH))\n            if opts.fmt == 'mobi':\n                recommendations.append(('no_inline_toc', True, OptionRecommendation.HIGH))\n                recommendations.append(('verbose', 2, OptionRecommendation.HIGH))\n        cpath = None\n        existing_cover = False\n        try:\n            search_text = 'title:\"{}\" author:{}'.format(opts.catalog_title.replace('\"', '\\\\\"'), 'calibre')\n            matches = db.search(search_text, return_matches=True, sort_results=False)\n            if matches:\n                cpath = db.cover(matches[0], index_is_id=True, as_path=True)\n                if cpath and os.path.exists(cpath):\n                    existing_cover = True\n        except:\n            pass\n        if self.opts.use_existing_cover and (not existing_cover):\n            log.warning('no existing catalog cover found')\n        if self.opts.use_existing_cover and existing_cover:\n            recommendations.append(('cover', cpath, OptionRecommendation.HIGH))\n            log.info('using existing catalog cover')\n        else:\n            from calibre.ebooks.covers import calibre_cover2\n            log.info('replacing catalog cover')\n            new_cover_path = PersistentTemporaryFile(suffix='.jpg')\n            new_cover = calibre_cover2(opts.catalog_title, 'calibre')\n            new_cover_path.write(new_cover)\n            new_cover_path.close()\n            recommendations.append(('cover', new_cover_path.name, OptionRecommendation.HIGH))\n        from calibre.ebooks.conversion.plumber import Plumber\n        plumber = Plumber(os.path.join(catalog.catalog_path, opts.basename + '.opf'), path_to_output, log, report_progress=notification, abort_after_input_dump=False)\n        plumber.merge_ui_recommendations(recommendations)\n        plumber.run()\n        try:\n            os.remove(cpath)\n        except:\n            pass\n        if GENERATE_DEBUG_EPUB:\n            from calibre.ebooks.epub import initialize_container\n            from calibre.ebooks.tweak import zip_rebuilder\n            from calibre.utils.zipfile import ZipFile\n            input_path = os.path.join(catalog_debug_path, 'input')\n            epub_shell = os.path.join(catalog_debug_path, 'epub_shell.zip')\n            initialize_container(epub_shell, opf_name='content.opf')\n            with ZipFile(epub_shell, 'r') as zf:\n                zf.extractall(path=input_path)\n            os.remove(epub_shell)\n            zip_rebuilder(input_path, os.path.join(catalog_debug_path, 'input.epub'))\n        if opts.verbose:\n            log.info(' Catalog creation complete (%s)\\n' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    return catalog.error",
            "def run(self, path_to_output, opts, db, notification=DummyReporter()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from calibre.library.catalogs.epub_mobi_builder import CatalogBuilder\n    from calibre.utils.config import JSONConfig\n    from calibre.utils.logging import default_log as log\n    if hasattr(opts, 'preset') and opts.preset:\n        available_presets = JSONConfig('catalog_presets')\n        if opts.preset not in available_presets:\n            if available_presets:\n                print(_('Error: Preset \"%s\" not found.' % opts.preset))\n                print(_('Stored presets: %s' % ', '.join([p for p in sorted(available_presets.keys())])))\n            else:\n                print(_('Error: No stored presets.'))\n            return 1\n        for item in available_presets[opts.preset]:\n            if item not in ['exclusion_rules_tw', 'format', 'prefix_rules_tw']:\n                setattr(opts, item, available_presets[opts.preset][item])\n        opts.connected_device = {'is_device_connected': False, 'kind': None, 'name': None, 'save_template': None, 'serial': None, 'storage': None}\n        prs = []\n        for rule in opts.prefix_rules:\n            prs.append(tuple(rule))\n        opts.prefix_rules = tuple(prs)\n        ers = []\n        for rule in opts.exclusion_rules:\n            ers.append(tuple(rule))\n        opts.exclusion_rules = tuple(ers)\n    opts.log = log\n    opts.fmt = self.fmt = path_to_output.rpartition('.')[2]\n    opts.creator = '{}, {} {}, {}'.format(strftime('%A'), strftime('%B'), strftime('%d').lstrip('0'), strftime('%Y'))\n    opts.creator_sort_as = '{} {}'.format('calibre', strftime('%Y-%m-%d'))\n    opts.connected_kindle = False\n    op = opts.output_profile\n    if op is None:\n        op = 'default'\n    if opts.connected_device['name'] and 'kindle' in opts.connected_device['name'].lower():\n        opts.connected_kindle = True\n        if opts.connected_device['serial'] and opts.connected_device['serial'][:4] in ['B004', 'B005']:\n            op = 'kindle_dx'\n        else:\n            op = 'kindle'\n    opts.description_clip = 380 if op.endswith('dx') or 'kindle' not in op else 100\n    opts.author_clip = 100 if op.endswith('dx') or 'kindle' not in op else 60\n    opts.output_profile = op\n    opts.basename = 'Catalog'\n    opts.cli_environment = not hasattr(opts, 'sync')\n    opts.sort_descriptions_by_author = True\n    build_log = []\n    build_log.append(\"%s('%s'): Generating %s %sin %s environment, locale: '%s'\" % (self.name, current_library_name(), self.fmt, 'for %s ' % opts.output_profile if opts.output_profile else '', 'CLI' if opts.cli_environment else 'GUI', calibre_langcode_to_name(canonicalize_lang(get_lang()), localize=False)))\n    if opts.exclude_genre.strip() == '':\n        opts.exclude_genre = 'a^'\n        build_log.append(\" converting empty exclude_genre to 'a^'\")\n    if opts.connected_device['is_device_connected'] and opts.connected_device['kind'] == 'device':\n        if opts.connected_device['serial']:\n            build_log.append(\" connected_device: '%s' #%s%s \" % (opts.connected_device['name'], opts.connected_device['serial'][0:4], 'x' * (len(opts.connected_device['serial']) - 4)))\n            for storage in opts.connected_device['storage']:\n                if storage:\n                    build_log.append('  mount point: %s' % storage)\n        else:\n            build_log.append(\" connected_device: '%s'\" % opts.connected_device['name'])\n            try:\n                for storage in opts.connected_device['storage']:\n                    if storage:\n                        build_log.append('  mount point: %s' % storage)\n            except:\n                build_log.append('  (no mount points)')\n    else:\n        build_log.append(\" connected_device: '%s'\" % opts.connected_device['name'])\n    opts_dict = vars(opts)\n    if opts_dict['ids']:\n        build_log.append(' book count: %d' % len(opts_dict['ids']))\n    sections_list = []\n    if opts.generate_authors:\n        sections_list.append('Authors')\n    if opts.generate_titles:\n        sections_list.append('Titles')\n    if opts.generate_series:\n        sections_list.append('Series')\n    if opts.generate_genres:\n        sections_list.append('Genres')\n    if opts.generate_recently_added:\n        sections_list.append('Recently Added')\n    if opts.generate_descriptions:\n        sections_list.append('Descriptions')\n    if not sections_list:\n        if opts.cli_environment:\n            opts.log.warn('*** No Section switches specified, enabling all Sections ***')\n            opts.generate_authors = True\n            opts.generate_titles = True\n            opts.generate_series = True\n            opts.generate_genres = True\n            opts.generate_recently_added = True\n            opts.generate_descriptions = True\n            sections_list = ['Authors', 'Titles', 'Series', 'Genres', 'Recently Added', 'Descriptions']\n        else:\n            opts.log.warn('\\n*** No enabled Sections, terminating catalog generation ***')\n            return ['No Included Sections', \"No enabled Sections.\\nCheck E-book options tab\\n'Included sections'\\n\"]\n    if opts.fmt == 'mobi' and sections_list == ['Descriptions']:\n        warning = _(\"\\n*** Adding 'By authors' section required for MOBI output ***\")\n        opts.log.warn(warning)\n        sections_list.insert(0, 'Authors')\n        opts.generate_authors = True\n    opts.log(' Sections: %s' % ', '.join(sections_list))\n    opts.section_list = sections_list\n    try:\n        if float(opts.thumb_width) < float(self.THUMB_SMALLEST):\n            log.warning(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_SMALLEST}'\")\n            opts.thumb_width = self.THUMB_SMALLEST\n        if float(opts.thumb_width) > float(self.THUMB_LARGEST):\n            log.warning(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_LARGEST}'\")\n            opts.thumb_width = self.THUMB_LARGEST\n        opts.thumb_width = '%.2f' % float(opts.thumb_width)\n    except Exception:\n        log.error(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_SMALLEST}'\")\n        opts.thumb_width = '1.0'\n    if type(opts.prefix_rules) is not tuple:\n        try:\n            opts.prefix_rules = eval(opts.prefix_rules)\n        except:\n            log.error('malformed --prefix-rules: %s' % opts.prefix_rules)\n            raise\n        for rule in opts.prefix_rules:\n            if len(rule) != 4:\n                log.error('incorrect number of args for --prefix-rules: %s' % repr(rule))\n    if type(opts.exclusion_rules) is not tuple:\n        try:\n            opts.exclusion_rules = eval(opts.exclusion_rules)\n        except:\n            log.error('malformed --exclusion-rules: %s' % opts.exclusion_rules)\n            raise\n        for rule in opts.exclusion_rules:\n            if len(rule) != 3:\n                log.error('incorrect number of args for --exclusion-rules: %s' % repr(rule))\n    keys = sorted(opts_dict.keys())\n    build_log.append(' opts:')\n    for key in keys:\n        if key in ['catalog_title', 'author_clip', 'connected_kindle', 'creator', 'cross_reference_authors', 'description_clip', 'exclude_book_marker', 'exclude_genre', 'exclude_tags', 'exclusion_rules', 'fmt', 'genre_source_field', 'header_note_source_field', 'merge_comments_rule', 'output_profile', 'prefix_rules', 'preset', 'read_book_marker', 'search_text', 'sort_by', 'sort_descriptions_by_author', 'sync', 'thumb_width', 'use_existing_cover', 'wishlist_tag']:\n            build_log.append(f'  {key}: {repr(opts_dict[key])}')\n    if opts.verbose:\n        log('\\n'.join((line for line in build_log)))\n    opts.start_time = time.time()\n    self.opts = opts\n    if opts.verbose:\n        log.info(' Begin catalog source generation (%s)' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    catalog = CatalogBuilder(db, opts, self, report_progress=notification)\n    try:\n        catalog.build_sources()\n        if opts.verbose:\n            log.info(' Completed catalog source generation (%s)\\n' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    except (AuthorSortMismatchException, EmptyCatalogException) as e:\n        log.error(' *** Terminated catalog generation: %s ***' % e)\n    except:\n        log.error(' unhandled exception in catalog generator')\n        raise\n    else:\n        recommendations = []\n        recommendations.append(('remove_fake_margins', False, OptionRecommendation.HIGH))\n        recommendations.append(('comments', '', OptionRecommendation.HIGH))\n        '\\n            >>> Use to debug generated catalog code before pipeline conversion <<<\\n            '\n        GENERATE_DEBUG_EPUB = False\n        if GENERATE_DEBUG_EPUB:\n            catalog_debug_path = os.path.join(os.path.expanduser('~'), 'Desktop', 'Catalog debug')\n            setattr(opts, 'debug_pipeline', os.path.expanduser(catalog_debug_path))\n        dp = getattr(opts, 'debug_pipeline', None)\n        if dp is not None:\n            recommendations.append(('debug_pipeline', dp, OptionRecommendation.HIGH))\n        if opts.output_profile and opts.output_profile.startswith('kindle'):\n            recommendations.append(('output_profile', opts.output_profile, OptionRecommendation.HIGH))\n            recommendations.append(('book_producer', opts.output_profile, OptionRecommendation.HIGH))\n            if opts.fmt == 'mobi':\n                recommendations.append(('no_inline_toc', True, OptionRecommendation.HIGH))\n                recommendations.append(('verbose', 2, OptionRecommendation.HIGH))\n        cpath = None\n        existing_cover = False\n        try:\n            search_text = 'title:\"{}\" author:{}'.format(opts.catalog_title.replace('\"', '\\\\\"'), 'calibre')\n            matches = db.search(search_text, return_matches=True, sort_results=False)\n            if matches:\n                cpath = db.cover(matches[0], index_is_id=True, as_path=True)\n                if cpath and os.path.exists(cpath):\n                    existing_cover = True\n        except:\n            pass\n        if self.opts.use_existing_cover and (not existing_cover):\n            log.warning('no existing catalog cover found')\n        if self.opts.use_existing_cover and existing_cover:\n            recommendations.append(('cover', cpath, OptionRecommendation.HIGH))\n            log.info('using existing catalog cover')\n        else:\n            from calibre.ebooks.covers import calibre_cover2\n            log.info('replacing catalog cover')\n            new_cover_path = PersistentTemporaryFile(suffix='.jpg')\n            new_cover = calibre_cover2(opts.catalog_title, 'calibre')\n            new_cover_path.write(new_cover)\n            new_cover_path.close()\n            recommendations.append(('cover', new_cover_path.name, OptionRecommendation.HIGH))\n        from calibre.ebooks.conversion.plumber import Plumber\n        plumber = Plumber(os.path.join(catalog.catalog_path, opts.basename + '.opf'), path_to_output, log, report_progress=notification, abort_after_input_dump=False)\n        plumber.merge_ui_recommendations(recommendations)\n        plumber.run()\n        try:\n            os.remove(cpath)\n        except:\n            pass\n        if GENERATE_DEBUG_EPUB:\n            from calibre.ebooks.epub import initialize_container\n            from calibre.ebooks.tweak import zip_rebuilder\n            from calibre.utils.zipfile import ZipFile\n            input_path = os.path.join(catalog_debug_path, 'input')\n            epub_shell = os.path.join(catalog_debug_path, 'epub_shell.zip')\n            initialize_container(epub_shell, opf_name='content.opf')\n            with ZipFile(epub_shell, 'r') as zf:\n                zf.extractall(path=input_path)\n            os.remove(epub_shell)\n            zip_rebuilder(input_path, os.path.join(catalog_debug_path, 'input.epub'))\n        if opts.verbose:\n            log.info(' Catalog creation complete (%s)\\n' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    return catalog.error",
            "def run(self, path_to_output, opts, db, notification=DummyReporter()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from calibre.library.catalogs.epub_mobi_builder import CatalogBuilder\n    from calibre.utils.config import JSONConfig\n    from calibre.utils.logging import default_log as log\n    if hasattr(opts, 'preset') and opts.preset:\n        available_presets = JSONConfig('catalog_presets')\n        if opts.preset not in available_presets:\n            if available_presets:\n                print(_('Error: Preset \"%s\" not found.' % opts.preset))\n                print(_('Stored presets: %s' % ', '.join([p for p in sorted(available_presets.keys())])))\n            else:\n                print(_('Error: No stored presets.'))\n            return 1\n        for item in available_presets[opts.preset]:\n            if item not in ['exclusion_rules_tw', 'format', 'prefix_rules_tw']:\n                setattr(opts, item, available_presets[opts.preset][item])\n        opts.connected_device = {'is_device_connected': False, 'kind': None, 'name': None, 'save_template': None, 'serial': None, 'storage': None}\n        prs = []\n        for rule in opts.prefix_rules:\n            prs.append(tuple(rule))\n        opts.prefix_rules = tuple(prs)\n        ers = []\n        for rule in opts.exclusion_rules:\n            ers.append(tuple(rule))\n        opts.exclusion_rules = tuple(ers)\n    opts.log = log\n    opts.fmt = self.fmt = path_to_output.rpartition('.')[2]\n    opts.creator = '{}, {} {}, {}'.format(strftime('%A'), strftime('%B'), strftime('%d').lstrip('0'), strftime('%Y'))\n    opts.creator_sort_as = '{} {}'.format('calibre', strftime('%Y-%m-%d'))\n    opts.connected_kindle = False\n    op = opts.output_profile\n    if op is None:\n        op = 'default'\n    if opts.connected_device['name'] and 'kindle' in opts.connected_device['name'].lower():\n        opts.connected_kindle = True\n        if opts.connected_device['serial'] and opts.connected_device['serial'][:4] in ['B004', 'B005']:\n            op = 'kindle_dx'\n        else:\n            op = 'kindle'\n    opts.description_clip = 380 if op.endswith('dx') or 'kindle' not in op else 100\n    opts.author_clip = 100 if op.endswith('dx') or 'kindle' not in op else 60\n    opts.output_profile = op\n    opts.basename = 'Catalog'\n    opts.cli_environment = not hasattr(opts, 'sync')\n    opts.sort_descriptions_by_author = True\n    build_log = []\n    build_log.append(\"%s('%s'): Generating %s %sin %s environment, locale: '%s'\" % (self.name, current_library_name(), self.fmt, 'for %s ' % opts.output_profile if opts.output_profile else '', 'CLI' if opts.cli_environment else 'GUI', calibre_langcode_to_name(canonicalize_lang(get_lang()), localize=False)))\n    if opts.exclude_genre.strip() == '':\n        opts.exclude_genre = 'a^'\n        build_log.append(\" converting empty exclude_genre to 'a^'\")\n    if opts.connected_device['is_device_connected'] and opts.connected_device['kind'] == 'device':\n        if opts.connected_device['serial']:\n            build_log.append(\" connected_device: '%s' #%s%s \" % (opts.connected_device['name'], opts.connected_device['serial'][0:4], 'x' * (len(opts.connected_device['serial']) - 4)))\n            for storage in opts.connected_device['storage']:\n                if storage:\n                    build_log.append('  mount point: %s' % storage)\n        else:\n            build_log.append(\" connected_device: '%s'\" % opts.connected_device['name'])\n            try:\n                for storage in opts.connected_device['storage']:\n                    if storage:\n                        build_log.append('  mount point: %s' % storage)\n            except:\n                build_log.append('  (no mount points)')\n    else:\n        build_log.append(\" connected_device: '%s'\" % opts.connected_device['name'])\n    opts_dict = vars(opts)\n    if opts_dict['ids']:\n        build_log.append(' book count: %d' % len(opts_dict['ids']))\n    sections_list = []\n    if opts.generate_authors:\n        sections_list.append('Authors')\n    if opts.generate_titles:\n        sections_list.append('Titles')\n    if opts.generate_series:\n        sections_list.append('Series')\n    if opts.generate_genres:\n        sections_list.append('Genres')\n    if opts.generate_recently_added:\n        sections_list.append('Recently Added')\n    if opts.generate_descriptions:\n        sections_list.append('Descriptions')\n    if not sections_list:\n        if opts.cli_environment:\n            opts.log.warn('*** No Section switches specified, enabling all Sections ***')\n            opts.generate_authors = True\n            opts.generate_titles = True\n            opts.generate_series = True\n            opts.generate_genres = True\n            opts.generate_recently_added = True\n            opts.generate_descriptions = True\n            sections_list = ['Authors', 'Titles', 'Series', 'Genres', 'Recently Added', 'Descriptions']\n        else:\n            opts.log.warn('\\n*** No enabled Sections, terminating catalog generation ***')\n            return ['No Included Sections', \"No enabled Sections.\\nCheck E-book options tab\\n'Included sections'\\n\"]\n    if opts.fmt == 'mobi' and sections_list == ['Descriptions']:\n        warning = _(\"\\n*** Adding 'By authors' section required for MOBI output ***\")\n        opts.log.warn(warning)\n        sections_list.insert(0, 'Authors')\n        opts.generate_authors = True\n    opts.log(' Sections: %s' % ', '.join(sections_list))\n    opts.section_list = sections_list\n    try:\n        if float(opts.thumb_width) < float(self.THUMB_SMALLEST):\n            log.warning(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_SMALLEST}'\")\n            opts.thumb_width = self.THUMB_SMALLEST\n        if float(opts.thumb_width) > float(self.THUMB_LARGEST):\n            log.warning(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_LARGEST}'\")\n            opts.thumb_width = self.THUMB_LARGEST\n        opts.thumb_width = '%.2f' % float(opts.thumb_width)\n    except Exception:\n        log.error(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_SMALLEST}'\")\n        opts.thumb_width = '1.0'\n    if type(opts.prefix_rules) is not tuple:\n        try:\n            opts.prefix_rules = eval(opts.prefix_rules)\n        except:\n            log.error('malformed --prefix-rules: %s' % opts.prefix_rules)\n            raise\n        for rule in opts.prefix_rules:\n            if len(rule) != 4:\n                log.error('incorrect number of args for --prefix-rules: %s' % repr(rule))\n    if type(opts.exclusion_rules) is not tuple:\n        try:\n            opts.exclusion_rules = eval(opts.exclusion_rules)\n        except:\n            log.error('malformed --exclusion-rules: %s' % opts.exclusion_rules)\n            raise\n        for rule in opts.exclusion_rules:\n            if len(rule) != 3:\n                log.error('incorrect number of args for --exclusion-rules: %s' % repr(rule))\n    keys = sorted(opts_dict.keys())\n    build_log.append(' opts:')\n    for key in keys:\n        if key in ['catalog_title', 'author_clip', 'connected_kindle', 'creator', 'cross_reference_authors', 'description_clip', 'exclude_book_marker', 'exclude_genre', 'exclude_tags', 'exclusion_rules', 'fmt', 'genre_source_field', 'header_note_source_field', 'merge_comments_rule', 'output_profile', 'prefix_rules', 'preset', 'read_book_marker', 'search_text', 'sort_by', 'sort_descriptions_by_author', 'sync', 'thumb_width', 'use_existing_cover', 'wishlist_tag']:\n            build_log.append(f'  {key}: {repr(opts_dict[key])}')\n    if opts.verbose:\n        log('\\n'.join((line for line in build_log)))\n    opts.start_time = time.time()\n    self.opts = opts\n    if opts.verbose:\n        log.info(' Begin catalog source generation (%s)' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    catalog = CatalogBuilder(db, opts, self, report_progress=notification)\n    try:\n        catalog.build_sources()\n        if opts.verbose:\n            log.info(' Completed catalog source generation (%s)\\n' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    except (AuthorSortMismatchException, EmptyCatalogException) as e:\n        log.error(' *** Terminated catalog generation: %s ***' % e)\n    except:\n        log.error(' unhandled exception in catalog generator')\n        raise\n    else:\n        recommendations = []\n        recommendations.append(('remove_fake_margins', False, OptionRecommendation.HIGH))\n        recommendations.append(('comments', '', OptionRecommendation.HIGH))\n        '\\n            >>> Use to debug generated catalog code before pipeline conversion <<<\\n            '\n        GENERATE_DEBUG_EPUB = False\n        if GENERATE_DEBUG_EPUB:\n            catalog_debug_path = os.path.join(os.path.expanduser('~'), 'Desktop', 'Catalog debug')\n            setattr(opts, 'debug_pipeline', os.path.expanduser(catalog_debug_path))\n        dp = getattr(opts, 'debug_pipeline', None)\n        if dp is not None:\n            recommendations.append(('debug_pipeline', dp, OptionRecommendation.HIGH))\n        if opts.output_profile and opts.output_profile.startswith('kindle'):\n            recommendations.append(('output_profile', opts.output_profile, OptionRecommendation.HIGH))\n            recommendations.append(('book_producer', opts.output_profile, OptionRecommendation.HIGH))\n            if opts.fmt == 'mobi':\n                recommendations.append(('no_inline_toc', True, OptionRecommendation.HIGH))\n                recommendations.append(('verbose', 2, OptionRecommendation.HIGH))\n        cpath = None\n        existing_cover = False\n        try:\n            search_text = 'title:\"{}\" author:{}'.format(opts.catalog_title.replace('\"', '\\\\\"'), 'calibre')\n            matches = db.search(search_text, return_matches=True, sort_results=False)\n            if matches:\n                cpath = db.cover(matches[0], index_is_id=True, as_path=True)\n                if cpath and os.path.exists(cpath):\n                    existing_cover = True\n        except:\n            pass\n        if self.opts.use_existing_cover and (not existing_cover):\n            log.warning('no existing catalog cover found')\n        if self.opts.use_existing_cover and existing_cover:\n            recommendations.append(('cover', cpath, OptionRecommendation.HIGH))\n            log.info('using existing catalog cover')\n        else:\n            from calibre.ebooks.covers import calibre_cover2\n            log.info('replacing catalog cover')\n            new_cover_path = PersistentTemporaryFile(suffix='.jpg')\n            new_cover = calibre_cover2(opts.catalog_title, 'calibre')\n            new_cover_path.write(new_cover)\n            new_cover_path.close()\n            recommendations.append(('cover', new_cover_path.name, OptionRecommendation.HIGH))\n        from calibre.ebooks.conversion.plumber import Plumber\n        plumber = Plumber(os.path.join(catalog.catalog_path, opts.basename + '.opf'), path_to_output, log, report_progress=notification, abort_after_input_dump=False)\n        plumber.merge_ui_recommendations(recommendations)\n        plumber.run()\n        try:\n            os.remove(cpath)\n        except:\n            pass\n        if GENERATE_DEBUG_EPUB:\n            from calibre.ebooks.epub import initialize_container\n            from calibre.ebooks.tweak import zip_rebuilder\n            from calibre.utils.zipfile import ZipFile\n            input_path = os.path.join(catalog_debug_path, 'input')\n            epub_shell = os.path.join(catalog_debug_path, 'epub_shell.zip')\n            initialize_container(epub_shell, opf_name='content.opf')\n            with ZipFile(epub_shell, 'r') as zf:\n                zf.extractall(path=input_path)\n            os.remove(epub_shell)\n            zip_rebuilder(input_path, os.path.join(catalog_debug_path, 'input.epub'))\n        if opts.verbose:\n            log.info(' Catalog creation complete (%s)\\n' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    return catalog.error",
            "def run(self, path_to_output, opts, db, notification=DummyReporter()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from calibre.library.catalogs.epub_mobi_builder import CatalogBuilder\n    from calibre.utils.config import JSONConfig\n    from calibre.utils.logging import default_log as log\n    if hasattr(opts, 'preset') and opts.preset:\n        available_presets = JSONConfig('catalog_presets')\n        if opts.preset not in available_presets:\n            if available_presets:\n                print(_('Error: Preset \"%s\" not found.' % opts.preset))\n                print(_('Stored presets: %s' % ', '.join([p for p in sorted(available_presets.keys())])))\n            else:\n                print(_('Error: No stored presets.'))\n            return 1\n        for item in available_presets[opts.preset]:\n            if item not in ['exclusion_rules_tw', 'format', 'prefix_rules_tw']:\n                setattr(opts, item, available_presets[opts.preset][item])\n        opts.connected_device = {'is_device_connected': False, 'kind': None, 'name': None, 'save_template': None, 'serial': None, 'storage': None}\n        prs = []\n        for rule in opts.prefix_rules:\n            prs.append(tuple(rule))\n        opts.prefix_rules = tuple(prs)\n        ers = []\n        for rule in opts.exclusion_rules:\n            ers.append(tuple(rule))\n        opts.exclusion_rules = tuple(ers)\n    opts.log = log\n    opts.fmt = self.fmt = path_to_output.rpartition('.')[2]\n    opts.creator = '{}, {} {}, {}'.format(strftime('%A'), strftime('%B'), strftime('%d').lstrip('0'), strftime('%Y'))\n    opts.creator_sort_as = '{} {}'.format('calibre', strftime('%Y-%m-%d'))\n    opts.connected_kindle = False\n    op = opts.output_profile\n    if op is None:\n        op = 'default'\n    if opts.connected_device['name'] and 'kindle' in opts.connected_device['name'].lower():\n        opts.connected_kindle = True\n        if opts.connected_device['serial'] and opts.connected_device['serial'][:4] in ['B004', 'B005']:\n            op = 'kindle_dx'\n        else:\n            op = 'kindle'\n    opts.description_clip = 380 if op.endswith('dx') or 'kindle' not in op else 100\n    opts.author_clip = 100 if op.endswith('dx') or 'kindle' not in op else 60\n    opts.output_profile = op\n    opts.basename = 'Catalog'\n    opts.cli_environment = not hasattr(opts, 'sync')\n    opts.sort_descriptions_by_author = True\n    build_log = []\n    build_log.append(\"%s('%s'): Generating %s %sin %s environment, locale: '%s'\" % (self.name, current_library_name(), self.fmt, 'for %s ' % opts.output_profile if opts.output_profile else '', 'CLI' if opts.cli_environment else 'GUI', calibre_langcode_to_name(canonicalize_lang(get_lang()), localize=False)))\n    if opts.exclude_genre.strip() == '':\n        opts.exclude_genre = 'a^'\n        build_log.append(\" converting empty exclude_genre to 'a^'\")\n    if opts.connected_device['is_device_connected'] and opts.connected_device['kind'] == 'device':\n        if opts.connected_device['serial']:\n            build_log.append(\" connected_device: '%s' #%s%s \" % (opts.connected_device['name'], opts.connected_device['serial'][0:4], 'x' * (len(opts.connected_device['serial']) - 4)))\n            for storage in opts.connected_device['storage']:\n                if storage:\n                    build_log.append('  mount point: %s' % storage)\n        else:\n            build_log.append(\" connected_device: '%s'\" % opts.connected_device['name'])\n            try:\n                for storage in opts.connected_device['storage']:\n                    if storage:\n                        build_log.append('  mount point: %s' % storage)\n            except:\n                build_log.append('  (no mount points)')\n    else:\n        build_log.append(\" connected_device: '%s'\" % opts.connected_device['name'])\n    opts_dict = vars(opts)\n    if opts_dict['ids']:\n        build_log.append(' book count: %d' % len(opts_dict['ids']))\n    sections_list = []\n    if opts.generate_authors:\n        sections_list.append('Authors')\n    if opts.generate_titles:\n        sections_list.append('Titles')\n    if opts.generate_series:\n        sections_list.append('Series')\n    if opts.generate_genres:\n        sections_list.append('Genres')\n    if opts.generate_recently_added:\n        sections_list.append('Recently Added')\n    if opts.generate_descriptions:\n        sections_list.append('Descriptions')\n    if not sections_list:\n        if opts.cli_environment:\n            opts.log.warn('*** No Section switches specified, enabling all Sections ***')\n            opts.generate_authors = True\n            opts.generate_titles = True\n            opts.generate_series = True\n            opts.generate_genres = True\n            opts.generate_recently_added = True\n            opts.generate_descriptions = True\n            sections_list = ['Authors', 'Titles', 'Series', 'Genres', 'Recently Added', 'Descriptions']\n        else:\n            opts.log.warn('\\n*** No enabled Sections, terminating catalog generation ***')\n            return ['No Included Sections', \"No enabled Sections.\\nCheck E-book options tab\\n'Included sections'\\n\"]\n    if opts.fmt == 'mobi' and sections_list == ['Descriptions']:\n        warning = _(\"\\n*** Adding 'By authors' section required for MOBI output ***\")\n        opts.log.warn(warning)\n        sections_list.insert(0, 'Authors')\n        opts.generate_authors = True\n    opts.log(' Sections: %s' % ', '.join(sections_list))\n    opts.section_list = sections_list\n    try:\n        if float(opts.thumb_width) < float(self.THUMB_SMALLEST):\n            log.warning(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_SMALLEST}'\")\n            opts.thumb_width = self.THUMB_SMALLEST\n        if float(opts.thumb_width) > float(self.THUMB_LARGEST):\n            log.warning(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_LARGEST}'\")\n            opts.thumb_width = self.THUMB_LARGEST\n        opts.thumb_width = '%.2f' % float(opts.thumb_width)\n    except Exception:\n        log.error(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_SMALLEST}'\")\n        opts.thumb_width = '1.0'\n    if type(opts.prefix_rules) is not tuple:\n        try:\n            opts.prefix_rules = eval(opts.prefix_rules)\n        except:\n            log.error('malformed --prefix-rules: %s' % opts.prefix_rules)\n            raise\n        for rule in opts.prefix_rules:\n            if len(rule) != 4:\n                log.error('incorrect number of args for --prefix-rules: %s' % repr(rule))\n    if type(opts.exclusion_rules) is not tuple:\n        try:\n            opts.exclusion_rules = eval(opts.exclusion_rules)\n        except:\n            log.error('malformed --exclusion-rules: %s' % opts.exclusion_rules)\n            raise\n        for rule in opts.exclusion_rules:\n            if len(rule) != 3:\n                log.error('incorrect number of args for --exclusion-rules: %s' % repr(rule))\n    keys = sorted(opts_dict.keys())\n    build_log.append(' opts:')\n    for key in keys:\n        if key in ['catalog_title', 'author_clip', 'connected_kindle', 'creator', 'cross_reference_authors', 'description_clip', 'exclude_book_marker', 'exclude_genre', 'exclude_tags', 'exclusion_rules', 'fmt', 'genre_source_field', 'header_note_source_field', 'merge_comments_rule', 'output_profile', 'prefix_rules', 'preset', 'read_book_marker', 'search_text', 'sort_by', 'sort_descriptions_by_author', 'sync', 'thumb_width', 'use_existing_cover', 'wishlist_tag']:\n            build_log.append(f'  {key}: {repr(opts_dict[key])}')\n    if opts.verbose:\n        log('\\n'.join((line for line in build_log)))\n    opts.start_time = time.time()\n    self.opts = opts\n    if opts.verbose:\n        log.info(' Begin catalog source generation (%s)' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    catalog = CatalogBuilder(db, opts, self, report_progress=notification)\n    try:\n        catalog.build_sources()\n        if opts.verbose:\n            log.info(' Completed catalog source generation (%s)\\n' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    except (AuthorSortMismatchException, EmptyCatalogException) as e:\n        log.error(' *** Terminated catalog generation: %s ***' % e)\n    except:\n        log.error(' unhandled exception in catalog generator')\n        raise\n    else:\n        recommendations = []\n        recommendations.append(('remove_fake_margins', False, OptionRecommendation.HIGH))\n        recommendations.append(('comments', '', OptionRecommendation.HIGH))\n        '\\n            >>> Use to debug generated catalog code before pipeline conversion <<<\\n            '\n        GENERATE_DEBUG_EPUB = False\n        if GENERATE_DEBUG_EPUB:\n            catalog_debug_path = os.path.join(os.path.expanduser('~'), 'Desktop', 'Catalog debug')\n            setattr(opts, 'debug_pipeline', os.path.expanduser(catalog_debug_path))\n        dp = getattr(opts, 'debug_pipeline', None)\n        if dp is not None:\n            recommendations.append(('debug_pipeline', dp, OptionRecommendation.HIGH))\n        if opts.output_profile and opts.output_profile.startswith('kindle'):\n            recommendations.append(('output_profile', opts.output_profile, OptionRecommendation.HIGH))\n            recommendations.append(('book_producer', opts.output_profile, OptionRecommendation.HIGH))\n            if opts.fmt == 'mobi':\n                recommendations.append(('no_inline_toc', True, OptionRecommendation.HIGH))\n                recommendations.append(('verbose', 2, OptionRecommendation.HIGH))\n        cpath = None\n        existing_cover = False\n        try:\n            search_text = 'title:\"{}\" author:{}'.format(opts.catalog_title.replace('\"', '\\\\\"'), 'calibre')\n            matches = db.search(search_text, return_matches=True, sort_results=False)\n            if matches:\n                cpath = db.cover(matches[0], index_is_id=True, as_path=True)\n                if cpath and os.path.exists(cpath):\n                    existing_cover = True\n        except:\n            pass\n        if self.opts.use_existing_cover and (not existing_cover):\n            log.warning('no existing catalog cover found')\n        if self.opts.use_existing_cover and existing_cover:\n            recommendations.append(('cover', cpath, OptionRecommendation.HIGH))\n            log.info('using existing catalog cover')\n        else:\n            from calibre.ebooks.covers import calibre_cover2\n            log.info('replacing catalog cover')\n            new_cover_path = PersistentTemporaryFile(suffix='.jpg')\n            new_cover = calibre_cover2(opts.catalog_title, 'calibre')\n            new_cover_path.write(new_cover)\n            new_cover_path.close()\n            recommendations.append(('cover', new_cover_path.name, OptionRecommendation.HIGH))\n        from calibre.ebooks.conversion.plumber import Plumber\n        plumber = Plumber(os.path.join(catalog.catalog_path, opts.basename + '.opf'), path_to_output, log, report_progress=notification, abort_after_input_dump=False)\n        plumber.merge_ui_recommendations(recommendations)\n        plumber.run()\n        try:\n            os.remove(cpath)\n        except:\n            pass\n        if GENERATE_DEBUG_EPUB:\n            from calibre.ebooks.epub import initialize_container\n            from calibre.ebooks.tweak import zip_rebuilder\n            from calibre.utils.zipfile import ZipFile\n            input_path = os.path.join(catalog_debug_path, 'input')\n            epub_shell = os.path.join(catalog_debug_path, 'epub_shell.zip')\n            initialize_container(epub_shell, opf_name='content.opf')\n            with ZipFile(epub_shell, 'r') as zf:\n                zf.extractall(path=input_path)\n            os.remove(epub_shell)\n            zip_rebuilder(input_path, os.path.join(catalog_debug_path, 'input.epub'))\n        if opts.verbose:\n            log.info(' Catalog creation complete (%s)\\n' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    return catalog.error",
            "def run(self, path_to_output, opts, db, notification=DummyReporter()):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from calibre.library.catalogs.epub_mobi_builder import CatalogBuilder\n    from calibre.utils.config import JSONConfig\n    from calibre.utils.logging import default_log as log\n    if hasattr(opts, 'preset') and opts.preset:\n        available_presets = JSONConfig('catalog_presets')\n        if opts.preset not in available_presets:\n            if available_presets:\n                print(_('Error: Preset \"%s\" not found.' % opts.preset))\n                print(_('Stored presets: %s' % ', '.join([p for p in sorted(available_presets.keys())])))\n            else:\n                print(_('Error: No stored presets.'))\n            return 1\n        for item in available_presets[opts.preset]:\n            if item not in ['exclusion_rules_tw', 'format', 'prefix_rules_tw']:\n                setattr(opts, item, available_presets[opts.preset][item])\n        opts.connected_device = {'is_device_connected': False, 'kind': None, 'name': None, 'save_template': None, 'serial': None, 'storage': None}\n        prs = []\n        for rule in opts.prefix_rules:\n            prs.append(tuple(rule))\n        opts.prefix_rules = tuple(prs)\n        ers = []\n        for rule in opts.exclusion_rules:\n            ers.append(tuple(rule))\n        opts.exclusion_rules = tuple(ers)\n    opts.log = log\n    opts.fmt = self.fmt = path_to_output.rpartition('.')[2]\n    opts.creator = '{}, {} {}, {}'.format(strftime('%A'), strftime('%B'), strftime('%d').lstrip('0'), strftime('%Y'))\n    opts.creator_sort_as = '{} {}'.format('calibre', strftime('%Y-%m-%d'))\n    opts.connected_kindle = False\n    op = opts.output_profile\n    if op is None:\n        op = 'default'\n    if opts.connected_device['name'] and 'kindle' in opts.connected_device['name'].lower():\n        opts.connected_kindle = True\n        if opts.connected_device['serial'] and opts.connected_device['serial'][:4] in ['B004', 'B005']:\n            op = 'kindle_dx'\n        else:\n            op = 'kindle'\n    opts.description_clip = 380 if op.endswith('dx') or 'kindle' not in op else 100\n    opts.author_clip = 100 if op.endswith('dx') or 'kindle' not in op else 60\n    opts.output_profile = op\n    opts.basename = 'Catalog'\n    opts.cli_environment = not hasattr(opts, 'sync')\n    opts.sort_descriptions_by_author = True\n    build_log = []\n    build_log.append(\"%s('%s'): Generating %s %sin %s environment, locale: '%s'\" % (self.name, current_library_name(), self.fmt, 'for %s ' % opts.output_profile if opts.output_profile else '', 'CLI' if opts.cli_environment else 'GUI', calibre_langcode_to_name(canonicalize_lang(get_lang()), localize=False)))\n    if opts.exclude_genre.strip() == '':\n        opts.exclude_genre = 'a^'\n        build_log.append(\" converting empty exclude_genre to 'a^'\")\n    if opts.connected_device['is_device_connected'] and opts.connected_device['kind'] == 'device':\n        if opts.connected_device['serial']:\n            build_log.append(\" connected_device: '%s' #%s%s \" % (opts.connected_device['name'], opts.connected_device['serial'][0:4], 'x' * (len(opts.connected_device['serial']) - 4)))\n            for storage in opts.connected_device['storage']:\n                if storage:\n                    build_log.append('  mount point: %s' % storage)\n        else:\n            build_log.append(\" connected_device: '%s'\" % opts.connected_device['name'])\n            try:\n                for storage in opts.connected_device['storage']:\n                    if storage:\n                        build_log.append('  mount point: %s' % storage)\n            except:\n                build_log.append('  (no mount points)')\n    else:\n        build_log.append(\" connected_device: '%s'\" % opts.connected_device['name'])\n    opts_dict = vars(opts)\n    if opts_dict['ids']:\n        build_log.append(' book count: %d' % len(opts_dict['ids']))\n    sections_list = []\n    if opts.generate_authors:\n        sections_list.append('Authors')\n    if opts.generate_titles:\n        sections_list.append('Titles')\n    if opts.generate_series:\n        sections_list.append('Series')\n    if opts.generate_genres:\n        sections_list.append('Genres')\n    if opts.generate_recently_added:\n        sections_list.append('Recently Added')\n    if opts.generate_descriptions:\n        sections_list.append('Descriptions')\n    if not sections_list:\n        if opts.cli_environment:\n            opts.log.warn('*** No Section switches specified, enabling all Sections ***')\n            opts.generate_authors = True\n            opts.generate_titles = True\n            opts.generate_series = True\n            opts.generate_genres = True\n            opts.generate_recently_added = True\n            opts.generate_descriptions = True\n            sections_list = ['Authors', 'Titles', 'Series', 'Genres', 'Recently Added', 'Descriptions']\n        else:\n            opts.log.warn('\\n*** No enabled Sections, terminating catalog generation ***')\n            return ['No Included Sections', \"No enabled Sections.\\nCheck E-book options tab\\n'Included sections'\\n\"]\n    if opts.fmt == 'mobi' and sections_list == ['Descriptions']:\n        warning = _(\"\\n*** Adding 'By authors' section required for MOBI output ***\")\n        opts.log.warn(warning)\n        sections_list.insert(0, 'Authors')\n        opts.generate_authors = True\n    opts.log(' Sections: %s' % ', '.join(sections_list))\n    opts.section_list = sections_list\n    try:\n        if float(opts.thumb_width) < float(self.THUMB_SMALLEST):\n            log.warning(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_SMALLEST}'\")\n            opts.thumb_width = self.THUMB_SMALLEST\n        if float(opts.thumb_width) > float(self.THUMB_LARGEST):\n            log.warning(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_LARGEST}'\")\n            opts.thumb_width = self.THUMB_LARGEST\n        opts.thumb_width = '%.2f' % float(opts.thumb_width)\n    except Exception:\n        log.error(f\"coercing thumb_width from '{opts.thumb_width}' to '{self.THUMB_SMALLEST}'\")\n        opts.thumb_width = '1.0'\n    if type(opts.prefix_rules) is not tuple:\n        try:\n            opts.prefix_rules = eval(opts.prefix_rules)\n        except:\n            log.error('malformed --prefix-rules: %s' % opts.prefix_rules)\n            raise\n        for rule in opts.prefix_rules:\n            if len(rule) != 4:\n                log.error('incorrect number of args for --prefix-rules: %s' % repr(rule))\n    if type(opts.exclusion_rules) is not tuple:\n        try:\n            opts.exclusion_rules = eval(opts.exclusion_rules)\n        except:\n            log.error('malformed --exclusion-rules: %s' % opts.exclusion_rules)\n            raise\n        for rule in opts.exclusion_rules:\n            if len(rule) != 3:\n                log.error('incorrect number of args for --exclusion-rules: %s' % repr(rule))\n    keys = sorted(opts_dict.keys())\n    build_log.append(' opts:')\n    for key in keys:\n        if key in ['catalog_title', 'author_clip', 'connected_kindle', 'creator', 'cross_reference_authors', 'description_clip', 'exclude_book_marker', 'exclude_genre', 'exclude_tags', 'exclusion_rules', 'fmt', 'genre_source_field', 'header_note_source_field', 'merge_comments_rule', 'output_profile', 'prefix_rules', 'preset', 'read_book_marker', 'search_text', 'sort_by', 'sort_descriptions_by_author', 'sync', 'thumb_width', 'use_existing_cover', 'wishlist_tag']:\n            build_log.append(f'  {key}: {repr(opts_dict[key])}')\n    if opts.verbose:\n        log('\\n'.join((line for line in build_log)))\n    opts.start_time = time.time()\n    self.opts = opts\n    if opts.verbose:\n        log.info(' Begin catalog source generation (%s)' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    catalog = CatalogBuilder(db, opts, self, report_progress=notification)\n    try:\n        catalog.build_sources()\n        if opts.verbose:\n            log.info(' Completed catalog source generation (%s)\\n' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    except (AuthorSortMismatchException, EmptyCatalogException) as e:\n        log.error(' *** Terminated catalog generation: %s ***' % e)\n    except:\n        log.error(' unhandled exception in catalog generator')\n        raise\n    else:\n        recommendations = []\n        recommendations.append(('remove_fake_margins', False, OptionRecommendation.HIGH))\n        recommendations.append(('comments', '', OptionRecommendation.HIGH))\n        '\\n            >>> Use to debug generated catalog code before pipeline conversion <<<\\n            '\n        GENERATE_DEBUG_EPUB = False\n        if GENERATE_DEBUG_EPUB:\n            catalog_debug_path = os.path.join(os.path.expanduser('~'), 'Desktop', 'Catalog debug')\n            setattr(opts, 'debug_pipeline', os.path.expanduser(catalog_debug_path))\n        dp = getattr(opts, 'debug_pipeline', None)\n        if dp is not None:\n            recommendations.append(('debug_pipeline', dp, OptionRecommendation.HIGH))\n        if opts.output_profile and opts.output_profile.startswith('kindle'):\n            recommendations.append(('output_profile', opts.output_profile, OptionRecommendation.HIGH))\n            recommendations.append(('book_producer', opts.output_profile, OptionRecommendation.HIGH))\n            if opts.fmt == 'mobi':\n                recommendations.append(('no_inline_toc', True, OptionRecommendation.HIGH))\n                recommendations.append(('verbose', 2, OptionRecommendation.HIGH))\n        cpath = None\n        existing_cover = False\n        try:\n            search_text = 'title:\"{}\" author:{}'.format(opts.catalog_title.replace('\"', '\\\\\"'), 'calibre')\n            matches = db.search(search_text, return_matches=True, sort_results=False)\n            if matches:\n                cpath = db.cover(matches[0], index_is_id=True, as_path=True)\n                if cpath and os.path.exists(cpath):\n                    existing_cover = True\n        except:\n            pass\n        if self.opts.use_existing_cover and (not existing_cover):\n            log.warning('no existing catalog cover found')\n        if self.opts.use_existing_cover and existing_cover:\n            recommendations.append(('cover', cpath, OptionRecommendation.HIGH))\n            log.info('using existing catalog cover')\n        else:\n            from calibre.ebooks.covers import calibre_cover2\n            log.info('replacing catalog cover')\n            new_cover_path = PersistentTemporaryFile(suffix='.jpg')\n            new_cover = calibre_cover2(opts.catalog_title, 'calibre')\n            new_cover_path.write(new_cover)\n            new_cover_path.close()\n            recommendations.append(('cover', new_cover_path.name, OptionRecommendation.HIGH))\n        from calibre.ebooks.conversion.plumber import Plumber\n        plumber = Plumber(os.path.join(catalog.catalog_path, opts.basename + '.opf'), path_to_output, log, report_progress=notification, abort_after_input_dump=False)\n        plumber.merge_ui_recommendations(recommendations)\n        plumber.run()\n        try:\n            os.remove(cpath)\n        except:\n            pass\n        if GENERATE_DEBUG_EPUB:\n            from calibre.ebooks.epub import initialize_container\n            from calibre.ebooks.tweak import zip_rebuilder\n            from calibre.utils.zipfile import ZipFile\n            input_path = os.path.join(catalog_debug_path, 'input')\n            epub_shell = os.path.join(catalog_debug_path, 'epub_shell.zip')\n            initialize_container(epub_shell, opf_name='content.opf')\n            with ZipFile(epub_shell, 'r') as zf:\n                zf.extractall(path=input_path)\n            os.remove(epub_shell)\n            zip_rebuilder(input_path, os.path.join(catalog_debug_path, 'input.epub'))\n        if opts.verbose:\n            log.info(' Catalog creation complete (%s)\\n' % str(datetime.timedelta(seconds=int(time.time() - opts.start_time))))\n    return catalog.error"
        ]
    }
]