[
    {
        "func_name": "__init__",
        "original": "def __init__(self, pc_range, out_size_factor, voxel_size, post_center_range=None, max_num=100, score_threshold=None, code_size=9):\n    self.pc_range = pc_range\n    self.out_size_factor = out_size_factor\n    self.voxel_size = voxel_size\n    self.post_center_range = post_center_range\n    self.max_num = max_num\n    self.score_threshold = score_threshold\n    self.code_size = code_size",
        "mutated": [
            "def __init__(self, pc_range, out_size_factor, voxel_size, post_center_range=None, max_num=100, score_threshold=None, code_size=9):\n    if False:\n        i = 10\n    self.pc_range = pc_range\n    self.out_size_factor = out_size_factor\n    self.voxel_size = voxel_size\n    self.post_center_range = post_center_range\n    self.max_num = max_num\n    self.score_threshold = score_threshold\n    self.code_size = code_size",
            "def __init__(self, pc_range, out_size_factor, voxel_size, post_center_range=None, max_num=100, score_threshold=None, code_size=9):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.pc_range = pc_range\n    self.out_size_factor = out_size_factor\n    self.voxel_size = voxel_size\n    self.post_center_range = post_center_range\n    self.max_num = max_num\n    self.score_threshold = score_threshold\n    self.code_size = code_size",
            "def __init__(self, pc_range, out_size_factor, voxel_size, post_center_range=None, max_num=100, score_threshold=None, code_size=9):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.pc_range = pc_range\n    self.out_size_factor = out_size_factor\n    self.voxel_size = voxel_size\n    self.post_center_range = post_center_range\n    self.max_num = max_num\n    self.score_threshold = score_threshold\n    self.code_size = code_size",
            "def __init__(self, pc_range, out_size_factor, voxel_size, post_center_range=None, max_num=100, score_threshold=None, code_size=9):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.pc_range = pc_range\n    self.out_size_factor = out_size_factor\n    self.voxel_size = voxel_size\n    self.post_center_range = post_center_range\n    self.max_num = max_num\n    self.score_threshold = score_threshold\n    self.code_size = code_size",
            "def __init__(self, pc_range, out_size_factor, voxel_size, post_center_range=None, max_num=100, score_threshold=None, code_size=9):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.pc_range = pc_range\n    self.out_size_factor = out_size_factor\n    self.voxel_size = voxel_size\n    self.post_center_range = post_center_range\n    self.max_num = max_num\n    self.score_threshold = score_threshold\n    self.code_size = code_size"
        ]
    },
    {
        "func_name": "_gather_feat",
        "original": "def _gather_feat(self, feats, inds, feat_masks=None):\n    \"\"\"Given feats and indexes, returns the gathered feats.\n\n        Args:\n            feats (torch.Tensor): Features to be transposed and gathered\n                with the shape of [B, 2, W, H].\n            inds (torch.Tensor): Indexes with the shape of [B, N].\n            feat_masks (torch.Tensor, optional): Mask of the feats.\n                Default: None.\n\n        Returns:\n            torch.Tensor: Gathered feats.\n        \"\"\"\n    dim = feats.size(2)\n    inds = inds.unsqueeze(2).expand(inds.size(0), inds.size(1), dim)\n    feats = feats.gather(1, inds)\n    if feat_masks is not None:\n        feat_masks = feat_masks.unsqueeze(2).expand_as(feats)\n        feats = feats[feat_masks]\n        feats = feats.view(-1, dim)\n    return feats",
        "mutated": [
            "def _gather_feat(self, feats, inds, feat_masks=None):\n    if False:\n        i = 10\n    'Given feats and indexes, returns the gathered feats.\\n\\n        Args:\\n            feats (torch.Tensor): Features to be transposed and gathered\\n                with the shape of [B, 2, W, H].\\n            inds (torch.Tensor): Indexes with the shape of [B, N].\\n            feat_masks (torch.Tensor, optional): Mask of the feats.\\n                Default: None.\\n\\n        Returns:\\n            torch.Tensor: Gathered feats.\\n        '\n    dim = feats.size(2)\n    inds = inds.unsqueeze(2).expand(inds.size(0), inds.size(1), dim)\n    feats = feats.gather(1, inds)\n    if feat_masks is not None:\n        feat_masks = feat_masks.unsqueeze(2).expand_as(feats)\n        feats = feats[feat_masks]\n        feats = feats.view(-1, dim)\n    return feats",
            "def _gather_feat(self, feats, inds, feat_masks=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Given feats and indexes, returns the gathered feats.\\n\\n        Args:\\n            feats (torch.Tensor): Features to be transposed and gathered\\n                with the shape of [B, 2, W, H].\\n            inds (torch.Tensor): Indexes with the shape of [B, N].\\n            feat_masks (torch.Tensor, optional): Mask of the feats.\\n                Default: None.\\n\\n        Returns:\\n            torch.Tensor: Gathered feats.\\n        '\n    dim = feats.size(2)\n    inds = inds.unsqueeze(2).expand(inds.size(0), inds.size(1), dim)\n    feats = feats.gather(1, inds)\n    if feat_masks is not None:\n        feat_masks = feat_masks.unsqueeze(2).expand_as(feats)\n        feats = feats[feat_masks]\n        feats = feats.view(-1, dim)\n    return feats",
            "def _gather_feat(self, feats, inds, feat_masks=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Given feats and indexes, returns the gathered feats.\\n\\n        Args:\\n            feats (torch.Tensor): Features to be transposed and gathered\\n                with the shape of [B, 2, W, H].\\n            inds (torch.Tensor): Indexes with the shape of [B, N].\\n            feat_masks (torch.Tensor, optional): Mask of the feats.\\n                Default: None.\\n\\n        Returns:\\n            torch.Tensor: Gathered feats.\\n        '\n    dim = feats.size(2)\n    inds = inds.unsqueeze(2).expand(inds.size(0), inds.size(1), dim)\n    feats = feats.gather(1, inds)\n    if feat_masks is not None:\n        feat_masks = feat_masks.unsqueeze(2).expand_as(feats)\n        feats = feats[feat_masks]\n        feats = feats.view(-1, dim)\n    return feats",
            "def _gather_feat(self, feats, inds, feat_masks=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Given feats and indexes, returns the gathered feats.\\n\\n        Args:\\n            feats (torch.Tensor): Features to be transposed and gathered\\n                with the shape of [B, 2, W, H].\\n            inds (torch.Tensor): Indexes with the shape of [B, N].\\n            feat_masks (torch.Tensor, optional): Mask of the feats.\\n                Default: None.\\n\\n        Returns:\\n            torch.Tensor: Gathered feats.\\n        '\n    dim = feats.size(2)\n    inds = inds.unsqueeze(2).expand(inds.size(0), inds.size(1), dim)\n    feats = feats.gather(1, inds)\n    if feat_masks is not None:\n        feat_masks = feat_masks.unsqueeze(2).expand_as(feats)\n        feats = feats[feat_masks]\n        feats = feats.view(-1, dim)\n    return feats",
            "def _gather_feat(self, feats, inds, feat_masks=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Given feats and indexes, returns the gathered feats.\\n\\n        Args:\\n            feats (torch.Tensor): Features to be transposed and gathered\\n                with the shape of [B, 2, W, H].\\n            inds (torch.Tensor): Indexes with the shape of [B, N].\\n            feat_masks (torch.Tensor, optional): Mask of the feats.\\n                Default: None.\\n\\n        Returns:\\n            torch.Tensor: Gathered feats.\\n        '\n    dim = feats.size(2)\n    inds = inds.unsqueeze(2).expand(inds.size(0), inds.size(1), dim)\n    feats = feats.gather(1, inds)\n    if feat_masks is not None:\n        feat_masks = feat_masks.unsqueeze(2).expand_as(feats)\n        feats = feats[feat_masks]\n        feats = feats.view(-1, dim)\n    return feats"
        ]
    },
    {
        "func_name": "_topk",
        "original": "def _topk(self, scores, K=80):\n    \"\"\"Get indexes based on scores.\n\n        Args:\n            scores (torch.Tensor): scores with the shape of [B, N, W, H].\n            K (int, optional): Number to be kept. Defaults to 80.\n\n        Returns:\n            tuple[torch.Tensor]\n                torch.Tensor: Selected scores with the shape of [B, K].\n                torch.Tensor: Selected indexes with the shape of [B, K].\n                torch.Tensor: Selected classes with the shape of [B, K].\n                torch.Tensor: Selected y coord with the shape of [B, K].\n                torch.Tensor: Selected x coord with the shape of [B, K].\n        \"\"\"\n    (batch, cat, height, width) = scores.size()\n    (topk_scores, topk_inds) = torch.topk(scores.view(batch, cat, -1), K)\n    topk_inds = topk_inds % (height * width)\n    topk_ys = (topk_inds.float() / torch.tensor(width, dtype=torch.float)).int().float()\n    topk_xs = (topk_inds % width).int().float()\n    (topk_score, topk_ind) = torch.topk(topk_scores.view(batch, -1), K)\n    topk_clses = (topk_ind / torch.tensor(K, dtype=torch.float)).int()\n    topk_inds = self._gather_feat(topk_inds.view(batch, -1, 1), topk_ind).view(batch, K)\n    topk_ys = self._gather_feat(topk_ys.view(batch, -1, 1), topk_ind).view(batch, K)\n    topk_xs = self._gather_feat(topk_xs.view(batch, -1, 1), topk_ind).view(batch, K)\n    return (topk_score, topk_inds, topk_clses, topk_ys, topk_xs)",
        "mutated": [
            "def _topk(self, scores, K=80):\n    if False:\n        i = 10\n    'Get indexes based on scores.\\n\\n        Args:\\n            scores (torch.Tensor): scores with the shape of [B, N, W, H].\\n            K (int, optional): Number to be kept. Defaults to 80.\\n\\n        Returns:\\n            tuple[torch.Tensor]\\n                torch.Tensor: Selected scores with the shape of [B, K].\\n                torch.Tensor: Selected indexes with the shape of [B, K].\\n                torch.Tensor: Selected classes with the shape of [B, K].\\n                torch.Tensor: Selected y coord with the shape of [B, K].\\n                torch.Tensor: Selected x coord with the shape of [B, K].\\n        '\n    (batch, cat, height, width) = scores.size()\n    (topk_scores, topk_inds) = torch.topk(scores.view(batch, cat, -1), K)\n    topk_inds = topk_inds % (height * width)\n    topk_ys = (topk_inds.float() / torch.tensor(width, dtype=torch.float)).int().float()\n    topk_xs = (topk_inds % width).int().float()\n    (topk_score, topk_ind) = torch.topk(topk_scores.view(batch, -1), K)\n    topk_clses = (topk_ind / torch.tensor(K, dtype=torch.float)).int()\n    topk_inds = self._gather_feat(topk_inds.view(batch, -1, 1), topk_ind).view(batch, K)\n    topk_ys = self._gather_feat(topk_ys.view(batch, -1, 1), topk_ind).view(batch, K)\n    topk_xs = self._gather_feat(topk_xs.view(batch, -1, 1), topk_ind).view(batch, K)\n    return (topk_score, topk_inds, topk_clses, topk_ys, topk_xs)",
            "def _topk(self, scores, K=80):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get indexes based on scores.\\n\\n        Args:\\n            scores (torch.Tensor): scores with the shape of [B, N, W, H].\\n            K (int, optional): Number to be kept. Defaults to 80.\\n\\n        Returns:\\n            tuple[torch.Tensor]\\n                torch.Tensor: Selected scores with the shape of [B, K].\\n                torch.Tensor: Selected indexes with the shape of [B, K].\\n                torch.Tensor: Selected classes with the shape of [B, K].\\n                torch.Tensor: Selected y coord with the shape of [B, K].\\n                torch.Tensor: Selected x coord with the shape of [B, K].\\n        '\n    (batch, cat, height, width) = scores.size()\n    (topk_scores, topk_inds) = torch.topk(scores.view(batch, cat, -1), K)\n    topk_inds = topk_inds % (height * width)\n    topk_ys = (topk_inds.float() / torch.tensor(width, dtype=torch.float)).int().float()\n    topk_xs = (topk_inds % width).int().float()\n    (topk_score, topk_ind) = torch.topk(topk_scores.view(batch, -1), K)\n    topk_clses = (topk_ind / torch.tensor(K, dtype=torch.float)).int()\n    topk_inds = self._gather_feat(topk_inds.view(batch, -1, 1), topk_ind).view(batch, K)\n    topk_ys = self._gather_feat(topk_ys.view(batch, -1, 1), topk_ind).view(batch, K)\n    topk_xs = self._gather_feat(topk_xs.view(batch, -1, 1), topk_ind).view(batch, K)\n    return (topk_score, topk_inds, topk_clses, topk_ys, topk_xs)",
            "def _topk(self, scores, K=80):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get indexes based on scores.\\n\\n        Args:\\n            scores (torch.Tensor): scores with the shape of [B, N, W, H].\\n            K (int, optional): Number to be kept. Defaults to 80.\\n\\n        Returns:\\n            tuple[torch.Tensor]\\n                torch.Tensor: Selected scores with the shape of [B, K].\\n                torch.Tensor: Selected indexes with the shape of [B, K].\\n                torch.Tensor: Selected classes with the shape of [B, K].\\n                torch.Tensor: Selected y coord with the shape of [B, K].\\n                torch.Tensor: Selected x coord with the shape of [B, K].\\n        '\n    (batch, cat, height, width) = scores.size()\n    (topk_scores, topk_inds) = torch.topk(scores.view(batch, cat, -1), K)\n    topk_inds = topk_inds % (height * width)\n    topk_ys = (topk_inds.float() / torch.tensor(width, dtype=torch.float)).int().float()\n    topk_xs = (topk_inds % width).int().float()\n    (topk_score, topk_ind) = torch.topk(topk_scores.view(batch, -1), K)\n    topk_clses = (topk_ind / torch.tensor(K, dtype=torch.float)).int()\n    topk_inds = self._gather_feat(topk_inds.view(batch, -1, 1), topk_ind).view(batch, K)\n    topk_ys = self._gather_feat(topk_ys.view(batch, -1, 1), topk_ind).view(batch, K)\n    topk_xs = self._gather_feat(topk_xs.view(batch, -1, 1), topk_ind).view(batch, K)\n    return (topk_score, topk_inds, topk_clses, topk_ys, topk_xs)",
            "def _topk(self, scores, K=80):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get indexes based on scores.\\n\\n        Args:\\n            scores (torch.Tensor): scores with the shape of [B, N, W, H].\\n            K (int, optional): Number to be kept. Defaults to 80.\\n\\n        Returns:\\n            tuple[torch.Tensor]\\n                torch.Tensor: Selected scores with the shape of [B, K].\\n                torch.Tensor: Selected indexes with the shape of [B, K].\\n                torch.Tensor: Selected classes with the shape of [B, K].\\n                torch.Tensor: Selected y coord with the shape of [B, K].\\n                torch.Tensor: Selected x coord with the shape of [B, K].\\n        '\n    (batch, cat, height, width) = scores.size()\n    (topk_scores, topk_inds) = torch.topk(scores.view(batch, cat, -1), K)\n    topk_inds = topk_inds % (height * width)\n    topk_ys = (topk_inds.float() / torch.tensor(width, dtype=torch.float)).int().float()\n    topk_xs = (topk_inds % width).int().float()\n    (topk_score, topk_ind) = torch.topk(topk_scores.view(batch, -1), K)\n    topk_clses = (topk_ind / torch.tensor(K, dtype=torch.float)).int()\n    topk_inds = self._gather_feat(topk_inds.view(batch, -1, 1), topk_ind).view(batch, K)\n    topk_ys = self._gather_feat(topk_ys.view(batch, -1, 1), topk_ind).view(batch, K)\n    topk_xs = self._gather_feat(topk_xs.view(batch, -1, 1), topk_ind).view(batch, K)\n    return (topk_score, topk_inds, topk_clses, topk_ys, topk_xs)",
            "def _topk(self, scores, K=80):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get indexes based on scores.\\n\\n        Args:\\n            scores (torch.Tensor): scores with the shape of [B, N, W, H].\\n            K (int, optional): Number to be kept. Defaults to 80.\\n\\n        Returns:\\n            tuple[torch.Tensor]\\n                torch.Tensor: Selected scores with the shape of [B, K].\\n                torch.Tensor: Selected indexes with the shape of [B, K].\\n                torch.Tensor: Selected classes with the shape of [B, K].\\n                torch.Tensor: Selected y coord with the shape of [B, K].\\n                torch.Tensor: Selected x coord with the shape of [B, K].\\n        '\n    (batch, cat, height, width) = scores.size()\n    (topk_scores, topk_inds) = torch.topk(scores.view(batch, cat, -1), K)\n    topk_inds = topk_inds % (height * width)\n    topk_ys = (topk_inds.float() / torch.tensor(width, dtype=torch.float)).int().float()\n    topk_xs = (topk_inds % width).int().float()\n    (topk_score, topk_ind) = torch.topk(topk_scores.view(batch, -1), K)\n    topk_clses = (topk_ind / torch.tensor(K, dtype=torch.float)).int()\n    topk_inds = self._gather_feat(topk_inds.view(batch, -1, 1), topk_ind).view(batch, K)\n    topk_ys = self._gather_feat(topk_ys.view(batch, -1, 1), topk_ind).view(batch, K)\n    topk_xs = self._gather_feat(topk_xs.view(batch, -1, 1), topk_ind).view(batch, K)\n    return (topk_score, topk_inds, topk_clses, topk_ys, topk_xs)"
        ]
    },
    {
        "func_name": "_transpose_and_gather_feat",
        "original": "def _transpose_and_gather_feat(self, feat, ind):\n    \"\"\"Given feats and indexes, returns the transposed and gathered feats.\n\n        Args:\n            feat (torch.Tensor): Features to be transposed and gathered\n                with the shape of [B, 2, W, H].\n            ind (torch.Tensor): Indexes with the shape of [B, N].\n\n        Returns:\n            torch.Tensor: Transposed and gathered feats.\n        \"\"\"\n    feat = feat.permute(0, 2, 3, 1).contiguous()\n    feat = feat.view(feat.size(0), -1, feat.size(3))\n    feat = self._gather_feat(feat, ind)\n    return feat",
        "mutated": [
            "def _transpose_and_gather_feat(self, feat, ind):\n    if False:\n        i = 10\n    'Given feats and indexes, returns the transposed and gathered feats.\\n\\n        Args:\\n            feat (torch.Tensor): Features to be transposed and gathered\\n                with the shape of [B, 2, W, H].\\n            ind (torch.Tensor): Indexes with the shape of [B, N].\\n\\n        Returns:\\n            torch.Tensor: Transposed and gathered feats.\\n        '\n    feat = feat.permute(0, 2, 3, 1).contiguous()\n    feat = feat.view(feat.size(0), -1, feat.size(3))\n    feat = self._gather_feat(feat, ind)\n    return feat",
            "def _transpose_and_gather_feat(self, feat, ind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Given feats and indexes, returns the transposed and gathered feats.\\n\\n        Args:\\n            feat (torch.Tensor): Features to be transposed and gathered\\n                with the shape of [B, 2, W, H].\\n            ind (torch.Tensor): Indexes with the shape of [B, N].\\n\\n        Returns:\\n            torch.Tensor: Transposed and gathered feats.\\n        '\n    feat = feat.permute(0, 2, 3, 1).contiguous()\n    feat = feat.view(feat.size(0), -1, feat.size(3))\n    feat = self._gather_feat(feat, ind)\n    return feat",
            "def _transpose_and_gather_feat(self, feat, ind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Given feats and indexes, returns the transposed and gathered feats.\\n\\n        Args:\\n            feat (torch.Tensor): Features to be transposed and gathered\\n                with the shape of [B, 2, W, H].\\n            ind (torch.Tensor): Indexes with the shape of [B, N].\\n\\n        Returns:\\n            torch.Tensor: Transposed and gathered feats.\\n        '\n    feat = feat.permute(0, 2, 3, 1).contiguous()\n    feat = feat.view(feat.size(0), -1, feat.size(3))\n    feat = self._gather_feat(feat, ind)\n    return feat",
            "def _transpose_and_gather_feat(self, feat, ind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Given feats and indexes, returns the transposed and gathered feats.\\n\\n        Args:\\n            feat (torch.Tensor): Features to be transposed and gathered\\n                with the shape of [B, 2, W, H].\\n            ind (torch.Tensor): Indexes with the shape of [B, N].\\n\\n        Returns:\\n            torch.Tensor: Transposed and gathered feats.\\n        '\n    feat = feat.permute(0, 2, 3, 1).contiguous()\n    feat = feat.view(feat.size(0), -1, feat.size(3))\n    feat = self._gather_feat(feat, ind)\n    return feat",
            "def _transpose_and_gather_feat(self, feat, ind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Given feats and indexes, returns the transposed and gathered feats.\\n\\n        Args:\\n            feat (torch.Tensor): Features to be transposed and gathered\\n                with the shape of [B, 2, W, H].\\n            ind (torch.Tensor): Indexes with the shape of [B, N].\\n\\n        Returns:\\n            torch.Tensor: Transposed and gathered feats.\\n        '\n    feat = feat.permute(0, 2, 3, 1).contiguous()\n    feat = feat.view(feat.size(0), -1, feat.size(3))\n    feat = self._gather_feat(feat, ind)\n    return feat"
        ]
    },
    {
        "func_name": "encode",
        "original": "def encode(self):\n    pass",
        "mutated": [
            "def encode(self):\n    if False:\n        i = 10\n    pass",
            "def encode(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pass",
            "def encode(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pass",
            "def encode(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pass",
            "def encode(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pass"
        ]
    },
    {
        "func_name": "decode",
        "original": "def decode(self, heat, rot_sine, rot_cosine, hei, dim, vel, reg=None, task_id=-1):\n    \"\"\"Decode bboxes.\n\n        Args:\n            heat (torch.Tensor): Heatmap with the shape of [B, N, W, H].\n            rot_sine (torch.Tensor): Sine of rotation with the shape of\n                [B, 1, W, H].\n            rot_cosine (torch.Tensor): Cosine of rotation with the shape of\n                [B, 1, W, H].\n            hei (torch.Tensor): Height of the boxes with the shape\n                of [B, 1, W, H].\n            dim (torch.Tensor): Dim of the boxes with the shape of\n                [B, 1, W, H].\n            vel (torch.Tensor): Velocity with the shape of [B, 1, W, H].\n            reg (torch.Tensor, optional): Regression value of the boxes in\n                2D with the shape of [B, 2, W, H]. Default: None.\n            task_id (int, optional): Index of task. Default: -1.\n\n        Returns:\n            list[dict]: Decoded boxes.\n        \"\"\"\n    (batch, cat, _, _) = heat.size()\n    (scores, inds, clses, ys, xs) = self._topk(heat, K=self.max_num)\n    if reg is not None:\n        reg = self._transpose_and_gather_feat(reg, inds)\n        reg = reg.view(batch, self.max_num, 2)\n        xs = xs.view(batch, self.max_num, 1) + reg[:, :, 0:1]\n        ys = ys.view(batch, self.max_num, 1) + reg[:, :, 1:2]\n    else:\n        xs = xs.view(batch, self.max_num, 1) + 0.5\n        ys = ys.view(batch, self.max_num, 1) + 0.5\n    rot_sine = self._transpose_and_gather_feat(rot_sine, inds)\n    rot_sine = rot_sine.view(batch, self.max_num, 1)\n    rot_cosine = self._transpose_and_gather_feat(rot_cosine, inds)\n    rot_cosine = rot_cosine.view(batch, self.max_num, 1)\n    rot = torch.atan2(rot_sine, rot_cosine)\n    hei = self._transpose_and_gather_feat(hei, inds)\n    hei = hei.view(batch, self.max_num, 1)\n    dim = self._transpose_and_gather_feat(dim, inds)\n    dim = dim.view(batch, self.max_num, 3)\n    clses = clses.view(batch, self.max_num).float()\n    scores = scores.view(batch, self.max_num)\n    xs = xs.view(batch, self.max_num, 1) * self.out_size_factor * self.voxel_size[0] + self.pc_range[0]\n    ys = ys.view(batch, self.max_num, 1) * self.out_size_factor * self.voxel_size[1] + self.pc_range[1]\n    if vel is None:\n        final_box_preds = torch.cat([xs, ys, hei, dim, rot], dim=2)\n    else:\n        vel = self._transpose_and_gather_feat(vel, inds)\n        vel = vel.view(batch, self.max_num, 2)\n        final_box_preds = torch.cat([xs, ys, hei, dim, rot, vel], dim=2)\n    final_scores = scores\n    final_preds = clses\n    if self.score_threshold is not None:\n        thresh_mask = final_scores > self.score_threshold\n    if self.post_center_range is not None:\n        self.post_center_range = torch.tensor(self.post_center_range, device=heat.device)\n        mask = (final_box_preds[..., :3] >= self.post_center_range[:3]).all(2)\n        mask &= (final_box_preds[..., :3] <= self.post_center_range[3:]).all(2)\n        predictions_dicts = []\n        for i in range(batch):\n            cmask = mask[i, :]\n            if self.score_threshold:\n                cmask &= thresh_mask[i]\n            boxes3d = final_box_preds[i, cmask]\n            scores = final_scores[i, cmask]\n            labels = final_preds[i, cmask]\n            predictions_dict = {'bboxes': boxes3d, 'scores': scores, 'labels': labels}\n            predictions_dicts.append(predictions_dict)\n    else:\n        raise NotImplementedError('Need to reorganize output as a batch, only support post_center_range is not None for now!')\n    return predictions_dicts",
        "mutated": [
            "def decode(self, heat, rot_sine, rot_cosine, hei, dim, vel, reg=None, task_id=-1):\n    if False:\n        i = 10\n    'Decode bboxes.\\n\\n        Args:\\n            heat (torch.Tensor): Heatmap with the shape of [B, N, W, H].\\n            rot_sine (torch.Tensor): Sine of rotation with the shape of\\n                [B, 1, W, H].\\n            rot_cosine (torch.Tensor): Cosine of rotation with the shape of\\n                [B, 1, W, H].\\n            hei (torch.Tensor): Height of the boxes with the shape\\n                of [B, 1, W, H].\\n            dim (torch.Tensor): Dim of the boxes with the shape of\\n                [B, 1, W, H].\\n            vel (torch.Tensor): Velocity with the shape of [B, 1, W, H].\\n            reg (torch.Tensor, optional): Regression value of the boxes in\\n                2D with the shape of [B, 2, W, H]. Default: None.\\n            task_id (int, optional): Index of task. Default: -1.\\n\\n        Returns:\\n            list[dict]: Decoded boxes.\\n        '\n    (batch, cat, _, _) = heat.size()\n    (scores, inds, clses, ys, xs) = self._topk(heat, K=self.max_num)\n    if reg is not None:\n        reg = self._transpose_and_gather_feat(reg, inds)\n        reg = reg.view(batch, self.max_num, 2)\n        xs = xs.view(batch, self.max_num, 1) + reg[:, :, 0:1]\n        ys = ys.view(batch, self.max_num, 1) + reg[:, :, 1:2]\n    else:\n        xs = xs.view(batch, self.max_num, 1) + 0.5\n        ys = ys.view(batch, self.max_num, 1) + 0.5\n    rot_sine = self._transpose_and_gather_feat(rot_sine, inds)\n    rot_sine = rot_sine.view(batch, self.max_num, 1)\n    rot_cosine = self._transpose_and_gather_feat(rot_cosine, inds)\n    rot_cosine = rot_cosine.view(batch, self.max_num, 1)\n    rot = torch.atan2(rot_sine, rot_cosine)\n    hei = self._transpose_and_gather_feat(hei, inds)\n    hei = hei.view(batch, self.max_num, 1)\n    dim = self._transpose_and_gather_feat(dim, inds)\n    dim = dim.view(batch, self.max_num, 3)\n    clses = clses.view(batch, self.max_num).float()\n    scores = scores.view(batch, self.max_num)\n    xs = xs.view(batch, self.max_num, 1) * self.out_size_factor * self.voxel_size[0] + self.pc_range[0]\n    ys = ys.view(batch, self.max_num, 1) * self.out_size_factor * self.voxel_size[1] + self.pc_range[1]\n    if vel is None:\n        final_box_preds = torch.cat([xs, ys, hei, dim, rot], dim=2)\n    else:\n        vel = self._transpose_and_gather_feat(vel, inds)\n        vel = vel.view(batch, self.max_num, 2)\n        final_box_preds = torch.cat([xs, ys, hei, dim, rot, vel], dim=2)\n    final_scores = scores\n    final_preds = clses\n    if self.score_threshold is not None:\n        thresh_mask = final_scores > self.score_threshold\n    if self.post_center_range is not None:\n        self.post_center_range = torch.tensor(self.post_center_range, device=heat.device)\n        mask = (final_box_preds[..., :3] >= self.post_center_range[:3]).all(2)\n        mask &= (final_box_preds[..., :3] <= self.post_center_range[3:]).all(2)\n        predictions_dicts = []\n        for i in range(batch):\n            cmask = mask[i, :]\n            if self.score_threshold:\n                cmask &= thresh_mask[i]\n            boxes3d = final_box_preds[i, cmask]\n            scores = final_scores[i, cmask]\n            labels = final_preds[i, cmask]\n            predictions_dict = {'bboxes': boxes3d, 'scores': scores, 'labels': labels}\n            predictions_dicts.append(predictions_dict)\n    else:\n        raise NotImplementedError('Need to reorganize output as a batch, only support post_center_range is not None for now!')\n    return predictions_dicts",
            "def decode(self, heat, rot_sine, rot_cosine, hei, dim, vel, reg=None, task_id=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Decode bboxes.\\n\\n        Args:\\n            heat (torch.Tensor): Heatmap with the shape of [B, N, W, H].\\n            rot_sine (torch.Tensor): Sine of rotation with the shape of\\n                [B, 1, W, H].\\n            rot_cosine (torch.Tensor): Cosine of rotation with the shape of\\n                [B, 1, W, H].\\n            hei (torch.Tensor): Height of the boxes with the shape\\n                of [B, 1, W, H].\\n            dim (torch.Tensor): Dim of the boxes with the shape of\\n                [B, 1, W, H].\\n            vel (torch.Tensor): Velocity with the shape of [B, 1, W, H].\\n            reg (torch.Tensor, optional): Regression value of the boxes in\\n                2D with the shape of [B, 2, W, H]. Default: None.\\n            task_id (int, optional): Index of task. Default: -1.\\n\\n        Returns:\\n            list[dict]: Decoded boxes.\\n        '\n    (batch, cat, _, _) = heat.size()\n    (scores, inds, clses, ys, xs) = self._topk(heat, K=self.max_num)\n    if reg is not None:\n        reg = self._transpose_and_gather_feat(reg, inds)\n        reg = reg.view(batch, self.max_num, 2)\n        xs = xs.view(batch, self.max_num, 1) + reg[:, :, 0:1]\n        ys = ys.view(batch, self.max_num, 1) + reg[:, :, 1:2]\n    else:\n        xs = xs.view(batch, self.max_num, 1) + 0.5\n        ys = ys.view(batch, self.max_num, 1) + 0.5\n    rot_sine = self._transpose_and_gather_feat(rot_sine, inds)\n    rot_sine = rot_sine.view(batch, self.max_num, 1)\n    rot_cosine = self._transpose_and_gather_feat(rot_cosine, inds)\n    rot_cosine = rot_cosine.view(batch, self.max_num, 1)\n    rot = torch.atan2(rot_sine, rot_cosine)\n    hei = self._transpose_and_gather_feat(hei, inds)\n    hei = hei.view(batch, self.max_num, 1)\n    dim = self._transpose_and_gather_feat(dim, inds)\n    dim = dim.view(batch, self.max_num, 3)\n    clses = clses.view(batch, self.max_num).float()\n    scores = scores.view(batch, self.max_num)\n    xs = xs.view(batch, self.max_num, 1) * self.out_size_factor * self.voxel_size[0] + self.pc_range[0]\n    ys = ys.view(batch, self.max_num, 1) * self.out_size_factor * self.voxel_size[1] + self.pc_range[1]\n    if vel is None:\n        final_box_preds = torch.cat([xs, ys, hei, dim, rot], dim=2)\n    else:\n        vel = self._transpose_and_gather_feat(vel, inds)\n        vel = vel.view(batch, self.max_num, 2)\n        final_box_preds = torch.cat([xs, ys, hei, dim, rot, vel], dim=2)\n    final_scores = scores\n    final_preds = clses\n    if self.score_threshold is not None:\n        thresh_mask = final_scores > self.score_threshold\n    if self.post_center_range is not None:\n        self.post_center_range = torch.tensor(self.post_center_range, device=heat.device)\n        mask = (final_box_preds[..., :3] >= self.post_center_range[:3]).all(2)\n        mask &= (final_box_preds[..., :3] <= self.post_center_range[3:]).all(2)\n        predictions_dicts = []\n        for i in range(batch):\n            cmask = mask[i, :]\n            if self.score_threshold:\n                cmask &= thresh_mask[i]\n            boxes3d = final_box_preds[i, cmask]\n            scores = final_scores[i, cmask]\n            labels = final_preds[i, cmask]\n            predictions_dict = {'bboxes': boxes3d, 'scores': scores, 'labels': labels}\n            predictions_dicts.append(predictions_dict)\n    else:\n        raise NotImplementedError('Need to reorganize output as a batch, only support post_center_range is not None for now!')\n    return predictions_dicts",
            "def decode(self, heat, rot_sine, rot_cosine, hei, dim, vel, reg=None, task_id=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Decode bboxes.\\n\\n        Args:\\n            heat (torch.Tensor): Heatmap with the shape of [B, N, W, H].\\n            rot_sine (torch.Tensor): Sine of rotation with the shape of\\n                [B, 1, W, H].\\n            rot_cosine (torch.Tensor): Cosine of rotation with the shape of\\n                [B, 1, W, H].\\n            hei (torch.Tensor): Height of the boxes with the shape\\n                of [B, 1, W, H].\\n            dim (torch.Tensor): Dim of the boxes with the shape of\\n                [B, 1, W, H].\\n            vel (torch.Tensor): Velocity with the shape of [B, 1, W, H].\\n            reg (torch.Tensor, optional): Regression value of the boxes in\\n                2D with the shape of [B, 2, W, H]. Default: None.\\n            task_id (int, optional): Index of task. Default: -1.\\n\\n        Returns:\\n            list[dict]: Decoded boxes.\\n        '\n    (batch, cat, _, _) = heat.size()\n    (scores, inds, clses, ys, xs) = self._topk(heat, K=self.max_num)\n    if reg is not None:\n        reg = self._transpose_and_gather_feat(reg, inds)\n        reg = reg.view(batch, self.max_num, 2)\n        xs = xs.view(batch, self.max_num, 1) + reg[:, :, 0:1]\n        ys = ys.view(batch, self.max_num, 1) + reg[:, :, 1:2]\n    else:\n        xs = xs.view(batch, self.max_num, 1) + 0.5\n        ys = ys.view(batch, self.max_num, 1) + 0.5\n    rot_sine = self._transpose_and_gather_feat(rot_sine, inds)\n    rot_sine = rot_sine.view(batch, self.max_num, 1)\n    rot_cosine = self._transpose_and_gather_feat(rot_cosine, inds)\n    rot_cosine = rot_cosine.view(batch, self.max_num, 1)\n    rot = torch.atan2(rot_sine, rot_cosine)\n    hei = self._transpose_and_gather_feat(hei, inds)\n    hei = hei.view(batch, self.max_num, 1)\n    dim = self._transpose_and_gather_feat(dim, inds)\n    dim = dim.view(batch, self.max_num, 3)\n    clses = clses.view(batch, self.max_num).float()\n    scores = scores.view(batch, self.max_num)\n    xs = xs.view(batch, self.max_num, 1) * self.out_size_factor * self.voxel_size[0] + self.pc_range[0]\n    ys = ys.view(batch, self.max_num, 1) * self.out_size_factor * self.voxel_size[1] + self.pc_range[1]\n    if vel is None:\n        final_box_preds = torch.cat([xs, ys, hei, dim, rot], dim=2)\n    else:\n        vel = self._transpose_and_gather_feat(vel, inds)\n        vel = vel.view(batch, self.max_num, 2)\n        final_box_preds = torch.cat([xs, ys, hei, dim, rot, vel], dim=2)\n    final_scores = scores\n    final_preds = clses\n    if self.score_threshold is not None:\n        thresh_mask = final_scores > self.score_threshold\n    if self.post_center_range is not None:\n        self.post_center_range = torch.tensor(self.post_center_range, device=heat.device)\n        mask = (final_box_preds[..., :3] >= self.post_center_range[:3]).all(2)\n        mask &= (final_box_preds[..., :3] <= self.post_center_range[3:]).all(2)\n        predictions_dicts = []\n        for i in range(batch):\n            cmask = mask[i, :]\n            if self.score_threshold:\n                cmask &= thresh_mask[i]\n            boxes3d = final_box_preds[i, cmask]\n            scores = final_scores[i, cmask]\n            labels = final_preds[i, cmask]\n            predictions_dict = {'bboxes': boxes3d, 'scores': scores, 'labels': labels}\n            predictions_dicts.append(predictions_dict)\n    else:\n        raise NotImplementedError('Need to reorganize output as a batch, only support post_center_range is not None for now!')\n    return predictions_dicts",
            "def decode(self, heat, rot_sine, rot_cosine, hei, dim, vel, reg=None, task_id=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Decode bboxes.\\n\\n        Args:\\n            heat (torch.Tensor): Heatmap with the shape of [B, N, W, H].\\n            rot_sine (torch.Tensor): Sine of rotation with the shape of\\n                [B, 1, W, H].\\n            rot_cosine (torch.Tensor): Cosine of rotation with the shape of\\n                [B, 1, W, H].\\n            hei (torch.Tensor): Height of the boxes with the shape\\n                of [B, 1, W, H].\\n            dim (torch.Tensor): Dim of the boxes with the shape of\\n                [B, 1, W, H].\\n            vel (torch.Tensor): Velocity with the shape of [B, 1, W, H].\\n            reg (torch.Tensor, optional): Regression value of the boxes in\\n                2D with the shape of [B, 2, W, H]. Default: None.\\n            task_id (int, optional): Index of task. Default: -1.\\n\\n        Returns:\\n            list[dict]: Decoded boxes.\\n        '\n    (batch, cat, _, _) = heat.size()\n    (scores, inds, clses, ys, xs) = self._topk(heat, K=self.max_num)\n    if reg is not None:\n        reg = self._transpose_and_gather_feat(reg, inds)\n        reg = reg.view(batch, self.max_num, 2)\n        xs = xs.view(batch, self.max_num, 1) + reg[:, :, 0:1]\n        ys = ys.view(batch, self.max_num, 1) + reg[:, :, 1:2]\n    else:\n        xs = xs.view(batch, self.max_num, 1) + 0.5\n        ys = ys.view(batch, self.max_num, 1) + 0.5\n    rot_sine = self._transpose_and_gather_feat(rot_sine, inds)\n    rot_sine = rot_sine.view(batch, self.max_num, 1)\n    rot_cosine = self._transpose_and_gather_feat(rot_cosine, inds)\n    rot_cosine = rot_cosine.view(batch, self.max_num, 1)\n    rot = torch.atan2(rot_sine, rot_cosine)\n    hei = self._transpose_and_gather_feat(hei, inds)\n    hei = hei.view(batch, self.max_num, 1)\n    dim = self._transpose_and_gather_feat(dim, inds)\n    dim = dim.view(batch, self.max_num, 3)\n    clses = clses.view(batch, self.max_num).float()\n    scores = scores.view(batch, self.max_num)\n    xs = xs.view(batch, self.max_num, 1) * self.out_size_factor * self.voxel_size[0] + self.pc_range[0]\n    ys = ys.view(batch, self.max_num, 1) * self.out_size_factor * self.voxel_size[1] + self.pc_range[1]\n    if vel is None:\n        final_box_preds = torch.cat([xs, ys, hei, dim, rot], dim=2)\n    else:\n        vel = self._transpose_and_gather_feat(vel, inds)\n        vel = vel.view(batch, self.max_num, 2)\n        final_box_preds = torch.cat([xs, ys, hei, dim, rot, vel], dim=2)\n    final_scores = scores\n    final_preds = clses\n    if self.score_threshold is not None:\n        thresh_mask = final_scores > self.score_threshold\n    if self.post_center_range is not None:\n        self.post_center_range = torch.tensor(self.post_center_range, device=heat.device)\n        mask = (final_box_preds[..., :3] >= self.post_center_range[:3]).all(2)\n        mask &= (final_box_preds[..., :3] <= self.post_center_range[3:]).all(2)\n        predictions_dicts = []\n        for i in range(batch):\n            cmask = mask[i, :]\n            if self.score_threshold:\n                cmask &= thresh_mask[i]\n            boxes3d = final_box_preds[i, cmask]\n            scores = final_scores[i, cmask]\n            labels = final_preds[i, cmask]\n            predictions_dict = {'bboxes': boxes3d, 'scores': scores, 'labels': labels}\n            predictions_dicts.append(predictions_dict)\n    else:\n        raise NotImplementedError('Need to reorganize output as a batch, only support post_center_range is not None for now!')\n    return predictions_dicts",
            "def decode(self, heat, rot_sine, rot_cosine, hei, dim, vel, reg=None, task_id=-1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Decode bboxes.\\n\\n        Args:\\n            heat (torch.Tensor): Heatmap with the shape of [B, N, W, H].\\n            rot_sine (torch.Tensor): Sine of rotation with the shape of\\n                [B, 1, W, H].\\n            rot_cosine (torch.Tensor): Cosine of rotation with the shape of\\n                [B, 1, W, H].\\n            hei (torch.Tensor): Height of the boxes with the shape\\n                of [B, 1, W, H].\\n            dim (torch.Tensor): Dim of the boxes with the shape of\\n                [B, 1, W, H].\\n            vel (torch.Tensor): Velocity with the shape of [B, 1, W, H].\\n            reg (torch.Tensor, optional): Regression value of the boxes in\\n                2D with the shape of [B, 2, W, H]. Default: None.\\n            task_id (int, optional): Index of task. Default: -1.\\n\\n        Returns:\\n            list[dict]: Decoded boxes.\\n        '\n    (batch, cat, _, _) = heat.size()\n    (scores, inds, clses, ys, xs) = self._topk(heat, K=self.max_num)\n    if reg is not None:\n        reg = self._transpose_and_gather_feat(reg, inds)\n        reg = reg.view(batch, self.max_num, 2)\n        xs = xs.view(batch, self.max_num, 1) + reg[:, :, 0:1]\n        ys = ys.view(batch, self.max_num, 1) + reg[:, :, 1:2]\n    else:\n        xs = xs.view(batch, self.max_num, 1) + 0.5\n        ys = ys.view(batch, self.max_num, 1) + 0.5\n    rot_sine = self._transpose_and_gather_feat(rot_sine, inds)\n    rot_sine = rot_sine.view(batch, self.max_num, 1)\n    rot_cosine = self._transpose_and_gather_feat(rot_cosine, inds)\n    rot_cosine = rot_cosine.view(batch, self.max_num, 1)\n    rot = torch.atan2(rot_sine, rot_cosine)\n    hei = self._transpose_and_gather_feat(hei, inds)\n    hei = hei.view(batch, self.max_num, 1)\n    dim = self._transpose_and_gather_feat(dim, inds)\n    dim = dim.view(batch, self.max_num, 3)\n    clses = clses.view(batch, self.max_num).float()\n    scores = scores.view(batch, self.max_num)\n    xs = xs.view(batch, self.max_num, 1) * self.out_size_factor * self.voxel_size[0] + self.pc_range[0]\n    ys = ys.view(batch, self.max_num, 1) * self.out_size_factor * self.voxel_size[1] + self.pc_range[1]\n    if vel is None:\n        final_box_preds = torch.cat([xs, ys, hei, dim, rot], dim=2)\n    else:\n        vel = self._transpose_and_gather_feat(vel, inds)\n        vel = vel.view(batch, self.max_num, 2)\n        final_box_preds = torch.cat([xs, ys, hei, dim, rot, vel], dim=2)\n    final_scores = scores\n    final_preds = clses\n    if self.score_threshold is not None:\n        thresh_mask = final_scores > self.score_threshold\n    if self.post_center_range is not None:\n        self.post_center_range = torch.tensor(self.post_center_range, device=heat.device)\n        mask = (final_box_preds[..., :3] >= self.post_center_range[:3]).all(2)\n        mask &= (final_box_preds[..., :3] <= self.post_center_range[3:]).all(2)\n        predictions_dicts = []\n        for i in range(batch):\n            cmask = mask[i, :]\n            if self.score_threshold:\n                cmask &= thresh_mask[i]\n            boxes3d = final_box_preds[i, cmask]\n            scores = final_scores[i, cmask]\n            labels = final_preds[i, cmask]\n            predictions_dict = {'bboxes': boxes3d, 'scores': scores, 'labels': labels}\n            predictions_dicts.append(predictions_dict)\n    else:\n        raise NotImplementedError('Need to reorganize output as a batch, only support post_center_range is not None for now!')\n    return predictions_dicts"
        ]
    }
]