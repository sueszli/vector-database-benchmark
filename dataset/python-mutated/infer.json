[
    {
        "func_name": "prepare_data_blocks",
        "original": "def prepare_data_blocks(blocks, size):\n    data = []\n    for block in blocks:\n        data.append(load_tf_img(block, size))\n    return data",
        "mutated": [
            "def prepare_data_blocks(blocks, size):\n    if False:\n        i = 10\n    data = []\n    for block in blocks:\n        data.append(load_tf_img(block, size))\n    return data",
            "def prepare_data_blocks(blocks, size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    data = []\n    for block in blocks:\n        data.append(load_tf_img(block, size))\n    return data",
            "def prepare_data_blocks(blocks, size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    data = []\n    for block in blocks:\n        data.append(load_tf_img(block, size))\n    return data",
            "def prepare_data_blocks(blocks, size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    data = []\n    for block in blocks:\n        data.append(load_tf_img(block, size))\n    return data",
            "def prepare_data_blocks(blocks, size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    data = []\n    for block in blocks:\n        data.append(load_tf_img(block, size))\n    return data"
        ]
    },
    {
        "func_name": "infer",
        "original": "def infer(model_name, model_weight, target_dir, save_out_dir, block_size=(256, 256), batch_size=1):\n    json_file = open(model_name, 'r')\n    loaded_model_json = json_file.read()\n    json_file.close()\n    model = model_from_json(loaded_model_json, custom_objects={'relu6': tf.nn.relu6, 'convert2gray': convert2gray})\n    model.summary()\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    model.load_weights(model_weight)\n    if not os.path.exists(save_out_dir):\n        os.makedirs(save_out_dir)\n    M = block_size[0]\n    N = block_size[1]\n    part = 8\n    filelists = getListOfFiles(target_dir)\n    for filename in tqdm(filelists):\n        initial_filename = os.path.splitext(filename)[0]\n        in1_filename = os.path.join(target_dir, filename)\n        in_clr = cv2.imread(in1_filename, 1)\n        in1_image = cv2.cvtColor(in_clr, cv2.COLOR_BGR2RGB)\n        in1_img = GetOverlappingBlocks(in1_image.copy(), M, N, part)\n        prepared_data_blocks = prepare_data_blocks(in1_img, M)\n        in1_img = []\n        out_img1 = model.predict(tf.convert_to_tensor(prepared_data_blocks), batch_size=batch_size)\n        (num_img, ht, wd, ch_out) = out_img1.shape\n        (h, w, ch) = in_clr.shape\n        if ch_out > 1:\n            c_image = cv2.cvtColor(CombineToImage(out_img1, h, w, ch_out), cv2.COLOR_RGB2BGR, part)\n            out_image_name = initial_filename + '.png'\n            name_fig = os.path.join(save_out_dir, out_image_name)\n            cv2.imwrite(name_fig, c_image)\n        else:\n            c_image = CombineToImage(out_img1, h, w, ch_out, part)\n            out_image_name = initial_filename + '.png'\n            name_fig = os.path.join(save_out_dir, out_image_name)\n            cv2.imwrite(name_fig, c_image)",
        "mutated": [
            "def infer(model_name, model_weight, target_dir, save_out_dir, block_size=(256, 256), batch_size=1):\n    if False:\n        i = 10\n    json_file = open(model_name, 'r')\n    loaded_model_json = json_file.read()\n    json_file.close()\n    model = model_from_json(loaded_model_json, custom_objects={'relu6': tf.nn.relu6, 'convert2gray': convert2gray})\n    model.summary()\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    model.load_weights(model_weight)\n    if not os.path.exists(save_out_dir):\n        os.makedirs(save_out_dir)\n    M = block_size[0]\n    N = block_size[1]\n    part = 8\n    filelists = getListOfFiles(target_dir)\n    for filename in tqdm(filelists):\n        initial_filename = os.path.splitext(filename)[0]\n        in1_filename = os.path.join(target_dir, filename)\n        in_clr = cv2.imread(in1_filename, 1)\n        in1_image = cv2.cvtColor(in_clr, cv2.COLOR_BGR2RGB)\n        in1_img = GetOverlappingBlocks(in1_image.copy(), M, N, part)\n        prepared_data_blocks = prepare_data_blocks(in1_img, M)\n        in1_img = []\n        out_img1 = model.predict(tf.convert_to_tensor(prepared_data_blocks), batch_size=batch_size)\n        (num_img, ht, wd, ch_out) = out_img1.shape\n        (h, w, ch) = in_clr.shape\n        if ch_out > 1:\n            c_image = cv2.cvtColor(CombineToImage(out_img1, h, w, ch_out), cv2.COLOR_RGB2BGR, part)\n            out_image_name = initial_filename + '.png'\n            name_fig = os.path.join(save_out_dir, out_image_name)\n            cv2.imwrite(name_fig, c_image)\n        else:\n            c_image = CombineToImage(out_img1, h, w, ch_out, part)\n            out_image_name = initial_filename + '.png'\n            name_fig = os.path.join(save_out_dir, out_image_name)\n            cv2.imwrite(name_fig, c_image)",
            "def infer(model_name, model_weight, target_dir, save_out_dir, block_size=(256, 256), batch_size=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    json_file = open(model_name, 'r')\n    loaded_model_json = json_file.read()\n    json_file.close()\n    model = model_from_json(loaded_model_json, custom_objects={'relu6': tf.nn.relu6, 'convert2gray': convert2gray})\n    model.summary()\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    model.load_weights(model_weight)\n    if not os.path.exists(save_out_dir):\n        os.makedirs(save_out_dir)\n    M = block_size[0]\n    N = block_size[1]\n    part = 8\n    filelists = getListOfFiles(target_dir)\n    for filename in tqdm(filelists):\n        initial_filename = os.path.splitext(filename)[0]\n        in1_filename = os.path.join(target_dir, filename)\n        in_clr = cv2.imread(in1_filename, 1)\n        in1_image = cv2.cvtColor(in_clr, cv2.COLOR_BGR2RGB)\n        in1_img = GetOverlappingBlocks(in1_image.copy(), M, N, part)\n        prepared_data_blocks = prepare_data_blocks(in1_img, M)\n        in1_img = []\n        out_img1 = model.predict(tf.convert_to_tensor(prepared_data_blocks), batch_size=batch_size)\n        (num_img, ht, wd, ch_out) = out_img1.shape\n        (h, w, ch) = in_clr.shape\n        if ch_out > 1:\n            c_image = cv2.cvtColor(CombineToImage(out_img1, h, w, ch_out), cv2.COLOR_RGB2BGR, part)\n            out_image_name = initial_filename + '.png'\n            name_fig = os.path.join(save_out_dir, out_image_name)\n            cv2.imwrite(name_fig, c_image)\n        else:\n            c_image = CombineToImage(out_img1, h, w, ch_out, part)\n            out_image_name = initial_filename + '.png'\n            name_fig = os.path.join(save_out_dir, out_image_name)\n            cv2.imwrite(name_fig, c_image)",
            "def infer(model_name, model_weight, target_dir, save_out_dir, block_size=(256, 256), batch_size=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    json_file = open(model_name, 'r')\n    loaded_model_json = json_file.read()\n    json_file.close()\n    model = model_from_json(loaded_model_json, custom_objects={'relu6': tf.nn.relu6, 'convert2gray': convert2gray})\n    model.summary()\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    model.load_weights(model_weight)\n    if not os.path.exists(save_out_dir):\n        os.makedirs(save_out_dir)\n    M = block_size[0]\n    N = block_size[1]\n    part = 8\n    filelists = getListOfFiles(target_dir)\n    for filename in tqdm(filelists):\n        initial_filename = os.path.splitext(filename)[0]\n        in1_filename = os.path.join(target_dir, filename)\n        in_clr = cv2.imread(in1_filename, 1)\n        in1_image = cv2.cvtColor(in_clr, cv2.COLOR_BGR2RGB)\n        in1_img = GetOverlappingBlocks(in1_image.copy(), M, N, part)\n        prepared_data_blocks = prepare_data_blocks(in1_img, M)\n        in1_img = []\n        out_img1 = model.predict(tf.convert_to_tensor(prepared_data_blocks), batch_size=batch_size)\n        (num_img, ht, wd, ch_out) = out_img1.shape\n        (h, w, ch) = in_clr.shape\n        if ch_out > 1:\n            c_image = cv2.cvtColor(CombineToImage(out_img1, h, w, ch_out), cv2.COLOR_RGB2BGR, part)\n            out_image_name = initial_filename + '.png'\n            name_fig = os.path.join(save_out_dir, out_image_name)\n            cv2.imwrite(name_fig, c_image)\n        else:\n            c_image = CombineToImage(out_img1, h, w, ch_out, part)\n            out_image_name = initial_filename + '.png'\n            name_fig = os.path.join(save_out_dir, out_image_name)\n            cv2.imwrite(name_fig, c_image)",
            "def infer(model_name, model_weight, target_dir, save_out_dir, block_size=(256, 256), batch_size=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    json_file = open(model_name, 'r')\n    loaded_model_json = json_file.read()\n    json_file.close()\n    model = model_from_json(loaded_model_json, custom_objects={'relu6': tf.nn.relu6, 'convert2gray': convert2gray})\n    model.summary()\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    model.load_weights(model_weight)\n    if not os.path.exists(save_out_dir):\n        os.makedirs(save_out_dir)\n    M = block_size[0]\n    N = block_size[1]\n    part = 8\n    filelists = getListOfFiles(target_dir)\n    for filename in tqdm(filelists):\n        initial_filename = os.path.splitext(filename)[0]\n        in1_filename = os.path.join(target_dir, filename)\n        in_clr = cv2.imread(in1_filename, 1)\n        in1_image = cv2.cvtColor(in_clr, cv2.COLOR_BGR2RGB)\n        in1_img = GetOverlappingBlocks(in1_image.copy(), M, N, part)\n        prepared_data_blocks = prepare_data_blocks(in1_img, M)\n        in1_img = []\n        out_img1 = model.predict(tf.convert_to_tensor(prepared_data_blocks), batch_size=batch_size)\n        (num_img, ht, wd, ch_out) = out_img1.shape\n        (h, w, ch) = in_clr.shape\n        if ch_out > 1:\n            c_image = cv2.cvtColor(CombineToImage(out_img1, h, w, ch_out), cv2.COLOR_RGB2BGR, part)\n            out_image_name = initial_filename + '.png'\n            name_fig = os.path.join(save_out_dir, out_image_name)\n            cv2.imwrite(name_fig, c_image)\n        else:\n            c_image = CombineToImage(out_img1, h, w, ch_out, part)\n            out_image_name = initial_filename + '.png'\n            name_fig = os.path.join(save_out_dir, out_image_name)\n            cv2.imwrite(name_fig, c_image)",
            "def infer(model_name, model_weight, target_dir, save_out_dir, block_size=(256, 256), batch_size=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    json_file = open(model_name, 'r')\n    loaded_model_json = json_file.read()\n    json_file.close()\n    model = model_from_json(loaded_model_json, custom_objects={'relu6': tf.nn.relu6, 'convert2gray': convert2gray})\n    model.summary()\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    model.load_weights(model_weight)\n    if not os.path.exists(save_out_dir):\n        os.makedirs(save_out_dir)\n    M = block_size[0]\n    N = block_size[1]\n    part = 8\n    filelists = getListOfFiles(target_dir)\n    for filename in tqdm(filelists):\n        initial_filename = os.path.splitext(filename)[0]\n        in1_filename = os.path.join(target_dir, filename)\n        in_clr = cv2.imread(in1_filename, 1)\n        in1_image = cv2.cvtColor(in_clr, cv2.COLOR_BGR2RGB)\n        in1_img = GetOverlappingBlocks(in1_image.copy(), M, N, part)\n        prepared_data_blocks = prepare_data_blocks(in1_img, M)\n        in1_img = []\n        out_img1 = model.predict(tf.convert_to_tensor(prepared_data_blocks), batch_size=batch_size)\n        (num_img, ht, wd, ch_out) = out_img1.shape\n        (h, w, ch) = in_clr.shape\n        if ch_out > 1:\n            c_image = cv2.cvtColor(CombineToImage(out_img1, h, w, ch_out), cv2.COLOR_RGB2BGR, part)\n            out_image_name = initial_filename + '.png'\n            name_fig = os.path.join(save_out_dir, out_image_name)\n            cv2.imwrite(name_fig, c_image)\n        else:\n            c_image = CombineToImage(out_img1, h, w, ch_out, part)\n            out_image_name = initial_filename + '.png'\n            name_fig = os.path.join(save_out_dir, out_image_name)\n            cv2.imwrite(name_fig, c_image)"
        ]
    },
    {
        "func_name": "infer_image",
        "original": "def infer_image(model_name, model_weight, target_image, out_image_name, block_size=(256, 256), batch_size=1):\n    json_file = open(model_name, 'r')\n    loaded_model_json = json_file.read()\n    json_file.close()\n    model = model_from_json(loaded_model_json, custom_objects={'relu6': tf.nn.relu6})\n    model.summary()\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    model.load_weights(model_weight)\n    M = block_size[0]\n    N = block_size[1]\n    part = 8\n    in_clr = cv2.imread(target_image, 1)\n    in1_image = cv2.cvtColor(in_clr, cv2.COLOR_BGR2RGB)\n    in1_img = GetOverlappingBlocks(in1_image.copy(), M, N, part)\n    prepared_data_blocks = prepare_data_blocks(in1_img, M)\n    in1_img = []\n    out_img1 = model.predict(tf.convert_to_tensor(prepared_data_blocks), batch_size=batch_size)\n    (num_img, ht, wd, ch_out) = out_img1.shape\n    (h, w, ch) = in_clr.shape\n    if ch_out > 1:\n        c_image = cv2.cvtColor(CombineToImage(out_img1, h, w, ch_out), cv2.COLOR_RGB2BGR, part)\n        cv2.imwrite(out_image_name, c_image)\n    else:\n        c_image = CombineToImage(out_img1, h, w, ch_out, part)\n        cv2.imwrite(out_image_name, c_image)",
        "mutated": [
            "def infer_image(model_name, model_weight, target_image, out_image_name, block_size=(256, 256), batch_size=1):\n    if False:\n        i = 10\n    json_file = open(model_name, 'r')\n    loaded_model_json = json_file.read()\n    json_file.close()\n    model = model_from_json(loaded_model_json, custom_objects={'relu6': tf.nn.relu6})\n    model.summary()\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    model.load_weights(model_weight)\n    M = block_size[0]\n    N = block_size[1]\n    part = 8\n    in_clr = cv2.imread(target_image, 1)\n    in1_image = cv2.cvtColor(in_clr, cv2.COLOR_BGR2RGB)\n    in1_img = GetOverlappingBlocks(in1_image.copy(), M, N, part)\n    prepared_data_blocks = prepare_data_blocks(in1_img, M)\n    in1_img = []\n    out_img1 = model.predict(tf.convert_to_tensor(prepared_data_blocks), batch_size=batch_size)\n    (num_img, ht, wd, ch_out) = out_img1.shape\n    (h, w, ch) = in_clr.shape\n    if ch_out > 1:\n        c_image = cv2.cvtColor(CombineToImage(out_img1, h, w, ch_out), cv2.COLOR_RGB2BGR, part)\n        cv2.imwrite(out_image_name, c_image)\n    else:\n        c_image = CombineToImage(out_img1, h, w, ch_out, part)\n        cv2.imwrite(out_image_name, c_image)",
            "def infer_image(model_name, model_weight, target_image, out_image_name, block_size=(256, 256), batch_size=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    json_file = open(model_name, 'r')\n    loaded_model_json = json_file.read()\n    json_file.close()\n    model = model_from_json(loaded_model_json, custom_objects={'relu6': tf.nn.relu6})\n    model.summary()\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    model.load_weights(model_weight)\n    M = block_size[0]\n    N = block_size[1]\n    part = 8\n    in_clr = cv2.imread(target_image, 1)\n    in1_image = cv2.cvtColor(in_clr, cv2.COLOR_BGR2RGB)\n    in1_img = GetOverlappingBlocks(in1_image.copy(), M, N, part)\n    prepared_data_blocks = prepare_data_blocks(in1_img, M)\n    in1_img = []\n    out_img1 = model.predict(tf.convert_to_tensor(prepared_data_blocks), batch_size=batch_size)\n    (num_img, ht, wd, ch_out) = out_img1.shape\n    (h, w, ch) = in_clr.shape\n    if ch_out > 1:\n        c_image = cv2.cvtColor(CombineToImage(out_img1, h, w, ch_out), cv2.COLOR_RGB2BGR, part)\n        cv2.imwrite(out_image_name, c_image)\n    else:\n        c_image = CombineToImage(out_img1, h, w, ch_out, part)\n        cv2.imwrite(out_image_name, c_image)",
            "def infer_image(model_name, model_weight, target_image, out_image_name, block_size=(256, 256), batch_size=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    json_file = open(model_name, 'r')\n    loaded_model_json = json_file.read()\n    json_file.close()\n    model = model_from_json(loaded_model_json, custom_objects={'relu6': tf.nn.relu6})\n    model.summary()\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    model.load_weights(model_weight)\n    M = block_size[0]\n    N = block_size[1]\n    part = 8\n    in_clr = cv2.imread(target_image, 1)\n    in1_image = cv2.cvtColor(in_clr, cv2.COLOR_BGR2RGB)\n    in1_img = GetOverlappingBlocks(in1_image.copy(), M, N, part)\n    prepared_data_blocks = prepare_data_blocks(in1_img, M)\n    in1_img = []\n    out_img1 = model.predict(tf.convert_to_tensor(prepared_data_blocks), batch_size=batch_size)\n    (num_img, ht, wd, ch_out) = out_img1.shape\n    (h, w, ch) = in_clr.shape\n    if ch_out > 1:\n        c_image = cv2.cvtColor(CombineToImage(out_img1, h, w, ch_out), cv2.COLOR_RGB2BGR, part)\n        cv2.imwrite(out_image_name, c_image)\n    else:\n        c_image = CombineToImage(out_img1, h, w, ch_out, part)\n        cv2.imwrite(out_image_name, c_image)",
            "def infer_image(model_name, model_weight, target_image, out_image_name, block_size=(256, 256), batch_size=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    json_file = open(model_name, 'r')\n    loaded_model_json = json_file.read()\n    json_file.close()\n    model = model_from_json(loaded_model_json, custom_objects={'relu6': tf.nn.relu6})\n    model.summary()\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    model.load_weights(model_weight)\n    M = block_size[0]\n    N = block_size[1]\n    part = 8\n    in_clr = cv2.imread(target_image, 1)\n    in1_image = cv2.cvtColor(in_clr, cv2.COLOR_BGR2RGB)\n    in1_img = GetOverlappingBlocks(in1_image.copy(), M, N, part)\n    prepared_data_blocks = prepare_data_blocks(in1_img, M)\n    in1_img = []\n    out_img1 = model.predict(tf.convert_to_tensor(prepared_data_blocks), batch_size=batch_size)\n    (num_img, ht, wd, ch_out) = out_img1.shape\n    (h, w, ch) = in_clr.shape\n    if ch_out > 1:\n        c_image = cv2.cvtColor(CombineToImage(out_img1, h, w, ch_out), cv2.COLOR_RGB2BGR, part)\n        cv2.imwrite(out_image_name, c_image)\n    else:\n        c_image = CombineToImage(out_img1, h, w, ch_out, part)\n        cv2.imwrite(out_image_name, c_image)",
            "def infer_image(model_name, model_weight, target_image, out_image_name, block_size=(256, 256), batch_size=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    json_file = open(model_name, 'r')\n    loaded_model_json = json_file.read()\n    json_file.close()\n    model = model_from_json(loaded_model_json, custom_objects={'relu6': tf.nn.relu6})\n    model.summary()\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    model.load_weights(model_weight)\n    M = block_size[0]\n    N = block_size[1]\n    part = 8\n    in_clr = cv2.imread(target_image, 1)\n    in1_image = cv2.cvtColor(in_clr, cv2.COLOR_BGR2RGB)\n    in1_img = GetOverlappingBlocks(in1_image.copy(), M, N, part)\n    prepared_data_blocks = prepare_data_blocks(in1_img, M)\n    in1_img = []\n    out_img1 = model.predict(tf.convert_to_tensor(prepared_data_blocks), batch_size=batch_size)\n    (num_img, ht, wd, ch_out) = out_img1.shape\n    (h, w, ch) = in_clr.shape\n    if ch_out > 1:\n        c_image = cv2.cvtColor(CombineToImage(out_img1, h, w, ch_out), cv2.COLOR_RGB2BGR, part)\n        cv2.imwrite(out_image_name, c_image)\n    else:\n        c_image = CombineToImage(out_img1, h, w, ch_out, part)\n        cv2.imwrite(out_image_name, c_image)"
        ]
    }
]