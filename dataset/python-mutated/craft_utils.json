[
    {
        "func_name": "warpCoord",
        "original": "def warpCoord(Minv, pt):\n    out = np.matmul(Minv, (pt[0], pt[1], 1))\n    return np.array([out[0] / out[2], out[1] / out[2]])",
        "mutated": [
            "def warpCoord(Minv, pt):\n    if False:\n        i = 10\n    out = np.matmul(Minv, (pt[0], pt[1], 1))\n    return np.array([out[0] / out[2], out[1] / out[2]])",
            "def warpCoord(Minv, pt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    out = np.matmul(Minv, (pt[0], pt[1], 1))\n    return np.array([out[0] / out[2], out[1] / out[2]])",
            "def warpCoord(Minv, pt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    out = np.matmul(Minv, (pt[0], pt[1], 1))\n    return np.array([out[0] / out[2], out[1] / out[2]])",
            "def warpCoord(Minv, pt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    out = np.matmul(Minv, (pt[0], pt[1], 1))\n    return np.array([out[0] / out[2], out[1] / out[2]])",
            "def warpCoord(Minv, pt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    out = np.matmul(Minv, (pt[0], pt[1], 1))\n    return np.array([out[0] / out[2], out[1] / out[2]])"
        ]
    },
    {
        "func_name": "getDetBoxes_core",
        "original": "def getDetBoxes_core(textmap, linkmap, text_threshold, link_threshold, low_text, estimate_num_chars=False):\n    linkmap = linkmap.copy()\n    textmap = textmap.copy()\n    (img_h, img_w) = textmap.shape\n    ' labeling method '\n    (ret, text_score) = cv2.threshold(textmap, low_text, 1, 0)\n    (ret, link_score) = cv2.threshold(linkmap, link_threshold, 1, 0)\n    text_score_comb = np.clip(text_score + link_score, 0, 1)\n    (nLabels, labels, stats, centroids) = cv2.connectedComponentsWithStats(text_score_comb.astype(np.uint8), connectivity=4)\n    det = []\n    mapper = []\n    for k in range(1, nLabels):\n        size = stats[k, cv2.CC_STAT_AREA]\n        if size < 10:\n            continue\n        if np.max(textmap[labels == k]) < text_threshold:\n            continue\n        segmap = np.zeros(textmap.shape, dtype=np.uint8)\n        segmap[labels == k] = 255\n        if estimate_num_chars:\n            (_, character_locs) = cv2.threshold((textmap - linkmap) * segmap / 255.0, text_threshold, 1, 0)\n            (_, n_chars) = label(character_locs)\n            mapper.append(n_chars)\n        else:\n            mapper.append(k)\n        segmap[np.logical_and(link_score == 1, text_score == 0)] = 0\n        (x, y) = (stats[k, cv2.CC_STAT_LEFT], stats[k, cv2.CC_STAT_TOP])\n        (w, h) = (stats[k, cv2.CC_STAT_WIDTH], stats[k, cv2.CC_STAT_HEIGHT])\n        niter = int(math.sqrt(size * min(w, h) / (w * h)) * 2)\n        (sx, ex, sy, ey) = (x - niter, x + w + niter + 1, y - niter, y + h + niter + 1)\n        if sx < 0:\n            sx = 0\n        if sy < 0:\n            sy = 0\n        if ex >= img_w:\n            ex = img_w\n        if ey >= img_h:\n            ey = img_h\n        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1 + niter, 1 + niter))\n        segmap[sy:ey, sx:ex] = cv2.dilate(segmap[sy:ey, sx:ex], kernel)\n        np_contours = np.roll(np.array(np.where(segmap != 0)), 1, axis=0).transpose().reshape(-1, 2)\n        rectangle = cv2.minAreaRect(np_contours)\n        box = cv2.boxPoints(rectangle)\n        (w, h) = (np.linalg.norm(box[0] - box[1]), np.linalg.norm(box[1] - box[2]))\n        box_ratio = max(w, h) / (min(w, h) + 1e-05)\n        if abs(1 - box_ratio) <= 0.1:\n            (l, r) = (min(np_contours[:, 0]), max(np_contours[:, 0]))\n            (t, b) = (min(np_contours[:, 1]), max(np_contours[:, 1]))\n            box = np.array([[l, t], [r, t], [r, b], [l, b]], dtype=np.float32)\n        startidx = box.sum(axis=1).argmin()\n        box = np.roll(box, 4 - startidx, 0)\n        box = np.array(box)\n        det.append(box)\n    return (det, labels, mapper)",
        "mutated": [
            "def getDetBoxes_core(textmap, linkmap, text_threshold, link_threshold, low_text, estimate_num_chars=False):\n    if False:\n        i = 10\n    linkmap = linkmap.copy()\n    textmap = textmap.copy()\n    (img_h, img_w) = textmap.shape\n    ' labeling method '\n    (ret, text_score) = cv2.threshold(textmap, low_text, 1, 0)\n    (ret, link_score) = cv2.threshold(linkmap, link_threshold, 1, 0)\n    text_score_comb = np.clip(text_score + link_score, 0, 1)\n    (nLabels, labels, stats, centroids) = cv2.connectedComponentsWithStats(text_score_comb.astype(np.uint8), connectivity=4)\n    det = []\n    mapper = []\n    for k in range(1, nLabels):\n        size = stats[k, cv2.CC_STAT_AREA]\n        if size < 10:\n            continue\n        if np.max(textmap[labels == k]) < text_threshold:\n            continue\n        segmap = np.zeros(textmap.shape, dtype=np.uint8)\n        segmap[labels == k] = 255\n        if estimate_num_chars:\n            (_, character_locs) = cv2.threshold((textmap - linkmap) * segmap / 255.0, text_threshold, 1, 0)\n            (_, n_chars) = label(character_locs)\n            mapper.append(n_chars)\n        else:\n            mapper.append(k)\n        segmap[np.logical_and(link_score == 1, text_score == 0)] = 0\n        (x, y) = (stats[k, cv2.CC_STAT_LEFT], stats[k, cv2.CC_STAT_TOP])\n        (w, h) = (stats[k, cv2.CC_STAT_WIDTH], stats[k, cv2.CC_STAT_HEIGHT])\n        niter = int(math.sqrt(size * min(w, h) / (w * h)) * 2)\n        (sx, ex, sy, ey) = (x - niter, x + w + niter + 1, y - niter, y + h + niter + 1)\n        if sx < 0:\n            sx = 0\n        if sy < 0:\n            sy = 0\n        if ex >= img_w:\n            ex = img_w\n        if ey >= img_h:\n            ey = img_h\n        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1 + niter, 1 + niter))\n        segmap[sy:ey, sx:ex] = cv2.dilate(segmap[sy:ey, sx:ex], kernel)\n        np_contours = np.roll(np.array(np.where(segmap != 0)), 1, axis=0).transpose().reshape(-1, 2)\n        rectangle = cv2.minAreaRect(np_contours)\n        box = cv2.boxPoints(rectangle)\n        (w, h) = (np.linalg.norm(box[0] - box[1]), np.linalg.norm(box[1] - box[2]))\n        box_ratio = max(w, h) / (min(w, h) + 1e-05)\n        if abs(1 - box_ratio) <= 0.1:\n            (l, r) = (min(np_contours[:, 0]), max(np_contours[:, 0]))\n            (t, b) = (min(np_contours[:, 1]), max(np_contours[:, 1]))\n            box = np.array([[l, t], [r, t], [r, b], [l, b]], dtype=np.float32)\n        startidx = box.sum(axis=1).argmin()\n        box = np.roll(box, 4 - startidx, 0)\n        box = np.array(box)\n        det.append(box)\n    return (det, labels, mapper)",
            "def getDetBoxes_core(textmap, linkmap, text_threshold, link_threshold, low_text, estimate_num_chars=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    linkmap = linkmap.copy()\n    textmap = textmap.copy()\n    (img_h, img_w) = textmap.shape\n    ' labeling method '\n    (ret, text_score) = cv2.threshold(textmap, low_text, 1, 0)\n    (ret, link_score) = cv2.threshold(linkmap, link_threshold, 1, 0)\n    text_score_comb = np.clip(text_score + link_score, 0, 1)\n    (nLabels, labels, stats, centroids) = cv2.connectedComponentsWithStats(text_score_comb.astype(np.uint8), connectivity=4)\n    det = []\n    mapper = []\n    for k in range(1, nLabels):\n        size = stats[k, cv2.CC_STAT_AREA]\n        if size < 10:\n            continue\n        if np.max(textmap[labels == k]) < text_threshold:\n            continue\n        segmap = np.zeros(textmap.shape, dtype=np.uint8)\n        segmap[labels == k] = 255\n        if estimate_num_chars:\n            (_, character_locs) = cv2.threshold((textmap - linkmap) * segmap / 255.0, text_threshold, 1, 0)\n            (_, n_chars) = label(character_locs)\n            mapper.append(n_chars)\n        else:\n            mapper.append(k)\n        segmap[np.logical_and(link_score == 1, text_score == 0)] = 0\n        (x, y) = (stats[k, cv2.CC_STAT_LEFT], stats[k, cv2.CC_STAT_TOP])\n        (w, h) = (stats[k, cv2.CC_STAT_WIDTH], stats[k, cv2.CC_STAT_HEIGHT])\n        niter = int(math.sqrt(size * min(w, h) / (w * h)) * 2)\n        (sx, ex, sy, ey) = (x - niter, x + w + niter + 1, y - niter, y + h + niter + 1)\n        if sx < 0:\n            sx = 0\n        if sy < 0:\n            sy = 0\n        if ex >= img_w:\n            ex = img_w\n        if ey >= img_h:\n            ey = img_h\n        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1 + niter, 1 + niter))\n        segmap[sy:ey, sx:ex] = cv2.dilate(segmap[sy:ey, sx:ex], kernel)\n        np_contours = np.roll(np.array(np.where(segmap != 0)), 1, axis=0).transpose().reshape(-1, 2)\n        rectangle = cv2.minAreaRect(np_contours)\n        box = cv2.boxPoints(rectangle)\n        (w, h) = (np.linalg.norm(box[0] - box[1]), np.linalg.norm(box[1] - box[2]))\n        box_ratio = max(w, h) / (min(w, h) + 1e-05)\n        if abs(1 - box_ratio) <= 0.1:\n            (l, r) = (min(np_contours[:, 0]), max(np_contours[:, 0]))\n            (t, b) = (min(np_contours[:, 1]), max(np_contours[:, 1]))\n            box = np.array([[l, t], [r, t], [r, b], [l, b]], dtype=np.float32)\n        startidx = box.sum(axis=1).argmin()\n        box = np.roll(box, 4 - startidx, 0)\n        box = np.array(box)\n        det.append(box)\n    return (det, labels, mapper)",
            "def getDetBoxes_core(textmap, linkmap, text_threshold, link_threshold, low_text, estimate_num_chars=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    linkmap = linkmap.copy()\n    textmap = textmap.copy()\n    (img_h, img_w) = textmap.shape\n    ' labeling method '\n    (ret, text_score) = cv2.threshold(textmap, low_text, 1, 0)\n    (ret, link_score) = cv2.threshold(linkmap, link_threshold, 1, 0)\n    text_score_comb = np.clip(text_score + link_score, 0, 1)\n    (nLabels, labels, stats, centroids) = cv2.connectedComponentsWithStats(text_score_comb.astype(np.uint8), connectivity=4)\n    det = []\n    mapper = []\n    for k in range(1, nLabels):\n        size = stats[k, cv2.CC_STAT_AREA]\n        if size < 10:\n            continue\n        if np.max(textmap[labels == k]) < text_threshold:\n            continue\n        segmap = np.zeros(textmap.shape, dtype=np.uint8)\n        segmap[labels == k] = 255\n        if estimate_num_chars:\n            (_, character_locs) = cv2.threshold((textmap - linkmap) * segmap / 255.0, text_threshold, 1, 0)\n            (_, n_chars) = label(character_locs)\n            mapper.append(n_chars)\n        else:\n            mapper.append(k)\n        segmap[np.logical_and(link_score == 1, text_score == 0)] = 0\n        (x, y) = (stats[k, cv2.CC_STAT_LEFT], stats[k, cv2.CC_STAT_TOP])\n        (w, h) = (stats[k, cv2.CC_STAT_WIDTH], stats[k, cv2.CC_STAT_HEIGHT])\n        niter = int(math.sqrt(size * min(w, h) / (w * h)) * 2)\n        (sx, ex, sy, ey) = (x - niter, x + w + niter + 1, y - niter, y + h + niter + 1)\n        if sx < 0:\n            sx = 0\n        if sy < 0:\n            sy = 0\n        if ex >= img_w:\n            ex = img_w\n        if ey >= img_h:\n            ey = img_h\n        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1 + niter, 1 + niter))\n        segmap[sy:ey, sx:ex] = cv2.dilate(segmap[sy:ey, sx:ex], kernel)\n        np_contours = np.roll(np.array(np.where(segmap != 0)), 1, axis=0).transpose().reshape(-1, 2)\n        rectangle = cv2.minAreaRect(np_contours)\n        box = cv2.boxPoints(rectangle)\n        (w, h) = (np.linalg.norm(box[0] - box[1]), np.linalg.norm(box[1] - box[2]))\n        box_ratio = max(w, h) / (min(w, h) + 1e-05)\n        if abs(1 - box_ratio) <= 0.1:\n            (l, r) = (min(np_contours[:, 0]), max(np_contours[:, 0]))\n            (t, b) = (min(np_contours[:, 1]), max(np_contours[:, 1]))\n            box = np.array([[l, t], [r, t], [r, b], [l, b]], dtype=np.float32)\n        startidx = box.sum(axis=1).argmin()\n        box = np.roll(box, 4 - startidx, 0)\n        box = np.array(box)\n        det.append(box)\n    return (det, labels, mapper)",
            "def getDetBoxes_core(textmap, linkmap, text_threshold, link_threshold, low_text, estimate_num_chars=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    linkmap = linkmap.copy()\n    textmap = textmap.copy()\n    (img_h, img_w) = textmap.shape\n    ' labeling method '\n    (ret, text_score) = cv2.threshold(textmap, low_text, 1, 0)\n    (ret, link_score) = cv2.threshold(linkmap, link_threshold, 1, 0)\n    text_score_comb = np.clip(text_score + link_score, 0, 1)\n    (nLabels, labels, stats, centroids) = cv2.connectedComponentsWithStats(text_score_comb.astype(np.uint8), connectivity=4)\n    det = []\n    mapper = []\n    for k in range(1, nLabels):\n        size = stats[k, cv2.CC_STAT_AREA]\n        if size < 10:\n            continue\n        if np.max(textmap[labels == k]) < text_threshold:\n            continue\n        segmap = np.zeros(textmap.shape, dtype=np.uint8)\n        segmap[labels == k] = 255\n        if estimate_num_chars:\n            (_, character_locs) = cv2.threshold((textmap - linkmap) * segmap / 255.0, text_threshold, 1, 0)\n            (_, n_chars) = label(character_locs)\n            mapper.append(n_chars)\n        else:\n            mapper.append(k)\n        segmap[np.logical_and(link_score == 1, text_score == 0)] = 0\n        (x, y) = (stats[k, cv2.CC_STAT_LEFT], stats[k, cv2.CC_STAT_TOP])\n        (w, h) = (stats[k, cv2.CC_STAT_WIDTH], stats[k, cv2.CC_STAT_HEIGHT])\n        niter = int(math.sqrt(size * min(w, h) / (w * h)) * 2)\n        (sx, ex, sy, ey) = (x - niter, x + w + niter + 1, y - niter, y + h + niter + 1)\n        if sx < 0:\n            sx = 0\n        if sy < 0:\n            sy = 0\n        if ex >= img_w:\n            ex = img_w\n        if ey >= img_h:\n            ey = img_h\n        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1 + niter, 1 + niter))\n        segmap[sy:ey, sx:ex] = cv2.dilate(segmap[sy:ey, sx:ex], kernel)\n        np_contours = np.roll(np.array(np.where(segmap != 0)), 1, axis=0).transpose().reshape(-1, 2)\n        rectangle = cv2.minAreaRect(np_contours)\n        box = cv2.boxPoints(rectangle)\n        (w, h) = (np.linalg.norm(box[0] - box[1]), np.linalg.norm(box[1] - box[2]))\n        box_ratio = max(w, h) / (min(w, h) + 1e-05)\n        if abs(1 - box_ratio) <= 0.1:\n            (l, r) = (min(np_contours[:, 0]), max(np_contours[:, 0]))\n            (t, b) = (min(np_contours[:, 1]), max(np_contours[:, 1]))\n            box = np.array([[l, t], [r, t], [r, b], [l, b]], dtype=np.float32)\n        startidx = box.sum(axis=1).argmin()\n        box = np.roll(box, 4 - startidx, 0)\n        box = np.array(box)\n        det.append(box)\n    return (det, labels, mapper)",
            "def getDetBoxes_core(textmap, linkmap, text_threshold, link_threshold, low_text, estimate_num_chars=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    linkmap = linkmap.copy()\n    textmap = textmap.copy()\n    (img_h, img_w) = textmap.shape\n    ' labeling method '\n    (ret, text_score) = cv2.threshold(textmap, low_text, 1, 0)\n    (ret, link_score) = cv2.threshold(linkmap, link_threshold, 1, 0)\n    text_score_comb = np.clip(text_score + link_score, 0, 1)\n    (nLabels, labels, stats, centroids) = cv2.connectedComponentsWithStats(text_score_comb.astype(np.uint8), connectivity=4)\n    det = []\n    mapper = []\n    for k in range(1, nLabels):\n        size = stats[k, cv2.CC_STAT_AREA]\n        if size < 10:\n            continue\n        if np.max(textmap[labels == k]) < text_threshold:\n            continue\n        segmap = np.zeros(textmap.shape, dtype=np.uint8)\n        segmap[labels == k] = 255\n        if estimate_num_chars:\n            (_, character_locs) = cv2.threshold((textmap - linkmap) * segmap / 255.0, text_threshold, 1, 0)\n            (_, n_chars) = label(character_locs)\n            mapper.append(n_chars)\n        else:\n            mapper.append(k)\n        segmap[np.logical_and(link_score == 1, text_score == 0)] = 0\n        (x, y) = (stats[k, cv2.CC_STAT_LEFT], stats[k, cv2.CC_STAT_TOP])\n        (w, h) = (stats[k, cv2.CC_STAT_WIDTH], stats[k, cv2.CC_STAT_HEIGHT])\n        niter = int(math.sqrt(size * min(w, h) / (w * h)) * 2)\n        (sx, ex, sy, ey) = (x - niter, x + w + niter + 1, y - niter, y + h + niter + 1)\n        if sx < 0:\n            sx = 0\n        if sy < 0:\n            sy = 0\n        if ex >= img_w:\n            ex = img_w\n        if ey >= img_h:\n            ey = img_h\n        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1 + niter, 1 + niter))\n        segmap[sy:ey, sx:ex] = cv2.dilate(segmap[sy:ey, sx:ex], kernel)\n        np_contours = np.roll(np.array(np.where(segmap != 0)), 1, axis=0).transpose().reshape(-1, 2)\n        rectangle = cv2.minAreaRect(np_contours)\n        box = cv2.boxPoints(rectangle)\n        (w, h) = (np.linalg.norm(box[0] - box[1]), np.linalg.norm(box[1] - box[2]))\n        box_ratio = max(w, h) / (min(w, h) + 1e-05)\n        if abs(1 - box_ratio) <= 0.1:\n            (l, r) = (min(np_contours[:, 0]), max(np_contours[:, 0]))\n            (t, b) = (min(np_contours[:, 1]), max(np_contours[:, 1]))\n            box = np.array([[l, t], [r, t], [r, b], [l, b]], dtype=np.float32)\n        startidx = box.sum(axis=1).argmin()\n        box = np.roll(box, 4 - startidx, 0)\n        box = np.array(box)\n        det.append(box)\n    return (det, labels, mapper)"
        ]
    },
    {
        "func_name": "getPoly_core",
        "original": "def getPoly_core(boxes, labels, mapper, linkmap):\n    num_cp = 5\n    max_len_ratio = 0.7\n    expand_ratio = 1.45\n    max_r = 2.0\n    step_r = 0.2\n    polys = []\n    for (k, box) in enumerate(boxes):\n        (w, h) = (int(np.linalg.norm(box[0] - box[1]) + 1), int(np.linalg.norm(box[1] - box[2]) + 1))\n        if w < 10 or h < 10:\n            polys.append(None)\n            continue\n        tar = np.float32([[0, 0], [w, 0], [w, h], [0, h]])\n        M = cv2.getPerspectiveTransform(box, tar)\n        word_label = cv2.warpPerspective(labels, M, (w, h), flags=cv2.INTER_NEAREST)\n        try:\n            Minv = np.linalg.inv(M)\n        except:\n            polys.append(None)\n            continue\n        cur_label = mapper[k]\n        word_label[word_label != cur_label] = 0\n        word_label[word_label > 0] = 1\n        ' Polygon generation '\n        cp = []\n        max_len = -1\n        for i in range(w):\n            region = np.where(word_label[:, i] != 0)[0]\n            if len(region) < 2:\n                continue\n            cp.append((i, region[0], region[-1]))\n            length = region[-1] - region[0] + 1\n            if length > max_len:\n                max_len = length\n        if h * max_len_ratio < max_len:\n            polys.append(None)\n            continue\n        tot_seg = num_cp * 2 + 1\n        seg_w = w / tot_seg\n        pp = [None] * num_cp\n        cp_section = [[0, 0]] * tot_seg\n        seg_height = [0] * num_cp\n        seg_num = 0\n        num_sec = 0\n        prev_h = -1\n        for i in range(0, len(cp)):\n            (x, sy, ey) = cp[i]\n            if (seg_num + 1) * seg_w <= x and seg_num <= tot_seg:\n                if num_sec == 0:\n                    break\n                cp_section[seg_num] = [cp_section[seg_num][0] / num_sec, cp_section[seg_num][1] / num_sec]\n                num_sec = 0\n                seg_num += 1\n                prev_h = -1\n            cy = (sy + ey) * 0.5\n            cur_h = ey - sy + 1\n            cp_section[seg_num] = [cp_section[seg_num][0] + x, cp_section[seg_num][1] + cy]\n            num_sec += 1\n            if seg_num % 2 == 0:\n                continue\n            if prev_h < cur_h:\n                pp[int((seg_num - 1) / 2)] = (x, cy)\n                seg_height[int((seg_num - 1) / 2)] = cur_h\n                prev_h = cur_h\n        if num_sec != 0:\n            cp_section[-1] = [cp_section[-1][0] / num_sec, cp_section[-1][1] / num_sec]\n        if None in pp or seg_w < np.max(seg_height) * 0.25:\n            polys.append(None)\n            continue\n        half_char_h = np.median(seg_height) * expand_ratio / 2\n        new_pp = []\n        for (i, (x, cy)) in enumerate(pp):\n            dx = cp_section[i * 2 + 2][0] - cp_section[i * 2][0]\n            dy = cp_section[i * 2 + 2][1] - cp_section[i * 2][1]\n            if dx == 0:\n                new_pp.append([x, cy - half_char_h, x, cy + half_char_h])\n                continue\n            rad = -math.atan2(dy, dx)\n            (c, s) = (half_char_h * math.cos(rad), half_char_h * math.sin(rad))\n            new_pp.append([x - s, cy - c, x + s, cy + c])\n        (isSppFound, isEppFound) = (False, False)\n        grad_s = (pp[1][1] - pp[0][1]) / (pp[1][0] - pp[0][0]) + (pp[2][1] - pp[1][1]) / (pp[2][0] - pp[1][0])\n        grad_e = (pp[-2][1] - pp[-1][1]) / (pp[-2][0] - pp[-1][0]) + (pp[-3][1] - pp[-2][1]) / (pp[-3][0] - pp[-2][0])\n        for r in np.arange(0.5, max_r, step_r):\n            dx = 2 * half_char_h * r\n            if not isSppFound:\n                line_img = np.zeros(word_label.shape, dtype=np.uint8)\n                dy = grad_s * dx\n                p = np.array(new_pp[0]) - np.array([dx, dy, dx, dy])\n                cv2.line(line_img, (int(p[0]), int(p[1])), (int(p[2]), int(p[3])), 1, thickness=1)\n                if np.sum(np.logical_and(word_label, line_img)) == 0 or r + 2 * step_r >= max_r:\n                    spp = p\n                    isSppFound = True\n            if not isEppFound:\n                line_img = np.zeros(word_label.shape, dtype=np.uint8)\n                dy = grad_e * dx\n                p = np.array(new_pp[-1]) + np.array([dx, dy, dx, dy])\n                cv2.line(line_img, (int(p[0]), int(p[1])), (int(p[2]), int(p[3])), 1, thickness=1)\n                if np.sum(np.logical_and(word_label, line_img)) == 0 or r + 2 * step_r >= max_r:\n                    epp = p\n                    isEppFound = True\n            if isSppFound and isEppFound:\n                break\n        if not (isSppFound and isEppFound):\n            polys.append(None)\n            continue\n        poly = []\n        poly.append(warpCoord(Minv, (spp[0], spp[1])))\n        for p in new_pp:\n            poly.append(warpCoord(Minv, (p[0], p[1])))\n        poly.append(warpCoord(Minv, (epp[0], epp[1])))\n        poly.append(warpCoord(Minv, (epp[2], epp[3])))\n        for p in reversed(new_pp):\n            poly.append(warpCoord(Minv, (p[2], p[3])))\n        poly.append(warpCoord(Minv, (spp[2], spp[3])))\n        polys.append(np.array(poly))\n    return polys",
        "mutated": [
            "def getPoly_core(boxes, labels, mapper, linkmap):\n    if False:\n        i = 10\n    num_cp = 5\n    max_len_ratio = 0.7\n    expand_ratio = 1.45\n    max_r = 2.0\n    step_r = 0.2\n    polys = []\n    for (k, box) in enumerate(boxes):\n        (w, h) = (int(np.linalg.norm(box[0] - box[1]) + 1), int(np.linalg.norm(box[1] - box[2]) + 1))\n        if w < 10 or h < 10:\n            polys.append(None)\n            continue\n        tar = np.float32([[0, 0], [w, 0], [w, h], [0, h]])\n        M = cv2.getPerspectiveTransform(box, tar)\n        word_label = cv2.warpPerspective(labels, M, (w, h), flags=cv2.INTER_NEAREST)\n        try:\n            Minv = np.linalg.inv(M)\n        except:\n            polys.append(None)\n            continue\n        cur_label = mapper[k]\n        word_label[word_label != cur_label] = 0\n        word_label[word_label > 0] = 1\n        ' Polygon generation '\n        cp = []\n        max_len = -1\n        for i in range(w):\n            region = np.where(word_label[:, i] != 0)[0]\n            if len(region) < 2:\n                continue\n            cp.append((i, region[0], region[-1]))\n            length = region[-1] - region[0] + 1\n            if length > max_len:\n                max_len = length\n        if h * max_len_ratio < max_len:\n            polys.append(None)\n            continue\n        tot_seg = num_cp * 2 + 1\n        seg_w = w / tot_seg\n        pp = [None] * num_cp\n        cp_section = [[0, 0]] * tot_seg\n        seg_height = [0] * num_cp\n        seg_num = 0\n        num_sec = 0\n        prev_h = -1\n        for i in range(0, len(cp)):\n            (x, sy, ey) = cp[i]\n            if (seg_num + 1) * seg_w <= x and seg_num <= tot_seg:\n                if num_sec == 0:\n                    break\n                cp_section[seg_num] = [cp_section[seg_num][0] / num_sec, cp_section[seg_num][1] / num_sec]\n                num_sec = 0\n                seg_num += 1\n                prev_h = -1\n            cy = (sy + ey) * 0.5\n            cur_h = ey - sy + 1\n            cp_section[seg_num] = [cp_section[seg_num][0] + x, cp_section[seg_num][1] + cy]\n            num_sec += 1\n            if seg_num % 2 == 0:\n                continue\n            if prev_h < cur_h:\n                pp[int((seg_num - 1) / 2)] = (x, cy)\n                seg_height[int((seg_num - 1) / 2)] = cur_h\n                prev_h = cur_h\n        if num_sec != 0:\n            cp_section[-1] = [cp_section[-1][0] / num_sec, cp_section[-1][1] / num_sec]\n        if None in pp or seg_w < np.max(seg_height) * 0.25:\n            polys.append(None)\n            continue\n        half_char_h = np.median(seg_height) * expand_ratio / 2\n        new_pp = []\n        for (i, (x, cy)) in enumerate(pp):\n            dx = cp_section[i * 2 + 2][0] - cp_section[i * 2][0]\n            dy = cp_section[i * 2 + 2][1] - cp_section[i * 2][1]\n            if dx == 0:\n                new_pp.append([x, cy - half_char_h, x, cy + half_char_h])\n                continue\n            rad = -math.atan2(dy, dx)\n            (c, s) = (half_char_h * math.cos(rad), half_char_h * math.sin(rad))\n            new_pp.append([x - s, cy - c, x + s, cy + c])\n        (isSppFound, isEppFound) = (False, False)\n        grad_s = (pp[1][1] - pp[0][1]) / (pp[1][0] - pp[0][0]) + (pp[2][1] - pp[1][1]) / (pp[2][0] - pp[1][0])\n        grad_e = (pp[-2][1] - pp[-1][1]) / (pp[-2][0] - pp[-1][0]) + (pp[-3][1] - pp[-2][1]) / (pp[-3][0] - pp[-2][0])\n        for r in np.arange(0.5, max_r, step_r):\n            dx = 2 * half_char_h * r\n            if not isSppFound:\n                line_img = np.zeros(word_label.shape, dtype=np.uint8)\n                dy = grad_s * dx\n                p = np.array(new_pp[0]) - np.array([dx, dy, dx, dy])\n                cv2.line(line_img, (int(p[0]), int(p[1])), (int(p[2]), int(p[3])), 1, thickness=1)\n                if np.sum(np.logical_and(word_label, line_img)) == 0 or r + 2 * step_r >= max_r:\n                    spp = p\n                    isSppFound = True\n            if not isEppFound:\n                line_img = np.zeros(word_label.shape, dtype=np.uint8)\n                dy = grad_e * dx\n                p = np.array(new_pp[-1]) + np.array([dx, dy, dx, dy])\n                cv2.line(line_img, (int(p[0]), int(p[1])), (int(p[2]), int(p[3])), 1, thickness=1)\n                if np.sum(np.logical_and(word_label, line_img)) == 0 or r + 2 * step_r >= max_r:\n                    epp = p\n                    isEppFound = True\n            if isSppFound and isEppFound:\n                break\n        if not (isSppFound and isEppFound):\n            polys.append(None)\n            continue\n        poly = []\n        poly.append(warpCoord(Minv, (spp[0], spp[1])))\n        for p in new_pp:\n            poly.append(warpCoord(Minv, (p[0], p[1])))\n        poly.append(warpCoord(Minv, (epp[0], epp[1])))\n        poly.append(warpCoord(Minv, (epp[2], epp[3])))\n        for p in reversed(new_pp):\n            poly.append(warpCoord(Minv, (p[2], p[3])))\n        poly.append(warpCoord(Minv, (spp[2], spp[3])))\n        polys.append(np.array(poly))\n    return polys",
            "def getPoly_core(boxes, labels, mapper, linkmap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    num_cp = 5\n    max_len_ratio = 0.7\n    expand_ratio = 1.45\n    max_r = 2.0\n    step_r = 0.2\n    polys = []\n    for (k, box) in enumerate(boxes):\n        (w, h) = (int(np.linalg.norm(box[0] - box[1]) + 1), int(np.linalg.norm(box[1] - box[2]) + 1))\n        if w < 10 or h < 10:\n            polys.append(None)\n            continue\n        tar = np.float32([[0, 0], [w, 0], [w, h], [0, h]])\n        M = cv2.getPerspectiveTransform(box, tar)\n        word_label = cv2.warpPerspective(labels, M, (w, h), flags=cv2.INTER_NEAREST)\n        try:\n            Minv = np.linalg.inv(M)\n        except:\n            polys.append(None)\n            continue\n        cur_label = mapper[k]\n        word_label[word_label != cur_label] = 0\n        word_label[word_label > 0] = 1\n        ' Polygon generation '\n        cp = []\n        max_len = -1\n        for i in range(w):\n            region = np.where(word_label[:, i] != 0)[0]\n            if len(region) < 2:\n                continue\n            cp.append((i, region[0], region[-1]))\n            length = region[-1] - region[0] + 1\n            if length > max_len:\n                max_len = length\n        if h * max_len_ratio < max_len:\n            polys.append(None)\n            continue\n        tot_seg = num_cp * 2 + 1\n        seg_w = w / tot_seg\n        pp = [None] * num_cp\n        cp_section = [[0, 0]] * tot_seg\n        seg_height = [0] * num_cp\n        seg_num = 0\n        num_sec = 0\n        prev_h = -1\n        for i in range(0, len(cp)):\n            (x, sy, ey) = cp[i]\n            if (seg_num + 1) * seg_w <= x and seg_num <= tot_seg:\n                if num_sec == 0:\n                    break\n                cp_section[seg_num] = [cp_section[seg_num][0] / num_sec, cp_section[seg_num][1] / num_sec]\n                num_sec = 0\n                seg_num += 1\n                prev_h = -1\n            cy = (sy + ey) * 0.5\n            cur_h = ey - sy + 1\n            cp_section[seg_num] = [cp_section[seg_num][0] + x, cp_section[seg_num][1] + cy]\n            num_sec += 1\n            if seg_num % 2 == 0:\n                continue\n            if prev_h < cur_h:\n                pp[int((seg_num - 1) / 2)] = (x, cy)\n                seg_height[int((seg_num - 1) / 2)] = cur_h\n                prev_h = cur_h\n        if num_sec != 0:\n            cp_section[-1] = [cp_section[-1][0] / num_sec, cp_section[-1][1] / num_sec]\n        if None in pp or seg_w < np.max(seg_height) * 0.25:\n            polys.append(None)\n            continue\n        half_char_h = np.median(seg_height) * expand_ratio / 2\n        new_pp = []\n        for (i, (x, cy)) in enumerate(pp):\n            dx = cp_section[i * 2 + 2][0] - cp_section[i * 2][0]\n            dy = cp_section[i * 2 + 2][1] - cp_section[i * 2][1]\n            if dx == 0:\n                new_pp.append([x, cy - half_char_h, x, cy + half_char_h])\n                continue\n            rad = -math.atan2(dy, dx)\n            (c, s) = (half_char_h * math.cos(rad), half_char_h * math.sin(rad))\n            new_pp.append([x - s, cy - c, x + s, cy + c])\n        (isSppFound, isEppFound) = (False, False)\n        grad_s = (pp[1][1] - pp[0][1]) / (pp[1][0] - pp[0][0]) + (pp[2][1] - pp[1][1]) / (pp[2][0] - pp[1][0])\n        grad_e = (pp[-2][1] - pp[-1][1]) / (pp[-2][0] - pp[-1][0]) + (pp[-3][1] - pp[-2][1]) / (pp[-3][0] - pp[-2][0])\n        for r in np.arange(0.5, max_r, step_r):\n            dx = 2 * half_char_h * r\n            if not isSppFound:\n                line_img = np.zeros(word_label.shape, dtype=np.uint8)\n                dy = grad_s * dx\n                p = np.array(new_pp[0]) - np.array([dx, dy, dx, dy])\n                cv2.line(line_img, (int(p[0]), int(p[1])), (int(p[2]), int(p[3])), 1, thickness=1)\n                if np.sum(np.logical_and(word_label, line_img)) == 0 or r + 2 * step_r >= max_r:\n                    spp = p\n                    isSppFound = True\n            if not isEppFound:\n                line_img = np.zeros(word_label.shape, dtype=np.uint8)\n                dy = grad_e * dx\n                p = np.array(new_pp[-1]) + np.array([dx, dy, dx, dy])\n                cv2.line(line_img, (int(p[0]), int(p[1])), (int(p[2]), int(p[3])), 1, thickness=1)\n                if np.sum(np.logical_and(word_label, line_img)) == 0 or r + 2 * step_r >= max_r:\n                    epp = p\n                    isEppFound = True\n            if isSppFound and isEppFound:\n                break\n        if not (isSppFound and isEppFound):\n            polys.append(None)\n            continue\n        poly = []\n        poly.append(warpCoord(Minv, (spp[0], spp[1])))\n        for p in new_pp:\n            poly.append(warpCoord(Minv, (p[0], p[1])))\n        poly.append(warpCoord(Minv, (epp[0], epp[1])))\n        poly.append(warpCoord(Minv, (epp[2], epp[3])))\n        for p in reversed(new_pp):\n            poly.append(warpCoord(Minv, (p[2], p[3])))\n        poly.append(warpCoord(Minv, (spp[2], spp[3])))\n        polys.append(np.array(poly))\n    return polys",
            "def getPoly_core(boxes, labels, mapper, linkmap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    num_cp = 5\n    max_len_ratio = 0.7\n    expand_ratio = 1.45\n    max_r = 2.0\n    step_r = 0.2\n    polys = []\n    for (k, box) in enumerate(boxes):\n        (w, h) = (int(np.linalg.norm(box[0] - box[1]) + 1), int(np.linalg.norm(box[1] - box[2]) + 1))\n        if w < 10 or h < 10:\n            polys.append(None)\n            continue\n        tar = np.float32([[0, 0], [w, 0], [w, h], [0, h]])\n        M = cv2.getPerspectiveTransform(box, tar)\n        word_label = cv2.warpPerspective(labels, M, (w, h), flags=cv2.INTER_NEAREST)\n        try:\n            Minv = np.linalg.inv(M)\n        except:\n            polys.append(None)\n            continue\n        cur_label = mapper[k]\n        word_label[word_label != cur_label] = 0\n        word_label[word_label > 0] = 1\n        ' Polygon generation '\n        cp = []\n        max_len = -1\n        for i in range(w):\n            region = np.where(word_label[:, i] != 0)[0]\n            if len(region) < 2:\n                continue\n            cp.append((i, region[0], region[-1]))\n            length = region[-1] - region[0] + 1\n            if length > max_len:\n                max_len = length\n        if h * max_len_ratio < max_len:\n            polys.append(None)\n            continue\n        tot_seg = num_cp * 2 + 1\n        seg_w = w / tot_seg\n        pp = [None] * num_cp\n        cp_section = [[0, 0]] * tot_seg\n        seg_height = [0] * num_cp\n        seg_num = 0\n        num_sec = 0\n        prev_h = -1\n        for i in range(0, len(cp)):\n            (x, sy, ey) = cp[i]\n            if (seg_num + 1) * seg_w <= x and seg_num <= tot_seg:\n                if num_sec == 0:\n                    break\n                cp_section[seg_num] = [cp_section[seg_num][0] / num_sec, cp_section[seg_num][1] / num_sec]\n                num_sec = 0\n                seg_num += 1\n                prev_h = -1\n            cy = (sy + ey) * 0.5\n            cur_h = ey - sy + 1\n            cp_section[seg_num] = [cp_section[seg_num][0] + x, cp_section[seg_num][1] + cy]\n            num_sec += 1\n            if seg_num % 2 == 0:\n                continue\n            if prev_h < cur_h:\n                pp[int((seg_num - 1) / 2)] = (x, cy)\n                seg_height[int((seg_num - 1) / 2)] = cur_h\n                prev_h = cur_h\n        if num_sec != 0:\n            cp_section[-1] = [cp_section[-1][0] / num_sec, cp_section[-1][1] / num_sec]\n        if None in pp or seg_w < np.max(seg_height) * 0.25:\n            polys.append(None)\n            continue\n        half_char_h = np.median(seg_height) * expand_ratio / 2\n        new_pp = []\n        for (i, (x, cy)) in enumerate(pp):\n            dx = cp_section[i * 2 + 2][0] - cp_section[i * 2][0]\n            dy = cp_section[i * 2 + 2][1] - cp_section[i * 2][1]\n            if dx == 0:\n                new_pp.append([x, cy - half_char_h, x, cy + half_char_h])\n                continue\n            rad = -math.atan2(dy, dx)\n            (c, s) = (half_char_h * math.cos(rad), half_char_h * math.sin(rad))\n            new_pp.append([x - s, cy - c, x + s, cy + c])\n        (isSppFound, isEppFound) = (False, False)\n        grad_s = (pp[1][1] - pp[0][1]) / (pp[1][0] - pp[0][0]) + (pp[2][1] - pp[1][1]) / (pp[2][0] - pp[1][0])\n        grad_e = (pp[-2][1] - pp[-1][1]) / (pp[-2][0] - pp[-1][0]) + (pp[-3][1] - pp[-2][1]) / (pp[-3][0] - pp[-2][0])\n        for r in np.arange(0.5, max_r, step_r):\n            dx = 2 * half_char_h * r\n            if not isSppFound:\n                line_img = np.zeros(word_label.shape, dtype=np.uint8)\n                dy = grad_s * dx\n                p = np.array(new_pp[0]) - np.array([dx, dy, dx, dy])\n                cv2.line(line_img, (int(p[0]), int(p[1])), (int(p[2]), int(p[3])), 1, thickness=1)\n                if np.sum(np.logical_and(word_label, line_img)) == 0 or r + 2 * step_r >= max_r:\n                    spp = p\n                    isSppFound = True\n            if not isEppFound:\n                line_img = np.zeros(word_label.shape, dtype=np.uint8)\n                dy = grad_e * dx\n                p = np.array(new_pp[-1]) + np.array([dx, dy, dx, dy])\n                cv2.line(line_img, (int(p[0]), int(p[1])), (int(p[2]), int(p[3])), 1, thickness=1)\n                if np.sum(np.logical_and(word_label, line_img)) == 0 or r + 2 * step_r >= max_r:\n                    epp = p\n                    isEppFound = True\n            if isSppFound and isEppFound:\n                break\n        if not (isSppFound and isEppFound):\n            polys.append(None)\n            continue\n        poly = []\n        poly.append(warpCoord(Minv, (spp[0], spp[1])))\n        for p in new_pp:\n            poly.append(warpCoord(Minv, (p[0], p[1])))\n        poly.append(warpCoord(Minv, (epp[0], epp[1])))\n        poly.append(warpCoord(Minv, (epp[2], epp[3])))\n        for p in reversed(new_pp):\n            poly.append(warpCoord(Minv, (p[2], p[3])))\n        poly.append(warpCoord(Minv, (spp[2], spp[3])))\n        polys.append(np.array(poly))\n    return polys",
            "def getPoly_core(boxes, labels, mapper, linkmap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    num_cp = 5\n    max_len_ratio = 0.7\n    expand_ratio = 1.45\n    max_r = 2.0\n    step_r = 0.2\n    polys = []\n    for (k, box) in enumerate(boxes):\n        (w, h) = (int(np.linalg.norm(box[0] - box[1]) + 1), int(np.linalg.norm(box[1] - box[2]) + 1))\n        if w < 10 or h < 10:\n            polys.append(None)\n            continue\n        tar = np.float32([[0, 0], [w, 0], [w, h], [0, h]])\n        M = cv2.getPerspectiveTransform(box, tar)\n        word_label = cv2.warpPerspective(labels, M, (w, h), flags=cv2.INTER_NEAREST)\n        try:\n            Minv = np.linalg.inv(M)\n        except:\n            polys.append(None)\n            continue\n        cur_label = mapper[k]\n        word_label[word_label != cur_label] = 0\n        word_label[word_label > 0] = 1\n        ' Polygon generation '\n        cp = []\n        max_len = -1\n        for i in range(w):\n            region = np.where(word_label[:, i] != 0)[0]\n            if len(region) < 2:\n                continue\n            cp.append((i, region[0], region[-1]))\n            length = region[-1] - region[0] + 1\n            if length > max_len:\n                max_len = length\n        if h * max_len_ratio < max_len:\n            polys.append(None)\n            continue\n        tot_seg = num_cp * 2 + 1\n        seg_w = w / tot_seg\n        pp = [None] * num_cp\n        cp_section = [[0, 0]] * tot_seg\n        seg_height = [0] * num_cp\n        seg_num = 0\n        num_sec = 0\n        prev_h = -1\n        for i in range(0, len(cp)):\n            (x, sy, ey) = cp[i]\n            if (seg_num + 1) * seg_w <= x and seg_num <= tot_seg:\n                if num_sec == 0:\n                    break\n                cp_section[seg_num] = [cp_section[seg_num][0] / num_sec, cp_section[seg_num][1] / num_sec]\n                num_sec = 0\n                seg_num += 1\n                prev_h = -1\n            cy = (sy + ey) * 0.5\n            cur_h = ey - sy + 1\n            cp_section[seg_num] = [cp_section[seg_num][0] + x, cp_section[seg_num][1] + cy]\n            num_sec += 1\n            if seg_num % 2 == 0:\n                continue\n            if prev_h < cur_h:\n                pp[int((seg_num - 1) / 2)] = (x, cy)\n                seg_height[int((seg_num - 1) / 2)] = cur_h\n                prev_h = cur_h\n        if num_sec != 0:\n            cp_section[-1] = [cp_section[-1][0] / num_sec, cp_section[-1][1] / num_sec]\n        if None in pp or seg_w < np.max(seg_height) * 0.25:\n            polys.append(None)\n            continue\n        half_char_h = np.median(seg_height) * expand_ratio / 2\n        new_pp = []\n        for (i, (x, cy)) in enumerate(pp):\n            dx = cp_section[i * 2 + 2][0] - cp_section[i * 2][0]\n            dy = cp_section[i * 2 + 2][1] - cp_section[i * 2][1]\n            if dx == 0:\n                new_pp.append([x, cy - half_char_h, x, cy + half_char_h])\n                continue\n            rad = -math.atan2(dy, dx)\n            (c, s) = (half_char_h * math.cos(rad), half_char_h * math.sin(rad))\n            new_pp.append([x - s, cy - c, x + s, cy + c])\n        (isSppFound, isEppFound) = (False, False)\n        grad_s = (pp[1][1] - pp[0][1]) / (pp[1][0] - pp[0][0]) + (pp[2][1] - pp[1][1]) / (pp[2][0] - pp[1][0])\n        grad_e = (pp[-2][1] - pp[-1][1]) / (pp[-2][0] - pp[-1][0]) + (pp[-3][1] - pp[-2][1]) / (pp[-3][0] - pp[-2][0])\n        for r in np.arange(0.5, max_r, step_r):\n            dx = 2 * half_char_h * r\n            if not isSppFound:\n                line_img = np.zeros(word_label.shape, dtype=np.uint8)\n                dy = grad_s * dx\n                p = np.array(new_pp[0]) - np.array([dx, dy, dx, dy])\n                cv2.line(line_img, (int(p[0]), int(p[1])), (int(p[2]), int(p[3])), 1, thickness=1)\n                if np.sum(np.logical_and(word_label, line_img)) == 0 or r + 2 * step_r >= max_r:\n                    spp = p\n                    isSppFound = True\n            if not isEppFound:\n                line_img = np.zeros(word_label.shape, dtype=np.uint8)\n                dy = grad_e * dx\n                p = np.array(new_pp[-1]) + np.array([dx, dy, dx, dy])\n                cv2.line(line_img, (int(p[0]), int(p[1])), (int(p[2]), int(p[3])), 1, thickness=1)\n                if np.sum(np.logical_and(word_label, line_img)) == 0 or r + 2 * step_r >= max_r:\n                    epp = p\n                    isEppFound = True\n            if isSppFound and isEppFound:\n                break\n        if not (isSppFound and isEppFound):\n            polys.append(None)\n            continue\n        poly = []\n        poly.append(warpCoord(Minv, (spp[0], spp[1])))\n        for p in new_pp:\n            poly.append(warpCoord(Minv, (p[0], p[1])))\n        poly.append(warpCoord(Minv, (epp[0], epp[1])))\n        poly.append(warpCoord(Minv, (epp[2], epp[3])))\n        for p in reversed(new_pp):\n            poly.append(warpCoord(Minv, (p[2], p[3])))\n        poly.append(warpCoord(Minv, (spp[2], spp[3])))\n        polys.append(np.array(poly))\n    return polys",
            "def getPoly_core(boxes, labels, mapper, linkmap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    num_cp = 5\n    max_len_ratio = 0.7\n    expand_ratio = 1.45\n    max_r = 2.0\n    step_r = 0.2\n    polys = []\n    for (k, box) in enumerate(boxes):\n        (w, h) = (int(np.linalg.norm(box[0] - box[1]) + 1), int(np.linalg.norm(box[1] - box[2]) + 1))\n        if w < 10 or h < 10:\n            polys.append(None)\n            continue\n        tar = np.float32([[0, 0], [w, 0], [w, h], [0, h]])\n        M = cv2.getPerspectiveTransform(box, tar)\n        word_label = cv2.warpPerspective(labels, M, (w, h), flags=cv2.INTER_NEAREST)\n        try:\n            Minv = np.linalg.inv(M)\n        except:\n            polys.append(None)\n            continue\n        cur_label = mapper[k]\n        word_label[word_label != cur_label] = 0\n        word_label[word_label > 0] = 1\n        ' Polygon generation '\n        cp = []\n        max_len = -1\n        for i in range(w):\n            region = np.where(word_label[:, i] != 0)[0]\n            if len(region) < 2:\n                continue\n            cp.append((i, region[0], region[-1]))\n            length = region[-1] - region[0] + 1\n            if length > max_len:\n                max_len = length\n        if h * max_len_ratio < max_len:\n            polys.append(None)\n            continue\n        tot_seg = num_cp * 2 + 1\n        seg_w = w / tot_seg\n        pp = [None] * num_cp\n        cp_section = [[0, 0]] * tot_seg\n        seg_height = [0] * num_cp\n        seg_num = 0\n        num_sec = 0\n        prev_h = -1\n        for i in range(0, len(cp)):\n            (x, sy, ey) = cp[i]\n            if (seg_num + 1) * seg_w <= x and seg_num <= tot_seg:\n                if num_sec == 0:\n                    break\n                cp_section[seg_num] = [cp_section[seg_num][0] / num_sec, cp_section[seg_num][1] / num_sec]\n                num_sec = 0\n                seg_num += 1\n                prev_h = -1\n            cy = (sy + ey) * 0.5\n            cur_h = ey - sy + 1\n            cp_section[seg_num] = [cp_section[seg_num][0] + x, cp_section[seg_num][1] + cy]\n            num_sec += 1\n            if seg_num % 2 == 0:\n                continue\n            if prev_h < cur_h:\n                pp[int((seg_num - 1) / 2)] = (x, cy)\n                seg_height[int((seg_num - 1) / 2)] = cur_h\n                prev_h = cur_h\n        if num_sec != 0:\n            cp_section[-1] = [cp_section[-1][0] / num_sec, cp_section[-1][1] / num_sec]\n        if None in pp or seg_w < np.max(seg_height) * 0.25:\n            polys.append(None)\n            continue\n        half_char_h = np.median(seg_height) * expand_ratio / 2\n        new_pp = []\n        for (i, (x, cy)) in enumerate(pp):\n            dx = cp_section[i * 2 + 2][0] - cp_section[i * 2][0]\n            dy = cp_section[i * 2 + 2][1] - cp_section[i * 2][1]\n            if dx == 0:\n                new_pp.append([x, cy - half_char_h, x, cy + half_char_h])\n                continue\n            rad = -math.atan2(dy, dx)\n            (c, s) = (half_char_h * math.cos(rad), half_char_h * math.sin(rad))\n            new_pp.append([x - s, cy - c, x + s, cy + c])\n        (isSppFound, isEppFound) = (False, False)\n        grad_s = (pp[1][1] - pp[0][1]) / (pp[1][0] - pp[0][0]) + (pp[2][1] - pp[1][1]) / (pp[2][0] - pp[1][0])\n        grad_e = (pp[-2][1] - pp[-1][1]) / (pp[-2][0] - pp[-1][0]) + (pp[-3][1] - pp[-2][1]) / (pp[-3][0] - pp[-2][0])\n        for r in np.arange(0.5, max_r, step_r):\n            dx = 2 * half_char_h * r\n            if not isSppFound:\n                line_img = np.zeros(word_label.shape, dtype=np.uint8)\n                dy = grad_s * dx\n                p = np.array(new_pp[0]) - np.array([dx, dy, dx, dy])\n                cv2.line(line_img, (int(p[0]), int(p[1])), (int(p[2]), int(p[3])), 1, thickness=1)\n                if np.sum(np.logical_and(word_label, line_img)) == 0 or r + 2 * step_r >= max_r:\n                    spp = p\n                    isSppFound = True\n            if not isEppFound:\n                line_img = np.zeros(word_label.shape, dtype=np.uint8)\n                dy = grad_e * dx\n                p = np.array(new_pp[-1]) + np.array([dx, dy, dx, dy])\n                cv2.line(line_img, (int(p[0]), int(p[1])), (int(p[2]), int(p[3])), 1, thickness=1)\n                if np.sum(np.logical_and(word_label, line_img)) == 0 or r + 2 * step_r >= max_r:\n                    epp = p\n                    isEppFound = True\n            if isSppFound and isEppFound:\n                break\n        if not (isSppFound and isEppFound):\n            polys.append(None)\n            continue\n        poly = []\n        poly.append(warpCoord(Minv, (spp[0], spp[1])))\n        for p in new_pp:\n            poly.append(warpCoord(Minv, (p[0], p[1])))\n        poly.append(warpCoord(Minv, (epp[0], epp[1])))\n        poly.append(warpCoord(Minv, (epp[2], epp[3])))\n        for p in reversed(new_pp):\n            poly.append(warpCoord(Minv, (p[2], p[3])))\n        poly.append(warpCoord(Minv, (spp[2], spp[3])))\n        polys.append(np.array(poly))\n    return polys"
        ]
    },
    {
        "func_name": "getDetBoxes",
        "original": "def getDetBoxes(textmap, linkmap, text_threshold, link_threshold, low_text, poly=False, estimate_num_chars=False):\n    if poly and estimate_num_chars:\n        raise Exception('Estimating the number of characters not currently supported with poly.')\n    (boxes, labels, mapper) = getDetBoxes_core(textmap, linkmap, text_threshold, link_threshold, low_text, estimate_num_chars)\n    if poly:\n        polys = getPoly_core(boxes, labels, mapper, linkmap)\n    else:\n        polys = [None] * len(boxes)\n    return (boxes, polys, mapper)",
        "mutated": [
            "def getDetBoxes(textmap, linkmap, text_threshold, link_threshold, low_text, poly=False, estimate_num_chars=False):\n    if False:\n        i = 10\n    if poly and estimate_num_chars:\n        raise Exception('Estimating the number of characters not currently supported with poly.')\n    (boxes, labels, mapper) = getDetBoxes_core(textmap, linkmap, text_threshold, link_threshold, low_text, estimate_num_chars)\n    if poly:\n        polys = getPoly_core(boxes, labels, mapper, linkmap)\n    else:\n        polys = [None] * len(boxes)\n    return (boxes, polys, mapper)",
            "def getDetBoxes(textmap, linkmap, text_threshold, link_threshold, low_text, poly=False, estimate_num_chars=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if poly and estimate_num_chars:\n        raise Exception('Estimating the number of characters not currently supported with poly.')\n    (boxes, labels, mapper) = getDetBoxes_core(textmap, linkmap, text_threshold, link_threshold, low_text, estimate_num_chars)\n    if poly:\n        polys = getPoly_core(boxes, labels, mapper, linkmap)\n    else:\n        polys = [None] * len(boxes)\n    return (boxes, polys, mapper)",
            "def getDetBoxes(textmap, linkmap, text_threshold, link_threshold, low_text, poly=False, estimate_num_chars=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if poly and estimate_num_chars:\n        raise Exception('Estimating the number of characters not currently supported with poly.')\n    (boxes, labels, mapper) = getDetBoxes_core(textmap, linkmap, text_threshold, link_threshold, low_text, estimate_num_chars)\n    if poly:\n        polys = getPoly_core(boxes, labels, mapper, linkmap)\n    else:\n        polys = [None] * len(boxes)\n    return (boxes, polys, mapper)",
            "def getDetBoxes(textmap, linkmap, text_threshold, link_threshold, low_text, poly=False, estimate_num_chars=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if poly and estimate_num_chars:\n        raise Exception('Estimating the number of characters not currently supported with poly.')\n    (boxes, labels, mapper) = getDetBoxes_core(textmap, linkmap, text_threshold, link_threshold, low_text, estimate_num_chars)\n    if poly:\n        polys = getPoly_core(boxes, labels, mapper, linkmap)\n    else:\n        polys = [None] * len(boxes)\n    return (boxes, polys, mapper)",
            "def getDetBoxes(textmap, linkmap, text_threshold, link_threshold, low_text, poly=False, estimate_num_chars=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if poly and estimate_num_chars:\n        raise Exception('Estimating the number of characters not currently supported with poly.')\n    (boxes, labels, mapper) = getDetBoxes_core(textmap, linkmap, text_threshold, link_threshold, low_text, estimate_num_chars)\n    if poly:\n        polys = getPoly_core(boxes, labels, mapper, linkmap)\n    else:\n        polys = [None] * len(boxes)\n    return (boxes, polys, mapper)"
        ]
    },
    {
        "func_name": "adjustResultCoordinates",
        "original": "def adjustResultCoordinates(polys, ratio_w, ratio_h, ratio_net=2):\n    if len(polys) > 0:\n        polys = np.array(polys)\n        for k in range(len(polys)):\n            if polys[k] is not None:\n                polys[k] *= (ratio_w * ratio_net, ratio_h * ratio_net)\n    return polys",
        "mutated": [
            "def adjustResultCoordinates(polys, ratio_w, ratio_h, ratio_net=2):\n    if False:\n        i = 10\n    if len(polys) > 0:\n        polys = np.array(polys)\n        for k in range(len(polys)):\n            if polys[k] is not None:\n                polys[k] *= (ratio_w * ratio_net, ratio_h * ratio_net)\n    return polys",
            "def adjustResultCoordinates(polys, ratio_w, ratio_h, ratio_net=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if len(polys) > 0:\n        polys = np.array(polys)\n        for k in range(len(polys)):\n            if polys[k] is not None:\n                polys[k] *= (ratio_w * ratio_net, ratio_h * ratio_net)\n    return polys",
            "def adjustResultCoordinates(polys, ratio_w, ratio_h, ratio_net=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if len(polys) > 0:\n        polys = np.array(polys)\n        for k in range(len(polys)):\n            if polys[k] is not None:\n                polys[k] *= (ratio_w * ratio_net, ratio_h * ratio_net)\n    return polys",
            "def adjustResultCoordinates(polys, ratio_w, ratio_h, ratio_net=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if len(polys) > 0:\n        polys = np.array(polys)\n        for k in range(len(polys)):\n            if polys[k] is not None:\n                polys[k] *= (ratio_w * ratio_net, ratio_h * ratio_net)\n    return polys",
            "def adjustResultCoordinates(polys, ratio_w, ratio_h, ratio_net=2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if len(polys) > 0:\n        polys = np.array(polys)\n        for k in range(len(polys)):\n            if polys[k] is not None:\n                polys[k] *= (ratio_w * ratio_net, ratio_h * ratio_net)\n    return polys"
        ]
    }
]