[
    {
        "func_name": "cyclic_cmd",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, command_name='cyclic')\ndef cyclic_cmd(alphabet, length, lookup, count=100) -> None:\n    if length:\n        length = int(length)\n    else:\n        length = pwndbg.gdblib.arch.ptrsize\n    if lookup:\n        lookup = pwndbg.commands.fix(lookup, sloppy=True)\n        if isinstance(lookup, (gdb.Value, int)):\n            lookup = int(lookup).to_bytes(length, pwndbg.gdblib.arch.endian)\n        elif isinstance(lookup, str):\n            lookup = bytes(lookup, 'utf-8')\n        if len(lookup) != length:\n            print(message.error(f'Lookup pattern must be {length} bytes (use `-n <length>` to lookup pattern of different length)'))\n            return\n        hexstr = '0x' + lookup.hex()\n        print(message.notice(f'Finding cyclic pattern of {length} bytes: {str(lookup)} (hex: {hexstr})'))\n        if any((c not in alphabet for c in lookup)):\n            print(message.error('Pattern contains characters not present in the alphabet'))\n            return\n        offset = cyclic_find(lookup, alphabet, length)\n        if offset == -1:\n            print(message.error('Given lookup pattern does not exist in the sequence'))\n        else:\n            print(message.success(f'Found at offset {offset}'))\n    else:\n        sequence = cyclic(int(count), alphabet, length)\n        print(sequence.decode())",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, command_name='cyclic')\ndef cyclic_cmd(alphabet, length, lookup, count=100) -> None:\n    if False:\n        i = 10\n    if length:\n        length = int(length)\n    else:\n        length = pwndbg.gdblib.arch.ptrsize\n    if lookup:\n        lookup = pwndbg.commands.fix(lookup, sloppy=True)\n        if isinstance(lookup, (gdb.Value, int)):\n            lookup = int(lookup).to_bytes(length, pwndbg.gdblib.arch.endian)\n        elif isinstance(lookup, str):\n            lookup = bytes(lookup, 'utf-8')\n        if len(lookup) != length:\n            print(message.error(f'Lookup pattern must be {length} bytes (use `-n <length>` to lookup pattern of different length)'))\n            return\n        hexstr = '0x' + lookup.hex()\n        print(message.notice(f'Finding cyclic pattern of {length} bytes: {str(lookup)} (hex: {hexstr})'))\n        if any((c not in alphabet for c in lookup)):\n            print(message.error('Pattern contains characters not present in the alphabet'))\n            return\n        offset = cyclic_find(lookup, alphabet, length)\n        if offset == -1:\n            print(message.error('Given lookup pattern does not exist in the sequence'))\n        else:\n            print(message.success(f'Found at offset {offset}'))\n    else:\n        sequence = cyclic(int(count), alphabet, length)\n        print(sequence.decode())",
            "@pwndbg.commands.ArgparsedCommand(parser, command_name='cyclic')\ndef cyclic_cmd(alphabet, length, lookup, count=100) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if length:\n        length = int(length)\n    else:\n        length = pwndbg.gdblib.arch.ptrsize\n    if lookup:\n        lookup = pwndbg.commands.fix(lookup, sloppy=True)\n        if isinstance(lookup, (gdb.Value, int)):\n            lookup = int(lookup).to_bytes(length, pwndbg.gdblib.arch.endian)\n        elif isinstance(lookup, str):\n            lookup = bytes(lookup, 'utf-8')\n        if len(lookup) != length:\n            print(message.error(f'Lookup pattern must be {length} bytes (use `-n <length>` to lookup pattern of different length)'))\n            return\n        hexstr = '0x' + lookup.hex()\n        print(message.notice(f'Finding cyclic pattern of {length} bytes: {str(lookup)} (hex: {hexstr})'))\n        if any((c not in alphabet for c in lookup)):\n            print(message.error('Pattern contains characters not present in the alphabet'))\n            return\n        offset = cyclic_find(lookup, alphabet, length)\n        if offset == -1:\n            print(message.error('Given lookup pattern does not exist in the sequence'))\n        else:\n            print(message.success(f'Found at offset {offset}'))\n    else:\n        sequence = cyclic(int(count), alphabet, length)\n        print(sequence.decode())",
            "@pwndbg.commands.ArgparsedCommand(parser, command_name='cyclic')\ndef cyclic_cmd(alphabet, length, lookup, count=100) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if length:\n        length = int(length)\n    else:\n        length = pwndbg.gdblib.arch.ptrsize\n    if lookup:\n        lookup = pwndbg.commands.fix(lookup, sloppy=True)\n        if isinstance(lookup, (gdb.Value, int)):\n            lookup = int(lookup).to_bytes(length, pwndbg.gdblib.arch.endian)\n        elif isinstance(lookup, str):\n            lookup = bytes(lookup, 'utf-8')\n        if len(lookup) != length:\n            print(message.error(f'Lookup pattern must be {length} bytes (use `-n <length>` to lookup pattern of different length)'))\n            return\n        hexstr = '0x' + lookup.hex()\n        print(message.notice(f'Finding cyclic pattern of {length} bytes: {str(lookup)} (hex: {hexstr})'))\n        if any((c not in alphabet for c in lookup)):\n            print(message.error('Pattern contains characters not present in the alphabet'))\n            return\n        offset = cyclic_find(lookup, alphabet, length)\n        if offset == -1:\n            print(message.error('Given lookup pattern does not exist in the sequence'))\n        else:\n            print(message.success(f'Found at offset {offset}'))\n    else:\n        sequence = cyclic(int(count), alphabet, length)\n        print(sequence.decode())",
            "@pwndbg.commands.ArgparsedCommand(parser, command_name='cyclic')\ndef cyclic_cmd(alphabet, length, lookup, count=100) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if length:\n        length = int(length)\n    else:\n        length = pwndbg.gdblib.arch.ptrsize\n    if lookup:\n        lookup = pwndbg.commands.fix(lookup, sloppy=True)\n        if isinstance(lookup, (gdb.Value, int)):\n            lookup = int(lookup).to_bytes(length, pwndbg.gdblib.arch.endian)\n        elif isinstance(lookup, str):\n            lookup = bytes(lookup, 'utf-8')\n        if len(lookup) != length:\n            print(message.error(f'Lookup pattern must be {length} bytes (use `-n <length>` to lookup pattern of different length)'))\n            return\n        hexstr = '0x' + lookup.hex()\n        print(message.notice(f'Finding cyclic pattern of {length} bytes: {str(lookup)} (hex: {hexstr})'))\n        if any((c not in alphabet for c in lookup)):\n            print(message.error('Pattern contains characters not present in the alphabet'))\n            return\n        offset = cyclic_find(lookup, alphabet, length)\n        if offset == -1:\n            print(message.error('Given lookup pattern does not exist in the sequence'))\n        else:\n            print(message.success(f'Found at offset {offset}'))\n    else:\n        sequence = cyclic(int(count), alphabet, length)\n        print(sequence.decode())",
            "@pwndbg.commands.ArgparsedCommand(parser, command_name='cyclic')\ndef cyclic_cmd(alphabet, length, lookup, count=100) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if length:\n        length = int(length)\n    else:\n        length = pwndbg.gdblib.arch.ptrsize\n    if lookup:\n        lookup = pwndbg.commands.fix(lookup, sloppy=True)\n        if isinstance(lookup, (gdb.Value, int)):\n            lookup = int(lookup).to_bytes(length, pwndbg.gdblib.arch.endian)\n        elif isinstance(lookup, str):\n            lookup = bytes(lookup, 'utf-8')\n        if len(lookup) != length:\n            print(message.error(f'Lookup pattern must be {length} bytes (use `-n <length>` to lookup pattern of different length)'))\n            return\n        hexstr = '0x' + lookup.hex()\n        print(message.notice(f'Finding cyclic pattern of {length} bytes: {str(lookup)} (hex: {hexstr})'))\n        if any((c not in alphabet for c in lookup)):\n            print(message.error('Pattern contains characters not present in the alphabet'))\n            return\n        offset = cyclic_find(lookup, alphabet, length)\n        if offset == -1:\n            print(message.error('Given lookup pattern does not exist in the sequence'))\n        else:\n            print(message.success(f'Found at offset {offset}'))\n    else:\n        sequence = cyclic(int(count), alphabet, length)\n        print(sequence.decode())"
        ]
    }
]