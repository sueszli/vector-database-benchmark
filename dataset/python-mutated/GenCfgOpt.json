[
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.index = 0\n    self.string = ''",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.index = 0\n    self.string = ''",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.index = 0\n    self.string = ''",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.index = 0\n    self.string = ''",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.index = 0\n    self.string = ''",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.index = 0\n    self.string = ''"
        ]
    },
    {
        "func_name": "errExit",
        "original": "def errExit(self, err=''):\n    print('ERROR: Express parsing for:')\n    print('       %s' % self.string)\n    print('       %s^' % (' ' * self.index))\n    if err:\n        print('INFO : %s' % err)\n    raise SystemExit",
        "mutated": [
            "def errExit(self, err=''):\n    if False:\n        i = 10\n    print('ERROR: Express parsing for:')\n    print('       %s' % self.string)\n    print('       %s^' % (' ' * self.index))\n    if err:\n        print('INFO : %s' % err)\n    raise SystemExit",
            "def errExit(self, err=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('ERROR: Express parsing for:')\n    print('       %s' % self.string)\n    print('       %s^' % (' ' * self.index))\n    if err:\n        print('INFO : %s' % err)\n    raise SystemExit",
            "def errExit(self, err=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('ERROR: Express parsing for:')\n    print('       %s' % self.string)\n    print('       %s^' % (' ' * self.index))\n    if err:\n        print('INFO : %s' % err)\n    raise SystemExit",
            "def errExit(self, err=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('ERROR: Express parsing for:')\n    print('       %s' % self.string)\n    print('       %s^' % (' ' * self.index))\n    if err:\n        print('INFO : %s' % err)\n    raise SystemExit",
            "def errExit(self, err=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('ERROR: Express parsing for:')\n    print('       %s' % self.string)\n    print('       %s^' % (' ' * self.index))\n    if err:\n        print('INFO : %s' % err)\n    raise SystemExit"
        ]
    },
    {
        "func_name": "getNonNumber",
        "original": "def getNonNumber(self, n1, n2):\n    if not n1.isdigit():\n        return n1\n    if not n2.isdigit():\n        return n2\n    return None",
        "mutated": [
            "def getNonNumber(self, n1, n2):\n    if False:\n        i = 10\n    if not n1.isdigit():\n        return n1\n    if not n2.isdigit():\n        return n2\n    return None",
            "def getNonNumber(self, n1, n2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not n1.isdigit():\n        return n1\n    if not n2.isdigit():\n        return n2\n    return None",
            "def getNonNumber(self, n1, n2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not n1.isdigit():\n        return n1\n    if not n2.isdigit():\n        return n2\n    return None",
            "def getNonNumber(self, n1, n2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not n1.isdigit():\n        return n1\n    if not n2.isdigit():\n        return n2\n    return None",
            "def getNonNumber(self, n1, n2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not n1.isdigit():\n        return n1\n    if not n2.isdigit():\n        return n2\n    return None"
        ]
    },
    {
        "func_name": "getCurr",
        "original": "def getCurr(self, lens=1):\n    try:\n        if lens == -1:\n            return self.string[self.index:]\n        else:\n            if self.index + lens > len(self.string):\n                lens = len(self.string) - self.index\n            return self.string[self.index:self.index + lens]\n    except Exception:\n        return ''",
        "mutated": [
            "def getCurr(self, lens=1):\n    if False:\n        i = 10\n    try:\n        if lens == -1:\n            return self.string[self.index:]\n        else:\n            if self.index + lens > len(self.string):\n                lens = len(self.string) - self.index\n            return self.string[self.index:self.index + lens]\n    except Exception:\n        return ''",
            "def getCurr(self, lens=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        if lens == -1:\n            return self.string[self.index:]\n        else:\n            if self.index + lens > len(self.string):\n                lens = len(self.string) - self.index\n            return self.string[self.index:self.index + lens]\n    except Exception:\n        return ''",
            "def getCurr(self, lens=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        if lens == -1:\n            return self.string[self.index:]\n        else:\n            if self.index + lens > len(self.string):\n                lens = len(self.string) - self.index\n            return self.string[self.index:self.index + lens]\n    except Exception:\n        return ''",
            "def getCurr(self, lens=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        if lens == -1:\n            return self.string[self.index:]\n        else:\n            if self.index + lens > len(self.string):\n                lens = len(self.string) - self.index\n            return self.string[self.index:self.index + lens]\n    except Exception:\n        return ''",
            "def getCurr(self, lens=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        if lens == -1:\n            return self.string[self.index:]\n        else:\n            if self.index + lens > len(self.string):\n                lens = len(self.string) - self.index\n            return self.string[self.index:self.index + lens]\n    except Exception:\n        return ''"
        ]
    },
    {
        "func_name": "isLast",
        "original": "def isLast(self):\n    return self.index == len(self.string)",
        "mutated": [
            "def isLast(self):\n    if False:\n        i = 10\n    return self.index == len(self.string)",
            "def isLast(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.index == len(self.string)",
            "def isLast(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.index == len(self.string)",
            "def isLast(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.index == len(self.string)",
            "def isLast(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.index == len(self.string)"
        ]
    },
    {
        "func_name": "moveNext",
        "original": "def moveNext(self, len=1):\n    self.index += len",
        "mutated": [
            "def moveNext(self, len=1):\n    if False:\n        i = 10\n    self.index += len",
            "def moveNext(self, len=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.index += len",
            "def moveNext(self, len=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.index += len",
            "def moveNext(self, len=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.index += len",
            "def moveNext(self, len=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.index += len"
        ]
    },
    {
        "func_name": "skipSpace",
        "original": "def skipSpace(self):\n    while not self.isLast():\n        if self.getCurr() in ' \\t':\n            self.moveNext()\n        else:\n            return",
        "mutated": [
            "def skipSpace(self):\n    if False:\n        i = 10\n    while not self.isLast():\n        if self.getCurr() in ' \\t':\n            self.moveNext()\n        else:\n            return",
            "def skipSpace(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    while not self.isLast():\n        if self.getCurr() in ' \\t':\n            self.moveNext()\n        else:\n            return",
            "def skipSpace(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    while not self.isLast():\n        if self.getCurr() in ' \\t':\n            self.moveNext()\n        else:\n            return",
            "def skipSpace(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    while not self.isLast():\n        if self.getCurr() in ' \\t':\n            self.moveNext()\n        else:\n            return",
            "def skipSpace(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    while not self.isLast():\n        if self.getCurr() in ' \\t':\n            self.moveNext()\n        else:\n            return"
        ]
    },
    {
        "func_name": "normNumber",
        "original": "def normNumber(self, val):\n    return True if val else False",
        "mutated": [
            "def normNumber(self, val):\n    if False:\n        i = 10\n    return True if val else False",
            "def normNumber(self, val):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return True if val else False",
            "def normNumber(self, val):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return True if val else False",
            "def normNumber(self, val):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return True if val else False",
            "def normNumber(self, val):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return True if val else False"
        ]
    },
    {
        "func_name": "getNumber",
        "original": "def getNumber(self, var):\n    var = var.strip()\n    if re.match('^0x[a-fA-F0-9]+$', var):\n        value = int(var, 16)\n    elif re.match('^[+-]?\\\\d+$', var):\n        value = int(var, 10)\n    else:\n        value = None\n    return value",
        "mutated": [
            "def getNumber(self, var):\n    if False:\n        i = 10\n    var = var.strip()\n    if re.match('^0x[a-fA-F0-9]+$', var):\n        value = int(var, 16)\n    elif re.match('^[+-]?\\\\d+$', var):\n        value = int(var, 10)\n    else:\n        value = None\n    return value",
            "def getNumber(self, var):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    var = var.strip()\n    if re.match('^0x[a-fA-F0-9]+$', var):\n        value = int(var, 16)\n    elif re.match('^[+-]?\\\\d+$', var):\n        value = int(var, 10)\n    else:\n        value = None\n    return value",
            "def getNumber(self, var):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    var = var.strip()\n    if re.match('^0x[a-fA-F0-9]+$', var):\n        value = int(var, 16)\n    elif re.match('^[+-]?\\\\d+$', var):\n        value = int(var, 10)\n    else:\n        value = None\n    return value",
            "def getNumber(self, var):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    var = var.strip()\n    if re.match('^0x[a-fA-F0-9]+$', var):\n        value = int(var, 16)\n    elif re.match('^[+-]?\\\\d+$', var):\n        value = int(var, 10)\n    else:\n        value = None\n    return value",
            "def getNumber(self, var):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    var = var.strip()\n    if re.match('^0x[a-fA-F0-9]+$', var):\n        value = int(var, 16)\n    elif re.match('^[+-]?\\\\d+$', var):\n        value = int(var, 10)\n    else:\n        value = None\n    return value"
        ]
    },
    {
        "func_name": "parseValue",
        "original": "def parseValue(self):\n    self.skipSpace()\n    var = ''\n    while not self.isLast():\n        char = self.getCurr()\n        if re.match('^[\\\\w.]', char):\n            var += char\n            self.moveNext()\n        else:\n            break\n    val = self.getNumber(var)\n    if val is None:\n        value = var\n    else:\n        value = '%d' % val\n    return value",
        "mutated": [
            "def parseValue(self):\n    if False:\n        i = 10\n    self.skipSpace()\n    var = ''\n    while not self.isLast():\n        char = self.getCurr()\n        if re.match('^[\\\\w.]', char):\n            var += char\n            self.moveNext()\n        else:\n            break\n    val = self.getNumber(var)\n    if val is None:\n        value = var\n    else:\n        value = '%d' % val\n    return value",
            "def parseValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.skipSpace()\n    var = ''\n    while not self.isLast():\n        char = self.getCurr()\n        if re.match('^[\\\\w.]', char):\n            var += char\n            self.moveNext()\n        else:\n            break\n    val = self.getNumber(var)\n    if val is None:\n        value = var\n    else:\n        value = '%d' % val\n    return value",
            "def parseValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.skipSpace()\n    var = ''\n    while not self.isLast():\n        char = self.getCurr()\n        if re.match('^[\\\\w.]', char):\n            var += char\n            self.moveNext()\n        else:\n            break\n    val = self.getNumber(var)\n    if val is None:\n        value = var\n    else:\n        value = '%d' % val\n    return value",
            "def parseValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.skipSpace()\n    var = ''\n    while not self.isLast():\n        char = self.getCurr()\n        if re.match('^[\\\\w.]', char):\n            var += char\n            self.moveNext()\n        else:\n            break\n    val = self.getNumber(var)\n    if val is None:\n        value = var\n    else:\n        value = '%d' % val\n    return value",
            "def parseValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.skipSpace()\n    var = ''\n    while not self.isLast():\n        char = self.getCurr()\n        if re.match('^[\\\\w.]', char):\n            var += char\n            self.moveNext()\n        else:\n            break\n    val = self.getNumber(var)\n    if val is None:\n        value = var\n    else:\n        value = '%d' % val\n    return value"
        ]
    },
    {
        "func_name": "parseSingleOp",
        "original": "def parseSingleOp(self):\n    self.skipSpace()\n    if re.match('^NOT\\\\W', self.getCurr(-1)):\n        self.moveNext(3)\n        op = self.parseBrace()\n        val = self.getNumber(op)\n        if val is None:\n            self.errExit(\"'%s' is not a number\" % op)\n        return '%d' % (not self.normNumber(int(op)))\n    else:\n        return self.parseValue()",
        "mutated": [
            "def parseSingleOp(self):\n    if False:\n        i = 10\n    self.skipSpace()\n    if re.match('^NOT\\\\W', self.getCurr(-1)):\n        self.moveNext(3)\n        op = self.parseBrace()\n        val = self.getNumber(op)\n        if val is None:\n            self.errExit(\"'%s' is not a number\" % op)\n        return '%d' % (not self.normNumber(int(op)))\n    else:\n        return self.parseValue()",
            "def parseSingleOp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.skipSpace()\n    if re.match('^NOT\\\\W', self.getCurr(-1)):\n        self.moveNext(3)\n        op = self.parseBrace()\n        val = self.getNumber(op)\n        if val is None:\n            self.errExit(\"'%s' is not a number\" % op)\n        return '%d' % (not self.normNumber(int(op)))\n    else:\n        return self.parseValue()",
            "def parseSingleOp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.skipSpace()\n    if re.match('^NOT\\\\W', self.getCurr(-1)):\n        self.moveNext(3)\n        op = self.parseBrace()\n        val = self.getNumber(op)\n        if val is None:\n            self.errExit(\"'%s' is not a number\" % op)\n        return '%d' % (not self.normNumber(int(op)))\n    else:\n        return self.parseValue()",
            "def parseSingleOp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.skipSpace()\n    if re.match('^NOT\\\\W', self.getCurr(-1)):\n        self.moveNext(3)\n        op = self.parseBrace()\n        val = self.getNumber(op)\n        if val is None:\n            self.errExit(\"'%s' is not a number\" % op)\n        return '%d' % (not self.normNumber(int(op)))\n    else:\n        return self.parseValue()",
            "def parseSingleOp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.skipSpace()\n    if re.match('^NOT\\\\W', self.getCurr(-1)):\n        self.moveNext(3)\n        op = self.parseBrace()\n        val = self.getNumber(op)\n        if val is None:\n            self.errExit(\"'%s' is not a number\" % op)\n        return '%d' % (not self.normNumber(int(op)))\n    else:\n        return self.parseValue()"
        ]
    },
    {
        "func_name": "parseBrace",
        "original": "def parseBrace(self):\n    self.skipSpace()\n    char = self.getCurr()\n    if char == '(':\n        self.moveNext()\n        value = self.parseExpr()\n        self.skipSpace()\n        if self.getCurr() != ')':\n            self.errExit('Expecting closing brace or operator')\n        self.moveNext()\n        return value\n    else:\n        value = self.parseSingleOp()\n        return value",
        "mutated": [
            "def parseBrace(self):\n    if False:\n        i = 10\n    self.skipSpace()\n    char = self.getCurr()\n    if char == '(':\n        self.moveNext()\n        value = self.parseExpr()\n        self.skipSpace()\n        if self.getCurr() != ')':\n            self.errExit('Expecting closing brace or operator')\n        self.moveNext()\n        return value\n    else:\n        value = self.parseSingleOp()\n        return value",
            "def parseBrace(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.skipSpace()\n    char = self.getCurr()\n    if char == '(':\n        self.moveNext()\n        value = self.parseExpr()\n        self.skipSpace()\n        if self.getCurr() != ')':\n            self.errExit('Expecting closing brace or operator')\n        self.moveNext()\n        return value\n    else:\n        value = self.parseSingleOp()\n        return value",
            "def parseBrace(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.skipSpace()\n    char = self.getCurr()\n    if char == '(':\n        self.moveNext()\n        value = self.parseExpr()\n        self.skipSpace()\n        if self.getCurr() != ')':\n            self.errExit('Expecting closing brace or operator')\n        self.moveNext()\n        return value\n    else:\n        value = self.parseSingleOp()\n        return value",
            "def parseBrace(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.skipSpace()\n    char = self.getCurr()\n    if char == '(':\n        self.moveNext()\n        value = self.parseExpr()\n        self.skipSpace()\n        if self.getCurr() != ')':\n            self.errExit('Expecting closing brace or operator')\n        self.moveNext()\n        return value\n    else:\n        value = self.parseSingleOp()\n        return value",
            "def parseBrace(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.skipSpace()\n    char = self.getCurr()\n    if char == '(':\n        self.moveNext()\n        value = self.parseExpr()\n        self.skipSpace()\n        if self.getCurr() != ')':\n            self.errExit('Expecting closing brace or operator')\n        self.moveNext()\n        return value\n    else:\n        value = self.parseSingleOp()\n        return value"
        ]
    },
    {
        "func_name": "parseCompare",
        "original": "def parseCompare(self):\n    value = self.parseBrace()\n    while True:\n        self.skipSpace()\n        char = self.getCurr()\n        if char in ['<', '>']:\n            self.moveNext()\n            next = self.getCurr()\n            if next == '=':\n                op = char + next\n                self.moveNext()\n            else:\n                op = char\n            result = self.parseBrace()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(eval(value + op + result))\n            else:\n                self.errExit(\"'%s' is not a valid number for comparision\" % test)\n        elif char in ['=', '!']:\n            op = self.getCurr(2)\n            if op in ['==', '!=']:\n                self.moveNext(2)\n                result = self.parseBrace()\n                test = self.getNonNumber(result, value)\n                if test is None:\n                    value = '%d' % self.normNumber(eval(value + op + result))\n                else:\n                    value = '%d' % self.normNumber(eval(\"'\" + value + \"'\" + op + \"'\" + result + \"'\"))\n            else:\n                break\n        else:\n            break\n    return value",
        "mutated": [
            "def parseCompare(self):\n    if False:\n        i = 10\n    value = self.parseBrace()\n    while True:\n        self.skipSpace()\n        char = self.getCurr()\n        if char in ['<', '>']:\n            self.moveNext()\n            next = self.getCurr()\n            if next == '=':\n                op = char + next\n                self.moveNext()\n            else:\n                op = char\n            result = self.parseBrace()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(eval(value + op + result))\n            else:\n                self.errExit(\"'%s' is not a valid number for comparision\" % test)\n        elif char in ['=', '!']:\n            op = self.getCurr(2)\n            if op in ['==', '!=']:\n                self.moveNext(2)\n                result = self.parseBrace()\n                test = self.getNonNumber(result, value)\n                if test is None:\n                    value = '%d' % self.normNumber(eval(value + op + result))\n                else:\n                    value = '%d' % self.normNumber(eval(\"'\" + value + \"'\" + op + \"'\" + result + \"'\"))\n            else:\n                break\n        else:\n            break\n    return value",
            "def parseCompare(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    value = self.parseBrace()\n    while True:\n        self.skipSpace()\n        char = self.getCurr()\n        if char in ['<', '>']:\n            self.moveNext()\n            next = self.getCurr()\n            if next == '=':\n                op = char + next\n                self.moveNext()\n            else:\n                op = char\n            result = self.parseBrace()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(eval(value + op + result))\n            else:\n                self.errExit(\"'%s' is not a valid number for comparision\" % test)\n        elif char in ['=', '!']:\n            op = self.getCurr(2)\n            if op in ['==', '!=']:\n                self.moveNext(2)\n                result = self.parseBrace()\n                test = self.getNonNumber(result, value)\n                if test is None:\n                    value = '%d' % self.normNumber(eval(value + op + result))\n                else:\n                    value = '%d' % self.normNumber(eval(\"'\" + value + \"'\" + op + \"'\" + result + \"'\"))\n            else:\n                break\n        else:\n            break\n    return value",
            "def parseCompare(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    value = self.parseBrace()\n    while True:\n        self.skipSpace()\n        char = self.getCurr()\n        if char in ['<', '>']:\n            self.moveNext()\n            next = self.getCurr()\n            if next == '=':\n                op = char + next\n                self.moveNext()\n            else:\n                op = char\n            result = self.parseBrace()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(eval(value + op + result))\n            else:\n                self.errExit(\"'%s' is not a valid number for comparision\" % test)\n        elif char in ['=', '!']:\n            op = self.getCurr(2)\n            if op in ['==', '!=']:\n                self.moveNext(2)\n                result = self.parseBrace()\n                test = self.getNonNumber(result, value)\n                if test is None:\n                    value = '%d' % self.normNumber(eval(value + op + result))\n                else:\n                    value = '%d' % self.normNumber(eval(\"'\" + value + \"'\" + op + \"'\" + result + \"'\"))\n            else:\n                break\n        else:\n            break\n    return value",
            "def parseCompare(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    value = self.parseBrace()\n    while True:\n        self.skipSpace()\n        char = self.getCurr()\n        if char in ['<', '>']:\n            self.moveNext()\n            next = self.getCurr()\n            if next == '=':\n                op = char + next\n                self.moveNext()\n            else:\n                op = char\n            result = self.parseBrace()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(eval(value + op + result))\n            else:\n                self.errExit(\"'%s' is not a valid number for comparision\" % test)\n        elif char in ['=', '!']:\n            op = self.getCurr(2)\n            if op in ['==', '!=']:\n                self.moveNext(2)\n                result = self.parseBrace()\n                test = self.getNonNumber(result, value)\n                if test is None:\n                    value = '%d' % self.normNumber(eval(value + op + result))\n                else:\n                    value = '%d' % self.normNumber(eval(\"'\" + value + \"'\" + op + \"'\" + result + \"'\"))\n            else:\n                break\n        else:\n            break\n    return value",
            "def parseCompare(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    value = self.parseBrace()\n    while True:\n        self.skipSpace()\n        char = self.getCurr()\n        if char in ['<', '>']:\n            self.moveNext()\n            next = self.getCurr()\n            if next == '=':\n                op = char + next\n                self.moveNext()\n            else:\n                op = char\n            result = self.parseBrace()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(eval(value + op + result))\n            else:\n                self.errExit(\"'%s' is not a valid number for comparision\" % test)\n        elif char in ['=', '!']:\n            op = self.getCurr(2)\n            if op in ['==', '!=']:\n                self.moveNext(2)\n                result = self.parseBrace()\n                test = self.getNonNumber(result, value)\n                if test is None:\n                    value = '%d' % self.normNumber(eval(value + op + result))\n                else:\n                    value = '%d' % self.normNumber(eval(\"'\" + value + \"'\" + op + \"'\" + result + \"'\"))\n            else:\n                break\n        else:\n            break\n    return value"
        ]
    },
    {
        "func_name": "parseAnd",
        "original": "def parseAnd(self):\n    value = self.parseCompare()\n    while True:\n        self.skipSpace()\n        if re.match('^AND\\\\W', self.getCurr(-1)):\n            self.moveNext(3)\n            result = self.parseCompare()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(int(value) & int(result))\n            else:\n                self.errExit(\"'%s' is not a valid op number for AND\" % test)\n        else:\n            break\n    return value",
        "mutated": [
            "def parseAnd(self):\n    if False:\n        i = 10\n    value = self.parseCompare()\n    while True:\n        self.skipSpace()\n        if re.match('^AND\\\\W', self.getCurr(-1)):\n            self.moveNext(3)\n            result = self.parseCompare()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(int(value) & int(result))\n            else:\n                self.errExit(\"'%s' is not a valid op number for AND\" % test)\n        else:\n            break\n    return value",
            "def parseAnd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    value = self.parseCompare()\n    while True:\n        self.skipSpace()\n        if re.match('^AND\\\\W', self.getCurr(-1)):\n            self.moveNext(3)\n            result = self.parseCompare()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(int(value) & int(result))\n            else:\n                self.errExit(\"'%s' is not a valid op number for AND\" % test)\n        else:\n            break\n    return value",
            "def parseAnd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    value = self.parseCompare()\n    while True:\n        self.skipSpace()\n        if re.match('^AND\\\\W', self.getCurr(-1)):\n            self.moveNext(3)\n            result = self.parseCompare()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(int(value) & int(result))\n            else:\n                self.errExit(\"'%s' is not a valid op number for AND\" % test)\n        else:\n            break\n    return value",
            "def parseAnd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    value = self.parseCompare()\n    while True:\n        self.skipSpace()\n        if re.match('^AND\\\\W', self.getCurr(-1)):\n            self.moveNext(3)\n            result = self.parseCompare()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(int(value) & int(result))\n            else:\n                self.errExit(\"'%s' is not a valid op number for AND\" % test)\n        else:\n            break\n    return value",
            "def parseAnd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    value = self.parseCompare()\n    while True:\n        self.skipSpace()\n        if re.match('^AND\\\\W', self.getCurr(-1)):\n            self.moveNext(3)\n            result = self.parseCompare()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(int(value) & int(result))\n            else:\n                self.errExit(\"'%s' is not a valid op number for AND\" % test)\n        else:\n            break\n    return value"
        ]
    },
    {
        "func_name": "parseOrXor",
        "original": "def parseOrXor(self):\n    value = self.parseAnd()\n    op = None\n    while True:\n        self.skipSpace()\n        op = None\n        if re.match('^XOR\\\\W', self.getCurr(-1)):\n            self.moveNext(3)\n            op = '^'\n        elif re.match('^OR\\\\W', self.getCurr(-1)):\n            self.moveNext(2)\n            op = '|'\n        else:\n            break\n        if op:\n            result = self.parseAnd()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(eval(value + op + result))\n            else:\n                self.errExit(\"'%s' is not a valid op number for XOR/OR\" % test)\n    return value",
        "mutated": [
            "def parseOrXor(self):\n    if False:\n        i = 10\n    value = self.parseAnd()\n    op = None\n    while True:\n        self.skipSpace()\n        op = None\n        if re.match('^XOR\\\\W', self.getCurr(-1)):\n            self.moveNext(3)\n            op = '^'\n        elif re.match('^OR\\\\W', self.getCurr(-1)):\n            self.moveNext(2)\n            op = '|'\n        else:\n            break\n        if op:\n            result = self.parseAnd()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(eval(value + op + result))\n            else:\n                self.errExit(\"'%s' is not a valid op number for XOR/OR\" % test)\n    return value",
            "def parseOrXor(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    value = self.parseAnd()\n    op = None\n    while True:\n        self.skipSpace()\n        op = None\n        if re.match('^XOR\\\\W', self.getCurr(-1)):\n            self.moveNext(3)\n            op = '^'\n        elif re.match('^OR\\\\W', self.getCurr(-1)):\n            self.moveNext(2)\n            op = '|'\n        else:\n            break\n        if op:\n            result = self.parseAnd()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(eval(value + op + result))\n            else:\n                self.errExit(\"'%s' is not a valid op number for XOR/OR\" % test)\n    return value",
            "def parseOrXor(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    value = self.parseAnd()\n    op = None\n    while True:\n        self.skipSpace()\n        op = None\n        if re.match('^XOR\\\\W', self.getCurr(-1)):\n            self.moveNext(3)\n            op = '^'\n        elif re.match('^OR\\\\W', self.getCurr(-1)):\n            self.moveNext(2)\n            op = '|'\n        else:\n            break\n        if op:\n            result = self.parseAnd()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(eval(value + op + result))\n            else:\n                self.errExit(\"'%s' is not a valid op number for XOR/OR\" % test)\n    return value",
            "def parseOrXor(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    value = self.parseAnd()\n    op = None\n    while True:\n        self.skipSpace()\n        op = None\n        if re.match('^XOR\\\\W', self.getCurr(-1)):\n            self.moveNext(3)\n            op = '^'\n        elif re.match('^OR\\\\W', self.getCurr(-1)):\n            self.moveNext(2)\n            op = '|'\n        else:\n            break\n        if op:\n            result = self.parseAnd()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(eval(value + op + result))\n            else:\n                self.errExit(\"'%s' is not a valid op number for XOR/OR\" % test)\n    return value",
            "def parseOrXor(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    value = self.parseAnd()\n    op = None\n    while True:\n        self.skipSpace()\n        op = None\n        if re.match('^XOR\\\\W', self.getCurr(-1)):\n            self.moveNext(3)\n            op = '^'\n        elif re.match('^OR\\\\W', self.getCurr(-1)):\n            self.moveNext(2)\n            op = '|'\n        else:\n            break\n        if op:\n            result = self.parseAnd()\n            test = self.getNonNumber(result, value)\n            if test is None:\n                value = '%d' % self.normNumber(eval(value + op + result))\n            else:\n                self.errExit(\"'%s' is not a valid op number for XOR/OR\" % test)\n    return value"
        ]
    },
    {
        "func_name": "parseExpr",
        "original": "def parseExpr(self):\n    return self.parseOrXor()",
        "mutated": [
            "def parseExpr(self):\n    if False:\n        i = 10\n    return self.parseOrXor()",
            "def parseExpr(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.parseOrXor()",
            "def parseExpr(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.parseOrXor()",
            "def parseExpr(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.parseOrXor()",
            "def parseExpr(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.parseOrXor()"
        ]
    },
    {
        "func_name": "getResult",
        "original": "def getResult(self):\n    value = self.parseExpr()\n    self.skipSpace()\n    if not self.isLast():\n        self.errExit(\"Unexpected character found '%s'\" % self.getCurr())\n    test = self.getNumber(value)\n    if test is None:\n        self.errExit(\"Result '%s' is not a number\" % value)\n    return int(value)",
        "mutated": [
            "def getResult(self):\n    if False:\n        i = 10\n    value = self.parseExpr()\n    self.skipSpace()\n    if not self.isLast():\n        self.errExit(\"Unexpected character found '%s'\" % self.getCurr())\n    test = self.getNumber(value)\n    if test is None:\n        self.errExit(\"Result '%s' is not a number\" % value)\n    return int(value)",
            "def getResult(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    value = self.parseExpr()\n    self.skipSpace()\n    if not self.isLast():\n        self.errExit(\"Unexpected character found '%s'\" % self.getCurr())\n    test = self.getNumber(value)\n    if test is None:\n        self.errExit(\"Result '%s' is not a number\" % value)\n    return int(value)",
            "def getResult(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    value = self.parseExpr()\n    self.skipSpace()\n    if not self.isLast():\n        self.errExit(\"Unexpected character found '%s'\" % self.getCurr())\n    test = self.getNumber(value)\n    if test is None:\n        self.errExit(\"Result '%s' is not a number\" % value)\n    return int(value)",
            "def getResult(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    value = self.parseExpr()\n    self.skipSpace()\n    if not self.isLast():\n        self.errExit(\"Unexpected character found '%s'\" % self.getCurr())\n    test = self.getNumber(value)\n    if test is None:\n        self.errExit(\"Result '%s' is not a number\" % value)\n    return int(value)",
            "def getResult(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    value = self.parseExpr()\n    self.skipSpace()\n    if not self.isLast():\n        self.errExit(\"Unexpected character found '%s'\" % self.getCurr())\n    test = self.getNumber(value)\n    if test is None:\n        self.errExit(\"Result '%s' is not a number\" % value)\n    return int(value)"
        ]
    },
    {
        "func_name": "evaluateExpress",
        "original": "def evaluateExpress(self, Expr):\n    self.index = 0\n    self.string = Expr\n    if self.getResult():\n        Result = True\n    else:\n        Result = False\n    return Result",
        "mutated": [
            "def evaluateExpress(self, Expr):\n    if False:\n        i = 10\n    self.index = 0\n    self.string = Expr\n    if self.getResult():\n        Result = True\n    else:\n        Result = False\n    return Result",
            "def evaluateExpress(self, Expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.index = 0\n    self.string = Expr\n    if self.getResult():\n        Result = True\n    else:\n        Result = False\n    return Result",
            "def evaluateExpress(self, Expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.index = 0\n    self.string = Expr\n    if self.getResult():\n        Result = True\n    else:\n        Result = False\n    return Result",
            "def evaluateExpress(self, Expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.index = 0\n    self.string = Expr\n    if self.getResult():\n        Result = True\n    else:\n        Result = False\n    return Result",
            "def evaluateExpress(self, Expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.index = 0\n    self.string = Expr\n    if self.getResult():\n        Result = True\n    else:\n        Result = False\n    return Result"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, Mode=''):\n    self.Debug = False\n    self.Error = ''\n    self.Mode = Mode\n    self._GlobalDataDef = '\\nGlobalDataDef\\n    SKUID = 0, \"DEFAULT\"\\nEndGlobalData\\n\\n'\n    self._BuidinOptionTxt = '\\nList &EN_DIS\\n    Selection 0x1 , \"Enabled\"\\n    Selection 0x0 , \"Disabled\"\\nEndList\\n\\n'\n    self._BsfKeyList = ['FIND', 'NAME', 'HELP', 'TYPE', 'PAGE', 'PAGES', 'BLOCK', 'OPTION', 'CONDITION', 'ORDER', 'MARKER', 'SUBT']\n    self._HdrKeyList = ['HEADER', 'STRUCT', 'EMBED', 'COMMENT']\n    self._BuidinOption = {'$EN_DIS': 'EN_DIS'}\n    self._MacroDict = {}\n    self._VarDict = {}\n    self._PcdsDict = {}\n    self._CfgBlkDict = {}\n    self._CfgPageDict = {}\n    self._BsfTempDict = {}\n    self._CfgItemList = []\n    self._DscLines = []\n    self._DscFile = ''\n    self._MapVer = 0\n    self._DscTime = 0",
        "mutated": [
            "def __init__(self, Mode=''):\n    if False:\n        i = 10\n    self.Debug = False\n    self.Error = ''\n    self.Mode = Mode\n    self._GlobalDataDef = '\\nGlobalDataDef\\n    SKUID = 0, \"DEFAULT\"\\nEndGlobalData\\n\\n'\n    self._BuidinOptionTxt = '\\nList &EN_DIS\\n    Selection 0x1 , \"Enabled\"\\n    Selection 0x0 , \"Disabled\"\\nEndList\\n\\n'\n    self._BsfKeyList = ['FIND', 'NAME', 'HELP', 'TYPE', 'PAGE', 'PAGES', 'BLOCK', 'OPTION', 'CONDITION', 'ORDER', 'MARKER', 'SUBT']\n    self._HdrKeyList = ['HEADER', 'STRUCT', 'EMBED', 'COMMENT']\n    self._BuidinOption = {'$EN_DIS': 'EN_DIS'}\n    self._MacroDict = {}\n    self._VarDict = {}\n    self._PcdsDict = {}\n    self._CfgBlkDict = {}\n    self._CfgPageDict = {}\n    self._BsfTempDict = {}\n    self._CfgItemList = []\n    self._DscLines = []\n    self._DscFile = ''\n    self._MapVer = 0\n    self._DscTime = 0",
            "def __init__(self, Mode=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.Debug = False\n    self.Error = ''\n    self.Mode = Mode\n    self._GlobalDataDef = '\\nGlobalDataDef\\n    SKUID = 0, \"DEFAULT\"\\nEndGlobalData\\n\\n'\n    self._BuidinOptionTxt = '\\nList &EN_DIS\\n    Selection 0x1 , \"Enabled\"\\n    Selection 0x0 , \"Disabled\"\\nEndList\\n\\n'\n    self._BsfKeyList = ['FIND', 'NAME', 'HELP', 'TYPE', 'PAGE', 'PAGES', 'BLOCK', 'OPTION', 'CONDITION', 'ORDER', 'MARKER', 'SUBT']\n    self._HdrKeyList = ['HEADER', 'STRUCT', 'EMBED', 'COMMENT']\n    self._BuidinOption = {'$EN_DIS': 'EN_DIS'}\n    self._MacroDict = {}\n    self._VarDict = {}\n    self._PcdsDict = {}\n    self._CfgBlkDict = {}\n    self._CfgPageDict = {}\n    self._BsfTempDict = {}\n    self._CfgItemList = []\n    self._DscLines = []\n    self._DscFile = ''\n    self._MapVer = 0\n    self._DscTime = 0",
            "def __init__(self, Mode=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.Debug = False\n    self.Error = ''\n    self.Mode = Mode\n    self._GlobalDataDef = '\\nGlobalDataDef\\n    SKUID = 0, \"DEFAULT\"\\nEndGlobalData\\n\\n'\n    self._BuidinOptionTxt = '\\nList &EN_DIS\\n    Selection 0x1 , \"Enabled\"\\n    Selection 0x0 , \"Disabled\"\\nEndList\\n\\n'\n    self._BsfKeyList = ['FIND', 'NAME', 'HELP', 'TYPE', 'PAGE', 'PAGES', 'BLOCK', 'OPTION', 'CONDITION', 'ORDER', 'MARKER', 'SUBT']\n    self._HdrKeyList = ['HEADER', 'STRUCT', 'EMBED', 'COMMENT']\n    self._BuidinOption = {'$EN_DIS': 'EN_DIS'}\n    self._MacroDict = {}\n    self._VarDict = {}\n    self._PcdsDict = {}\n    self._CfgBlkDict = {}\n    self._CfgPageDict = {}\n    self._BsfTempDict = {}\n    self._CfgItemList = []\n    self._DscLines = []\n    self._DscFile = ''\n    self._MapVer = 0\n    self._DscTime = 0",
            "def __init__(self, Mode=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.Debug = False\n    self.Error = ''\n    self.Mode = Mode\n    self._GlobalDataDef = '\\nGlobalDataDef\\n    SKUID = 0, \"DEFAULT\"\\nEndGlobalData\\n\\n'\n    self._BuidinOptionTxt = '\\nList &EN_DIS\\n    Selection 0x1 , \"Enabled\"\\n    Selection 0x0 , \"Disabled\"\\nEndList\\n\\n'\n    self._BsfKeyList = ['FIND', 'NAME', 'HELP', 'TYPE', 'PAGE', 'PAGES', 'BLOCK', 'OPTION', 'CONDITION', 'ORDER', 'MARKER', 'SUBT']\n    self._HdrKeyList = ['HEADER', 'STRUCT', 'EMBED', 'COMMENT']\n    self._BuidinOption = {'$EN_DIS': 'EN_DIS'}\n    self._MacroDict = {}\n    self._VarDict = {}\n    self._PcdsDict = {}\n    self._CfgBlkDict = {}\n    self._CfgPageDict = {}\n    self._BsfTempDict = {}\n    self._CfgItemList = []\n    self._DscLines = []\n    self._DscFile = ''\n    self._MapVer = 0\n    self._DscTime = 0",
            "def __init__(self, Mode=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.Debug = False\n    self.Error = ''\n    self.Mode = Mode\n    self._GlobalDataDef = '\\nGlobalDataDef\\n    SKUID = 0, \"DEFAULT\"\\nEndGlobalData\\n\\n'\n    self._BuidinOptionTxt = '\\nList &EN_DIS\\n    Selection 0x1 , \"Enabled\"\\n    Selection 0x0 , \"Disabled\"\\nEndList\\n\\n'\n    self._BsfKeyList = ['FIND', 'NAME', 'HELP', 'TYPE', 'PAGE', 'PAGES', 'BLOCK', 'OPTION', 'CONDITION', 'ORDER', 'MARKER', 'SUBT']\n    self._HdrKeyList = ['HEADER', 'STRUCT', 'EMBED', 'COMMENT']\n    self._BuidinOption = {'$EN_DIS': 'EN_DIS'}\n    self._MacroDict = {}\n    self._VarDict = {}\n    self._PcdsDict = {}\n    self._CfgBlkDict = {}\n    self._CfgPageDict = {}\n    self._BsfTempDict = {}\n    self._CfgItemList = []\n    self._DscLines = []\n    self._DscFile = ''\n    self._MapVer = 0\n    self._DscTime = 0"
        ]
    },
    {
        "func_name": "ParseMacros",
        "original": "def ParseMacros(self, MacroDefStr):\n    self._MacroDict = {}\n    IsExpression = False\n    for Macro in MacroDefStr:\n        if Macro.startswith('-D'):\n            IsExpression = True\n            if len(Macro) > 2:\n                Macro = Macro[2:]\n            else:\n                continue\n        if IsExpression:\n            IsExpression = False\n            Match = re.match('(\\\\w+)=(.+)', Macro)\n            if Match:\n                self._MacroDict[Match.group(1)] = Match.group(2)\n            else:\n                Match = re.match('(\\\\w+)', Macro)\n                if Match:\n                    self._MacroDict[Match.group(1)] = ''\n    if len(self._MacroDict) == 0:\n        Error = 1\n    else:\n        Error = 0\n        if self.Debug:\n            print('INFO : Macro dictionary:')\n            for Each in self._MacroDict:\n                print('       $(%s) = [ %s ]' % (Each, self._MacroDict[Each]))\n    return Error",
        "mutated": [
            "def ParseMacros(self, MacroDefStr):\n    if False:\n        i = 10\n    self._MacroDict = {}\n    IsExpression = False\n    for Macro in MacroDefStr:\n        if Macro.startswith('-D'):\n            IsExpression = True\n            if len(Macro) > 2:\n                Macro = Macro[2:]\n            else:\n                continue\n        if IsExpression:\n            IsExpression = False\n            Match = re.match('(\\\\w+)=(.+)', Macro)\n            if Match:\n                self._MacroDict[Match.group(1)] = Match.group(2)\n            else:\n                Match = re.match('(\\\\w+)', Macro)\n                if Match:\n                    self._MacroDict[Match.group(1)] = ''\n    if len(self._MacroDict) == 0:\n        Error = 1\n    else:\n        Error = 0\n        if self.Debug:\n            print('INFO : Macro dictionary:')\n            for Each in self._MacroDict:\n                print('       $(%s) = [ %s ]' % (Each, self._MacroDict[Each]))\n    return Error",
            "def ParseMacros(self, MacroDefStr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._MacroDict = {}\n    IsExpression = False\n    for Macro in MacroDefStr:\n        if Macro.startswith('-D'):\n            IsExpression = True\n            if len(Macro) > 2:\n                Macro = Macro[2:]\n            else:\n                continue\n        if IsExpression:\n            IsExpression = False\n            Match = re.match('(\\\\w+)=(.+)', Macro)\n            if Match:\n                self._MacroDict[Match.group(1)] = Match.group(2)\n            else:\n                Match = re.match('(\\\\w+)', Macro)\n                if Match:\n                    self._MacroDict[Match.group(1)] = ''\n    if len(self._MacroDict) == 0:\n        Error = 1\n    else:\n        Error = 0\n        if self.Debug:\n            print('INFO : Macro dictionary:')\n            for Each in self._MacroDict:\n                print('       $(%s) = [ %s ]' % (Each, self._MacroDict[Each]))\n    return Error",
            "def ParseMacros(self, MacroDefStr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._MacroDict = {}\n    IsExpression = False\n    for Macro in MacroDefStr:\n        if Macro.startswith('-D'):\n            IsExpression = True\n            if len(Macro) > 2:\n                Macro = Macro[2:]\n            else:\n                continue\n        if IsExpression:\n            IsExpression = False\n            Match = re.match('(\\\\w+)=(.+)', Macro)\n            if Match:\n                self._MacroDict[Match.group(1)] = Match.group(2)\n            else:\n                Match = re.match('(\\\\w+)', Macro)\n                if Match:\n                    self._MacroDict[Match.group(1)] = ''\n    if len(self._MacroDict) == 0:\n        Error = 1\n    else:\n        Error = 0\n        if self.Debug:\n            print('INFO : Macro dictionary:')\n            for Each in self._MacroDict:\n                print('       $(%s) = [ %s ]' % (Each, self._MacroDict[Each]))\n    return Error",
            "def ParseMacros(self, MacroDefStr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._MacroDict = {}\n    IsExpression = False\n    for Macro in MacroDefStr:\n        if Macro.startswith('-D'):\n            IsExpression = True\n            if len(Macro) > 2:\n                Macro = Macro[2:]\n            else:\n                continue\n        if IsExpression:\n            IsExpression = False\n            Match = re.match('(\\\\w+)=(.+)', Macro)\n            if Match:\n                self._MacroDict[Match.group(1)] = Match.group(2)\n            else:\n                Match = re.match('(\\\\w+)', Macro)\n                if Match:\n                    self._MacroDict[Match.group(1)] = ''\n    if len(self._MacroDict) == 0:\n        Error = 1\n    else:\n        Error = 0\n        if self.Debug:\n            print('INFO : Macro dictionary:')\n            for Each in self._MacroDict:\n                print('       $(%s) = [ %s ]' % (Each, self._MacroDict[Each]))\n    return Error",
            "def ParseMacros(self, MacroDefStr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._MacroDict = {}\n    IsExpression = False\n    for Macro in MacroDefStr:\n        if Macro.startswith('-D'):\n            IsExpression = True\n            if len(Macro) > 2:\n                Macro = Macro[2:]\n            else:\n                continue\n        if IsExpression:\n            IsExpression = False\n            Match = re.match('(\\\\w+)=(.+)', Macro)\n            if Match:\n                self._MacroDict[Match.group(1)] = Match.group(2)\n            else:\n                Match = re.match('(\\\\w+)', Macro)\n                if Match:\n                    self._MacroDict[Match.group(1)] = ''\n    if len(self._MacroDict) == 0:\n        Error = 1\n    else:\n        Error = 0\n        if self.Debug:\n            print('INFO : Macro dictionary:')\n            for Each in self._MacroDict:\n                print('       $(%s) = [ %s ]' % (Each, self._MacroDict[Each]))\n    return Error"
        ]
    },
    {
        "func_name": "EvaulateIfdef",
        "original": "def EvaulateIfdef(self, Macro):\n    Result = Macro in self._MacroDict\n    if self.Debug:\n        print('INFO : Eval Ifdef [%s] : %s' % (Macro, Result))\n    return Result",
        "mutated": [
            "def EvaulateIfdef(self, Macro):\n    if False:\n        i = 10\n    Result = Macro in self._MacroDict\n    if self.Debug:\n        print('INFO : Eval Ifdef [%s] : %s' % (Macro, Result))\n    return Result",
            "def EvaulateIfdef(self, Macro):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Result = Macro in self._MacroDict\n    if self.Debug:\n        print('INFO : Eval Ifdef [%s] : %s' % (Macro, Result))\n    return Result",
            "def EvaulateIfdef(self, Macro):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Result = Macro in self._MacroDict\n    if self.Debug:\n        print('INFO : Eval Ifdef [%s] : %s' % (Macro, Result))\n    return Result",
            "def EvaulateIfdef(self, Macro):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Result = Macro in self._MacroDict\n    if self.Debug:\n        print('INFO : Eval Ifdef [%s] : %s' % (Macro, Result))\n    return Result",
            "def EvaulateIfdef(self, Macro):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Result = Macro in self._MacroDict\n    if self.Debug:\n        print('INFO : Eval Ifdef [%s] : %s' % (Macro, Result))\n    return Result"
        ]
    },
    {
        "func_name": "ExpandMacros",
        "original": "def ExpandMacros(self, Input, Preserve=False):\n    Line = Input\n    Match = re.findall('\\\\$\\\\(\\\\w+\\\\)', Input)\n    if Match:\n        for Each in Match:\n            Variable = Each[2:-1]\n            if Variable in self._MacroDict:\n                Line = Line.replace(Each, self._MacroDict[Variable])\n            else:\n                if self.Debug:\n                    print('WARN : %s is not defined' % Each)\n                if not Preserve:\n                    Line = Line.replace(Each, Each[2:-1])\n    return Line",
        "mutated": [
            "def ExpandMacros(self, Input, Preserve=False):\n    if False:\n        i = 10\n    Line = Input\n    Match = re.findall('\\\\$\\\\(\\\\w+\\\\)', Input)\n    if Match:\n        for Each in Match:\n            Variable = Each[2:-1]\n            if Variable in self._MacroDict:\n                Line = Line.replace(Each, self._MacroDict[Variable])\n            else:\n                if self.Debug:\n                    print('WARN : %s is not defined' % Each)\n                if not Preserve:\n                    Line = Line.replace(Each, Each[2:-1])\n    return Line",
            "def ExpandMacros(self, Input, Preserve=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Line = Input\n    Match = re.findall('\\\\$\\\\(\\\\w+\\\\)', Input)\n    if Match:\n        for Each in Match:\n            Variable = Each[2:-1]\n            if Variable in self._MacroDict:\n                Line = Line.replace(Each, self._MacroDict[Variable])\n            else:\n                if self.Debug:\n                    print('WARN : %s is not defined' % Each)\n                if not Preserve:\n                    Line = Line.replace(Each, Each[2:-1])\n    return Line",
            "def ExpandMacros(self, Input, Preserve=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Line = Input\n    Match = re.findall('\\\\$\\\\(\\\\w+\\\\)', Input)\n    if Match:\n        for Each in Match:\n            Variable = Each[2:-1]\n            if Variable in self._MacroDict:\n                Line = Line.replace(Each, self._MacroDict[Variable])\n            else:\n                if self.Debug:\n                    print('WARN : %s is not defined' % Each)\n                if not Preserve:\n                    Line = Line.replace(Each, Each[2:-1])\n    return Line",
            "def ExpandMacros(self, Input, Preserve=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Line = Input\n    Match = re.findall('\\\\$\\\\(\\\\w+\\\\)', Input)\n    if Match:\n        for Each in Match:\n            Variable = Each[2:-1]\n            if Variable in self._MacroDict:\n                Line = Line.replace(Each, self._MacroDict[Variable])\n            else:\n                if self.Debug:\n                    print('WARN : %s is not defined' % Each)\n                if not Preserve:\n                    Line = Line.replace(Each, Each[2:-1])\n    return Line",
            "def ExpandMacros(self, Input, Preserve=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Line = Input\n    Match = re.findall('\\\\$\\\\(\\\\w+\\\\)', Input)\n    if Match:\n        for Each in Match:\n            Variable = Each[2:-1]\n            if Variable in self._MacroDict:\n                Line = Line.replace(Each, self._MacroDict[Variable])\n            else:\n                if self.Debug:\n                    print('WARN : %s is not defined' % Each)\n                if not Preserve:\n                    Line = Line.replace(Each, Each[2:-1])\n    return Line"
        ]
    },
    {
        "func_name": "ExpandPcds",
        "original": "def ExpandPcds(self, Input):\n    Line = Input\n    Match = re.findall('(\\\\w+\\\\.\\\\w+)', Input)\n    if Match:\n        for PcdName in Match:\n            if PcdName in self._PcdsDict:\n                Line = Line.replace(PcdName, self._PcdsDict[PcdName])\n            elif self.Debug:\n                print('WARN : %s is not defined' % PcdName)\n    return Line",
        "mutated": [
            "def ExpandPcds(self, Input):\n    if False:\n        i = 10\n    Line = Input\n    Match = re.findall('(\\\\w+\\\\.\\\\w+)', Input)\n    if Match:\n        for PcdName in Match:\n            if PcdName in self._PcdsDict:\n                Line = Line.replace(PcdName, self._PcdsDict[PcdName])\n            elif self.Debug:\n                print('WARN : %s is not defined' % PcdName)\n    return Line",
            "def ExpandPcds(self, Input):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Line = Input\n    Match = re.findall('(\\\\w+\\\\.\\\\w+)', Input)\n    if Match:\n        for PcdName in Match:\n            if PcdName in self._PcdsDict:\n                Line = Line.replace(PcdName, self._PcdsDict[PcdName])\n            elif self.Debug:\n                print('WARN : %s is not defined' % PcdName)\n    return Line",
            "def ExpandPcds(self, Input):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Line = Input\n    Match = re.findall('(\\\\w+\\\\.\\\\w+)', Input)\n    if Match:\n        for PcdName in Match:\n            if PcdName in self._PcdsDict:\n                Line = Line.replace(PcdName, self._PcdsDict[PcdName])\n            elif self.Debug:\n                print('WARN : %s is not defined' % PcdName)\n    return Line",
            "def ExpandPcds(self, Input):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Line = Input\n    Match = re.findall('(\\\\w+\\\\.\\\\w+)', Input)\n    if Match:\n        for PcdName in Match:\n            if PcdName in self._PcdsDict:\n                Line = Line.replace(PcdName, self._PcdsDict[PcdName])\n            elif self.Debug:\n                print('WARN : %s is not defined' % PcdName)\n    return Line",
            "def ExpandPcds(self, Input):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Line = Input\n    Match = re.findall('(\\\\w+\\\\.\\\\w+)', Input)\n    if Match:\n        for PcdName in Match:\n            if PcdName in self._PcdsDict:\n                Line = Line.replace(PcdName, self._PcdsDict[PcdName])\n            elif self.Debug:\n                print('WARN : %s is not defined' % PcdName)\n    return Line"
        ]
    },
    {
        "func_name": "EvaluateExpress",
        "original": "def EvaluateExpress(self, Expr):\n    ExpExpr = self.ExpandPcds(Expr)\n    ExpExpr = self.ExpandMacros(ExpExpr)\n    LogExpr = CLogicalExpression()\n    Result = LogExpr.evaluateExpress(ExpExpr)\n    if self.Debug:\n        print('INFO : Eval Express [%s] : %s' % (Expr, Result))\n    return Result",
        "mutated": [
            "def EvaluateExpress(self, Expr):\n    if False:\n        i = 10\n    ExpExpr = self.ExpandPcds(Expr)\n    ExpExpr = self.ExpandMacros(ExpExpr)\n    LogExpr = CLogicalExpression()\n    Result = LogExpr.evaluateExpress(ExpExpr)\n    if self.Debug:\n        print('INFO : Eval Express [%s] : %s' % (Expr, Result))\n    return Result",
            "def EvaluateExpress(self, Expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ExpExpr = self.ExpandPcds(Expr)\n    ExpExpr = self.ExpandMacros(ExpExpr)\n    LogExpr = CLogicalExpression()\n    Result = LogExpr.evaluateExpress(ExpExpr)\n    if self.Debug:\n        print('INFO : Eval Express [%s] : %s' % (Expr, Result))\n    return Result",
            "def EvaluateExpress(self, Expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ExpExpr = self.ExpandPcds(Expr)\n    ExpExpr = self.ExpandMacros(ExpExpr)\n    LogExpr = CLogicalExpression()\n    Result = LogExpr.evaluateExpress(ExpExpr)\n    if self.Debug:\n        print('INFO : Eval Express [%s] : %s' % (Expr, Result))\n    return Result",
            "def EvaluateExpress(self, Expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ExpExpr = self.ExpandPcds(Expr)\n    ExpExpr = self.ExpandMacros(ExpExpr)\n    LogExpr = CLogicalExpression()\n    Result = LogExpr.evaluateExpress(ExpExpr)\n    if self.Debug:\n        print('INFO : Eval Express [%s] : %s' % (Expr, Result))\n    return Result",
            "def EvaluateExpress(self, Expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ExpExpr = self.ExpandPcds(Expr)\n    ExpExpr = self.ExpandMacros(ExpExpr)\n    LogExpr = CLogicalExpression()\n    Result = LogExpr.evaluateExpress(ExpExpr)\n    if self.Debug:\n        print('INFO : Eval Express [%s] : %s' % (Expr, Result))\n    return Result"
        ]
    },
    {
        "func_name": "ValueToByteArray",
        "original": "def ValueToByteArray(self, ValueStr, Length):\n    Match = re.match('\\\\{\\\\s*FILE:(.+)\\\\}', ValueStr)\n    if Match:\n        FileList = Match.group(1).split(',')\n        Result = bytearray()\n        for File in FileList:\n            File = File.strip()\n            BinPath = os.path.join(os.path.dirname(self._DscFile), File)\n            Result.extend(bytearray(open(BinPath, 'rb').read()))\n    else:\n        try:\n            Result = bytearray(self.ValueToList(ValueStr, Length))\n        except ValueError as e:\n            raise Exception(\"Bytes in '%s' must be in range 0~255 !\" % ValueStr)\n    if len(Result) < Length:\n        Result.extend(b'\\x00' * (Length - len(Result)))\n    elif len(Result) > Length:\n        raise Exception(\"Value '%s' is too big to fit into %d bytes !\" % (ValueStr, Length))\n    return Result[:Length]",
        "mutated": [
            "def ValueToByteArray(self, ValueStr, Length):\n    if False:\n        i = 10\n    Match = re.match('\\\\{\\\\s*FILE:(.+)\\\\}', ValueStr)\n    if Match:\n        FileList = Match.group(1).split(',')\n        Result = bytearray()\n        for File in FileList:\n            File = File.strip()\n            BinPath = os.path.join(os.path.dirname(self._DscFile), File)\n            Result.extend(bytearray(open(BinPath, 'rb').read()))\n    else:\n        try:\n            Result = bytearray(self.ValueToList(ValueStr, Length))\n        except ValueError as e:\n            raise Exception(\"Bytes in '%s' must be in range 0~255 !\" % ValueStr)\n    if len(Result) < Length:\n        Result.extend(b'\\x00' * (Length - len(Result)))\n    elif len(Result) > Length:\n        raise Exception(\"Value '%s' is too big to fit into %d bytes !\" % (ValueStr, Length))\n    return Result[:Length]",
            "def ValueToByteArray(self, ValueStr, Length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Match = re.match('\\\\{\\\\s*FILE:(.+)\\\\}', ValueStr)\n    if Match:\n        FileList = Match.group(1).split(',')\n        Result = bytearray()\n        for File in FileList:\n            File = File.strip()\n            BinPath = os.path.join(os.path.dirname(self._DscFile), File)\n            Result.extend(bytearray(open(BinPath, 'rb').read()))\n    else:\n        try:\n            Result = bytearray(self.ValueToList(ValueStr, Length))\n        except ValueError as e:\n            raise Exception(\"Bytes in '%s' must be in range 0~255 !\" % ValueStr)\n    if len(Result) < Length:\n        Result.extend(b'\\x00' * (Length - len(Result)))\n    elif len(Result) > Length:\n        raise Exception(\"Value '%s' is too big to fit into %d bytes !\" % (ValueStr, Length))\n    return Result[:Length]",
            "def ValueToByteArray(self, ValueStr, Length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Match = re.match('\\\\{\\\\s*FILE:(.+)\\\\}', ValueStr)\n    if Match:\n        FileList = Match.group(1).split(',')\n        Result = bytearray()\n        for File in FileList:\n            File = File.strip()\n            BinPath = os.path.join(os.path.dirname(self._DscFile), File)\n            Result.extend(bytearray(open(BinPath, 'rb').read()))\n    else:\n        try:\n            Result = bytearray(self.ValueToList(ValueStr, Length))\n        except ValueError as e:\n            raise Exception(\"Bytes in '%s' must be in range 0~255 !\" % ValueStr)\n    if len(Result) < Length:\n        Result.extend(b'\\x00' * (Length - len(Result)))\n    elif len(Result) > Length:\n        raise Exception(\"Value '%s' is too big to fit into %d bytes !\" % (ValueStr, Length))\n    return Result[:Length]",
            "def ValueToByteArray(self, ValueStr, Length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Match = re.match('\\\\{\\\\s*FILE:(.+)\\\\}', ValueStr)\n    if Match:\n        FileList = Match.group(1).split(',')\n        Result = bytearray()\n        for File in FileList:\n            File = File.strip()\n            BinPath = os.path.join(os.path.dirname(self._DscFile), File)\n            Result.extend(bytearray(open(BinPath, 'rb').read()))\n    else:\n        try:\n            Result = bytearray(self.ValueToList(ValueStr, Length))\n        except ValueError as e:\n            raise Exception(\"Bytes in '%s' must be in range 0~255 !\" % ValueStr)\n    if len(Result) < Length:\n        Result.extend(b'\\x00' * (Length - len(Result)))\n    elif len(Result) > Length:\n        raise Exception(\"Value '%s' is too big to fit into %d bytes !\" % (ValueStr, Length))\n    return Result[:Length]",
            "def ValueToByteArray(self, ValueStr, Length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Match = re.match('\\\\{\\\\s*FILE:(.+)\\\\}', ValueStr)\n    if Match:\n        FileList = Match.group(1).split(',')\n        Result = bytearray()\n        for File in FileList:\n            File = File.strip()\n            BinPath = os.path.join(os.path.dirname(self._DscFile), File)\n            Result.extend(bytearray(open(BinPath, 'rb').read()))\n    else:\n        try:\n            Result = bytearray(self.ValueToList(ValueStr, Length))\n        except ValueError as e:\n            raise Exception(\"Bytes in '%s' must be in range 0~255 !\" % ValueStr)\n    if len(Result) < Length:\n        Result.extend(b'\\x00' * (Length - len(Result)))\n    elif len(Result) > Length:\n        raise Exception(\"Value '%s' is too big to fit into %d bytes !\" % (ValueStr, Length))\n    return Result[:Length]"
        ]
    },
    {
        "func_name": "ValueToList",
        "original": "def ValueToList(self, ValueStr, Length):\n    if ValueStr[0] == '{':\n        Result = []\n        BinList = ValueStr[1:-1].split(',')\n        InBitField = False\n        LastInBitField = False\n        Value = 0\n        BitLen = 0\n        for Element in BinList:\n            InBitField = False\n            Each = Element.strip()\n            if len(Each) == 0:\n                pass\n            elif Each[0] in ['\"', \"'\"]:\n                Result.extend(list(bytearray(Each[1:-1], 'utf-8')))\n            elif ':' in Each:\n                Match = re.match('(.+):(\\\\d+)b', Each)\n                if Match is None:\n                    raise Exception(\"Invald value list format '%s' !\" % Each)\n                InBitField = True\n                CurrentBitLen = int(Match.group(2))\n                CurrentValue = (self.EvaluateExpress(Match.group(1)) & (1 << CurrentBitLen) - 1) << BitLen\n            else:\n                Result.append(self.EvaluateExpress(Each.strip()))\n            if InBitField:\n                Value += CurrentValue\n                BitLen += CurrentBitLen\n            if LastInBitField and (not InBitField or Element == BinList[-1]):\n                if BitLen % 8 != 0:\n                    raise Exception('Invald bit field length!')\n                Result.extend(Val2Bytes(Value, BitLen // 8))\n                Value = 0\n                BitLen = 0\n            LastInBitField = InBitField\n    elif ValueStr.startswith(\"'\") and ValueStr.endswith(\"'\"):\n        Result = Str2Bytes(ValueStr, Length)\n    elif ValueStr.startswith('\"') and ValueStr.endswith('\"'):\n        Result = Str2Bytes(ValueStr, Length)\n    else:\n        Result = Val2Bytes(self.EvaluateExpress(ValueStr), Length)\n    return Result",
        "mutated": [
            "def ValueToList(self, ValueStr, Length):\n    if False:\n        i = 10\n    if ValueStr[0] == '{':\n        Result = []\n        BinList = ValueStr[1:-1].split(',')\n        InBitField = False\n        LastInBitField = False\n        Value = 0\n        BitLen = 0\n        for Element in BinList:\n            InBitField = False\n            Each = Element.strip()\n            if len(Each) == 0:\n                pass\n            elif Each[0] in ['\"', \"'\"]:\n                Result.extend(list(bytearray(Each[1:-1], 'utf-8')))\n            elif ':' in Each:\n                Match = re.match('(.+):(\\\\d+)b', Each)\n                if Match is None:\n                    raise Exception(\"Invald value list format '%s' !\" % Each)\n                InBitField = True\n                CurrentBitLen = int(Match.group(2))\n                CurrentValue = (self.EvaluateExpress(Match.group(1)) & (1 << CurrentBitLen) - 1) << BitLen\n            else:\n                Result.append(self.EvaluateExpress(Each.strip()))\n            if InBitField:\n                Value += CurrentValue\n                BitLen += CurrentBitLen\n            if LastInBitField and (not InBitField or Element == BinList[-1]):\n                if BitLen % 8 != 0:\n                    raise Exception('Invald bit field length!')\n                Result.extend(Val2Bytes(Value, BitLen // 8))\n                Value = 0\n                BitLen = 0\n            LastInBitField = InBitField\n    elif ValueStr.startswith(\"'\") and ValueStr.endswith(\"'\"):\n        Result = Str2Bytes(ValueStr, Length)\n    elif ValueStr.startswith('\"') and ValueStr.endswith('\"'):\n        Result = Str2Bytes(ValueStr, Length)\n    else:\n        Result = Val2Bytes(self.EvaluateExpress(ValueStr), Length)\n    return Result",
            "def ValueToList(self, ValueStr, Length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if ValueStr[0] == '{':\n        Result = []\n        BinList = ValueStr[1:-1].split(',')\n        InBitField = False\n        LastInBitField = False\n        Value = 0\n        BitLen = 0\n        for Element in BinList:\n            InBitField = False\n            Each = Element.strip()\n            if len(Each) == 0:\n                pass\n            elif Each[0] in ['\"', \"'\"]:\n                Result.extend(list(bytearray(Each[1:-1], 'utf-8')))\n            elif ':' in Each:\n                Match = re.match('(.+):(\\\\d+)b', Each)\n                if Match is None:\n                    raise Exception(\"Invald value list format '%s' !\" % Each)\n                InBitField = True\n                CurrentBitLen = int(Match.group(2))\n                CurrentValue = (self.EvaluateExpress(Match.group(1)) & (1 << CurrentBitLen) - 1) << BitLen\n            else:\n                Result.append(self.EvaluateExpress(Each.strip()))\n            if InBitField:\n                Value += CurrentValue\n                BitLen += CurrentBitLen\n            if LastInBitField and (not InBitField or Element == BinList[-1]):\n                if BitLen % 8 != 0:\n                    raise Exception('Invald bit field length!')\n                Result.extend(Val2Bytes(Value, BitLen // 8))\n                Value = 0\n                BitLen = 0\n            LastInBitField = InBitField\n    elif ValueStr.startswith(\"'\") and ValueStr.endswith(\"'\"):\n        Result = Str2Bytes(ValueStr, Length)\n    elif ValueStr.startswith('\"') and ValueStr.endswith('\"'):\n        Result = Str2Bytes(ValueStr, Length)\n    else:\n        Result = Val2Bytes(self.EvaluateExpress(ValueStr), Length)\n    return Result",
            "def ValueToList(self, ValueStr, Length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if ValueStr[0] == '{':\n        Result = []\n        BinList = ValueStr[1:-1].split(',')\n        InBitField = False\n        LastInBitField = False\n        Value = 0\n        BitLen = 0\n        for Element in BinList:\n            InBitField = False\n            Each = Element.strip()\n            if len(Each) == 0:\n                pass\n            elif Each[0] in ['\"', \"'\"]:\n                Result.extend(list(bytearray(Each[1:-1], 'utf-8')))\n            elif ':' in Each:\n                Match = re.match('(.+):(\\\\d+)b', Each)\n                if Match is None:\n                    raise Exception(\"Invald value list format '%s' !\" % Each)\n                InBitField = True\n                CurrentBitLen = int(Match.group(2))\n                CurrentValue = (self.EvaluateExpress(Match.group(1)) & (1 << CurrentBitLen) - 1) << BitLen\n            else:\n                Result.append(self.EvaluateExpress(Each.strip()))\n            if InBitField:\n                Value += CurrentValue\n                BitLen += CurrentBitLen\n            if LastInBitField and (not InBitField or Element == BinList[-1]):\n                if BitLen % 8 != 0:\n                    raise Exception('Invald bit field length!')\n                Result.extend(Val2Bytes(Value, BitLen // 8))\n                Value = 0\n                BitLen = 0\n            LastInBitField = InBitField\n    elif ValueStr.startswith(\"'\") and ValueStr.endswith(\"'\"):\n        Result = Str2Bytes(ValueStr, Length)\n    elif ValueStr.startswith('\"') and ValueStr.endswith('\"'):\n        Result = Str2Bytes(ValueStr, Length)\n    else:\n        Result = Val2Bytes(self.EvaluateExpress(ValueStr), Length)\n    return Result",
            "def ValueToList(self, ValueStr, Length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if ValueStr[0] == '{':\n        Result = []\n        BinList = ValueStr[1:-1].split(',')\n        InBitField = False\n        LastInBitField = False\n        Value = 0\n        BitLen = 0\n        for Element in BinList:\n            InBitField = False\n            Each = Element.strip()\n            if len(Each) == 0:\n                pass\n            elif Each[0] in ['\"', \"'\"]:\n                Result.extend(list(bytearray(Each[1:-1], 'utf-8')))\n            elif ':' in Each:\n                Match = re.match('(.+):(\\\\d+)b', Each)\n                if Match is None:\n                    raise Exception(\"Invald value list format '%s' !\" % Each)\n                InBitField = True\n                CurrentBitLen = int(Match.group(2))\n                CurrentValue = (self.EvaluateExpress(Match.group(1)) & (1 << CurrentBitLen) - 1) << BitLen\n            else:\n                Result.append(self.EvaluateExpress(Each.strip()))\n            if InBitField:\n                Value += CurrentValue\n                BitLen += CurrentBitLen\n            if LastInBitField and (not InBitField or Element == BinList[-1]):\n                if BitLen % 8 != 0:\n                    raise Exception('Invald bit field length!')\n                Result.extend(Val2Bytes(Value, BitLen // 8))\n                Value = 0\n                BitLen = 0\n            LastInBitField = InBitField\n    elif ValueStr.startswith(\"'\") and ValueStr.endswith(\"'\"):\n        Result = Str2Bytes(ValueStr, Length)\n    elif ValueStr.startswith('\"') and ValueStr.endswith('\"'):\n        Result = Str2Bytes(ValueStr, Length)\n    else:\n        Result = Val2Bytes(self.EvaluateExpress(ValueStr), Length)\n    return Result",
            "def ValueToList(self, ValueStr, Length):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if ValueStr[0] == '{':\n        Result = []\n        BinList = ValueStr[1:-1].split(',')\n        InBitField = False\n        LastInBitField = False\n        Value = 0\n        BitLen = 0\n        for Element in BinList:\n            InBitField = False\n            Each = Element.strip()\n            if len(Each) == 0:\n                pass\n            elif Each[0] in ['\"', \"'\"]:\n                Result.extend(list(bytearray(Each[1:-1], 'utf-8')))\n            elif ':' in Each:\n                Match = re.match('(.+):(\\\\d+)b', Each)\n                if Match is None:\n                    raise Exception(\"Invald value list format '%s' !\" % Each)\n                InBitField = True\n                CurrentBitLen = int(Match.group(2))\n                CurrentValue = (self.EvaluateExpress(Match.group(1)) & (1 << CurrentBitLen) - 1) << BitLen\n            else:\n                Result.append(self.EvaluateExpress(Each.strip()))\n            if InBitField:\n                Value += CurrentValue\n                BitLen += CurrentBitLen\n            if LastInBitField and (not InBitField or Element == BinList[-1]):\n                if BitLen % 8 != 0:\n                    raise Exception('Invald bit field length!')\n                Result.extend(Val2Bytes(Value, BitLen // 8))\n                Value = 0\n                BitLen = 0\n            LastInBitField = InBitField\n    elif ValueStr.startswith(\"'\") and ValueStr.endswith(\"'\"):\n        Result = Str2Bytes(ValueStr, Length)\n    elif ValueStr.startswith('\"') and ValueStr.endswith('\"'):\n        Result = Str2Bytes(ValueStr, Length)\n    else:\n        Result = Val2Bytes(self.EvaluateExpress(ValueStr), Length)\n    return Result"
        ]
    },
    {
        "func_name": "FormatListValue",
        "original": "def FormatListValue(self, ConfigDict):\n    Struct = ConfigDict['struct']\n    if Struct not in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n        return\n    dataarray = []\n    binlist = ConfigDict['value'][1:-1].split(',')\n    for each in binlist:\n        each = each.strip()\n        if each.startswith('0x'):\n            value = int(each, 16)\n        else:\n            value = int(each)\n        dataarray.append(value)\n    unit = int(Struct[4:]) / 8\n    if int(ConfigDict['length']) != unit * len(dataarray):\n        raise Exception(\"Array size is not proper for '%s' !\" % ConfigDict['cname'])\n    bytearray = []\n    for each in dataarray:\n        value = each\n        for loop in range(int(unit)):\n            bytearray.append('0x%02X' % (value & 255))\n            value = value >> 8\n    newvalue = '{' + ','.join(bytearray) + '}'\n    ConfigDict['value'] = newvalue\n    return ''",
        "mutated": [
            "def FormatListValue(self, ConfigDict):\n    if False:\n        i = 10\n    Struct = ConfigDict['struct']\n    if Struct not in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n        return\n    dataarray = []\n    binlist = ConfigDict['value'][1:-1].split(',')\n    for each in binlist:\n        each = each.strip()\n        if each.startswith('0x'):\n            value = int(each, 16)\n        else:\n            value = int(each)\n        dataarray.append(value)\n    unit = int(Struct[4:]) / 8\n    if int(ConfigDict['length']) != unit * len(dataarray):\n        raise Exception(\"Array size is not proper for '%s' !\" % ConfigDict['cname'])\n    bytearray = []\n    for each in dataarray:\n        value = each\n        for loop in range(int(unit)):\n            bytearray.append('0x%02X' % (value & 255))\n            value = value >> 8\n    newvalue = '{' + ','.join(bytearray) + '}'\n    ConfigDict['value'] = newvalue\n    return ''",
            "def FormatListValue(self, ConfigDict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Struct = ConfigDict['struct']\n    if Struct not in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n        return\n    dataarray = []\n    binlist = ConfigDict['value'][1:-1].split(',')\n    for each in binlist:\n        each = each.strip()\n        if each.startswith('0x'):\n            value = int(each, 16)\n        else:\n            value = int(each)\n        dataarray.append(value)\n    unit = int(Struct[4:]) / 8\n    if int(ConfigDict['length']) != unit * len(dataarray):\n        raise Exception(\"Array size is not proper for '%s' !\" % ConfigDict['cname'])\n    bytearray = []\n    for each in dataarray:\n        value = each\n        for loop in range(int(unit)):\n            bytearray.append('0x%02X' % (value & 255))\n            value = value >> 8\n    newvalue = '{' + ','.join(bytearray) + '}'\n    ConfigDict['value'] = newvalue\n    return ''",
            "def FormatListValue(self, ConfigDict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Struct = ConfigDict['struct']\n    if Struct not in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n        return\n    dataarray = []\n    binlist = ConfigDict['value'][1:-1].split(',')\n    for each in binlist:\n        each = each.strip()\n        if each.startswith('0x'):\n            value = int(each, 16)\n        else:\n            value = int(each)\n        dataarray.append(value)\n    unit = int(Struct[4:]) / 8\n    if int(ConfigDict['length']) != unit * len(dataarray):\n        raise Exception(\"Array size is not proper for '%s' !\" % ConfigDict['cname'])\n    bytearray = []\n    for each in dataarray:\n        value = each\n        for loop in range(int(unit)):\n            bytearray.append('0x%02X' % (value & 255))\n            value = value >> 8\n    newvalue = '{' + ','.join(bytearray) + '}'\n    ConfigDict['value'] = newvalue\n    return ''",
            "def FormatListValue(self, ConfigDict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Struct = ConfigDict['struct']\n    if Struct not in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n        return\n    dataarray = []\n    binlist = ConfigDict['value'][1:-1].split(',')\n    for each in binlist:\n        each = each.strip()\n        if each.startswith('0x'):\n            value = int(each, 16)\n        else:\n            value = int(each)\n        dataarray.append(value)\n    unit = int(Struct[4:]) / 8\n    if int(ConfigDict['length']) != unit * len(dataarray):\n        raise Exception(\"Array size is not proper for '%s' !\" % ConfigDict['cname'])\n    bytearray = []\n    for each in dataarray:\n        value = each\n        for loop in range(int(unit)):\n            bytearray.append('0x%02X' % (value & 255))\n            value = value >> 8\n    newvalue = '{' + ','.join(bytearray) + '}'\n    ConfigDict['value'] = newvalue\n    return ''",
            "def FormatListValue(self, ConfigDict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Struct = ConfigDict['struct']\n    if Struct not in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n        return\n    dataarray = []\n    binlist = ConfigDict['value'][1:-1].split(',')\n    for each in binlist:\n        each = each.strip()\n        if each.startswith('0x'):\n            value = int(each, 16)\n        else:\n            value = int(each)\n        dataarray.append(value)\n    unit = int(Struct[4:]) / 8\n    if int(ConfigDict['length']) != unit * len(dataarray):\n        raise Exception(\"Array size is not proper for '%s' !\" % ConfigDict['cname'])\n    bytearray = []\n    for each in dataarray:\n        value = each\n        for loop in range(int(unit)):\n            bytearray.append('0x%02X' % (value & 255))\n            value = value >> 8\n    newvalue = '{' + ','.join(bytearray) + '}'\n    ConfigDict['value'] = newvalue\n    return ''"
        ]
    },
    {
        "func_name": "ParseDscFile",
        "original": "def ParseDscFile(self, DscFile, FvDir):\n    Hardcode = False\n    AutoAlign = False\n    self._CfgItemList = []\n    self._CfgPageDict = {}\n    self._CfgBlkDict = {}\n    self._DscFile = DscFile\n    self._FvDir = FvDir\n    self._DscLines = []\n    self._BsfTempDict = {}\n    self._DscTime = os.path.getmtime(DscFile)\n    CfgDict = {}\n    IsDefSect = False\n    IsPcdSect = False\n    IsUpdSect = False\n    IsVpdSect = False\n    IsTmpSect = False\n    TemplateName = ''\n    IfStack = []\n    ElifStack = []\n    Error = 0\n    ConfigDict = {}\n    if type(DscFile) is list:\n        DscLines = DscFile\n        self._DscFile = '.'\n    else:\n        DscFd = open(DscFile, 'r')\n        DscLines = DscFd.readlines()\n        DscFd.close()\n        self._DscFile = DscFile\n    SkipLines = 0\n    MaxAlign = 32\n    SizeAlign = 0\n    Base = 0\n    while len(DscLines):\n        DscLine = DscLines.pop(0).strip()\n        if SkipLines == 0:\n            self._DscLines.append(DscLine)\n        else:\n            SkipLines = SkipLines - 1\n        if len(DscLine) == 0:\n            continue\n        Handle = False\n        Match = re.match('^\\\\[(.+)\\\\]', DscLine)\n        if Match is not None:\n            IsDefSect = False\n            IsPcdSect = False\n            IsVpdSect = False\n            IsUpdSect = False\n            IsTmpSect = False\n            SectionName = Match.group(1).lower()\n            if SectionName == 'Defines'.lower():\n                IsDefSect = True\n            if SectionName == 'PcdsFeatureFlag'.lower() or SectionName == 'PcdsFixedAtBuild'.lower():\n                IsPcdSect = True\n            elif SectionName == 'PcdsDynamicVpd.Tmp'.lower():\n                IsTmpSect = True\n            elif SectionName == 'PcdsDynamicVpd.Upd'.lower():\n                ConfigDict = {}\n                ConfigDict['header'] = 'ON'\n                ConfigDict['region'] = 'UPD'\n                ConfigDict['order'] = -1\n                ConfigDict['page'] = ''\n                ConfigDict['name'] = ''\n                ConfigDict['find'] = ''\n                ConfigDict['marker'] = ''\n                ConfigDict['struct'] = ''\n                ConfigDict['embed'] = ''\n                ConfigDict['comment'] = ''\n                ConfigDict['subreg'] = []\n                ConfigDict['condition'] = ''\n                ConfigDict['option'] = ''\n                IsUpdSect = True\n                Offset = 0\n        elif IsDefSect or IsPcdSect or IsUpdSect or IsVpdSect or IsTmpSect:\n            Match = False if DscLine[0] != '!' else True\n            if Match:\n                Match = re.match('^!(else|endif|ifdef|ifndef|if|elseif|include)\\\\s*(.+)?$', DscLine.split('#')[0])\n            Keyword = Match.group(1) if Match else ''\n            Remaining = Match.group(2) if Match else ''\n            Remaining = '' if Remaining is None else Remaining.strip()\n            if Keyword in ['if', 'elseif', 'ifdef', 'ifndef', 'include'] and (not Remaining):\n                raise Exception(\"ERROR: Expression is expected after '!if' or !elseif' for line '%s'\" % DscLine)\n            if Keyword == 'else':\n                if IfStack:\n                    IfStack[-1] = not IfStack[-1]\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!else' for line '%s'\" % DscLine)\n            elif Keyword == 'endif':\n                if IfStack:\n                    IfStack.pop()\n                    Level = ElifStack.pop()\n                    if Level > 0:\n                        del IfStack[-Level:]\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!endif' for line '%s'\" % DscLine)\n            elif Keyword == 'ifdef' or Keyword == 'ifndef':\n                Result = self.EvaulateIfdef(Remaining)\n                if Keyword == 'ifndef':\n                    Result = not Result\n                IfStack.append(Result)\n                ElifStack.append(0)\n            elif Keyword == 'if' or Keyword == 'elseif':\n                Result = self.EvaluateExpress(Remaining)\n                if Keyword == 'if':\n                    ElifStack.append(0)\n                    IfStack.append(Result)\n                elif IfStack:\n                    IfStack[-1] = not IfStack[-1]\n                    IfStack.append(Result)\n                    ElifStack[-1] = ElifStack[-1] + 1\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!elif' for line '%s'\" % DscLine)\n            else:\n                if IfStack:\n                    Handle = reduce(lambda x, y: x and y, IfStack)\n                else:\n                    Handle = True\n                if Handle:\n                    Match = re.match('!include\\\\s+(.+)', DscLine)\n                    if Match:\n                        IncludeFilePath = Match.group(1)\n                        IncludeFilePath = self.ExpandMacros(IncludeFilePath)\n                        PackagesPath = os.getenv('PACKAGES_PATH')\n                        if PackagesPath:\n                            for PackagePath in PackagesPath.split(os.pathsep):\n                                IncludeFilePathAbs = os.path.join(os.path.normpath(PackagePath), os.path.normpath(IncludeFilePath))\n                                if os.path.exists(IncludeFilePathAbs):\n                                    IncludeDsc = open(IncludeFilePathAbs, 'r')\n                                    break\n                        else:\n                            IncludeDsc = open(IncludeFilePath, 'r')\n                        if IncludeDsc == None:\n                            print(\"ERROR: Cannot open file '%s'\" % IncludeFilePath)\n                            raise SystemExit\n                        CurrentDscTime = os.path.getmtime(os.path.realpath(IncludeDsc.name))\n                        if CurrentDscTime > self._DscTime:\n                            self._DscTime = CurrentDscTime\n                        NewDscLines = IncludeDsc.readlines()\n                        IncludeDsc.close()\n                        DscLines = NewDscLines + DscLines\n                        del self._DscLines[-1]\n                        Offset = 0\n                    elif DscLine.startswith('!'):\n                        print(\"ERROR: Unrecognized directive for line '%s'\" % DscLine)\n                        raise SystemExit\n        if not Handle:\n            del self._DscLines[-1]\n            continue\n        if IsDefSect:\n            Match = re.match('^\\\\s*(?:DEFINE\\\\s+)*(\\\\w+)\\\\s*=\\\\s*(.+)', DscLine)\n            if Match:\n                self._MacroDict[Match.group(1)] = self.ExpandMacros(Match.group(2))\n                if self.Debug:\n                    print('INFO : DEFINE %s = [ %s ]' % (Match.group(1), self.ExpandMacros(Match.group(2))))\n        elif IsPcdSect:\n            Match = re.match('^\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\|\\\\s*(\\\\w+)', DscLine)\n            if Match:\n                self._PcdsDict[Match.group(1)] = Match.group(2)\n                if self.Debug:\n                    print('INFO : PCD %s = [ %s ]' % (Match.group(1), Match.group(2)))\n                i = 0\n                while i < len(BuildOptionPcd):\n                    Match = re.match('\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\=\\\\s*(\\\\w+)', BuildOptionPcd[i])\n                    if Match:\n                        self._PcdsDict[Match.group(1)] = Match.group(2)\n                    i += 1\n        elif IsTmpSect:\n            Match = re.match('^\\\\s*#\\\\s+(!BSF)\\\\s+DEFT:{(.+?):(START|END)}', DscLine)\n            if Match:\n                if Match.group(3) == 'START' and (not TemplateName):\n                    TemplateName = Match.group(2).strip()\n                    self._BsfTempDict[TemplateName] = []\n                if Match.group(3) == 'END' and TemplateName == Match.group(2).strip() and TemplateName:\n                    TemplateName = ''\n            elif TemplateName:\n                Match = re.match('^!include\\\\s*(.+)?$', DscLine)\n                if Match:\n                    continue\n                self._BsfTempDict[TemplateName].append(DscLine)\n        else:\n            Match = re.match('^\\\\s*#\\\\s+(!BSF|@Bsf|!HDR)\\\\s+(.+)', DscLine)\n            if Match:\n                Remaining = Match.group(2)\n                if Match.group(1) == '!BSF' or Match.group(1) == '@Bsf':\n                    Match = re.match('(?:^|.+\\\\s+)PAGES:{(.+?)}', Remaining)\n                    if Match:\n                        PageList = Match.group(1).split(',')\n                        for Page in PageList:\n                            Page = Page.strip()\n                            Match = re.match('(\\\\w+):\"(.+)\"', Page)\n                            if Match != None:\n                                self._CfgPageDict[Match.group(1)] = Match.group(2)\n                    Match = re.match('(?:^|.+\\\\s+)BLOCK:{NAME:\"(.+)\"\\\\s*,\\\\s*VER:\"(.+)\"\\\\s*}', Remaining)\n                    if Match:\n                        self._CfgBlkDict['name'] = Match.group(1)\n                        self._CfgBlkDict['ver'] = Match.group(2)\n                    for Key in self._BsfKeyList:\n                        Match = re.match('(?:^|.+\\\\s+)%s:{(.+?)}' % Key, Remaining)\n                        if Match:\n                            if Key in ['NAME', 'HELP', 'OPTION'] and Match.group(1).startswith('+'):\n                                ConfigDict[Key.lower()] += Match.group(1)[1:]\n                            else:\n                                ConfigDict[Key.lower()] = Match.group(1)\n                else:\n                    for Key in self._HdrKeyList:\n                        Match = re.match('(?:^|.+\\\\s+)%s:{(.+?)}' % Key, Remaining)\n                        if Match:\n                            ConfigDict[Key.lower()] = Match.group(1)\n            Match = re.match('^\\\\s*#\\\\s+@Prompt\\\\s+(.+)', DscLine)\n            if Match:\n                ConfigDict['name'] = Match.group(1)\n            Match = re.match('^\\\\s*#\\\\s*@ValidList\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*', DscLine)\n            if Match:\n                if Match.group(2).strip() in self._BuidinOption:\n                    ConfigDict['option'] = Match.group(2).strip()\n                else:\n                    OptionValueList = Match.group(2).split(',')\n                    OptionStringList = Match.group(3).split(',')\n                    Index = 0\n                    for Option in OptionValueList:\n                        Option = Option.strip()\n                        ConfigDict['option'] = ConfigDict['option'] + str(Option) + ':' + OptionStringList[Index].strip()\n                        Index += 1\n                        if Index in range(len(OptionValueList)):\n                            ConfigDict['option'] += ', '\n                ConfigDict['type'] = 'Combo'\n            Match = re.match('^\\\\s*#\\\\s*@ValidRange\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*-\\\\s*(.+)\\\\s*', DscLine)\n            if Match:\n                if '0x' in Match.group(2) or '0x' in Match.group(3):\n                    ConfigDict['type'] = 'EditNum, HEX, (%s,%s)' % (Match.group(2), Match.group(3))\n                else:\n                    ConfigDict['type'] = 'EditNum, DEC, (%s,%s)' % (Match.group(2), Match.group(3))\n            Match = re.match('^\\\\s*##\\\\s+(.+)', DscLine)\n            if Match:\n                ConfigDict['help'] = Match.group(1)\n            if IsUpdSect:\n                Match = re.match('^([_a-zA-Z0-9]+).([_a-zA-Z0-9]+)\\\\s*\\\\|\\\\s*(0x[0-9A-F]+|\\\\*)\\\\s*\\\\|\\\\s*(\\\\d+|0x[0-9a-fA-F]+)\\\\s*\\\\|\\\\s*(.+)', DscLine)\n            else:\n                Match = re.match('^([_a-zA-Z0-9]+).([_a-zA-Z0-9]+)\\\\s*\\\\|\\\\s*(0x[0-9A-F]+)(?:\\\\s*\\\\|\\\\s*(.+))?', DscLine)\n            if Match:\n                ConfigDict['space'] = Match.group(1)\n                ConfigDict['cname'] = Match.group(2)\n                if Match.group(3) != '*':\n                    Hardcode = True\n                    Offset = int(Match.group(3), 16)\n                else:\n                    AutoAlign = True\n                if Hardcode and AutoAlign:\n                    print('Hardcode and auto-align mixed mode is not supported by GenCfgOpt')\n                    raise SystemExit\n                ConfigDict['offset'] = Offset\n                if ConfigDict['order'] == -1:\n                    ConfigDict['order'] = ConfigDict['offset'] << 8\n                else:\n                    (Major, Minor) = ConfigDict['order'].split('.')\n                    ConfigDict['order'] = (int(Major, 16) << 8) + int(Minor, 16)\n                if IsUpdSect:\n                    Value = Match.group(5).strip()\n                    if Match.group(4).startswith('0x'):\n                        Length = int(Match.group(4), 16)\n                    else:\n                        Length = int(Match.group(4))\n                    Offset += Length\n                else:\n                    Value = Match.group(4)\n                    if Value is None:\n                        Value = ''\n                    Value = Value.strip()\n                    if '|' in Value:\n                        Match = re.match('^.+\\\\s*\\\\|\\\\s*(.+)', Value)\n                        if Match:\n                            Value = Match.group(1)\n                    Length = -1\n                ConfigDict['length'] = Length\n                Match = re.match('\\\\$\\\\((\\\\w+)\\\\)', Value)\n                if Match:\n                    if Match.group(1) in self._MacroDict:\n                        Value = self._MacroDict[Match.group(1)]\n                ConfigDict['value'] = Value\n                if len(Value) > 0 and Value[0] == '{':\n                    Value = self.FormatListValue(ConfigDict)\n                if ConfigDict['name'] == '':\n                    ConfigDict['bsfname'] = ''\n                    ConfigDict['help'] = ''\n                    ConfigDict['type'] = ''\n                    ConfigDict['option'] = ''\n                if IsUpdSect and AutoAlign:\n                    ItemLength = int(ConfigDict['length'])\n                    ItemOffset = int(ConfigDict['offset'])\n                    ItemStruct = ConfigDict['struct']\n                    Unit = 1\n                    if ItemLength in [1, 2, 4, 8] and (not ConfigDict['value'].startswith('{')):\n                        Unit = ItemLength\n                        if Unit == 8:\n                            MaxAlign = 64\n                            SizeAlign = 8\n                    if ItemStruct != '':\n                        UnitDict = {'UINT8': 1, 'UINT16': 2, 'UINT32': 4, 'UINT64': 8}\n                        if ItemStruct in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n                            Unit = UnitDict[ItemStruct]\n                            if Unit == 8:\n                                MaxAlign = 64\n                            SizeAlign = max(SizeAlign, Unit)\n                    if ConfigDict['embed'].find(':START') != -1:\n                        Base = ItemOffset\n                    SubOffset = ItemOffset - Base\n                    SubRemainder = SubOffset % Unit\n                    if SubRemainder:\n                        Diff = Unit - SubRemainder\n                        Offset = Offset + Diff\n                        ItemOffset = ItemOffset + Diff\n                    if ConfigDict['embed'].find(':END') != -1:\n                        Remainder = Offset % (MaxAlign / 8)\n                        if Remainder:\n                            Diff = int(MaxAlign / 8 - Remainder)\n                            Offset = Offset + Diff\n                            ItemOffset = ItemOffset + Diff\n                        MaxAlign = 32\n                    if ConfigDict['cname'] == 'UpdTerminator':\n                        Remainder = Offset % max(ItemLength / 8, 4, SizeAlign)\n                        Offset = Offset + ItemLength\n                        if Remainder:\n                            Diff = int(max(ItemLength / 8, 4, SizeAlign) - Remainder)\n                            ItemOffset = ItemOffset + Diff\n                    ConfigDict['offset'] = ItemOffset\n                self._CfgItemList.append(ConfigDict.copy())\n                ConfigDict['name'] = ''\n                ConfigDict['find'] = ''\n                ConfigDict['struct'] = ''\n                ConfigDict['embed'] = ''\n                ConfigDict['comment'] = ''\n                ConfigDict['marker'] = ''\n                ConfigDict['order'] = -1\n                ConfigDict['subreg'] = []\n                ConfigDict['option'] = ''\n            else:\n                Match = re.match('^\\\\s*#\\\\s+(!BSF|@Bsf)\\\\s+FIELD:{(.+):(\\\\d+)([Bb])?}', DscLine)\n                if Match:\n                    SubCfgDict = ConfigDict.copy()\n                    if Match.group(4) == None or Match.group(4) == 'B':\n                        UnitBitLen = 8\n                    elif Match.group(4) == 'b':\n                        UnitBitLen = 1\n                    else:\n                        print(\"ERROR: Invalide BSF FIELD length for line '%s'\" % DscLine)\n                        raise SystemExit\n                    SubCfgDict['cname'] = Match.group(2)\n                    SubCfgDict['bitlength'] = int(Match.group(3)) * UnitBitLen\n                    if SubCfgDict['bitlength'] > 0:\n                        LastItem = self._CfgItemList[-1]\n                        if len(LastItem['subreg']) == 0:\n                            SubOffset = 0\n                        else:\n                            SubOffset = LastItem['subreg'][-1]['bitoffset'] + LastItem['subreg'][-1]['bitlength']\n                        SubCfgDict['bitoffset'] = SubOffset\n                        LastItem['subreg'].append(SubCfgDict.copy())\n                    ConfigDict['name'] = ''\n    return Error",
        "mutated": [
            "def ParseDscFile(self, DscFile, FvDir):\n    if False:\n        i = 10\n    Hardcode = False\n    AutoAlign = False\n    self._CfgItemList = []\n    self._CfgPageDict = {}\n    self._CfgBlkDict = {}\n    self._DscFile = DscFile\n    self._FvDir = FvDir\n    self._DscLines = []\n    self._BsfTempDict = {}\n    self._DscTime = os.path.getmtime(DscFile)\n    CfgDict = {}\n    IsDefSect = False\n    IsPcdSect = False\n    IsUpdSect = False\n    IsVpdSect = False\n    IsTmpSect = False\n    TemplateName = ''\n    IfStack = []\n    ElifStack = []\n    Error = 0\n    ConfigDict = {}\n    if type(DscFile) is list:\n        DscLines = DscFile\n        self._DscFile = '.'\n    else:\n        DscFd = open(DscFile, 'r')\n        DscLines = DscFd.readlines()\n        DscFd.close()\n        self._DscFile = DscFile\n    SkipLines = 0\n    MaxAlign = 32\n    SizeAlign = 0\n    Base = 0\n    while len(DscLines):\n        DscLine = DscLines.pop(0).strip()\n        if SkipLines == 0:\n            self._DscLines.append(DscLine)\n        else:\n            SkipLines = SkipLines - 1\n        if len(DscLine) == 0:\n            continue\n        Handle = False\n        Match = re.match('^\\\\[(.+)\\\\]', DscLine)\n        if Match is not None:\n            IsDefSect = False\n            IsPcdSect = False\n            IsVpdSect = False\n            IsUpdSect = False\n            IsTmpSect = False\n            SectionName = Match.group(1).lower()\n            if SectionName == 'Defines'.lower():\n                IsDefSect = True\n            if SectionName == 'PcdsFeatureFlag'.lower() or SectionName == 'PcdsFixedAtBuild'.lower():\n                IsPcdSect = True\n            elif SectionName == 'PcdsDynamicVpd.Tmp'.lower():\n                IsTmpSect = True\n            elif SectionName == 'PcdsDynamicVpd.Upd'.lower():\n                ConfigDict = {}\n                ConfigDict['header'] = 'ON'\n                ConfigDict['region'] = 'UPD'\n                ConfigDict['order'] = -1\n                ConfigDict['page'] = ''\n                ConfigDict['name'] = ''\n                ConfigDict['find'] = ''\n                ConfigDict['marker'] = ''\n                ConfigDict['struct'] = ''\n                ConfigDict['embed'] = ''\n                ConfigDict['comment'] = ''\n                ConfigDict['subreg'] = []\n                ConfigDict['condition'] = ''\n                ConfigDict['option'] = ''\n                IsUpdSect = True\n                Offset = 0\n        elif IsDefSect or IsPcdSect or IsUpdSect or IsVpdSect or IsTmpSect:\n            Match = False if DscLine[0] != '!' else True\n            if Match:\n                Match = re.match('^!(else|endif|ifdef|ifndef|if|elseif|include)\\\\s*(.+)?$', DscLine.split('#')[0])\n            Keyword = Match.group(1) if Match else ''\n            Remaining = Match.group(2) if Match else ''\n            Remaining = '' if Remaining is None else Remaining.strip()\n            if Keyword in ['if', 'elseif', 'ifdef', 'ifndef', 'include'] and (not Remaining):\n                raise Exception(\"ERROR: Expression is expected after '!if' or !elseif' for line '%s'\" % DscLine)\n            if Keyword == 'else':\n                if IfStack:\n                    IfStack[-1] = not IfStack[-1]\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!else' for line '%s'\" % DscLine)\n            elif Keyword == 'endif':\n                if IfStack:\n                    IfStack.pop()\n                    Level = ElifStack.pop()\n                    if Level > 0:\n                        del IfStack[-Level:]\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!endif' for line '%s'\" % DscLine)\n            elif Keyword == 'ifdef' or Keyword == 'ifndef':\n                Result = self.EvaulateIfdef(Remaining)\n                if Keyword == 'ifndef':\n                    Result = not Result\n                IfStack.append(Result)\n                ElifStack.append(0)\n            elif Keyword == 'if' or Keyword == 'elseif':\n                Result = self.EvaluateExpress(Remaining)\n                if Keyword == 'if':\n                    ElifStack.append(0)\n                    IfStack.append(Result)\n                elif IfStack:\n                    IfStack[-1] = not IfStack[-1]\n                    IfStack.append(Result)\n                    ElifStack[-1] = ElifStack[-1] + 1\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!elif' for line '%s'\" % DscLine)\n            else:\n                if IfStack:\n                    Handle = reduce(lambda x, y: x and y, IfStack)\n                else:\n                    Handle = True\n                if Handle:\n                    Match = re.match('!include\\\\s+(.+)', DscLine)\n                    if Match:\n                        IncludeFilePath = Match.group(1)\n                        IncludeFilePath = self.ExpandMacros(IncludeFilePath)\n                        PackagesPath = os.getenv('PACKAGES_PATH')\n                        if PackagesPath:\n                            for PackagePath in PackagesPath.split(os.pathsep):\n                                IncludeFilePathAbs = os.path.join(os.path.normpath(PackagePath), os.path.normpath(IncludeFilePath))\n                                if os.path.exists(IncludeFilePathAbs):\n                                    IncludeDsc = open(IncludeFilePathAbs, 'r')\n                                    break\n                        else:\n                            IncludeDsc = open(IncludeFilePath, 'r')\n                        if IncludeDsc == None:\n                            print(\"ERROR: Cannot open file '%s'\" % IncludeFilePath)\n                            raise SystemExit\n                        CurrentDscTime = os.path.getmtime(os.path.realpath(IncludeDsc.name))\n                        if CurrentDscTime > self._DscTime:\n                            self._DscTime = CurrentDscTime\n                        NewDscLines = IncludeDsc.readlines()\n                        IncludeDsc.close()\n                        DscLines = NewDscLines + DscLines\n                        del self._DscLines[-1]\n                        Offset = 0\n                    elif DscLine.startswith('!'):\n                        print(\"ERROR: Unrecognized directive for line '%s'\" % DscLine)\n                        raise SystemExit\n        if not Handle:\n            del self._DscLines[-1]\n            continue\n        if IsDefSect:\n            Match = re.match('^\\\\s*(?:DEFINE\\\\s+)*(\\\\w+)\\\\s*=\\\\s*(.+)', DscLine)\n            if Match:\n                self._MacroDict[Match.group(1)] = self.ExpandMacros(Match.group(2))\n                if self.Debug:\n                    print('INFO : DEFINE %s = [ %s ]' % (Match.group(1), self.ExpandMacros(Match.group(2))))\n        elif IsPcdSect:\n            Match = re.match('^\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\|\\\\s*(\\\\w+)', DscLine)\n            if Match:\n                self._PcdsDict[Match.group(1)] = Match.group(2)\n                if self.Debug:\n                    print('INFO : PCD %s = [ %s ]' % (Match.group(1), Match.group(2)))\n                i = 0\n                while i < len(BuildOptionPcd):\n                    Match = re.match('\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\=\\\\s*(\\\\w+)', BuildOptionPcd[i])\n                    if Match:\n                        self._PcdsDict[Match.group(1)] = Match.group(2)\n                    i += 1\n        elif IsTmpSect:\n            Match = re.match('^\\\\s*#\\\\s+(!BSF)\\\\s+DEFT:{(.+?):(START|END)}', DscLine)\n            if Match:\n                if Match.group(3) == 'START' and (not TemplateName):\n                    TemplateName = Match.group(2).strip()\n                    self._BsfTempDict[TemplateName] = []\n                if Match.group(3) == 'END' and TemplateName == Match.group(2).strip() and TemplateName:\n                    TemplateName = ''\n            elif TemplateName:\n                Match = re.match('^!include\\\\s*(.+)?$', DscLine)\n                if Match:\n                    continue\n                self._BsfTempDict[TemplateName].append(DscLine)\n        else:\n            Match = re.match('^\\\\s*#\\\\s+(!BSF|@Bsf|!HDR)\\\\s+(.+)', DscLine)\n            if Match:\n                Remaining = Match.group(2)\n                if Match.group(1) == '!BSF' or Match.group(1) == '@Bsf':\n                    Match = re.match('(?:^|.+\\\\s+)PAGES:{(.+?)}', Remaining)\n                    if Match:\n                        PageList = Match.group(1).split(',')\n                        for Page in PageList:\n                            Page = Page.strip()\n                            Match = re.match('(\\\\w+):\"(.+)\"', Page)\n                            if Match != None:\n                                self._CfgPageDict[Match.group(1)] = Match.group(2)\n                    Match = re.match('(?:^|.+\\\\s+)BLOCK:{NAME:\"(.+)\"\\\\s*,\\\\s*VER:\"(.+)\"\\\\s*}', Remaining)\n                    if Match:\n                        self._CfgBlkDict['name'] = Match.group(1)\n                        self._CfgBlkDict['ver'] = Match.group(2)\n                    for Key in self._BsfKeyList:\n                        Match = re.match('(?:^|.+\\\\s+)%s:{(.+?)}' % Key, Remaining)\n                        if Match:\n                            if Key in ['NAME', 'HELP', 'OPTION'] and Match.group(1).startswith('+'):\n                                ConfigDict[Key.lower()] += Match.group(1)[1:]\n                            else:\n                                ConfigDict[Key.lower()] = Match.group(1)\n                else:\n                    for Key in self._HdrKeyList:\n                        Match = re.match('(?:^|.+\\\\s+)%s:{(.+?)}' % Key, Remaining)\n                        if Match:\n                            ConfigDict[Key.lower()] = Match.group(1)\n            Match = re.match('^\\\\s*#\\\\s+@Prompt\\\\s+(.+)', DscLine)\n            if Match:\n                ConfigDict['name'] = Match.group(1)\n            Match = re.match('^\\\\s*#\\\\s*@ValidList\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*', DscLine)\n            if Match:\n                if Match.group(2).strip() in self._BuidinOption:\n                    ConfigDict['option'] = Match.group(2).strip()\n                else:\n                    OptionValueList = Match.group(2).split(',')\n                    OptionStringList = Match.group(3).split(',')\n                    Index = 0\n                    for Option in OptionValueList:\n                        Option = Option.strip()\n                        ConfigDict['option'] = ConfigDict['option'] + str(Option) + ':' + OptionStringList[Index].strip()\n                        Index += 1\n                        if Index in range(len(OptionValueList)):\n                            ConfigDict['option'] += ', '\n                ConfigDict['type'] = 'Combo'\n            Match = re.match('^\\\\s*#\\\\s*@ValidRange\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*-\\\\s*(.+)\\\\s*', DscLine)\n            if Match:\n                if '0x' in Match.group(2) or '0x' in Match.group(3):\n                    ConfigDict['type'] = 'EditNum, HEX, (%s,%s)' % (Match.group(2), Match.group(3))\n                else:\n                    ConfigDict['type'] = 'EditNum, DEC, (%s,%s)' % (Match.group(2), Match.group(3))\n            Match = re.match('^\\\\s*##\\\\s+(.+)', DscLine)\n            if Match:\n                ConfigDict['help'] = Match.group(1)\n            if IsUpdSect:\n                Match = re.match('^([_a-zA-Z0-9]+).([_a-zA-Z0-9]+)\\\\s*\\\\|\\\\s*(0x[0-9A-F]+|\\\\*)\\\\s*\\\\|\\\\s*(\\\\d+|0x[0-9a-fA-F]+)\\\\s*\\\\|\\\\s*(.+)', DscLine)\n            else:\n                Match = re.match('^([_a-zA-Z0-9]+).([_a-zA-Z0-9]+)\\\\s*\\\\|\\\\s*(0x[0-9A-F]+)(?:\\\\s*\\\\|\\\\s*(.+))?', DscLine)\n            if Match:\n                ConfigDict['space'] = Match.group(1)\n                ConfigDict['cname'] = Match.group(2)\n                if Match.group(3) != '*':\n                    Hardcode = True\n                    Offset = int(Match.group(3), 16)\n                else:\n                    AutoAlign = True\n                if Hardcode and AutoAlign:\n                    print('Hardcode and auto-align mixed mode is not supported by GenCfgOpt')\n                    raise SystemExit\n                ConfigDict['offset'] = Offset\n                if ConfigDict['order'] == -1:\n                    ConfigDict['order'] = ConfigDict['offset'] << 8\n                else:\n                    (Major, Minor) = ConfigDict['order'].split('.')\n                    ConfigDict['order'] = (int(Major, 16) << 8) + int(Minor, 16)\n                if IsUpdSect:\n                    Value = Match.group(5).strip()\n                    if Match.group(4).startswith('0x'):\n                        Length = int(Match.group(4), 16)\n                    else:\n                        Length = int(Match.group(4))\n                    Offset += Length\n                else:\n                    Value = Match.group(4)\n                    if Value is None:\n                        Value = ''\n                    Value = Value.strip()\n                    if '|' in Value:\n                        Match = re.match('^.+\\\\s*\\\\|\\\\s*(.+)', Value)\n                        if Match:\n                            Value = Match.group(1)\n                    Length = -1\n                ConfigDict['length'] = Length\n                Match = re.match('\\\\$\\\\((\\\\w+)\\\\)', Value)\n                if Match:\n                    if Match.group(1) in self._MacroDict:\n                        Value = self._MacroDict[Match.group(1)]\n                ConfigDict['value'] = Value\n                if len(Value) > 0 and Value[0] == '{':\n                    Value = self.FormatListValue(ConfigDict)\n                if ConfigDict['name'] == '':\n                    ConfigDict['bsfname'] = ''\n                    ConfigDict['help'] = ''\n                    ConfigDict['type'] = ''\n                    ConfigDict['option'] = ''\n                if IsUpdSect and AutoAlign:\n                    ItemLength = int(ConfigDict['length'])\n                    ItemOffset = int(ConfigDict['offset'])\n                    ItemStruct = ConfigDict['struct']\n                    Unit = 1\n                    if ItemLength in [1, 2, 4, 8] and (not ConfigDict['value'].startswith('{')):\n                        Unit = ItemLength\n                        if Unit == 8:\n                            MaxAlign = 64\n                            SizeAlign = 8\n                    if ItemStruct != '':\n                        UnitDict = {'UINT8': 1, 'UINT16': 2, 'UINT32': 4, 'UINT64': 8}\n                        if ItemStruct in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n                            Unit = UnitDict[ItemStruct]\n                            if Unit == 8:\n                                MaxAlign = 64\n                            SizeAlign = max(SizeAlign, Unit)\n                    if ConfigDict['embed'].find(':START') != -1:\n                        Base = ItemOffset\n                    SubOffset = ItemOffset - Base\n                    SubRemainder = SubOffset % Unit\n                    if SubRemainder:\n                        Diff = Unit - SubRemainder\n                        Offset = Offset + Diff\n                        ItemOffset = ItemOffset + Diff\n                    if ConfigDict['embed'].find(':END') != -1:\n                        Remainder = Offset % (MaxAlign / 8)\n                        if Remainder:\n                            Diff = int(MaxAlign / 8 - Remainder)\n                            Offset = Offset + Diff\n                            ItemOffset = ItemOffset + Diff\n                        MaxAlign = 32\n                    if ConfigDict['cname'] == 'UpdTerminator':\n                        Remainder = Offset % max(ItemLength / 8, 4, SizeAlign)\n                        Offset = Offset + ItemLength\n                        if Remainder:\n                            Diff = int(max(ItemLength / 8, 4, SizeAlign) - Remainder)\n                            ItemOffset = ItemOffset + Diff\n                    ConfigDict['offset'] = ItemOffset\n                self._CfgItemList.append(ConfigDict.copy())\n                ConfigDict['name'] = ''\n                ConfigDict['find'] = ''\n                ConfigDict['struct'] = ''\n                ConfigDict['embed'] = ''\n                ConfigDict['comment'] = ''\n                ConfigDict['marker'] = ''\n                ConfigDict['order'] = -1\n                ConfigDict['subreg'] = []\n                ConfigDict['option'] = ''\n            else:\n                Match = re.match('^\\\\s*#\\\\s+(!BSF|@Bsf)\\\\s+FIELD:{(.+):(\\\\d+)([Bb])?}', DscLine)\n                if Match:\n                    SubCfgDict = ConfigDict.copy()\n                    if Match.group(4) == None or Match.group(4) == 'B':\n                        UnitBitLen = 8\n                    elif Match.group(4) == 'b':\n                        UnitBitLen = 1\n                    else:\n                        print(\"ERROR: Invalide BSF FIELD length for line '%s'\" % DscLine)\n                        raise SystemExit\n                    SubCfgDict['cname'] = Match.group(2)\n                    SubCfgDict['bitlength'] = int(Match.group(3)) * UnitBitLen\n                    if SubCfgDict['bitlength'] > 0:\n                        LastItem = self._CfgItemList[-1]\n                        if len(LastItem['subreg']) == 0:\n                            SubOffset = 0\n                        else:\n                            SubOffset = LastItem['subreg'][-1]['bitoffset'] + LastItem['subreg'][-1]['bitlength']\n                        SubCfgDict['bitoffset'] = SubOffset\n                        LastItem['subreg'].append(SubCfgDict.copy())\n                    ConfigDict['name'] = ''\n    return Error",
            "def ParseDscFile(self, DscFile, FvDir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Hardcode = False\n    AutoAlign = False\n    self._CfgItemList = []\n    self._CfgPageDict = {}\n    self._CfgBlkDict = {}\n    self._DscFile = DscFile\n    self._FvDir = FvDir\n    self._DscLines = []\n    self._BsfTempDict = {}\n    self._DscTime = os.path.getmtime(DscFile)\n    CfgDict = {}\n    IsDefSect = False\n    IsPcdSect = False\n    IsUpdSect = False\n    IsVpdSect = False\n    IsTmpSect = False\n    TemplateName = ''\n    IfStack = []\n    ElifStack = []\n    Error = 0\n    ConfigDict = {}\n    if type(DscFile) is list:\n        DscLines = DscFile\n        self._DscFile = '.'\n    else:\n        DscFd = open(DscFile, 'r')\n        DscLines = DscFd.readlines()\n        DscFd.close()\n        self._DscFile = DscFile\n    SkipLines = 0\n    MaxAlign = 32\n    SizeAlign = 0\n    Base = 0\n    while len(DscLines):\n        DscLine = DscLines.pop(0).strip()\n        if SkipLines == 0:\n            self._DscLines.append(DscLine)\n        else:\n            SkipLines = SkipLines - 1\n        if len(DscLine) == 0:\n            continue\n        Handle = False\n        Match = re.match('^\\\\[(.+)\\\\]', DscLine)\n        if Match is not None:\n            IsDefSect = False\n            IsPcdSect = False\n            IsVpdSect = False\n            IsUpdSect = False\n            IsTmpSect = False\n            SectionName = Match.group(1).lower()\n            if SectionName == 'Defines'.lower():\n                IsDefSect = True\n            if SectionName == 'PcdsFeatureFlag'.lower() or SectionName == 'PcdsFixedAtBuild'.lower():\n                IsPcdSect = True\n            elif SectionName == 'PcdsDynamicVpd.Tmp'.lower():\n                IsTmpSect = True\n            elif SectionName == 'PcdsDynamicVpd.Upd'.lower():\n                ConfigDict = {}\n                ConfigDict['header'] = 'ON'\n                ConfigDict['region'] = 'UPD'\n                ConfigDict['order'] = -1\n                ConfigDict['page'] = ''\n                ConfigDict['name'] = ''\n                ConfigDict['find'] = ''\n                ConfigDict['marker'] = ''\n                ConfigDict['struct'] = ''\n                ConfigDict['embed'] = ''\n                ConfigDict['comment'] = ''\n                ConfigDict['subreg'] = []\n                ConfigDict['condition'] = ''\n                ConfigDict['option'] = ''\n                IsUpdSect = True\n                Offset = 0\n        elif IsDefSect or IsPcdSect or IsUpdSect or IsVpdSect or IsTmpSect:\n            Match = False if DscLine[0] != '!' else True\n            if Match:\n                Match = re.match('^!(else|endif|ifdef|ifndef|if|elseif|include)\\\\s*(.+)?$', DscLine.split('#')[0])\n            Keyword = Match.group(1) if Match else ''\n            Remaining = Match.group(2) if Match else ''\n            Remaining = '' if Remaining is None else Remaining.strip()\n            if Keyword in ['if', 'elseif', 'ifdef', 'ifndef', 'include'] and (not Remaining):\n                raise Exception(\"ERROR: Expression is expected after '!if' or !elseif' for line '%s'\" % DscLine)\n            if Keyword == 'else':\n                if IfStack:\n                    IfStack[-1] = not IfStack[-1]\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!else' for line '%s'\" % DscLine)\n            elif Keyword == 'endif':\n                if IfStack:\n                    IfStack.pop()\n                    Level = ElifStack.pop()\n                    if Level > 0:\n                        del IfStack[-Level:]\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!endif' for line '%s'\" % DscLine)\n            elif Keyword == 'ifdef' or Keyword == 'ifndef':\n                Result = self.EvaulateIfdef(Remaining)\n                if Keyword == 'ifndef':\n                    Result = not Result\n                IfStack.append(Result)\n                ElifStack.append(0)\n            elif Keyword == 'if' or Keyword == 'elseif':\n                Result = self.EvaluateExpress(Remaining)\n                if Keyword == 'if':\n                    ElifStack.append(0)\n                    IfStack.append(Result)\n                elif IfStack:\n                    IfStack[-1] = not IfStack[-1]\n                    IfStack.append(Result)\n                    ElifStack[-1] = ElifStack[-1] + 1\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!elif' for line '%s'\" % DscLine)\n            else:\n                if IfStack:\n                    Handle = reduce(lambda x, y: x and y, IfStack)\n                else:\n                    Handle = True\n                if Handle:\n                    Match = re.match('!include\\\\s+(.+)', DscLine)\n                    if Match:\n                        IncludeFilePath = Match.group(1)\n                        IncludeFilePath = self.ExpandMacros(IncludeFilePath)\n                        PackagesPath = os.getenv('PACKAGES_PATH')\n                        if PackagesPath:\n                            for PackagePath in PackagesPath.split(os.pathsep):\n                                IncludeFilePathAbs = os.path.join(os.path.normpath(PackagePath), os.path.normpath(IncludeFilePath))\n                                if os.path.exists(IncludeFilePathAbs):\n                                    IncludeDsc = open(IncludeFilePathAbs, 'r')\n                                    break\n                        else:\n                            IncludeDsc = open(IncludeFilePath, 'r')\n                        if IncludeDsc == None:\n                            print(\"ERROR: Cannot open file '%s'\" % IncludeFilePath)\n                            raise SystemExit\n                        CurrentDscTime = os.path.getmtime(os.path.realpath(IncludeDsc.name))\n                        if CurrentDscTime > self._DscTime:\n                            self._DscTime = CurrentDscTime\n                        NewDscLines = IncludeDsc.readlines()\n                        IncludeDsc.close()\n                        DscLines = NewDscLines + DscLines\n                        del self._DscLines[-1]\n                        Offset = 0\n                    elif DscLine.startswith('!'):\n                        print(\"ERROR: Unrecognized directive for line '%s'\" % DscLine)\n                        raise SystemExit\n        if not Handle:\n            del self._DscLines[-1]\n            continue\n        if IsDefSect:\n            Match = re.match('^\\\\s*(?:DEFINE\\\\s+)*(\\\\w+)\\\\s*=\\\\s*(.+)', DscLine)\n            if Match:\n                self._MacroDict[Match.group(1)] = self.ExpandMacros(Match.group(2))\n                if self.Debug:\n                    print('INFO : DEFINE %s = [ %s ]' % (Match.group(1), self.ExpandMacros(Match.group(2))))\n        elif IsPcdSect:\n            Match = re.match('^\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\|\\\\s*(\\\\w+)', DscLine)\n            if Match:\n                self._PcdsDict[Match.group(1)] = Match.group(2)\n                if self.Debug:\n                    print('INFO : PCD %s = [ %s ]' % (Match.group(1), Match.group(2)))\n                i = 0\n                while i < len(BuildOptionPcd):\n                    Match = re.match('\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\=\\\\s*(\\\\w+)', BuildOptionPcd[i])\n                    if Match:\n                        self._PcdsDict[Match.group(1)] = Match.group(2)\n                    i += 1\n        elif IsTmpSect:\n            Match = re.match('^\\\\s*#\\\\s+(!BSF)\\\\s+DEFT:{(.+?):(START|END)}', DscLine)\n            if Match:\n                if Match.group(3) == 'START' and (not TemplateName):\n                    TemplateName = Match.group(2).strip()\n                    self._BsfTempDict[TemplateName] = []\n                if Match.group(3) == 'END' and TemplateName == Match.group(2).strip() and TemplateName:\n                    TemplateName = ''\n            elif TemplateName:\n                Match = re.match('^!include\\\\s*(.+)?$', DscLine)\n                if Match:\n                    continue\n                self._BsfTempDict[TemplateName].append(DscLine)\n        else:\n            Match = re.match('^\\\\s*#\\\\s+(!BSF|@Bsf|!HDR)\\\\s+(.+)', DscLine)\n            if Match:\n                Remaining = Match.group(2)\n                if Match.group(1) == '!BSF' or Match.group(1) == '@Bsf':\n                    Match = re.match('(?:^|.+\\\\s+)PAGES:{(.+?)}', Remaining)\n                    if Match:\n                        PageList = Match.group(1).split(',')\n                        for Page in PageList:\n                            Page = Page.strip()\n                            Match = re.match('(\\\\w+):\"(.+)\"', Page)\n                            if Match != None:\n                                self._CfgPageDict[Match.group(1)] = Match.group(2)\n                    Match = re.match('(?:^|.+\\\\s+)BLOCK:{NAME:\"(.+)\"\\\\s*,\\\\s*VER:\"(.+)\"\\\\s*}', Remaining)\n                    if Match:\n                        self._CfgBlkDict['name'] = Match.group(1)\n                        self._CfgBlkDict['ver'] = Match.group(2)\n                    for Key in self._BsfKeyList:\n                        Match = re.match('(?:^|.+\\\\s+)%s:{(.+?)}' % Key, Remaining)\n                        if Match:\n                            if Key in ['NAME', 'HELP', 'OPTION'] and Match.group(1).startswith('+'):\n                                ConfigDict[Key.lower()] += Match.group(1)[1:]\n                            else:\n                                ConfigDict[Key.lower()] = Match.group(1)\n                else:\n                    for Key in self._HdrKeyList:\n                        Match = re.match('(?:^|.+\\\\s+)%s:{(.+?)}' % Key, Remaining)\n                        if Match:\n                            ConfigDict[Key.lower()] = Match.group(1)\n            Match = re.match('^\\\\s*#\\\\s+@Prompt\\\\s+(.+)', DscLine)\n            if Match:\n                ConfigDict['name'] = Match.group(1)\n            Match = re.match('^\\\\s*#\\\\s*@ValidList\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*', DscLine)\n            if Match:\n                if Match.group(2).strip() in self._BuidinOption:\n                    ConfigDict['option'] = Match.group(2).strip()\n                else:\n                    OptionValueList = Match.group(2).split(',')\n                    OptionStringList = Match.group(3).split(',')\n                    Index = 0\n                    for Option in OptionValueList:\n                        Option = Option.strip()\n                        ConfigDict['option'] = ConfigDict['option'] + str(Option) + ':' + OptionStringList[Index].strip()\n                        Index += 1\n                        if Index in range(len(OptionValueList)):\n                            ConfigDict['option'] += ', '\n                ConfigDict['type'] = 'Combo'\n            Match = re.match('^\\\\s*#\\\\s*@ValidRange\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*-\\\\s*(.+)\\\\s*', DscLine)\n            if Match:\n                if '0x' in Match.group(2) or '0x' in Match.group(3):\n                    ConfigDict['type'] = 'EditNum, HEX, (%s,%s)' % (Match.group(2), Match.group(3))\n                else:\n                    ConfigDict['type'] = 'EditNum, DEC, (%s,%s)' % (Match.group(2), Match.group(3))\n            Match = re.match('^\\\\s*##\\\\s+(.+)', DscLine)\n            if Match:\n                ConfigDict['help'] = Match.group(1)\n            if IsUpdSect:\n                Match = re.match('^([_a-zA-Z0-9]+).([_a-zA-Z0-9]+)\\\\s*\\\\|\\\\s*(0x[0-9A-F]+|\\\\*)\\\\s*\\\\|\\\\s*(\\\\d+|0x[0-9a-fA-F]+)\\\\s*\\\\|\\\\s*(.+)', DscLine)\n            else:\n                Match = re.match('^([_a-zA-Z0-9]+).([_a-zA-Z0-9]+)\\\\s*\\\\|\\\\s*(0x[0-9A-F]+)(?:\\\\s*\\\\|\\\\s*(.+))?', DscLine)\n            if Match:\n                ConfigDict['space'] = Match.group(1)\n                ConfigDict['cname'] = Match.group(2)\n                if Match.group(3) != '*':\n                    Hardcode = True\n                    Offset = int(Match.group(3), 16)\n                else:\n                    AutoAlign = True\n                if Hardcode and AutoAlign:\n                    print('Hardcode and auto-align mixed mode is not supported by GenCfgOpt')\n                    raise SystemExit\n                ConfigDict['offset'] = Offset\n                if ConfigDict['order'] == -1:\n                    ConfigDict['order'] = ConfigDict['offset'] << 8\n                else:\n                    (Major, Minor) = ConfigDict['order'].split('.')\n                    ConfigDict['order'] = (int(Major, 16) << 8) + int(Minor, 16)\n                if IsUpdSect:\n                    Value = Match.group(5).strip()\n                    if Match.group(4).startswith('0x'):\n                        Length = int(Match.group(4), 16)\n                    else:\n                        Length = int(Match.group(4))\n                    Offset += Length\n                else:\n                    Value = Match.group(4)\n                    if Value is None:\n                        Value = ''\n                    Value = Value.strip()\n                    if '|' in Value:\n                        Match = re.match('^.+\\\\s*\\\\|\\\\s*(.+)', Value)\n                        if Match:\n                            Value = Match.group(1)\n                    Length = -1\n                ConfigDict['length'] = Length\n                Match = re.match('\\\\$\\\\((\\\\w+)\\\\)', Value)\n                if Match:\n                    if Match.group(1) in self._MacroDict:\n                        Value = self._MacroDict[Match.group(1)]\n                ConfigDict['value'] = Value\n                if len(Value) > 0 and Value[0] == '{':\n                    Value = self.FormatListValue(ConfigDict)\n                if ConfigDict['name'] == '':\n                    ConfigDict['bsfname'] = ''\n                    ConfigDict['help'] = ''\n                    ConfigDict['type'] = ''\n                    ConfigDict['option'] = ''\n                if IsUpdSect and AutoAlign:\n                    ItemLength = int(ConfigDict['length'])\n                    ItemOffset = int(ConfigDict['offset'])\n                    ItemStruct = ConfigDict['struct']\n                    Unit = 1\n                    if ItemLength in [1, 2, 4, 8] and (not ConfigDict['value'].startswith('{')):\n                        Unit = ItemLength\n                        if Unit == 8:\n                            MaxAlign = 64\n                            SizeAlign = 8\n                    if ItemStruct != '':\n                        UnitDict = {'UINT8': 1, 'UINT16': 2, 'UINT32': 4, 'UINT64': 8}\n                        if ItemStruct in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n                            Unit = UnitDict[ItemStruct]\n                            if Unit == 8:\n                                MaxAlign = 64\n                            SizeAlign = max(SizeAlign, Unit)\n                    if ConfigDict['embed'].find(':START') != -1:\n                        Base = ItemOffset\n                    SubOffset = ItemOffset - Base\n                    SubRemainder = SubOffset % Unit\n                    if SubRemainder:\n                        Diff = Unit - SubRemainder\n                        Offset = Offset + Diff\n                        ItemOffset = ItemOffset + Diff\n                    if ConfigDict['embed'].find(':END') != -1:\n                        Remainder = Offset % (MaxAlign / 8)\n                        if Remainder:\n                            Diff = int(MaxAlign / 8 - Remainder)\n                            Offset = Offset + Diff\n                            ItemOffset = ItemOffset + Diff\n                        MaxAlign = 32\n                    if ConfigDict['cname'] == 'UpdTerminator':\n                        Remainder = Offset % max(ItemLength / 8, 4, SizeAlign)\n                        Offset = Offset + ItemLength\n                        if Remainder:\n                            Diff = int(max(ItemLength / 8, 4, SizeAlign) - Remainder)\n                            ItemOffset = ItemOffset + Diff\n                    ConfigDict['offset'] = ItemOffset\n                self._CfgItemList.append(ConfigDict.copy())\n                ConfigDict['name'] = ''\n                ConfigDict['find'] = ''\n                ConfigDict['struct'] = ''\n                ConfigDict['embed'] = ''\n                ConfigDict['comment'] = ''\n                ConfigDict['marker'] = ''\n                ConfigDict['order'] = -1\n                ConfigDict['subreg'] = []\n                ConfigDict['option'] = ''\n            else:\n                Match = re.match('^\\\\s*#\\\\s+(!BSF|@Bsf)\\\\s+FIELD:{(.+):(\\\\d+)([Bb])?}', DscLine)\n                if Match:\n                    SubCfgDict = ConfigDict.copy()\n                    if Match.group(4) == None or Match.group(4) == 'B':\n                        UnitBitLen = 8\n                    elif Match.group(4) == 'b':\n                        UnitBitLen = 1\n                    else:\n                        print(\"ERROR: Invalide BSF FIELD length for line '%s'\" % DscLine)\n                        raise SystemExit\n                    SubCfgDict['cname'] = Match.group(2)\n                    SubCfgDict['bitlength'] = int(Match.group(3)) * UnitBitLen\n                    if SubCfgDict['bitlength'] > 0:\n                        LastItem = self._CfgItemList[-1]\n                        if len(LastItem['subreg']) == 0:\n                            SubOffset = 0\n                        else:\n                            SubOffset = LastItem['subreg'][-1]['bitoffset'] + LastItem['subreg'][-1]['bitlength']\n                        SubCfgDict['bitoffset'] = SubOffset\n                        LastItem['subreg'].append(SubCfgDict.copy())\n                    ConfigDict['name'] = ''\n    return Error",
            "def ParseDscFile(self, DscFile, FvDir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Hardcode = False\n    AutoAlign = False\n    self._CfgItemList = []\n    self._CfgPageDict = {}\n    self._CfgBlkDict = {}\n    self._DscFile = DscFile\n    self._FvDir = FvDir\n    self._DscLines = []\n    self._BsfTempDict = {}\n    self._DscTime = os.path.getmtime(DscFile)\n    CfgDict = {}\n    IsDefSect = False\n    IsPcdSect = False\n    IsUpdSect = False\n    IsVpdSect = False\n    IsTmpSect = False\n    TemplateName = ''\n    IfStack = []\n    ElifStack = []\n    Error = 0\n    ConfigDict = {}\n    if type(DscFile) is list:\n        DscLines = DscFile\n        self._DscFile = '.'\n    else:\n        DscFd = open(DscFile, 'r')\n        DscLines = DscFd.readlines()\n        DscFd.close()\n        self._DscFile = DscFile\n    SkipLines = 0\n    MaxAlign = 32\n    SizeAlign = 0\n    Base = 0\n    while len(DscLines):\n        DscLine = DscLines.pop(0).strip()\n        if SkipLines == 0:\n            self._DscLines.append(DscLine)\n        else:\n            SkipLines = SkipLines - 1\n        if len(DscLine) == 0:\n            continue\n        Handle = False\n        Match = re.match('^\\\\[(.+)\\\\]', DscLine)\n        if Match is not None:\n            IsDefSect = False\n            IsPcdSect = False\n            IsVpdSect = False\n            IsUpdSect = False\n            IsTmpSect = False\n            SectionName = Match.group(1).lower()\n            if SectionName == 'Defines'.lower():\n                IsDefSect = True\n            if SectionName == 'PcdsFeatureFlag'.lower() or SectionName == 'PcdsFixedAtBuild'.lower():\n                IsPcdSect = True\n            elif SectionName == 'PcdsDynamicVpd.Tmp'.lower():\n                IsTmpSect = True\n            elif SectionName == 'PcdsDynamicVpd.Upd'.lower():\n                ConfigDict = {}\n                ConfigDict['header'] = 'ON'\n                ConfigDict['region'] = 'UPD'\n                ConfigDict['order'] = -1\n                ConfigDict['page'] = ''\n                ConfigDict['name'] = ''\n                ConfigDict['find'] = ''\n                ConfigDict['marker'] = ''\n                ConfigDict['struct'] = ''\n                ConfigDict['embed'] = ''\n                ConfigDict['comment'] = ''\n                ConfigDict['subreg'] = []\n                ConfigDict['condition'] = ''\n                ConfigDict['option'] = ''\n                IsUpdSect = True\n                Offset = 0\n        elif IsDefSect or IsPcdSect or IsUpdSect or IsVpdSect or IsTmpSect:\n            Match = False if DscLine[0] != '!' else True\n            if Match:\n                Match = re.match('^!(else|endif|ifdef|ifndef|if|elseif|include)\\\\s*(.+)?$', DscLine.split('#')[0])\n            Keyword = Match.group(1) if Match else ''\n            Remaining = Match.group(2) if Match else ''\n            Remaining = '' if Remaining is None else Remaining.strip()\n            if Keyword in ['if', 'elseif', 'ifdef', 'ifndef', 'include'] and (not Remaining):\n                raise Exception(\"ERROR: Expression is expected after '!if' or !elseif' for line '%s'\" % DscLine)\n            if Keyword == 'else':\n                if IfStack:\n                    IfStack[-1] = not IfStack[-1]\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!else' for line '%s'\" % DscLine)\n            elif Keyword == 'endif':\n                if IfStack:\n                    IfStack.pop()\n                    Level = ElifStack.pop()\n                    if Level > 0:\n                        del IfStack[-Level:]\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!endif' for line '%s'\" % DscLine)\n            elif Keyword == 'ifdef' or Keyword == 'ifndef':\n                Result = self.EvaulateIfdef(Remaining)\n                if Keyword == 'ifndef':\n                    Result = not Result\n                IfStack.append(Result)\n                ElifStack.append(0)\n            elif Keyword == 'if' or Keyword == 'elseif':\n                Result = self.EvaluateExpress(Remaining)\n                if Keyword == 'if':\n                    ElifStack.append(0)\n                    IfStack.append(Result)\n                elif IfStack:\n                    IfStack[-1] = not IfStack[-1]\n                    IfStack.append(Result)\n                    ElifStack[-1] = ElifStack[-1] + 1\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!elif' for line '%s'\" % DscLine)\n            else:\n                if IfStack:\n                    Handle = reduce(lambda x, y: x and y, IfStack)\n                else:\n                    Handle = True\n                if Handle:\n                    Match = re.match('!include\\\\s+(.+)', DscLine)\n                    if Match:\n                        IncludeFilePath = Match.group(1)\n                        IncludeFilePath = self.ExpandMacros(IncludeFilePath)\n                        PackagesPath = os.getenv('PACKAGES_PATH')\n                        if PackagesPath:\n                            for PackagePath in PackagesPath.split(os.pathsep):\n                                IncludeFilePathAbs = os.path.join(os.path.normpath(PackagePath), os.path.normpath(IncludeFilePath))\n                                if os.path.exists(IncludeFilePathAbs):\n                                    IncludeDsc = open(IncludeFilePathAbs, 'r')\n                                    break\n                        else:\n                            IncludeDsc = open(IncludeFilePath, 'r')\n                        if IncludeDsc == None:\n                            print(\"ERROR: Cannot open file '%s'\" % IncludeFilePath)\n                            raise SystemExit\n                        CurrentDscTime = os.path.getmtime(os.path.realpath(IncludeDsc.name))\n                        if CurrentDscTime > self._DscTime:\n                            self._DscTime = CurrentDscTime\n                        NewDscLines = IncludeDsc.readlines()\n                        IncludeDsc.close()\n                        DscLines = NewDscLines + DscLines\n                        del self._DscLines[-1]\n                        Offset = 0\n                    elif DscLine.startswith('!'):\n                        print(\"ERROR: Unrecognized directive for line '%s'\" % DscLine)\n                        raise SystemExit\n        if not Handle:\n            del self._DscLines[-1]\n            continue\n        if IsDefSect:\n            Match = re.match('^\\\\s*(?:DEFINE\\\\s+)*(\\\\w+)\\\\s*=\\\\s*(.+)', DscLine)\n            if Match:\n                self._MacroDict[Match.group(1)] = self.ExpandMacros(Match.group(2))\n                if self.Debug:\n                    print('INFO : DEFINE %s = [ %s ]' % (Match.group(1), self.ExpandMacros(Match.group(2))))\n        elif IsPcdSect:\n            Match = re.match('^\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\|\\\\s*(\\\\w+)', DscLine)\n            if Match:\n                self._PcdsDict[Match.group(1)] = Match.group(2)\n                if self.Debug:\n                    print('INFO : PCD %s = [ %s ]' % (Match.group(1), Match.group(2)))\n                i = 0\n                while i < len(BuildOptionPcd):\n                    Match = re.match('\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\=\\\\s*(\\\\w+)', BuildOptionPcd[i])\n                    if Match:\n                        self._PcdsDict[Match.group(1)] = Match.group(2)\n                    i += 1\n        elif IsTmpSect:\n            Match = re.match('^\\\\s*#\\\\s+(!BSF)\\\\s+DEFT:{(.+?):(START|END)}', DscLine)\n            if Match:\n                if Match.group(3) == 'START' and (not TemplateName):\n                    TemplateName = Match.group(2).strip()\n                    self._BsfTempDict[TemplateName] = []\n                if Match.group(3) == 'END' and TemplateName == Match.group(2).strip() and TemplateName:\n                    TemplateName = ''\n            elif TemplateName:\n                Match = re.match('^!include\\\\s*(.+)?$', DscLine)\n                if Match:\n                    continue\n                self._BsfTempDict[TemplateName].append(DscLine)\n        else:\n            Match = re.match('^\\\\s*#\\\\s+(!BSF|@Bsf|!HDR)\\\\s+(.+)', DscLine)\n            if Match:\n                Remaining = Match.group(2)\n                if Match.group(1) == '!BSF' or Match.group(1) == '@Bsf':\n                    Match = re.match('(?:^|.+\\\\s+)PAGES:{(.+?)}', Remaining)\n                    if Match:\n                        PageList = Match.group(1).split(',')\n                        for Page in PageList:\n                            Page = Page.strip()\n                            Match = re.match('(\\\\w+):\"(.+)\"', Page)\n                            if Match != None:\n                                self._CfgPageDict[Match.group(1)] = Match.group(2)\n                    Match = re.match('(?:^|.+\\\\s+)BLOCK:{NAME:\"(.+)\"\\\\s*,\\\\s*VER:\"(.+)\"\\\\s*}', Remaining)\n                    if Match:\n                        self._CfgBlkDict['name'] = Match.group(1)\n                        self._CfgBlkDict['ver'] = Match.group(2)\n                    for Key in self._BsfKeyList:\n                        Match = re.match('(?:^|.+\\\\s+)%s:{(.+?)}' % Key, Remaining)\n                        if Match:\n                            if Key in ['NAME', 'HELP', 'OPTION'] and Match.group(1).startswith('+'):\n                                ConfigDict[Key.lower()] += Match.group(1)[1:]\n                            else:\n                                ConfigDict[Key.lower()] = Match.group(1)\n                else:\n                    for Key in self._HdrKeyList:\n                        Match = re.match('(?:^|.+\\\\s+)%s:{(.+?)}' % Key, Remaining)\n                        if Match:\n                            ConfigDict[Key.lower()] = Match.group(1)\n            Match = re.match('^\\\\s*#\\\\s+@Prompt\\\\s+(.+)', DscLine)\n            if Match:\n                ConfigDict['name'] = Match.group(1)\n            Match = re.match('^\\\\s*#\\\\s*@ValidList\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*', DscLine)\n            if Match:\n                if Match.group(2).strip() in self._BuidinOption:\n                    ConfigDict['option'] = Match.group(2).strip()\n                else:\n                    OptionValueList = Match.group(2).split(',')\n                    OptionStringList = Match.group(3).split(',')\n                    Index = 0\n                    for Option in OptionValueList:\n                        Option = Option.strip()\n                        ConfigDict['option'] = ConfigDict['option'] + str(Option) + ':' + OptionStringList[Index].strip()\n                        Index += 1\n                        if Index in range(len(OptionValueList)):\n                            ConfigDict['option'] += ', '\n                ConfigDict['type'] = 'Combo'\n            Match = re.match('^\\\\s*#\\\\s*@ValidRange\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*-\\\\s*(.+)\\\\s*', DscLine)\n            if Match:\n                if '0x' in Match.group(2) or '0x' in Match.group(3):\n                    ConfigDict['type'] = 'EditNum, HEX, (%s,%s)' % (Match.group(2), Match.group(3))\n                else:\n                    ConfigDict['type'] = 'EditNum, DEC, (%s,%s)' % (Match.group(2), Match.group(3))\n            Match = re.match('^\\\\s*##\\\\s+(.+)', DscLine)\n            if Match:\n                ConfigDict['help'] = Match.group(1)\n            if IsUpdSect:\n                Match = re.match('^([_a-zA-Z0-9]+).([_a-zA-Z0-9]+)\\\\s*\\\\|\\\\s*(0x[0-9A-F]+|\\\\*)\\\\s*\\\\|\\\\s*(\\\\d+|0x[0-9a-fA-F]+)\\\\s*\\\\|\\\\s*(.+)', DscLine)\n            else:\n                Match = re.match('^([_a-zA-Z0-9]+).([_a-zA-Z0-9]+)\\\\s*\\\\|\\\\s*(0x[0-9A-F]+)(?:\\\\s*\\\\|\\\\s*(.+))?', DscLine)\n            if Match:\n                ConfigDict['space'] = Match.group(1)\n                ConfigDict['cname'] = Match.group(2)\n                if Match.group(3) != '*':\n                    Hardcode = True\n                    Offset = int(Match.group(3), 16)\n                else:\n                    AutoAlign = True\n                if Hardcode and AutoAlign:\n                    print('Hardcode and auto-align mixed mode is not supported by GenCfgOpt')\n                    raise SystemExit\n                ConfigDict['offset'] = Offset\n                if ConfigDict['order'] == -1:\n                    ConfigDict['order'] = ConfigDict['offset'] << 8\n                else:\n                    (Major, Minor) = ConfigDict['order'].split('.')\n                    ConfigDict['order'] = (int(Major, 16) << 8) + int(Minor, 16)\n                if IsUpdSect:\n                    Value = Match.group(5).strip()\n                    if Match.group(4).startswith('0x'):\n                        Length = int(Match.group(4), 16)\n                    else:\n                        Length = int(Match.group(4))\n                    Offset += Length\n                else:\n                    Value = Match.group(4)\n                    if Value is None:\n                        Value = ''\n                    Value = Value.strip()\n                    if '|' in Value:\n                        Match = re.match('^.+\\\\s*\\\\|\\\\s*(.+)', Value)\n                        if Match:\n                            Value = Match.group(1)\n                    Length = -1\n                ConfigDict['length'] = Length\n                Match = re.match('\\\\$\\\\((\\\\w+)\\\\)', Value)\n                if Match:\n                    if Match.group(1) in self._MacroDict:\n                        Value = self._MacroDict[Match.group(1)]\n                ConfigDict['value'] = Value\n                if len(Value) > 0 and Value[0] == '{':\n                    Value = self.FormatListValue(ConfigDict)\n                if ConfigDict['name'] == '':\n                    ConfigDict['bsfname'] = ''\n                    ConfigDict['help'] = ''\n                    ConfigDict['type'] = ''\n                    ConfigDict['option'] = ''\n                if IsUpdSect and AutoAlign:\n                    ItemLength = int(ConfigDict['length'])\n                    ItemOffset = int(ConfigDict['offset'])\n                    ItemStruct = ConfigDict['struct']\n                    Unit = 1\n                    if ItemLength in [1, 2, 4, 8] and (not ConfigDict['value'].startswith('{')):\n                        Unit = ItemLength\n                        if Unit == 8:\n                            MaxAlign = 64\n                            SizeAlign = 8\n                    if ItemStruct != '':\n                        UnitDict = {'UINT8': 1, 'UINT16': 2, 'UINT32': 4, 'UINT64': 8}\n                        if ItemStruct in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n                            Unit = UnitDict[ItemStruct]\n                            if Unit == 8:\n                                MaxAlign = 64\n                            SizeAlign = max(SizeAlign, Unit)\n                    if ConfigDict['embed'].find(':START') != -1:\n                        Base = ItemOffset\n                    SubOffset = ItemOffset - Base\n                    SubRemainder = SubOffset % Unit\n                    if SubRemainder:\n                        Diff = Unit - SubRemainder\n                        Offset = Offset + Diff\n                        ItemOffset = ItemOffset + Diff\n                    if ConfigDict['embed'].find(':END') != -1:\n                        Remainder = Offset % (MaxAlign / 8)\n                        if Remainder:\n                            Diff = int(MaxAlign / 8 - Remainder)\n                            Offset = Offset + Diff\n                            ItemOffset = ItemOffset + Diff\n                        MaxAlign = 32\n                    if ConfigDict['cname'] == 'UpdTerminator':\n                        Remainder = Offset % max(ItemLength / 8, 4, SizeAlign)\n                        Offset = Offset + ItemLength\n                        if Remainder:\n                            Diff = int(max(ItemLength / 8, 4, SizeAlign) - Remainder)\n                            ItemOffset = ItemOffset + Diff\n                    ConfigDict['offset'] = ItemOffset\n                self._CfgItemList.append(ConfigDict.copy())\n                ConfigDict['name'] = ''\n                ConfigDict['find'] = ''\n                ConfigDict['struct'] = ''\n                ConfigDict['embed'] = ''\n                ConfigDict['comment'] = ''\n                ConfigDict['marker'] = ''\n                ConfigDict['order'] = -1\n                ConfigDict['subreg'] = []\n                ConfigDict['option'] = ''\n            else:\n                Match = re.match('^\\\\s*#\\\\s+(!BSF|@Bsf)\\\\s+FIELD:{(.+):(\\\\d+)([Bb])?}', DscLine)\n                if Match:\n                    SubCfgDict = ConfigDict.copy()\n                    if Match.group(4) == None or Match.group(4) == 'B':\n                        UnitBitLen = 8\n                    elif Match.group(4) == 'b':\n                        UnitBitLen = 1\n                    else:\n                        print(\"ERROR: Invalide BSF FIELD length for line '%s'\" % DscLine)\n                        raise SystemExit\n                    SubCfgDict['cname'] = Match.group(2)\n                    SubCfgDict['bitlength'] = int(Match.group(3)) * UnitBitLen\n                    if SubCfgDict['bitlength'] > 0:\n                        LastItem = self._CfgItemList[-1]\n                        if len(LastItem['subreg']) == 0:\n                            SubOffset = 0\n                        else:\n                            SubOffset = LastItem['subreg'][-1]['bitoffset'] + LastItem['subreg'][-1]['bitlength']\n                        SubCfgDict['bitoffset'] = SubOffset\n                        LastItem['subreg'].append(SubCfgDict.copy())\n                    ConfigDict['name'] = ''\n    return Error",
            "def ParseDscFile(self, DscFile, FvDir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Hardcode = False\n    AutoAlign = False\n    self._CfgItemList = []\n    self._CfgPageDict = {}\n    self._CfgBlkDict = {}\n    self._DscFile = DscFile\n    self._FvDir = FvDir\n    self._DscLines = []\n    self._BsfTempDict = {}\n    self._DscTime = os.path.getmtime(DscFile)\n    CfgDict = {}\n    IsDefSect = False\n    IsPcdSect = False\n    IsUpdSect = False\n    IsVpdSect = False\n    IsTmpSect = False\n    TemplateName = ''\n    IfStack = []\n    ElifStack = []\n    Error = 0\n    ConfigDict = {}\n    if type(DscFile) is list:\n        DscLines = DscFile\n        self._DscFile = '.'\n    else:\n        DscFd = open(DscFile, 'r')\n        DscLines = DscFd.readlines()\n        DscFd.close()\n        self._DscFile = DscFile\n    SkipLines = 0\n    MaxAlign = 32\n    SizeAlign = 0\n    Base = 0\n    while len(DscLines):\n        DscLine = DscLines.pop(0).strip()\n        if SkipLines == 0:\n            self._DscLines.append(DscLine)\n        else:\n            SkipLines = SkipLines - 1\n        if len(DscLine) == 0:\n            continue\n        Handle = False\n        Match = re.match('^\\\\[(.+)\\\\]', DscLine)\n        if Match is not None:\n            IsDefSect = False\n            IsPcdSect = False\n            IsVpdSect = False\n            IsUpdSect = False\n            IsTmpSect = False\n            SectionName = Match.group(1).lower()\n            if SectionName == 'Defines'.lower():\n                IsDefSect = True\n            if SectionName == 'PcdsFeatureFlag'.lower() or SectionName == 'PcdsFixedAtBuild'.lower():\n                IsPcdSect = True\n            elif SectionName == 'PcdsDynamicVpd.Tmp'.lower():\n                IsTmpSect = True\n            elif SectionName == 'PcdsDynamicVpd.Upd'.lower():\n                ConfigDict = {}\n                ConfigDict['header'] = 'ON'\n                ConfigDict['region'] = 'UPD'\n                ConfigDict['order'] = -1\n                ConfigDict['page'] = ''\n                ConfigDict['name'] = ''\n                ConfigDict['find'] = ''\n                ConfigDict['marker'] = ''\n                ConfigDict['struct'] = ''\n                ConfigDict['embed'] = ''\n                ConfigDict['comment'] = ''\n                ConfigDict['subreg'] = []\n                ConfigDict['condition'] = ''\n                ConfigDict['option'] = ''\n                IsUpdSect = True\n                Offset = 0\n        elif IsDefSect or IsPcdSect or IsUpdSect or IsVpdSect or IsTmpSect:\n            Match = False if DscLine[0] != '!' else True\n            if Match:\n                Match = re.match('^!(else|endif|ifdef|ifndef|if|elseif|include)\\\\s*(.+)?$', DscLine.split('#')[0])\n            Keyword = Match.group(1) if Match else ''\n            Remaining = Match.group(2) if Match else ''\n            Remaining = '' if Remaining is None else Remaining.strip()\n            if Keyword in ['if', 'elseif', 'ifdef', 'ifndef', 'include'] and (not Remaining):\n                raise Exception(\"ERROR: Expression is expected after '!if' or !elseif' for line '%s'\" % DscLine)\n            if Keyword == 'else':\n                if IfStack:\n                    IfStack[-1] = not IfStack[-1]\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!else' for line '%s'\" % DscLine)\n            elif Keyword == 'endif':\n                if IfStack:\n                    IfStack.pop()\n                    Level = ElifStack.pop()\n                    if Level > 0:\n                        del IfStack[-Level:]\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!endif' for line '%s'\" % DscLine)\n            elif Keyword == 'ifdef' or Keyword == 'ifndef':\n                Result = self.EvaulateIfdef(Remaining)\n                if Keyword == 'ifndef':\n                    Result = not Result\n                IfStack.append(Result)\n                ElifStack.append(0)\n            elif Keyword == 'if' or Keyword == 'elseif':\n                Result = self.EvaluateExpress(Remaining)\n                if Keyword == 'if':\n                    ElifStack.append(0)\n                    IfStack.append(Result)\n                elif IfStack:\n                    IfStack[-1] = not IfStack[-1]\n                    IfStack.append(Result)\n                    ElifStack[-1] = ElifStack[-1] + 1\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!elif' for line '%s'\" % DscLine)\n            else:\n                if IfStack:\n                    Handle = reduce(lambda x, y: x and y, IfStack)\n                else:\n                    Handle = True\n                if Handle:\n                    Match = re.match('!include\\\\s+(.+)', DscLine)\n                    if Match:\n                        IncludeFilePath = Match.group(1)\n                        IncludeFilePath = self.ExpandMacros(IncludeFilePath)\n                        PackagesPath = os.getenv('PACKAGES_PATH')\n                        if PackagesPath:\n                            for PackagePath in PackagesPath.split(os.pathsep):\n                                IncludeFilePathAbs = os.path.join(os.path.normpath(PackagePath), os.path.normpath(IncludeFilePath))\n                                if os.path.exists(IncludeFilePathAbs):\n                                    IncludeDsc = open(IncludeFilePathAbs, 'r')\n                                    break\n                        else:\n                            IncludeDsc = open(IncludeFilePath, 'r')\n                        if IncludeDsc == None:\n                            print(\"ERROR: Cannot open file '%s'\" % IncludeFilePath)\n                            raise SystemExit\n                        CurrentDscTime = os.path.getmtime(os.path.realpath(IncludeDsc.name))\n                        if CurrentDscTime > self._DscTime:\n                            self._DscTime = CurrentDscTime\n                        NewDscLines = IncludeDsc.readlines()\n                        IncludeDsc.close()\n                        DscLines = NewDscLines + DscLines\n                        del self._DscLines[-1]\n                        Offset = 0\n                    elif DscLine.startswith('!'):\n                        print(\"ERROR: Unrecognized directive for line '%s'\" % DscLine)\n                        raise SystemExit\n        if not Handle:\n            del self._DscLines[-1]\n            continue\n        if IsDefSect:\n            Match = re.match('^\\\\s*(?:DEFINE\\\\s+)*(\\\\w+)\\\\s*=\\\\s*(.+)', DscLine)\n            if Match:\n                self._MacroDict[Match.group(1)] = self.ExpandMacros(Match.group(2))\n                if self.Debug:\n                    print('INFO : DEFINE %s = [ %s ]' % (Match.group(1), self.ExpandMacros(Match.group(2))))\n        elif IsPcdSect:\n            Match = re.match('^\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\|\\\\s*(\\\\w+)', DscLine)\n            if Match:\n                self._PcdsDict[Match.group(1)] = Match.group(2)\n                if self.Debug:\n                    print('INFO : PCD %s = [ %s ]' % (Match.group(1), Match.group(2)))\n                i = 0\n                while i < len(BuildOptionPcd):\n                    Match = re.match('\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\=\\\\s*(\\\\w+)', BuildOptionPcd[i])\n                    if Match:\n                        self._PcdsDict[Match.group(1)] = Match.group(2)\n                    i += 1\n        elif IsTmpSect:\n            Match = re.match('^\\\\s*#\\\\s+(!BSF)\\\\s+DEFT:{(.+?):(START|END)}', DscLine)\n            if Match:\n                if Match.group(3) == 'START' and (not TemplateName):\n                    TemplateName = Match.group(2).strip()\n                    self._BsfTempDict[TemplateName] = []\n                if Match.group(3) == 'END' and TemplateName == Match.group(2).strip() and TemplateName:\n                    TemplateName = ''\n            elif TemplateName:\n                Match = re.match('^!include\\\\s*(.+)?$', DscLine)\n                if Match:\n                    continue\n                self._BsfTempDict[TemplateName].append(DscLine)\n        else:\n            Match = re.match('^\\\\s*#\\\\s+(!BSF|@Bsf|!HDR)\\\\s+(.+)', DscLine)\n            if Match:\n                Remaining = Match.group(2)\n                if Match.group(1) == '!BSF' or Match.group(1) == '@Bsf':\n                    Match = re.match('(?:^|.+\\\\s+)PAGES:{(.+?)}', Remaining)\n                    if Match:\n                        PageList = Match.group(1).split(',')\n                        for Page in PageList:\n                            Page = Page.strip()\n                            Match = re.match('(\\\\w+):\"(.+)\"', Page)\n                            if Match != None:\n                                self._CfgPageDict[Match.group(1)] = Match.group(2)\n                    Match = re.match('(?:^|.+\\\\s+)BLOCK:{NAME:\"(.+)\"\\\\s*,\\\\s*VER:\"(.+)\"\\\\s*}', Remaining)\n                    if Match:\n                        self._CfgBlkDict['name'] = Match.group(1)\n                        self._CfgBlkDict['ver'] = Match.group(2)\n                    for Key in self._BsfKeyList:\n                        Match = re.match('(?:^|.+\\\\s+)%s:{(.+?)}' % Key, Remaining)\n                        if Match:\n                            if Key in ['NAME', 'HELP', 'OPTION'] and Match.group(1).startswith('+'):\n                                ConfigDict[Key.lower()] += Match.group(1)[1:]\n                            else:\n                                ConfigDict[Key.lower()] = Match.group(1)\n                else:\n                    for Key in self._HdrKeyList:\n                        Match = re.match('(?:^|.+\\\\s+)%s:{(.+?)}' % Key, Remaining)\n                        if Match:\n                            ConfigDict[Key.lower()] = Match.group(1)\n            Match = re.match('^\\\\s*#\\\\s+@Prompt\\\\s+(.+)', DscLine)\n            if Match:\n                ConfigDict['name'] = Match.group(1)\n            Match = re.match('^\\\\s*#\\\\s*@ValidList\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*', DscLine)\n            if Match:\n                if Match.group(2).strip() in self._BuidinOption:\n                    ConfigDict['option'] = Match.group(2).strip()\n                else:\n                    OptionValueList = Match.group(2).split(',')\n                    OptionStringList = Match.group(3).split(',')\n                    Index = 0\n                    for Option in OptionValueList:\n                        Option = Option.strip()\n                        ConfigDict['option'] = ConfigDict['option'] + str(Option) + ':' + OptionStringList[Index].strip()\n                        Index += 1\n                        if Index in range(len(OptionValueList)):\n                            ConfigDict['option'] += ', '\n                ConfigDict['type'] = 'Combo'\n            Match = re.match('^\\\\s*#\\\\s*@ValidRange\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*-\\\\s*(.+)\\\\s*', DscLine)\n            if Match:\n                if '0x' in Match.group(2) or '0x' in Match.group(3):\n                    ConfigDict['type'] = 'EditNum, HEX, (%s,%s)' % (Match.group(2), Match.group(3))\n                else:\n                    ConfigDict['type'] = 'EditNum, DEC, (%s,%s)' % (Match.group(2), Match.group(3))\n            Match = re.match('^\\\\s*##\\\\s+(.+)', DscLine)\n            if Match:\n                ConfigDict['help'] = Match.group(1)\n            if IsUpdSect:\n                Match = re.match('^([_a-zA-Z0-9]+).([_a-zA-Z0-9]+)\\\\s*\\\\|\\\\s*(0x[0-9A-F]+|\\\\*)\\\\s*\\\\|\\\\s*(\\\\d+|0x[0-9a-fA-F]+)\\\\s*\\\\|\\\\s*(.+)', DscLine)\n            else:\n                Match = re.match('^([_a-zA-Z0-9]+).([_a-zA-Z0-9]+)\\\\s*\\\\|\\\\s*(0x[0-9A-F]+)(?:\\\\s*\\\\|\\\\s*(.+))?', DscLine)\n            if Match:\n                ConfigDict['space'] = Match.group(1)\n                ConfigDict['cname'] = Match.group(2)\n                if Match.group(3) != '*':\n                    Hardcode = True\n                    Offset = int(Match.group(3), 16)\n                else:\n                    AutoAlign = True\n                if Hardcode and AutoAlign:\n                    print('Hardcode and auto-align mixed mode is not supported by GenCfgOpt')\n                    raise SystemExit\n                ConfigDict['offset'] = Offset\n                if ConfigDict['order'] == -1:\n                    ConfigDict['order'] = ConfigDict['offset'] << 8\n                else:\n                    (Major, Minor) = ConfigDict['order'].split('.')\n                    ConfigDict['order'] = (int(Major, 16) << 8) + int(Minor, 16)\n                if IsUpdSect:\n                    Value = Match.group(5).strip()\n                    if Match.group(4).startswith('0x'):\n                        Length = int(Match.group(4), 16)\n                    else:\n                        Length = int(Match.group(4))\n                    Offset += Length\n                else:\n                    Value = Match.group(4)\n                    if Value is None:\n                        Value = ''\n                    Value = Value.strip()\n                    if '|' in Value:\n                        Match = re.match('^.+\\\\s*\\\\|\\\\s*(.+)', Value)\n                        if Match:\n                            Value = Match.group(1)\n                    Length = -1\n                ConfigDict['length'] = Length\n                Match = re.match('\\\\$\\\\((\\\\w+)\\\\)', Value)\n                if Match:\n                    if Match.group(1) in self._MacroDict:\n                        Value = self._MacroDict[Match.group(1)]\n                ConfigDict['value'] = Value\n                if len(Value) > 0 and Value[0] == '{':\n                    Value = self.FormatListValue(ConfigDict)\n                if ConfigDict['name'] == '':\n                    ConfigDict['bsfname'] = ''\n                    ConfigDict['help'] = ''\n                    ConfigDict['type'] = ''\n                    ConfigDict['option'] = ''\n                if IsUpdSect and AutoAlign:\n                    ItemLength = int(ConfigDict['length'])\n                    ItemOffset = int(ConfigDict['offset'])\n                    ItemStruct = ConfigDict['struct']\n                    Unit = 1\n                    if ItemLength in [1, 2, 4, 8] and (not ConfigDict['value'].startswith('{')):\n                        Unit = ItemLength\n                        if Unit == 8:\n                            MaxAlign = 64\n                            SizeAlign = 8\n                    if ItemStruct != '':\n                        UnitDict = {'UINT8': 1, 'UINT16': 2, 'UINT32': 4, 'UINT64': 8}\n                        if ItemStruct in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n                            Unit = UnitDict[ItemStruct]\n                            if Unit == 8:\n                                MaxAlign = 64\n                            SizeAlign = max(SizeAlign, Unit)\n                    if ConfigDict['embed'].find(':START') != -1:\n                        Base = ItemOffset\n                    SubOffset = ItemOffset - Base\n                    SubRemainder = SubOffset % Unit\n                    if SubRemainder:\n                        Diff = Unit - SubRemainder\n                        Offset = Offset + Diff\n                        ItemOffset = ItemOffset + Diff\n                    if ConfigDict['embed'].find(':END') != -1:\n                        Remainder = Offset % (MaxAlign / 8)\n                        if Remainder:\n                            Diff = int(MaxAlign / 8 - Remainder)\n                            Offset = Offset + Diff\n                            ItemOffset = ItemOffset + Diff\n                        MaxAlign = 32\n                    if ConfigDict['cname'] == 'UpdTerminator':\n                        Remainder = Offset % max(ItemLength / 8, 4, SizeAlign)\n                        Offset = Offset + ItemLength\n                        if Remainder:\n                            Diff = int(max(ItemLength / 8, 4, SizeAlign) - Remainder)\n                            ItemOffset = ItemOffset + Diff\n                    ConfigDict['offset'] = ItemOffset\n                self._CfgItemList.append(ConfigDict.copy())\n                ConfigDict['name'] = ''\n                ConfigDict['find'] = ''\n                ConfigDict['struct'] = ''\n                ConfigDict['embed'] = ''\n                ConfigDict['comment'] = ''\n                ConfigDict['marker'] = ''\n                ConfigDict['order'] = -1\n                ConfigDict['subreg'] = []\n                ConfigDict['option'] = ''\n            else:\n                Match = re.match('^\\\\s*#\\\\s+(!BSF|@Bsf)\\\\s+FIELD:{(.+):(\\\\d+)([Bb])?}', DscLine)\n                if Match:\n                    SubCfgDict = ConfigDict.copy()\n                    if Match.group(4) == None or Match.group(4) == 'B':\n                        UnitBitLen = 8\n                    elif Match.group(4) == 'b':\n                        UnitBitLen = 1\n                    else:\n                        print(\"ERROR: Invalide BSF FIELD length for line '%s'\" % DscLine)\n                        raise SystemExit\n                    SubCfgDict['cname'] = Match.group(2)\n                    SubCfgDict['bitlength'] = int(Match.group(3)) * UnitBitLen\n                    if SubCfgDict['bitlength'] > 0:\n                        LastItem = self._CfgItemList[-1]\n                        if len(LastItem['subreg']) == 0:\n                            SubOffset = 0\n                        else:\n                            SubOffset = LastItem['subreg'][-1]['bitoffset'] + LastItem['subreg'][-1]['bitlength']\n                        SubCfgDict['bitoffset'] = SubOffset\n                        LastItem['subreg'].append(SubCfgDict.copy())\n                    ConfigDict['name'] = ''\n    return Error",
            "def ParseDscFile(self, DscFile, FvDir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Hardcode = False\n    AutoAlign = False\n    self._CfgItemList = []\n    self._CfgPageDict = {}\n    self._CfgBlkDict = {}\n    self._DscFile = DscFile\n    self._FvDir = FvDir\n    self._DscLines = []\n    self._BsfTempDict = {}\n    self._DscTime = os.path.getmtime(DscFile)\n    CfgDict = {}\n    IsDefSect = False\n    IsPcdSect = False\n    IsUpdSect = False\n    IsVpdSect = False\n    IsTmpSect = False\n    TemplateName = ''\n    IfStack = []\n    ElifStack = []\n    Error = 0\n    ConfigDict = {}\n    if type(DscFile) is list:\n        DscLines = DscFile\n        self._DscFile = '.'\n    else:\n        DscFd = open(DscFile, 'r')\n        DscLines = DscFd.readlines()\n        DscFd.close()\n        self._DscFile = DscFile\n    SkipLines = 0\n    MaxAlign = 32\n    SizeAlign = 0\n    Base = 0\n    while len(DscLines):\n        DscLine = DscLines.pop(0).strip()\n        if SkipLines == 0:\n            self._DscLines.append(DscLine)\n        else:\n            SkipLines = SkipLines - 1\n        if len(DscLine) == 0:\n            continue\n        Handle = False\n        Match = re.match('^\\\\[(.+)\\\\]', DscLine)\n        if Match is not None:\n            IsDefSect = False\n            IsPcdSect = False\n            IsVpdSect = False\n            IsUpdSect = False\n            IsTmpSect = False\n            SectionName = Match.group(1).lower()\n            if SectionName == 'Defines'.lower():\n                IsDefSect = True\n            if SectionName == 'PcdsFeatureFlag'.lower() or SectionName == 'PcdsFixedAtBuild'.lower():\n                IsPcdSect = True\n            elif SectionName == 'PcdsDynamicVpd.Tmp'.lower():\n                IsTmpSect = True\n            elif SectionName == 'PcdsDynamicVpd.Upd'.lower():\n                ConfigDict = {}\n                ConfigDict['header'] = 'ON'\n                ConfigDict['region'] = 'UPD'\n                ConfigDict['order'] = -1\n                ConfigDict['page'] = ''\n                ConfigDict['name'] = ''\n                ConfigDict['find'] = ''\n                ConfigDict['marker'] = ''\n                ConfigDict['struct'] = ''\n                ConfigDict['embed'] = ''\n                ConfigDict['comment'] = ''\n                ConfigDict['subreg'] = []\n                ConfigDict['condition'] = ''\n                ConfigDict['option'] = ''\n                IsUpdSect = True\n                Offset = 0\n        elif IsDefSect or IsPcdSect or IsUpdSect or IsVpdSect or IsTmpSect:\n            Match = False if DscLine[0] != '!' else True\n            if Match:\n                Match = re.match('^!(else|endif|ifdef|ifndef|if|elseif|include)\\\\s*(.+)?$', DscLine.split('#')[0])\n            Keyword = Match.group(1) if Match else ''\n            Remaining = Match.group(2) if Match else ''\n            Remaining = '' if Remaining is None else Remaining.strip()\n            if Keyword in ['if', 'elseif', 'ifdef', 'ifndef', 'include'] and (not Remaining):\n                raise Exception(\"ERROR: Expression is expected after '!if' or !elseif' for line '%s'\" % DscLine)\n            if Keyword == 'else':\n                if IfStack:\n                    IfStack[-1] = not IfStack[-1]\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!else' for line '%s'\" % DscLine)\n            elif Keyword == 'endif':\n                if IfStack:\n                    IfStack.pop()\n                    Level = ElifStack.pop()\n                    if Level > 0:\n                        del IfStack[-Level:]\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!endif' for line '%s'\" % DscLine)\n            elif Keyword == 'ifdef' or Keyword == 'ifndef':\n                Result = self.EvaulateIfdef(Remaining)\n                if Keyword == 'ifndef':\n                    Result = not Result\n                IfStack.append(Result)\n                ElifStack.append(0)\n            elif Keyword == 'if' or Keyword == 'elseif':\n                Result = self.EvaluateExpress(Remaining)\n                if Keyword == 'if':\n                    ElifStack.append(0)\n                    IfStack.append(Result)\n                elif IfStack:\n                    IfStack[-1] = not IfStack[-1]\n                    IfStack.append(Result)\n                    ElifStack[-1] = ElifStack[-1] + 1\n                else:\n                    raise Exception(\"ERROR: No paired '!if' found for '!elif' for line '%s'\" % DscLine)\n            else:\n                if IfStack:\n                    Handle = reduce(lambda x, y: x and y, IfStack)\n                else:\n                    Handle = True\n                if Handle:\n                    Match = re.match('!include\\\\s+(.+)', DscLine)\n                    if Match:\n                        IncludeFilePath = Match.group(1)\n                        IncludeFilePath = self.ExpandMacros(IncludeFilePath)\n                        PackagesPath = os.getenv('PACKAGES_PATH')\n                        if PackagesPath:\n                            for PackagePath in PackagesPath.split(os.pathsep):\n                                IncludeFilePathAbs = os.path.join(os.path.normpath(PackagePath), os.path.normpath(IncludeFilePath))\n                                if os.path.exists(IncludeFilePathAbs):\n                                    IncludeDsc = open(IncludeFilePathAbs, 'r')\n                                    break\n                        else:\n                            IncludeDsc = open(IncludeFilePath, 'r')\n                        if IncludeDsc == None:\n                            print(\"ERROR: Cannot open file '%s'\" % IncludeFilePath)\n                            raise SystemExit\n                        CurrentDscTime = os.path.getmtime(os.path.realpath(IncludeDsc.name))\n                        if CurrentDscTime > self._DscTime:\n                            self._DscTime = CurrentDscTime\n                        NewDscLines = IncludeDsc.readlines()\n                        IncludeDsc.close()\n                        DscLines = NewDscLines + DscLines\n                        del self._DscLines[-1]\n                        Offset = 0\n                    elif DscLine.startswith('!'):\n                        print(\"ERROR: Unrecognized directive for line '%s'\" % DscLine)\n                        raise SystemExit\n        if not Handle:\n            del self._DscLines[-1]\n            continue\n        if IsDefSect:\n            Match = re.match('^\\\\s*(?:DEFINE\\\\s+)*(\\\\w+)\\\\s*=\\\\s*(.+)', DscLine)\n            if Match:\n                self._MacroDict[Match.group(1)] = self.ExpandMacros(Match.group(2))\n                if self.Debug:\n                    print('INFO : DEFINE %s = [ %s ]' % (Match.group(1), self.ExpandMacros(Match.group(2))))\n        elif IsPcdSect:\n            Match = re.match('^\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\|\\\\s*(\\\\w+)', DscLine)\n            if Match:\n                self._PcdsDict[Match.group(1)] = Match.group(2)\n                if self.Debug:\n                    print('INFO : PCD %s = [ %s ]' % (Match.group(1), Match.group(2)))\n                i = 0\n                while i < len(BuildOptionPcd):\n                    Match = re.match('\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\=\\\\s*(\\\\w+)', BuildOptionPcd[i])\n                    if Match:\n                        self._PcdsDict[Match.group(1)] = Match.group(2)\n                    i += 1\n        elif IsTmpSect:\n            Match = re.match('^\\\\s*#\\\\s+(!BSF)\\\\s+DEFT:{(.+?):(START|END)}', DscLine)\n            if Match:\n                if Match.group(3) == 'START' and (not TemplateName):\n                    TemplateName = Match.group(2).strip()\n                    self._BsfTempDict[TemplateName] = []\n                if Match.group(3) == 'END' and TemplateName == Match.group(2).strip() and TemplateName:\n                    TemplateName = ''\n            elif TemplateName:\n                Match = re.match('^!include\\\\s*(.+)?$', DscLine)\n                if Match:\n                    continue\n                self._BsfTempDict[TemplateName].append(DscLine)\n        else:\n            Match = re.match('^\\\\s*#\\\\s+(!BSF|@Bsf|!HDR)\\\\s+(.+)', DscLine)\n            if Match:\n                Remaining = Match.group(2)\n                if Match.group(1) == '!BSF' or Match.group(1) == '@Bsf':\n                    Match = re.match('(?:^|.+\\\\s+)PAGES:{(.+?)}', Remaining)\n                    if Match:\n                        PageList = Match.group(1).split(',')\n                        for Page in PageList:\n                            Page = Page.strip()\n                            Match = re.match('(\\\\w+):\"(.+)\"', Page)\n                            if Match != None:\n                                self._CfgPageDict[Match.group(1)] = Match.group(2)\n                    Match = re.match('(?:^|.+\\\\s+)BLOCK:{NAME:\"(.+)\"\\\\s*,\\\\s*VER:\"(.+)\"\\\\s*}', Remaining)\n                    if Match:\n                        self._CfgBlkDict['name'] = Match.group(1)\n                        self._CfgBlkDict['ver'] = Match.group(2)\n                    for Key in self._BsfKeyList:\n                        Match = re.match('(?:^|.+\\\\s+)%s:{(.+?)}' % Key, Remaining)\n                        if Match:\n                            if Key in ['NAME', 'HELP', 'OPTION'] and Match.group(1).startswith('+'):\n                                ConfigDict[Key.lower()] += Match.group(1)[1:]\n                            else:\n                                ConfigDict[Key.lower()] = Match.group(1)\n                else:\n                    for Key in self._HdrKeyList:\n                        Match = re.match('(?:^|.+\\\\s+)%s:{(.+?)}' % Key, Remaining)\n                        if Match:\n                            ConfigDict[Key.lower()] = Match.group(1)\n            Match = re.match('^\\\\s*#\\\\s+@Prompt\\\\s+(.+)', DscLine)\n            if Match:\n                ConfigDict['name'] = Match.group(1)\n            Match = re.match('^\\\\s*#\\\\s*@ValidList\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*', DscLine)\n            if Match:\n                if Match.group(2).strip() in self._BuidinOption:\n                    ConfigDict['option'] = Match.group(2).strip()\n                else:\n                    OptionValueList = Match.group(2).split(',')\n                    OptionStringList = Match.group(3).split(',')\n                    Index = 0\n                    for Option in OptionValueList:\n                        Option = Option.strip()\n                        ConfigDict['option'] = ConfigDict['option'] + str(Option) + ':' + OptionStringList[Index].strip()\n                        Index += 1\n                        if Index in range(len(OptionValueList)):\n                            ConfigDict['option'] += ', '\n                ConfigDict['type'] = 'Combo'\n            Match = re.match('^\\\\s*#\\\\s*@ValidRange\\\\s*(.+)\\\\s*\\\\|\\\\s*(.+)\\\\s*-\\\\s*(.+)\\\\s*', DscLine)\n            if Match:\n                if '0x' in Match.group(2) or '0x' in Match.group(3):\n                    ConfigDict['type'] = 'EditNum, HEX, (%s,%s)' % (Match.group(2), Match.group(3))\n                else:\n                    ConfigDict['type'] = 'EditNum, DEC, (%s,%s)' % (Match.group(2), Match.group(3))\n            Match = re.match('^\\\\s*##\\\\s+(.+)', DscLine)\n            if Match:\n                ConfigDict['help'] = Match.group(1)\n            if IsUpdSect:\n                Match = re.match('^([_a-zA-Z0-9]+).([_a-zA-Z0-9]+)\\\\s*\\\\|\\\\s*(0x[0-9A-F]+|\\\\*)\\\\s*\\\\|\\\\s*(\\\\d+|0x[0-9a-fA-F]+)\\\\s*\\\\|\\\\s*(.+)', DscLine)\n            else:\n                Match = re.match('^([_a-zA-Z0-9]+).([_a-zA-Z0-9]+)\\\\s*\\\\|\\\\s*(0x[0-9A-F]+)(?:\\\\s*\\\\|\\\\s*(.+))?', DscLine)\n            if Match:\n                ConfigDict['space'] = Match.group(1)\n                ConfigDict['cname'] = Match.group(2)\n                if Match.group(3) != '*':\n                    Hardcode = True\n                    Offset = int(Match.group(3), 16)\n                else:\n                    AutoAlign = True\n                if Hardcode and AutoAlign:\n                    print('Hardcode and auto-align mixed mode is not supported by GenCfgOpt')\n                    raise SystemExit\n                ConfigDict['offset'] = Offset\n                if ConfigDict['order'] == -1:\n                    ConfigDict['order'] = ConfigDict['offset'] << 8\n                else:\n                    (Major, Minor) = ConfigDict['order'].split('.')\n                    ConfigDict['order'] = (int(Major, 16) << 8) + int(Minor, 16)\n                if IsUpdSect:\n                    Value = Match.group(5).strip()\n                    if Match.group(4).startswith('0x'):\n                        Length = int(Match.group(4), 16)\n                    else:\n                        Length = int(Match.group(4))\n                    Offset += Length\n                else:\n                    Value = Match.group(4)\n                    if Value is None:\n                        Value = ''\n                    Value = Value.strip()\n                    if '|' in Value:\n                        Match = re.match('^.+\\\\s*\\\\|\\\\s*(.+)', Value)\n                        if Match:\n                            Value = Match.group(1)\n                    Length = -1\n                ConfigDict['length'] = Length\n                Match = re.match('\\\\$\\\\((\\\\w+)\\\\)', Value)\n                if Match:\n                    if Match.group(1) in self._MacroDict:\n                        Value = self._MacroDict[Match.group(1)]\n                ConfigDict['value'] = Value\n                if len(Value) > 0 and Value[0] == '{':\n                    Value = self.FormatListValue(ConfigDict)\n                if ConfigDict['name'] == '':\n                    ConfigDict['bsfname'] = ''\n                    ConfigDict['help'] = ''\n                    ConfigDict['type'] = ''\n                    ConfigDict['option'] = ''\n                if IsUpdSect and AutoAlign:\n                    ItemLength = int(ConfigDict['length'])\n                    ItemOffset = int(ConfigDict['offset'])\n                    ItemStruct = ConfigDict['struct']\n                    Unit = 1\n                    if ItemLength in [1, 2, 4, 8] and (not ConfigDict['value'].startswith('{')):\n                        Unit = ItemLength\n                        if Unit == 8:\n                            MaxAlign = 64\n                            SizeAlign = 8\n                    if ItemStruct != '':\n                        UnitDict = {'UINT8': 1, 'UINT16': 2, 'UINT32': 4, 'UINT64': 8}\n                        if ItemStruct in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n                            Unit = UnitDict[ItemStruct]\n                            if Unit == 8:\n                                MaxAlign = 64\n                            SizeAlign = max(SizeAlign, Unit)\n                    if ConfigDict['embed'].find(':START') != -1:\n                        Base = ItemOffset\n                    SubOffset = ItemOffset - Base\n                    SubRemainder = SubOffset % Unit\n                    if SubRemainder:\n                        Diff = Unit - SubRemainder\n                        Offset = Offset + Diff\n                        ItemOffset = ItemOffset + Diff\n                    if ConfigDict['embed'].find(':END') != -1:\n                        Remainder = Offset % (MaxAlign / 8)\n                        if Remainder:\n                            Diff = int(MaxAlign / 8 - Remainder)\n                            Offset = Offset + Diff\n                            ItemOffset = ItemOffset + Diff\n                        MaxAlign = 32\n                    if ConfigDict['cname'] == 'UpdTerminator':\n                        Remainder = Offset % max(ItemLength / 8, 4, SizeAlign)\n                        Offset = Offset + ItemLength\n                        if Remainder:\n                            Diff = int(max(ItemLength / 8, 4, SizeAlign) - Remainder)\n                            ItemOffset = ItemOffset + Diff\n                    ConfigDict['offset'] = ItemOffset\n                self._CfgItemList.append(ConfigDict.copy())\n                ConfigDict['name'] = ''\n                ConfigDict['find'] = ''\n                ConfigDict['struct'] = ''\n                ConfigDict['embed'] = ''\n                ConfigDict['comment'] = ''\n                ConfigDict['marker'] = ''\n                ConfigDict['order'] = -1\n                ConfigDict['subreg'] = []\n                ConfigDict['option'] = ''\n            else:\n                Match = re.match('^\\\\s*#\\\\s+(!BSF|@Bsf)\\\\s+FIELD:{(.+):(\\\\d+)([Bb])?}', DscLine)\n                if Match:\n                    SubCfgDict = ConfigDict.copy()\n                    if Match.group(4) == None or Match.group(4) == 'B':\n                        UnitBitLen = 8\n                    elif Match.group(4) == 'b':\n                        UnitBitLen = 1\n                    else:\n                        print(\"ERROR: Invalide BSF FIELD length for line '%s'\" % DscLine)\n                        raise SystemExit\n                    SubCfgDict['cname'] = Match.group(2)\n                    SubCfgDict['bitlength'] = int(Match.group(3)) * UnitBitLen\n                    if SubCfgDict['bitlength'] > 0:\n                        LastItem = self._CfgItemList[-1]\n                        if len(LastItem['subreg']) == 0:\n                            SubOffset = 0\n                        else:\n                            SubOffset = LastItem['subreg'][-1]['bitoffset'] + LastItem['subreg'][-1]['bitlength']\n                        SubCfgDict['bitoffset'] = SubOffset\n                        LastItem['subreg'].append(SubCfgDict.copy())\n                    ConfigDict['name'] = ''\n    return Error"
        ]
    },
    {
        "func_name": "GetBsfBitFields",
        "original": "def GetBsfBitFields(self, subitem, bytes):\n    start = subitem['bitoffset']\n    end = start + subitem['bitlength']\n    bitsvalue = ''.join(('{0:08b}'.format(i) for i in bytes[::-1]))\n    bitsvalue = bitsvalue[::-1]\n    bitslen = len(bitsvalue)\n    if start > bitslen or end > bitslen:\n        raise Exception('Invalid bits offset [%d,%d] %d for %s' % (start, end, bitslen, subitem['name']))\n    return '0x%X' % int(bitsvalue[start:end][::-1], 2)",
        "mutated": [
            "def GetBsfBitFields(self, subitem, bytes):\n    if False:\n        i = 10\n    start = subitem['bitoffset']\n    end = start + subitem['bitlength']\n    bitsvalue = ''.join(('{0:08b}'.format(i) for i in bytes[::-1]))\n    bitsvalue = bitsvalue[::-1]\n    bitslen = len(bitsvalue)\n    if start > bitslen or end > bitslen:\n        raise Exception('Invalid bits offset [%d,%d] %d for %s' % (start, end, bitslen, subitem['name']))\n    return '0x%X' % int(bitsvalue[start:end][::-1], 2)",
            "def GetBsfBitFields(self, subitem, bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    start = subitem['bitoffset']\n    end = start + subitem['bitlength']\n    bitsvalue = ''.join(('{0:08b}'.format(i) for i in bytes[::-1]))\n    bitsvalue = bitsvalue[::-1]\n    bitslen = len(bitsvalue)\n    if start > bitslen or end > bitslen:\n        raise Exception('Invalid bits offset [%d,%d] %d for %s' % (start, end, bitslen, subitem['name']))\n    return '0x%X' % int(bitsvalue[start:end][::-1], 2)",
            "def GetBsfBitFields(self, subitem, bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    start = subitem['bitoffset']\n    end = start + subitem['bitlength']\n    bitsvalue = ''.join(('{0:08b}'.format(i) for i in bytes[::-1]))\n    bitsvalue = bitsvalue[::-1]\n    bitslen = len(bitsvalue)\n    if start > bitslen or end > bitslen:\n        raise Exception('Invalid bits offset [%d,%d] %d for %s' % (start, end, bitslen, subitem['name']))\n    return '0x%X' % int(bitsvalue[start:end][::-1], 2)",
            "def GetBsfBitFields(self, subitem, bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    start = subitem['bitoffset']\n    end = start + subitem['bitlength']\n    bitsvalue = ''.join(('{0:08b}'.format(i) for i in bytes[::-1]))\n    bitsvalue = bitsvalue[::-1]\n    bitslen = len(bitsvalue)\n    if start > bitslen or end > bitslen:\n        raise Exception('Invalid bits offset [%d,%d] %d for %s' % (start, end, bitslen, subitem['name']))\n    return '0x%X' % int(bitsvalue[start:end][::-1], 2)",
            "def GetBsfBitFields(self, subitem, bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    start = subitem['bitoffset']\n    end = start + subitem['bitlength']\n    bitsvalue = ''.join(('{0:08b}'.format(i) for i in bytes[::-1]))\n    bitsvalue = bitsvalue[::-1]\n    bitslen = len(bitsvalue)\n    if start > bitslen or end > bitslen:\n        raise Exception('Invalid bits offset [%d,%d] %d for %s' % (start, end, bitslen, subitem['name']))\n    return '0x%X' % int(bitsvalue[start:end][::-1], 2)"
        ]
    },
    {
        "func_name": "UpdateSubRegionDefaultValue",
        "original": "def UpdateSubRegionDefaultValue(self):\n    Error = 0\n    for Item in self._CfgItemList:\n        if len(Item['subreg']) == 0:\n            continue\n        bytearray = []\n        if Item['value'][0] == '{':\n            binlist = Item['value'][1:-1].split(',')\n            for each in binlist:\n                each = each.strip()\n                if each.startswith('0x'):\n                    value = int(each, 16)\n                else:\n                    value = int(each)\n                bytearray.append(value)\n        else:\n            if Item['value'].startswith('0x'):\n                value = int(Item['value'], 16)\n            else:\n                value = int(Item['value'])\n            idx = 0\n            while idx < Item['length']:\n                bytearray.append(value & 255)\n                value = value >> 8\n                idx = idx + 1\n        for SubItem in Item['subreg']:\n            valuestr = self.GetBsfBitFields(SubItem, bytearray)\n            SubItem['value'] = valuestr\n    return Error",
        "mutated": [
            "def UpdateSubRegionDefaultValue(self):\n    if False:\n        i = 10\n    Error = 0\n    for Item in self._CfgItemList:\n        if len(Item['subreg']) == 0:\n            continue\n        bytearray = []\n        if Item['value'][0] == '{':\n            binlist = Item['value'][1:-1].split(',')\n            for each in binlist:\n                each = each.strip()\n                if each.startswith('0x'):\n                    value = int(each, 16)\n                else:\n                    value = int(each)\n                bytearray.append(value)\n        else:\n            if Item['value'].startswith('0x'):\n                value = int(Item['value'], 16)\n            else:\n                value = int(Item['value'])\n            idx = 0\n            while idx < Item['length']:\n                bytearray.append(value & 255)\n                value = value >> 8\n                idx = idx + 1\n        for SubItem in Item['subreg']:\n            valuestr = self.GetBsfBitFields(SubItem, bytearray)\n            SubItem['value'] = valuestr\n    return Error",
            "def UpdateSubRegionDefaultValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Error = 0\n    for Item in self._CfgItemList:\n        if len(Item['subreg']) == 0:\n            continue\n        bytearray = []\n        if Item['value'][0] == '{':\n            binlist = Item['value'][1:-1].split(',')\n            for each in binlist:\n                each = each.strip()\n                if each.startswith('0x'):\n                    value = int(each, 16)\n                else:\n                    value = int(each)\n                bytearray.append(value)\n        else:\n            if Item['value'].startswith('0x'):\n                value = int(Item['value'], 16)\n            else:\n                value = int(Item['value'])\n            idx = 0\n            while idx < Item['length']:\n                bytearray.append(value & 255)\n                value = value >> 8\n                idx = idx + 1\n        for SubItem in Item['subreg']:\n            valuestr = self.GetBsfBitFields(SubItem, bytearray)\n            SubItem['value'] = valuestr\n    return Error",
            "def UpdateSubRegionDefaultValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Error = 0\n    for Item in self._CfgItemList:\n        if len(Item['subreg']) == 0:\n            continue\n        bytearray = []\n        if Item['value'][0] == '{':\n            binlist = Item['value'][1:-1].split(',')\n            for each in binlist:\n                each = each.strip()\n                if each.startswith('0x'):\n                    value = int(each, 16)\n                else:\n                    value = int(each)\n                bytearray.append(value)\n        else:\n            if Item['value'].startswith('0x'):\n                value = int(Item['value'], 16)\n            else:\n                value = int(Item['value'])\n            idx = 0\n            while idx < Item['length']:\n                bytearray.append(value & 255)\n                value = value >> 8\n                idx = idx + 1\n        for SubItem in Item['subreg']:\n            valuestr = self.GetBsfBitFields(SubItem, bytearray)\n            SubItem['value'] = valuestr\n    return Error",
            "def UpdateSubRegionDefaultValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Error = 0\n    for Item in self._CfgItemList:\n        if len(Item['subreg']) == 0:\n            continue\n        bytearray = []\n        if Item['value'][0] == '{':\n            binlist = Item['value'][1:-1].split(',')\n            for each in binlist:\n                each = each.strip()\n                if each.startswith('0x'):\n                    value = int(each, 16)\n                else:\n                    value = int(each)\n                bytearray.append(value)\n        else:\n            if Item['value'].startswith('0x'):\n                value = int(Item['value'], 16)\n            else:\n                value = int(Item['value'])\n            idx = 0\n            while idx < Item['length']:\n                bytearray.append(value & 255)\n                value = value >> 8\n                idx = idx + 1\n        for SubItem in Item['subreg']:\n            valuestr = self.GetBsfBitFields(SubItem, bytearray)\n            SubItem['value'] = valuestr\n    return Error",
            "def UpdateSubRegionDefaultValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Error = 0\n    for Item in self._CfgItemList:\n        if len(Item['subreg']) == 0:\n            continue\n        bytearray = []\n        if Item['value'][0] == '{':\n            binlist = Item['value'][1:-1].split(',')\n            for each in binlist:\n                each = each.strip()\n                if each.startswith('0x'):\n                    value = int(each, 16)\n                else:\n                    value = int(each)\n                bytearray.append(value)\n        else:\n            if Item['value'].startswith('0x'):\n                value = int(Item['value'], 16)\n            else:\n                value = int(Item['value'])\n            idx = 0\n            while idx < Item['length']:\n                bytearray.append(value & 255)\n                value = value >> 8\n                idx = idx + 1\n        for SubItem in Item['subreg']:\n            valuestr = self.GetBsfBitFields(SubItem, bytearray)\n            SubItem['value'] = valuestr\n    return Error"
        ]
    },
    {
        "func_name": "NoDscFileChange",
        "original": "def NoDscFileChange(self, OutPutFile):\n    NoFileChange = True\n    if not os.path.exists(OutPutFile):\n        NoFileChange = False\n    else:\n        OutputTime = os.path.getmtime(OutPutFile)\n        if self._DscTime > OutputTime:\n            NoFileChange = False\n    return NoFileChange",
        "mutated": [
            "def NoDscFileChange(self, OutPutFile):\n    if False:\n        i = 10\n    NoFileChange = True\n    if not os.path.exists(OutPutFile):\n        NoFileChange = False\n    else:\n        OutputTime = os.path.getmtime(OutPutFile)\n        if self._DscTime > OutputTime:\n            NoFileChange = False\n    return NoFileChange",
            "def NoDscFileChange(self, OutPutFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    NoFileChange = True\n    if not os.path.exists(OutPutFile):\n        NoFileChange = False\n    else:\n        OutputTime = os.path.getmtime(OutPutFile)\n        if self._DscTime > OutputTime:\n            NoFileChange = False\n    return NoFileChange",
            "def NoDscFileChange(self, OutPutFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    NoFileChange = True\n    if not os.path.exists(OutPutFile):\n        NoFileChange = False\n    else:\n        OutputTime = os.path.getmtime(OutPutFile)\n        if self._DscTime > OutputTime:\n            NoFileChange = False\n    return NoFileChange",
            "def NoDscFileChange(self, OutPutFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    NoFileChange = True\n    if not os.path.exists(OutPutFile):\n        NoFileChange = False\n    else:\n        OutputTime = os.path.getmtime(OutPutFile)\n        if self._DscTime > OutputTime:\n            NoFileChange = False\n    return NoFileChange",
            "def NoDscFileChange(self, OutPutFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    NoFileChange = True\n    if not os.path.exists(OutPutFile):\n        NoFileChange = False\n    else:\n        OutputTime = os.path.getmtime(OutPutFile)\n        if self._DscTime > OutputTime:\n            NoFileChange = False\n    return NoFileChange"
        ]
    },
    {
        "func_name": "CreateSplitUpdTxt",
        "original": "def CreateSplitUpdTxt(self, UpdTxtFile):\n    GuidList = ['FSP_T_UPD_TOOL_GUID', 'FSP_M_UPD_TOOL_GUID', 'FSP_S_UPD_TOOL_GUID', 'FSP_I_UPD_TOOL_GUID']\n    SignatureList = ['0x545F', '0x4D5F', '0x535F', '0x495F']\n    for Index in range(len(GuidList)):\n        UpdTxtFile = ''\n        FvDir = self._FvDir\n        if GuidList[Index] not in self._MacroDict:\n            NoFSPI = False\n            if GuidList[Index] == 'FSP_I_UPD_TOOL_GUID':\n                NoFSPI = True\n                continue\n            else:\n                self.Error = '%s definition is missing in DSC file' % GuidList[Index]\n                return 1\n        if UpdTxtFile == '':\n            UpdTxtFile = os.path.join(FvDir, self._MacroDict[GuidList[Index]] + '.txt')\n        if self.NoDscFileChange(UpdTxtFile):\n            self.Error = 'No DSC file change, skip to create UPD TXT file'\n            return 256\n        TxtFd = open(UpdTxtFile, 'w')\n        TxtFd.write('%s\\n' % (__copyright_txt__ % date.today().year))\n        NextOffset = 0\n        SpaceIdx = 0\n        StartAddr = 0\n        EndAddr = 0\n        Default = 'DEFAULT|'\n        InRange = False\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == SignatureList[Index]:\n                StartAddr = Item['offset']\n                NextOffset = StartAddr\n                InRange = True\n            if Item['cname'] == 'UpdTerminator' and InRange == True:\n                EndAddr = Item['offset']\n                InRange = False\n        InRange = False\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == SignatureList[Index]:\n                InRange = True\n            if InRange != True:\n                continue\n            if Item['cname'] == 'UpdTerminator':\n                InRange = False\n            if Item['region'] != 'UPD':\n                continue\n            Offset = Item['offset']\n            if StartAddr > Offset or EndAddr < Offset:\n                continue\n            if NextOffset < Offset:\n                TxtFd.write('%s.UnusedUpdSpace%d|%s0x%04X|0x%04X|{0}\\n' % (Item['space'], SpaceIdx, Default, NextOffset - StartAddr, Offset - NextOffset))\n                SpaceIdx = SpaceIdx + 1\n            NextOffset = Offset + Item['length']\n            TxtFd.write('%s.%s|%s0x%04X|%s|%s\\n' % (Item['space'], Item['cname'], Default, Item['offset'] - StartAddr, Item['length'], Item['value']))\n        TxtFd.close()\n    return 0",
        "mutated": [
            "def CreateSplitUpdTxt(self, UpdTxtFile):\n    if False:\n        i = 10\n    GuidList = ['FSP_T_UPD_TOOL_GUID', 'FSP_M_UPD_TOOL_GUID', 'FSP_S_UPD_TOOL_GUID', 'FSP_I_UPD_TOOL_GUID']\n    SignatureList = ['0x545F', '0x4D5F', '0x535F', '0x495F']\n    for Index in range(len(GuidList)):\n        UpdTxtFile = ''\n        FvDir = self._FvDir\n        if GuidList[Index] not in self._MacroDict:\n            NoFSPI = False\n            if GuidList[Index] == 'FSP_I_UPD_TOOL_GUID':\n                NoFSPI = True\n                continue\n            else:\n                self.Error = '%s definition is missing in DSC file' % GuidList[Index]\n                return 1\n        if UpdTxtFile == '':\n            UpdTxtFile = os.path.join(FvDir, self._MacroDict[GuidList[Index]] + '.txt')\n        if self.NoDscFileChange(UpdTxtFile):\n            self.Error = 'No DSC file change, skip to create UPD TXT file'\n            return 256\n        TxtFd = open(UpdTxtFile, 'w')\n        TxtFd.write('%s\\n' % (__copyright_txt__ % date.today().year))\n        NextOffset = 0\n        SpaceIdx = 0\n        StartAddr = 0\n        EndAddr = 0\n        Default = 'DEFAULT|'\n        InRange = False\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == SignatureList[Index]:\n                StartAddr = Item['offset']\n                NextOffset = StartAddr\n                InRange = True\n            if Item['cname'] == 'UpdTerminator' and InRange == True:\n                EndAddr = Item['offset']\n                InRange = False\n        InRange = False\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == SignatureList[Index]:\n                InRange = True\n            if InRange != True:\n                continue\n            if Item['cname'] == 'UpdTerminator':\n                InRange = False\n            if Item['region'] != 'UPD':\n                continue\n            Offset = Item['offset']\n            if StartAddr > Offset or EndAddr < Offset:\n                continue\n            if NextOffset < Offset:\n                TxtFd.write('%s.UnusedUpdSpace%d|%s0x%04X|0x%04X|{0}\\n' % (Item['space'], SpaceIdx, Default, NextOffset - StartAddr, Offset - NextOffset))\n                SpaceIdx = SpaceIdx + 1\n            NextOffset = Offset + Item['length']\n            TxtFd.write('%s.%s|%s0x%04X|%s|%s\\n' % (Item['space'], Item['cname'], Default, Item['offset'] - StartAddr, Item['length'], Item['value']))\n        TxtFd.close()\n    return 0",
            "def CreateSplitUpdTxt(self, UpdTxtFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    GuidList = ['FSP_T_UPD_TOOL_GUID', 'FSP_M_UPD_TOOL_GUID', 'FSP_S_UPD_TOOL_GUID', 'FSP_I_UPD_TOOL_GUID']\n    SignatureList = ['0x545F', '0x4D5F', '0x535F', '0x495F']\n    for Index in range(len(GuidList)):\n        UpdTxtFile = ''\n        FvDir = self._FvDir\n        if GuidList[Index] not in self._MacroDict:\n            NoFSPI = False\n            if GuidList[Index] == 'FSP_I_UPD_TOOL_GUID':\n                NoFSPI = True\n                continue\n            else:\n                self.Error = '%s definition is missing in DSC file' % GuidList[Index]\n                return 1\n        if UpdTxtFile == '':\n            UpdTxtFile = os.path.join(FvDir, self._MacroDict[GuidList[Index]] + '.txt')\n        if self.NoDscFileChange(UpdTxtFile):\n            self.Error = 'No DSC file change, skip to create UPD TXT file'\n            return 256\n        TxtFd = open(UpdTxtFile, 'w')\n        TxtFd.write('%s\\n' % (__copyright_txt__ % date.today().year))\n        NextOffset = 0\n        SpaceIdx = 0\n        StartAddr = 0\n        EndAddr = 0\n        Default = 'DEFAULT|'\n        InRange = False\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == SignatureList[Index]:\n                StartAddr = Item['offset']\n                NextOffset = StartAddr\n                InRange = True\n            if Item['cname'] == 'UpdTerminator' and InRange == True:\n                EndAddr = Item['offset']\n                InRange = False\n        InRange = False\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == SignatureList[Index]:\n                InRange = True\n            if InRange != True:\n                continue\n            if Item['cname'] == 'UpdTerminator':\n                InRange = False\n            if Item['region'] != 'UPD':\n                continue\n            Offset = Item['offset']\n            if StartAddr > Offset or EndAddr < Offset:\n                continue\n            if NextOffset < Offset:\n                TxtFd.write('%s.UnusedUpdSpace%d|%s0x%04X|0x%04X|{0}\\n' % (Item['space'], SpaceIdx, Default, NextOffset - StartAddr, Offset - NextOffset))\n                SpaceIdx = SpaceIdx + 1\n            NextOffset = Offset + Item['length']\n            TxtFd.write('%s.%s|%s0x%04X|%s|%s\\n' % (Item['space'], Item['cname'], Default, Item['offset'] - StartAddr, Item['length'], Item['value']))\n        TxtFd.close()\n    return 0",
            "def CreateSplitUpdTxt(self, UpdTxtFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    GuidList = ['FSP_T_UPD_TOOL_GUID', 'FSP_M_UPD_TOOL_GUID', 'FSP_S_UPD_TOOL_GUID', 'FSP_I_UPD_TOOL_GUID']\n    SignatureList = ['0x545F', '0x4D5F', '0x535F', '0x495F']\n    for Index in range(len(GuidList)):\n        UpdTxtFile = ''\n        FvDir = self._FvDir\n        if GuidList[Index] not in self._MacroDict:\n            NoFSPI = False\n            if GuidList[Index] == 'FSP_I_UPD_TOOL_GUID':\n                NoFSPI = True\n                continue\n            else:\n                self.Error = '%s definition is missing in DSC file' % GuidList[Index]\n                return 1\n        if UpdTxtFile == '':\n            UpdTxtFile = os.path.join(FvDir, self._MacroDict[GuidList[Index]] + '.txt')\n        if self.NoDscFileChange(UpdTxtFile):\n            self.Error = 'No DSC file change, skip to create UPD TXT file'\n            return 256\n        TxtFd = open(UpdTxtFile, 'w')\n        TxtFd.write('%s\\n' % (__copyright_txt__ % date.today().year))\n        NextOffset = 0\n        SpaceIdx = 0\n        StartAddr = 0\n        EndAddr = 0\n        Default = 'DEFAULT|'\n        InRange = False\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == SignatureList[Index]:\n                StartAddr = Item['offset']\n                NextOffset = StartAddr\n                InRange = True\n            if Item['cname'] == 'UpdTerminator' and InRange == True:\n                EndAddr = Item['offset']\n                InRange = False\n        InRange = False\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == SignatureList[Index]:\n                InRange = True\n            if InRange != True:\n                continue\n            if Item['cname'] == 'UpdTerminator':\n                InRange = False\n            if Item['region'] != 'UPD':\n                continue\n            Offset = Item['offset']\n            if StartAddr > Offset or EndAddr < Offset:\n                continue\n            if NextOffset < Offset:\n                TxtFd.write('%s.UnusedUpdSpace%d|%s0x%04X|0x%04X|{0}\\n' % (Item['space'], SpaceIdx, Default, NextOffset - StartAddr, Offset - NextOffset))\n                SpaceIdx = SpaceIdx + 1\n            NextOffset = Offset + Item['length']\n            TxtFd.write('%s.%s|%s0x%04X|%s|%s\\n' % (Item['space'], Item['cname'], Default, Item['offset'] - StartAddr, Item['length'], Item['value']))\n        TxtFd.close()\n    return 0",
            "def CreateSplitUpdTxt(self, UpdTxtFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    GuidList = ['FSP_T_UPD_TOOL_GUID', 'FSP_M_UPD_TOOL_GUID', 'FSP_S_UPD_TOOL_GUID', 'FSP_I_UPD_TOOL_GUID']\n    SignatureList = ['0x545F', '0x4D5F', '0x535F', '0x495F']\n    for Index in range(len(GuidList)):\n        UpdTxtFile = ''\n        FvDir = self._FvDir\n        if GuidList[Index] not in self._MacroDict:\n            NoFSPI = False\n            if GuidList[Index] == 'FSP_I_UPD_TOOL_GUID':\n                NoFSPI = True\n                continue\n            else:\n                self.Error = '%s definition is missing in DSC file' % GuidList[Index]\n                return 1\n        if UpdTxtFile == '':\n            UpdTxtFile = os.path.join(FvDir, self._MacroDict[GuidList[Index]] + '.txt')\n        if self.NoDscFileChange(UpdTxtFile):\n            self.Error = 'No DSC file change, skip to create UPD TXT file'\n            return 256\n        TxtFd = open(UpdTxtFile, 'w')\n        TxtFd.write('%s\\n' % (__copyright_txt__ % date.today().year))\n        NextOffset = 0\n        SpaceIdx = 0\n        StartAddr = 0\n        EndAddr = 0\n        Default = 'DEFAULT|'\n        InRange = False\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == SignatureList[Index]:\n                StartAddr = Item['offset']\n                NextOffset = StartAddr\n                InRange = True\n            if Item['cname'] == 'UpdTerminator' and InRange == True:\n                EndAddr = Item['offset']\n                InRange = False\n        InRange = False\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == SignatureList[Index]:\n                InRange = True\n            if InRange != True:\n                continue\n            if Item['cname'] == 'UpdTerminator':\n                InRange = False\n            if Item['region'] != 'UPD':\n                continue\n            Offset = Item['offset']\n            if StartAddr > Offset or EndAddr < Offset:\n                continue\n            if NextOffset < Offset:\n                TxtFd.write('%s.UnusedUpdSpace%d|%s0x%04X|0x%04X|{0}\\n' % (Item['space'], SpaceIdx, Default, NextOffset - StartAddr, Offset - NextOffset))\n                SpaceIdx = SpaceIdx + 1\n            NextOffset = Offset + Item['length']\n            TxtFd.write('%s.%s|%s0x%04X|%s|%s\\n' % (Item['space'], Item['cname'], Default, Item['offset'] - StartAddr, Item['length'], Item['value']))\n        TxtFd.close()\n    return 0",
            "def CreateSplitUpdTxt(self, UpdTxtFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    GuidList = ['FSP_T_UPD_TOOL_GUID', 'FSP_M_UPD_TOOL_GUID', 'FSP_S_UPD_TOOL_GUID', 'FSP_I_UPD_TOOL_GUID']\n    SignatureList = ['0x545F', '0x4D5F', '0x535F', '0x495F']\n    for Index in range(len(GuidList)):\n        UpdTxtFile = ''\n        FvDir = self._FvDir\n        if GuidList[Index] not in self._MacroDict:\n            NoFSPI = False\n            if GuidList[Index] == 'FSP_I_UPD_TOOL_GUID':\n                NoFSPI = True\n                continue\n            else:\n                self.Error = '%s definition is missing in DSC file' % GuidList[Index]\n                return 1\n        if UpdTxtFile == '':\n            UpdTxtFile = os.path.join(FvDir, self._MacroDict[GuidList[Index]] + '.txt')\n        if self.NoDscFileChange(UpdTxtFile):\n            self.Error = 'No DSC file change, skip to create UPD TXT file'\n            return 256\n        TxtFd = open(UpdTxtFile, 'w')\n        TxtFd.write('%s\\n' % (__copyright_txt__ % date.today().year))\n        NextOffset = 0\n        SpaceIdx = 0\n        StartAddr = 0\n        EndAddr = 0\n        Default = 'DEFAULT|'\n        InRange = False\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == SignatureList[Index]:\n                StartAddr = Item['offset']\n                NextOffset = StartAddr\n                InRange = True\n            if Item['cname'] == 'UpdTerminator' and InRange == True:\n                EndAddr = Item['offset']\n                InRange = False\n        InRange = False\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == SignatureList[Index]:\n                InRange = True\n            if InRange != True:\n                continue\n            if Item['cname'] == 'UpdTerminator':\n                InRange = False\n            if Item['region'] != 'UPD':\n                continue\n            Offset = Item['offset']\n            if StartAddr > Offset or EndAddr < Offset:\n                continue\n            if NextOffset < Offset:\n                TxtFd.write('%s.UnusedUpdSpace%d|%s0x%04X|0x%04X|{0}\\n' % (Item['space'], SpaceIdx, Default, NextOffset - StartAddr, Offset - NextOffset))\n                SpaceIdx = SpaceIdx + 1\n            NextOffset = Offset + Item['length']\n            TxtFd.write('%s.%s|%s0x%04X|%s|%s\\n' % (Item['space'], Item['cname'], Default, Item['offset'] - StartAddr, Item['length'], Item['value']))\n        TxtFd.close()\n    return 0"
        ]
    },
    {
        "func_name": "CreateVarDict",
        "original": "def CreateVarDict(self):\n    Error = 0\n    self._VarDict = {}\n    if len(self._CfgItemList) > 0:\n        Item = self._CfgItemList[-1]\n        self._VarDict['_LENGTH_'] = '%d' % (Item['offset'] + Item['length'])\n    for Item in self._CfgItemList:\n        Embed = Item['embed']\n        Match = re.match('^(\\\\w+):(\\\\w+):(START|END)', Embed)\n        if Match:\n            StructName = Match.group(1)\n            VarName = '_%s_%s_' % (Match.group(3), StructName)\n            if Match.group(3) == 'END':\n                self._VarDict[VarName] = Item['offset'] + Item['length']\n                self._VarDict['_LENGTH_%s_' % StructName] = self._VarDict['_END_%s_' % StructName] - self._VarDict['_START_%s_' % StructName]\n                if Match.group(2).startswith('TAG_'):\n                    if self.Mode != 'FSP' and self._VarDict['_LENGTH_%s_' % StructName] % 4:\n                        raise Exception(\"Size of structure '%s' is %d, not DWORD aligned !\" % (StructName, self._VarDict['_LENGTH_%s_' % StructName]))\n                    self._VarDict['_TAG_%s_' % StructName] = int(Match.group(2)[4:], 16) & 4095\n            else:\n                self._VarDict[VarName] = Item['offset']\n        if Item['marker']:\n            self._VarDict['_OFFSET_%s_' % Item['marker'].strip()] = Item['offset']\n    return Error",
        "mutated": [
            "def CreateVarDict(self):\n    if False:\n        i = 10\n    Error = 0\n    self._VarDict = {}\n    if len(self._CfgItemList) > 0:\n        Item = self._CfgItemList[-1]\n        self._VarDict['_LENGTH_'] = '%d' % (Item['offset'] + Item['length'])\n    for Item in self._CfgItemList:\n        Embed = Item['embed']\n        Match = re.match('^(\\\\w+):(\\\\w+):(START|END)', Embed)\n        if Match:\n            StructName = Match.group(1)\n            VarName = '_%s_%s_' % (Match.group(3), StructName)\n            if Match.group(3) == 'END':\n                self._VarDict[VarName] = Item['offset'] + Item['length']\n                self._VarDict['_LENGTH_%s_' % StructName] = self._VarDict['_END_%s_' % StructName] - self._VarDict['_START_%s_' % StructName]\n                if Match.group(2).startswith('TAG_'):\n                    if self.Mode != 'FSP' and self._VarDict['_LENGTH_%s_' % StructName] % 4:\n                        raise Exception(\"Size of structure '%s' is %d, not DWORD aligned !\" % (StructName, self._VarDict['_LENGTH_%s_' % StructName]))\n                    self._VarDict['_TAG_%s_' % StructName] = int(Match.group(2)[4:], 16) & 4095\n            else:\n                self._VarDict[VarName] = Item['offset']\n        if Item['marker']:\n            self._VarDict['_OFFSET_%s_' % Item['marker'].strip()] = Item['offset']\n    return Error",
            "def CreateVarDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Error = 0\n    self._VarDict = {}\n    if len(self._CfgItemList) > 0:\n        Item = self._CfgItemList[-1]\n        self._VarDict['_LENGTH_'] = '%d' % (Item['offset'] + Item['length'])\n    for Item in self._CfgItemList:\n        Embed = Item['embed']\n        Match = re.match('^(\\\\w+):(\\\\w+):(START|END)', Embed)\n        if Match:\n            StructName = Match.group(1)\n            VarName = '_%s_%s_' % (Match.group(3), StructName)\n            if Match.group(3) == 'END':\n                self._VarDict[VarName] = Item['offset'] + Item['length']\n                self._VarDict['_LENGTH_%s_' % StructName] = self._VarDict['_END_%s_' % StructName] - self._VarDict['_START_%s_' % StructName]\n                if Match.group(2).startswith('TAG_'):\n                    if self.Mode != 'FSP' and self._VarDict['_LENGTH_%s_' % StructName] % 4:\n                        raise Exception(\"Size of structure '%s' is %d, not DWORD aligned !\" % (StructName, self._VarDict['_LENGTH_%s_' % StructName]))\n                    self._VarDict['_TAG_%s_' % StructName] = int(Match.group(2)[4:], 16) & 4095\n            else:\n                self._VarDict[VarName] = Item['offset']\n        if Item['marker']:\n            self._VarDict['_OFFSET_%s_' % Item['marker'].strip()] = Item['offset']\n    return Error",
            "def CreateVarDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Error = 0\n    self._VarDict = {}\n    if len(self._CfgItemList) > 0:\n        Item = self._CfgItemList[-1]\n        self._VarDict['_LENGTH_'] = '%d' % (Item['offset'] + Item['length'])\n    for Item in self._CfgItemList:\n        Embed = Item['embed']\n        Match = re.match('^(\\\\w+):(\\\\w+):(START|END)', Embed)\n        if Match:\n            StructName = Match.group(1)\n            VarName = '_%s_%s_' % (Match.group(3), StructName)\n            if Match.group(3) == 'END':\n                self._VarDict[VarName] = Item['offset'] + Item['length']\n                self._VarDict['_LENGTH_%s_' % StructName] = self._VarDict['_END_%s_' % StructName] - self._VarDict['_START_%s_' % StructName]\n                if Match.group(2).startswith('TAG_'):\n                    if self.Mode != 'FSP' and self._VarDict['_LENGTH_%s_' % StructName] % 4:\n                        raise Exception(\"Size of structure '%s' is %d, not DWORD aligned !\" % (StructName, self._VarDict['_LENGTH_%s_' % StructName]))\n                    self._VarDict['_TAG_%s_' % StructName] = int(Match.group(2)[4:], 16) & 4095\n            else:\n                self._VarDict[VarName] = Item['offset']\n        if Item['marker']:\n            self._VarDict['_OFFSET_%s_' % Item['marker'].strip()] = Item['offset']\n    return Error",
            "def CreateVarDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Error = 0\n    self._VarDict = {}\n    if len(self._CfgItemList) > 0:\n        Item = self._CfgItemList[-1]\n        self._VarDict['_LENGTH_'] = '%d' % (Item['offset'] + Item['length'])\n    for Item in self._CfgItemList:\n        Embed = Item['embed']\n        Match = re.match('^(\\\\w+):(\\\\w+):(START|END)', Embed)\n        if Match:\n            StructName = Match.group(1)\n            VarName = '_%s_%s_' % (Match.group(3), StructName)\n            if Match.group(3) == 'END':\n                self._VarDict[VarName] = Item['offset'] + Item['length']\n                self._VarDict['_LENGTH_%s_' % StructName] = self._VarDict['_END_%s_' % StructName] - self._VarDict['_START_%s_' % StructName]\n                if Match.group(2).startswith('TAG_'):\n                    if self.Mode != 'FSP' and self._VarDict['_LENGTH_%s_' % StructName] % 4:\n                        raise Exception(\"Size of structure '%s' is %d, not DWORD aligned !\" % (StructName, self._VarDict['_LENGTH_%s_' % StructName]))\n                    self._VarDict['_TAG_%s_' % StructName] = int(Match.group(2)[4:], 16) & 4095\n            else:\n                self._VarDict[VarName] = Item['offset']\n        if Item['marker']:\n            self._VarDict['_OFFSET_%s_' % Item['marker'].strip()] = Item['offset']\n    return Error",
            "def CreateVarDict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Error = 0\n    self._VarDict = {}\n    if len(self._CfgItemList) > 0:\n        Item = self._CfgItemList[-1]\n        self._VarDict['_LENGTH_'] = '%d' % (Item['offset'] + Item['length'])\n    for Item in self._CfgItemList:\n        Embed = Item['embed']\n        Match = re.match('^(\\\\w+):(\\\\w+):(START|END)', Embed)\n        if Match:\n            StructName = Match.group(1)\n            VarName = '_%s_%s_' % (Match.group(3), StructName)\n            if Match.group(3) == 'END':\n                self._VarDict[VarName] = Item['offset'] + Item['length']\n                self._VarDict['_LENGTH_%s_' % StructName] = self._VarDict['_END_%s_' % StructName] - self._VarDict['_START_%s_' % StructName]\n                if Match.group(2).startswith('TAG_'):\n                    if self.Mode != 'FSP' and self._VarDict['_LENGTH_%s_' % StructName] % 4:\n                        raise Exception(\"Size of structure '%s' is %d, not DWORD aligned !\" % (StructName, self._VarDict['_LENGTH_%s_' % StructName]))\n                    self._VarDict['_TAG_%s_' % StructName] = int(Match.group(2)[4:], 16) & 4095\n            else:\n                self._VarDict[VarName] = Item['offset']\n        if Item['marker']:\n            self._VarDict['_OFFSET_%s_' % Item['marker'].strip()] = Item['offset']\n    return Error"
        ]
    },
    {
        "func_name": "UpdateBsfBitUnit",
        "original": "def UpdateBsfBitUnit(self, Item):\n    BitTotal = 0\n    BitOffset = 0\n    StartIdx = 0\n    Unit = None\n    UnitDec = {1: 'BYTE', 2: 'WORD', 4: 'DWORD', 8: 'QWORD'}\n    for (Idx, SubItem) in enumerate(Item['subreg']):\n        if Unit is None:\n            Unit = SubItem['bitunit']\n        BitLength = SubItem['bitlength']\n        BitTotal += BitLength\n        BitOffset += BitLength\n        if BitOffset > 64 or BitOffset > Unit * 8:\n            break\n        if BitOffset == Unit * 8:\n            for SubIdx in range(StartIdx, Idx + 1):\n                Item['subreg'][SubIdx]['bitunit'] = Unit\n            BitOffset = 0\n            StartIdx = Idx + 1\n            Unit = None\n    if BitOffset > 0:\n        raise Exception(\"Bit fields cannot fit into %s for '%s.%s' !\" % (UnitDec[Unit], Item['cname'], SubItem['cname']))\n    ExpectedTotal = Item['length'] * 8\n    if Item['length'] * 8 != BitTotal:\n        raise Exception(\"Bit fields total length (%d) does not match length (%d) of '%s' !\" % (BitTotal, ExpectedTotal, Item['cname']))",
        "mutated": [
            "def UpdateBsfBitUnit(self, Item):\n    if False:\n        i = 10\n    BitTotal = 0\n    BitOffset = 0\n    StartIdx = 0\n    Unit = None\n    UnitDec = {1: 'BYTE', 2: 'WORD', 4: 'DWORD', 8: 'QWORD'}\n    for (Idx, SubItem) in enumerate(Item['subreg']):\n        if Unit is None:\n            Unit = SubItem['bitunit']\n        BitLength = SubItem['bitlength']\n        BitTotal += BitLength\n        BitOffset += BitLength\n        if BitOffset > 64 or BitOffset > Unit * 8:\n            break\n        if BitOffset == Unit * 8:\n            for SubIdx in range(StartIdx, Idx + 1):\n                Item['subreg'][SubIdx]['bitunit'] = Unit\n            BitOffset = 0\n            StartIdx = Idx + 1\n            Unit = None\n    if BitOffset > 0:\n        raise Exception(\"Bit fields cannot fit into %s for '%s.%s' !\" % (UnitDec[Unit], Item['cname'], SubItem['cname']))\n    ExpectedTotal = Item['length'] * 8\n    if Item['length'] * 8 != BitTotal:\n        raise Exception(\"Bit fields total length (%d) does not match length (%d) of '%s' !\" % (BitTotal, ExpectedTotal, Item['cname']))",
            "def UpdateBsfBitUnit(self, Item):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    BitTotal = 0\n    BitOffset = 0\n    StartIdx = 0\n    Unit = None\n    UnitDec = {1: 'BYTE', 2: 'WORD', 4: 'DWORD', 8: 'QWORD'}\n    for (Idx, SubItem) in enumerate(Item['subreg']):\n        if Unit is None:\n            Unit = SubItem['bitunit']\n        BitLength = SubItem['bitlength']\n        BitTotal += BitLength\n        BitOffset += BitLength\n        if BitOffset > 64 or BitOffset > Unit * 8:\n            break\n        if BitOffset == Unit * 8:\n            for SubIdx in range(StartIdx, Idx + 1):\n                Item['subreg'][SubIdx]['bitunit'] = Unit\n            BitOffset = 0\n            StartIdx = Idx + 1\n            Unit = None\n    if BitOffset > 0:\n        raise Exception(\"Bit fields cannot fit into %s for '%s.%s' !\" % (UnitDec[Unit], Item['cname'], SubItem['cname']))\n    ExpectedTotal = Item['length'] * 8\n    if Item['length'] * 8 != BitTotal:\n        raise Exception(\"Bit fields total length (%d) does not match length (%d) of '%s' !\" % (BitTotal, ExpectedTotal, Item['cname']))",
            "def UpdateBsfBitUnit(self, Item):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    BitTotal = 0\n    BitOffset = 0\n    StartIdx = 0\n    Unit = None\n    UnitDec = {1: 'BYTE', 2: 'WORD', 4: 'DWORD', 8: 'QWORD'}\n    for (Idx, SubItem) in enumerate(Item['subreg']):\n        if Unit is None:\n            Unit = SubItem['bitunit']\n        BitLength = SubItem['bitlength']\n        BitTotal += BitLength\n        BitOffset += BitLength\n        if BitOffset > 64 or BitOffset > Unit * 8:\n            break\n        if BitOffset == Unit * 8:\n            for SubIdx in range(StartIdx, Idx + 1):\n                Item['subreg'][SubIdx]['bitunit'] = Unit\n            BitOffset = 0\n            StartIdx = Idx + 1\n            Unit = None\n    if BitOffset > 0:\n        raise Exception(\"Bit fields cannot fit into %s for '%s.%s' !\" % (UnitDec[Unit], Item['cname'], SubItem['cname']))\n    ExpectedTotal = Item['length'] * 8\n    if Item['length'] * 8 != BitTotal:\n        raise Exception(\"Bit fields total length (%d) does not match length (%d) of '%s' !\" % (BitTotal, ExpectedTotal, Item['cname']))",
            "def UpdateBsfBitUnit(self, Item):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    BitTotal = 0\n    BitOffset = 0\n    StartIdx = 0\n    Unit = None\n    UnitDec = {1: 'BYTE', 2: 'WORD', 4: 'DWORD', 8: 'QWORD'}\n    for (Idx, SubItem) in enumerate(Item['subreg']):\n        if Unit is None:\n            Unit = SubItem['bitunit']\n        BitLength = SubItem['bitlength']\n        BitTotal += BitLength\n        BitOffset += BitLength\n        if BitOffset > 64 or BitOffset > Unit * 8:\n            break\n        if BitOffset == Unit * 8:\n            for SubIdx in range(StartIdx, Idx + 1):\n                Item['subreg'][SubIdx]['bitunit'] = Unit\n            BitOffset = 0\n            StartIdx = Idx + 1\n            Unit = None\n    if BitOffset > 0:\n        raise Exception(\"Bit fields cannot fit into %s for '%s.%s' !\" % (UnitDec[Unit], Item['cname'], SubItem['cname']))\n    ExpectedTotal = Item['length'] * 8\n    if Item['length'] * 8 != BitTotal:\n        raise Exception(\"Bit fields total length (%d) does not match length (%d) of '%s' !\" % (BitTotal, ExpectedTotal, Item['cname']))",
            "def UpdateBsfBitUnit(self, Item):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    BitTotal = 0\n    BitOffset = 0\n    StartIdx = 0\n    Unit = None\n    UnitDec = {1: 'BYTE', 2: 'WORD', 4: 'DWORD', 8: 'QWORD'}\n    for (Idx, SubItem) in enumerate(Item['subreg']):\n        if Unit is None:\n            Unit = SubItem['bitunit']\n        BitLength = SubItem['bitlength']\n        BitTotal += BitLength\n        BitOffset += BitLength\n        if BitOffset > 64 or BitOffset > Unit * 8:\n            break\n        if BitOffset == Unit * 8:\n            for SubIdx in range(StartIdx, Idx + 1):\n                Item['subreg'][SubIdx]['bitunit'] = Unit\n            BitOffset = 0\n            StartIdx = Idx + 1\n            Unit = None\n    if BitOffset > 0:\n        raise Exception(\"Bit fields cannot fit into %s for '%s.%s' !\" % (UnitDec[Unit], Item['cname'], SubItem['cname']))\n    ExpectedTotal = Item['length'] * 8\n    if Item['length'] * 8 != BitTotal:\n        raise Exception(\"Bit fields total length (%d) does not match length (%d) of '%s' !\" % (BitTotal, ExpectedTotal, Item['cname']))"
        ]
    },
    {
        "func_name": "UpdateDefaultValue",
        "original": "def UpdateDefaultValue(self):\n    Error = 0\n    for (Idx, Item) in enumerate(self._CfgItemList):\n        if len(Item['subreg']) == 0:\n            Value = Item['value']\n            if len(Value) > 0 and (Value[0] == '{' or Value[0] == \"'\" or Value[0] == '\"'):\n                self.FormatListValue(self._CfgItemList[Idx])\n            else:\n                Match = re.match('(0x[0-9a-fA-F]+|[0-9]+)', Value)\n                if not Match:\n                    NumValue = self.EvaluateExpress(Value)\n                    Item['value'] = '0x%X' % NumValue\n        else:\n            ValArray = self.ValueToByteArray(Item['value'], Item['length'])\n            for SubItem in Item['subreg']:\n                SubItem['value'] = self.GetBsfBitFields(SubItem, ValArray)\n            self.UpdateBsfBitUnit(Item)\n    return Error",
        "mutated": [
            "def UpdateDefaultValue(self):\n    if False:\n        i = 10\n    Error = 0\n    for (Idx, Item) in enumerate(self._CfgItemList):\n        if len(Item['subreg']) == 0:\n            Value = Item['value']\n            if len(Value) > 0 and (Value[0] == '{' or Value[0] == \"'\" or Value[0] == '\"'):\n                self.FormatListValue(self._CfgItemList[Idx])\n            else:\n                Match = re.match('(0x[0-9a-fA-F]+|[0-9]+)', Value)\n                if not Match:\n                    NumValue = self.EvaluateExpress(Value)\n                    Item['value'] = '0x%X' % NumValue\n        else:\n            ValArray = self.ValueToByteArray(Item['value'], Item['length'])\n            for SubItem in Item['subreg']:\n                SubItem['value'] = self.GetBsfBitFields(SubItem, ValArray)\n            self.UpdateBsfBitUnit(Item)\n    return Error",
            "def UpdateDefaultValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Error = 0\n    for (Idx, Item) in enumerate(self._CfgItemList):\n        if len(Item['subreg']) == 0:\n            Value = Item['value']\n            if len(Value) > 0 and (Value[0] == '{' or Value[0] == \"'\" or Value[0] == '\"'):\n                self.FormatListValue(self._CfgItemList[Idx])\n            else:\n                Match = re.match('(0x[0-9a-fA-F]+|[0-9]+)', Value)\n                if not Match:\n                    NumValue = self.EvaluateExpress(Value)\n                    Item['value'] = '0x%X' % NumValue\n        else:\n            ValArray = self.ValueToByteArray(Item['value'], Item['length'])\n            for SubItem in Item['subreg']:\n                SubItem['value'] = self.GetBsfBitFields(SubItem, ValArray)\n            self.UpdateBsfBitUnit(Item)\n    return Error",
            "def UpdateDefaultValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Error = 0\n    for (Idx, Item) in enumerate(self._CfgItemList):\n        if len(Item['subreg']) == 0:\n            Value = Item['value']\n            if len(Value) > 0 and (Value[0] == '{' or Value[0] == \"'\" or Value[0] == '\"'):\n                self.FormatListValue(self._CfgItemList[Idx])\n            else:\n                Match = re.match('(0x[0-9a-fA-F]+|[0-9]+)', Value)\n                if not Match:\n                    NumValue = self.EvaluateExpress(Value)\n                    Item['value'] = '0x%X' % NumValue\n        else:\n            ValArray = self.ValueToByteArray(Item['value'], Item['length'])\n            for SubItem in Item['subreg']:\n                SubItem['value'] = self.GetBsfBitFields(SubItem, ValArray)\n            self.UpdateBsfBitUnit(Item)\n    return Error",
            "def UpdateDefaultValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Error = 0\n    for (Idx, Item) in enumerate(self._CfgItemList):\n        if len(Item['subreg']) == 0:\n            Value = Item['value']\n            if len(Value) > 0 and (Value[0] == '{' or Value[0] == \"'\" or Value[0] == '\"'):\n                self.FormatListValue(self._CfgItemList[Idx])\n            else:\n                Match = re.match('(0x[0-9a-fA-F]+|[0-9]+)', Value)\n                if not Match:\n                    NumValue = self.EvaluateExpress(Value)\n                    Item['value'] = '0x%X' % NumValue\n        else:\n            ValArray = self.ValueToByteArray(Item['value'], Item['length'])\n            for SubItem in Item['subreg']:\n                SubItem['value'] = self.GetBsfBitFields(SubItem, ValArray)\n            self.UpdateBsfBitUnit(Item)\n    return Error",
            "def UpdateDefaultValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Error = 0\n    for (Idx, Item) in enumerate(self._CfgItemList):\n        if len(Item['subreg']) == 0:\n            Value = Item['value']\n            if len(Value) > 0 and (Value[0] == '{' or Value[0] == \"'\" or Value[0] == '\"'):\n                self.FormatListValue(self._CfgItemList[Idx])\n            else:\n                Match = re.match('(0x[0-9a-fA-F]+|[0-9]+)', Value)\n                if not Match:\n                    NumValue = self.EvaluateExpress(Value)\n                    Item['value'] = '0x%X' % NumValue\n        else:\n            ValArray = self.ValueToByteArray(Item['value'], Item['length'])\n            for SubItem in Item['subreg']:\n                SubItem['value'] = self.GetBsfBitFields(SubItem, ValArray)\n            self.UpdateBsfBitUnit(Item)\n    return Error"
        ]
    },
    {
        "func_name": "ProcessMultilines",
        "original": "def ProcessMultilines(self, String, MaxCharLength):\n    Multilines = ''\n    StringLength = len(String)\n    CurrentStringStart = 0\n    StringOffset = 0\n    BreakLineDict = []\n    if len(String) <= MaxCharLength:\n        while StringOffset < StringLength:\n            if StringOffset >= 1:\n                if String[StringOffset - 1] == '\\\\' and String[StringOffset] == 'n':\n                    BreakLineDict.append(StringOffset + 1)\n            StringOffset += 1\n        if BreakLineDict != []:\n            for Each in BreakLineDict:\n                Multilines += '  %s\\n' % String[CurrentStringStart:Each].lstrip()\n                CurrentStringStart = Each\n            if StringLength - CurrentStringStart > 0:\n                Multilines += '  %s\\n' % String[CurrentStringStart:].lstrip()\n        else:\n            Multilines = '  %s\\n' % String\n    else:\n        NewLineStart = 0\n        NewLineCount = 0\n        FoundSpaceChar = False\n        while StringOffset < StringLength:\n            if StringOffset >= 1:\n                if NewLineCount >= MaxCharLength - 1:\n                    if String[StringOffset] == ' ' and StringLength - StringOffset > 10:\n                        BreakLineDict.append(NewLineStart + NewLineCount)\n                        NewLineStart = NewLineStart + NewLineCount\n                        NewLineCount = 0\n                        FoundSpaceChar = True\n                    elif StringOffset == StringLength - 1 and FoundSpaceChar == False:\n                        BreakLineDict.append(0)\n                if String[StringOffset - 1] == '\\\\' and String[StringOffset] == 'n':\n                    BreakLineDict.append(StringOffset + 1)\n                    NewLineStart = StringOffset + 1\n                    NewLineCount = 0\n            StringOffset += 1\n            NewLineCount += 1\n        if BreakLineDict != []:\n            BreakLineDict.sort()\n            for Each in BreakLineDict:\n                if Each > 0:\n                    Multilines += '  %s\\n' % String[CurrentStringStart:Each].lstrip()\n                CurrentStringStart = Each\n            if StringLength - CurrentStringStart > 0:\n                Multilines += '  %s\\n' % String[CurrentStringStart:].lstrip()\n    return Multilines",
        "mutated": [
            "def ProcessMultilines(self, String, MaxCharLength):\n    if False:\n        i = 10\n    Multilines = ''\n    StringLength = len(String)\n    CurrentStringStart = 0\n    StringOffset = 0\n    BreakLineDict = []\n    if len(String) <= MaxCharLength:\n        while StringOffset < StringLength:\n            if StringOffset >= 1:\n                if String[StringOffset - 1] == '\\\\' and String[StringOffset] == 'n':\n                    BreakLineDict.append(StringOffset + 1)\n            StringOffset += 1\n        if BreakLineDict != []:\n            for Each in BreakLineDict:\n                Multilines += '  %s\\n' % String[CurrentStringStart:Each].lstrip()\n                CurrentStringStart = Each\n            if StringLength - CurrentStringStart > 0:\n                Multilines += '  %s\\n' % String[CurrentStringStart:].lstrip()\n        else:\n            Multilines = '  %s\\n' % String\n    else:\n        NewLineStart = 0\n        NewLineCount = 0\n        FoundSpaceChar = False\n        while StringOffset < StringLength:\n            if StringOffset >= 1:\n                if NewLineCount >= MaxCharLength - 1:\n                    if String[StringOffset] == ' ' and StringLength - StringOffset > 10:\n                        BreakLineDict.append(NewLineStart + NewLineCount)\n                        NewLineStart = NewLineStart + NewLineCount\n                        NewLineCount = 0\n                        FoundSpaceChar = True\n                    elif StringOffset == StringLength - 1 and FoundSpaceChar == False:\n                        BreakLineDict.append(0)\n                if String[StringOffset - 1] == '\\\\' and String[StringOffset] == 'n':\n                    BreakLineDict.append(StringOffset + 1)\n                    NewLineStart = StringOffset + 1\n                    NewLineCount = 0\n            StringOffset += 1\n            NewLineCount += 1\n        if BreakLineDict != []:\n            BreakLineDict.sort()\n            for Each in BreakLineDict:\n                if Each > 0:\n                    Multilines += '  %s\\n' % String[CurrentStringStart:Each].lstrip()\n                CurrentStringStart = Each\n            if StringLength - CurrentStringStart > 0:\n                Multilines += '  %s\\n' % String[CurrentStringStart:].lstrip()\n    return Multilines",
            "def ProcessMultilines(self, String, MaxCharLength):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Multilines = ''\n    StringLength = len(String)\n    CurrentStringStart = 0\n    StringOffset = 0\n    BreakLineDict = []\n    if len(String) <= MaxCharLength:\n        while StringOffset < StringLength:\n            if StringOffset >= 1:\n                if String[StringOffset - 1] == '\\\\' and String[StringOffset] == 'n':\n                    BreakLineDict.append(StringOffset + 1)\n            StringOffset += 1\n        if BreakLineDict != []:\n            for Each in BreakLineDict:\n                Multilines += '  %s\\n' % String[CurrentStringStart:Each].lstrip()\n                CurrentStringStart = Each\n            if StringLength - CurrentStringStart > 0:\n                Multilines += '  %s\\n' % String[CurrentStringStart:].lstrip()\n        else:\n            Multilines = '  %s\\n' % String\n    else:\n        NewLineStart = 0\n        NewLineCount = 0\n        FoundSpaceChar = False\n        while StringOffset < StringLength:\n            if StringOffset >= 1:\n                if NewLineCount >= MaxCharLength - 1:\n                    if String[StringOffset] == ' ' and StringLength - StringOffset > 10:\n                        BreakLineDict.append(NewLineStart + NewLineCount)\n                        NewLineStart = NewLineStart + NewLineCount\n                        NewLineCount = 0\n                        FoundSpaceChar = True\n                    elif StringOffset == StringLength - 1 and FoundSpaceChar == False:\n                        BreakLineDict.append(0)\n                if String[StringOffset - 1] == '\\\\' and String[StringOffset] == 'n':\n                    BreakLineDict.append(StringOffset + 1)\n                    NewLineStart = StringOffset + 1\n                    NewLineCount = 0\n            StringOffset += 1\n            NewLineCount += 1\n        if BreakLineDict != []:\n            BreakLineDict.sort()\n            for Each in BreakLineDict:\n                if Each > 0:\n                    Multilines += '  %s\\n' % String[CurrentStringStart:Each].lstrip()\n                CurrentStringStart = Each\n            if StringLength - CurrentStringStart > 0:\n                Multilines += '  %s\\n' % String[CurrentStringStart:].lstrip()\n    return Multilines",
            "def ProcessMultilines(self, String, MaxCharLength):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Multilines = ''\n    StringLength = len(String)\n    CurrentStringStart = 0\n    StringOffset = 0\n    BreakLineDict = []\n    if len(String) <= MaxCharLength:\n        while StringOffset < StringLength:\n            if StringOffset >= 1:\n                if String[StringOffset - 1] == '\\\\' and String[StringOffset] == 'n':\n                    BreakLineDict.append(StringOffset + 1)\n            StringOffset += 1\n        if BreakLineDict != []:\n            for Each in BreakLineDict:\n                Multilines += '  %s\\n' % String[CurrentStringStart:Each].lstrip()\n                CurrentStringStart = Each\n            if StringLength - CurrentStringStart > 0:\n                Multilines += '  %s\\n' % String[CurrentStringStart:].lstrip()\n        else:\n            Multilines = '  %s\\n' % String\n    else:\n        NewLineStart = 0\n        NewLineCount = 0\n        FoundSpaceChar = False\n        while StringOffset < StringLength:\n            if StringOffset >= 1:\n                if NewLineCount >= MaxCharLength - 1:\n                    if String[StringOffset] == ' ' and StringLength - StringOffset > 10:\n                        BreakLineDict.append(NewLineStart + NewLineCount)\n                        NewLineStart = NewLineStart + NewLineCount\n                        NewLineCount = 0\n                        FoundSpaceChar = True\n                    elif StringOffset == StringLength - 1 and FoundSpaceChar == False:\n                        BreakLineDict.append(0)\n                if String[StringOffset - 1] == '\\\\' and String[StringOffset] == 'n':\n                    BreakLineDict.append(StringOffset + 1)\n                    NewLineStart = StringOffset + 1\n                    NewLineCount = 0\n            StringOffset += 1\n            NewLineCount += 1\n        if BreakLineDict != []:\n            BreakLineDict.sort()\n            for Each in BreakLineDict:\n                if Each > 0:\n                    Multilines += '  %s\\n' % String[CurrentStringStart:Each].lstrip()\n                CurrentStringStart = Each\n            if StringLength - CurrentStringStart > 0:\n                Multilines += '  %s\\n' % String[CurrentStringStart:].lstrip()\n    return Multilines",
            "def ProcessMultilines(self, String, MaxCharLength):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Multilines = ''\n    StringLength = len(String)\n    CurrentStringStart = 0\n    StringOffset = 0\n    BreakLineDict = []\n    if len(String) <= MaxCharLength:\n        while StringOffset < StringLength:\n            if StringOffset >= 1:\n                if String[StringOffset - 1] == '\\\\' and String[StringOffset] == 'n':\n                    BreakLineDict.append(StringOffset + 1)\n            StringOffset += 1\n        if BreakLineDict != []:\n            for Each in BreakLineDict:\n                Multilines += '  %s\\n' % String[CurrentStringStart:Each].lstrip()\n                CurrentStringStart = Each\n            if StringLength - CurrentStringStart > 0:\n                Multilines += '  %s\\n' % String[CurrentStringStart:].lstrip()\n        else:\n            Multilines = '  %s\\n' % String\n    else:\n        NewLineStart = 0\n        NewLineCount = 0\n        FoundSpaceChar = False\n        while StringOffset < StringLength:\n            if StringOffset >= 1:\n                if NewLineCount >= MaxCharLength - 1:\n                    if String[StringOffset] == ' ' and StringLength - StringOffset > 10:\n                        BreakLineDict.append(NewLineStart + NewLineCount)\n                        NewLineStart = NewLineStart + NewLineCount\n                        NewLineCount = 0\n                        FoundSpaceChar = True\n                    elif StringOffset == StringLength - 1 and FoundSpaceChar == False:\n                        BreakLineDict.append(0)\n                if String[StringOffset - 1] == '\\\\' and String[StringOffset] == 'n':\n                    BreakLineDict.append(StringOffset + 1)\n                    NewLineStart = StringOffset + 1\n                    NewLineCount = 0\n            StringOffset += 1\n            NewLineCount += 1\n        if BreakLineDict != []:\n            BreakLineDict.sort()\n            for Each in BreakLineDict:\n                if Each > 0:\n                    Multilines += '  %s\\n' % String[CurrentStringStart:Each].lstrip()\n                CurrentStringStart = Each\n            if StringLength - CurrentStringStart > 0:\n                Multilines += '  %s\\n' % String[CurrentStringStart:].lstrip()\n    return Multilines",
            "def ProcessMultilines(self, String, MaxCharLength):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Multilines = ''\n    StringLength = len(String)\n    CurrentStringStart = 0\n    StringOffset = 0\n    BreakLineDict = []\n    if len(String) <= MaxCharLength:\n        while StringOffset < StringLength:\n            if StringOffset >= 1:\n                if String[StringOffset - 1] == '\\\\' and String[StringOffset] == 'n':\n                    BreakLineDict.append(StringOffset + 1)\n            StringOffset += 1\n        if BreakLineDict != []:\n            for Each in BreakLineDict:\n                Multilines += '  %s\\n' % String[CurrentStringStart:Each].lstrip()\n                CurrentStringStart = Each\n            if StringLength - CurrentStringStart > 0:\n                Multilines += '  %s\\n' % String[CurrentStringStart:].lstrip()\n        else:\n            Multilines = '  %s\\n' % String\n    else:\n        NewLineStart = 0\n        NewLineCount = 0\n        FoundSpaceChar = False\n        while StringOffset < StringLength:\n            if StringOffset >= 1:\n                if NewLineCount >= MaxCharLength - 1:\n                    if String[StringOffset] == ' ' and StringLength - StringOffset > 10:\n                        BreakLineDict.append(NewLineStart + NewLineCount)\n                        NewLineStart = NewLineStart + NewLineCount\n                        NewLineCount = 0\n                        FoundSpaceChar = True\n                    elif StringOffset == StringLength - 1 and FoundSpaceChar == False:\n                        BreakLineDict.append(0)\n                if String[StringOffset - 1] == '\\\\' and String[StringOffset] == 'n':\n                    BreakLineDict.append(StringOffset + 1)\n                    NewLineStart = StringOffset + 1\n                    NewLineCount = 0\n            StringOffset += 1\n            NewLineCount += 1\n        if BreakLineDict != []:\n            BreakLineDict.sort()\n            for Each in BreakLineDict:\n                if Each > 0:\n                    Multilines += '  %s\\n' % String[CurrentStringStart:Each].lstrip()\n                CurrentStringStart = Each\n            if StringLength - CurrentStringStart > 0:\n                Multilines += '  %s\\n' % String[CurrentStringStart:].lstrip()\n    return Multilines"
        ]
    },
    {
        "func_name": "CreateField",
        "original": "def CreateField(self, Item, Name, Length, Offset, Struct, BsfName, Help, Option, BitsLength=None):\n    PosName = 28\n    PosComment = 30\n    NameLine = ''\n    HelpLine = ''\n    OptionLine = ''\n    if Length == 0 and Name == 'Dummy':\n        return '\\n'\n    IsArray = False\n    if Length in [1, 2, 4, 8]:\n        Type = 'UINT%d' % (Length * 8)\n        if Name.startswith('UnusedUpdSpace') and Length != 1:\n            IsArray = True\n            Type = 'UINT8'\n    else:\n        IsArray = True\n        Type = 'UINT8'\n    if Item and Item['value'].startswith('{'):\n        Type = 'UINT8'\n        IsArray = True\n    if Struct != '':\n        Type = Struct\n        if Struct in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n            IsArray = True\n            Unit = int(Type[4:]) / 8\n            Length = Length / Unit\n        else:\n            IsArray = False\n    if IsArray:\n        Name = Name + '[%d]' % Length\n    if len(Type) < PosName:\n        Space1 = PosName - len(Type)\n    else:\n        Space1 = 1\n    if BsfName != '':\n        NameLine = ' - %s\\n' % BsfName\n    else:\n        NameLine = '\\n'\n    if Help != '':\n        HelpLine = self.ProcessMultilines(Help, 80)\n    if Option != '':\n        OptionLine = self.ProcessMultilines(Option, 80)\n    if Offset is None:\n        OffsetStr = '????'\n    else:\n        OffsetStr = '0x%04X' % Offset\n    if BitsLength is None:\n        BitsLength = ''\n    else:\n        BitsLength = ' : %d' % BitsLength\n    return '\\n/** Offset %s%s%s%s**/\\n  %s%s%s%s;\\n' % (OffsetStr, NameLine, HelpLine, OptionLine, Type, ' ' * Space1, Name, BitsLength)",
        "mutated": [
            "def CreateField(self, Item, Name, Length, Offset, Struct, BsfName, Help, Option, BitsLength=None):\n    if False:\n        i = 10\n    PosName = 28\n    PosComment = 30\n    NameLine = ''\n    HelpLine = ''\n    OptionLine = ''\n    if Length == 0 and Name == 'Dummy':\n        return '\\n'\n    IsArray = False\n    if Length in [1, 2, 4, 8]:\n        Type = 'UINT%d' % (Length * 8)\n        if Name.startswith('UnusedUpdSpace') and Length != 1:\n            IsArray = True\n            Type = 'UINT8'\n    else:\n        IsArray = True\n        Type = 'UINT8'\n    if Item and Item['value'].startswith('{'):\n        Type = 'UINT8'\n        IsArray = True\n    if Struct != '':\n        Type = Struct\n        if Struct in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n            IsArray = True\n            Unit = int(Type[4:]) / 8\n            Length = Length / Unit\n        else:\n            IsArray = False\n    if IsArray:\n        Name = Name + '[%d]' % Length\n    if len(Type) < PosName:\n        Space1 = PosName - len(Type)\n    else:\n        Space1 = 1\n    if BsfName != '':\n        NameLine = ' - %s\\n' % BsfName\n    else:\n        NameLine = '\\n'\n    if Help != '':\n        HelpLine = self.ProcessMultilines(Help, 80)\n    if Option != '':\n        OptionLine = self.ProcessMultilines(Option, 80)\n    if Offset is None:\n        OffsetStr = '????'\n    else:\n        OffsetStr = '0x%04X' % Offset\n    if BitsLength is None:\n        BitsLength = ''\n    else:\n        BitsLength = ' : %d' % BitsLength\n    return '\\n/** Offset %s%s%s%s**/\\n  %s%s%s%s;\\n' % (OffsetStr, NameLine, HelpLine, OptionLine, Type, ' ' * Space1, Name, BitsLength)",
            "def CreateField(self, Item, Name, Length, Offset, Struct, BsfName, Help, Option, BitsLength=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    PosName = 28\n    PosComment = 30\n    NameLine = ''\n    HelpLine = ''\n    OptionLine = ''\n    if Length == 0 and Name == 'Dummy':\n        return '\\n'\n    IsArray = False\n    if Length in [1, 2, 4, 8]:\n        Type = 'UINT%d' % (Length * 8)\n        if Name.startswith('UnusedUpdSpace') and Length != 1:\n            IsArray = True\n            Type = 'UINT8'\n    else:\n        IsArray = True\n        Type = 'UINT8'\n    if Item and Item['value'].startswith('{'):\n        Type = 'UINT8'\n        IsArray = True\n    if Struct != '':\n        Type = Struct\n        if Struct in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n            IsArray = True\n            Unit = int(Type[4:]) / 8\n            Length = Length / Unit\n        else:\n            IsArray = False\n    if IsArray:\n        Name = Name + '[%d]' % Length\n    if len(Type) < PosName:\n        Space1 = PosName - len(Type)\n    else:\n        Space1 = 1\n    if BsfName != '':\n        NameLine = ' - %s\\n' % BsfName\n    else:\n        NameLine = '\\n'\n    if Help != '':\n        HelpLine = self.ProcessMultilines(Help, 80)\n    if Option != '':\n        OptionLine = self.ProcessMultilines(Option, 80)\n    if Offset is None:\n        OffsetStr = '????'\n    else:\n        OffsetStr = '0x%04X' % Offset\n    if BitsLength is None:\n        BitsLength = ''\n    else:\n        BitsLength = ' : %d' % BitsLength\n    return '\\n/** Offset %s%s%s%s**/\\n  %s%s%s%s;\\n' % (OffsetStr, NameLine, HelpLine, OptionLine, Type, ' ' * Space1, Name, BitsLength)",
            "def CreateField(self, Item, Name, Length, Offset, Struct, BsfName, Help, Option, BitsLength=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    PosName = 28\n    PosComment = 30\n    NameLine = ''\n    HelpLine = ''\n    OptionLine = ''\n    if Length == 0 and Name == 'Dummy':\n        return '\\n'\n    IsArray = False\n    if Length in [1, 2, 4, 8]:\n        Type = 'UINT%d' % (Length * 8)\n        if Name.startswith('UnusedUpdSpace') and Length != 1:\n            IsArray = True\n            Type = 'UINT8'\n    else:\n        IsArray = True\n        Type = 'UINT8'\n    if Item and Item['value'].startswith('{'):\n        Type = 'UINT8'\n        IsArray = True\n    if Struct != '':\n        Type = Struct\n        if Struct in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n            IsArray = True\n            Unit = int(Type[4:]) / 8\n            Length = Length / Unit\n        else:\n            IsArray = False\n    if IsArray:\n        Name = Name + '[%d]' % Length\n    if len(Type) < PosName:\n        Space1 = PosName - len(Type)\n    else:\n        Space1 = 1\n    if BsfName != '':\n        NameLine = ' - %s\\n' % BsfName\n    else:\n        NameLine = '\\n'\n    if Help != '':\n        HelpLine = self.ProcessMultilines(Help, 80)\n    if Option != '':\n        OptionLine = self.ProcessMultilines(Option, 80)\n    if Offset is None:\n        OffsetStr = '????'\n    else:\n        OffsetStr = '0x%04X' % Offset\n    if BitsLength is None:\n        BitsLength = ''\n    else:\n        BitsLength = ' : %d' % BitsLength\n    return '\\n/** Offset %s%s%s%s**/\\n  %s%s%s%s;\\n' % (OffsetStr, NameLine, HelpLine, OptionLine, Type, ' ' * Space1, Name, BitsLength)",
            "def CreateField(self, Item, Name, Length, Offset, Struct, BsfName, Help, Option, BitsLength=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    PosName = 28\n    PosComment = 30\n    NameLine = ''\n    HelpLine = ''\n    OptionLine = ''\n    if Length == 0 and Name == 'Dummy':\n        return '\\n'\n    IsArray = False\n    if Length in [1, 2, 4, 8]:\n        Type = 'UINT%d' % (Length * 8)\n        if Name.startswith('UnusedUpdSpace') and Length != 1:\n            IsArray = True\n            Type = 'UINT8'\n    else:\n        IsArray = True\n        Type = 'UINT8'\n    if Item and Item['value'].startswith('{'):\n        Type = 'UINT8'\n        IsArray = True\n    if Struct != '':\n        Type = Struct\n        if Struct in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n            IsArray = True\n            Unit = int(Type[4:]) / 8\n            Length = Length / Unit\n        else:\n            IsArray = False\n    if IsArray:\n        Name = Name + '[%d]' % Length\n    if len(Type) < PosName:\n        Space1 = PosName - len(Type)\n    else:\n        Space1 = 1\n    if BsfName != '':\n        NameLine = ' - %s\\n' % BsfName\n    else:\n        NameLine = '\\n'\n    if Help != '':\n        HelpLine = self.ProcessMultilines(Help, 80)\n    if Option != '':\n        OptionLine = self.ProcessMultilines(Option, 80)\n    if Offset is None:\n        OffsetStr = '????'\n    else:\n        OffsetStr = '0x%04X' % Offset\n    if BitsLength is None:\n        BitsLength = ''\n    else:\n        BitsLength = ' : %d' % BitsLength\n    return '\\n/** Offset %s%s%s%s**/\\n  %s%s%s%s;\\n' % (OffsetStr, NameLine, HelpLine, OptionLine, Type, ' ' * Space1, Name, BitsLength)",
            "def CreateField(self, Item, Name, Length, Offset, Struct, BsfName, Help, Option, BitsLength=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    PosName = 28\n    PosComment = 30\n    NameLine = ''\n    HelpLine = ''\n    OptionLine = ''\n    if Length == 0 and Name == 'Dummy':\n        return '\\n'\n    IsArray = False\n    if Length in [1, 2, 4, 8]:\n        Type = 'UINT%d' % (Length * 8)\n        if Name.startswith('UnusedUpdSpace') and Length != 1:\n            IsArray = True\n            Type = 'UINT8'\n    else:\n        IsArray = True\n        Type = 'UINT8'\n    if Item and Item['value'].startswith('{'):\n        Type = 'UINT8'\n        IsArray = True\n    if Struct != '':\n        Type = Struct\n        if Struct in ['UINT8', 'UINT16', 'UINT32', 'UINT64']:\n            IsArray = True\n            Unit = int(Type[4:]) / 8\n            Length = Length / Unit\n        else:\n            IsArray = False\n    if IsArray:\n        Name = Name + '[%d]' % Length\n    if len(Type) < PosName:\n        Space1 = PosName - len(Type)\n    else:\n        Space1 = 1\n    if BsfName != '':\n        NameLine = ' - %s\\n' % BsfName\n    else:\n        NameLine = '\\n'\n    if Help != '':\n        HelpLine = self.ProcessMultilines(Help, 80)\n    if Option != '':\n        OptionLine = self.ProcessMultilines(Option, 80)\n    if Offset is None:\n        OffsetStr = '????'\n    else:\n        OffsetStr = '0x%04X' % Offset\n    if BitsLength is None:\n        BitsLength = ''\n    else:\n        BitsLength = ' : %d' % BitsLength\n    return '\\n/** Offset %s%s%s%s**/\\n  %s%s%s%s;\\n' % (OffsetStr, NameLine, HelpLine, OptionLine, Type, ' ' * Space1, Name, BitsLength)"
        ]
    },
    {
        "func_name": "PostProcessBody",
        "original": "def PostProcessBody(self, TextBody):\n    NewTextBody = []\n    OldTextBody = []\n    IncludeLine = False\n    StructName = ''\n    VariableName = ''\n    IsUpdHdrDefined = False\n    IsUpdHeader = False\n    for Line in TextBody:\n        SplitToLines = Line.splitlines()\n        MatchComment = re.match('^/\\\\*\\\\sCOMMENT:(\\\\w+):([\\\\w|\\\\W|\\\\s]+)\\\\s\\\\*/\\\\s([\\\\s\\\\S]*)', SplitToLines[0])\n        if MatchComment:\n            if MatchComment.group(1) == 'FSP_UPD_HEADER':\n                IsUpdHeader = True\n            else:\n                IsUpdHeader = False\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                CommentLine = ' ' + MatchComment.group(2) + '\\n'\n                NewTextBody.append('/**' + CommentLine + '**/\\n')\n            Line = Line[len(SplitToLines[0]) + 1:]\n        Match = re.match('^/\\\\*\\\\sEMBED_STRUCT:(\\\\w+):(\\\\w+):(START|END)\\\\s\\\\*/\\\\s([\\\\s\\\\S]*)', Line)\n        if Match:\n            Line = Match.group(4)\n            if Match.group(1) == 'FSP_UPD_HEADER':\n                IsUpdHeader = True\n            else:\n                IsUpdHeader = False\n        if Match and Match.group(3) == 'START':\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append('typedef struct {\\n')\n            StructName = Match.group(1)\n            VariableName = Match.group(2)\n            MatchOffset = re.search('/\\\\*\\\\*\\\\sOffset\\\\s0x([a-fA-F0-9]+)', Line)\n            if MatchOffset:\n                Offset = int(MatchOffset.group(1), 16)\n            else:\n                Offset = None\n            Line\n            IncludeLine = True\n            OldTextBody.append(self.CreateField(None, VariableName, 0, Offset, StructName, '', '', ''))\n        if IncludeLine:\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append(Line)\n        else:\n            OldTextBody.append(Line)\n        if Match and Match.group(3) == 'END':\n            if StructName != Match.group(1) or VariableName != Match.group(2):\n                print(\"Unmatched struct name '%s' and '%s' !\" % (StructName, Match.group(1)))\n            elif IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append('} %s;\\n\\n' % StructName)\n                IsUpdHdrDefined = True\n            IncludeLine = False\n    NewTextBody.extend(OldTextBody)\n    return NewTextBody",
        "mutated": [
            "def PostProcessBody(self, TextBody):\n    if False:\n        i = 10\n    NewTextBody = []\n    OldTextBody = []\n    IncludeLine = False\n    StructName = ''\n    VariableName = ''\n    IsUpdHdrDefined = False\n    IsUpdHeader = False\n    for Line in TextBody:\n        SplitToLines = Line.splitlines()\n        MatchComment = re.match('^/\\\\*\\\\sCOMMENT:(\\\\w+):([\\\\w|\\\\W|\\\\s]+)\\\\s\\\\*/\\\\s([\\\\s\\\\S]*)', SplitToLines[0])\n        if MatchComment:\n            if MatchComment.group(1) == 'FSP_UPD_HEADER':\n                IsUpdHeader = True\n            else:\n                IsUpdHeader = False\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                CommentLine = ' ' + MatchComment.group(2) + '\\n'\n                NewTextBody.append('/**' + CommentLine + '**/\\n')\n            Line = Line[len(SplitToLines[0]) + 1:]\n        Match = re.match('^/\\\\*\\\\sEMBED_STRUCT:(\\\\w+):(\\\\w+):(START|END)\\\\s\\\\*/\\\\s([\\\\s\\\\S]*)', Line)\n        if Match:\n            Line = Match.group(4)\n            if Match.group(1) == 'FSP_UPD_HEADER':\n                IsUpdHeader = True\n            else:\n                IsUpdHeader = False\n        if Match and Match.group(3) == 'START':\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append('typedef struct {\\n')\n            StructName = Match.group(1)\n            VariableName = Match.group(2)\n            MatchOffset = re.search('/\\\\*\\\\*\\\\sOffset\\\\s0x([a-fA-F0-9]+)', Line)\n            if MatchOffset:\n                Offset = int(MatchOffset.group(1), 16)\n            else:\n                Offset = None\n            Line\n            IncludeLine = True\n            OldTextBody.append(self.CreateField(None, VariableName, 0, Offset, StructName, '', '', ''))\n        if IncludeLine:\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append(Line)\n        else:\n            OldTextBody.append(Line)\n        if Match and Match.group(3) == 'END':\n            if StructName != Match.group(1) or VariableName != Match.group(2):\n                print(\"Unmatched struct name '%s' and '%s' !\" % (StructName, Match.group(1)))\n            elif IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append('} %s;\\n\\n' % StructName)\n                IsUpdHdrDefined = True\n            IncludeLine = False\n    NewTextBody.extend(OldTextBody)\n    return NewTextBody",
            "def PostProcessBody(self, TextBody):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    NewTextBody = []\n    OldTextBody = []\n    IncludeLine = False\n    StructName = ''\n    VariableName = ''\n    IsUpdHdrDefined = False\n    IsUpdHeader = False\n    for Line in TextBody:\n        SplitToLines = Line.splitlines()\n        MatchComment = re.match('^/\\\\*\\\\sCOMMENT:(\\\\w+):([\\\\w|\\\\W|\\\\s]+)\\\\s\\\\*/\\\\s([\\\\s\\\\S]*)', SplitToLines[0])\n        if MatchComment:\n            if MatchComment.group(1) == 'FSP_UPD_HEADER':\n                IsUpdHeader = True\n            else:\n                IsUpdHeader = False\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                CommentLine = ' ' + MatchComment.group(2) + '\\n'\n                NewTextBody.append('/**' + CommentLine + '**/\\n')\n            Line = Line[len(SplitToLines[0]) + 1:]\n        Match = re.match('^/\\\\*\\\\sEMBED_STRUCT:(\\\\w+):(\\\\w+):(START|END)\\\\s\\\\*/\\\\s([\\\\s\\\\S]*)', Line)\n        if Match:\n            Line = Match.group(4)\n            if Match.group(1) == 'FSP_UPD_HEADER':\n                IsUpdHeader = True\n            else:\n                IsUpdHeader = False\n        if Match and Match.group(3) == 'START':\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append('typedef struct {\\n')\n            StructName = Match.group(1)\n            VariableName = Match.group(2)\n            MatchOffset = re.search('/\\\\*\\\\*\\\\sOffset\\\\s0x([a-fA-F0-9]+)', Line)\n            if MatchOffset:\n                Offset = int(MatchOffset.group(1), 16)\n            else:\n                Offset = None\n            Line\n            IncludeLine = True\n            OldTextBody.append(self.CreateField(None, VariableName, 0, Offset, StructName, '', '', ''))\n        if IncludeLine:\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append(Line)\n        else:\n            OldTextBody.append(Line)\n        if Match and Match.group(3) == 'END':\n            if StructName != Match.group(1) or VariableName != Match.group(2):\n                print(\"Unmatched struct name '%s' and '%s' !\" % (StructName, Match.group(1)))\n            elif IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append('} %s;\\n\\n' % StructName)\n                IsUpdHdrDefined = True\n            IncludeLine = False\n    NewTextBody.extend(OldTextBody)\n    return NewTextBody",
            "def PostProcessBody(self, TextBody):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    NewTextBody = []\n    OldTextBody = []\n    IncludeLine = False\n    StructName = ''\n    VariableName = ''\n    IsUpdHdrDefined = False\n    IsUpdHeader = False\n    for Line in TextBody:\n        SplitToLines = Line.splitlines()\n        MatchComment = re.match('^/\\\\*\\\\sCOMMENT:(\\\\w+):([\\\\w|\\\\W|\\\\s]+)\\\\s\\\\*/\\\\s([\\\\s\\\\S]*)', SplitToLines[0])\n        if MatchComment:\n            if MatchComment.group(1) == 'FSP_UPD_HEADER':\n                IsUpdHeader = True\n            else:\n                IsUpdHeader = False\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                CommentLine = ' ' + MatchComment.group(2) + '\\n'\n                NewTextBody.append('/**' + CommentLine + '**/\\n')\n            Line = Line[len(SplitToLines[0]) + 1:]\n        Match = re.match('^/\\\\*\\\\sEMBED_STRUCT:(\\\\w+):(\\\\w+):(START|END)\\\\s\\\\*/\\\\s([\\\\s\\\\S]*)', Line)\n        if Match:\n            Line = Match.group(4)\n            if Match.group(1) == 'FSP_UPD_HEADER':\n                IsUpdHeader = True\n            else:\n                IsUpdHeader = False\n        if Match and Match.group(3) == 'START':\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append('typedef struct {\\n')\n            StructName = Match.group(1)\n            VariableName = Match.group(2)\n            MatchOffset = re.search('/\\\\*\\\\*\\\\sOffset\\\\s0x([a-fA-F0-9]+)', Line)\n            if MatchOffset:\n                Offset = int(MatchOffset.group(1), 16)\n            else:\n                Offset = None\n            Line\n            IncludeLine = True\n            OldTextBody.append(self.CreateField(None, VariableName, 0, Offset, StructName, '', '', ''))\n        if IncludeLine:\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append(Line)\n        else:\n            OldTextBody.append(Line)\n        if Match and Match.group(3) == 'END':\n            if StructName != Match.group(1) or VariableName != Match.group(2):\n                print(\"Unmatched struct name '%s' and '%s' !\" % (StructName, Match.group(1)))\n            elif IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append('} %s;\\n\\n' % StructName)\n                IsUpdHdrDefined = True\n            IncludeLine = False\n    NewTextBody.extend(OldTextBody)\n    return NewTextBody",
            "def PostProcessBody(self, TextBody):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    NewTextBody = []\n    OldTextBody = []\n    IncludeLine = False\n    StructName = ''\n    VariableName = ''\n    IsUpdHdrDefined = False\n    IsUpdHeader = False\n    for Line in TextBody:\n        SplitToLines = Line.splitlines()\n        MatchComment = re.match('^/\\\\*\\\\sCOMMENT:(\\\\w+):([\\\\w|\\\\W|\\\\s]+)\\\\s\\\\*/\\\\s([\\\\s\\\\S]*)', SplitToLines[0])\n        if MatchComment:\n            if MatchComment.group(1) == 'FSP_UPD_HEADER':\n                IsUpdHeader = True\n            else:\n                IsUpdHeader = False\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                CommentLine = ' ' + MatchComment.group(2) + '\\n'\n                NewTextBody.append('/**' + CommentLine + '**/\\n')\n            Line = Line[len(SplitToLines[0]) + 1:]\n        Match = re.match('^/\\\\*\\\\sEMBED_STRUCT:(\\\\w+):(\\\\w+):(START|END)\\\\s\\\\*/\\\\s([\\\\s\\\\S]*)', Line)\n        if Match:\n            Line = Match.group(4)\n            if Match.group(1) == 'FSP_UPD_HEADER':\n                IsUpdHeader = True\n            else:\n                IsUpdHeader = False\n        if Match and Match.group(3) == 'START':\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append('typedef struct {\\n')\n            StructName = Match.group(1)\n            VariableName = Match.group(2)\n            MatchOffset = re.search('/\\\\*\\\\*\\\\sOffset\\\\s0x([a-fA-F0-9]+)', Line)\n            if MatchOffset:\n                Offset = int(MatchOffset.group(1), 16)\n            else:\n                Offset = None\n            Line\n            IncludeLine = True\n            OldTextBody.append(self.CreateField(None, VariableName, 0, Offset, StructName, '', '', ''))\n        if IncludeLine:\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append(Line)\n        else:\n            OldTextBody.append(Line)\n        if Match and Match.group(3) == 'END':\n            if StructName != Match.group(1) or VariableName != Match.group(2):\n                print(\"Unmatched struct name '%s' and '%s' !\" % (StructName, Match.group(1)))\n            elif IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append('} %s;\\n\\n' % StructName)\n                IsUpdHdrDefined = True\n            IncludeLine = False\n    NewTextBody.extend(OldTextBody)\n    return NewTextBody",
            "def PostProcessBody(self, TextBody):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    NewTextBody = []\n    OldTextBody = []\n    IncludeLine = False\n    StructName = ''\n    VariableName = ''\n    IsUpdHdrDefined = False\n    IsUpdHeader = False\n    for Line in TextBody:\n        SplitToLines = Line.splitlines()\n        MatchComment = re.match('^/\\\\*\\\\sCOMMENT:(\\\\w+):([\\\\w|\\\\W|\\\\s]+)\\\\s\\\\*/\\\\s([\\\\s\\\\S]*)', SplitToLines[0])\n        if MatchComment:\n            if MatchComment.group(1) == 'FSP_UPD_HEADER':\n                IsUpdHeader = True\n            else:\n                IsUpdHeader = False\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                CommentLine = ' ' + MatchComment.group(2) + '\\n'\n                NewTextBody.append('/**' + CommentLine + '**/\\n')\n            Line = Line[len(SplitToLines[0]) + 1:]\n        Match = re.match('^/\\\\*\\\\sEMBED_STRUCT:(\\\\w+):(\\\\w+):(START|END)\\\\s\\\\*/\\\\s([\\\\s\\\\S]*)', Line)\n        if Match:\n            Line = Match.group(4)\n            if Match.group(1) == 'FSP_UPD_HEADER':\n                IsUpdHeader = True\n            else:\n                IsUpdHeader = False\n        if Match and Match.group(3) == 'START':\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append('typedef struct {\\n')\n            StructName = Match.group(1)\n            VariableName = Match.group(2)\n            MatchOffset = re.search('/\\\\*\\\\*\\\\sOffset\\\\s0x([a-fA-F0-9]+)', Line)\n            if MatchOffset:\n                Offset = int(MatchOffset.group(1), 16)\n            else:\n                Offset = None\n            Line\n            IncludeLine = True\n            OldTextBody.append(self.CreateField(None, VariableName, 0, Offset, StructName, '', '', ''))\n        if IncludeLine:\n            if IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append(Line)\n        else:\n            OldTextBody.append(Line)\n        if Match and Match.group(3) == 'END':\n            if StructName != Match.group(1) or VariableName != Match.group(2):\n                print(\"Unmatched struct name '%s' and '%s' !\" % (StructName, Match.group(1)))\n            elif IsUpdHdrDefined != True or IsUpdHeader != True:\n                NewTextBody.append('} %s;\\n\\n' % StructName)\n                IsUpdHdrDefined = True\n            IncludeLine = False\n    NewTextBody.extend(OldTextBody)\n    return NewTextBody"
        ]
    },
    {
        "func_name": "WriteLinesWithoutTailingSpace",
        "original": "def WriteLinesWithoutTailingSpace(self, HeaderFd, Line):\n    TxtBody2 = Line.splitlines(True)\n    for Line2 in TxtBody2:\n        Line2 = Line2.rstrip()\n        Line2 += '\\n'\n        HeaderFd.write(Line2)\n    return 0",
        "mutated": [
            "def WriteLinesWithoutTailingSpace(self, HeaderFd, Line):\n    if False:\n        i = 10\n    TxtBody2 = Line.splitlines(True)\n    for Line2 in TxtBody2:\n        Line2 = Line2.rstrip()\n        Line2 += '\\n'\n        HeaderFd.write(Line2)\n    return 0",
            "def WriteLinesWithoutTailingSpace(self, HeaderFd, Line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    TxtBody2 = Line.splitlines(True)\n    for Line2 in TxtBody2:\n        Line2 = Line2.rstrip()\n        Line2 += '\\n'\n        HeaderFd.write(Line2)\n    return 0",
            "def WriteLinesWithoutTailingSpace(self, HeaderFd, Line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    TxtBody2 = Line.splitlines(True)\n    for Line2 in TxtBody2:\n        Line2 = Line2.rstrip()\n        Line2 += '\\n'\n        HeaderFd.write(Line2)\n    return 0",
            "def WriteLinesWithoutTailingSpace(self, HeaderFd, Line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    TxtBody2 = Line.splitlines(True)\n    for Line2 in TxtBody2:\n        Line2 = Line2.rstrip()\n        Line2 += '\\n'\n        HeaderFd.write(Line2)\n    return 0",
            "def WriteLinesWithoutTailingSpace(self, HeaderFd, Line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    TxtBody2 = Line.splitlines(True)\n    for Line2 in TxtBody2:\n        Line2 = Line2.rstrip()\n        Line2 += '\\n'\n        HeaderFd.write(Line2)\n    return 0"
        ]
    },
    {
        "func_name": "CreateHeaderFile",
        "original": "def CreateHeaderFile(self, InputHeaderFile):\n    FvDir = self._FvDir\n    HeaderFileName = 'FspUpd.h'\n    HeaderFile = os.path.join(FvDir, HeaderFileName)\n    if self.NoDscFileChange(HeaderFile):\n        self.Error = 'No DSC file change, skip to create UPD header file'\n        return 256\n    TxtBody = []\n    for Item in self._CfgItemList:\n        if str(Item['cname']) == 'Signature' and Item['length'] == 8:\n            Value = int(Item['value'], 16)\n            Chars = []\n            while Value != 0:\n                Chars.append(chr(Value & 255))\n                Value = Value >> 8\n            SignatureStr = ''.join(Chars)\n            if '_T' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPT_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_M' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPM_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_S' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPS_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_I' in SignatureStr[6:6 + 2]:\n                if NoFSPI == False:\n                    TxtBody.append(\"#define FSPI_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n    TxtBody.append('\\n')\n    for Region in ['UPD']:\n        UpdOffsetTable = []\n        UpdSignature = ['0x545F', '0x4D5F', '0x535F', '0x495F']\n        UpdStructure = ['FSPT_UPD', 'FSPM_UPD', 'FSPS_UPD', 'FSPI_UPD']\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and Item['value'][0:6] in UpdSignature:\n                Item['offset'] = 0\n                UpdOffsetTable.append(Item['offset'])\n        for UpdIdx in range(len(UpdOffsetTable)):\n            CommentLine = ''\n            for Item in self._CfgItemList:\n                if Item['comment'] != '' and Item['offset'] >= UpdOffsetTable[UpdIdx]:\n                    MatchComment = re.match('^(U|V)PD_DATA_REGION:([\\\\w|\\\\W|\\\\s]+)', Item['comment'])\n                    if MatchComment and MatchComment.group(1) == Region[0]:\n                        CommentLine = ' ' + MatchComment.group(2) + '\\n'\n                        TxtBody.append('/**' + CommentLine + '**/\\n')\n                elif Item['offset'] >= UpdOffsetTable[UpdIdx] and Item['comment'] == '':\n                    Match = re.match('^FSP([\\\\w|\\\\W|\\\\s])_UPD', UpdStructure[UpdIdx])\n                    if Match:\n                        TxtBody.append('/** Fsp ' + Match.group(1) + ' UPD Configuration\\n**/\\n')\n            TxtBody.append('typedef struct {\\n')\n            NextOffset = 0\n            SpaceIdx = 0\n            Offset = 0\n            LastVisible = True\n            ResvOffset = 0\n            ResvIdx = 0\n            LineBuffer = []\n            InRange = False\n            for Item in self._CfgItemList:\n                if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == UpdSignature[UpdIdx] or Region[0] == 'V':\n                    InRange = True\n                if InRange != True:\n                    continue\n                if Item['cname'] == 'UpdTerminator':\n                    InRange = False\n                if Item['region'] != Region:\n                    continue\n                if Item['offset'] < UpdOffsetTable[UpdIdx]:\n                    continue\n                NextVisible = LastVisible\n                if LastVisible and Item['header'] == 'OFF':\n                    NextVisible = False\n                    ResvOffset = Item['offset']\n                elif not LastVisible and Item['header'] == 'ON':\n                    NextVisible = True\n                    Name = 'Reserved' + Region[0] + 'pdSpace%d' % ResvIdx\n                    ResvIdx = ResvIdx + 1\n                    TxtBody.append(self.CreateField(Item, Name, Item['offset'] - ResvOffset, ResvOffset, '', '', '', ''))\n                if Offset < Item['offset']:\n                    if LastVisible:\n                        Name = 'Unused' + Region[0] + 'pdSpace%d' % SpaceIdx\n                        LineBuffer.append(self.CreateField(Item, Name, Item['offset'] - Offset, Offset, '', '', '', ''))\n                    SpaceIdx = SpaceIdx + 1\n                    Offset = Item['offset']\n                LastVisible = NextVisible\n                Offset = Offset + Item['length']\n                if LastVisible:\n                    for Each in LineBuffer:\n                        TxtBody.append(Each)\n                    LineBuffer = []\n                    Comment = Item['comment']\n                    Embed = Item['embed'].upper()\n                    if Embed.endswith(':START') or Embed.endswith(':END'):\n                        if not Comment == '' and Embed.endswith(':START'):\n                            Marker = '/* COMMENT:%s */ \\n' % Item['comment']\n                            Marker = Marker + '/* EMBED_STRUCT:%s */ ' % Item['embed']\n                        else:\n                            Marker = '/* EMBED_STRUCT:%s */ ' % Item['embed']\n                    elif Embed == '':\n                        Marker = ''\n                    else:\n                        self.Error = \"Invalid embedded structure format '%s'!\\n\" % Item['embed']\n                        return 4\n                    Line = Marker + self.CreateField(Item, Item['cname'], Item['length'], Item['offset'], Item['struct'], Item['name'], Item['help'], Item['option'])\n                    TxtBody.append(Line)\n                if Item['cname'] == 'UpdTerminator':\n                    break\n            TxtBody.append('} ' + UpdStructure[UpdIdx] + ';\\n\\n')\n    TxtBody = self.PostProcessBody(TxtBody)\n    HeaderTFileName = 'FsptUpd.h'\n    HeaderMFileName = 'FspmUpd.h'\n    HeaderSFileName = 'FspsUpd.h'\n    HeaderIFileName = 'FspiUpd.h'\n    UpdRegionCheck = ['FSPT', 'FSPM', 'FSPS', 'FSPI']\n    UpdConfigCheck = ['FSP_T', 'FSP_M', 'FSP_S', 'FSP_I']\n    UpdSignatureCheck = ['FSPT_UPD_SIGNATURE', 'FSPM_UPD_SIGNATURE', 'FSPS_UPD_SIGNATURE', 'FSPI_UPD_SIGNATURE']\n    ExcludedSpecificUpd = ['FSPT_ARCH_UPD', 'FSPM_ARCH_UPD', 'FSPS_ARCH_UPD', 'FSPI_ARCH_UPD']\n    ExcludedSpecificUpd1 = ['FSPT_ARCH2_UPD', 'FSPM_ARCH2_UPD', 'FSPS_ARCH2_UPD']\n    IncLines = []\n    if InputHeaderFile != '':\n        if not os.path.exists(InputHeaderFile):\n            self.Error = \"Input header file '%s' does not exist\" % InputHeaderFile\n            return 6\n        InFd = open(InputHeaderFile, 'r')\n        IncLines = InFd.readlines()\n        InFd.close()\n    for item in range(len(UpdRegionCheck)):\n        if UpdRegionCheck[item] == 'FSPT':\n            HeaderFd = open(os.path.join(FvDir, HeaderTFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderTFileName))\n        elif UpdRegionCheck[item] == 'FSPM':\n            HeaderFd = open(os.path.join(FvDir, HeaderMFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderMFileName))\n        elif UpdRegionCheck[item] == 'FSPS':\n            HeaderFd = open(os.path.join(FvDir, HeaderSFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderSFileName))\n        elif UpdRegionCheck[item] == 'FSPI':\n            HeaderFd = open(os.path.join(FvDir, HeaderIFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderIFileName))\n        FileName = FileBase.replace('.', '_').upper()\n        HeaderFd.write('%s\\n' % (__copyright_h__ % date.today().year))\n        HeaderFd.write('#ifndef __%s__\\n' % FileName)\n        HeaderFd.write('#define __%s__\\n\\n' % FileName)\n        HeaderFd.write('#include <%s>\\n\\n' % HeaderFileName)\n        HeaderFd.write('#pragma pack(1)\\n\\n')\n        Export = False\n        for Line in IncLines:\n            Match = re.search('!EXPORT\\\\s+([A-Z]+)\\\\s+EXTERNAL_BOOTLOADER_STRUCT_(BEGIN|END)\\\\s+', Line)\n            if Match:\n                if Match.group(2) == 'BEGIN' and Match.group(1) == UpdRegionCheck[item]:\n                    Export = True\n                    continue\n                else:\n                    Export = False\n                    continue\n            if Export:\n                HeaderFd.write(Line)\n        HeaderFd.write('\\n')\n        Index = 0\n        StartIndex = 0\n        EndIndex = 0\n        StructStart = []\n        StructStartWithComment = []\n        StructEnd = []\n        for Line in TxtBody:\n            Index += 1\n            Match = re.match('(typedef struct {)', Line)\n            if Match:\n                StartIndex = Index - 1\n            Match = re.match('}\\\\s([_A-Z0-9]+);', Line)\n            if Match and (UpdRegionCheck[item] in Match.group(1) or UpdConfigCheck[item] in Match.group(1)) and (ExcludedSpecificUpd[item] not in Match.group(1)) and (ExcludedSpecificUpd1[item] not in Match.group(1)):\n                EndIndex = Index\n                StructStart.append(StartIndex)\n                StructEnd.append(EndIndex)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index == StructStart[Item]:\n                    Match = re.match('^(/\\\\*\\\\*\\\\s*)', Line)\n                    if Match:\n                        StructStartWithComment.append(StructStart[Item])\n                    else:\n                        StructStartWithComment.append(StructStart[Item] + 1)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index >= StructStartWithComment[Item] and Index <= StructEnd[Item]:\n                    self.WriteLinesWithoutTailingSpace(HeaderFd, Line)\n        HeaderFd.write('#pragma pack()\\n\\n')\n        HeaderFd.write('#endif\\n')\n        HeaderFd.close()\n    HeaderFd = open(HeaderFile, 'w')\n    FileBase = os.path.basename(HeaderFile)\n    FileName = FileBase.replace('.', '_').upper()\n    HeaderFd.write('%s\\n' % (__copyright_h__ % date.today().year))\n    HeaderFd.write('#ifndef __%s__\\n' % FileName)\n    HeaderFd.write('#define __%s__\\n\\n' % FileName)\n    HeaderFd.write('#include <FspEas.h>\\n\\n')\n    HeaderFd.write('#pragma pack(1)\\n\\n')\n    for item in range(len(UpdRegionCheck)):\n        Index = 0\n        StartIndex = 0\n        EndIndex = 0\n        StructStart = []\n        StructStartWithComment = []\n        StructEnd = []\n        for Line in TxtBody:\n            Index += 1\n            Match = re.match('(typedef struct {)', Line)\n            if Match:\n                StartIndex = Index - 1\n            Match = re.match('#define\\\\s([_A-Z0-9]+)\\\\s*', Line)\n            if Match and (UpdSignatureCheck[item] in Match.group(1) or UpdSignatureCheck[item] in Match.group(1)):\n                StructStart.append(Index - 1)\n                StructEnd.append(Index)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index == StructStart[Item]:\n                    Match = re.match('^(/\\\\*\\\\*\\\\s*)', Line)\n                    if Match:\n                        StructStartWithComment.append(StructStart[Item])\n                    else:\n                        StructStartWithComment.append(StructStart[Item] + 1)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index >= StructStartWithComment[Item] and Index <= StructEnd[Item]:\n                    self.WriteLinesWithoutTailingSpace(HeaderFd, Line)\n    HeaderFd.write('#pragma pack()\\n\\n')\n    HeaderFd.write('#endif\\n')\n    HeaderFd.close()\n    return 0",
        "mutated": [
            "def CreateHeaderFile(self, InputHeaderFile):\n    if False:\n        i = 10\n    FvDir = self._FvDir\n    HeaderFileName = 'FspUpd.h'\n    HeaderFile = os.path.join(FvDir, HeaderFileName)\n    if self.NoDscFileChange(HeaderFile):\n        self.Error = 'No DSC file change, skip to create UPD header file'\n        return 256\n    TxtBody = []\n    for Item in self._CfgItemList:\n        if str(Item['cname']) == 'Signature' and Item['length'] == 8:\n            Value = int(Item['value'], 16)\n            Chars = []\n            while Value != 0:\n                Chars.append(chr(Value & 255))\n                Value = Value >> 8\n            SignatureStr = ''.join(Chars)\n            if '_T' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPT_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_M' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPM_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_S' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPS_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_I' in SignatureStr[6:6 + 2]:\n                if NoFSPI == False:\n                    TxtBody.append(\"#define FSPI_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n    TxtBody.append('\\n')\n    for Region in ['UPD']:\n        UpdOffsetTable = []\n        UpdSignature = ['0x545F', '0x4D5F', '0x535F', '0x495F']\n        UpdStructure = ['FSPT_UPD', 'FSPM_UPD', 'FSPS_UPD', 'FSPI_UPD']\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and Item['value'][0:6] in UpdSignature:\n                Item['offset'] = 0\n                UpdOffsetTable.append(Item['offset'])\n        for UpdIdx in range(len(UpdOffsetTable)):\n            CommentLine = ''\n            for Item in self._CfgItemList:\n                if Item['comment'] != '' and Item['offset'] >= UpdOffsetTable[UpdIdx]:\n                    MatchComment = re.match('^(U|V)PD_DATA_REGION:([\\\\w|\\\\W|\\\\s]+)', Item['comment'])\n                    if MatchComment and MatchComment.group(1) == Region[0]:\n                        CommentLine = ' ' + MatchComment.group(2) + '\\n'\n                        TxtBody.append('/**' + CommentLine + '**/\\n')\n                elif Item['offset'] >= UpdOffsetTable[UpdIdx] and Item['comment'] == '':\n                    Match = re.match('^FSP([\\\\w|\\\\W|\\\\s])_UPD', UpdStructure[UpdIdx])\n                    if Match:\n                        TxtBody.append('/** Fsp ' + Match.group(1) + ' UPD Configuration\\n**/\\n')\n            TxtBody.append('typedef struct {\\n')\n            NextOffset = 0\n            SpaceIdx = 0\n            Offset = 0\n            LastVisible = True\n            ResvOffset = 0\n            ResvIdx = 0\n            LineBuffer = []\n            InRange = False\n            for Item in self._CfgItemList:\n                if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == UpdSignature[UpdIdx] or Region[0] == 'V':\n                    InRange = True\n                if InRange != True:\n                    continue\n                if Item['cname'] == 'UpdTerminator':\n                    InRange = False\n                if Item['region'] != Region:\n                    continue\n                if Item['offset'] < UpdOffsetTable[UpdIdx]:\n                    continue\n                NextVisible = LastVisible\n                if LastVisible and Item['header'] == 'OFF':\n                    NextVisible = False\n                    ResvOffset = Item['offset']\n                elif not LastVisible and Item['header'] == 'ON':\n                    NextVisible = True\n                    Name = 'Reserved' + Region[0] + 'pdSpace%d' % ResvIdx\n                    ResvIdx = ResvIdx + 1\n                    TxtBody.append(self.CreateField(Item, Name, Item['offset'] - ResvOffset, ResvOffset, '', '', '', ''))\n                if Offset < Item['offset']:\n                    if LastVisible:\n                        Name = 'Unused' + Region[0] + 'pdSpace%d' % SpaceIdx\n                        LineBuffer.append(self.CreateField(Item, Name, Item['offset'] - Offset, Offset, '', '', '', ''))\n                    SpaceIdx = SpaceIdx + 1\n                    Offset = Item['offset']\n                LastVisible = NextVisible\n                Offset = Offset + Item['length']\n                if LastVisible:\n                    for Each in LineBuffer:\n                        TxtBody.append(Each)\n                    LineBuffer = []\n                    Comment = Item['comment']\n                    Embed = Item['embed'].upper()\n                    if Embed.endswith(':START') or Embed.endswith(':END'):\n                        if not Comment == '' and Embed.endswith(':START'):\n                            Marker = '/* COMMENT:%s */ \\n' % Item['comment']\n                            Marker = Marker + '/* EMBED_STRUCT:%s */ ' % Item['embed']\n                        else:\n                            Marker = '/* EMBED_STRUCT:%s */ ' % Item['embed']\n                    elif Embed == '':\n                        Marker = ''\n                    else:\n                        self.Error = \"Invalid embedded structure format '%s'!\\n\" % Item['embed']\n                        return 4\n                    Line = Marker + self.CreateField(Item, Item['cname'], Item['length'], Item['offset'], Item['struct'], Item['name'], Item['help'], Item['option'])\n                    TxtBody.append(Line)\n                if Item['cname'] == 'UpdTerminator':\n                    break\n            TxtBody.append('} ' + UpdStructure[UpdIdx] + ';\\n\\n')\n    TxtBody = self.PostProcessBody(TxtBody)\n    HeaderTFileName = 'FsptUpd.h'\n    HeaderMFileName = 'FspmUpd.h'\n    HeaderSFileName = 'FspsUpd.h'\n    HeaderIFileName = 'FspiUpd.h'\n    UpdRegionCheck = ['FSPT', 'FSPM', 'FSPS', 'FSPI']\n    UpdConfigCheck = ['FSP_T', 'FSP_M', 'FSP_S', 'FSP_I']\n    UpdSignatureCheck = ['FSPT_UPD_SIGNATURE', 'FSPM_UPD_SIGNATURE', 'FSPS_UPD_SIGNATURE', 'FSPI_UPD_SIGNATURE']\n    ExcludedSpecificUpd = ['FSPT_ARCH_UPD', 'FSPM_ARCH_UPD', 'FSPS_ARCH_UPD', 'FSPI_ARCH_UPD']\n    ExcludedSpecificUpd1 = ['FSPT_ARCH2_UPD', 'FSPM_ARCH2_UPD', 'FSPS_ARCH2_UPD']\n    IncLines = []\n    if InputHeaderFile != '':\n        if not os.path.exists(InputHeaderFile):\n            self.Error = \"Input header file '%s' does not exist\" % InputHeaderFile\n            return 6\n        InFd = open(InputHeaderFile, 'r')\n        IncLines = InFd.readlines()\n        InFd.close()\n    for item in range(len(UpdRegionCheck)):\n        if UpdRegionCheck[item] == 'FSPT':\n            HeaderFd = open(os.path.join(FvDir, HeaderTFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderTFileName))\n        elif UpdRegionCheck[item] == 'FSPM':\n            HeaderFd = open(os.path.join(FvDir, HeaderMFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderMFileName))\n        elif UpdRegionCheck[item] == 'FSPS':\n            HeaderFd = open(os.path.join(FvDir, HeaderSFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderSFileName))\n        elif UpdRegionCheck[item] == 'FSPI':\n            HeaderFd = open(os.path.join(FvDir, HeaderIFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderIFileName))\n        FileName = FileBase.replace('.', '_').upper()\n        HeaderFd.write('%s\\n' % (__copyright_h__ % date.today().year))\n        HeaderFd.write('#ifndef __%s__\\n' % FileName)\n        HeaderFd.write('#define __%s__\\n\\n' % FileName)\n        HeaderFd.write('#include <%s>\\n\\n' % HeaderFileName)\n        HeaderFd.write('#pragma pack(1)\\n\\n')\n        Export = False\n        for Line in IncLines:\n            Match = re.search('!EXPORT\\\\s+([A-Z]+)\\\\s+EXTERNAL_BOOTLOADER_STRUCT_(BEGIN|END)\\\\s+', Line)\n            if Match:\n                if Match.group(2) == 'BEGIN' and Match.group(1) == UpdRegionCheck[item]:\n                    Export = True\n                    continue\n                else:\n                    Export = False\n                    continue\n            if Export:\n                HeaderFd.write(Line)\n        HeaderFd.write('\\n')\n        Index = 0\n        StartIndex = 0\n        EndIndex = 0\n        StructStart = []\n        StructStartWithComment = []\n        StructEnd = []\n        for Line in TxtBody:\n            Index += 1\n            Match = re.match('(typedef struct {)', Line)\n            if Match:\n                StartIndex = Index - 1\n            Match = re.match('}\\\\s([_A-Z0-9]+);', Line)\n            if Match and (UpdRegionCheck[item] in Match.group(1) or UpdConfigCheck[item] in Match.group(1)) and (ExcludedSpecificUpd[item] not in Match.group(1)) and (ExcludedSpecificUpd1[item] not in Match.group(1)):\n                EndIndex = Index\n                StructStart.append(StartIndex)\n                StructEnd.append(EndIndex)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index == StructStart[Item]:\n                    Match = re.match('^(/\\\\*\\\\*\\\\s*)', Line)\n                    if Match:\n                        StructStartWithComment.append(StructStart[Item])\n                    else:\n                        StructStartWithComment.append(StructStart[Item] + 1)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index >= StructStartWithComment[Item] and Index <= StructEnd[Item]:\n                    self.WriteLinesWithoutTailingSpace(HeaderFd, Line)\n        HeaderFd.write('#pragma pack()\\n\\n')\n        HeaderFd.write('#endif\\n')\n        HeaderFd.close()\n    HeaderFd = open(HeaderFile, 'w')\n    FileBase = os.path.basename(HeaderFile)\n    FileName = FileBase.replace('.', '_').upper()\n    HeaderFd.write('%s\\n' % (__copyright_h__ % date.today().year))\n    HeaderFd.write('#ifndef __%s__\\n' % FileName)\n    HeaderFd.write('#define __%s__\\n\\n' % FileName)\n    HeaderFd.write('#include <FspEas.h>\\n\\n')\n    HeaderFd.write('#pragma pack(1)\\n\\n')\n    for item in range(len(UpdRegionCheck)):\n        Index = 0\n        StartIndex = 0\n        EndIndex = 0\n        StructStart = []\n        StructStartWithComment = []\n        StructEnd = []\n        for Line in TxtBody:\n            Index += 1\n            Match = re.match('(typedef struct {)', Line)\n            if Match:\n                StartIndex = Index - 1\n            Match = re.match('#define\\\\s([_A-Z0-9]+)\\\\s*', Line)\n            if Match and (UpdSignatureCheck[item] in Match.group(1) or UpdSignatureCheck[item] in Match.group(1)):\n                StructStart.append(Index - 1)\n                StructEnd.append(Index)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index == StructStart[Item]:\n                    Match = re.match('^(/\\\\*\\\\*\\\\s*)', Line)\n                    if Match:\n                        StructStartWithComment.append(StructStart[Item])\n                    else:\n                        StructStartWithComment.append(StructStart[Item] + 1)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index >= StructStartWithComment[Item] and Index <= StructEnd[Item]:\n                    self.WriteLinesWithoutTailingSpace(HeaderFd, Line)\n    HeaderFd.write('#pragma pack()\\n\\n')\n    HeaderFd.write('#endif\\n')\n    HeaderFd.close()\n    return 0",
            "def CreateHeaderFile(self, InputHeaderFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    FvDir = self._FvDir\n    HeaderFileName = 'FspUpd.h'\n    HeaderFile = os.path.join(FvDir, HeaderFileName)\n    if self.NoDscFileChange(HeaderFile):\n        self.Error = 'No DSC file change, skip to create UPD header file'\n        return 256\n    TxtBody = []\n    for Item in self._CfgItemList:\n        if str(Item['cname']) == 'Signature' and Item['length'] == 8:\n            Value = int(Item['value'], 16)\n            Chars = []\n            while Value != 0:\n                Chars.append(chr(Value & 255))\n                Value = Value >> 8\n            SignatureStr = ''.join(Chars)\n            if '_T' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPT_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_M' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPM_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_S' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPS_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_I' in SignatureStr[6:6 + 2]:\n                if NoFSPI == False:\n                    TxtBody.append(\"#define FSPI_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n    TxtBody.append('\\n')\n    for Region in ['UPD']:\n        UpdOffsetTable = []\n        UpdSignature = ['0x545F', '0x4D5F', '0x535F', '0x495F']\n        UpdStructure = ['FSPT_UPD', 'FSPM_UPD', 'FSPS_UPD', 'FSPI_UPD']\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and Item['value'][0:6] in UpdSignature:\n                Item['offset'] = 0\n                UpdOffsetTable.append(Item['offset'])\n        for UpdIdx in range(len(UpdOffsetTable)):\n            CommentLine = ''\n            for Item in self._CfgItemList:\n                if Item['comment'] != '' and Item['offset'] >= UpdOffsetTable[UpdIdx]:\n                    MatchComment = re.match('^(U|V)PD_DATA_REGION:([\\\\w|\\\\W|\\\\s]+)', Item['comment'])\n                    if MatchComment and MatchComment.group(1) == Region[0]:\n                        CommentLine = ' ' + MatchComment.group(2) + '\\n'\n                        TxtBody.append('/**' + CommentLine + '**/\\n')\n                elif Item['offset'] >= UpdOffsetTable[UpdIdx] and Item['comment'] == '':\n                    Match = re.match('^FSP([\\\\w|\\\\W|\\\\s])_UPD', UpdStructure[UpdIdx])\n                    if Match:\n                        TxtBody.append('/** Fsp ' + Match.group(1) + ' UPD Configuration\\n**/\\n')\n            TxtBody.append('typedef struct {\\n')\n            NextOffset = 0\n            SpaceIdx = 0\n            Offset = 0\n            LastVisible = True\n            ResvOffset = 0\n            ResvIdx = 0\n            LineBuffer = []\n            InRange = False\n            for Item in self._CfgItemList:\n                if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == UpdSignature[UpdIdx] or Region[0] == 'V':\n                    InRange = True\n                if InRange != True:\n                    continue\n                if Item['cname'] == 'UpdTerminator':\n                    InRange = False\n                if Item['region'] != Region:\n                    continue\n                if Item['offset'] < UpdOffsetTable[UpdIdx]:\n                    continue\n                NextVisible = LastVisible\n                if LastVisible and Item['header'] == 'OFF':\n                    NextVisible = False\n                    ResvOffset = Item['offset']\n                elif not LastVisible and Item['header'] == 'ON':\n                    NextVisible = True\n                    Name = 'Reserved' + Region[0] + 'pdSpace%d' % ResvIdx\n                    ResvIdx = ResvIdx + 1\n                    TxtBody.append(self.CreateField(Item, Name, Item['offset'] - ResvOffset, ResvOffset, '', '', '', ''))\n                if Offset < Item['offset']:\n                    if LastVisible:\n                        Name = 'Unused' + Region[0] + 'pdSpace%d' % SpaceIdx\n                        LineBuffer.append(self.CreateField(Item, Name, Item['offset'] - Offset, Offset, '', '', '', ''))\n                    SpaceIdx = SpaceIdx + 1\n                    Offset = Item['offset']\n                LastVisible = NextVisible\n                Offset = Offset + Item['length']\n                if LastVisible:\n                    for Each in LineBuffer:\n                        TxtBody.append(Each)\n                    LineBuffer = []\n                    Comment = Item['comment']\n                    Embed = Item['embed'].upper()\n                    if Embed.endswith(':START') or Embed.endswith(':END'):\n                        if not Comment == '' and Embed.endswith(':START'):\n                            Marker = '/* COMMENT:%s */ \\n' % Item['comment']\n                            Marker = Marker + '/* EMBED_STRUCT:%s */ ' % Item['embed']\n                        else:\n                            Marker = '/* EMBED_STRUCT:%s */ ' % Item['embed']\n                    elif Embed == '':\n                        Marker = ''\n                    else:\n                        self.Error = \"Invalid embedded structure format '%s'!\\n\" % Item['embed']\n                        return 4\n                    Line = Marker + self.CreateField(Item, Item['cname'], Item['length'], Item['offset'], Item['struct'], Item['name'], Item['help'], Item['option'])\n                    TxtBody.append(Line)\n                if Item['cname'] == 'UpdTerminator':\n                    break\n            TxtBody.append('} ' + UpdStructure[UpdIdx] + ';\\n\\n')\n    TxtBody = self.PostProcessBody(TxtBody)\n    HeaderTFileName = 'FsptUpd.h'\n    HeaderMFileName = 'FspmUpd.h'\n    HeaderSFileName = 'FspsUpd.h'\n    HeaderIFileName = 'FspiUpd.h'\n    UpdRegionCheck = ['FSPT', 'FSPM', 'FSPS', 'FSPI']\n    UpdConfigCheck = ['FSP_T', 'FSP_M', 'FSP_S', 'FSP_I']\n    UpdSignatureCheck = ['FSPT_UPD_SIGNATURE', 'FSPM_UPD_SIGNATURE', 'FSPS_UPD_SIGNATURE', 'FSPI_UPD_SIGNATURE']\n    ExcludedSpecificUpd = ['FSPT_ARCH_UPD', 'FSPM_ARCH_UPD', 'FSPS_ARCH_UPD', 'FSPI_ARCH_UPD']\n    ExcludedSpecificUpd1 = ['FSPT_ARCH2_UPD', 'FSPM_ARCH2_UPD', 'FSPS_ARCH2_UPD']\n    IncLines = []\n    if InputHeaderFile != '':\n        if not os.path.exists(InputHeaderFile):\n            self.Error = \"Input header file '%s' does not exist\" % InputHeaderFile\n            return 6\n        InFd = open(InputHeaderFile, 'r')\n        IncLines = InFd.readlines()\n        InFd.close()\n    for item in range(len(UpdRegionCheck)):\n        if UpdRegionCheck[item] == 'FSPT':\n            HeaderFd = open(os.path.join(FvDir, HeaderTFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderTFileName))\n        elif UpdRegionCheck[item] == 'FSPM':\n            HeaderFd = open(os.path.join(FvDir, HeaderMFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderMFileName))\n        elif UpdRegionCheck[item] == 'FSPS':\n            HeaderFd = open(os.path.join(FvDir, HeaderSFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderSFileName))\n        elif UpdRegionCheck[item] == 'FSPI':\n            HeaderFd = open(os.path.join(FvDir, HeaderIFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderIFileName))\n        FileName = FileBase.replace('.', '_').upper()\n        HeaderFd.write('%s\\n' % (__copyright_h__ % date.today().year))\n        HeaderFd.write('#ifndef __%s__\\n' % FileName)\n        HeaderFd.write('#define __%s__\\n\\n' % FileName)\n        HeaderFd.write('#include <%s>\\n\\n' % HeaderFileName)\n        HeaderFd.write('#pragma pack(1)\\n\\n')\n        Export = False\n        for Line in IncLines:\n            Match = re.search('!EXPORT\\\\s+([A-Z]+)\\\\s+EXTERNAL_BOOTLOADER_STRUCT_(BEGIN|END)\\\\s+', Line)\n            if Match:\n                if Match.group(2) == 'BEGIN' and Match.group(1) == UpdRegionCheck[item]:\n                    Export = True\n                    continue\n                else:\n                    Export = False\n                    continue\n            if Export:\n                HeaderFd.write(Line)\n        HeaderFd.write('\\n')\n        Index = 0\n        StartIndex = 0\n        EndIndex = 0\n        StructStart = []\n        StructStartWithComment = []\n        StructEnd = []\n        for Line in TxtBody:\n            Index += 1\n            Match = re.match('(typedef struct {)', Line)\n            if Match:\n                StartIndex = Index - 1\n            Match = re.match('}\\\\s([_A-Z0-9]+);', Line)\n            if Match and (UpdRegionCheck[item] in Match.group(1) or UpdConfigCheck[item] in Match.group(1)) and (ExcludedSpecificUpd[item] not in Match.group(1)) and (ExcludedSpecificUpd1[item] not in Match.group(1)):\n                EndIndex = Index\n                StructStart.append(StartIndex)\n                StructEnd.append(EndIndex)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index == StructStart[Item]:\n                    Match = re.match('^(/\\\\*\\\\*\\\\s*)', Line)\n                    if Match:\n                        StructStartWithComment.append(StructStart[Item])\n                    else:\n                        StructStartWithComment.append(StructStart[Item] + 1)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index >= StructStartWithComment[Item] and Index <= StructEnd[Item]:\n                    self.WriteLinesWithoutTailingSpace(HeaderFd, Line)\n        HeaderFd.write('#pragma pack()\\n\\n')\n        HeaderFd.write('#endif\\n')\n        HeaderFd.close()\n    HeaderFd = open(HeaderFile, 'w')\n    FileBase = os.path.basename(HeaderFile)\n    FileName = FileBase.replace('.', '_').upper()\n    HeaderFd.write('%s\\n' % (__copyright_h__ % date.today().year))\n    HeaderFd.write('#ifndef __%s__\\n' % FileName)\n    HeaderFd.write('#define __%s__\\n\\n' % FileName)\n    HeaderFd.write('#include <FspEas.h>\\n\\n')\n    HeaderFd.write('#pragma pack(1)\\n\\n')\n    for item in range(len(UpdRegionCheck)):\n        Index = 0\n        StartIndex = 0\n        EndIndex = 0\n        StructStart = []\n        StructStartWithComment = []\n        StructEnd = []\n        for Line in TxtBody:\n            Index += 1\n            Match = re.match('(typedef struct {)', Line)\n            if Match:\n                StartIndex = Index - 1\n            Match = re.match('#define\\\\s([_A-Z0-9]+)\\\\s*', Line)\n            if Match and (UpdSignatureCheck[item] in Match.group(1) or UpdSignatureCheck[item] in Match.group(1)):\n                StructStart.append(Index - 1)\n                StructEnd.append(Index)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index == StructStart[Item]:\n                    Match = re.match('^(/\\\\*\\\\*\\\\s*)', Line)\n                    if Match:\n                        StructStartWithComment.append(StructStart[Item])\n                    else:\n                        StructStartWithComment.append(StructStart[Item] + 1)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index >= StructStartWithComment[Item] and Index <= StructEnd[Item]:\n                    self.WriteLinesWithoutTailingSpace(HeaderFd, Line)\n    HeaderFd.write('#pragma pack()\\n\\n')\n    HeaderFd.write('#endif\\n')\n    HeaderFd.close()\n    return 0",
            "def CreateHeaderFile(self, InputHeaderFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    FvDir = self._FvDir\n    HeaderFileName = 'FspUpd.h'\n    HeaderFile = os.path.join(FvDir, HeaderFileName)\n    if self.NoDscFileChange(HeaderFile):\n        self.Error = 'No DSC file change, skip to create UPD header file'\n        return 256\n    TxtBody = []\n    for Item in self._CfgItemList:\n        if str(Item['cname']) == 'Signature' and Item['length'] == 8:\n            Value = int(Item['value'], 16)\n            Chars = []\n            while Value != 0:\n                Chars.append(chr(Value & 255))\n                Value = Value >> 8\n            SignatureStr = ''.join(Chars)\n            if '_T' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPT_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_M' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPM_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_S' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPS_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_I' in SignatureStr[6:6 + 2]:\n                if NoFSPI == False:\n                    TxtBody.append(\"#define FSPI_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n    TxtBody.append('\\n')\n    for Region in ['UPD']:\n        UpdOffsetTable = []\n        UpdSignature = ['0x545F', '0x4D5F', '0x535F', '0x495F']\n        UpdStructure = ['FSPT_UPD', 'FSPM_UPD', 'FSPS_UPD', 'FSPI_UPD']\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and Item['value'][0:6] in UpdSignature:\n                Item['offset'] = 0\n                UpdOffsetTable.append(Item['offset'])\n        for UpdIdx in range(len(UpdOffsetTable)):\n            CommentLine = ''\n            for Item in self._CfgItemList:\n                if Item['comment'] != '' and Item['offset'] >= UpdOffsetTable[UpdIdx]:\n                    MatchComment = re.match('^(U|V)PD_DATA_REGION:([\\\\w|\\\\W|\\\\s]+)', Item['comment'])\n                    if MatchComment and MatchComment.group(1) == Region[0]:\n                        CommentLine = ' ' + MatchComment.group(2) + '\\n'\n                        TxtBody.append('/**' + CommentLine + '**/\\n')\n                elif Item['offset'] >= UpdOffsetTable[UpdIdx] and Item['comment'] == '':\n                    Match = re.match('^FSP([\\\\w|\\\\W|\\\\s])_UPD', UpdStructure[UpdIdx])\n                    if Match:\n                        TxtBody.append('/** Fsp ' + Match.group(1) + ' UPD Configuration\\n**/\\n')\n            TxtBody.append('typedef struct {\\n')\n            NextOffset = 0\n            SpaceIdx = 0\n            Offset = 0\n            LastVisible = True\n            ResvOffset = 0\n            ResvIdx = 0\n            LineBuffer = []\n            InRange = False\n            for Item in self._CfgItemList:\n                if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == UpdSignature[UpdIdx] or Region[0] == 'V':\n                    InRange = True\n                if InRange != True:\n                    continue\n                if Item['cname'] == 'UpdTerminator':\n                    InRange = False\n                if Item['region'] != Region:\n                    continue\n                if Item['offset'] < UpdOffsetTable[UpdIdx]:\n                    continue\n                NextVisible = LastVisible\n                if LastVisible and Item['header'] == 'OFF':\n                    NextVisible = False\n                    ResvOffset = Item['offset']\n                elif not LastVisible and Item['header'] == 'ON':\n                    NextVisible = True\n                    Name = 'Reserved' + Region[0] + 'pdSpace%d' % ResvIdx\n                    ResvIdx = ResvIdx + 1\n                    TxtBody.append(self.CreateField(Item, Name, Item['offset'] - ResvOffset, ResvOffset, '', '', '', ''))\n                if Offset < Item['offset']:\n                    if LastVisible:\n                        Name = 'Unused' + Region[0] + 'pdSpace%d' % SpaceIdx\n                        LineBuffer.append(self.CreateField(Item, Name, Item['offset'] - Offset, Offset, '', '', '', ''))\n                    SpaceIdx = SpaceIdx + 1\n                    Offset = Item['offset']\n                LastVisible = NextVisible\n                Offset = Offset + Item['length']\n                if LastVisible:\n                    for Each in LineBuffer:\n                        TxtBody.append(Each)\n                    LineBuffer = []\n                    Comment = Item['comment']\n                    Embed = Item['embed'].upper()\n                    if Embed.endswith(':START') or Embed.endswith(':END'):\n                        if not Comment == '' and Embed.endswith(':START'):\n                            Marker = '/* COMMENT:%s */ \\n' % Item['comment']\n                            Marker = Marker + '/* EMBED_STRUCT:%s */ ' % Item['embed']\n                        else:\n                            Marker = '/* EMBED_STRUCT:%s */ ' % Item['embed']\n                    elif Embed == '':\n                        Marker = ''\n                    else:\n                        self.Error = \"Invalid embedded structure format '%s'!\\n\" % Item['embed']\n                        return 4\n                    Line = Marker + self.CreateField(Item, Item['cname'], Item['length'], Item['offset'], Item['struct'], Item['name'], Item['help'], Item['option'])\n                    TxtBody.append(Line)\n                if Item['cname'] == 'UpdTerminator':\n                    break\n            TxtBody.append('} ' + UpdStructure[UpdIdx] + ';\\n\\n')\n    TxtBody = self.PostProcessBody(TxtBody)\n    HeaderTFileName = 'FsptUpd.h'\n    HeaderMFileName = 'FspmUpd.h'\n    HeaderSFileName = 'FspsUpd.h'\n    HeaderIFileName = 'FspiUpd.h'\n    UpdRegionCheck = ['FSPT', 'FSPM', 'FSPS', 'FSPI']\n    UpdConfigCheck = ['FSP_T', 'FSP_M', 'FSP_S', 'FSP_I']\n    UpdSignatureCheck = ['FSPT_UPD_SIGNATURE', 'FSPM_UPD_SIGNATURE', 'FSPS_UPD_SIGNATURE', 'FSPI_UPD_SIGNATURE']\n    ExcludedSpecificUpd = ['FSPT_ARCH_UPD', 'FSPM_ARCH_UPD', 'FSPS_ARCH_UPD', 'FSPI_ARCH_UPD']\n    ExcludedSpecificUpd1 = ['FSPT_ARCH2_UPD', 'FSPM_ARCH2_UPD', 'FSPS_ARCH2_UPD']\n    IncLines = []\n    if InputHeaderFile != '':\n        if not os.path.exists(InputHeaderFile):\n            self.Error = \"Input header file '%s' does not exist\" % InputHeaderFile\n            return 6\n        InFd = open(InputHeaderFile, 'r')\n        IncLines = InFd.readlines()\n        InFd.close()\n    for item in range(len(UpdRegionCheck)):\n        if UpdRegionCheck[item] == 'FSPT':\n            HeaderFd = open(os.path.join(FvDir, HeaderTFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderTFileName))\n        elif UpdRegionCheck[item] == 'FSPM':\n            HeaderFd = open(os.path.join(FvDir, HeaderMFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderMFileName))\n        elif UpdRegionCheck[item] == 'FSPS':\n            HeaderFd = open(os.path.join(FvDir, HeaderSFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderSFileName))\n        elif UpdRegionCheck[item] == 'FSPI':\n            HeaderFd = open(os.path.join(FvDir, HeaderIFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderIFileName))\n        FileName = FileBase.replace('.', '_').upper()\n        HeaderFd.write('%s\\n' % (__copyright_h__ % date.today().year))\n        HeaderFd.write('#ifndef __%s__\\n' % FileName)\n        HeaderFd.write('#define __%s__\\n\\n' % FileName)\n        HeaderFd.write('#include <%s>\\n\\n' % HeaderFileName)\n        HeaderFd.write('#pragma pack(1)\\n\\n')\n        Export = False\n        for Line in IncLines:\n            Match = re.search('!EXPORT\\\\s+([A-Z]+)\\\\s+EXTERNAL_BOOTLOADER_STRUCT_(BEGIN|END)\\\\s+', Line)\n            if Match:\n                if Match.group(2) == 'BEGIN' and Match.group(1) == UpdRegionCheck[item]:\n                    Export = True\n                    continue\n                else:\n                    Export = False\n                    continue\n            if Export:\n                HeaderFd.write(Line)\n        HeaderFd.write('\\n')\n        Index = 0\n        StartIndex = 0\n        EndIndex = 0\n        StructStart = []\n        StructStartWithComment = []\n        StructEnd = []\n        for Line in TxtBody:\n            Index += 1\n            Match = re.match('(typedef struct {)', Line)\n            if Match:\n                StartIndex = Index - 1\n            Match = re.match('}\\\\s([_A-Z0-9]+);', Line)\n            if Match and (UpdRegionCheck[item] in Match.group(1) or UpdConfigCheck[item] in Match.group(1)) and (ExcludedSpecificUpd[item] not in Match.group(1)) and (ExcludedSpecificUpd1[item] not in Match.group(1)):\n                EndIndex = Index\n                StructStart.append(StartIndex)\n                StructEnd.append(EndIndex)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index == StructStart[Item]:\n                    Match = re.match('^(/\\\\*\\\\*\\\\s*)', Line)\n                    if Match:\n                        StructStartWithComment.append(StructStart[Item])\n                    else:\n                        StructStartWithComment.append(StructStart[Item] + 1)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index >= StructStartWithComment[Item] and Index <= StructEnd[Item]:\n                    self.WriteLinesWithoutTailingSpace(HeaderFd, Line)\n        HeaderFd.write('#pragma pack()\\n\\n')\n        HeaderFd.write('#endif\\n')\n        HeaderFd.close()\n    HeaderFd = open(HeaderFile, 'w')\n    FileBase = os.path.basename(HeaderFile)\n    FileName = FileBase.replace('.', '_').upper()\n    HeaderFd.write('%s\\n' % (__copyright_h__ % date.today().year))\n    HeaderFd.write('#ifndef __%s__\\n' % FileName)\n    HeaderFd.write('#define __%s__\\n\\n' % FileName)\n    HeaderFd.write('#include <FspEas.h>\\n\\n')\n    HeaderFd.write('#pragma pack(1)\\n\\n')\n    for item in range(len(UpdRegionCheck)):\n        Index = 0\n        StartIndex = 0\n        EndIndex = 0\n        StructStart = []\n        StructStartWithComment = []\n        StructEnd = []\n        for Line in TxtBody:\n            Index += 1\n            Match = re.match('(typedef struct {)', Line)\n            if Match:\n                StartIndex = Index - 1\n            Match = re.match('#define\\\\s([_A-Z0-9]+)\\\\s*', Line)\n            if Match and (UpdSignatureCheck[item] in Match.group(1) or UpdSignatureCheck[item] in Match.group(1)):\n                StructStart.append(Index - 1)\n                StructEnd.append(Index)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index == StructStart[Item]:\n                    Match = re.match('^(/\\\\*\\\\*\\\\s*)', Line)\n                    if Match:\n                        StructStartWithComment.append(StructStart[Item])\n                    else:\n                        StructStartWithComment.append(StructStart[Item] + 1)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index >= StructStartWithComment[Item] and Index <= StructEnd[Item]:\n                    self.WriteLinesWithoutTailingSpace(HeaderFd, Line)\n    HeaderFd.write('#pragma pack()\\n\\n')\n    HeaderFd.write('#endif\\n')\n    HeaderFd.close()\n    return 0",
            "def CreateHeaderFile(self, InputHeaderFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    FvDir = self._FvDir\n    HeaderFileName = 'FspUpd.h'\n    HeaderFile = os.path.join(FvDir, HeaderFileName)\n    if self.NoDscFileChange(HeaderFile):\n        self.Error = 'No DSC file change, skip to create UPD header file'\n        return 256\n    TxtBody = []\n    for Item in self._CfgItemList:\n        if str(Item['cname']) == 'Signature' and Item['length'] == 8:\n            Value = int(Item['value'], 16)\n            Chars = []\n            while Value != 0:\n                Chars.append(chr(Value & 255))\n                Value = Value >> 8\n            SignatureStr = ''.join(Chars)\n            if '_T' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPT_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_M' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPM_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_S' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPS_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_I' in SignatureStr[6:6 + 2]:\n                if NoFSPI == False:\n                    TxtBody.append(\"#define FSPI_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n    TxtBody.append('\\n')\n    for Region in ['UPD']:\n        UpdOffsetTable = []\n        UpdSignature = ['0x545F', '0x4D5F', '0x535F', '0x495F']\n        UpdStructure = ['FSPT_UPD', 'FSPM_UPD', 'FSPS_UPD', 'FSPI_UPD']\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and Item['value'][0:6] in UpdSignature:\n                Item['offset'] = 0\n                UpdOffsetTable.append(Item['offset'])\n        for UpdIdx in range(len(UpdOffsetTable)):\n            CommentLine = ''\n            for Item in self._CfgItemList:\n                if Item['comment'] != '' and Item['offset'] >= UpdOffsetTable[UpdIdx]:\n                    MatchComment = re.match('^(U|V)PD_DATA_REGION:([\\\\w|\\\\W|\\\\s]+)', Item['comment'])\n                    if MatchComment and MatchComment.group(1) == Region[0]:\n                        CommentLine = ' ' + MatchComment.group(2) + '\\n'\n                        TxtBody.append('/**' + CommentLine + '**/\\n')\n                elif Item['offset'] >= UpdOffsetTable[UpdIdx] and Item['comment'] == '':\n                    Match = re.match('^FSP([\\\\w|\\\\W|\\\\s])_UPD', UpdStructure[UpdIdx])\n                    if Match:\n                        TxtBody.append('/** Fsp ' + Match.group(1) + ' UPD Configuration\\n**/\\n')\n            TxtBody.append('typedef struct {\\n')\n            NextOffset = 0\n            SpaceIdx = 0\n            Offset = 0\n            LastVisible = True\n            ResvOffset = 0\n            ResvIdx = 0\n            LineBuffer = []\n            InRange = False\n            for Item in self._CfgItemList:\n                if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == UpdSignature[UpdIdx] or Region[0] == 'V':\n                    InRange = True\n                if InRange != True:\n                    continue\n                if Item['cname'] == 'UpdTerminator':\n                    InRange = False\n                if Item['region'] != Region:\n                    continue\n                if Item['offset'] < UpdOffsetTable[UpdIdx]:\n                    continue\n                NextVisible = LastVisible\n                if LastVisible and Item['header'] == 'OFF':\n                    NextVisible = False\n                    ResvOffset = Item['offset']\n                elif not LastVisible and Item['header'] == 'ON':\n                    NextVisible = True\n                    Name = 'Reserved' + Region[0] + 'pdSpace%d' % ResvIdx\n                    ResvIdx = ResvIdx + 1\n                    TxtBody.append(self.CreateField(Item, Name, Item['offset'] - ResvOffset, ResvOffset, '', '', '', ''))\n                if Offset < Item['offset']:\n                    if LastVisible:\n                        Name = 'Unused' + Region[0] + 'pdSpace%d' % SpaceIdx\n                        LineBuffer.append(self.CreateField(Item, Name, Item['offset'] - Offset, Offset, '', '', '', ''))\n                    SpaceIdx = SpaceIdx + 1\n                    Offset = Item['offset']\n                LastVisible = NextVisible\n                Offset = Offset + Item['length']\n                if LastVisible:\n                    for Each in LineBuffer:\n                        TxtBody.append(Each)\n                    LineBuffer = []\n                    Comment = Item['comment']\n                    Embed = Item['embed'].upper()\n                    if Embed.endswith(':START') or Embed.endswith(':END'):\n                        if not Comment == '' and Embed.endswith(':START'):\n                            Marker = '/* COMMENT:%s */ \\n' % Item['comment']\n                            Marker = Marker + '/* EMBED_STRUCT:%s */ ' % Item['embed']\n                        else:\n                            Marker = '/* EMBED_STRUCT:%s */ ' % Item['embed']\n                    elif Embed == '':\n                        Marker = ''\n                    else:\n                        self.Error = \"Invalid embedded structure format '%s'!\\n\" % Item['embed']\n                        return 4\n                    Line = Marker + self.CreateField(Item, Item['cname'], Item['length'], Item['offset'], Item['struct'], Item['name'], Item['help'], Item['option'])\n                    TxtBody.append(Line)\n                if Item['cname'] == 'UpdTerminator':\n                    break\n            TxtBody.append('} ' + UpdStructure[UpdIdx] + ';\\n\\n')\n    TxtBody = self.PostProcessBody(TxtBody)\n    HeaderTFileName = 'FsptUpd.h'\n    HeaderMFileName = 'FspmUpd.h'\n    HeaderSFileName = 'FspsUpd.h'\n    HeaderIFileName = 'FspiUpd.h'\n    UpdRegionCheck = ['FSPT', 'FSPM', 'FSPS', 'FSPI']\n    UpdConfigCheck = ['FSP_T', 'FSP_M', 'FSP_S', 'FSP_I']\n    UpdSignatureCheck = ['FSPT_UPD_SIGNATURE', 'FSPM_UPD_SIGNATURE', 'FSPS_UPD_SIGNATURE', 'FSPI_UPD_SIGNATURE']\n    ExcludedSpecificUpd = ['FSPT_ARCH_UPD', 'FSPM_ARCH_UPD', 'FSPS_ARCH_UPD', 'FSPI_ARCH_UPD']\n    ExcludedSpecificUpd1 = ['FSPT_ARCH2_UPD', 'FSPM_ARCH2_UPD', 'FSPS_ARCH2_UPD']\n    IncLines = []\n    if InputHeaderFile != '':\n        if not os.path.exists(InputHeaderFile):\n            self.Error = \"Input header file '%s' does not exist\" % InputHeaderFile\n            return 6\n        InFd = open(InputHeaderFile, 'r')\n        IncLines = InFd.readlines()\n        InFd.close()\n    for item in range(len(UpdRegionCheck)):\n        if UpdRegionCheck[item] == 'FSPT':\n            HeaderFd = open(os.path.join(FvDir, HeaderTFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderTFileName))\n        elif UpdRegionCheck[item] == 'FSPM':\n            HeaderFd = open(os.path.join(FvDir, HeaderMFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderMFileName))\n        elif UpdRegionCheck[item] == 'FSPS':\n            HeaderFd = open(os.path.join(FvDir, HeaderSFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderSFileName))\n        elif UpdRegionCheck[item] == 'FSPI':\n            HeaderFd = open(os.path.join(FvDir, HeaderIFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderIFileName))\n        FileName = FileBase.replace('.', '_').upper()\n        HeaderFd.write('%s\\n' % (__copyright_h__ % date.today().year))\n        HeaderFd.write('#ifndef __%s__\\n' % FileName)\n        HeaderFd.write('#define __%s__\\n\\n' % FileName)\n        HeaderFd.write('#include <%s>\\n\\n' % HeaderFileName)\n        HeaderFd.write('#pragma pack(1)\\n\\n')\n        Export = False\n        for Line in IncLines:\n            Match = re.search('!EXPORT\\\\s+([A-Z]+)\\\\s+EXTERNAL_BOOTLOADER_STRUCT_(BEGIN|END)\\\\s+', Line)\n            if Match:\n                if Match.group(2) == 'BEGIN' and Match.group(1) == UpdRegionCheck[item]:\n                    Export = True\n                    continue\n                else:\n                    Export = False\n                    continue\n            if Export:\n                HeaderFd.write(Line)\n        HeaderFd.write('\\n')\n        Index = 0\n        StartIndex = 0\n        EndIndex = 0\n        StructStart = []\n        StructStartWithComment = []\n        StructEnd = []\n        for Line in TxtBody:\n            Index += 1\n            Match = re.match('(typedef struct {)', Line)\n            if Match:\n                StartIndex = Index - 1\n            Match = re.match('}\\\\s([_A-Z0-9]+);', Line)\n            if Match and (UpdRegionCheck[item] in Match.group(1) or UpdConfigCheck[item] in Match.group(1)) and (ExcludedSpecificUpd[item] not in Match.group(1)) and (ExcludedSpecificUpd1[item] not in Match.group(1)):\n                EndIndex = Index\n                StructStart.append(StartIndex)\n                StructEnd.append(EndIndex)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index == StructStart[Item]:\n                    Match = re.match('^(/\\\\*\\\\*\\\\s*)', Line)\n                    if Match:\n                        StructStartWithComment.append(StructStart[Item])\n                    else:\n                        StructStartWithComment.append(StructStart[Item] + 1)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index >= StructStartWithComment[Item] and Index <= StructEnd[Item]:\n                    self.WriteLinesWithoutTailingSpace(HeaderFd, Line)\n        HeaderFd.write('#pragma pack()\\n\\n')\n        HeaderFd.write('#endif\\n')\n        HeaderFd.close()\n    HeaderFd = open(HeaderFile, 'w')\n    FileBase = os.path.basename(HeaderFile)\n    FileName = FileBase.replace('.', '_').upper()\n    HeaderFd.write('%s\\n' % (__copyright_h__ % date.today().year))\n    HeaderFd.write('#ifndef __%s__\\n' % FileName)\n    HeaderFd.write('#define __%s__\\n\\n' % FileName)\n    HeaderFd.write('#include <FspEas.h>\\n\\n')\n    HeaderFd.write('#pragma pack(1)\\n\\n')\n    for item in range(len(UpdRegionCheck)):\n        Index = 0\n        StartIndex = 0\n        EndIndex = 0\n        StructStart = []\n        StructStartWithComment = []\n        StructEnd = []\n        for Line in TxtBody:\n            Index += 1\n            Match = re.match('(typedef struct {)', Line)\n            if Match:\n                StartIndex = Index - 1\n            Match = re.match('#define\\\\s([_A-Z0-9]+)\\\\s*', Line)\n            if Match and (UpdSignatureCheck[item] in Match.group(1) or UpdSignatureCheck[item] in Match.group(1)):\n                StructStart.append(Index - 1)\n                StructEnd.append(Index)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index == StructStart[Item]:\n                    Match = re.match('^(/\\\\*\\\\*\\\\s*)', Line)\n                    if Match:\n                        StructStartWithComment.append(StructStart[Item])\n                    else:\n                        StructStartWithComment.append(StructStart[Item] + 1)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index >= StructStartWithComment[Item] and Index <= StructEnd[Item]:\n                    self.WriteLinesWithoutTailingSpace(HeaderFd, Line)\n    HeaderFd.write('#pragma pack()\\n\\n')\n    HeaderFd.write('#endif\\n')\n    HeaderFd.close()\n    return 0",
            "def CreateHeaderFile(self, InputHeaderFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    FvDir = self._FvDir\n    HeaderFileName = 'FspUpd.h'\n    HeaderFile = os.path.join(FvDir, HeaderFileName)\n    if self.NoDscFileChange(HeaderFile):\n        self.Error = 'No DSC file change, skip to create UPD header file'\n        return 256\n    TxtBody = []\n    for Item in self._CfgItemList:\n        if str(Item['cname']) == 'Signature' and Item['length'] == 8:\n            Value = int(Item['value'], 16)\n            Chars = []\n            while Value != 0:\n                Chars.append(chr(Value & 255))\n                Value = Value >> 8\n            SignatureStr = ''.join(Chars)\n            if '_T' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPT_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_M' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPM_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_S' in SignatureStr[6:6 + 2]:\n                TxtBody.append(\"#define FSPS_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n            elif '_I' in SignatureStr[6:6 + 2]:\n                if NoFSPI == False:\n                    TxtBody.append(\"#define FSPI_UPD_SIGNATURE               %s        /* '%s' */\\n\\n\" % (Item['value'], SignatureStr))\n    TxtBody.append('\\n')\n    for Region in ['UPD']:\n        UpdOffsetTable = []\n        UpdSignature = ['0x545F', '0x4D5F', '0x535F', '0x495F']\n        UpdStructure = ['FSPT_UPD', 'FSPM_UPD', 'FSPS_UPD', 'FSPI_UPD']\n        for Item in self._CfgItemList:\n            if Item['cname'] == 'Signature' and Item['value'][0:6] in UpdSignature:\n                Item['offset'] = 0\n                UpdOffsetTable.append(Item['offset'])\n        for UpdIdx in range(len(UpdOffsetTable)):\n            CommentLine = ''\n            for Item in self._CfgItemList:\n                if Item['comment'] != '' and Item['offset'] >= UpdOffsetTable[UpdIdx]:\n                    MatchComment = re.match('^(U|V)PD_DATA_REGION:([\\\\w|\\\\W|\\\\s]+)', Item['comment'])\n                    if MatchComment and MatchComment.group(1) == Region[0]:\n                        CommentLine = ' ' + MatchComment.group(2) + '\\n'\n                        TxtBody.append('/**' + CommentLine + '**/\\n')\n                elif Item['offset'] >= UpdOffsetTable[UpdIdx] and Item['comment'] == '':\n                    Match = re.match('^FSP([\\\\w|\\\\W|\\\\s])_UPD', UpdStructure[UpdIdx])\n                    if Match:\n                        TxtBody.append('/** Fsp ' + Match.group(1) + ' UPD Configuration\\n**/\\n')\n            TxtBody.append('typedef struct {\\n')\n            NextOffset = 0\n            SpaceIdx = 0\n            Offset = 0\n            LastVisible = True\n            ResvOffset = 0\n            ResvIdx = 0\n            LineBuffer = []\n            InRange = False\n            for Item in self._CfgItemList:\n                if Item['cname'] == 'Signature' and str(Item['value'])[0:6] == UpdSignature[UpdIdx] or Region[0] == 'V':\n                    InRange = True\n                if InRange != True:\n                    continue\n                if Item['cname'] == 'UpdTerminator':\n                    InRange = False\n                if Item['region'] != Region:\n                    continue\n                if Item['offset'] < UpdOffsetTable[UpdIdx]:\n                    continue\n                NextVisible = LastVisible\n                if LastVisible and Item['header'] == 'OFF':\n                    NextVisible = False\n                    ResvOffset = Item['offset']\n                elif not LastVisible and Item['header'] == 'ON':\n                    NextVisible = True\n                    Name = 'Reserved' + Region[0] + 'pdSpace%d' % ResvIdx\n                    ResvIdx = ResvIdx + 1\n                    TxtBody.append(self.CreateField(Item, Name, Item['offset'] - ResvOffset, ResvOffset, '', '', '', ''))\n                if Offset < Item['offset']:\n                    if LastVisible:\n                        Name = 'Unused' + Region[0] + 'pdSpace%d' % SpaceIdx\n                        LineBuffer.append(self.CreateField(Item, Name, Item['offset'] - Offset, Offset, '', '', '', ''))\n                    SpaceIdx = SpaceIdx + 1\n                    Offset = Item['offset']\n                LastVisible = NextVisible\n                Offset = Offset + Item['length']\n                if LastVisible:\n                    for Each in LineBuffer:\n                        TxtBody.append(Each)\n                    LineBuffer = []\n                    Comment = Item['comment']\n                    Embed = Item['embed'].upper()\n                    if Embed.endswith(':START') or Embed.endswith(':END'):\n                        if not Comment == '' and Embed.endswith(':START'):\n                            Marker = '/* COMMENT:%s */ \\n' % Item['comment']\n                            Marker = Marker + '/* EMBED_STRUCT:%s */ ' % Item['embed']\n                        else:\n                            Marker = '/* EMBED_STRUCT:%s */ ' % Item['embed']\n                    elif Embed == '':\n                        Marker = ''\n                    else:\n                        self.Error = \"Invalid embedded structure format '%s'!\\n\" % Item['embed']\n                        return 4\n                    Line = Marker + self.CreateField(Item, Item['cname'], Item['length'], Item['offset'], Item['struct'], Item['name'], Item['help'], Item['option'])\n                    TxtBody.append(Line)\n                if Item['cname'] == 'UpdTerminator':\n                    break\n            TxtBody.append('} ' + UpdStructure[UpdIdx] + ';\\n\\n')\n    TxtBody = self.PostProcessBody(TxtBody)\n    HeaderTFileName = 'FsptUpd.h'\n    HeaderMFileName = 'FspmUpd.h'\n    HeaderSFileName = 'FspsUpd.h'\n    HeaderIFileName = 'FspiUpd.h'\n    UpdRegionCheck = ['FSPT', 'FSPM', 'FSPS', 'FSPI']\n    UpdConfigCheck = ['FSP_T', 'FSP_M', 'FSP_S', 'FSP_I']\n    UpdSignatureCheck = ['FSPT_UPD_SIGNATURE', 'FSPM_UPD_SIGNATURE', 'FSPS_UPD_SIGNATURE', 'FSPI_UPD_SIGNATURE']\n    ExcludedSpecificUpd = ['FSPT_ARCH_UPD', 'FSPM_ARCH_UPD', 'FSPS_ARCH_UPD', 'FSPI_ARCH_UPD']\n    ExcludedSpecificUpd1 = ['FSPT_ARCH2_UPD', 'FSPM_ARCH2_UPD', 'FSPS_ARCH2_UPD']\n    IncLines = []\n    if InputHeaderFile != '':\n        if not os.path.exists(InputHeaderFile):\n            self.Error = \"Input header file '%s' does not exist\" % InputHeaderFile\n            return 6\n        InFd = open(InputHeaderFile, 'r')\n        IncLines = InFd.readlines()\n        InFd.close()\n    for item in range(len(UpdRegionCheck)):\n        if UpdRegionCheck[item] == 'FSPT':\n            HeaderFd = open(os.path.join(FvDir, HeaderTFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderTFileName))\n        elif UpdRegionCheck[item] == 'FSPM':\n            HeaderFd = open(os.path.join(FvDir, HeaderMFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderMFileName))\n        elif UpdRegionCheck[item] == 'FSPS':\n            HeaderFd = open(os.path.join(FvDir, HeaderSFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderSFileName))\n        elif UpdRegionCheck[item] == 'FSPI':\n            HeaderFd = open(os.path.join(FvDir, HeaderIFileName), 'w')\n            FileBase = os.path.basename(os.path.join(FvDir, HeaderIFileName))\n        FileName = FileBase.replace('.', '_').upper()\n        HeaderFd.write('%s\\n' % (__copyright_h__ % date.today().year))\n        HeaderFd.write('#ifndef __%s__\\n' % FileName)\n        HeaderFd.write('#define __%s__\\n\\n' % FileName)\n        HeaderFd.write('#include <%s>\\n\\n' % HeaderFileName)\n        HeaderFd.write('#pragma pack(1)\\n\\n')\n        Export = False\n        for Line in IncLines:\n            Match = re.search('!EXPORT\\\\s+([A-Z]+)\\\\s+EXTERNAL_BOOTLOADER_STRUCT_(BEGIN|END)\\\\s+', Line)\n            if Match:\n                if Match.group(2) == 'BEGIN' and Match.group(1) == UpdRegionCheck[item]:\n                    Export = True\n                    continue\n                else:\n                    Export = False\n                    continue\n            if Export:\n                HeaderFd.write(Line)\n        HeaderFd.write('\\n')\n        Index = 0\n        StartIndex = 0\n        EndIndex = 0\n        StructStart = []\n        StructStartWithComment = []\n        StructEnd = []\n        for Line in TxtBody:\n            Index += 1\n            Match = re.match('(typedef struct {)', Line)\n            if Match:\n                StartIndex = Index - 1\n            Match = re.match('}\\\\s([_A-Z0-9]+);', Line)\n            if Match and (UpdRegionCheck[item] in Match.group(1) or UpdConfigCheck[item] in Match.group(1)) and (ExcludedSpecificUpd[item] not in Match.group(1)) and (ExcludedSpecificUpd1[item] not in Match.group(1)):\n                EndIndex = Index\n                StructStart.append(StartIndex)\n                StructEnd.append(EndIndex)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index == StructStart[Item]:\n                    Match = re.match('^(/\\\\*\\\\*\\\\s*)', Line)\n                    if Match:\n                        StructStartWithComment.append(StructStart[Item])\n                    else:\n                        StructStartWithComment.append(StructStart[Item] + 1)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index >= StructStartWithComment[Item] and Index <= StructEnd[Item]:\n                    self.WriteLinesWithoutTailingSpace(HeaderFd, Line)\n        HeaderFd.write('#pragma pack()\\n\\n')\n        HeaderFd.write('#endif\\n')\n        HeaderFd.close()\n    HeaderFd = open(HeaderFile, 'w')\n    FileBase = os.path.basename(HeaderFile)\n    FileName = FileBase.replace('.', '_').upper()\n    HeaderFd.write('%s\\n' % (__copyright_h__ % date.today().year))\n    HeaderFd.write('#ifndef __%s__\\n' % FileName)\n    HeaderFd.write('#define __%s__\\n\\n' % FileName)\n    HeaderFd.write('#include <FspEas.h>\\n\\n')\n    HeaderFd.write('#pragma pack(1)\\n\\n')\n    for item in range(len(UpdRegionCheck)):\n        Index = 0\n        StartIndex = 0\n        EndIndex = 0\n        StructStart = []\n        StructStartWithComment = []\n        StructEnd = []\n        for Line in TxtBody:\n            Index += 1\n            Match = re.match('(typedef struct {)', Line)\n            if Match:\n                StartIndex = Index - 1\n            Match = re.match('#define\\\\s([_A-Z0-9]+)\\\\s*', Line)\n            if Match and (UpdSignatureCheck[item] in Match.group(1) or UpdSignatureCheck[item] in Match.group(1)):\n                StructStart.append(Index - 1)\n                StructEnd.append(Index)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index == StructStart[Item]:\n                    Match = re.match('^(/\\\\*\\\\*\\\\s*)', Line)\n                    if Match:\n                        StructStartWithComment.append(StructStart[Item])\n                    else:\n                        StructStartWithComment.append(StructStart[Item] + 1)\n        Index = 0\n        for Line in TxtBody:\n            Index += 1\n            for Item in range(len(StructStart)):\n                if Index >= StructStartWithComment[Item] and Index <= StructEnd[Item]:\n                    self.WriteLinesWithoutTailingSpace(HeaderFd, Line)\n    HeaderFd.write('#pragma pack()\\n\\n')\n    HeaderFd.write('#endif\\n')\n    HeaderFd.close()\n    return 0"
        ]
    },
    {
        "func_name": "WriteBsfStruct",
        "original": "def WriteBsfStruct(self, BsfFd, Item):\n    LogExpr = CLogicalExpression()\n    if Item['type'] == 'None':\n        Space = 'gPlatformFspPkgTokenSpaceGuid'\n    else:\n        Space = Item['space']\n    Line = '    $%s_%s' % (Space, Item['cname'])\n    Match = re.match('\\\\s*\\\\{([x0-9a-fA-F,\\\\s]+)\\\\}\\\\s*', Item['value'])\n    if Match:\n        DefaultValue = Match.group(1).strip()\n    else:\n        DefaultValue = Item['value'].strip()\n    if 'bitlength' in Item:\n        BsfFd.write('    %s%s%4d bits     $_DEFAULT_ = %s\\n' % (Line, ' ' * (64 - len(Line)), Item['bitlength'], DefaultValue))\n    else:\n        BsfFd.write('    %s%s%4d bytes    $_DEFAULT_ = %s\\n' % (Line, ' ' * (64 - len(Line)), Item['length'], DefaultValue))\n    TmpList = []\n    if Item['type'] == 'Combo':\n        if not Item['option'] in self._BuidinOption:\n            OptList = Item['option'].split(',')\n            for Option in OptList:\n                Option = Option.strip()\n                (OpVal, OpStr) = Option.split(':')\n                test = LogExpr.getNumber(OpVal)\n                if test is None:\n                    raise Exception(\"Selection Index '%s' is not a number\" % OpVal)\n                TmpList.append((OpVal, OpStr))\n    return TmpList",
        "mutated": [
            "def WriteBsfStruct(self, BsfFd, Item):\n    if False:\n        i = 10\n    LogExpr = CLogicalExpression()\n    if Item['type'] == 'None':\n        Space = 'gPlatformFspPkgTokenSpaceGuid'\n    else:\n        Space = Item['space']\n    Line = '    $%s_%s' % (Space, Item['cname'])\n    Match = re.match('\\\\s*\\\\{([x0-9a-fA-F,\\\\s]+)\\\\}\\\\s*', Item['value'])\n    if Match:\n        DefaultValue = Match.group(1).strip()\n    else:\n        DefaultValue = Item['value'].strip()\n    if 'bitlength' in Item:\n        BsfFd.write('    %s%s%4d bits     $_DEFAULT_ = %s\\n' % (Line, ' ' * (64 - len(Line)), Item['bitlength'], DefaultValue))\n    else:\n        BsfFd.write('    %s%s%4d bytes    $_DEFAULT_ = %s\\n' % (Line, ' ' * (64 - len(Line)), Item['length'], DefaultValue))\n    TmpList = []\n    if Item['type'] == 'Combo':\n        if not Item['option'] in self._BuidinOption:\n            OptList = Item['option'].split(',')\n            for Option in OptList:\n                Option = Option.strip()\n                (OpVal, OpStr) = Option.split(':')\n                test = LogExpr.getNumber(OpVal)\n                if test is None:\n                    raise Exception(\"Selection Index '%s' is not a number\" % OpVal)\n                TmpList.append((OpVal, OpStr))\n    return TmpList",
            "def WriteBsfStruct(self, BsfFd, Item):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    LogExpr = CLogicalExpression()\n    if Item['type'] == 'None':\n        Space = 'gPlatformFspPkgTokenSpaceGuid'\n    else:\n        Space = Item['space']\n    Line = '    $%s_%s' % (Space, Item['cname'])\n    Match = re.match('\\\\s*\\\\{([x0-9a-fA-F,\\\\s]+)\\\\}\\\\s*', Item['value'])\n    if Match:\n        DefaultValue = Match.group(1).strip()\n    else:\n        DefaultValue = Item['value'].strip()\n    if 'bitlength' in Item:\n        BsfFd.write('    %s%s%4d bits     $_DEFAULT_ = %s\\n' % (Line, ' ' * (64 - len(Line)), Item['bitlength'], DefaultValue))\n    else:\n        BsfFd.write('    %s%s%4d bytes    $_DEFAULT_ = %s\\n' % (Line, ' ' * (64 - len(Line)), Item['length'], DefaultValue))\n    TmpList = []\n    if Item['type'] == 'Combo':\n        if not Item['option'] in self._BuidinOption:\n            OptList = Item['option'].split(',')\n            for Option in OptList:\n                Option = Option.strip()\n                (OpVal, OpStr) = Option.split(':')\n                test = LogExpr.getNumber(OpVal)\n                if test is None:\n                    raise Exception(\"Selection Index '%s' is not a number\" % OpVal)\n                TmpList.append((OpVal, OpStr))\n    return TmpList",
            "def WriteBsfStruct(self, BsfFd, Item):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    LogExpr = CLogicalExpression()\n    if Item['type'] == 'None':\n        Space = 'gPlatformFspPkgTokenSpaceGuid'\n    else:\n        Space = Item['space']\n    Line = '    $%s_%s' % (Space, Item['cname'])\n    Match = re.match('\\\\s*\\\\{([x0-9a-fA-F,\\\\s]+)\\\\}\\\\s*', Item['value'])\n    if Match:\n        DefaultValue = Match.group(1).strip()\n    else:\n        DefaultValue = Item['value'].strip()\n    if 'bitlength' in Item:\n        BsfFd.write('    %s%s%4d bits     $_DEFAULT_ = %s\\n' % (Line, ' ' * (64 - len(Line)), Item['bitlength'], DefaultValue))\n    else:\n        BsfFd.write('    %s%s%4d bytes    $_DEFAULT_ = %s\\n' % (Line, ' ' * (64 - len(Line)), Item['length'], DefaultValue))\n    TmpList = []\n    if Item['type'] == 'Combo':\n        if not Item['option'] in self._BuidinOption:\n            OptList = Item['option'].split(',')\n            for Option in OptList:\n                Option = Option.strip()\n                (OpVal, OpStr) = Option.split(':')\n                test = LogExpr.getNumber(OpVal)\n                if test is None:\n                    raise Exception(\"Selection Index '%s' is not a number\" % OpVal)\n                TmpList.append((OpVal, OpStr))\n    return TmpList",
            "def WriteBsfStruct(self, BsfFd, Item):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    LogExpr = CLogicalExpression()\n    if Item['type'] == 'None':\n        Space = 'gPlatformFspPkgTokenSpaceGuid'\n    else:\n        Space = Item['space']\n    Line = '    $%s_%s' % (Space, Item['cname'])\n    Match = re.match('\\\\s*\\\\{([x0-9a-fA-F,\\\\s]+)\\\\}\\\\s*', Item['value'])\n    if Match:\n        DefaultValue = Match.group(1).strip()\n    else:\n        DefaultValue = Item['value'].strip()\n    if 'bitlength' in Item:\n        BsfFd.write('    %s%s%4d bits     $_DEFAULT_ = %s\\n' % (Line, ' ' * (64 - len(Line)), Item['bitlength'], DefaultValue))\n    else:\n        BsfFd.write('    %s%s%4d bytes    $_DEFAULT_ = %s\\n' % (Line, ' ' * (64 - len(Line)), Item['length'], DefaultValue))\n    TmpList = []\n    if Item['type'] == 'Combo':\n        if not Item['option'] in self._BuidinOption:\n            OptList = Item['option'].split(',')\n            for Option in OptList:\n                Option = Option.strip()\n                (OpVal, OpStr) = Option.split(':')\n                test = LogExpr.getNumber(OpVal)\n                if test is None:\n                    raise Exception(\"Selection Index '%s' is not a number\" % OpVal)\n                TmpList.append((OpVal, OpStr))\n    return TmpList",
            "def WriteBsfStruct(self, BsfFd, Item):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    LogExpr = CLogicalExpression()\n    if Item['type'] == 'None':\n        Space = 'gPlatformFspPkgTokenSpaceGuid'\n    else:\n        Space = Item['space']\n    Line = '    $%s_%s' % (Space, Item['cname'])\n    Match = re.match('\\\\s*\\\\{([x0-9a-fA-F,\\\\s]+)\\\\}\\\\s*', Item['value'])\n    if Match:\n        DefaultValue = Match.group(1).strip()\n    else:\n        DefaultValue = Item['value'].strip()\n    if 'bitlength' in Item:\n        BsfFd.write('    %s%s%4d bits     $_DEFAULT_ = %s\\n' % (Line, ' ' * (64 - len(Line)), Item['bitlength'], DefaultValue))\n    else:\n        BsfFd.write('    %s%s%4d bytes    $_DEFAULT_ = %s\\n' % (Line, ' ' * (64 - len(Line)), Item['length'], DefaultValue))\n    TmpList = []\n    if Item['type'] == 'Combo':\n        if not Item['option'] in self._BuidinOption:\n            OptList = Item['option'].split(',')\n            for Option in OptList:\n                Option = Option.strip()\n                (OpVal, OpStr) = Option.split(':')\n                test = LogExpr.getNumber(OpVal)\n                if test is None:\n                    raise Exception(\"Selection Index '%s' is not a number\" % OpVal)\n                TmpList.append((OpVal, OpStr))\n    return TmpList"
        ]
    },
    {
        "func_name": "WriteBsfOption",
        "original": "def WriteBsfOption(self, BsfFd, Item):\n    PcdName = Item['space'] + '_' + Item['cname']\n    WriteHelp = 0\n    if Item['type'] == 'Combo':\n        if Item['option'] in self._BuidinOption:\n            Options = self._BuidinOption[Item['option']]\n        else:\n            Options = PcdName\n        BsfFd.write('    %s $%s, \"%s\", &%s,\\n' % (Item['type'], PcdName, Item['name'], Options))\n        WriteHelp = 1\n    elif Item['type'].startswith('EditNum'):\n        Match = re.match('EditNum\\\\s*,\\\\s*(HEX|DEC)\\\\s*,\\\\s*\\\\((\\\\d+|0x[0-9A-Fa-f]+)\\\\s*,\\\\s*(\\\\d+|0x[0-9A-Fa-f]+)\\\\)', Item['type'])\n        if Match:\n            BsfFd.write('    EditNum $%s, \"%s\", %s,\\n' % (PcdName, Item['name'], Match.group(1)))\n            WriteHelp = 2\n    elif Item['type'].startswith('EditText'):\n        BsfFd.write('    %s $%s, \"%s\",\\n' % (Item['type'], PcdName, Item['name']))\n        WriteHelp = 1\n    elif Item['type'] == 'Table':\n        Columns = Item['option'].split(',')\n        if len(Columns) != 0:\n            BsfFd.write('    %s $%s \"%s\",' % (Item['type'], PcdName, Item['name']))\n            for Col in Columns:\n                Fmt = Col.split(':')\n                if len(Fmt) != 3:\n                    raise Exception(\"Column format '%s' is invalid !\" % Fmt)\n                try:\n                    Dtype = int(Fmt[1].strip())\n                except:\n                    raise Exception(\"Column size '%s' is invalid !\" % Fmt[1])\n                BsfFd.write('\\n        Column \"%s\", %d bytes, %s' % (Fmt[0].strip(), Dtype, Fmt[2].strip()))\n            BsfFd.write(',\\n')\n            WriteHelp = 1\n    if WriteHelp > 0:\n        HelpLines = Item['help'].split('\\\\n\\\\r')\n        FirstLine = True\n        for HelpLine in HelpLines:\n            if FirstLine:\n                FirstLine = False\n                BsfFd.write('        Help \"%s\"\\n' % HelpLine)\n            else:\n                BsfFd.write('             \"%s\"\\n' % HelpLine)\n        if WriteHelp == 2:\n            BsfFd.write('             \"Valid range: %s ~ %s\"\\n' % (Match.group(2), Match.group(3)))",
        "mutated": [
            "def WriteBsfOption(self, BsfFd, Item):\n    if False:\n        i = 10\n    PcdName = Item['space'] + '_' + Item['cname']\n    WriteHelp = 0\n    if Item['type'] == 'Combo':\n        if Item['option'] in self._BuidinOption:\n            Options = self._BuidinOption[Item['option']]\n        else:\n            Options = PcdName\n        BsfFd.write('    %s $%s, \"%s\", &%s,\\n' % (Item['type'], PcdName, Item['name'], Options))\n        WriteHelp = 1\n    elif Item['type'].startswith('EditNum'):\n        Match = re.match('EditNum\\\\s*,\\\\s*(HEX|DEC)\\\\s*,\\\\s*\\\\((\\\\d+|0x[0-9A-Fa-f]+)\\\\s*,\\\\s*(\\\\d+|0x[0-9A-Fa-f]+)\\\\)', Item['type'])\n        if Match:\n            BsfFd.write('    EditNum $%s, \"%s\", %s,\\n' % (PcdName, Item['name'], Match.group(1)))\n            WriteHelp = 2\n    elif Item['type'].startswith('EditText'):\n        BsfFd.write('    %s $%s, \"%s\",\\n' % (Item['type'], PcdName, Item['name']))\n        WriteHelp = 1\n    elif Item['type'] == 'Table':\n        Columns = Item['option'].split(',')\n        if len(Columns) != 0:\n            BsfFd.write('    %s $%s \"%s\",' % (Item['type'], PcdName, Item['name']))\n            for Col in Columns:\n                Fmt = Col.split(':')\n                if len(Fmt) != 3:\n                    raise Exception(\"Column format '%s' is invalid !\" % Fmt)\n                try:\n                    Dtype = int(Fmt[1].strip())\n                except:\n                    raise Exception(\"Column size '%s' is invalid !\" % Fmt[1])\n                BsfFd.write('\\n        Column \"%s\", %d bytes, %s' % (Fmt[0].strip(), Dtype, Fmt[2].strip()))\n            BsfFd.write(',\\n')\n            WriteHelp = 1\n    if WriteHelp > 0:\n        HelpLines = Item['help'].split('\\\\n\\\\r')\n        FirstLine = True\n        for HelpLine in HelpLines:\n            if FirstLine:\n                FirstLine = False\n                BsfFd.write('        Help \"%s\"\\n' % HelpLine)\n            else:\n                BsfFd.write('             \"%s\"\\n' % HelpLine)\n        if WriteHelp == 2:\n            BsfFd.write('             \"Valid range: %s ~ %s\"\\n' % (Match.group(2), Match.group(3)))",
            "def WriteBsfOption(self, BsfFd, Item):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    PcdName = Item['space'] + '_' + Item['cname']\n    WriteHelp = 0\n    if Item['type'] == 'Combo':\n        if Item['option'] in self._BuidinOption:\n            Options = self._BuidinOption[Item['option']]\n        else:\n            Options = PcdName\n        BsfFd.write('    %s $%s, \"%s\", &%s,\\n' % (Item['type'], PcdName, Item['name'], Options))\n        WriteHelp = 1\n    elif Item['type'].startswith('EditNum'):\n        Match = re.match('EditNum\\\\s*,\\\\s*(HEX|DEC)\\\\s*,\\\\s*\\\\((\\\\d+|0x[0-9A-Fa-f]+)\\\\s*,\\\\s*(\\\\d+|0x[0-9A-Fa-f]+)\\\\)', Item['type'])\n        if Match:\n            BsfFd.write('    EditNum $%s, \"%s\", %s,\\n' % (PcdName, Item['name'], Match.group(1)))\n            WriteHelp = 2\n    elif Item['type'].startswith('EditText'):\n        BsfFd.write('    %s $%s, \"%s\",\\n' % (Item['type'], PcdName, Item['name']))\n        WriteHelp = 1\n    elif Item['type'] == 'Table':\n        Columns = Item['option'].split(',')\n        if len(Columns) != 0:\n            BsfFd.write('    %s $%s \"%s\",' % (Item['type'], PcdName, Item['name']))\n            for Col in Columns:\n                Fmt = Col.split(':')\n                if len(Fmt) != 3:\n                    raise Exception(\"Column format '%s' is invalid !\" % Fmt)\n                try:\n                    Dtype = int(Fmt[1].strip())\n                except:\n                    raise Exception(\"Column size '%s' is invalid !\" % Fmt[1])\n                BsfFd.write('\\n        Column \"%s\", %d bytes, %s' % (Fmt[0].strip(), Dtype, Fmt[2].strip()))\n            BsfFd.write(',\\n')\n            WriteHelp = 1\n    if WriteHelp > 0:\n        HelpLines = Item['help'].split('\\\\n\\\\r')\n        FirstLine = True\n        for HelpLine in HelpLines:\n            if FirstLine:\n                FirstLine = False\n                BsfFd.write('        Help \"%s\"\\n' % HelpLine)\n            else:\n                BsfFd.write('             \"%s\"\\n' % HelpLine)\n        if WriteHelp == 2:\n            BsfFd.write('             \"Valid range: %s ~ %s\"\\n' % (Match.group(2), Match.group(3)))",
            "def WriteBsfOption(self, BsfFd, Item):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    PcdName = Item['space'] + '_' + Item['cname']\n    WriteHelp = 0\n    if Item['type'] == 'Combo':\n        if Item['option'] in self._BuidinOption:\n            Options = self._BuidinOption[Item['option']]\n        else:\n            Options = PcdName\n        BsfFd.write('    %s $%s, \"%s\", &%s,\\n' % (Item['type'], PcdName, Item['name'], Options))\n        WriteHelp = 1\n    elif Item['type'].startswith('EditNum'):\n        Match = re.match('EditNum\\\\s*,\\\\s*(HEX|DEC)\\\\s*,\\\\s*\\\\((\\\\d+|0x[0-9A-Fa-f]+)\\\\s*,\\\\s*(\\\\d+|0x[0-9A-Fa-f]+)\\\\)', Item['type'])\n        if Match:\n            BsfFd.write('    EditNum $%s, \"%s\", %s,\\n' % (PcdName, Item['name'], Match.group(1)))\n            WriteHelp = 2\n    elif Item['type'].startswith('EditText'):\n        BsfFd.write('    %s $%s, \"%s\",\\n' % (Item['type'], PcdName, Item['name']))\n        WriteHelp = 1\n    elif Item['type'] == 'Table':\n        Columns = Item['option'].split(',')\n        if len(Columns) != 0:\n            BsfFd.write('    %s $%s \"%s\",' % (Item['type'], PcdName, Item['name']))\n            for Col in Columns:\n                Fmt = Col.split(':')\n                if len(Fmt) != 3:\n                    raise Exception(\"Column format '%s' is invalid !\" % Fmt)\n                try:\n                    Dtype = int(Fmt[1].strip())\n                except:\n                    raise Exception(\"Column size '%s' is invalid !\" % Fmt[1])\n                BsfFd.write('\\n        Column \"%s\", %d bytes, %s' % (Fmt[0].strip(), Dtype, Fmt[2].strip()))\n            BsfFd.write(',\\n')\n            WriteHelp = 1\n    if WriteHelp > 0:\n        HelpLines = Item['help'].split('\\\\n\\\\r')\n        FirstLine = True\n        for HelpLine in HelpLines:\n            if FirstLine:\n                FirstLine = False\n                BsfFd.write('        Help \"%s\"\\n' % HelpLine)\n            else:\n                BsfFd.write('             \"%s\"\\n' % HelpLine)\n        if WriteHelp == 2:\n            BsfFd.write('             \"Valid range: %s ~ %s\"\\n' % (Match.group(2), Match.group(3)))",
            "def WriteBsfOption(self, BsfFd, Item):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    PcdName = Item['space'] + '_' + Item['cname']\n    WriteHelp = 0\n    if Item['type'] == 'Combo':\n        if Item['option'] in self._BuidinOption:\n            Options = self._BuidinOption[Item['option']]\n        else:\n            Options = PcdName\n        BsfFd.write('    %s $%s, \"%s\", &%s,\\n' % (Item['type'], PcdName, Item['name'], Options))\n        WriteHelp = 1\n    elif Item['type'].startswith('EditNum'):\n        Match = re.match('EditNum\\\\s*,\\\\s*(HEX|DEC)\\\\s*,\\\\s*\\\\((\\\\d+|0x[0-9A-Fa-f]+)\\\\s*,\\\\s*(\\\\d+|0x[0-9A-Fa-f]+)\\\\)', Item['type'])\n        if Match:\n            BsfFd.write('    EditNum $%s, \"%s\", %s,\\n' % (PcdName, Item['name'], Match.group(1)))\n            WriteHelp = 2\n    elif Item['type'].startswith('EditText'):\n        BsfFd.write('    %s $%s, \"%s\",\\n' % (Item['type'], PcdName, Item['name']))\n        WriteHelp = 1\n    elif Item['type'] == 'Table':\n        Columns = Item['option'].split(',')\n        if len(Columns) != 0:\n            BsfFd.write('    %s $%s \"%s\",' % (Item['type'], PcdName, Item['name']))\n            for Col in Columns:\n                Fmt = Col.split(':')\n                if len(Fmt) != 3:\n                    raise Exception(\"Column format '%s' is invalid !\" % Fmt)\n                try:\n                    Dtype = int(Fmt[1].strip())\n                except:\n                    raise Exception(\"Column size '%s' is invalid !\" % Fmt[1])\n                BsfFd.write('\\n        Column \"%s\", %d bytes, %s' % (Fmt[0].strip(), Dtype, Fmt[2].strip()))\n            BsfFd.write(',\\n')\n            WriteHelp = 1\n    if WriteHelp > 0:\n        HelpLines = Item['help'].split('\\\\n\\\\r')\n        FirstLine = True\n        for HelpLine in HelpLines:\n            if FirstLine:\n                FirstLine = False\n                BsfFd.write('        Help \"%s\"\\n' % HelpLine)\n            else:\n                BsfFd.write('             \"%s\"\\n' % HelpLine)\n        if WriteHelp == 2:\n            BsfFd.write('             \"Valid range: %s ~ %s\"\\n' % (Match.group(2), Match.group(3)))",
            "def WriteBsfOption(self, BsfFd, Item):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    PcdName = Item['space'] + '_' + Item['cname']\n    WriteHelp = 0\n    if Item['type'] == 'Combo':\n        if Item['option'] in self._BuidinOption:\n            Options = self._BuidinOption[Item['option']]\n        else:\n            Options = PcdName\n        BsfFd.write('    %s $%s, \"%s\", &%s,\\n' % (Item['type'], PcdName, Item['name'], Options))\n        WriteHelp = 1\n    elif Item['type'].startswith('EditNum'):\n        Match = re.match('EditNum\\\\s*,\\\\s*(HEX|DEC)\\\\s*,\\\\s*\\\\((\\\\d+|0x[0-9A-Fa-f]+)\\\\s*,\\\\s*(\\\\d+|0x[0-9A-Fa-f]+)\\\\)', Item['type'])\n        if Match:\n            BsfFd.write('    EditNum $%s, \"%s\", %s,\\n' % (PcdName, Item['name'], Match.group(1)))\n            WriteHelp = 2\n    elif Item['type'].startswith('EditText'):\n        BsfFd.write('    %s $%s, \"%s\",\\n' % (Item['type'], PcdName, Item['name']))\n        WriteHelp = 1\n    elif Item['type'] == 'Table':\n        Columns = Item['option'].split(',')\n        if len(Columns) != 0:\n            BsfFd.write('    %s $%s \"%s\",' % (Item['type'], PcdName, Item['name']))\n            for Col in Columns:\n                Fmt = Col.split(':')\n                if len(Fmt) != 3:\n                    raise Exception(\"Column format '%s' is invalid !\" % Fmt)\n                try:\n                    Dtype = int(Fmt[1].strip())\n                except:\n                    raise Exception(\"Column size '%s' is invalid !\" % Fmt[1])\n                BsfFd.write('\\n        Column \"%s\", %d bytes, %s' % (Fmt[0].strip(), Dtype, Fmt[2].strip()))\n            BsfFd.write(',\\n')\n            WriteHelp = 1\n    if WriteHelp > 0:\n        HelpLines = Item['help'].split('\\\\n\\\\r')\n        FirstLine = True\n        for HelpLine in HelpLines:\n            if FirstLine:\n                FirstLine = False\n                BsfFd.write('        Help \"%s\"\\n' % HelpLine)\n            else:\n                BsfFd.write('             \"%s\"\\n' % HelpLine)\n        if WriteHelp == 2:\n            BsfFd.write('             \"Valid range: %s ~ %s\"\\n' % (Match.group(2), Match.group(3)))"
        ]
    },
    {
        "func_name": "GenerateBsfFile",
        "original": "def GenerateBsfFile(self, BsfFile):\n    if BsfFile == '':\n        self.Error = \"BSF output file '%s' is invalid\" % BsfFile\n        return 1\n    if self.NoDscFileChange(BsfFile):\n        self.Error = 'No DSC file change, skip to create UPD BSF file'\n        return 256\n    Error = 0\n    OptionDict = {}\n    BsfFd = open(BsfFile, 'w')\n    BsfFd.write('%s\\n' % (__copyright_bsf__ % date.today().year))\n    BsfFd.write('%s\\n' % self._GlobalDataDef)\n    BsfFd.write('StructDef\\n')\n    NextOffset = -1\n    for Item in self._CfgItemList:\n        if Item['find'] != '':\n            BsfFd.write('\\n    Find \"%s\"\\n' % Item['find'])\n            NextOffset = Item['offset'] + Item['length']\n        if Item['name'] != '':\n            if NextOffset != Item['offset']:\n                BsfFd.write('        Skip %d bytes\\n' % (Item['offset'] - NextOffset))\n            if len(Item['subreg']) > 0:\n                NextOffset = Item['offset']\n                BitsOffset = NextOffset * 8\n                for SubItem in Item['subreg']:\n                    BitsOffset += SubItem['bitlength']\n                    if SubItem['name'] == '':\n                        if 'bitlength' in SubItem:\n                            BsfFd.write('        Skip %d bits\\n' % SubItem['bitlength'])\n                        else:\n                            BsfFd.write('        Skip %d bytes\\n' % SubItem['length'])\n                    else:\n                        Options = self.WriteBsfStruct(BsfFd, SubItem)\n                        if len(Options) > 0:\n                            OptionDict[SubItem['space'] + '_' + SubItem['cname']] = Options\n                NextBitsOffset = (Item['offset'] + Item['length']) * 8\n                if NextBitsOffset > BitsOffset:\n                    BitsGap = NextBitsOffset - BitsOffset\n                    BitsRemain = BitsGap % 8\n                    if BitsRemain:\n                        BsfFd.write('        Skip %d bits\\n' % BitsRemain)\n                        BitsGap -= BitsRemain\n                    BytesRemain = int(BitsGap / 8)\n                    if BytesRemain:\n                        BsfFd.write('        Skip %d bytes\\n' % BytesRemain)\n                NextOffset = Item['offset'] + Item['length']\n            else:\n                NextOffset = Item['offset'] + Item['length']\n                Options = self.WriteBsfStruct(BsfFd, Item)\n                if len(Options) > 0:\n                    OptionDict[Item['space'] + '_' + Item['cname']] = Options\n    BsfFd.write('\\nEndStruct\\n\\n')\n    BsfFd.write('%s' % self._BuidinOptionTxt)\n    for Each in OptionDict:\n        BsfFd.write('List &%s\\n' % Each)\n        for Item in OptionDict[Each]:\n            BsfFd.write('    Selection %s , \"%s\"\\n' % (Item[0], Item[1]))\n        BsfFd.write('EndList\\n\\n')\n    BsfFd.write('BeginInfoBlock\\n')\n    BsfFd.write('    PPVer       \"%s\"\\n' % self._CfgBlkDict['ver'])\n    BsfFd.write('    Description \"%s\"\\n' % self._CfgBlkDict['name'])\n    BsfFd.write('EndInfoBlock\\n\\n')\n    for Each in self._CfgPageDict:\n        BsfFd.write('Page \"%s\"\\n' % self._CfgPageDict[Each])\n        BsfItems = []\n        for Item in self._CfgItemList:\n            if Item['name'] != '':\n                if Item['page'] != Each:\n                    continue\n                if len(Item['subreg']) > 0:\n                    for SubItem in Item['subreg']:\n                        if SubItem['name'] != '':\n                            BsfItems.append(SubItem)\n                else:\n                    BsfItems.append(Item)\n        BsfItems.sort(key=lambda x: x['order'])\n        for Item in BsfItems:\n            self.WriteBsfOption(BsfFd, Item)\n        BsfFd.write('EndPage\\n\\n')\n    BsfFd.close()\n    return Error",
        "mutated": [
            "def GenerateBsfFile(self, BsfFile):\n    if False:\n        i = 10\n    if BsfFile == '':\n        self.Error = \"BSF output file '%s' is invalid\" % BsfFile\n        return 1\n    if self.NoDscFileChange(BsfFile):\n        self.Error = 'No DSC file change, skip to create UPD BSF file'\n        return 256\n    Error = 0\n    OptionDict = {}\n    BsfFd = open(BsfFile, 'w')\n    BsfFd.write('%s\\n' % (__copyright_bsf__ % date.today().year))\n    BsfFd.write('%s\\n' % self._GlobalDataDef)\n    BsfFd.write('StructDef\\n')\n    NextOffset = -1\n    for Item in self._CfgItemList:\n        if Item['find'] != '':\n            BsfFd.write('\\n    Find \"%s\"\\n' % Item['find'])\n            NextOffset = Item['offset'] + Item['length']\n        if Item['name'] != '':\n            if NextOffset != Item['offset']:\n                BsfFd.write('        Skip %d bytes\\n' % (Item['offset'] - NextOffset))\n            if len(Item['subreg']) > 0:\n                NextOffset = Item['offset']\n                BitsOffset = NextOffset * 8\n                for SubItem in Item['subreg']:\n                    BitsOffset += SubItem['bitlength']\n                    if SubItem['name'] == '':\n                        if 'bitlength' in SubItem:\n                            BsfFd.write('        Skip %d bits\\n' % SubItem['bitlength'])\n                        else:\n                            BsfFd.write('        Skip %d bytes\\n' % SubItem['length'])\n                    else:\n                        Options = self.WriteBsfStruct(BsfFd, SubItem)\n                        if len(Options) > 0:\n                            OptionDict[SubItem['space'] + '_' + SubItem['cname']] = Options\n                NextBitsOffset = (Item['offset'] + Item['length']) * 8\n                if NextBitsOffset > BitsOffset:\n                    BitsGap = NextBitsOffset - BitsOffset\n                    BitsRemain = BitsGap % 8\n                    if BitsRemain:\n                        BsfFd.write('        Skip %d bits\\n' % BitsRemain)\n                        BitsGap -= BitsRemain\n                    BytesRemain = int(BitsGap / 8)\n                    if BytesRemain:\n                        BsfFd.write('        Skip %d bytes\\n' % BytesRemain)\n                NextOffset = Item['offset'] + Item['length']\n            else:\n                NextOffset = Item['offset'] + Item['length']\n                Options = self.WriteBsfStruct(BsfFd, Item)\n                if len(Options) > 0:\n                    OptionDict[Item['space'] + '_' + Item['cname']] = Options\n    BsfFd.write('\\nEndStruct\\n\\n')\n    BsfFd.write('%s' % self._BuidinOptionTxt)\n    for Each in OptionDict:\n        BsfFd.write('List &%s\\n' % Each)\n        for Item in OptionDict[Each]:\n            BsfFd.write('    Selection %s , \"%s\"\\n' % (Item[0], Item[1]))\n        BsfFd.write('EndList\\n\\n')\n    BsfFd.write('BeginInfoBlock\\n')\n    BsfFd.write('    PPVer       \"%s\"\\n' % self._CfgBlkDict['ver'])\n    BsfFd.write('    Description \"%s\"\\n' % self._CfgBlkDict['name'])\n    BsfFd.write('EndInfoBlock\\n\\n')\n    for Each in self._CfgPageDict:\n        BsfFd.write('Page \"%s\"\\n' % self._CfgPageDict[Each])\n        BsfItems = []\n        for Item in self._CfgItemList:\n            if Item['name'] != '':\n                if Item['page'] != Each:\n                    continue\n                if len(Item['subreg']) > 0:\n                    for SubItem in Item['subreg']:\n                        if SubItem['name'] != '':\n                            BsfItems.append(SubItem)\n                else:\n                    BsfItems.append(Item)\n        BsfItems.sort(key=lambda x: x['order'])\n        for Item in BsfItems:\n            self.WriteBsfOption(BsfFd, Item)\n        BsfFd.write('EndPage\\n\\n')\n    BsfFd.close()\n    return Error",
            "def GenerateBsfFile(self, BsfFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if BsfFile == '':\n        self.Error = \"BSF output file '%s' is invalid\" % BsfFile\n        return 1\n    if self.NoDscFileChange(BsfFile):\n        self.Error = 'No DSC file change, skip to create UPD BSF file'\n        return 256\n    Error = 0\n    OptionDict = {}\n    BsfFd = open(BsfFile, 'w')\n    BsfFd.write('%s\\n' % (__copyright_bsf__ % date.today().year))\n    BsfFd.write('%s\\n' % self._GlobalDataDef)\n    BsfFd.write('StructDef\\n')\n    NextOffset = -1\n    for Item in self._CfgItemList:\n        if Item['find'] != '':\n            BsfFd.write('\\n    Find \"%s\"\\n' % Item['find'])\n            NextOffset = Item['offset'] + Item['length']\n        if Item['name'] != '':\n            if NextOffset != Item['offset']:\n                BsfFd.write('        Skip %d bytes\\n' % (Item['offset'] - NextOffset))\n            if len(Item['subreg']) > 0:\n                NextOffset = Item['offset']\n                BitsOffset = NextOffset * 8\n                for SubItem in Item['subreg']:\n                    BitsOffset += SubItem['bitlength']\n                    if SubItem['name'] == '':\n                        if 'bitlength' in SubItem:\n                            BsfFd.write('        Skip %d bits\\n' % SubItem['bitlength'])\n                        else:\n                            BsfFd.write('        Skip %d bytes\\n' % SubItem['length'])\n                    else:\n                        Options = self.WriteBsfStruct(BsfFd, SubItem)\n                        if len(Options) > 0:\n                            OptionDict[SubItem['space'] + '_' + SubItem['cname']] = Options\n                NextBitsOffset = (Item['offset'] + Item['length']) * 8\n                if NextBitsOffset > BitsOffset:\n                    BitsGap = NextBitsOffset - BitsOffset\n                    BitsRemain = BitsGap % 8\n                    if BitsRemain:\n                        BsfFd.write('        Skip %d bits\\n' % BitsRemain)\n                        BitsGap -= BitsRemain\n                    BytesRemain = int(BitsGap / 8)\n                    if BytesRemain:\n                        BsfFd.write('        Skip %d bytes\\n' % BytesRemain)\n                NextOffset = Item['offset'] + Item['length']\n            else:\n                NextOffset = Item['offset'] + Item['length']\n                Options = self.WriteBsfStruct(BsfFd, Item)\n                if len(Options) > 0:\n                    OptionDict[Item['space'] + '_' + Item['cname']] = Options\n    BsfFd.write('\\nEndStruct\\n\\n')\n    BsfFd.write('%s' % self._BuidinOptionTxt)\n    for Each in OptionDict:\n        BsfFd.write('List &%s\\n' % Each)\n        for Item in OptionDict[Each]:\n            BsfFd.write('    Selection %s , \"%s\"\\n' % (Item[0], Item[1]))\n        BsfFd.write('EndList\\n\\n')\n    BsfFd.write('BeginInfoBlock\\n')\n    BsfFd.write('    PPVer       \"%s\"\\n' % self._CfgBlkDict['ver'])\n    BsfFd.write('    Description \"%s\"\\n' % self._CfgBlkDict['name'])\n    BsfFd.write('EndInfoBlock\\n\\n')\n    for Each in self._CfgPageDict:\n        BsfFd.write('Page \"%s\"\\n' % self._CfgPageDict[Each])\n        BsfItems = []\n        for Item in self._CfgItemList:\n            if Item['name'] != '':\n                if Item['page'] != Each:\n                    continue\n                if len(Item['subreg']) > 0:\n                    for SubItem in Item['subreg']:\n                        if SubItem['name'] != '':\n                            BsfItems.append(SubItem)\n                else:\n                    BsfItems.append(Item)\n        BsfItems.sort(key=lambda x: x['order'])\n        for Item in BsfItems:\n            self.WriteBsfOption(BsfFd, Item)\n        BsfFd.write('EndPage\\n\\n')\n    BsfFd.close()\n    return Error",
            "def GenerateBsfFile(self, BsfFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if BsfFile == '':\n        self.Error = \"BSF output file '%s' is invalid\" % BsfFile\n        return 1\n    if self.NoDscFileChange(BsfFile):\n        self.Error = 'No DSC file change, skip to create UPD BSF file'\n        return 256\n    Error = 0\n    OptionDict = {}\n    BsfFd = open(BsfFile, 'w')\n    BsfFd.write('%s\\n' % (__copyright_bsf__ % date.today().year))\n    BsfFd.write('%s\\n' % self._GlobalDataDef)\n    BsfFd.write('StructDef\\n')\n    NextOffset = -1\n    for Item in self._CfgItemList:\n        if Item['find'] != '':\n            BsfFd.write('\\n    Find \"%s\"\\n' % Item['find'])\n            NextOffset = Item['offset'] + Item['length']\n        if Item['name'] != '':\n            if NextOffset != Item['offset']:\n                BsfFd.write('        Skip %d bytes\\n' % (Item['offset'] - NextOffset))\n            if len(Item['subreg']) > 0:\n                NextOffset = Item['offset']\n                BitsOffset = NextOffset * 8\n                for SubItem in Item['subreg']:\n                    BitsOffset += SubItem['bitlength']\n                    if SubItem['name'] == '':\n                        if 'bitlength' in SubItem:\n                            BsfFd.write('        Skip %d bits\\n' % SubItem['bitlength'])\n                        else:\n                            BsfFd.write('        Skip %d bytes\\n' % SubItem['length'])\n                    else:\n                        Options = self.WriteBsfStruct(BsfFd, SubItem)\n                        if len(Options) > 0:\n                            OptionDict[SubItem['space'] + '_' + SubItem['cname']] = Options\n                NextBitsOffset = (Item['offset'] + Item['length']) * 8\n                if NextBitsOffset > BitsOffset:\n                    BitsGap = NextBitsOffset - BitsOffset\n                    BitsRemain = BitsGap % 8\n                    if BitsRemain:\n                        BsfFd.write('        Skip %d bits\\n' % BitsRemain)\n                        BitsGap -= BitsRemain\n                    BytesRemain = int(BitsGap / 8)\n                    if BytesRemain:\n                        BsfFd.write('        Skip %d bytes\\n' % BytesRemain)\n                NextOffset = Item['offset'] + Item['length']\n            else:\n                NextOffset = Item['offset'] + Item['length']\n                Options = self.WriteBsfStruct(BsfFd, Item)\n                if len(Options) > 0:\n                    OptionDict[Item['space'] + '_' + Item['cname']] = Options\n    BsfFd.write('\\nEndStruct\\n\\n')\n    BsfFd.write('%s' % self._BuidinOptionTxt)\n    for Each in OptionDict:\n        BsfFd.write('List &%s\\n' % Each)\n        for Item in OptionDict[Each]:\n            BsfFd.write('    Selection %s , \"%s\"\\n' % (Item[0], Item[1]))\n        BsfFd.write('EndList\\n\\n')\n    BsfFd.write('BeginInfoBlock\\n')\n    BsfFd.write('    PPVer       \"%s\"\\n' % self._CfgBlkDict['ver'])\n    BsfFd.write('    Description \"%s\"\\n' % self._CfgBlkDict['name'])\n    BsfFd.write('EndInfoBlock\\n\\n')\n    for Each in self._CfgPageDict:\n        BsfFd.write('Page \"%s\"\\n' % self._CfgPageDict[Each])\n        BsfItems = []\n        for Item in self._CfgItemList:\n            if Item['name'] != '':\n                if Item['page'] != Each:\n                    continue\n                if len(Item['subreg']) > 0:\n                    for SubItem in Item['subreg']:\n                        if SubItem['name'] != '':\n                            BsfItems.append(SubItem)\n                else:\n                    BsfItems.append(Item)\n        BsfItems.sort(key=lambda x: x['order'])\n        for Item in BsfItems:\n            self.WriteBsfOption(BsfFd, Item)\n        BsfFd.write('EndPage\\n\\n')\n    BsfFd.close()\n    return Error",
            "def GenerateBsfFile(self, BsfFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if BsfFile == '':\n        self.Error = \"BSF output file '%s' is invalid\" % BsfFile\n        return 1\n    if self.NoDscFileChange(BsfFile):\n        self.Error = 'No DSC file change, skip to create UPD BSF file'\n        return 256\n    Error = 0\n    OptionDict = {}\n    BsfFd = open(BsfFile, 'w')\n    BsfFd.write('%s\\n' % (__copyright_bsf__ % date.today().year))\n    BsfFd.write('%s\\n' % self._GlobalDataDef)\n    BsfFd.write('StructDef\\n')\n    NextOffset = -1\n    for Item in self._CfgItemList:\n        if Item['find'] != '':\n            BsfFd.write('\\n    Find \"%s\"\\n' % Item['find'])\n            NextOffset = Item['offset'] + Item['length']\n        if Item['name'] != '':\n            if NextOffset != Item['offset']:\n                BsfFd.write('        Skip %d bytes\\n' % (Item['offset'] - NextOffset))\n            if len(Item['subreg']) > 0:\n                NextOffset = Item['offset']\n                BitsOffset = NextOffset * 8\n                for SubItem in Item['subreg']:\n                    BitsOffset += SubItem['bitlength']\n                    if SubItem['name'] == '':\n                        if 'bitlength' in SubItem:\n                            BsfFd.write('        Skip %d bits\\n' % SubItem['bitlength'])\n                        else:\n                            BsfFd.write('        Skip %d bytes\\n' % SubItem['length'])\n                    else:\n                        Options = self.WriteBsfStruct(BsfFd, SubItem)\n                        if len(Options) > 0:\n                            OptionDict[SubItem['space'] + '_' + SubItem['cname']] = Options\n                NextBitsOffset = (Item['offset'] + Item['length']) * 8\n                if NextBitsOffset > BitsOffset:\n                    BitsGap = NextBitsOffset - BitsOffset\n                    BitsRemain = BitsGap % 8\n                    if BitsRemain:\n                        BsfFd.write('        Skip %d bits\\n' % BitsRemain)\n                        BitsGap -= BitsRemain\n                    BytesRemain = int(BitsGap / 8)\n                    if BytesRemain:\n                        BsfFd.write('        Skip %d bytes\\n' % BytesRemain)\n                NextOffset = Item['offset'] + Item['length']\n            else:\n                NextOffset = Item['offset'] + Item['length']\n                Options = self.WriteBsfStruct(BsfFd, Item)\n                if len(Options) > 0:\n                    OptionDict[Item['space'] + '_' + Item['cname']] = Options\n    BsfFd.write('\\nEndStruct\\n\\n')\n    BsfFd.write('%s' % self._BuidinOptionTxt)\n    for Each in OptionDict:\n        BsfFd.write('List &%s\\n' % Each)\n        for Item in OptionDict[Each]:\n            BsfFd.write('    Selection %s , \"%s\"\\n' % (Item[0], Item[1]))\n        BsfFd.write('EndList\\n\\n')\n    BsfFd.write('BeginInfoBlock\\n')\n    BsfFd.write('    PPVer       \"%s\"\\n' % self._CfgBlkDict['ver'])\n    BsfFd.write('    Description \"%s\"\\n' % self._CfgBlkDict['name'])\n    BsfFd.write('EndInfoBlock\\n\\n')\n    for Each in self._CfgPageDict:\n        BsfFd.write('Page \"%s\"\\n' % self._CfgPageDict[Each])\n        BsfItems = []\n        for Item in self._CfgItemList:\n            if Item['name'] != '':\n                if Item['page'] != Each:\n                    continue\n                if len(Item['subreg']) > 0:\n                    for SubItem in Item['subreg']:\n                        if SubItem['name'] != '':\n                            BsfItems.append(SubItem)\n                else:\n                    BsfItems.append(Item)\n        BsfItems.sort(key=lambda x: x['order'])\n        for Item in BsfItems:\n            self.WriteBsfOption(BsfFd, Item)\n        BsfFd.write('EndPage\\n\\n')\n    BsfFd.close()\n    return Error",
            "def GenerateBsfFile(self, BsfFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if BsfFile == '':\n        self.Error = \"BSF output file '%s' is invalid\" % BsfFile\n        return 1\n    if self.NoDscFileChange(BsfFile):\n        self.Error = 'No DSC file change, skip to create UPD BSF file'\n        return 256\n    Error = 0\n    OptionDict = {}\n    BsfFd = open(BsfFile, 'w')\n    BsfFd.write('%s\\n' % (__copyright_bsf__ % date.today().year))\n    BsfFd.write('%s\\n' % self._GlobalDataDef)\n    BsfFd.write('StructDef\\n')\n    NextOffset = -1\n    for Item in self._CfgItemList:\n        if Item['find'] != '':\n            BsfFd.write('\\n    Find \"%s\"\\n' % Item['find'])\n            NextOffset = Item['offset'] + Item['length']\n        if Item['name'] != '':\n            if NextOffset != Item['offset']:\n                BsfFd.write('        Skip %d bytes\\n' % (Item['offset'] - NextOffset))\n            if len(Item['subreg']) > 0:\n                NextOffset = Item['offset']\n                BitsOffset = NextOffset * 8\n                for SubItem in Item['subreg']:\n                    BitsOffset += SubItem['bitlength']\n                    if SubItem['name'] == '':\n                        if 'bitlength' in SubItem:\n                            BsfFd.write('        Skip %d bits\\n' % SubItem['bitlength'])\n                        else:\n                            BsfFd.write('        Skip %d bytes\\n' % SubItem['length'])\n                    else:\n                        Options = self.WriteBsfStruct(BsfFd, SubItem)\n                        if len(Options) > 0:\n                            OptionDict[SubItem['space'] + '_' + SubItem['cname']] = Options\n                NextBitsOffset = (Item['offset'] + Item['length']) * 8\n                if NextBitsOffset > BitsOffset:\n                    BitsGap = NextBitsOffset - BitsOffset\n                    BitsRemain = BitsGap % 8\n                    if BitsRemain:\n                        BsfFd.write('        Skip %d bits\\n' % BitsRemain)\n                        BitsGap -= BitsRemain\n                    BytesRemain = int(BitsGap / 8)\n                    if BytesRemain:\n                        BsfFd.write('        Skip %d bytes\\n' % BytesRemain)\n                NextOffset = Item['offset'] + Item['length']\n            else:\n                NextOffset = Item['offset'] + Item['length']\n                Options = self.WriteBsfStruct(BsfFd, Item)\n                if len(Options) > 0:\n                    OptionDict[Item['space'] + '_' + Item['cname']] = Options\n    BsfFd.write('\\nEndStruct\\n\\n')\n    BsfFd.write('%s' % self._BuidinOptionTxt)\n    for Each in OptionDict:\n        BsfFd.write('List &%s\\n' % Each)\n        for Item in OptionDict[Each]:\n            BsfFd.write('    Selection %s , \"%s\"\\n' % (Item[0], Item[1]))\n        BsfFd.write('EndList\\n\\n')\n    BsfFd.write('BeginInfoBlock\\n')\n    BsfFd.write('    PPVer       \"%s\"\\n' % self._CfgBlkDict['ver'])\n    BsfFd.write('    Description \"%s\"\\n' % self._CfgBlkDict['name'])\n    BsfFd.write('EndInfoBlock\\n\\n')\n    for Each in self._CfgPageDict:\n        BsfFd.write('Page \"%s\"\\n' % self._CfgPageDict[Each])\n        BsfItems = []\n        for Item in self._CfgItemList:\n            if Item['name'] != '':\n                if Item['page'] != Each:\n                    continue\n                if len(Item['subreg']) > 0:\n                    for SubItem in Item['subreg']:\n                        if SubItem['name'] != '':\n                            BsfItems.append(SubItem)\n                else:\n                    BsfItems.append(Item)\n        BsfItems.sort(key=lambda x: x['order'])\n        for Item in BsfItems:\n            self.WriteBsfOption(BsfFd, Item)\n        BsfFd.write('EndPage\\n\\n')\n    BsfFd.close()\n    return Error"
        ]
    },
    {
        "func_name": "Usage",
        "original": "def Usage():\n    print('GenCfgOpt Version 0.59')\n    print('Usage:')\n    print('    GenCfgOpt  UPDTXT  PlatformDscFile BuildFvDir                 [-D Macros]')\n    print('    GenCfgOpt  HEADER  PlatformDscFile BuildFvDir  InputHFile     [-D Macros]')\n    print('    GenCfgOpt  GENBSF  PlatformDscFile BuildFvDir  BsfOutFile     [-D Macros]')",
        "mutated": [
            "def Usage():\n    if False:\n        i = 10\n    print('GenCfgOpt Version 0.59')\n    print('Usage:')\n    print('    GenCfgOpt  UPDTXT  PlatformDscFile BuildFvDir                 [-D Macros]')\n    print('    GenCfgOpt  HEADER  PlatformDscFile BuildFvDir  InputHFile     [-D Macros]')\n    print('    GenCfgOpt  GENBSF  PlatformDscFile BuildFvDir  BsfOutFile     [-D Macros]')",
            "def Usage():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('GenCfgOpt Version 0.59')\n    print('Usage:')\n    print('    GenCfgOpt  UPDTXT  PlatformDscFile BuildFvDir                 [-D Macros]')\n    print('    GenCfgOpt  HEADER  PlatformDscFile BuildFvDir  InputHFile     [-D Macros]')\n    print('    GenCfgOpt  GENBSF  PlatformDscFile BuildFvDir  BsfOutFile     [-D Macros]')",
            "def Usage():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('GenCfgOpt Version 0.59')\n    print('Usage:')\n    print('    GenCfgOpt  UPDTXT  PlatformDscFile BuildFvDir                 [-D Macros]')\n    print('    GenCfgOpt  HEADER  PlatformDscFile BuildFvDir  InputHFile     [-D Macros]')\n    print('    GenCfgOpt  GENBSF  PlatformDscFile BuildFvDir  BsfOutFile     [-D Macros]')",
            "def Usage():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('GenCfgOpt Version 0.59')\n    print('Usage:')\n    print('    GenCfgOpt  UPDTXT  PlatformDscFile BuildFvDir                 [-D Macros]')\n    print('    GenCfgOpt  HEADER  PlatformDscFile BuildFvDir  InputHFile     [-D Macros]')\n    print('    GenCfgOpt  GENBSF  PlatformDscFile BuildFvDir  BsfOutFile     [-D Macros]')",
            "def Usage():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('GenCfgOpt Version 0.59')\n    print('Usage:')\n    print('    GenCfgOpt  UPDTXT  PlatformDscFile BuildFvDir                 [-D Macros]')\n    print('    GenCfgOpt  HEADER  PlatformDscFile BuildFvDir  InputHFile     [-D Macros]')\n    print('    GenCfgOpt  GENBSF  PlatformDscFile BuildFvDir  BsfOutFile     [-D Macros]')"
        ]
    },
    {
        "func_name": "Main",
        "original": "def Main():\n    i = 1\n    GenCfgOpt = CGenCfgOpt()\n    while i < len(sys.argv):\n        if sys.argv[i].strip().lower() == '--pcd':\n            BuildOptionPcd.append(sys.argv[i + 1])\n            i += 1\n        i += 1\n    argc = len(sys.argv)\n    if argc < 4:\n        Usage()\n        return 1\n    else:\n        DscFile = sys.argv[2]\n        if not os.path.exists(DscFile):\n            print(\"ERROR: Cannot open DSC file '%s' !\" % DscFile)\n            return 2\n        OutFile = ''\n        if argc > 4:\n            if sys.argv[4][0] == '-':\n                Start = 4\n            else:\n                OutFile = sys.argv[4]\n                Start = 5\n            if argc > Start:\n                if GenCfgOpt.ParseMacros(sys.argv[Start:]) != 0:\n                    print('ERROR: Macro parsing failed !')\n                    return 3\n        FvDir = sys.argv[3]\n        if not os.path.exists(FvDir):\n            os.makedirs(FvDir)\n        if GenCfgOpt.ParseDscFile(DscFile, FvDir) != 0:\n            print('ERROR: %s !' % GenCfgOpt.Error)\n            return 5\n        if GenCfgOpt.UpdateSubRegionDefaultValue() != 0:\n            print('ERROR: %s !' % GenCfgOpt.Error)\n            return 7\n        if sys.argv[1] == 'UPDTXT':\n            Ret = GenCfgOpt.CreateSplitUpdTxt(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n            return Ret\n        elif sys.argv[1] == 'HEADER':\n            Ret = GenCfgOpt.CreateHeaderFile(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n                    return 8\n            return Ret\n        elif sys.argv[1] == 'GENBSF':\n            Ret = GenCfgOpt.GenerateBsfFile(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n                    return 9\n            return Ret\n        else:\n            if argc < 5:\n                Usage()\n                return 1\n            print(\"ERROR: Unknown command '%s' !\" % sys.argv[1])\n            Usage()\n            return 1\n        return 0\n    return 0",
        "mutated": [
            "def Main():\n    if False:\n        i = 10\n    i = 1\n    GenCfgOpt = CGenCfgOpt()\n    while i < len(sys.argv):\n        if sys.argv[i].strip().lower() == '--pcd':\n            BuildOptionPcd.append(sys.argv[i + 1])\n            i += 1\n        i += 1\n    argc = len(sys.argv)\n    if argc < 4:\n        Usage()\n        return 1\n    else:\n        DscFile = sys.argv[2]\n        if not os.path.exists(DscFile):\n            print(\"ERROR: Cannot open DSC file '%s' !\" % DscFile)\n            return 2\n        OutFile = ''\n        if argc > 4:\n            if sys.argv[4][0] == '-':\n                Start = 4\n            else:\n                OutFile = sys.argv[4]\n                Start = 5\n            if argc > Start:\n                if GenCfgOpt.ParseMacros(sys.argv[Start:]) != 0:\n                    print('ERROR: Macro parsing failed !')\n                    return 3\n        FvDir = sys.argv[3]\n        if not os.path.exists(FvDir):\n            os.makedirs(FvDir)\n        if GenCfgOpt.ParseDscFile(DscFile, FvDir) != 0:\n            print('ERROR: %s !' % GenCfgOpt.Error)\n            return 5\n        if GenCfgOpt.UpdateSubRegionDefaultValue() != 0:\n            print('ERROR: %s !' % GenCfgOpt.Error)\n            return 7\n        if sys.argv[1] == 'UPDTXT':\n            Ret = GenCfgOpt.CreateSplitUpdTxt(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n            return Ret\n        elif sys.argv[1] == 'HEADER':\n            Ret = GenCfgOpt.CreateHeaderFile(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n                    return 8\n            return Ret\n        elif sys.argv[1] == 'GENBSF':\n            Ret = GenCfgOpt.GenerateBsfFile(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n                    return 9\n            return Ret\n        else:\n            if argc < 5:\n                Usage()\n                return 1\n            print(\"ERROR: Unknown command '%s' !\" % sys.argv[1])\n            Usage()\n            return 1\n        return 0\n    return 0",
            "def Main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    i = 1\n    GenCfgOpt = CGenCfgOpt()\n    while i < len(sys.argv):\n        if sys.argv[i].strip().lower() == '--pcd':\n            BuildOptionPcd.append(sys.argv[i + 1])\n            i += 1\n        i += 1\n    argc = len(sys.argv)\n    if argc < 4:\n        Usage()\n        return 1\n    else:\n        DscFile = sys.argv[2]\n        if not os.path.exists(DscFile):\n            print(\"ERROR: Cannot open DSC file '%s' !\" % DscFile)\n            return 2\n        OutFile = ''\n        if argc > 4:\n            if sys.argv[4][0] == '-':\n                Start = 4\n            else:\n                OutFile = sys.argv[4]\n                Start = 5\n            if argc > Start:\n                if GenCfgOpt.ParseMacros(sys.argv[Start:]) != 0:\n                    print('ERROR: Macro parsing failed !')\n                    return 3\n        FvDir = sys.argv[3]\n        if not os.path.exists(FvDir):\n            os.makedirs(FvDir)\n        if GenCfgOpt.ParseDscFile(DscFile, FvDir) != 0:\n            print('ERROR: %s !' % GenCfgOpt.Error)\n            return 5\n        if GenCfgOpt.UpdateSubRegionDefaultValue() != 0:\n            print('ERROR: %s !' % GenCfgOpt.Error)\n            return 7\n        if sys.argv[1] == 'UPDTXT':\n            Ret = GenCfgOpt.CreateSplitUpdTxt(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n            return Ret\n        elif sys.argv[1] == 'HEADER':\n            Ret = GenCfgOpt.CreateHeaderFile(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n                    return 8\n            return Ret\n        elif sys.argv[1] == 'GENBSF':\n            Ret = GenCfgOpt.GenerateBsfFile(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n                    return 9\n            return Ret\n        else:\n            if argc < 5:\n                Usage()\n                return 1\n            print(\"ERROR: Unknown command '%s' !\" % sys.argv[1])\n            Usage()\n            return 1\n        return 0\n    return 0",
            "def Main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    i = 1\n    GenCfgOpt = CGenCfgOpt()\n    while i < len(sys.argv):\n        if sys.argv[i].strip().lower() == '--pcd':\n            BuildOptionPcd.append(sys.argv[i + 1])\n            i += 1\n        i += 1\n    argc = len(sys.argv)\n    if argc < 4:\n        Usage()\n        return 1\n    else:\n        DscFile = sys.argv[2]\n        if not os.path.exists(DscFile):\n            print(\"ERROR: Cannot open DSC file '%s' !\" % DscFile)\n            return 2\n        OutFile = ''\n        if argc > 4:\n            if sys.argv[4][0] == '-':\n                Start = 4\n            else:\n                OutFile = sys.argv[4]\n                Start = 5\n            if argc > Start:\n                if GenCfgOpt.ParseMacros(sys.argv[Start:]) != 0:\n                    print('ERROR: Macro parsing failed !')\n                    return 3\n        FvDir = sys.argv[3]\n        if not os.path.exists(FvDir):\n            os.makedirs(FvDir)\n        if GenCfgOpt.ParseDscFile(DscFile, FvDir) != 0:\n            print('ERROR: %s !' % GenCfgOpt.Error)\n            return 5\n        if GenCfgOpt.UpdateSubRegionDefaultValue() != 0:\n            print('ERROR: %s !' % GenCfgOpt.Error)\n            return 7\n        if sys.argv[1] == 'UPDTXT':\n            Ret = GenCfgOpt.CreateSplitUpdTxt(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n            return Ret\n        elif sys.argv[1] == 'HEADER':\n            Ret = GenCfgOpt.CreateHeaderFile(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n                    return 8\n            return Ret\n        elif sys.argv[1] == 'GENBSF':\n            Ret = GenCfgOpt.GenerateBsfFile(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n                    return 9\n            return Ret\n        else:\n            if argc < 5:\n                Usage()\n                return 1\n            print(\"ERROR: Unknown command '%s' !\" % sys.argv[1])\n            Usage()\n            return 1\n        return 0\n    return 0",
            "def Main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    i = 1\n    GenCfgOpt = CGenCfgOpt()\n    while i < len(sys.argv):\n        if sys.argv[i].strip().lower() == '--pcd':\n            BuildOptionPcd.append(sys.argv[i + 1])\n            i += 1\n        i += 1\n    argc = len(sys.argv)\n    if argc < 4:\n        Usage()\n        return 1\n    else:\n        DscFile = sys.argv[2]\n        if not os.path.exists(DscFile):\n            print(\"ERROR: Cannot open DSC file '%s' !\" % DscFile)\n            return 2\n        OutFile = ''\n        if argc > 4:\n            if sys.argv[4][0] == '-':\n                Start = 4\n            else:\n                OutFile = sys.argv[4]\n                Start = 5\n            if argc > Start:\n                if GenCfgOpt.ParseMacros(sys.argv[Start:]) != 0:\n                    print('ERROR: Macro parsing failed !')\n                    return 3\n        FvDir = sys.argv[3]\n        if not os.path.exists(FvDir):\n            os.makedirs(FvDir)\n        if GenCfgOpt.ParseDscFile(DscFile, FvDir) != 0:\n            print('ERROR: %s !' % GenCfgOpt.Error)\n            return 5\n        if GenCfgOpt.UpdateSubRegionDefaultValue() != 0:\n            print('ERROR: %s !' % GenCfgOpt.Error)\n            return 7\n        if sys.argv[1] == 'UPDTXT':\n            Ret = GenCfgOpt.CreateSplitUpdTxt(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n            return Ret\n        elif sys.argv[1] == 'HEADER':\n            Ret = GenCfgOpt.CreateHeaderFile(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n                    return 8\n            return Ret\n        elif sys.argv[1] == 'GENBSF':\n            Ret = GenCfgOpt.GenerateBsfFile(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n                    return 9\n            return Ret\n        else:\n            if argc < 5:\n                Usage()\n                return 1\n            print(\"ERROR: Unknown command '%s' !\" % sys.argv[1])\n            Usage()\n            return 1\n        return 0\n    return 0",
            "def Main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    i = 1\n    GenCfgOpt = CGenCfgOpt()\n    while i < len(sys.argv):\n        if sys.argv[i].strip().lower() == '--pcd':\n            BuildOptionPcd.append(sys.argv[i + 1])\n            i += 1\n        i += 1\n    argc = len(sys.argv)\n    if argc < 4:\n        Usage()\n        return 1\n    else:\n        DscFile = sys.argv[2]\n        if not os.path.exists(DscFile):\n            print(\"ERROR: Cannot open DSC file '%s' !\" % DscFile)\n            return 2\n        OutFile = ''\n        if argc > 4:\n            if sys.argv[4][0] == '-':\n                Start = 4\n            else:\n                OutFile = sys.argv[4]\n                Start = 5\n            if argc > Start:\n                if GenCfgOpt.ParseMacros(sys.argv[Start:]) != 0:\n                    print('ERROR: Macro parsing failed !')\n                    return 3\n        FvDir = sys.argv[3]\n        if not os.path.exists(FvDir):\n            os.makedirs(FvDir)\n        if GenCfgOpt.ParseDscFile(DscFile, FvDir) != 0:\n            print('ERROR: %s !' % GenCfgOpt.Error)\n            return 5\n        if GenCfgOpt.UpdateSubRegionDefaultValue() != 0:\n            print('ERROR: %s !' % GenCfgOpt.Error)\n            return 7\n        if sys.argv[1] == 'UPDTXT':\n            Ret = GenCfgOpt.CreateSplitUpdTxt(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n            return Ret\n        elif sys.argv[1] == 'HEADER':\n            Ret = GenCfgOpt.CreateHeaderFile(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n                    return 8\n            return Ret\n        elif sys.argv[1] == 'GENBSF':\n            Ret = GenCfgOpt.GenerateBsfFile(OutFile)\n            if Ret != 0:\n                if Ret == 256:\n                    print('INFO: %s !' % GenCfgOpt.Error)\n                else:\n                    print('ERROR: %s !' % GenCfgOpt.Error)\n                    return 9\n            return Ret\n        else:\n            if argc < 5:\n                Usage()\n                return 1\n            print(\"ERROR: Unknown command '%s' !\" % sys.argv[1])\n            Usage()\n            return 1\n        return 0\n    return 0"
        ]
    }
]