import base64
import numpy as np
from . import _marching_cubes_lewiner_luts as mcluts
from . import _marching_cubes_lewiner_cy

def marching_cubes(volume, level=None, *, spacing=(1.0, 1.0, 1.0), gradient_direction='descent', step_size=1, allow_degenerate=True, method='lewiner', mask=None):
    if False:
        while True:
            i = 10
    "Marching cubes algorithm to find surfaces in 3d volumetric data.\n\n    In contrast with Lorensen et al. approach [2]_, Lewiner et\n    al. algorithm is faster, resolves ambiguities, and guarantees\n    topologically correct results. Therefore, this algorithm generally\n    a better choice.\n\n    Parameters\n    ----------\n    volume : (M, N, P) ndarray\n        Input data volume to find isosurfaces. Will internally be\n        converted to float32 if necessary.\n    level : float, optional\n        Contour value to search for isosurfaces in `volume`. If not\n        given or None, the average of the min and max of vol is used.\n    spacing : length-3 tuple of floats, optional\n        Voxel spacing in spatial dimensions corresponding to numpy array\n        indexing dimensions (M, N, P) as in `volume`.\n    gradient_direction : string, optional\n        Controls if the mesh was generated from an isosurface with gradient\n        descent toward objects of interest (the default), or the opposite,\n        considering the *left-hand* rule.\n        The two options are:\n        * descent : Object was greater than exterior\n        * ascent : Exterior was greater than object\n    step_size : int, optional\n        Step size in voxels. Default 1. Larger steps yield faster but\n        coarser results. The result will always be topologically correct\n        though.\n    allow_degenerate : bool, optional\n        Whether to allow degenerate (i.e. zero-area) triangles in the\n        end-result. Default True. If False, degenerate triangles are\n        removed, at the cost of making the algorithm slower.\n    method: {'lewiner', 'lorensen'}, optional\n        Whether the method of Lewiner et al. or Lorensen et al. will be used.\n    mask : (M, N, P) array, optional\n        Boolean array. The marching cube algorithm will be computed only on\n        True elements. This will save computational time when interfaces\n        are located within certain region of the volume M, N, P-e.g. the top\n        half of the cube-and also allow to compute finite surfaces-i.e. open\n        surfaces that do not end at the border of the cube.\n\n    Returns\n    -------\n    verts : (V, 3) array\n        Spatial coordinates for V unique mesh vertices. Coordinate order\n        matches input `volume` (M, N, P). If ``allow_degenerate`` is set to\n        True, then the presence of degenerate triangles in the mesh can make\n        this array have duplicate vertices.\n    faces : (F, 3) array\n        Define triangular faces via referencing vertex indices from ``verts``.\n        This algorithm specifically outputs triangles, so each face has\n        exactly three indices.\n    normals : (V, 3) array\n        The normal direction at each vertex, as calculated from the\n        data.\n    values : (V,) array\n        Gives a measure for the maximum value of the data in the local region\n        near each vertex. This can be used by visualization tools to apply\n        a colormap to the mesh.\n\n    See Also\n    --------\n    skimage.measure.mesh_surface_area\n    skimage.measure.find_contours\n\n    Notes\n    -----\n    The algorithm [1]_ is an improved version of Chernyaev's Marching\n    Cubes 33 algorithm. It is an efficient algorithm that relies on\n    heavy use of lookup tables to handle the many different cases,\n    keeping the algorithm relatively easy. This implementation is\n    written in Cython, ported from Lewiner's C++ implementation.\n\n    To quantify the area of an isosurface generated by this algorithm, pass\n    verts and faces to `skimage.measure.mesh_surface_area`.\n\n    Regarding visualization of algorithm output, to contour a volume\n    named `myvolume` about the level 0.0, using the ``mayavi`` package::\n\n      >>>\n      >> from mayavi import mlab\n      >> verts, faces, _, _ = marching_cubes(myvolume, 0.0)\n      >> mlab.triangular_mesh([vert[0] for vert in verts],\n                              [vert[1] for vert in verts],\n                              [vert[2] for vert in verts],\n                              faces)\n      >> mlab.show()\n\n    Similarly using the ``visvis`` package::\n\n      >>>\n      >> import visvis as vv\n      >> verts, faces, normals, values = marching_cubes(myvolume, 0.0)\n      >> vv.mesh(np.fliplr(verts), faces, normals, values)\n      >> vv.use().Run()\n\n    To reduce the number of triangles in the mesh for better performance,\n    see this `example\n    <https://docs.enthought.com/mayavi/mayavi/auto/example_julia_set_decimation.html#example-julia-set-decimation>`_\n    using the ``mayavi`` package.\n\n    References\n    ----------\n    .. [1] Thomas Lewiner, Helio Lopes, Antonio Wilson Vieira and Geovan\n           Tavares. Efficient implementation of Marching Cubes' cases with\n           topological guarantees. Journal of Graphics Tools 8(2)\n           pp. 1-15 (december 2003).\n           :DOI:`10.1080/10867651.2003.10487582`\n    .. [2] Lorensen, William and Harvey E. Cline. Marching Cubes: A High\n           Resolution 3D Surface Construction Algorithm. Computer Graphics\n           (SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170).\n           :DOI:`10.1145/37401.37422`\n    "
    use_classic = False
    if method == 'lorensen':
        use_classic = True
    elif method != 'lewiner':
        raise ValueError("method should be either 'lewiner' or 'lorensen'")
    return _marching_cubes_lewiner(volume, level, spacing, gradient_direction, step_size, allow_degenerate, use_classic=use_classic, mask=mask)

def _marching_cubes_lewiner(volume, level, spacing, gradient_direction, step_size, allow_degenerate, use_classic, mask):
    if False:
        i = 10
        return i + 15
    'Lewiner et al. algorithm for marching cubes. See\n    marching_cubes_lewiner for documentation.\n\n    '
    if not isinstance(volume, np.ndarray) or volume.ndim != 3:
        raise ValueError('Input volume should be a 3D numpy array.')
    if volume.shape[0] < 2 or volume.shape[1] < 2 or volume.shape[2] < 2:
        raise ValueError('Input array must be at least 2x2x2.')
    volume = np.ascontiguousarray(volume, np.float32)
    if level is None:
        level = 0.5 * (volume.min() + volume.max())
    else:
        level = float(level)
        if level < volume.min() or level > volume.max():
            raise ValueError('Surface level must be within volume data range.')
    if len(spacing) != 3:
        raise ValueError('`spacing` must consist of three floats.')
    step_size = int(step_size)
    if step_size < 1:
        raise ValueError('step_size must be at least one.')
    use_classic = bool(use_classic)
    L = _get_mc_luts()
    if mask is not None:
        if not mask.shape == volume.shape:
            raise ValueError('volume and mask must have the same shape.')
    func = _marching_cubes_lewiner_cy.marching_cubes
    (vertices, faces, normals, values) = func(volume, level, L, step_size, use_classic, mask)
    if not len(vertices):
        raise RuntimeError('No surface found at the given iso value.')
    vertices = np.fliplr(vertices)
    normals = np.fliplr(normals)
    faces.shape = (-1, 3)
    if gradient_direction == 'descent':
        faces = np.fliplr(faces)
    elif not gradient_direction == 'ascent':
        raise ValueError(f'Incorrect input {gradient_direction} in `gradient_direction`, see docstring.')
    if not np.array_equal(spacing, (1, 1, 1)):
        vertices = vertices * np.r_[spacing]
    if allow_degenerate:
        return (vertices, faces, normals, values)
    else:
        fun = _marching_cubes_lewiner_cy.remove_degenerate_faces
        return fun(vertices.astype(np.float32), faces, normals, values)

def _to_array(args):
    if False:
        i = 10
        return i + 15
    (shape, text) = args
    byts = base64.decodebytes(text.encode('utf-8'))
    ar = np.frombuffer(byts, dtype='int8')
    ar.shape = shape
    return ar
EDGETORELATIVEPOSX = np.array([[0, 1], [1, 1], [1, 0], [0, 0], [0, 1], [1, 1], [1, 0], [0, 0], [0, 0], [1, 1], [1, 1], [0, 0]], 'int8')
EDGETORELATIVEPOSY = np.array([[0, 0], [0, 1], [1, 1], [1, 0], [0, 0], [0, 1], [1, 1], [1, 0], [0, 0], [0, 0], [1, 1], [1, 1]], 'int8')
EDGETORELATIVEPOSZ = np.array([[0, 0], [0, 0], [0, 0], [0, 0], [1, 1], [1, 1], [1, 1], [1, 1], [0, 1], [0, 1], [0, 1], [0, 1]], 'int8')

def _get_mc_luts():
    if False:
        return 10
    'Kind of lazy obtaining of the luts.'
    if not hasattr(mcluts, 'THE_LUTS'):
        mcluts.THE_LUTS = _marching_cubes_lewiner_cy.LutProvider(EDGETORELATIVEPOSX, EDGETORELATIVEPOSY, EDGETORELATIVEPOSZ, _to_array(mcluts.CASESCLASSIC), _to_array(mcluts.CASES), _to_array(mcluts.TILING1), _to_array(mcluts.TILING2), _to_array(mcluts.TILING3_1), _to_array(mcluts.TILING3_2), _to_array(mcluts.TILING4_1), _to_array(mcluts.TILING4_2), _to_array(mcluts.TILING5), _to_array(mcluts.TILING6_1_1), _to_array(mcluts.TILING6_1_2), _to_array(mcluts.TILING6_2), _to_array(mcluts.TILING7_1), _to_array(mcluts.TILING7_2), _to_array(mcluts.TILING7_3), _to_array(mcluts.TILING7_4_1), _to_array(mcluts.TILING7_4_2), _to_array(mcluts.TILING8), _to_array(mcluts.TILING9), _to_array(mcluts.TILING10_1_1), _to_array(mcluts.TILING10_1_1_), _to_array(mcluts.TILING10_1_2), _to_array(mcluts.TILING10_2), _to_array(mcluts.TILING10_2_), _to_array(mcluts.TILING11), _to_array(mcluts.TILING12_1_1), _to_array(mcluts.TILING12_1_1_), _to_array(mcluts.TILING12_1_2), _to_array(mcluts.TILING12_2), _to_array(mcluts.TILING12_2_), _to_array(mcluts.TILING13_1), _to_array(mcluts.TILING13_1_), _to_array(mcluts.TILING13_2), _to_array(mcluts.TILING13_2_), _to_array(mcluts.TILING13_3), _to_array(mcluts.TILING13_3_), _to_array(mcluts.TILING13_4), _to_array(mcluts.TILING13_5_1), _to_array(mcluts.TILING13_5_2), _to_array(mcluts.TILING14), _to_array(mcluts.TEST3), _to_array(mcluts.TEST4), _to_array(mcluts.TEST6), _to_array(mcluts.TEST7), _to_array(mcluts.TEST10), _to_array(mcluts.TEST12), _to_array(mcluts.TEST13), _to_array(mcluts.SUBCONFIG13))
    return mcluts.THE_LUTS

def mesh_surface_area(verts, faces):
    if False:
        while True:
            i = 10
    'Compute surface area, given vertices and triangular faces.\n\n    Parameters\n    ----------\n    verts : (V, 3) array of floats\n        Array containing coordinates for V unique mesh vertices.\n    faces : (F, 3) array of ints\n        List of length-3 lists of integers, referencing vertex coordinates as\n        provided in `verts`.\n\n    Returns\n    -------\n    area : float\n        Surface area of mesh. Units now [coordinate units] ** 2.\n\n    Notes\n    -----\n    The arguments expected by this function are the first two outputs from\n    `skimage.measure.marching_cubes`. For unit correct output, ensure correct\n    `spacing` was passed to `skimage.measure.marching_cubes`.\n\n    This algorithm works properly only if the ``faces`` provided are all\n    triangles.\n\n    See Also\n    --------\n    skimage.measure.marching_cubes\n\n    '
    actual_verts = verts[faces]
    a = actual_verts[:, 0, :] - actual_verts[:, 1, :]
    b = actual_verts[:, 0, :] - actual_verts[:, 2, :]
    del actual_verts
    return ((np.cross(a, b) ** 2).sum(axis=1) ** 0.5).sum() / 2.0