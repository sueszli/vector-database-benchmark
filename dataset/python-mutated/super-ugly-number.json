[
    {
        "func_name": "nthSuperUglyNumber",
        "original": "def nthSuperUglyNumber(self, n, primes):\n    \"\"\"\n        :type n: int\n        :type primes: List[int]\n        :rtype: int\n        \"\"\"\n    (heap, uglies, idx, ugly_by_last_prime) = ([], [0] * n, [0] * len(primes), [0] * n)\n    uglies[0] = 1\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n    for i in xrange(1, n):\n        (uglies[i], k) = heapq.heappop(heap)\n        ugly_by_last_prime[i] = k\n        idx[k] += 1\n        while ugly_by_last_prime[idx[k]] > k:\n            idx[k] += 1\n        heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n    return uglies[-1]",
        "mutated": [
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    (heap, uglies, idx, ugly_by_last_prime) = ([], [0] * n, [0] * len(primes), [0] * n)\n    uglies[0] = 1\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n    for i in xrange(1, n):\n        (uglies[i], k) = heapq.heappop(heap)\n        ugly_by_last_prime[i] = k\n        idx[k] += 1\n        while ugly_by_last_prime[idx[k]] > k:\n            idx[k] += 1\n        heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    (heap, uglies, idx, ugly_by_last_prime) = ([], [0] * n, [0] * len(primes), [0] * n)\n    uglies[0] = 1\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n    for i in xrange(1, n):\n        (uglies[i], k) = heapq.heappop(heap)\n        ugly_by_last_prime[i] = k\n        idx[k] += 1\n        while ugly_by_last_prime[idx[k]] > k:\n            idx[k] += 1\n        heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    (heap, uglies, idx, ugly_by_last_prime) = ([], [0] * n, [0] * len(primes), [0] * n)\n    uglies[0] = 1\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n    for i in xrange(1, n):\n        (uglies[i], k) = heapq.heappop(heap)\n        ugly_by_last_prime[i] = k\n        idx[k] += 1\n        while ugly_by_last_prime[idx[k]] > k:\n            idx[k] += 1\n        heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    (heap, uglies, idx, ugly_by_last_prime) = ([], [0] * n, [0] * len(primes), [0] * n)\n    uglies[0] = 1\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n    for i in xrange(1, n):\n        (uglies[i], k) = heapq.heappop(heap)\n        ugly_by_last_prime[i] = k\n        idx[k] += 1\n        while ugly_by_last_prime[idx[k]] > k:\n            idx[k] += 1\n        heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    (heap, uglies, idx, ugly_by_last_prime) = ([], [0] * n, [0] * len(primes), [0] * n)\n    uglies[0] = 1\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n    for i in xrange(1, n):\n        (uglies[i], k) = heapq.heappop(heap)\n        ugly_by_last_prime[i] = k\n        idx[k] += 1\n        while ugly_by_last_prime[idx[k]] > k:\n            idx[k] += 1\n        heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n    return uglies[-1]"
        ]
    },
    {
        "func_name": "nthSuperUglyNumber",
        "original": "def nthSuperUglyNumber(self, n, primes):\n    \"\"\"\n        :type n: int\n        :type primes: List[int]\n        :rtype: int\n        \"\"\"\n    (uglies, idx, heap, ugly_set) = ([0] * n, [0] * len(primes), [], set([1]))\n    uglies[0] = 1\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n        ugly_set.add(p)\n    for i in xrange(1, n):\n        (uglies[i], k) = heapq.heappop(heap)\n        while primes[k] * uglies[idx[k]] in ugly_set:\n            idx[k] += 1\n        heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n        ugly_set.add(primes[k] * uglies[idx[k]])\n    return uglies[-1]",
        "mutated": [
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    (uglies, idx, heap, ugly_set) = ([0] * n, [0] * len(primes), [], set([1]))\n    uglies[0] = 1\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n        ugly_set.add(p)\n    for i in xrange(1, n):\n        (uglies[i], k) = heapq.heappop(heap)\n        while primes[k] * uglies[idx[k]] in ugly_set:\n            idx[k] += 1\n        heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n        ugly_set.add(primes[k] * uglies[idx[k]])\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    (uglies, idx, heap, ugly_set) = ([0] * n, [0] * len(primes), [], set([1]))\n    uglies[0] = 1\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n        ugly_set.add(p)\n    for i in xrange(1, n):\n        (uglies[i], k) = heapq.heappop(heap)\n        while primes[k] * uglies[idx[k]] in ugly_set:\n            idx[k] += 1\n        heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n        ugly_set.add(primes[k] * uglies[idx[k]])\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    (uglies, idx, heap, ugly_set) = ([0] * n, [0] * len(primes), [], set([1]))\n    uglies[0] = 1\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n        ugly_set.add(p)\n    for i in xrange(1, n):\n        (uglies[i], k) = heapq.heappop(heap)\n        while primes[k] * uglies[idx[k]] in ugly_set:\n            idx[k] += 1\n        heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n        ugly_set.add(primes[k] * uglies[idx[k]])\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    (uglies, idx, heap, ugly_set) = ([0] * n, [0] * len(primes), [], set([1]))\n    uglies[0] = 1\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n        ugly_set.add(p)\n    for i in xrange(1, n):\n        (uglies[i], k) = heapq.heappop(heap)\n        while primes[k] * uglies[idx[k]] in ugly_set:\n            idx[k] += 1\n        heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n        ugly_set.add(primes[k] * uglies[idx[k]])\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    (uglies, idx, heap, ugly_set) = ([0] * n, [0] * len(primes), [], set([1]))\n    uglies[0] = 1\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n        ugly_set.add(p)\n    for i in xrange(1, n):\n        (uglies[i], k) = heapq.heappop(heap)\n        while primes[k] * uglies[idx[k]] in ugly_set:\n            idx[k] += 1\n        heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n        ugly_set.add(primes[k] * uglies[idx[k]])\n    return uglies[-1]"
        ]
    },
    {
        "func_name": "nthSuperUglyNumber",
        "original": "def nthSuperUglyNumber(self, n, primes):\n    \"\"\"\n        :type n: int\n        :type primes: List[int]\n        :rtype: int\n        \"\"\"\n    (uglies, idx, heap) = ([1], [0] * len(primes), [])\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n    for i in xrange(1, n):\n        (min_val, k) = heap[0]\n        uglies += [min_val]\n        while heap[0][0] == min_val:\n            (min_val, k) = heapq.heappop(heap)\n            idx[k] += 1\n            heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n    return uglies[-1]",
        "mutated": [
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    (uglies, idx, heap) = ([1], [0] * len(primes), [])\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n    for i in xrange(1, n):\n        (min_val, k) = heap[0]\n        uglies += [min_val]\n        while heap[0][0] == min_val:\n            (min_val, k) = heapq.heappop(heap)\n            idx[k] += 1\n            heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    (uglies, idx, heap) = ([1], [0] * len(primes), [])\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n    for i in xrange(1, n):\n        (min_val, k) = heap[0]\n        uglies += [min_val]\n        while heap[0][0] == min_val:\n            (min_val, k) = heapq.heappop(heap)\n            idx[k] += 1\n            heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    (uglies, idx, heap) = ([1], [0] * len(primes), [])\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n    for i in xrange(1, n):\n        (min_val, k) = heap[0]\n        uglies += [min_val]\n        while heap[0][0] == min_val:\n            (min_val, k) = heapq.heappop(heap)\n            idx[k] += 1\n            heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    (uglies, idx, heap) = ([1], [0] * len(primes), [])\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n    for i in xrange(1, n):\n        (min_val, k) = heap[0]\n        uglies += [min_val]\n        while heap[0][0] == min_val:\n            (min_val, k) = heapq.heappop(heap)\n            idx[k] += 1\n            heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    (uglies, idx, heap) = ([1], [0] * len(primes), [])\n    for (k, p) in enumerate(primes):\n        heapq.heappush(heap, (p, k))\n    for i in xrange(1, n):\n        (min_val, k) = heap[0]\n        uglies += [min_val]\n        while heap[0][0] == min_val:\n            (min_val, k) = heapq.heappop(heap)\n            idx[k] += 1\n            heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n    return uglies[-1]"
        ]
    },
    {
        "func_name": "nthSuperUglyNumber",
        "original": "def nthSuperUglyNumber(self, n, primes):\n    \"\"\"\n        :type n: int\n        :type primes: List[int]\n        :rtype: int\n        \"\"\"\n    uglies = [0] * n\n    uglies[0] = 1\n    ugly_by_prime = list(primes)\n    idx = [0] * len(primes)\n    for i in xrange(1, n):\n        uglies[i] = min(ugly_by_prime)\n        for k in xrange(len(primes)):\n            if uglies[i] == ugly_by_prime[k]:\n                idx[k] += 1\n                ugly_by_prime[k] = primes[k] * uglies[idx[k]]\n    return uglies[-1]",
        "mutated": [
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    uglies = [0] * n\n    uglies[0] = 1\n    ugly_by_prime = list(primes)\n    idx = [0] * len(primes)\n    for i in xrange(1, n):\n        uglies[i] = min(ugly_by_prime)\n        for k in xrange(len(primes)):\n            if uglies[i] == ugly_by_prime[k]:\n                idx[k] += 1\n                ugly_by_prime[k] = primes[k] * uglies[idx[k]]\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    uglies = [0] * n\n    uglies[0] = 1\n    ugly_by_prime = list(primes)\n    idx = [0] * len(primes)\n    for i in xrange(1, n):\n        uglies[i] = min(ugly_by_prime)\n        for k in xrange(len(primes)):\n            if uglies[i] == ugly_by_prime[k]:\n                idx[k] += 1\n                ugly_by_prime[k] = primes[k] * uglies[idx[k]]\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    uglies = [0] * n\n    uglies[0] = 1\n    ugly_by_prime = list(primes)\n    idx = [0] * len(primes)\n    for i in xrange(1, n):\n        uglies[i] = min(ugly_by_prime)\n        for k in xrange(len(primes)):\n            if uglies[i] == ugly_by_prime[k]:\n                idx[k] += 1\n                ugly_by_prime[k] = primes[k] * uglies[idx[k]]\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    uglies = [0] * n\n    uglies[0] = 1\n    ugly_by_prime = list(primes)\n    idx = [0] * len(primes)\n    for i in xrange(1, n):\n        uglies[i] = min(ugly_by_prime)\n        for k in xrange(len(primes)):\n            if uglies[i] == ugly_by_prime[k]:\n                idx[k] += 1\n                ugly_by_prime[k] = primes[k] * uglies[idx[k]]\n    return uglies[-1]",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    uglies = [0] * n\n    uglies[0] = 1\n    ugly_by_prime = list(primes)\n    idx = [0] * len(primes)\n    for i in xrange(1, n):\n        uglies[i] = min(ugly_by_prime)\n        for k in xrange(len(primes)):\n            if uglies[i] == ugly_by_prime[k]:\n                idx[k] += 1\n                ugly_by_prime[k] = primes[k] * uglies[idx[k]]\n    return uglies[-1]"
        ]
    },
    {
        "func_name": "nthSuperUglyNumber",
        "original": "def nthSuperUglyNumber(self, n, primes):\n    \"\"\"\n        :type n: int\n        :type primes: List[int]\n        :rtype: int\n        \"\"\"\n    ugly_number = 0\n    heap = []\n    heapq.heappush(heap, 1)\n    for p in primes:\n        heapq.heappush(heap, p)\n    for _ in xrange(n):\n        ugly_number = heapq.heappop(heap)\n        for i in xrange(len(primes)):\n            if ugly_number % primes[i] == 0:\n                for j in xrange(i + 1):\n                    heapq.heappush(heap, ugly_number * primes[j])\n                break\n    return ugly_number",
        "mutated": [
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    ugly_number = 0\n    heap = []\n    heapq.heappush(heap, 1)\n    for p in primes:\n        heapq.heappush(heap, p)\n    for _ in xrange(n):\n        ugly_number = heapq.heappop(heap)\n        for i in xrange(len(primes)):\n            if ugly_number % primes[i] == 0:\n                for j in xrange(i + 1):\n                    heapq.heappush(heap, ugly_number * primes[j])\n                break\n    return ugly_number",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    ugly_number = 0\n    heap = []\n    heapq.heappush(heap, 1)\n    for p in primes:\n        heapq.heappush(heap, p)\n    for _ in xrange(n):\n        ugly_number = heapq.heappop(heap)\n        for i in xrange(len(primes)):\n            if ugly_number % primes[i] == 0:\n                for j in xrange(i + 1):\n                    heapq.heappush(heap, ugly_number * primes[j])\n                break\n    return ugly_number",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    ugly_number = 0\n    heap = []\n    heapq.heappush(heap, 1)\n    for p in primes:\n        heapq.heappush(heap, p)\n    for _ in xrange(n):\n        ugly_number = heapq.heappop(heap)\n        for i in xrange(len(primes)):\n            if ugly_number % primes[i] == 0:\n                for j in xrange(i + 1):\n                    heapq.heappush(heap, ugly_number * primes[j])\n                break\n    return ugly_number",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    ugly_number = 0\n    heap = []\n    heapq.heappush(heap, 1)\n    for p in primes:\n        heapq.heappush(heap, p)\n    for _ in xrange(n):\n        ugly_number = heapq.heappop(heap)\n        for i in xrange(len(primes)):\n            if ugly_number % primes[i] == 0:\n                for j in xrange(i + 1):\n                    heapq.heappush(heap, ugly_number * primes[j])\n                break\n    return ugly_number",
            "def nthSuperUglyNumber(self, n, primes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        '\n    ugly_number = 0\n    heap = []\n    heapq.heappush(heap, 1)\n    for p in primes:\n        heapq.heappush(heap, p)\n    for _ in xrange(n):\n        ugly_number = heapq.heappop(heap)\n        for i in xrange(len(primes)):\n            if ugly_number % primes[i] == 0:\n                for j in xrange(i + 1):\n                    heapq.heappush(heap, ugly_number * primes[j])\n                break\n    return ugly_number"
        ]
    }
]