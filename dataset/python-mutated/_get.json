[
    {
        "func_name": "_get_table_input",
        "original": "def _get_table_input(database: str, table: str, boto3_session: Optional[boto3.Session], transaction_id: Optional[str]=None, catalog_id: Optional[str]=None) -> Optional[Dict[str, Any]]:\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, DatabaseName=database, Name=table))\n    try:\n        response = client_glue.get_table(**args)\n    except client_glue.exceptions.EntityNotFoundException:\n        return None\n    table_input: Dict[str, Any] = {}\n    for (k, v) in response['Table'].items():\n        if k in ['Name', 'Description', 'Owner', 'LastAccessTime', 'LastAnalyzedTime', 'Retention', 'StorageDescriptor', 'PartitionKeys', 'ViewOriginalText', 'ViewExpandedText', 'TableType', 'Parameters', 'TargetTable']:\n            table_input[k] = v\n    return table_input",
        "mutated": [
            "def _get_table_input(database: str, table: str, boto3_session: Optional[boto3.Session], transaction_id: Optional[str]=None, catalog_id: Optional[str]=None) -> Optional[Dict[str, Any]]:\n    if False:\n        i = 10\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, DatabaseName=database, Name=table))\n    try:\n        response = client_glue.get_table(**args)\n    except client_glue.exceptions.EntityNotFoundException:\n        return None\n    table_input: Dict[str, Any] = {}\n    for (k, v) in response['Table'].items():\n        if k in ['Name', 'Description', 'Owner', 'LastAccessTime', 'LastAnalyzedTime', 'Retention', 'StorageDescriptor', 'PartitionKeys', 'ViewOriginalText', 'ViewExpandedText', 'TableType', 'Parameters', 'TargetTable']:\n            table_input[k] = v\n    return table_input",
            "def _get_table_input(database: str, table: str, boto3_session: Optional[boto3.Session], transaction_id: Optional[str]=None, catalog_id: Optional[str]=None) -> Optional[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, DatabaseName=database, Name=table))\n    try:\n        response = client_glue.get_table(**args)\n    except client_glue.exceptions.EntityNotFoundException:\n        return None\n    table_input: Dict[str, Any] = {}\n    for (k, v) in response['Table'].items():\n        if k in ['Name', 'Description', 'Owner', 'LastAccessTime', 'LastAnalyzedTime', 'Retention', 'StorageDescriptor', 'PartitionKeys', 'ViewOriginalText', 'ViewExpandedText', 'TableType', 'Parameters', 'TargetTable']:\n            table_input[k] = v\n    return table_input",
            "def _get_table_input(database: str, table: str, boto3_session: Optional[boto3.Session], transaction_id: Optional[str]=None, catalog_id: Optional[str]=None) -> Optional[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, DatabaseName=database, Name=table))\n    try:\n        response = client_glue.get_table(**args)\n    except client_glue.exceptions.EntityNotFoundException:\n        return None\n    table_input: Dict[str, Any] = {}\n    for (k, v) in response['Table'].items():\n        if k in ['Name', 'Description', 'Owner', 'LastAccessTime', 'LastAnalyzedTime', 'Retention', 'StorageDescriptor', 'PartitionKeys', 'ViewOriginalText', 'ViewExpandedText', 'TableType', 'Parameters', 'TargetTable']:\n            table_input[k] = v\n    return table_input",
            "def _get_table_input(database: str, table: str, boto3_session: Optional[boto3.Session], transaction_id: Optional[str]=None, catalog_id: Optional[str]=None) -> Optional[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, DatabaseName=database, Name=table))\n    try:\n        response = client_glue.get_table(**args)\n    except client_glue.exceptions.EntityNotFoundException:\n        return None\n    table_input: Dict[str, Any] = {}\n    for (k, v) in response['Table'].items():\n        if k in ['Name', 'Description', 'Owner', 'LastAccessTime', 'LastAnalyzedTime', 'Retention', 'StorageDescriptor', 'PartitionKeys', 'ViewOriginalText', 'ViewExpandedText', 'TableType', 'Parameters', 'TargetTable']:\n            table_input[k] = v\n    return table_input",
            "def _get_table_input(database: str, table: str, boto3_session: Optional[boto3.Session], transaction_id: Optional[str]=None, catalog_id: Optional[str]=None) -> Optional[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, DatabaseName=database, Name=table))\n    try:\n        response = client_glue.get_table(**args)\n    except client_glue.exceptions.EntityNotFoundException:\n        return None\n    table_input: Dict[str, Any] = {}\n    for (k, v) in response['Table'].items():\n        if k in ['Name', 'Description', 'Owner', 'LastAccessTime', 'LastAnalyzedTime', 'Retention', 'StorageDescriptor', 'PartitionKeys', 'ViewOriginalText', 'ViewExpandedText', 'TableType', 'Parameters', 'TargetTable']:\n            table_input[k] = v\n    return table_input"
        ]
    },
    {
        "func_name": "_append_partitions",
        "original": "def _append_partitions(partitions_values: Dict[str, List[str]], response: 'GetPartitionsResponseTypeDef') -> Optional[str]:\n    _logger.debug('response: %s', response)\n    token: Optional[str] = response.get('NextToken', None)\n    if response is not None and 'Partitions' in response:\n        for partition in response['Partitions']:\n            location: Optional[str] = partition['StorageDescriptor'].get('Location')\n            if location is not None:\n                values: List[str] = partition['Values']\n                partitions_values[location] = values\n    else:\n        token = None\n    return token",
        "mutated": [
            "def _append_partitions(partitions_values: Dict[str, List[str]], response: 'GetPartitionsResponseTypeDef') -> Optional[str]:\n    if False:\n        i = 10\n    _logger.debug('response: %s', response)\n    token: Optional[str] = response.get('NextToken', None)\n    if response is not None and 'Partitions' in response:\n        for partition in response['Partitions']:\n            location: Optional[str] = partition['StorageDescriptor'].get('Location')\n            if location is not None:\n                values: List[str] = partition['Values']\n                partitions_values[location] = values\n    else:\n        token = None\n    return token",
            "def _append_partitions(partitions_values: Dict[str, List[str]], response: 'GetPartitionsResponseTypeDef') -> Optional[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    _logger.debug('response: %s', response)\n    token: Optional[str] = response.get('NextToken', None)\n    if response is not None and 'Partitions' in response:\n        for partition in response['Partitions']:\n            location: Optional[str] = partition['StorageDescriptor'].get('Location')\n            if location is not None:\n                values: List[str] = partition['Values']\n                partitions_values[location] = values\n    else:\n        token = None\n    return token",
            "def _append_partitions(partitions_values: Dict[str, List[str]], response: 'GetPartitionsResponseTypeDef') -> Optional[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    _logger.debug('response: %s', response)\n    token: Optional[str] = response.get('NextToken', None)\n    if response is not None and 'Partitions' in response:\n        for partition in response['Partitions']:\n            location: Optional[str] = partition['StorageDescriptor'].get('Location')\n            if location is not None:\n                values: List[str] = partition['Values']\n                partitions_values[location] = values\n    else:\n        token = None\n    return token",
            "def _append_partitions(partitions_values: Dict[str, List[str]], response: 'GetPartitionsResponseTypeDef') -> Optional[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    _logger.debug('response: %s', response)\n    token: Optional[str] = response.get('NextToken', None)\n    if response is not None and 'Partitions' in response:\n        for partition in response['Partitions']:\n            location: Optional[str] = partition['StorageDescriptor'].get('Location')\n            if location is not None:\n                values: List[str] = partition['Values']\n                partitions_values[location] = values\n    else:\n        token = None\n    return token",
            "def _append_partitions(partitions_values: Dict[str, List[str]], response: 'GetPartitionsResponseTypeDef') -> Optional[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    _logger.debug('response: %s', response)\n    token: Optional[str] = response.get('NextToken', None)\n    if response is not None and 'Partitions' in response:\n        for partition in response['Partitions']:\n            location: Optional[str] = partition['StorageDescriptor'].get('Location')\n            if location is not None:\n                values: List[str] = partition['Values']\n                partitions_values[location] = values\n    else:\n        token = None\n    return token"
        ]
    },
    {
        "func_name": "_get_partitions",
        "original": "def _get_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, DatabaseName=database, TableName=table, MaxResults=1000, Segment={'SegmentNumber': 0, 'TotalSegments': 1}, ExcludeColumnSchema=True)\n    if expression is not None:\n        args['Expression'] = expression\n    partitions_values: Dict[str, List[str]] = {}\n    _logger.debug('Starting pagination...')\n    response = client_glue.get_partitions(**args)\n    token: Optional[str] = _append_partitions(partitions_values=partitions_values, response=response)\n    while token is not None:\n        args['NextToken'] = response['NextToken']\n        response = client_glue.get_partitions(**args)\n        token = _append_partitions(partitions_values=partitions_values, response=response)\n    _logger.debug('Pagination done.')\n    return partitions_values",
        "mutated": [
            "def _get_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, DatabaseName=database, TableName=table, MaxResults=1000, Segment={'SegmentNumber': 0, 'TotalSegments': 1}, ExcludeColumnSchema=True)\n    if expression is not None:\n        args['Expression'] = expression\n    partitions_values: Dict[str, List[str]] = {}\n    _logger.debug('Starting pagination...')\n    response = client_glue.get_partitions(**args)\n    token: Optional[str] = _append_partitions(partitions_values=partitions_values, response=response)\n    while token is not None:\n        args['NextToken'] = response['NextToken']\n        response = client_glue.get_partitions(**args)\n        token = _append_partitions(partitions_values=partitions_values, response=response)\n    _logger.debug('Pagination done.')\n    return partitions_values",
            "def _get_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, DatabaseName=database, TableName=table, MaxResults=1000, Segment={'SegmentNumber': 0, 'TotalSegments': 1}, ExcludeColumnSchema=True)\n    if expression is not None:\n        args['Expression'] = expression\n    partitions_values: Dict[str, List[str]] = {}\n    _logger.debug('Starting pagination...')\n    response = client_glue.get_partitions(**args)\n    token: Optional[str] = _append_partitions(partitions_values=partitions_values, response=response)\n    while token is not None:\n        args['NextToken'] = response['NextToken']\n        response = client_glue.get_partitions(**args)\n        token = _append_partitions(partitions_values=partitions_values, response=response)\n    _logger.debug('Pagination done.')\n    return partitions_values",
            "def _get_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, DatabaseName=database, TableName=table, MaxResults=1000, Segment={'SegmentNumber': 0, 'TotalSegments': 1}, ExcludeColumnSchema=True)\n    if expression is not None:\n        args['Expression'] = expression\n    partitions_values: Dict[str, List[str]] = {}\n    _logger.debug('Starting pagination...')\n    response = client_glue.get_partitions(**args)\n    token: Optional[str] = _append_partitions(partitions_values=partitions_values, response=response)\n    while token is not None:\n        args['NextToken'] = response['NextToken']\n        response = client_glue.get_partitions(**args)\n        token = _append_partitions(partitions_values=partitions_values, response=response)\n    _logger.debug('Pagination done.')\n    return partitions_values",
            "def _get_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, DatabaseName=database, TableName=table, MaxResults=1000, Segment={'SegmentNumber': 0, 'TotalSegments': 1}, ExcludeColumnSchema=True)\n    if expression is not None:\n        args['Expression'] = expression\n    partitions_values: Dict[str, List[str]] = {}\n    _logger.debug('Starting pagination...')\n    response = client_glue.get_partitions(**args)\n    token: Optional[str] = _append_partitions(partitions_values=partitions_values, response=response)\n    while token is not None:\n        args['NextToken'] = response['NextToken']\n        response = client_glue.get_partitions(**args)\n        token = _append_partitions(partitions_values=partitions_values, response=response)\n    _logger.debug('Pagination done.')\n    return partitions_values",
            "def _get_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, DatabaseName=database, TableName=table, MaxResults=1000, Segment={'SegmentNumber': 0, 'TotalSegments': 1}, ExcludeColumnSchema=True)\n    if expression is not None:\n        args['Expression'] = expression\n    partitions_values: Dict[str, List[str]] = {}\n    _logger.debug('Starting pagination...')\n    response = client_glue.get_partitions(**args)\n    token: Optional[str] = _append_partitions(partitions_values=partitions_values, response=response)\n    while token is not None:\n        args['NextToken'] = response['NextToken']\n        response = client_glue.get_partitions(**args)\n        token = _append_partitions(partitions_values=partitions_values, response=response)\n    _logger.debug('Pagination done.')\n    return partitions_values"
        ]
    },
    {
        "func_name": "get_table_types",
        "original": "@apply_configs\ndef get_table_types(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Optional[Dict[str, str]]:\n    \"\"\"Get all columns and types from a table.\n\n    Note\n    ----\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\n\n    Parameters\n    ----------\n    database: str\n        Database name.\n    table: str\n        Table name.\n    transaction_id: str, optional\n        The ID of the transaction (i.e. used with GOVERNED tables).\n    query_as_of_time: str, optional\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\n        Cannot be specified alongside transaction_id.\n    catalog_id: str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    boto3_session: boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    Optional[Dict[str, str]]\n        If table exists, a dictionary like {'col name': 'col data type'}. Otherwise None.\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> wr.catalog.get_table_types(database='default', table='my_table')\n    {'col0': 'int', 'col1': double}\n\n    \"\"\"\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    try:\n        response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    except client_glue.exceptions.EntityNotFoundException:\n        return None\n    return _extract_dtypes_from_table_details(response=response)",
        "mutated": [
            "@apply_configs\ndef get_table_types(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Optional[Dict[str, str]]:\n    if False:\n        i = 10\n    \"Get all columns and types from a table.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database: str\\n        Database name.\\n    table: str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id: str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session: boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Optional[Dict[str, str]]\\n        If table exists, a dictionary like {'col name': 'col data type'}. Otherwise None.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_table_types(database='default', table='my_table')\\n    {'col0': 'int', 'col1': double}\\n\\n    \"\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    try:\n        response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    except client_glue.exceptions.EntityNotFoundException:\n        return None\n    return _extract_dtypes_from_table_details(response=response)",
            "@apply_configs\ndef get_table_types(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Optional[Dict[str, str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Get all columns and types from a table.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database: str\\n        Database name.\\n    table: str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id: str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session: boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Optional[Dict[str, str]]\\n        If table exists, a dictionary like {'col name': 'col data type'}. Otherwise None.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_table_types(database='default', table='my_table')\\n    {'col0': 'int', 'col1': double}\\n\\n    \"\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    try:\n        response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    except client_glue.exceptions.EntityNotFoundException:\n        return None\n    return _extract_dtypes_from_table_details(response=response)",
            "@apply_configs\ndef get_table_types(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Optional[Dict[str, str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Get all columns and types from a table.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database: str\\n        Database name.\\n    table: str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id: str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session: boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Optional[Dict[str, str]]\\n        If table exists, a dictionary like {'col name': 'col data type'}. Otherwise None.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_table_types(database='default', table='my_table')\\n    {'col0': 'int', 'col1': double}\\n\\n    \"\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    try:\n        response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    except client_glue.exceptions.EntityNotFoundException:\n        return None\n    return _extract_dtypes_from_table_details(response=response)",
            "@apply_configs\ndef get_table_types(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Optional[Dict[str, str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Get all columns and types from a table.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database: str\\n        Database name.\\n    table: str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id: str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session: boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Optional[Dict[str, str]]\\n        If table exists, a dictionary like {'col name': 'col data type'}. Otherwise None.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_table_types(database='default', table='my_table')\\n    {'col0': 'int', 'col1': double}\\n\\n    \"\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    try:\n        response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    except client_glue.exceptions.EntityNotFoundException:\n        return None\n    return _extract_dtypes_from_table_details(response=response)",
            "@apply_configs\ndef get_table_types(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Optional[Dict[str, str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Get all columns and types from a table.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database: str\\n        Database name.\\n    table: str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id: str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session: boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Optional[Dict[str, str]]\\n        If table exists, a dictionary like {'col name': 'col data type'}. Otherwise None.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_table_types(database='default', table='my_table')\\n    {'col0': 'int', 'col1': double}\\n\\n    \"\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    try:\n        response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    except client_glue.exceptions.EntityNotFoundException:\n        return None\n    return _extract_dtypes_from_table_details(response=response)"
        ]
    },
    {
        "func_name": "get_databases",
        "original": "def get_databases(catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    \"\"\"Get an iterator of databases.\n\n    Parameters\n    ----------\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    Iterator[Dict[str, Any]]\n        Iterator of Databases.\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> dbs = wr.catalog.get_databases()\n\n    \"\"\"\n    client_glue = _utils.client('glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_databases')\n    response_iterator = paginator.paginate(**_catalog_id(catalog_id=catalog_id))\n    for page in response_iterator:\n        for db in page['DatabaseList']:\n            yield cast(Dict[str, Any], db)",
        "mutated": [
            "def get_databases(catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    if False:\n        i = 10\n    'Get an iterator of databases.\\n\\n    Parameters\\n    ----------\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Iterator[Dict[str, Any]]\\n        Iterator of Databases.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> dbs = wr.catalog.get_databases()\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_databases')\n    response_iterator = paginator.paginate(**_catalog_id(catalog_id=catalog_id))\n    for page in response_iterator:\n        for db in page['DatabaseList']:\n            yield cast(Dict[str, Any], db)",
            "def get_databases(catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get an iterator of databases.\\n\\n    Parameters\\n    ----------\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Iterator[Dict[str, Any]]\\n        Iterator of Databases.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> dbs = wr.catalog.get_databases()\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_databases')\n    response_iterator = paginator.paginate(**_catalog_id(catalog_id=catalog_id))\n    for page in response_iterator:\n        for db in page['DatabaseList']:\n            yield cast(Dict[str, Any], db)",
            "def get_databases(catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get an iterator of databases.\\n\\n    Parameters\\n    ----------\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Iterator[Dict[str, Any]]\\n        Iterator of Databases.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> dbs = wr.catalog.get_databases()\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_databases')\n    response_iterator = paginator.paginate(**_catalog_id(catalog_id=catalog_id))\n    for page in response_iterator:\n        for db in page['DatabaseList']:\n            yield cast(Dict[str, Any], db)",
            "def get_databases(catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get an iterator of databases.\\n\\n    Parameters\\n    ----------\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Iterator[Dict[str, Any]]\\n        Iterator of Databases.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> dbs = wr.catalog.get_databases()\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_databases')\n    response_iterator = paginator.paginate(**_catalog_id(catalog_id=catalog_id))\n    for page in response_iterator:\n        for db in page['DatabaseList']:\n            yield cast(Dict[str, Any], db)",
            "def get_databases(catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get an iterator of databases.\\n\\n    Parameters\\n    ----------\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Iterator[Dict[str, Any]]\\n        Iterator of Databases.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> dbs = wr.catalog.get_databases()\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_databases')\n    response_iterator = paginator.paginate(**_catalog_id(catalog_id=catalog_id))\n    for page in response_iterator:\n        for db in page['DatabaseList']:\n            yield cast(Dict[str, Any], db)"
        ]
    },
    {
        "func_name": "databases",
        "original": "@apply_configs\ndef databases(limit: int=100, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    \"\"\"Get a Pandas DataFrame with all listed databases.\n\n    Parameters\n    ----------\n    limit : int, optional\n        Max number of tables to be returned.\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    pandas.DataFrame\n        Pandas DataFrame filled by formatted table information.\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> df_dbs = wr.catalog.databases()\n\n    \"\"\"\n    database_iter = get_databases(catalog_id=catalog_id, boto3_session=boto3_session)\n    dbs = itertools.islice(database_iter, limit)\n    df_dict: Dict[str, List[str]] = {'Database': [], 'Description': []}\n    for db in dbs:\n        df_dict['Database'].append(db['Name'])\n        df_dict['Description'].append(db.get('Description', ''))\n    return pd.DataFrame(data=df_dict)",
        "mutated": [
            "@apply_configs\ndef databases(limit: int=100, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n    'Get a Pandas DataFrame with all listed databases.\\n\\n    Parameters\\n    ----------\\n    limit : int, optional\\n        Max number of tables to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    pandas.DataFrame\\n        Pandas DataFrame filled by formatted table information.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_dbs = wr.catalog.databases()\\n\\n    '\n    database_iter = get_databases(catalog_id=catalog_id, boto3_session=boto3_session)\n    dbs = itertools.islice(database_iter, limit)\n    df_dict: Dict[str, List[str]] = {'Database': [], 'Description': []}\n    for db in dbs:\n        df_dict['Database'].append(db['Name'])\n        df_dict['Description'].append(db.get('Description', ''))\n    return pd.DataFrame(data=df_dict)",
            "@apply_configs\ndef databases(limit: int=100, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get a Pandas DataFrame with all listed databases.\\n\\n    Parameters\\n    ----------\\n    limit : int, optional\\n        Max number of tables to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    pandas.DataFrame\\n        Pandas DataFrame filled by formatted table information.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_dbs = wr.catalog.databases()\\n\\n    '\n    database_iter = get_databases(catalog_id=catalog_id, boto3_session=boto3_session)\n    dbs = itertools.islice(database_iter, limit)\n    df_dict: Dict[str, List[str]] = {'Database': [], 'Description': []}\n    for db in dbs:\n        df_dict['Database'].append(db['Name'])\n        df_dict['Description'].append(db.get('Description', ''))\n    return pd.DataFrame(data=df_dict)",
            "@apply_configs\ndef databases(limit: int=100, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get a Pandas DataFrame with all listed databases.\\n\\n    Parameters\\n    ----------\\n    limit : int, optional\\n        Max number of tables to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    pandas.DataFrame\\n        Pandas DataFrame filled by formatted table information.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_dbs = wr.catalog.databases()\\n\\n    '\n    database_iter = get_databases(catalog_id=catalog_id, boto3_session=boto3_session)\n    dbs = itertools.islice(database_iter, limit)\n    df_dict: Dict[str, List[str]] = {'Database': [], 'Description': []}\n    for db in dbs:\n        df_dict['Database'].append(db['Name'])\n        df_dict['Description'].append(db.get('Description', ''))\n    return pd.DataFrame(data=df_dict)",
            "@apply_configs\ndef databases(limit: int=100, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get a Pandas DataFrame with all listed databases.\\n\\n    Parameters\\n    ----------\\n    limit : int, optional\\n        Max number of tables to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    pandas.DataFrame\\n        Pandas DataFrame filled by formatted table information.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_dbs = wr.catalog.databases()\\n\\n    '\n    database_iter = get_databases(catalog_id=catalog_id, boto3_session=boto3_session)\n    dbs = itertools.islice(database_iter, limit)\n    df_dict: Dict[str, List[str]] = {'Database': [], 'Description': []}\n    for db in dbs:\n        df_dict['Database'].append(db['Name'])\n        df_dict['Description'].append(db.get('Description', ''))\n    return pd.DataFrame(data=df_dict)",
            "@apply_configs\ndef databases(limit: int=100, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get a Pandas DataFrame with all listed databases.\\n\\n    Parameters\\n    ----------\\n    limit : int, optional\\n        Max number of tables to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    pandas.DataFrame\\n        Pandas DataFrame filled by formatted table information.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_dbs = wr.catalog.databases()\\n\\n    '\n    database_iter = get_databases(catalog_id=catalog_id, boto3_session=boto3_session)\n    dbs = itertools.islice(database_iter, limit)\n    df_dict: Dict[str, List[str]] = {'Database': [], 'Description': []}\n    for db in dbs:\n        df_dict['Database'].append(db['Name'])\n        df_dict['Description'].append(db.get('Description', ''))\n    return pd.DataFrame(data=df_dict)"
        ]
    },
    {
        "func_name": "get_tables",
        "original": "@apply_configs\ndef get_tables(catalog_id: Optional[str]=None, database: Optional[str]=None, transaction_id: Optional[str]=None, name_contains: Optional[str]=None, name_prefix: Optional[str]=None, name_suffix: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    \"\"\"Get an iterator of tables.\n\n    Note\n    ----\n    Please, do not filter using name_contains and name_prefix/name_suffix at the same time.\n    Only name_prefix and name_suffix can be combined together.\n\n    Parameters\n    ----------\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    database : str, optional\n        Database name.\n    transaction_id: str, optional\n        The ID of the transaction (i.e. used with GOVERNED tables).\n    name_contains : str, optional\n        Select by a specific string on table name\n    name_prefix : str, optional\n        Select by a specific prefix on table name\n    name_suffix : str, optional\n        Select by a specific suffix on table name\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    Iterator[Dict[str, Any]]\n        Iterator of tables.\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> tables = wr.catalog.get_tables()\n\n    \"\"\"\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_tables')\n    args: Dict[str, str] = {}\n    if name_prefix is not None and name_suffix is not None and (name_contains is not None):\n        raise exceptions.InvalidArgumentCombination('Please, do not filter using name_contains and name_prefix/name_suffix at the same time. Only name_prefix and name_suffix can be combined together.')\n    if name_prefix is not None and name_suffix is not None:\n        args['Expression'] = f'{name_prefix}*{name_suffix}'\n    elif name_contains is not None:\n        args['Expression'] = f'*{name_contains}*'\n    elif name_prefix is not None:\n        args['Expression'] = f'{name_prefix}*'\n    elif name_suffix is not None:\n        args['Expression'] = f'*{name_suffix}'\n    if database is not None:\n        dbs: List[str] = [database]\n    else:\n        dbs = [x['Name'] for x in get_databases(catalog_id=catalog_id)]\n    for db in dbs:\n        args['DatabaseName'] = db\n        response_iterator = paginator.paginate(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, **args)))\n        try:\n            for page in response_iterator:\n                for tbl in page['TableList']:\n                    yield cast(Dict[str, Any], tbl)\n        except client_glue.exceptions.EntityNotFoundException:\n            continue",
        "mutated": [
            "@apply_configs\ndef get_tables(catalog_id: Optional[str]=None, database: Optional[str]=None, transaction_id: Optional[str]=None, name_contains: Optional[str]=None, name_prefix: Optional[str]=None, name_suffix: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    if False:\n        i = 10\n    'Get an iterator of tables.\\n\\n    Note\\n    ----\\n    Please, do not filter using name_contains and name_prefix/name_suffix at the same time.\\n    Only name_prefix and name_suffix can be combined together.\\n\\n    Parameters\\n    ----------\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    database : str, optional\\n        Database name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    name_contains : str, optional\\n        Select by a specific string on table name\\n    name_prefix : str, optional\\n        Select by a specific prefix on table name\\n    name_suffix : str, optional\\n        Select by a specific suffix on table name\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Iterator[Dict[str, Any]]\\n        Iterator of tables.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> tables = wr.catalog.get_tables()\\n\\n    '\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_tables')\n    args: Dict[str, str] = {}\n    if name_prefix is not None and name_suffix is not None and (name_contains is not None):\n        raise exceptions.InvalidArgumentCombination('Please, do not filter using name_contains and name_prefix/name_suffix at the same time. Only name_prefix and name_suffix can be combined together.')\n    if name_prefix is not None and name_suffix is not None:\n        args['Expression'] = f'{name_prefix}*{name_suffix}'\n    elif name_contains is not None:\n        args['Expression'] = f'*{name_contains}*'\n    elif name_prefix is not None:\n        args['Expression'] = f'{name_prefix}*'\n    elif name_suffix is not None:\n        args['Expression'] = f'*{name_suffix}'\n    if database is not None:\n        dbs: List[str] = [database]\n    else:\n        dbs = [x['Name'] for x in get_databases(catalog_id=catalog_id)]\n    for db in dbs:\n        args['DatabaseName'] = db\n        response_iterator = paginator.paginate(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, **args)))\n        try:\n            for page in response_iterator:\n                for tbl in page['TableList']:\n                    yield cast(Dict[str, Any], tbl)\n        except client_glue.exceptions.EntityNotFoundException:\n            continue",
            "@apply_configs\ndef get_tables(catalog_id: Optional[str]=None, database: Optional[str]=None, transaction_id: Optional[str]=None, name_contains: Optional[str]=None, name_prefix: Optional[str]=None, name_suffix: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get an iterator of tables.\\n\\n    Note\\n    ----\\n    Please, do not filter using name_contains and name_prefix/name_suffix at the same time.\\n    Only name_prefix and name_suffix can be combined together.\\n\\n    Parameters\\n    ----------\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    database : str, optional\\n        Database name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    name_contains : str, optional\\n        Select by a specific string on table name\\n    name_prefix : str, optional\\n        Select by a specific prefix on table name\\n    name_suffix : str, optional\\n        Select by a specific suffix on table name\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Iterator[Dict[str, Any]]\\n        Iterator of tables.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> tables = wr.catalog.get_tables()\\n\\n    '\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_tables')\n    args: Dict[str, str] = {}\n    if name_prefix is not None and name_suffix is not None and (name_contains is not None):\n        raise exceptions.InvalidArgumentCombination('Please, do not filter using name_contains and name_prefix/name_suffix at the same time. Only name_prefix and name_suffix can be combined together.')\n    if name_prefix is not None and name_suffix is not None:\n        args['Expression'] = f'{name_prefix}*{name_suffix}'\n    elif name_contains is not None:\n        args['Expression'] = f'*{name_contains}*'\n    elif name_prefix is not None:\n        args['Expression'] = f'{name_prefix}*'\n    elif name_suffix is not None:\n        args['Expression'] = f'*{name_suffix}'\n    if database is not None:\n        dbs: List[str] = [database]\n    else:\n        dbs = [x['Name'] for x in get_databases(catalog_id=catalog_id)]\n    for db in dbs:\n        args['DatabaseName'] = db\n        response_iterator = paginator.paginate(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, **args)))\n        try:\n            for page in response_iterator:\n                for tbl in page['TableList']:\n                    yield cast(Dict[str, Any], tbl)\n        except client_glue.exceptions.EntityNotFoundException:\n            continue",
            "@apply_configs\ndef get_tables(catalog_id: Optional[str]=None, database: Optional[str]=None, transaction_id: Optional[str]=None, name_contains: Optional[str]=None, name_prefix: Optional[str]=None, name_suffix: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get an iterator of tables.\\n\\n    Note\\n    ----\\n    Please, do not filter using name_contains and name_prefix/name_suffix at the same time.\\n    Only name_prefix and name_suffix can be combined together.\\n\\n    Parameters\\n    ----------\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    database : str, optional\\n        Database name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    name_contains : str, optional\\n        Select by a specific string on table name\\n    name_prefix : str, optional\\n        Select by a specific prefix on table name\\n    name_suffix : str, optional\\n        Select by a specific suffix on table name\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Iterator[Dict[str, Any]]\\n        Iterator of tables.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> tables = wr.catalog.get_tables()\\n\\n    '\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_tables')\n    args: Dict[str, str] = {}\n    if name_prefix is not None and name_suffix is not None and (name_contains is not None):\n        raise exceptions.InvalidArgumentCombination('Please, do not filter using name_contains and name_prefix/name_suffix at the same time. Only name_prefix and name_suffix can be combined together.')\n    if name_prefix is not None and name_suffix is not None:\n        args['Expression'] = f'{name_prefix}*{name_suffix}'\n    elif name_contains is not None:\n        args['Expression'] = f'*{name_contains}*'\n    elif name_prefix is not None:\n        args['Expression'] = f'{name_prefix}*'\n    elif name_suffix is not None:\n        args['Expression'] = f'*{name_suffix}'\n    if database is not None:\n        dbs: List[str] = [database]\n    else:\n        dbs = [x['Name'] for x in get_databases(catalog_id=catalog_id)]\n    for db in dbs:\n        args['DatabaseName'] = db\n        response_iterator = paginator.paginate(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, **args)))\n        try:\n            for page in response_iterator:\n                for tbl in page['TableList']:\n                    yield cast(Dict[str, Any], tbl)\n        except client_glue.exceptions.EntityNotFoundException:\n            continue",
            "@apply_configs\ndef get_tables(catalog_id: Optional[str]=None, database: Optional[str]=None, transaction_id: Optional[str]=None, name_contains: Optional[str]=None, name_prefix: Optional[str]=None, name_suffix: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get an iterator of tables.\\n\\n    Note\\n    ----\\n    Please, do not filter using name_contains and name_prefix/name_suffix at the same time.\\n    Only name_prefix and name_suffix can be combined together.\\n\\n    Parameters\\n    ----------\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    database : str, optional\\n        Database name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    name_contains : str, optional\\n        Select by a specific string on table name\\n    name_prefix : str, optional\\n        Select by a specific prefix on table name\\n    name_suffix : str, optional\\n        Select by a specific suffix on table name\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Iterator[Dict[str, Any]]\\n        Iterator of tables.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> tables = wr.catalog.get_tables()\\n\\n    '\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_tables')\n    args: Dict[str, str] = {}\n    if name_prefix is not None and name_suffix is not None and (name_contains is not None):\n        raise exceptions.InvalidArgumentCombination('Please, do not filter using name_contains and name_prefix/name_suffix at the same time. Only name_prefix and name_suffix can be combined together.')\n    if name_prefix is not None and name_suffix is not None:\n        args['Expression'] = f'{name_prefix}*{name_suffix}'\n    elif name_contains is not None:\n        args['Expression'] = f'*{name_contains}*'\n    elif name_prefix is not None:\n        args['Expression'] = f'{name_prefix}*'\n    elif name_suffix is not None:\n        args['Expression'] = f'*{name_suffix}'\n    if database is not None:\n        dbs: List[str] = [database]\n    else:\n        dbs = [x['Name'] for x in get_databases(catalog_id=catalog_id)]\n    for db in dbs:\n        args['DatabaseName'] = db\n        response_iterator = paginator.paginate(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, **args)))\n        try:\n            for page in response_iterator:\n                for tbl in page['TableList']:\n                    yield cast(Dict[str, Any], tbl)\n        except client_glue.exceptions.EntityNotFoundException:\n            continue",
            "@apply_configs\ndef get_tables(catalog_id: Optional[str]=None, database: Optional[str]=None, transaction_id: Optional[str]=None, name_contains: Optional[str]=None, name_prefix: Optional[str]=None, name_suffix: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get an iterator of tables.\\n\\n    Note\\n    ----\\n    Please, do not filter using name_contains and name_prefix/name_suffix at the same time.\\n    Only name_prefix and name_suffix can be combined together.\\n\\n    Parameters\\n    ----------\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    database : str, optional\\n        Database name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    name_contains : str, optional\\n        Select by a specific string on table name\\n    name_prefix : str, optional\\n        Select by a specific prefix on table name\\n    name_suffix : str, optional\\n        Select by a specific suffix on table name\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Iterator[Dict[str, Any]]\\n        Iterator of tables.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> tables = wr.catalog.get_tables()\\n\\n    '\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_tables')\n    args: Dict[str, str] = {}\n    if name_prefix is not None and name_suffix is not None and (name_contains is not None):\n        raise exceptions.InvalidArgumentCombination('Please, do not filter using name_contains and name_prefix/name_suffix at the same time. Only name_prefix and name_suffix can be combined together.')\n    if name_prefix is not None and name_suffix is not None:\n        args['Expression'] = f'{name_prefix}*{name_suffix}'\n    elif name_contains is not None:\n        args['Expression'] = f'*{name_contains}*'\n    elif name_prefix is not None:\n        args['Expression'] = f'{name_prefix}*'\n    elif name_suffix is not None:\n        args['Expression'] = f'*{name_suffix}'\n    if database is not None:\n        dbs: List[str] = [database]\n    else:\n        dbs = [x['Name'] for x in get_databases(catalog_id=catalog_id)]\n    for db in dbs:\n        args['DatabaseName'] = db\n        response_iterator = paginator.paginate(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, **args)))\n        try:\n            for page in response_iterator:\n                for tbl in page['TableList']:\n                    yield cast(Dict[str, Any], tbl)\n        except client_glue.exceptions.EntityNotFoundException:\n            continue"
        ]
    },
    {
        "func_name": "tables",
        "original": "@apply_configs\ndef tables(limit: int=100, catalog_id: Optional[str]=None, database: Optional[str]=None, transaction_id: Optional[str]=None, search_text: Optional[str]=None, name_contains: Optional[str]=None, name_prefix: Optional[str]=None, name_suffix: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    \"\"\"Get a DataFrame with tables filtered by a search term, prefix, suffix.\n\n    Note\n    ----\n    Search feature is not supported for Governed tables.\n\n    Parameters\n    ----------\n    limit : int, optional\n        Max number of tables to be returned.\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    database : str, optional\n        Database name.\n    transaction_id: str, optional\n        The ID of the transaction (i.e. used with GOVERNED tables).\n    search_text : str, optional\n        Select only tables with the given string in table's properties.\n    name_contains : str, optional\n        Select by a specific string on table name\n    name_prefix : str, optional\n        Select by a specific prefix on table name\n    name_suffix : str, optional\n        Select by a specific suffix on table name\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    pandas.DataFrame\n        Pandas DataFrame filled by formatted table information.\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> df_tables = wr.catalog.tables()\n\n    \"\"\"\n    if search_text is None:\n        table_iter = get_tables(catalog_id=catalog_id, database=database, transaction_id=transaction_id, name_contains=name_contains, name_prefix=name_prefix, name_suffix=name_suffix, boto3_session=boto3_session)\n        tbls: List[Dict[str, Any]] = list(itertools.islice(table_iter, limit))\n    else:\n        tbls = list(search_tables(text=search_text, catalog_id=catalog_id, boto3_session=boto3_session))\n        if database is not None:\n            tbls = [x for x in tbls if x['DatabaseName'] == database]\n        if name_contains is not None:\n            tbls = [x for x in tbls if name_contains in x['Name']]\n        if name_prefix is not None:\n            tbls = [x for x in tbls if x['Name'].startswith(name_prefix)]\n        if name_suffix is not None:\n            tbls = [x for x in tbls if x['Name'].endswith(name_suffix)]\n        tbls = tbls[:limit]\n    df_dict: Dict[str, List[str]] = {'Database': [], 'Table': [], 'Description': [], 'TableType': [], 'Columns': [], 'Partitions': []}\n    for tbl in tbls:\n        df_dict['Database'].append(tbl['DatabaseName'])\n        df_dict['Table'].append(tbl['Name'])\n        df_dict['Description'].append(tbl.get('Description', ''))\n        df_dict['TableType'].append(tbl.get('TableType', ''))\n        try:\n            columns = tbl['StorageDescriptor']['Columns']\n            df_dict['Columns'].append(', '.join([x['Name'] for x in columns]))\n        except KeyError:\n            df_dict['Columns'].append('')\n        if 'PartitionKeys' in tbl:\n            df_dict['Partitions'].append(', '.join([x['Name'] for x in tbl['PartitionKeys']]))\n        else:\n            df_dict['Partitions'].append('')\n    return pd.DataFrame(data=df_dict)",
        "mutated": [
            "@apply_configs\ndef tables(limit: int=100, catalog_id: Optional[str]=None, database: Optional[str]=None, transaction_id: Optional[str]=None, search_text: Optional[str]=None, name_contains: Optional[str]=None, name_prefix: Optional[str]=None, name_suffix: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n    \"Get a DataFrame with tables filtered by a search term, prefix, suffix.\\n\\n    Note\\n    ----\\n    Search feature is not supported for Governed tables.\\n\\n    Parameters\\n    ----------\\n    limit : int, optional\\n        Max number of tables to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    database : str, optional\\n        Database name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    search_text : str, optional\\n        Select only tables with the given string in table's properties.\\n    name_contains : str, optional\\n        Select by a specific string on table name\\n    name_prefix : str, optional\\n        Select by a specific prefix on table name\\n    name_suffix : str, optional\\n        Select by a specific suffix on table name\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    pandas.DataFrame\\n        Pandas DataFrame filled by formatted table information.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_tables = wr.catalog.tables()\\n\\n    \"\n    if search_text is None:\n        table_iter = get_tables(catalog_id=catalog_id, database=database, transaction_id=transaction_id, name_contains=name_contains, name_prefix=name_prefix, name_suffix=name_suffix, boto3_session=boto3_session)\n        tbls: List[Dict[str, Any]] = list(itertools.islice(table_iter, limit))\n    else:\n        tbls = list(search_tables(text=search_text, catalog_id=catalog_id, boto3_session=boto3_session))\n        if database is not None:\n            tbls = [x for x in tbls if x['DatabaseName'] == database]\n        if name_contains is not None:\n            tbls = [x for x in tbls if name_contains in x['Name']]\n        if name_prefix is not None:\n            tbls = [x for x in tbls if x['Name'].startswith(name_prefix)]\n        if name_suffix is not None:\n            tbls = [x for x in tbls if x['Name'].endswith(name_suffix)]\n        tbls = tbls[:limit]\n    df_dict: Dict[str, List[str]] = {'Database': [], 'Table': [], 'Description': [], 'TableType': [], 'Columns': [], 'Partitions': []}\n    for tbl in tbls:\n        df_dict['Database'].append(tbl['DatabaseName'])\n        df_dict['Table'].append(tbl['Name'])\n        df_dict['Description'].append(tbl.get('Description', ''))\n        df_dict['TableType'].append(tbl.get('TableType', ''))\n        try:\n            columns = tbl['StorageDescriptor']['Columns']\n            df_dict['Columns'].append(', '.join([x['Name'] for x in columns]))\n        except KeyError:\n            df_dict['Columns'].append('')\n        if 'PartitionKeys' in tbl:\n            df_dict['Partitions'].append(', '.join([x['Name'] for x in tbl['PartitionKeys']]))\n        else:\n            df_dict['Partitions'].append('')\n    return pd.DataFrame(data=df_dict)",
            "@apply_configs\ndef tables(limit: int=100, catalog_id: Optional[str]=None, database: Optional[str]=None, transaction_id: Optional[str]=None, search_text: Optional[str]=None, name_contains: Optional[str]=None, name_prefix: Optional[str]=None, name_suffix: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Get a DataFrame with tables filtered by a search term, prefix, suffix.\\n\\n    Note\\n    ----\\n    Search feature is not supported for Governed tables.\\n\\n    Parameters\\n    ----------\\n    limit : int, optional\\n        Max number of tables to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    database : str, optional\\n        Database name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    search_text : str, optional\\n        Select only tables with the given string in table's properties.\\n    name_contains : str, optional\\n        Select by a specific string on table name\\n    name_prefix : str, optional\\n        Select by a specific prefix on table name\\n    name_suffix : str, optional\\n        Select by a specific suffix on table name\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    pandas.DataFrame\\n        Pandas DataFrame filled by formatted table information.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_tables = wr.catalog.tables()\\n\\n    \"\n    if search_text is None:\n        table_iter = get_tables(catalog_id=catalog_id, database=database, transaction_id=transaction_id, name_contains=name_contains, name_prefix=name_prefix, name_suffix=name_suffix, boto3_session=boto3_session)\n        tbls: List[Dict[str, Any]] = list(itertools.islice(table_iter, limit))\n    else:\n        tbls = list(search_tables(text=search_text, catalog_id=catalog_id, boto3_session=boto3_session))\n        if database is not None:\n            tbls = [x for x in tbls if x['DatabaseName'] == database]\n        if name_contains is not None:\n            tbls = [x for x in tbls if name_contains in x['Name']]\n        if name_prefix is not None:\n            tbls = [x for x in tbls if x['Name'].startswith(name_prefix)]\n        if name_suffix is not None:\n            tbls = [x for x in tbls if x['Name'].endswith(name_suffix)]\n        tbls = tbls[:limit]\n    df_dict: Dict[str, List[str]] = {'Database': [], 'Table': [], 'Description': [], 'TableType': [], 'Columns': [], 'Partitions': []}\n    for tbl in tbls:\n        df_dict['Database'].append(tbl['DatabaseName'])\n        df_dict['Table'].append(tbl['Name'])\n        df_dict['Description'].append(tbl.get('Description', ''))\n        df_dict['TableType'].append(tbl.get('TableType', ''))\n        try:\n            columns = tbl['StorageDescriptor']['Columns']\n            df_dict['Columns'].append(', '.join([x['Name'] for x in columns]))\n        except KeyError:\n            df_dict['Columns'].append('')\n        if 'PartitionKeys' in tbl:\n            df_dict['Partitions'].append(', '.join([x['Name'] for x in tbl['PartitionKeys']]))\n        else:\n            df_dict['Partitions'].append('')\n    return pd.DataFrame(data=df_dict)",
            "@apply_configs\ndef tables(limit: int=100, catalog_id: Optional[str]=None, database: Optional[str]=None, transaction_id: Optional[str]=None, search_text: Optional[str]=None, name_contains: Optional[str]=None, name_prefix: Optional[str]=None, name_suffix: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Get a DataFrame with tables filtered by a search term, prefix, suffix.\\n\\n    Note\\n    ----\\n    Search feature is not supported for Governed tables.\\n\\n    Parameters\\n    ----------\\n    limit : int, optional\\n        Max number of tables to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    database : str, optional\\n        Database name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    search_text : str, optional\\n        Select only tables with the given string in table's properties.\\n    name_contains : str, optional\\n        Select by a specific string on table name\\n    name_prefix : str, optional\\n        Select by a specific prefix on table name\\n    name_suffix : str, optional\\n        Select by a specific suffix on table name\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    pandas.DataFrame\\n        Pandas DataFrame filled by formatted table information.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_tables = wr.catalog.tables()\\n\\n    \"\n    if search_text is None:\n        table_iter = get_tables(catalog_id=catalog_id, database=database, transaction_id=transaction_id, name_contains=name_contains, name_prefix=name_prefix, name_suffix=name_suffix, boto3_session=boto3_session)\n        tbls: List[Dict[str, Any]] = list(itertools.islice(table_iter, limit))\n    else:\n        tbls = list(search_tables(text=search_text, catalog_id=catalog_id, boto3_session=boto3_session))\n        if database is not None:\n            tbls = [x for x in tbls if x['DatabaseName'] == database]\n        if name_contains is not None:\n            tbls = [x for x in tbls if name_contains in x['Name']]\n        if name_prefix is not None:\n            tbls = [x for x in tbls if x['Name'].startswith(name_prefix)]\n        if name_suffix is not None:\n            tbls = [x for x in tbls if x['Name'].endswith(name_suffix)]\n        tbls = tbls[:limit]\n    df_dict: Dict[str, List[str]] = {'Database': [], 'Table': [], 'Description': [], 'TableType': [], 'Columns': [], 'Partitions': []}\n    for tbl in tbls:\n        df_dict['Database'].append(tbl['DatabaseName'])\n        df_dict['Table'].append(tbl['Name'])\n        df_dict['Description'].append(tbl.get('Description', ''))\n        df_dict['TableType'].append(tbl.get('TableType', ''))\n        try:\n            columns = tbl['StorageDescriptor']['Columns']\n            df_dict['Columns'].append(', '.join([x['Name'] for x in columns]))\n        except KeyError:\n            df_dict['Columns'].append('')\n        if 'PartitionKeys' in tbl:\n            df_dict['Partitions'].append(', '.join([x['Name'] for x in tbl['PartitionKeys']]))\n        else:\n            df_dict['Partitions'].append('')\n    return pd.DataFrame(data=df_dict)",
            "@apply_configs\ndef tables(limit: int=100, catalog_id: Optional[str]=None, database: Optional[str]=None, transaction_id: Optional[str]=None, search_text: Optional[str]=None, name_contains: Optional[str]=None, name_prefix: Optional[str]=None, name_suffix: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Get a DataFrame with tables filtered by a search term, prefix, suffix.\\n\\n    Note\\n    ----\\n    Search feature is not supported for Governed tables.\\n\\n    Parameters\\n    ----------\\n    limit : int, optional\\n        Max number of tables to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    database : str, optional\\n        Database name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    search_text : str, optional\\n        Select only tables with the given string in table's properties.\\n    name_contains : str, optional\\n        Select by a specific string on table name\\n    name_prefix : str, optional\\n        Select by a specific prefix on table name\\n    name_suffix : str, optional\\n        Select by a specific suffix on table name\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    pandas.DataFrame\\n        Pandas DataFrame filled by formatted table information.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_tables = wr.catalog.tables()\\n\\n    \"\n    if search_text is None:\n        table_iter = get_tables(catalog_id=catalog_id, database=database, transaction_id=transaction_id, name_contains=name_contains, name_prefix=name_prefix, name_suffix=name_suffix, boto3_session=boto3_session)\n        tbls: List[Dict[str, Any]] = list(itertools.islice(table_iter, limit))\n    else:\n        tbls = list(search_tables(text=search_text, catalog_id=catalog_id, boto3_session=boto3_session))\n        if database is not None:\n            tbls = [x for x in tbls if x['DatabaseName'] == database]\n        if name_contains is not None:\n            tbls = [x for x in tbls if name_contains in x['Name']]\n        if name_prefix is not None:\n            tbls = [x for x in tbls if x['Name'].startswith(name_prefix)]\n        if name_suffix is not None:\n            tbls = [x for x in tbls if x['Name'].endswith(name_suffix)]\n        tbls = tbls[:limit]\n    df_dict: Dict[str, List[str]] = {'Database': [], 'Table': [], 'Description': [], 'TableType': [], 'Columns': [], 'Partitions': []}\n    for tbl in tbls:\n        df_dict['Database'].append(tbl['DatabaseName'])\n        df_dict['Table'].append(tbl['Name'])\n        df_dict['Description'].append(tbl.get('Description', ''))\n        df_dict['TableType'].append(tbl.get('TableType', ''))\n        try:\n            columns = tbl['StorageDescriptor']['Columns']\n            df_dict['Columns'].append(', '.join([x['Name'] for x in columns]))\n        except KeyError:\n            df_dict['Columns'].append('')\n        if 'PartitionKeys' in tbl:\n            df_dict['Partitions'].append(', '.join([x['Name'] for x in tbl['PartitionKeys']]))\n        else:\n            df_dict['Partitions'].append('')\n    return pd.DataFrame(data=df_dict)",
            "@apply_configs\ndef tables(limit: int=100, catalog_id: Optional[str]=None, database: Optional[str]=None, transaction_id: Optional[str]=None, search_text: Optional[str]=None, name_contains: Optional[str]=None, name_prefix: Optional[str]=None, name_suffix: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Get a DataFrame with tables filtered by a search term, prefix, suffix.\\n\\n    Note\\n    ----\\n    Search feature is not supported for Governed tables.\\n\\n    Parameters\\n    ----------\\n    limit : int, optional\\n        Max number of tables to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    database : str, optional\\n        Database name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    search_text : str, optional\\n        Select only tables with the given string in table's properties.\\n    name_contains : str, optional\\n        Select by a specific string on table name\\n    name_prefix : str, optional\\n        Select by a specific prefix on table name\\n    name_suffix : str, optional\\n        Select by a specific suffix on table name\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    pandas.DataFrame\\n        Pandas DataFrame filled by formatted table information.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_tables = wr.catalog.tables()\\n\\n    \"\n    if search_text is None:\n        table_iter = get_tables(catalog_id=catalog_id, database=database, transaction_id=transaction_id, name_contains=name_contains, name_prefix=name_prefix, name_suffix=name_suffix, boto3_session=boto3_session)\n        tbls: List[Dict[str, Any]] = list(itertools.islice(table_iter, limit))\n    else:\n        tbls = list(search_tables(text=search_text, catalog_id=catalog_id, boto3_session=boto3_session))\n        if database is not None:\n            tbls = [x for x in tbls if x['DatabaseName'] == database]\n        if name_contains is not None:\n            tbls = [x for x in tbls if name_contains in x['Name']]\n        if name_prefix is not None:\n            tbls = [x for x in tbls if x['Name'].startswith(name_prefix)]\n        if name_suffix is not None:\n            tbls = [x for x in tbls if x['Name'].endswith(name_suffix)]\n        tbls = tbls[:limit]\n    df_dict: Dict[str, List[str]] = {'Database': [], 'Table': [], 'Description': [], 'TableType': [], 'Columns': [], 'Partitions': []}\n    for tbl in tbls:\n        df_dict['Database'].append(tbl['DatabaseName'])\n        df_dict['Table'].append(tbl['Name'])\n        df_dict['Description'].append(tbl.get('Description', ''))\n        df_dict['TableType'].append(tbl.get('TableType', ''))\n        try:\n            columns = tbl['StorageDescriptor']['Columns']\n            df_dict['Columns'].append(', '.join([x['Name'] for x in columns]))\n        except KeyError:\n            df_dict['Columns'].append('')\n        if 'PartitionKeys' in tbl:\n            df_dict['Partitions'].append(', '.join([x['Name'] for x in tbl['PartitionKeys']]))\n        else:\n            df_dict['Partitions'].append('')\n    return pd.DataFrame(data=df_dict)"
        ]
    },
    {
        "func_name": "search_tables",
        "original": "def search_tables(text: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    \"\"\"Get Pandas DataFrame of tables filtered by a search string.\n\n    Note\n    ----\n    Search feature is not supported for Governed tables.\n\n    Parameters\n    ----------\n    text : str, optional\n        Select only tables with the given string in table's properties.\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    Iterator[Dict[str, Any]]\n        Iterator of tables.\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> df_tables = wr.catalog.search_tables(text='my_property')\n\n    \"\"\"\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, SearchText=text)\n    response = client_glue.search_tables(**args)\n    for tbl in response['TableList']:\n        yield cast(Dict[str, Any], tbl)\n    while 'NextToken' in response:\n        args['NextToken'] = response['NextToken']\n        response = client_glue.search_tables(**args)\n        for tbl in response['TableList']:\n            yield cast(Dict[str, Any], tbl)",
        "mutated": [
            "def search_tables(text: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    if False:\n        i = 10\n    \"Get Pandas DataFrame of tables filtered by a search string.\\n\\n    Note\\n    ----\\n    Search feature is not supported for Governed tables.\\n\\n    Parameters\\n    ----------\\n    text : str, optional\\n        Select only tables with the given string in table's properties.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Iterator[Dict[str, Any]]\\n        Iterator of tables.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_tables = wr.catalog.search_tables(text='my_property')\\n\\n    \"\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, SearchText=text)\n    response = client_glue.search_tables(**args)\n    for tbl in response['TableList']:\n        yield cast(Dict[str, Any], tbl)\n    while 'NextToken' in response:\n        args['NextToken'] = response['NextToken']\n        response = client_glue.search_tables(**args)\n        for tbl in response['TableList']:\n            yield cast(Dict[str, Any], tbl)",
            "def search_tables(text: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Get Pandas DataFrame of tables filtered by a search string.\\n\\n    Note\\n    ----\\n    Search feature is not supported for Governed tables.\\n\\n    Parameters\\n    ----------\\n    text : str, optional\\n        Select only tables with the given string in table's properties.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Iterator[Dict[str, Any]]\\n        Iterator of tables.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_tables = wr.catalog.search_tables(text='my_property')\\n\\n    \"\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, SearchText=text)\n    response = client_glue.search_tables(**args)\n    for tbl in response['TableList']:\n        yield cast(Dict[str, Any], tbl)\n    while 'NextToken' in response:\n        args['NextToken'] = response['NextToken']\n        response = client_glue.search_tables(**args)\n        for tbl in response['TableList']:\n            yield cast(Dict[str, Any], tbl)",
            "def search_tables(text: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Get Pandas DataFrame of tables filtered by a search string.\\n\\n    Note\\n    ----\\n    Search feature is not supported for Governed tables.\\n\\n    Parameters\\n    ----------\\n    text : str, optional\\n        Select only tables with the given string in table's properties.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Iterator[Dict[str, Any]]\\n        Iterator of tables.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_tables = wr.catalog.search_tables(text='my_property')\\n\\n    \"\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, SearchText=text)\n    response = client_glue.search_tables(**args)\n    for tbl in response['TableList']:\n        yield cast(Dict[str, Any], tbl)\n    while 'NextToken' in response:\n        args['NextToken'] = response['NextToken']\n        response = client_glue.search_tables(**args)\n        for tbl in response['TableList']:\n            yield cast(Dict[str, Any], tbl)",
            "def search_tables(text: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Get Pandas DataFrame of tables filtered by a search string.\\n\\n    Note\\n    ----\\n    Search feature is not supported for Governed tables.\\n\\n    Parameters\\n    ----------\\n    text : str, optional\\n        Select only tables with the given string in table's properties.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Iterator[Dict[str, Any]]\\n        Iterator of tables.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_tables = wr.catalog.search_tables(text='my_property')\\n\\n    \"\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, SearchText=text)\n    response = client_glue.search_tables(**args)\n    for tbl in response['TableList']:\n        yield cast(Dict[str, Any], tbl)\n    while 'NextToken' in response:\n        args['NextToken'] = response['NextToken']\n        response = client_glue.search_tables(**args)\n        for tbl in response['TableList']:\n            yield cast(Dict[str, Any], tbl)",
            "def search_tables(text: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Iterator[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Get Pandas DataFrame of tables filtered by a search string.\\n\\n    Note\\n    ----\\n    Search feature is not supported for Governed tables.\\n\\n    Parameters\\n    ----------\\n    text : str, optional\\n        Select only tables with the given string in table's properties.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Iterator[Dict[str, Any]]\\n        Iterator of tables.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_tables = wr.catalog.search_tables(text='my_property')\\n\\n    \"\n    client_glue = _utils.client('glue', session=boto3_session)\n    args: Dict[str, Any] = _catalog_id(catalog_id=catalog_id, SearchText=text)\n    response = client_glue.search_tables(**args)\n    for tbl in response['TableList']:\n        yield cast(Dict[str, Any], tbl)\n    while 'NextToken' in response:\n        args['NextToken'] = response['NextToken']\n        response = client_glue.search_tables(**args)\n        for tbl in response['TableList']:\n            yield cast(Dict[str, Any], tbl)"
        ]
    },
    {
        "func_name": "table",
        "original": "@apply_configs\ndef table(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    \"\"\"Get table details as Pandas DataFrame.\n\n    Note\n    ----\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\n\n    Parameters\n    ----------\n    database: str\n        Database name.\n    table: str\n        Table name.\n    transaction_id: str, optional\n        The ID of the transaction (i.e. used with GOVERNED tables).\n    query_as_of_time: str, optional\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\n        Cannot be specified alongside transaction_id.\n    catalog_id: str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    boto3_session: boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    pandas.DataFrame\n        Pandas DataFrame filled by formatted table information.\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> df_table = wr.catalog.table(database='default', table='my_table')\n\n    \"\"\"\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    tbl = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))['Table']\n    df_dict: Dict[str, List[Union[str, bool]]] = {'Column Name': [], 'Type': [], 'Partition': [], 'Comment': []}\n    if 'StorageDescriptor' in tbl:\n        for col in tbl['StorageDescriptor'].get('Columns', {}):\n            df_dict['Column Name'].append(col['Name'])\n            df_dict['Type'].append(col['Type'])\n            df_dict['Partition'].append(False)\n            if 'Comment' in col:\n                df_dict['Comment'].append(col['Comment'])\n            else:\n                df_dict['Comment'].append('')\n    if 'PartitionKeys' in tbl:\n        for col in tbl['PartitionKeys']:\n            df_dict['Column Name'].append(col['Name'])\n            df_dict['Type'].append(col['Type'])\n            df_dict['Partition'].append(True)\n            if 'Comment' in col:\n                df_dict['Comment'].append(col['Comment'])\n            else:\n                df_dict['Comment'].append('')\n    return pd.DataFrame(data=df_dict)",
        "mutated": [
            "@apply_configs\ndef table(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n    \"Get table details as Pandas DataFrame.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database: str\\n        Database name.\\n    table: str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id: str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session: boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    pandas.DataFrame\\n        Pandas DataFrame filled by formatted table information.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_table = wr.catalog.table(database='default', table='my_table')\\n\\n    \"\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    tbl = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))['Table']\n    df_dict: Dict[str, List[Union[str, bool]]] = {'Column Name': [], 'Type': [], 'Partition': [], 'Comment': []}\n    if 'StorageDescriptor' in tbl:\n        for col in tbl['StorageDescriptor'].get('Columns', {}):\n            df_dict['Column Name'].append(col['Name'])\n            df_dict['Type'].append(col['Type'])\n            df_dict['Partition'].append(False)\n            if 'Comment' in col:\n                df_dict['Comment'].append(col['Comment'])\n            else:\n                df_dict['Comment'].append('')\n    if 'PartitionKeys' in tbl:\n        for col in tbl['PartitionKeys']:\n            df_dict['Column Name'].append(col['Name'])\n            df_dict['Type'].append(col['Type'])\n            df_dict['Partition'].append(True)\n            if 'Comment' in col:\n                df_dict['Comment'].append(col['Comment'])\n            else:\n                df_dict['Comment'].append('')\n    return pd.DataFrame(data=df_dict)",
            "@apply_configs\ndef table(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Get table details as Pandas DataFrame.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database: str\\n        Database name.\\n    table: str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id: str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session: boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    pandas.DataFrame\\n        Pandas DataFrame filled by formatted table information.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_table = wr.catalog.table(database='default', table='my_table')\\n\\n    \"\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    tbl = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))['Table']\n    df_dict: Dict[str, List[Union[str, bool]]] = {'Column Name': [], 'Type': [], 'Partition': [], 'Comment': []}\n    if 'StorageDescriptor' in tbl:\n        for col in tbl['StorageDescriptor'].get('Columns', {}):\n            df_dict['Column Name'].append(col['Name'])\n            df_dict['Type'].append(col['Type'])\n            df_dict['Partition'].append(False)\n            if 'Comment' in col:\n                df_dict['Comment'].append(col['Comment'])\n            else:\n                df_dict['Comment'].append('')\n    if 'PartitionKeys' in tbl:\n        for col in tbl['PartitionKeys']:\n            df_dict['Column Name'].append(col['Name'])\n            df_dict['Type'].append(col['Type'])\n            df_dict['Partition'].append(True)\n            if 'Comment' in col:\n                df_dict['Comment'].append(col['Comment'])\n            else:\n                df_dict['Comment'].append('')\n    return pd.DataFrame(data=df_dict)",
            "@apply_configs\ndef table(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Get table details as Pandas DataFrame.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database: str\\n        Database name.\\n    table: str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id: str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session: boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    pandas.DataFrame\\n        Pandas DataFrame filled by formatted table information.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_table = wr.catalog.table(database='default', table='my_table')\\n\\n    \"\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    tbl = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))['Table']\n    df_dict: Dict[str, List[Union[str, bool]]] = {'Column Name': [], 'Type': [], 'Partition': [], 'Comment': []}\n    if 'StorageDescriptor' in tbl:\n        for col in tbl['StorageDescriptor'].get('Columns', {}):\n            df_dict['Column Name'].append(col['Name'])\n            df_dict['Type'].append(col['Type'])\n            df_dict['Partition'].append(False)\n            if 'Comment' in col:\n                df_dict['Comment'].append(col['Comment'])\n            else:\n                df_dict['Comment'].append('')\n    if 'PartitionKeys' in tbl:\n        for col in tbl['PartitionKeys']:\n            df_dict['Column Name'].append(col['Name'])\n            df_dict['Type'].append(col['Type'])\n            df_dict['Partition'].append(True)\n            if 'Comment' in col:\n                df_dict['Comment'].append(col['Comment'])\n            else:\n                df_dict['Comment'].append('')\n    return pd.DataFrame(data=df_dict)",
            "@apply_configs\ndef table(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Get table details as Pandas DataFrame.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database: str\\n        Database name.\\n    table: str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id: str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session: boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    pandas.DataFrame\\n        Pandas DataFrame filled by formatted table information.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_table = wr.catalog.table(database='default', table='my_table')\\n\\n    \"\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    tbl = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))['Table']\n    df_dict: Dict[str, List[Union[str, bool]]] = {'Column Name': [], 'Type': [], 'Partition': [], 'Comment': []}\n    if 'StorageDescriptor' in tbl:\n        for col in tbl['StorageDescriptor'].get('Columns', {}):\n            df_dict['Column Name'].append(col['Name'])\n            df_dict['Type'].append(col['Type'])\n            df_dict['Partition'].append(False)\n            if 'Comment' in col:\n                df_dict['Comment'].append(col['Comment'])\n            else:\n                df_dict['Comment'].append('')\n    if 'PartitionKeys' in tbl:\n        for col in tbl['PartitionKeys']:\n            df_dict['Column Name'].append(col['Name'])\n            df_dict['Type'].append(col['Type'])\n            df_dict['Partition'].append(True)\n            if 'Comment' in col:\n                df_dict['Comment'].append(col['Comment'])\n            else:\n                df_dict['Comment'].append('')\n    return pd.DataFrame(data=df_dict)",
            "@apply_configs\ndef table(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> pd.DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Get table details as Pandas DataFrame.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database: str\\n        Database name.\\n    table: str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id: str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session: boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    pandas.DataFrame\\n        Pandas DataFrame filled by formatted table information.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> df_table = wr.catalog.table(database='default', table='my_table')\\n\\n    \"\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    tbl = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))['Table']\n    df_dict: Dict[str, List[Union[str, bool]]] = {'Column Name': [], 'Type': [], 'Partition': [], 'Comment': []}\n    if 'StorageDescriptor' in tbl:\n        for col in tbl['StorageDescriptor'].get('Columns', {}):\n            df_dict['Column Name'].append(col['Name'])\n            df_dict['Type'].append(col['Type'])\n            df_dict['Partition'].append(False)\n            if 'Comment' in col:\n                df_dict['Comment'].append(col['Comment'])\n            else:\n                df_dict['Comment'].append('')\n    if 'PartitionKeys' in tbl:\n        for col in tbl['PartitionKeys']:\n            df_dict['Column Name'].append(col['Name'])\n            df_dict['Type'].append(col['Type'])\n            df_dict['Partition'].append(True)\n            if 'Comment' in col:\n                df_dict['Comment'].append(col['Comment'])\n            else:\n                df_dict['Comment'].append('')\n    return pd.DataFrame(data=df_dict)"
        ]
    },
    {
        "func_name": "get_table_location",
        "original": "@apply_configs\ndef get_table_location(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> str:\n    \"\"\"Get table's location on Glue catalog.\n\n    Note\n    ----\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\n\n    Parameters\n    ----------\n    database: str\n        Database name.\n    table: str\n        Table name.\n    transaction_id: str, optional\n        The ID of the transaction (i.e. used with GOVERNED tables).\n    query_as_of_time: str, optional\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\n        Cannot be specified alongside transaction_id.\n    catalog_id: str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    boto3_session: boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    str\n        Table's location.\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> wr.catalog.get_table_location(database='default', table='my_table')\n    's3://bucket/prefix/'\n\n    \"\"\"\n    client_glue = _utils.client('glue', session=boto3_session)\n    res = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    try:\n        return res['Table']['StorageDescriptor']['Location']\n    except KeyError as ex:\n        raise exceptions.InvalidTable(f'{database}.{table}') from ex",
        "mutated": [
            "@apply_configs\ndef get_table_location(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> str:\n    if False:\n        i = 10\n    \"Get table's location on Glue catalog.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database: str\\n        Database name.\\n    table: str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id: str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session: boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    str\\n        Table's location.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_table_location(database='default', table='my_table')\\n    's3://bucket/prefix/'\\n\\n    \"\n    client_glue = _utils.client('glue', session=boto3_session)\n    res = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    try:\n        return res['Table']['StorageDescriptor']['Location']\n    except KeyError as ex:\n        raise exceptions.InvalidTable(f'{database}.{table}') from ex",
            "@apply_configs\ndef get_table_location(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Get table's location on Glue catalog.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database: str\\n        Database name.\\n    table: str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id: str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session: boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    str\\n        Table's location.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_table_location(database='default', table='my_table')\\n    's3://bucket/prefix/'\\n\\n    \"\n    client_glue = _utils.client('glue', session=boto3_session)\n    res = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    try:\n        return res['Table']['StorageDescriptor']['Location']\n    except KeyError as ex:\n        raise exceptions.InvalidTable(f'{database}.{table}') from ex",
            "@apply_configs\ndef get_table_location(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Get table's location on Glue catalog.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database: str\\n        Database name.\\n    table: str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id: str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session: boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    str\\n        Table's location.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_table_location(database='default', table='my_table')\\n    's3://bucket/prefix/'\\n\\n    \"\n    client_glue = _utils.client('glue', session=boto3_session)\n    res = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    try:\n        return res['Table']['StorageDescriptor']['Location']\n    except KeyError as ex:\n        raise exceptions.InvalidTable(f'{database}.{table}') from ex",
            "@apply_configs\ndef get_table_location(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Get table's location on Glue catalog.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database: str\\n        Database name.\\n    table: str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id: str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session: boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    str\\n        Table's location.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_table_location(database='default', table='my_table')\\n    's3://bucket/prefix/'\\n\\n    \"\n    client_glue = _utils.client('glue', session=boto3_session)\n    res = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    try:\n        return res['Table']['StorageDescriptor']['Location']\n    except KeyError as ex:\n        raise exceptions.InvalidTable(f'{database}.{table}') from ex",
            "@apply_configs\ndef get_table_location(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Get table's location on Glue catalog.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database: str\\n        Database name.\\n    table: str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id: str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session: boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    str\\n        Table's location.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_table_location(database='default', table='my_table')\\n    's3://bucket/prefix/'\\n\\n    \"\n    client_glue = _utils.client('glue', session=boto3_session)\n    res = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    try:\n        return res['Table']['StorageDescriptor']['Location']\n    except KeyError as ex:\n        raise exceptions.InvalidTable(f'{database}.{table}') from ex"
        ]
    },
    {
        "func_name": "get_connection",
        "original": "def get_connection(name: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, Any]:\n    \"\"\"Get Glue connection details.\n\n    Parameters\n    ----------\n    name : str\n        Connection name.\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    Dict[str, Any]\n        API Response for:\n        https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_connection\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> res = wr.catalog.get_connection(name='my_connection')\n\n    \"\"\"\n    client_glue = _utils.client('glue', session=boto3_session)\n    res = _utils.try_it(f=client_glue.get_connection, ex=botocore.exceptions.ClientError, ex_code='ThrottlingException', max_num_tries=3, **_catalog_id(catalog_id=catalog_id, Name=name, HidePassword=False))['Connection']\n    if 'ENCRYPTED_PASSWORD' in res['ConnectionProperties']:\n        client_kms = _utils.client(service_name='kms', session=boto3_session)\n        pwd = client_kms.decrypt(CiphertextBlob=base64.b64decode(res['ConnectionProperties']['ENCRYPTED_PASSWORD']))['Plaintext'].decode('utf-8')\n        res['ConnectionProperties']['PASSWORD'] = pwd\n    return cast(Dict[str, Any], res)",
        "mutated": [
            "def get_connection(name: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, Any]:\n    if False:\n        i = 10\n    \"Get Glue connection details.\\n\\n    Parameters\\n    ----------\\n    name : str\\n        Connection name.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, Any]\\n        API Response for:\\n        https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_connection\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> res = wr.catalog.get_connection(name='my_connection')\\n\\n    \"\n    client_glue = _utils.client('glue', session=boto3_session)\n    res = _utils.try_it(f=client_glue.get_connection, ex=botocore.exceptions.ClientError, ex_code='ThrottlingException', max_num_tries=3, **_catalog_id(catalog_id=catalog_id, Name=name, HidePassword=False))['Connection']\n    if 'ENCRYPTED_PASSWORD' in res['ConnectionProperties']:\n        client_kms = _utils.client(service_name='kms', session=boto3_session)\n        pwd = client_kms.decrypt(CiphertextBlob=base64.b64decode(res['ConnectionProperties']['ENCRYPTED_PASSWORD']))['Plaintext'].decode('utf-8')\n        res['ConnectionProperties']['PASSWORD'] = pwd\n    return cast(Dict[str, Any], res)",
            "def get_connection(name: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Get Glue connection details.\\n\\n    Parameters\\n    ----------\\n    name : str\\n        Connection name.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, Any]\\n        API Response for:\\n        https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_connection\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> res = wr.catalog.get_connection(name='my_connection')\\n\\n    \"\n    client_glue = _utils.client('glue', session=boto3_session)\n    res = _utils.try_it(f=client_glue.get_connection, ex=botocore.exceptions.ClientError, ex_code='ThrottlingException', max_num_tries=3, **_catalog_id(catalog_id=catalog_id, Name=name, HidePassword=False))['Connection']\n    if 'ENCRYPTED_PASSWORD' in res['ConnectionProperties']:\n        client_kms = _utils.client(service_name='kms', session=boto3_session)\n        pwd = client_kms.decrypt(CiphertextBlob=base64.b64decode(res['ConnectionProperties']['ENCRYPTED_PASSWORD']))['Plaintext'].decode('utf-8')\n        res['ConnectionProperties']['PASSWORD'] = pwd\n    return cast(Dict[str, Any], res)",
            "def get_connection(name: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Get Glue connection details.\\n\\n    Parameters\\n    ----------\\n    name : str\\n        Connection name.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, Any]\\n        API Response for:\\n        https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_connection\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> res = wr.catalog.get_connection(name='my_connection')\\n\\n    \"\n    client_glue = _utils.client('glue', session=boto3_session)\n    res = _utils.try_it(f=client_glue.get_connection, ex=botocore.exceptions.ClientError, ex_code='ThrottlingException', max_num_tries=3, **_catalog_id(catalog_id=catalog_id, Name=name, HidePassword=False))['Connection']\n    if 'ENCRYPTED_PASSWORD' in res['ConnectionProperties']:\n        client_kms = _utils.client(service_name='kms', session=boto3_session)\n        pwd = client_kms.decrypt(CiphertextBlob=base64.b64decode(res['ConnectionProperties']['ENCRYPTED_PASSWORD']))['Plaintext'].decode('utf-8')\n        res['ConnectionProperties']['PASSWORD'] = pwd\n    return cast(Dict[str, Any], res)",
            "def get_connection(name: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Get Glue connection details.\\n\\n    Parameters\\n    ----------\\n    name : str\\n        Connection name.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, Any]\\n        API Response for:\\n        https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_connection\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> res = wr.catalog.get_connection(name='my_connection')\\n\\n    \"\n    client_glue = _utils.client('glue', session=boto3_session)\n    res = _utils.try_it(f=client_glue.get_connection, ex=botocore.exceptions.ClientError, ex_code='ThrottlingException', max_num_tries=3, **_catalog_id(catalog_id=catalog_id, Name=name, HidePassword=False))['Connection']\n    if 'ENCRYPTED_PASSWORD' in res['ConnectionProperties']:\n        client_kms = _utils.client(service_name='kms', session=boto3_session)\n        pwd = client_kms.decrypt(CiphertextBlob=base64.b64decode(res['ConnectionProperties']['ENCRYPTED_PASSWORD']))['Plaintext'].decode('utf-8')\n        res['ConnectionProperties']['PASSWORD'] = pwd\n    return cast(Dict[str, Any], res)",
            "def get_connection(name: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Get Glue connection details.\\n\\n    Parameters\\n    ----------\\n    name : str\\n        Connection name.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, Any]\\n        API Response for:\\n        https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_connection\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> res = wr.catalog.get_connection(name='my_connection')\\n\\n    \"\n    client_glue = _utils.client('glue', session=boto3_session)\n    res = _utils.try_it(f=client_glue.get_connection, ex=botocore.exceptions.ClientError, ex_code='ThrottlingException', max_num_tries=3, **_catalog_id(catalog_id=catalog_id, Name=name, HidePassword=False))['Connection']\n    if 'ENCRYPTED_PASSWORD' in res['ConnectionProperties']:\n        client_kms = _utils.client(service_name='kms', session=boto3_session)\n        pwd = client_kms.decrypt(CiphertextBlob=base64.b64decode(res['ConnectionProperties']['ENCRYPTED_PASSWORD']))['Plaintext'].decode('utf-8')\n        res['ConnectionProperties']['PASSWORD'] = pwd\n    return cast(Dict[str, Any], res)"
        ]
    },
    {
        "func_name": "get_parquet_partitions",
        "original": "@apply_configs\ndef get_parquet_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    \"\"\"Get all partitions from a Table in the AWS Glue Catalog.\n\n    Expression argument instructions:\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\n\n    Parameters\n    ----------\n    database : str\n        Database name.\n    table : str\n        Table name.\n    expression : str, optional\n        An expression that filters the partitions to be returned.\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    Dict[str, List[str]]\n        partitions_values: Dictionary with keys as S3 path locations and values as a\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\n\n    Examples\n    --------\n    Fetch all partitions\n\n    >>> import awswrangler as wr\n    >>> wr.catalog.get_parquet_partitions(\n    ...     database='default',\n    ...     table='my_table',\n    ... )\n    {\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\n    }\n\n    Filtering partitions\n\n    >>> import awswrangler as wr\n    >>> wr.catalog.get_parquet_partitions(\n    ...     database='default',\n    ...     table='my_table',\n    ...     expression='m=10'\n    ... )\n    {\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\n    }\n\n    \"\"\"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)",
        "mutated": [
            "@apply_configs\ndef get_parquet_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n    \"Get all partitions from a Table in the AWS Glue Catalog.\\n\\n    Expression argument instructions:\\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    expression : str, optional\\n        An expression that filters the partitions to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, List[str]]\\n        partitions_values: Dictionary with keys as S3 path locations and values as a\\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\\n\\n    Examples\\n    --------\\n    Fetch all partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_parquet_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\\n    }\\n\\n    Filtering partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_parquet_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ...     expression='m=10'\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\\n    }\\n\\n    \"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)",
            "@apply_configs\ndef get_parquet_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Get all partitions from a Table in the AWS Glue Catalog.\\n\\n    Expression argument instructions:\\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    expression : str, optional\\n        An expression that filters the partitions to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, List[str]]\\n        partitions_values: Dictionary with keys as S3 path locations and values as a\\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\\n\\n    Examples\\n    --------\\n    Fetch all partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_parquet_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\\n    }\\n\\n    Filtering partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_parquet_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ...     expression='m=10'\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\\n    }\\n\\n    \"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)",
            "@apply_configs\ndef get_parquet_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Get all partitions from a Table in the AWS Glue Catalog.\\n\\n    Expression argument instructions:\\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    expression : str, optional\\n        An expression that filters the partitions to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, List[str]]\\n        partitions_values: Dictionary with keys as S3 path locations and values as a\\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\\n\\n    Examples\\n    --------\\n    Fetch all partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_parquet_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\\n    }\\n\\n    Filtering partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_parquet_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ...     expression='m=10'\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\\n    }\\n\\n    \"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)",
            "@apply_configs\ndef get_parquet_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Get all partitions from a Table in the AWS Glue Catalog.\\n\\n    Expression argument instructions:\\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    expression : str, optional\\n        An expression that filters the partitions to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, List[str]]\\n        partitions_values: Dictionary with keys as S3 path locations and values as a\\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\\n\\n    Examples\\n    --------\\n    Fetch all partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_parquet_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\\n    }\\n\\n    Filtering partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_parquet_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ...     expression='m=10'\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\\n    }\\n\\n    \"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)",
            "@apply_configs\ndef get_parquet_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Get all partitions from a Table in the AWS Glue Catalog.\\n\\n    Expression argument instructions:\\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    expression : str, optional\\n        An expression that filters the partitions to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, List[str]]\\n        partitions_values: Dictionary with keys as S3 path locations and values as a\\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\\n\\n    Examples\\n    --------\\n    Fetch all partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_parquet_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\\n    }\\n\\n    Filtering partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_parquet_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ...     expression='m=10'\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\\n    }\\n\\n    \"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)"
        ]
    },
    {
        "func_name": "get_csv_partitions",
        "original": "@apply_configs\ndef get_csv_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    \"\"\"Get all partitions from a Table in the AWS Glue Catalog.\n\n    Expression argument instructions:\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\n\n    Parameters\n    ----------\n    database : str\n        Database name.\n    table : str\n        Table name.\n    expression : str, optional\n        An expression that filters the partitions to be returned.\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    Dict[str, List[str]]\n        partitions_values: Dictionary with keys as S3 path locations and values as a\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\n\n    Examples\n    --------\n    Fetch all partitions\n\n    >>> import awswrangler as wr\n    >>> wr.catalog.get_csv_partitions(\n    ...     database='default',\n    ...     table='my_table',\n    ... )\n    {\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\n    }\n\n    Filtering partitions\n\n    >>> import awswrangler as wr\n    >>> wr.catalog.get_csv_partitions(\n    ...     database='default',\n    ...     table='my_table',\n    ...     expression='m=10'\n    ... )\n    {\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\n    }\n\n    \"\"\"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)",
        "mutated": [
            "@apply_configs\ndef get_csv_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n    \"Get all partitions from a Table in the AWS Glue Catalog.\\n\\n    Expression argument instructions:\\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    expression : str, optional\\n        An expression that filters the partitions to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, List[str]]\\n        partitions_values: Dictionary with keys as S3 path locations and values as a\\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\\n\\n    Examples\\n    --------\\n    Fetch all partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_csv_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\\n    }\\n\\n    Filtering partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_csv_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ...     expression='m=10'\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\\n    }\\n\\n    \"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)",
            "@apply_configs\ndef get_csv_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Get all partitions from a Table in the AWS Glue Catalog.\\n\\n    Expression argument instructions:\\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    expression : str, optional\\n        An expression that filters the partitions to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, List[str]]\\n        partitions_values: Dictionary with keys as S3 path locations and values as a\\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\\n\\n    Examples\\n    --------\\n    Fetch all partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_csv_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\\n    }\\n\\n    Filtering partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_csv_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ...     expression='m=10'\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\\n    }\\n\\n    \"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)",
            "@apply_configs\ndef get_csv_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Get all partitions from a Table in the AWS Glue Catalog.\\n\\n    Expression argument instructions:\\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    expression : str, optional\\n        An expression that filters the partitions to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, List[str]]\\n        partitions_values: Dictionary with keys as S3 path locations and values as a\\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\\n\\n    Examples\\n    --------\\n    Fetch all partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_csv_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\\n    }\\n\\n    Filtering partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_csv_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ...     expression='m=10'\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\\n    }\\n\\n    \"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)",
            "@apply_configs\ndef get_csv_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Get all partitions from a Table in the AWS Glue Catalog.\\n\\n    Expression argument instructions:\\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    expression : str, optional\\n        An expression that filters the partitions to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, List[str]]\\n        partitions_values: Dictionary with keys as S3 path locations and values as a\\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\\n\\n    Examples\\n    --------\\n    Fetch all partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_csv_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\\n    }\\n\\n    Filtering partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_csv_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ...     expression='m=10'\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\\n    }\\n\\n    \"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)",
            "@apply_configs\ndef get_csv_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Get all partitions from a Table in the AWS Glue Catalog.\\n\\n    Expression argument instructions:\\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    expression : str, optional\\n        An expression that filters the partitions to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, List[str]]\\n        partitions_values: Dictionary with keys as S3 path locations and values as a\\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\\n\\n    Examples\\n    --------\\n    Fetch all partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_csv_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\\n    }\\n\\n    Filtering partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_csv_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ...     expression='m=10'\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\\n    }\\n\\n    \"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)"
        ]
    },
    {
        "func_name": "get_partitions",
        "original": "@apply_configs\ndef get_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    \"\"\"Get all partitions from a Table in the AWS Glue Catalog.\n\n    Expression argument instructions:\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\n\n    Parameters\n    ----------\n    database : str\n        Database name.\n    table : str\n        Table name.\n    expression : str, optional\n        An expression that filters the partitions to be returned.\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    Dict[str, List[str]]\n        partitions_values: Dictionary with keys as S3 path locations and values as a\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\n\n    Examples\n    --------\n    Fetch all partitions\n\n    >>> import awswrangler as wr\n    >>> wr.catalog.get_partitions(\n    ...     database='default',\n    ...     table='my_table',\n    ... )\n    {\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\n    }\n\n    Filtering partitions\n\n    >>> import awswrangler as wr\n    >>> wr.catalog.get_partitions(\n    ...     database='default',\n    ...     table='my_table',\n    ...     expression='m=10'\n    ... )\n    {\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\n    }\n\n    \"\"\"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)",
        "mutated": [
            "@apply_configs\ndef get_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n    \"Get all partitions from a Table in the AWS Glue Catalog.\\n\\n    Expression argument instructions:\\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    expression : str, optional\\n        An expression that filters the partitions to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, List[str]]\\n        partitions_values: Dictionary with keys as S3 path locations and values as a\\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\\n\\n    Examples\\n    --------\\n    Fetch all partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\\n    }\\n\\n    Filtering partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ...     expression='m=10'\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\\n    }\\n\\n    \"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)",
            "@apply_configs\ndef get_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Get all partitions from a Table in the AWS Glue Catalog.\\n\\n    Expression argument instructions:\\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    expression : str, optional\\n        An expression that filters the partitions to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, List[str]]\\n        partitions_values: Dictionary with keys as S3 path locations and values as a\\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\\n\\n    Examples\\n    --------\\n    Fetch all partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\\n    }\\n\\n    Filtering partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ...     expression='m=10'\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\\n    }\\n\\n    \"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)",
            "@apply_configs\ndef get_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Get all partitions from a Table in the AWS Glue Catalog.\\n\\n    Expression argument instructions:\\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    expression : str, optional\\n        An expression that filters the partitions to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, List[str]]\\n        partitions_values: Dictionary with keys as S3 path locations and values as a\\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\\n\\n    Examples\\n    --------\\n    Fetch all partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\\n    }\\n\\n    Filtering partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ...     expression='m=10'\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\\n    }\\n\\n    \"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)",
            "@apply_configs\ndef get_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Get all partitions from a Table in the AWS Glue Catalog.\\n\\n    Expression argument instructions:\\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    expression : str, optional\\n        An expression that filters the partitions to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, List[str]]\\n        partitions_values: Dictionary with keys as S3 path locations and values as a\\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\\n\\n    Examples\\n    --------\\n    Fetch all partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\\n    }\\n\\n    Filtering partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ...     expression='m=10'\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\\n    }\\n\\n    \"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)",
            "@apply_configs\ndef get_partitions(database: str, table: str, expression: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Get all partitions from a Table in the AWS Glue Catalog.\\n\\n    Expression argument instructions:\\n    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_partitions\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    expression : str, optional\\n        An expression that filters the partitions to be returned.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, List[str]]\\n        partitions_values: Dictionary with keys as S3 path locations and values as a\\n        list of partitions values as str (e.g. {'s3://bucket/prefix/y=2020/m=10/': ['2020', '10']}).\\n\\n    Examples\\n    --------\\n    Fetch all partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10'],\\n        's3://bucket/prefix/y=2020/m=11/': ['2020', '11'],\\n        's3://bucket/prefix/y=2020/m=12/': ['2020', '12']\\n    }\\n\\n    Filtering partitions\\n\\n    >>> import awswrangler as wr\\n    >>> wr.catalog.get_partitions(\\n    ...     database='default',\\n    ...     table='my_table',\\n    ...     expression='m=10'\\n    ... )\\n    {\\n        's3://bucket/prefix/y=2020/m=10/': ['2020', '10']\\n    }\\n\\n    \"\n    return _get_partitions(database=database, table=table, expression=expression, catalog_id=catalog_id, boto3_session=boto3_session)"
        ]
    },
    {
        "func_name": "get_table_parameters",
        "original": "def get_table_parameters(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, str]:\n    \"\"\"Get all parameters.\n\n    Note\n    ----\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\n\n    Parameters\n    ----------\n    database : str\n        Database name.\n    table : str\n        Table name.\n    transaction_id: str, optional\n        The ID of the transaction (i.e. used with GOVERNED tables).\n    query_as_of_time : str, optional\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\n        Cannot be specified alongside transaction_id.\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    Dict[str, str]\n        Dictionary of parameters.\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> pars = wr.catalog.get_table_parameters(database=\"...\", table=\"...\")\n\n    \"\"\"\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    parameters: Dict[str, str] = response['Table']['Parameters']\n    return parameters",
        "mutated": [
            "def get_table_parameters(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, str]:\n    if False:\n        i = 10\n    'Get all parameters.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time : str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, str]\\n        Dictionary of parameters.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> pars = wr.catalog.get_table_parameters(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    parameters: Dict[str, str] = response['Table']['Parameters']\n    return parameters",
            "def get_table_parameters(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get all parameters.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time : str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, str]\\n        Dictionary of parameters.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> pars = wr.catalog.get_table_parameters(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    parameters: Dict[str, str] = response['Table']['Parameters']\n    return parameters",
            "def get_table_parameters(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get all parameters.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time : str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, str]\\n        Dictionary of parameters.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> pars = wr.catalog.get_table_parameters(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    parameters: Dict[str, str] = response['Table']['Parameters']\n    return parameters",
            "def get_table_parameters(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get all parameters.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time : str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, str]\\n        Dictionary of parameters.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> pars = wr.catalog.get_table_parameters(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    parameters: Dict[str, str] = response['Table']['Parameters']\n    return parameters",
            "def get_table_parameters(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get all parameters.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time : str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, str]\\n        Dictionary of parameters.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> pars = wr.catalog.get_table_parameters(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    parameters: Dict[str, str] = response['Table']['Parameters']\n    return parameters"
        ]
    },
    {
        "func_name": "get_table_description",
        "original": "def get_table_description(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Optional[str]:\n    \"\"\"Get table description.\n\n    Note\n    ----\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\n\n    Parameters\n    ----------\n    database : str\n        Database name.\n    table : str\n        Table name.\n    transaction_id: str, optional\n        The ID of the transaction (i.e. used with GOVERNED tables).\n    query_as_of_time: str, optional\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\n        Cannot be specified alongside transaction_id.\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    Optional[str]\n        Description if exists.\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> desc = wr.catalog.get_table_description(database=\"...\", table=\"...\")\n\n    \"\"\"\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    desc: Optional[str] = response['Table'].get('Description', None)\n    return desc",
        "mutated": [
            "def get_table_description(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Optional[str]:\n    if False:\n        i = 10\n    'Get table description.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Optional[str]\\n        Description if exists.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> desc = wr.catalog.get_table_description(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    desc: Optional[str] = response['Table'].get('Description', None)\n    return desc",
            "def get_table_description(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Optional[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get table description.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Optional[str]\\n        Description if exists.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> desc = wr.catalog.get_table_description(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    desc: Optional[str] = response['Table'].get('Description', None)\n    return desc",
            "def get_table_description(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Optional[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get table description.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Optional[str]\\n        Description if exists.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> desc = wr.catalog.get_table_description(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    desc: Optional[str] = response['Table'].get('Description', None)\n    return desc",
            "def get_table_description(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Optional[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get table description.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Optional[str]\\n        Description if exists.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> desc = wr.catalog.get_table_description(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    desc: Optional[str] = response['Table'].get('Description', None)\n    return desc",
            "def get_table_description(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Optional[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get table description.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Optional[str]\\n        Description if exists.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> desc = wr.catalog.get_table_description(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    desc: Optional[str] = response['Table'].get('Description', None)\n    return desc"
        ]
    },
    {
        "func_name": "get_columns_comments",
        "original": "@apply_configs\ndef get_columns_comments(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, Optional[str]]:\n    \"\"\"Get all columns comments.\n\n    Note\n    ----\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\n\n    Parameters\n    ----------\n    database : str\n        Database name.\n    table : str\n        Table name.\n    transaction_id: str, optional\n        The ID of the transaction (i.e. used with GOVERNED tables).\n    query_as_of_time: str, optional\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\n        Cannot be specified alongside transaction_id.\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    Dict[str, Optional[str]]\n        Columns comments. e.g. {\"col1\": \"foo boo bar\", \"col2\": None}.\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> pars = wr.catalog.get_columns_comments(database=\"...\", table=\"...\")\n\n    \"\"\"\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    comments: Dict[str, Optional[str]] = {}\n    for c in response['Table']['StorageDescriptor']['Columns']:\n        comments[c['Name']] = c.get('Comment')\n    if 'PartitionKeys' in response['Table']:\n        for p in response['Table']['PartitionKeys']:\n            comments[p['Name']] = p.get('Comment')\n    return comments",
        "mutated": [
            "@apply_configs\ndef get_columns_comments(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, Optional[str]]:\n    if False:\n        i = 10\n    'Get all columns comments.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, Optional[str]]\\n        Columns comments. e.g. {\"col1\": \"foo boo bar\", \"col2\": None}.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> pars = wr.catalog.get_columns_comments(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    comments: Dict[str, Optional[str]] = {}\n    for c in response['Table']['StorageDescriptor']['Columns']:\n        comments[c['Name']] = c.get('Comment')\n    if 'PartitionKeys' in response['Table']:\n        for p in response['Table']['PartitionKeys']:\n            comments[p['Name']] = p.get('Comment')\n    return comments",
            "@apply_configs\ndef get_columns_comments(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, Optional[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get all columns comments.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, Optional[str]]\\n        Columns comments. e.g. {\"col1\": \"foo boo bar\", \"col2\": None}.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> pars = wr.catalog.get_columns_comments(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    comments: Dict[str, Optional[str]] = {}\n    for c in response['Table']['StorageDescriptor']['Columns']:\n        comments[c['Name']] = c.get('Comment')\n    if 'PartitionKeys' in response['Table']:\n        for p in response['Table']['PartitionKeys']:\n            comments[p['Name']] = p.get('Comment')\n    return comments",
            "@apply_configs\ndef get_columns_comments(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, Optional[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get all columns comments.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, Optional[str]]\\n        Columns comments. e.g. {\"col1\": \"foo boo bar\", \"col2\": None}.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> pars = wr.catalog.get_columns_comments(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    comments: Dict[str, Optional[str]] = {}\n    for c in response['Table']['StorageDescriptor']['Columns']:\n        comments[c['Name']] = c.get('Comment')\n    if 'PartitionKeys' in response['Table']:\n        for p in response['Table']['PartitionKeys']:\n            comments[p['Name']] = p.get('Comment')\n    return comments",
            "@apply_configs\ndef get_columns_comments(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, Optional[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get all columns comments.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, Optional[str]]\\n        Columns comments. e.g. {\"col1\": \"foo boo bar\", \"col2\": None}.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> pars = wr.catalog.get_columns_comments(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    comments: Dict[str, Optional[str]] = {}\n    for c in response['Table']['StorageDescriptor']['Columns']:\n        comments[c['Name']] = c.get('Comment')\n    if 'PartitionKeys' in response['Table']:\n        for p in response['Table']['PartitionKeys']:\n            comments[p['Name']] = p.get('Comment')\n    return comments",
            "@apply_configs\ndef get_columns_comments(database: str, table: str, transaction_id: Optional[str]=None, query_as_of_time: Optional[str]=None, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> Dict[str, Optional[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get all columns comments.\\n\\n    Note\\n    ----\\n    If reading from a governed table, pass only one of `transaction_id` or `query_as_of_time`.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    transaction_id: str, optional\\n        The ID of the transaction (i.e. used with GOVERNED tables).\\n    query_as_of_time: str, optional\\n        The time as of when to read the table contents. Must be a valid Unix epoch timestamp.\\n        Cannot be specified alongside transaction_id.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    Dict[str, Optional[str]]\\n        Columns comments. e.g. {\"col1\": \"foo boo bar\", \"col2\": None}.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> pars = wr.catalog.get_columns_comments(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    response = client_glue.get_table(**_catalog_id(catalog_id=catalog_id, **_transaction_id(transaction_id=transaction_id, query_as_of_time=query_as_of_time, DatabaseName=database, Name=table)))\n    comments: Dict[str, Optional[str]] = {}\n    for c in response['Table']['StorageDescriptor']['Columns']:\n        comments[c['Name']] = c.get('Comment')\n    if 'PartitionKeys' in response['Table']:\n        for p in response['Table']['PartitionKeys']:\n            comments[p['Name']] = p.get('Comment')\n    return comments"
        ]
    },
    {
        "func_name": "get_table_versions",
        "original": "@apply_configs\ndef get_table_versions(database: str, table: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> List[Dict[str, Any]]:\n    \"\"\"Get all versions.\n\n    Parameters\n    ----------\n    database : str\n        Database name.\n    table : str\n        Table name.\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    List[Dict[str, Any]\n        List of table inputs:\n        https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_table_versions\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> tables_versions = wr.catalog.get_table_versions(database=\"...\", table=\"...\")\n\n    \"\"\"\n    client_glue = _utils.client('glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_table_versions')\n    versions: List[Dict[str, Any]] = []\n    response_iterator = paginator.paginate(**_catalog_id(DatabaseName=database, TableName=table, catalog_id=catalog_id))\n    for page in response_iterator:\n        for tbl in page['TableVersions']:\n            versions.append(cast(Dict[str, Any], tbl))\n    return versions",
        "mutated": [
            "@apply_configs\ndef get_table_versions(database: str, table: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n    'Get all versions.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    List[Dict[str, Any]\\n        List of table inputs:\\n        https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_table_versions\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> tables_versions = wr.catalog.get_table_versions(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_table_versions')\n    versions: List[Dict[str, Any]] = []\n    response_iterator = paginator.paginate(**_catalog_id(DatabaseName=database, TableName=table, catalog_id=catalog_id))\n    for page in response_iterator:\n        for tbl in page['TableVersions']:\n            versions.append(cast(Dict[str, Any], tbl))\n    return versions",
            "@apply_configs\ndef get_table_versions(database: str, table: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get all versions.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    List[Dict[str, Any]\\n        List of table inputs:\\n        https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_table_versions\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> tables_versions = wr.catalog.get_table_versions(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_table_versions')\n    versions: List[Dict[str, Any]] = []\n    response_iterator = paginator.paginate(**_catalog_id(DatabaseName=database, TableName=table, catalog_id=catalog_id))\n    for page in response_iterator:\n        for tbl in page['TableVersions']:\n            versions.append(cast(Dict[str, Any], tbl))\n    return versions",
            "@apply_configs\ndef get_table_versions(database: str, table: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get all versions.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    List[Dict[str, Any]\\n        List of table inputs:\\n        https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_table_versions\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> tables_versions = wr.catalog.get_table_versions(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_table_versions')\n    versions: List[Dict[str, Any]] = []\n    response_iterator = paginator.paginate(**_catalog_id(DatabaseName=database, TableName=table, catalog_id=catalog_id))\n    for page in response_iterator:\n        for tbl in page['TableVersions']:\n            versions.append(cast(Dict[str, Any], tbl))\n    return versions",
            "@apply_configs\ndef get_table_versions(database: str, table: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get all versions.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    List[Dict[str, Any]\\n        List of table inputs:\\n        https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_table_versions\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> tables_versions = wr.catalog.get_table_versions(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_table_versions')\n    versions: List[Dict[str, Any]] = []\n    response_iterator = paginator.paginate(**_catalog_id(DatabaseName=database, TableName=table, catalog_id=catalog_id))\n    for page in response_iterator:\n        for tbl in page['TableVersions']:\n            versions.append(cast(Dict[str, Any], tbl))\n    return versions",
            "@apply_configs\ndef get_table_versions(database: str, table: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get all versions.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    List[Dict[str, Any]\\n        List of table inputs:\\n        https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/glue.html#Glue.Client.get_table_versions\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> tables_versions = wr.catalog.get_table_versions(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client('glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_table_versions')\n    versions: List[Dict[str, Any]] = []\n    response_iterator = paginator.paginate(**_catalog_id(DatabaseName=database, TableName=table, catalog_id=catalog_id))\n    for page in response_iterator:\n        for tbl in page['TableVersions']:\n            versions.append(cast(Dict[str, Any], tbl))\n    return versions"
        ]
    },
    {
        "func_name": "get_table_number_of_versions",
        "original": "@apply_configs\ndef get_table_number_of_versions(database: str, table: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> int:\n    \"\"\"Get total number of versions.\n\n    Parameters\n    ----------\n    database : str\n        Database name.\n    table : str\n        Table name.\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    int\n        Total number of versions.\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> num = wr.catalog.get_table_number_of_versions(database=\"...\", table=\"...\")\n\n    \"\"\"\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_table_versions')\n    count: int = 0\n    response_iterator = paginator.paginate(**_catalog_id(DatabaseName=database, TableName=table, catalog_id=catalog_id))\n    for page in response_iterator:\n        count += len(page['TableVersions'])\n    return count",
        "mutated": [
            "@apply_configs\ndef get_table_number_of_versions(database: str, table: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> int:\n    if False:\n        i = 10\n    'Get total number of versions.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    int\\n        Total number of versions.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> num = wr.catalog.get_table_number_of_versions(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_table_versions')\n    count: int = 0\n    response_iterator = paginator.paginate(**_catalog_id(DatabaseName=database, TableName=table, catalog_id=catalog_id))\n    for page in response_iterator:\n        count += len(page['TableVersions'])\n    return count",
            "@apply_configs\ndef get_table_number_of_versions(database: str, table: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get total number of versions.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    int\\n        Total number of versions.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> num = wr.catalog.get_table_number_of_versions(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_table_versions')\n    count: int = 0\n    response_iterator = paginator.paginate(**_catalog_id(DatabaseName=database, TableName=table, catalog_id=catalog_id))\n    for page in response_iterator:\n        count += len(page['TableVersions'])\n    return count",
            "@apply_configs\ndef get_table_number_of_versions(database: str, table: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get total number of versions.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    int\\n        Total number of versions.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> num = wr.catalog.get_table_number_of_versions(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_table_versions')\n    count: int = 0\n    response_iterator = paginator.paginate(**_catalog_id(DatabaseName=database, TableName=table, catalog_id=catalog_id))\n    for page in response_iterator:\n        count += len(page['TableVersions'])\n    return count",
            "@apply_configs\ndef get_table_number_of_versions(database: str, table: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get total number of versions.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    int\\n        Total number of versions.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> num = wr.catalog.get_table_number_of_versions(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_table_versions')\n    count: int = 0\n    response_iterator = paginator.paginate(**_catalog_id(DatabaseName=database, TableName=table, catalog_id=catalog_id))\n    for page in response_iterator:\n        count += len(page['TableVersions'])\n    return count",
            "@apply_configs\ndef get_table_number_of_versions(database: str, table: str, catalog_id: Optional[str]=None, boto3_session: Optional[boto3.Session]=None) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get total number of versions.\\n\\n    Parameters\\n    ----------\\n    database : str\\n        Database name.\\n    table : str\\n        Table name.\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n\\n    Returns\\n    -------\\n    int\\n        Total number of versions.\\n\\n    Examples\\n    --------\\n    >>> import awswrangler as wr\\n    >>> num = wr.catalog.get_table_number_of_versions(database=\"...\", table=\"...\")\\n\\n    '\n    client_glue = _utils.client(service_name='glue', session=boto3_session)\n    paginator = client_glue.get_paginator('get_table_versions')\n    count: int = 0\n    response_iterator = paginator.paginate(**_catalog_id(DatabaseName=database, TableName=table, catalog_id=catalog_id))\n    for page in response_iterator:\n        count += len(page['TableVersions'])\n    return count"
        ]
    }
]