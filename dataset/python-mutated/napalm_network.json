[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\n    \"\"\"\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)"
        ]
    },
    {
        "func_name": "_filter_list",
        "original": "def _filter_list(input_list, search_key, search_value):\n    \"\"\"\n    Filters a list of dictionary by a set of key-value pair.\n\n    :param input_list:   is a list of dictionaries\n    :param search_key:   is the key we are looking for\n    :param search_value: is the value we are looking for the key specified in search_key\n    :return:             filered list of dictionaries\n    \"\"\"\n    output_list = list()\n    for dictionary in input_list:\n        if dictionary.get(search_key) == search_value:\n            output_list.append(dictionary)\n    return output_list",
        "mutated": [
            "def _filter_list(input_list, search_key, search_value):\n    if False:\n        i = 10\n    '\\n    Filters a list of dictionary by a set of key-value pair.\\n\\n    :param input_list:   is a list of dictionaries\\n    :param search_key:   is the key we are looking for\\n    :param search_value: is the value we are looking for the key specified in search_key\\n    :return:             filered list of dictionaries\\n    '\n    output_list = list()\n    for dictionary in input_list:\n        if dictionary.get(search_key) == search_value:\n            output_list.append(dictionary)\n    return output_list",
            "def _filter_list(input_list, search_key, search_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Filters a list of dictionary by a set of key-value pair.\\n\\n    :param input_list:   is a list of dictionaries\\n    :param search_key:   is the key we are looking for\\n    :param search_value: is the value we are looking for the key specified in search_key\\n    :return:             filered list of dictionaries\\n    '\n    output_list = list()\n    for dictionary in input_list:\n        if dictionary.get(search_key) == search_value:\n            output_list.append(dictionary)\n    return output_list",
            "def _filter_list(input_list, search_key, search_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Filters a list of dictionary by a set of key-value pair.\\n\\n    :param input_list:   is a list of dictionaries\\n    :param search_key:   is the key we are looking for\\n    :param search_value: is the value we are looking for the key specified in search_key\\n    :return:             filered list of dictionaries\\n    '\n    output_list = list()\n    for dictionary in input_list:\n        if dictionary.get(search_key) == search_value:\n            output_list.append(dictionary)\n    return output_list",
            "def _filter_list(input_list, search_key, search_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Filters a list of dictionary by a set of key-value pair.\\n\\n    :param input_list:   is a list of dictionaries\\n    :param search_key:   is the key we are looking for\\n    :param search_value: is the value we are looking for the key specified in search_key\\n    :return:             filered list of dictionaries\\n    '\n    output_list = list()\n    for dictionary in input_list:\n        if dictionary.get(search_key) == search_value:\n            output_list.append(dictionary)\n    return output_list",
            "def _filter_list(input_list, search_key, search_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Filters a list of dictionary by a set of key-value pair.\\n\\n    :param input_list:   is a list of dictionaries\\n    :param search_key:   is the key we are looking for\\n    :param search_value: is the value we are looking for the key specified in search_key\\n    :return:             filered list of dictionaries\\n    '\n    output_list = list()\n    for dictionary in input_list:\n        if dictionary.get(search_key) == search_value:\n            output_list.append(dictionary)\n    return output_list"
        ]
    },
    {
        "func_name": "_filter_dict",
        "original": "def _filter_dict(input_dict, search_key, search_value):\n    \"\"\"\n    Filters a dictionary of dictionaries by a key-value pair.\n\n    :param input_dict:    is a dictionary whose values are lists of dictionaries\n    :param search_key:    is the key in the leaf dictionaries\n    :param search_values: is the value in the leaf dictionaries\n    :return:              filtered dictionary\n    \"\"\"\n    output_dict = dict()\n    for (key, key_list) in input_dict.items():\n        key_list_filtered = _filter_list(key_list, search_key, search_value)\n        if key_list_filtered:\n            output_dict[key] = key_list_filtered\n    return output_dict",
        "mutated": [
            "def _filter_dict(input_dict, search_key, search_value):\n    if False:\n        i = 10\n    '\\n    Filters a dictionary of dictionaries by a key-value pair.\\n\\n    :param input_dict:    is a dictionary whose values are lists of dictionaries\\n    :param search_key:    is the key in the leaf dictionaries\\n    :param search_values: is the value in the leaf dictionaries\\n    :return:              filtered dictionary\\n    '\n    output_dict = dict()\n    for (key, key_list) in input_dict.items():\n        key_list_filtered = _filter_list(key_list, search_key, search_value)\n        if key_list_filtered:\n            output_dict[key] = key_list_filtered\n    return output_dict",
            "def _filter_dict(input_dict, search_key, search_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Filters a dictionary of dictionaries by a key-value pair.\\n\\n    :param input_dict:    is a dictionary whose values are lists of dictionaries\\n    :param search_key:    is the key in the leaf dictionaries\\n    :param search_values: is the value in the leaf dictionaries\\n    :return:              filtered dictionary\\n    '\n    output_dict = dict()\n    for (key, key_list) in input_dict.items():\n        key_list_filtered = _filter_list(key_list, search_key, search_value)\n        if key_list_filtered:\n            output_dict[key] = key_list_filtered\n    return output_dict",
            "def _filter_dict(input_dict, search_key, search_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Filters a dictionary of dictionaries by a key-value pair.\\n\\n    :param input_dict:    is a dictionary whose values are lists of dictionaries\\n    :param search_key:    is the key in the leaf dictionaries\\n    :param search_values: is the value in the leaf dictionaries\\n    :return:              filtered dictionary\\n    '\n    output_dict = dict()\n    for (key, key_list) in input_dict.items():\n        key_list_filtered = _filter_list(key_list, search_key, search_value)\n        if key_list_filtered:\n            output_dict[key] = key_list_filtered\n    return output_dict",
            "def _filter_dict(input_dict, search_key, search_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Filters a dictionary of dictionaries by a key-value pair.\\n\\n    :param input_dict:    is a dictionary whose values are lists of dictionaries\\n    :param search_key:    is the key in the leaf dictionaries\\n    :param search_values: is the value in the leaf dictionaries\\n    :return:              filtered dictionary\\n    '\n    output_dict = dict()\n    for (key, key_list) in input_dict.items():\n        key_list_filtered = _filter_list(key_list, search_key, search_value)\n        if key_list_filtered:\n            output_dict[key] = key_list_filtered\n    return output_dict",
            "def _filter_dict(input_dict, search_key, search_value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Filters a dictionary of dictionaries by a key-value pair.\\n\\n    :param input_dict:    is a dictionary whose values are lists of dictionaries\\n    :param search_key:    is the key in the leaf dictionaries\\n    :param search_values: is the value in the leaf dictionaries\\n    :return:              filtered dictionary\\n    '\n    output_dict = dict()\n    for (key, key_list) in input_dict.items():\n        key_list_filtered = _filter_list(key_list, search_key, search_value)\n        if key_list_filtered:\n            output_dict[key] = key_list_filtered\n    return output_dict"
        ]
    },
    {
        "func_name": "_safe_commit_config",
        "original": "def _safe_commit_config(loaded_result, napalm_device):\n    _commit = commit(inherit_napalm_device=napalm_device)\n    if not _commit.get('result', False):\n        loaded_result['comment'] += _commit['comment'] if _commit.get('comment') else 'Unable to commit.'\n        loaded_result['result'] = False\n        discarded = _safe_dicard_config(loaded_result, napalm_device)\n        if not discarded['result']:\n            return loaded_result\n    return _commit",
        "mutated": [
            "def _safe_commit_config(loaded_result, napalm_device):\n    if False:\n        i = 10\n    _commit = commit(inherit_napalm_device=napalm_device)\n    if not _commit.get('result', False):\n        loaded_result['comment'] += _commit['comment'] if _commit.get('comment') else 'Unable to commit.'\n        loaded_result['result'] = False\n        discarded = _safe_dicard_config(loaded_result, napalm_device)\n        if not discarded['result']:\n            return loaded_result\n    return _commit",
            "def _safe_commit_config(loaded_result, napalm_device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    _commit = commit(inherit_napalm_device=napalm_device)\n    if not _commit.get('result', False):\n        loaded_result['comment'] += _commit['comment'] if _commit.get('comment') else 'Unable to commit.'\n        loaded_result['result'] = False\n        discarded = _safe_dicard_config(loaded_result, napalm_device)\n        if not discarded['result']:\n            return loaded_result\n    return _commit",
            "def _safe_commit_config(loaded_result, napalm_device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    _commit = commit(inherit_napalm_device=napalm_device)\n    if not _commit.get('result', False):\n        loaded_result['comment'] += _commit['comment'] if _commit.get('comment') else 'Unable to commit.'\n        loaded_result['result'] = False\n        discarded = _safe_dicard_config(loaded_result, napalm_device)\n        if not discarded['result']:\n            return loaded_result\n    return _commit",
            "def _safe_commit_config(loaded_result, napalm_device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    _commit = commit(inherit_napalm_device=napalm_device)\n    if not _commit.get('result', False):\n        loaded_result['comment'] += _commit['comment'] if _commit.get('comment') else 'Unable to commit.'\n        loaded_result['result'] = False\n        discarded = _safe_dicard_config(loaded_result, napalm_device)\n        if not discarded['result']:\n            return loaded_result\n    return _commit",
            "def _safe_commit_config(loaded_result, napalm_device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    _commit = commit(inherit_napalm_device=napalm_device)\n    if not _commit.get('result', False):\n        loaded_result['comment'] += _commit['comment'] if _commit.get('comment') else 'Unable to commit.'\n        loaded_result['result'] = False\n        discarded = _safe_dicard_config(loaded_result, napalm_device)\n        if not discarded['result']:\n            return loaded_result\n    return _commit"
        ]
    },
    {
        "func_name": "_safe_dicard_config",
        "original": "def _safe_dicard_config(loaded_result, napalm_device):\n    log.debug('Discarding the config')\n    log.debug(loaded_result)\n    _discarded = discard_config(inherit_napalm_device=napalm_device)\n    if not _discarded.get('result', False):\n        loaded_result['comment'] += _discarded['comment'] if _discarded.get('comment') else 'Unable to discard config.'\n        loaded_result['result'] = False\n        _explicit_close(napalm_device)\n        __context__['retcode'] = 1\n        return loaded_result\n    return _discarded",
        "mutated": [
            "def _safe_dicard_config(loaded_result, napalm_device):\n    if False:\n        i = 10\n    log.debug('Discarding the config')\n    log.debug(loaded_result)\n    _discarded = discard_config(inherit_napalm_device=napalm_device)\n    if not _discarded.get('result', False):\n        loaded_result['comment'] += _discarded['comment'] if _discarded.get('comment') else 'Unable to discard config.'\n        loaded_result['result'] = False\n        _explicit_close(napalm_device)\n        __context__['retcode'] = 1\n        return loaded_result\n    return _discarded",
            "def _safe_dicard_config(loaded_result, napalm_device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    log.debug('Discarding the config')\n    log.debug(loaded_result)\n    _discarded = discard_config(inherit_napalm_device=napalm_device)\n    if not _discarded.get('result', False):\n        loaded_result['comment'] += _discarded['comment'] if _discarded.get('comment') else 'Unable to discard config.'\n        loaded_result['result'] = False\n        _explicit_close(napalm_device)\n        __context__['retcode'] = 1\n        return loaded_result\n    return _discarded",
            "def _safe_dicard_config(loaded_result, napalm_device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    log.debug('Discarding the config')\n    log.debug(loaded_result)\n    _discarded = discard_config(inherit_napalm_device=napalm_device)\n    if not _discarded.get('result', False):\n        loaded_result['comment'] += _discarded['comment'] if _discarded.get('comment') else 'Unable to discard config.'\n        loaded_result['result'] = False\n        _explicit_close(napalm_device)\n        __context__['retcode'] = 1\n        return loaded_result\n    return _discarded",
            "def _safe_dicard_config(loaded_result, napalm_device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    log.debug('Discarding the config')\n    log.debug(loaded_result)\n    _discarded = discard_config(inherit_napalm_device=napalm_device)\n    if not _discarded.get('result', False):\n        loaded_result['comment'] += _discarded['comment'] if _discarded.get('comment') else 'Unable to discard config.'\n        loaded_result['result'] = False\n        _explicit_close(napalm_device)\n        __context__['retcode'] = 1\n        return loaded_result\n    return _discarded",
            "def _safe_dicard_config(loaded_result, napalm_device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    log.debug('Discarding the config')\n    log.debug(loaded_result)\n    _discarded = discard_config(inherit_napalm_device=napalm_device)\n    if not _discarded.get('result', False):\n        loaded_result['comment'] += _discarded['comment'] if _discarded.get('comment') else 'Unable to discard config.'\n        loaded_result['result'] = False\n        _explicit_close(napalm_device)\n        __context__['retcode'] = 1\n        return loaded_result\n    return _discarded"
        ]
    },
    {
        "func_name": "_explicit_close",
        "original": "def _explicit_close(napalm_device):\n    \"\"\"\n    Will explicily close the config session with the network device,\n    when running in a now-always-alive proxy minion or regular minion.\n    This helper must be used in configuration-related functions,\n    as the session is preserved and not closed before making any changes.\n    \"\"\"\n    if salt.utils.napalm.not_always_alive(__opts__):\n        try:\n            napalm_device['DRIVER'].close()\n        except Exception as err:\n            log.error('Unable to close the temp connection with the device:')\n            log.error(err)\n            log.error('Please report.')",
        "mutated": [
            "def _explicit_close(napalm_device):\n    if False:\n        i = 10\n    '\\n    Will explicily close the config session with the network device,\\n    when running in a now-always-alive proxy minion or regular minion.\\n    This helper must be used in configuration-related functions,\\n    as the session is preserved and not closed before making any changes.\\n    '\n    if salt.utils.napalm.not_always_alive(__opts__):\n        try:\n            napalm_device['DRIVER'].close()\n        except Exception as err:\n            log.error('Unable to close the temp connection with the device:')\n            log.error(err)\n            log.error('Please report.')",
            "def _explicit_close(napalm_device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Will explicily close the config session with the network device,\\n    when running in a now-always-alive proxy minion or regular minion.\\n    This helper must be used in configuration-related functions,\\n    as the session is preserved and not closed before making any changes.\\n    '\n    if salt.utils.napalm.not_always_alive(__opts__):\n        try:\n            napalm_device['DRIVER'].close()\n        except Exception as err:\n            log.error('Unable to close the temp connection with the device:')\n            log.error(err)\n            log.error('Please report.')",
            "def _explicit_close(napalm_device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Will explicily close the config session with the network device,\\n    when running in a now-always-alive proxy minion or regular minion.\\n    This helper must be used in configuration-related functions,\\n    as the session is preserved and not closed before making any changes.\\n    '\n    if salt.utils.napalm.not_always_alive(__opts__):\n        try:\n            napalm_device['DRIVER'].close()\n        except Exception as err:\n            log.error('Unable to close the temp connection with the device:')\n            log.error(err)\n            log.error('Please report.')",
            "def _explicit_close(napalm_device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Will explicily close the config session with the network device,\\n    when running in a now-always-alive proxy minion or regular minion.\\n    This helper must be used in configuration-related functions,\\n    as the session is preserved and not closed before making any changes.\\n    '\n    if salt.utils.napalm.not_always_alive(__opts__):\n        try:\n            napalm_device['DRIVER'].close()\n        except Exception as err:\n            log.error('Unable to close the temp connection with the device:')\n            log.error(err)\n            log.error('Please report.')",
            "def _explicit_close(napalm_device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Will explicily close the config session with the network device,\\n    when running in a now-always-alive proxy minion or regular minion.\\n    This helper must be used in configuration-related functions,\\n    as the session is preserved and not closed before making any changes.\\n    '\n    if salt.utils.napalm.not_always_alive(__opts__):\n        try:\n            napalm_device['DRIVER'].close()\n        except Exception as err:\n            log.error('Unable to close the temp connection with the device:')\n            log.error(err)\n            log.error('Please report.')"
        ]
    },
    {
        "func_name": "_config_logic",
        "original": "def _config_logic(napalm_device, loaded_result, test=False, debug=False, replace=False, commit_config=True, loaded_config=None, commit_in=None, commit_at=None, revert_in=None, revert_at=None, commit_jid=None, **kwargs):\n    \"\"\"\n    Builds the config logic for `load_config` and `load_template` functions.\n    \"\"\"\n    current_jid = kwargs.get('__pub_jid')\n    if not current_jid:\n        current_jid = '{:%Y%m%d%H%M%S%f}'.format(datetime.datetime.now())\n    loaded_result['already_configured'] = False\n    loaded_result['loaded_config'] = ''\n    if debug:\n        loaded_result['loaded_config'] = loaded_config\n    _compare = compare_config(inherit_napalm_device=napalm_device)\n    if _compare.get('result', False):\n        loaded_result['diff'] = _compare.get('out')\n        loaded_result.pop('out', '')\n    else:\n        loaded_result['diff'] = None\n        loaded_result['result'] = False\n        loaded_result['comment'] = _compare.get('comment')\n        __context__['retcode'] = 1\n        return loaded_result\n    _loaded_res = loaded_result.get('result', False)\n    if not _loaded_res or test:\n        if loaded_result['comment']:\n            loaded_result['comment'] += '\\n'\n        if not loaded_result.get('diff', ''):\n            loaded_result['already_configured'] = True\n        discarded = _safe_dicard_config(loaded_result, napalm_device)\n        if not discarded['result']:\n            return loaded_result\n        loaded_result['comment'] += 'Configuration discarded.'\n        _explicit_close(napalm_device)\n        if not loaded_result['result']:\n            __context__['retcode'] = 1\n        return loaded_result\n    if not test and commit_config:\n        if commit_jid:\n            log.info('Committing the JID: %s', str(commit_jid))\n            removed = cancel_commit(commit_jid)\n            log.debug('Cleaned up the commit from the schedule')\n            log.debug(removed['comment'])\n        if loaded_result.get('diff', ''):\n            if commit_in or commit_at:\n                commit_time = __utils__['timeutil.get_time_at'](time_in=commit_in, time_at=commit_in)\n                scheduled_job_name = '__napalm_commit_{}'.format(current_jid)\n                temp_file = salt.utils.files.mkstemp()\n                with salt.utils.files.fopen(temp_file, 'w') as fp_:\n                    fp_.write(loaded_config)\n                scheduled = __salt__['schedule.add'](scheduled_job_name, function='net.load_config', job_kwargs={'filename': temp_file, 'commit_jid': current_jid, 'replace': replace}, once=commit_time)\n                log.debug('Scheduling job')\n                log.debug(scheduled)\n                saved = __salt__['schedule.save']()\n                discarded = _safe_dicard_config(loaded_result, napalm_device)\n                if not discarded['result']:\n                    discarded['comment'] += 'Scheduled the job to be executed at {schedule_ts}, but was unable to discard the config: \\n'.format(schedule_ts=commit_time)\n                    return discarded\n                loaded_result['comment'] = 'Changes discarded for now, and scheduled commit at: {schedule_ts}.\\nThe commit ID is: {current_jid}.\\nTo discard this commit, you can execute: \\n\\nsalt {min_id} net.cancel_commit {current_jid}'.format(schedule_ts=commit_time, min_id=__opts__['id'], current_jid=current_jid)\n                loaded_result['commit_id'] = current_jid\n                return loaded_result\n            log.debug('About to commit:')\n            log.debug(loaded_result['diff'])\n            if revert_in or revert_at:\n                revert_time = __utils__['timeutil.get_time_at'](time_in=revert_in, time_at=revert_at)\n                if __grains__['os'] == 'junos':\n                    if not HAS_JXMLEASE:\n                        loaded_result['comment'] = 'This feature requires the library jxmlease to be installed.\\nTo install, please execute: ``pip install jxmlease``.'\n                        loaded_result['result'] = False\n                        return loaded_result\n                    timestamp_at = __utils__['timeutil.get_timestamp_at'](time_in=revert_in, time_at=revert_at)\n                    minutes = int((timestamp_at - time.time()) / 60)\n                    _comm = __salt__['napalm.junos_commit'](confirm=minutes)\n                    if not _comm['out']:\n                        loaded_result['comment'] = 'Unable to commit confirm: {}'.format(_comm['message'])\n                        loaded_result['result'] = False\n                        discarded = _safe_dicard_config(loaded_result, napalm_device)\n                        if not discarded['result']:\n                            return loaded_result\n                else:\n                    temp_file = salt.utils.files.mkstemp()\n                    running_config = __salt__['net.config'](source='running')['out']['running']\n                    with salt.utils.files.fopen(temp_file, 'w') as fp_:\n                        fp_.write(running_config)\n                    committed = _safe_commit_config(loaded_result, napalm_device)\n                    if not committed['result']:\n                        return loaded_result\n                    scheduled_job_name = '__napalm_commit_{}'.format(current_jid)\n                    scheduled = __salt__['schedule.add'](scheduled_job_name, function='net.load_config', job_kwargs={'filename': temp_file, 'commit_jid': current_jid, 'replace': True}, once=revert_time)\n                    log.debug('Scheduling commit confirmed')\n                    log.debug(scheduled)\n                    saved = __salt__['schedule.save']()\n                loaded_result['comment'] = 'The commit ID is: {current_jid}.\\nThis commit will be reverted at: {schedule_ts}, unless confirmed.\\nTo confirm the commit and avoid reverting, you can execute:\\n\\nsalt {min_id} net.confirm_commit {current_jid}'.format(schedule_ts=revert_time, min_id=__opts__['id'], current_jid=current_jid)\n                loaded_result['commit_id'] = current_jid\n                return loaded_result\n            committed = _safe_commit_config(loaded_result, napalm_device)\n            if not committed['result']:\n                return loaded_result\n        else:\n            discarded = _safe_dicard_config(loaded_result, napalm_device)\n            if not discarded['result']:\n                return loaded_result\n            loaded_result['already_configured'] = True\n            loaded_result['comment'] = 'Already configured.'\n    _explicit_close(napalm_device)\n    if not loaded_result['result']:\n        __context__['retcode'] = 1\n    return loaded_result",
        "mutated": [
            "def _config_logic(napalm_device, loaded_result, test=False, debug=False, replace=False, commit_config=True, loaded_config=None, commit_in=None, commit_at=None, revert_in=None, revert_at=None, commit_jid=None, **kwargs):\n    if False:\n        i = 10\n    '\\n    Builds the config logic for `load_config` and `load_template` functions.\\n    '\n    current_jid = kwargs.get('__pub_jid')\n    if not current_jid:\n        current_jid = '{:%Y%m%d%H%M%S%f}'.format(datetime.datetime.now())\n    loaded_result['already_configured'] = False\n    loaded_result['loaded_config'] = ''\n    if debug:\n        loaded_result['loaded_config'] = loaded_config\n    _compare = compare_config(inherit_napalm_device=napalm_device)\n    if _compare.get('result', False):\n        loaded_result['diff'] = _compare.get('out')\n        loaded_result.pop('out', '')\n    else:\n        loaded_result['diff'] = None\n        loaded_result['result'] = False\n        loaded_result['comment'] = _compare.get('comment')\n        __context__['retcode'] = 1\n        return loaded_result\n    _loaded_res = loaded_result.get('result', False)\n    if not _loaded_res or test:\n        if loaded_result['comment']:\n            loaded_result['comment'] += '\\n'\n        if not loaded_result.get('diff', ''):\n            loaded_result['already_configured'] = True\n        discarded = _safe_dicard_config(loaded_result, napalm_device)\n        if not discarded['result']:\n            return loaded_result\n        loaded_result['comment'] += 'Configuration discarded.'\n        _explicit_close(napalm_device)\n        if not loaded_result['result']:\n            __context__['retcode'] = 1\n        return loaded_result\n    if not test and commit_config:\n        if commit_jid:\n            log.info('Committing the JID: %s', str(commit_jid))\n            removed = cancel_commit(commit_jid)\n            log.debug('Cleaned up the commit from the schedule')\n            log.debug(removed['comment'])\n        if loaded_result.get('diff', ''):\n            if commit_in or commit_at:\n                commit_time = __utils__['timeutil.get_time_at'](time_in=commit_in, time_at=commit_in)\n                scheduled_job_name = '__napalm_commit_{}'.format(current_jid)\n                temp_file = salt.utils.files.mkstemp()\n                with salt.utils.files.fopen(temp_file, 'w') as fp_:\n                    fp_.write(loaded_config)\n                scheduled = __salt__['schedule.add'](scheduled_job_name, function='net.load_config', job_kwargs={'filename': temp_file, 'commit_jid': current_jid, 'replace': replace}, once=commit_time)\n                log.debug('Scheduling job')\n                log.debug(scheduled)\n                saved = __salt__['schedule.save']()\n                discarded = _safe_dicard_config(loaded_result, napalm_device)\n                if not discarded['result']:\n                    discarded['comment'] += 'Scheduled the job to be executed at {schedule_ts}, but was unable to discard the config: \\n'.format(schedule_ts=commit_time)\n                    return discarded\n                loaded_result['comment'] = 'Changes discarded for now, and scheduled commit at: {schedule_ts}.\\nThe commit ID is: {current_jid}.\\nTo discard this commit, you can execute: \\n\\nsalt {min_id} net.cancel_commit {current_jid}'.format(schedule_ts=commit_time, min_id=__opts__['id'], current_jid=current_jid)\n                loaded_result['commit_id'] = current_jid\n                return loaded_result\n            log.debug('About to commit:')\n            log.debug(loaded_result['diff'])\n            if revert_in or revert_at:\n                revert_time = __utils__['timeutil.get_time_at'](time_in=revert_in, time_at=revert_at)\n                if __grains__['os'] == 'junos':\n                    if not HAS_JXMLEASE:\n                        loaded_result['comment'] = 'This feature requires the library jxmlease to be installed.\\nTo install, please execute: ``pip install jxmlease``.'\n                        loaded_result['result'] = False\n                        return loaded_result\n                    timestamp_at = __utils__['timeutil.get_timestamp_at'](time_in=revert_in, time_at=revert_at)\n                    minutes = int((timestamp_at - time.time()) / 60)\n                    _comm = __salt__['napalm.junos_commit'](confirm=minutes)\n                    if not _comm['out']:\n                        loaded_result['comment'] = 'Unable to commit confirm: {}'.format(_comm['message'])\n                        loaded_result['result'] = False\n                        discarded = _safe_dicard_config(loaded_result, napalm_device)\n                        if not discarded['result']:\n                            return loaded_result\n                else:\n                    temp_file = salt.utils.files.mkstemp()\n                    running_config = __salt__['net.config'](source='running')['out']['running']\n                    with salt.utils.files.fopen(temp_file, 'w') as fp_:\n                        fp_.write(running_config)\n                    committed = _safe_commit_config(loaded_result, napalm_device)\n                    if not committed['result']:\n                        return loaded_result\n                    scheduled_job_name = '__napalm_commit_{}'.format(current_jid)\n                    scheduled = __salt__['schedule.add'](scheduled_job_name, function='net.load_config', job_kwargs={'filename': temp_file, 'commit_jid': current_jid, 'replace': True}, once=revert_time)\n                    log.debug('Scheduling commit confirmed')\n                    log.debug(scheduled)\n                    saved = __salt__['schedule.save']()\n                loaded_result['comment'] = 'The commit ID is: {current_jid}.\\nThis commit will be reverted at: {schedule_ts}, unless confirmed.\\nTo confirm the commit and avoid reverting, you can execute:\\n\\nsalt {min_id} net.confirm_commit {current_jid}'.format(schedule_ts=revert_time, min_id=__opts__['id'], current_jid=current_jid)\n                loaded_result['commit_id'] = current_jid\n                return loaded_result\n            committed = _safe_commit_config(loaded_result, napalm_device)\n            if not committed['result']:\n                return loaded_result\n        else:\n            discarded = _safe_dicard_config(loaded_result, napalm_device)\n            if not discarded['result']:\n                return loaded_result\n            loaded_result['already_configured'] = True\n            loaded_result['comment'] = 'Already configured.'\n    _explicit_close(napalm_device)\n    if not loaded_result['result']:\n        __context__['retcode'] = 1\n    return loaded_result",
            "def _config_logic(napalm_device, loaded_result, test=False, debug=False, replace=False, commit_config=True, loaded_config=None, commit_in=None, commit_at=None, revert_in=None, revert_at=None, commit_jid=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Builds the config logic for `load_config` and `load_template` functions.\\n    '\n    current_jid = kwargs.get('__pub_jid')\n    if not current_jid:\n        current_jid = '{:%Y%m%d%H%M%S%f}'.format(datetime.datetime.now())\n    loaded_result['already_configured'] = False\n    loaded_result['loaded_config'] = ''\n    if debug:\n        loaded_result['loaded_config'] = loaded_config\n    _compare = compare_config(inherit_napalm_device=napalm_device)\n    if _compare.get('result', False):\n        loaded_result['diff'] = _compare.get('out')\n        loaded_result.pop('out', '')\n    else:\n        loaded_result['diff'] = None\n        loaded_result['result'] = False\n        loaded_result['comment'] = _compare.get('comment')\n        __context__['retcode'] = 1\n        return loaded_result\n    _loaded_res = loaded_result.get('result', False)\n    if not _loaded_res or test:\n        if loaded_result['comment']:\n            loaded_result['comment'] += '\\n'\n        if not loaded_result.get('diff', ''):\n            loaded_result['already_configured'] = True\n        discarded = _safe_dicard_config(loaded_result, napalm_device)\n        if not discarded['result']:\n            return loaded_result\n        loaded_result['comment'] += 'Configuration discarded.'\n        _explicit_close(napalm_device)\n        if not loaded_result['result']:\n            __context__['retcode'] = 1\n        return loaded_result\n    if not test and commit_config:\n        if commit_jid:\n            log.info('Committing the JID: %s', str(commit_jid))\n            removed = cancel_commit(commit_jid)\n            log.debug('Cleaned up the commit from the schedule')\n            log.debug(removed['comment'])\n        if loaded_result.get('diff', ''):\n            if commit_in or commit_at:\n                commit_time = __utils__['timeutil.get_time_at'](time_in=commit_in, time_at=commit_in)\n                scheduled_job_name = '__napalm_commit_{}'.format(current_jid)\n                temp_file = salt.utils.files.mkstemp()\n                with salt.utils.files.fopen(temp_file, 'w') as fp_:\n                    fp_.write(loaded_config)\n                scheduled = __salt__['schedule.add'](scheduled_job_name, function='net.load_config', job_kwargs={'filename': temp_file, 'commit_jid': current_jid, 'replace': replace}, once=commit_time)\n                log.debug('Scheduling job')\n                log.debug(scheduled)\n                saved = __salt__['schedule.save']()\n                discarded = _safe_dicard_config(loaded_result, napalm_device)\n                if not discarded['result']:\n                    discarded['comment'] += 'Scheduled the job to be executed at {schedule_ts}, but was unable to discard the config: \\n'.format(schedule_ts=commit_time)\n                    return discarded\n                loaded_result['comment'] = 'Changes discarded for now, and scheduled commit at: {schedule_ts}.\\nThe commit ID is: {current_jid}.\\nTo discard this commit, you can execute: \\n\\nsalt {min_id} net.cancel_commit {current_jid}'.format(schedule_ts=commit_time, min_id=__opts__['id'], current_jid=current_jid)\n                loaded_result['commit_id'] = current_jid\n                return loaded_result\n            log.debug('About to commit:')\n            log.debug(loaded_result['diff'])\n            if revert_in or revert_at:\n                revert_time = __utils__['timeutil.get_time_at'](time_in=revert_in, time_at=revert_at)\n                if __grains__['os'] == 'junos':\n                    if not HAS_JXMLEASE:\n                        loaded_result['comment'] = 'This feature requires the library jxmlease to be installed.\\nTo install, please execute: ``pip install jxmlease``.'\n                        loaded_result['result'] = False\n                        return loaded_result\n                    timestamp_at = __utils__['timeutil.get_timestamp_at'](time_in=revert_in, time_at=revert_at)\n                    minutes = int((timestamp_at - time.time()) / 60)\n                    _comm = __salt__['napalm.junos_commit'](confirm=minutes)\n                    if not _comm['out']:\n                        loaded_result['comment'] = 'Unable to commit confirm: {}'.format(_comm['message'])\n                        loaded_result['result'] = False\n                        discarded = _safe_dicard_config(loaded_result, napalm_device)\n                        if not discarded['result']:\n                            return loaded_result\n                else:\n                    temp_file = salt.utils.files.mkstemp()\n                    running_config = __salt__['net.config'](source='running')['out']['running']\n                    with salt.utils.files.fopen(temp_file, 'w') as fp_:\n                        fp_.write(running_config)\n                    committed = _safe_commit_config(loaded_result, napalm_device)\n                    if not committed['result']:\n                        return loaded_result\n                    scheduled_job_name = '__napalm_commit_{}'.format(current_jid)\n                    scheduled = __salt__['schedule.add'](scheduled_job_name, function='net.load_config', job_kwargs={'filename': temp_file, 'commit_jid': current_jid, 'replace': True}, once=revert_time)\n                    log.debug('Scheduling commit confirmed')\n                    log.debug(scheduled)\n                    saved = __salt__['schedule.save']()\n                loaded_result['comment'] = 'The commit ID is: {current_jid}.\\nThis commit will be reverted at: {schedule_ts}, unless confirmed.\\nTo confirm the commit and avoid reverting, you can execute:\\n\\nsalt {min_id} net.confirm_commit {current_jid}'.format(schedule_ts=revert_time, min_id=__opts__['id'], current_jid=current_jid)\n                loaded_result['commit_id'] = current_jid\n                return loaded_result\n            committed = _safe_commit_config(loaded_result, napalm_device)\n            if not committed['result']:\n                return loaded_result\n        else:\n            discarded = _safe_dicard_config(loaded_result, napalm_device)\n            if not discarded['result']:\n                return loaded_result\n            loaded_result['already_configured'] = True\n            loaded_result['comment'] = 'Already configured.'\n    _explicit_close(napalm_device)\n    if not loaded_result['result']:\n        __context__['retcode'] = 1\n    return loaded_result",
            "def _config_logic(napalm_device, loaded_result, test=False, debug=False, replace=False, commit_config=True, loaded_config=None, commit_in=None, commit_at=None, revert_in=None, revert_at=None, commit_jid=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Builds the config logic for `load_config` and `load_template` functions.\\n    '\n    current_jid = kwargs.get('__pub_jid')\n    if not current_jid:\n        current_jid = '{:%Y%m%d%H%M%S%f}'.format(datetime.datetime.now())\n    loaded_result['already_configured'] = False\n    loaded_result['loaded_config'] = ''\n    if debug:\n        loaded_result['loaded_config'] = loaded_config\n    _compare = compare_config(inherit_napalm_device=napalm_device)\n    if _compare.get('result', False):\n        loaded_result['diff'] = _compare.get('out')\n        loaded_result.pop('out', '')\n    else:\n        loaded_result['diff'] = None\n        loaded_result['result'] = False\n        loaded_result['comment'] = _compare.get('comment')\n        __context__['retcode'] = 1\n        return loaded_result\n    _loaded_res = loaded_result.get('result', False)\n    if not _loaded_res or test:\n        if loaded_result['comment']:\n            loaded_result['comment'] += '\\n'\n        if not loaded_result.get('diff', ''):\n            loaded_result['already_configured'] = True\n        discarded = _safe_dicard_config(loaded_result, napalm_device)\n        if not discarded['result']:\n            return loaded_result\n        loaded_result['comment'] += 'Configuration discarded.'\n        _explicit_close(napalm_device)\n        if not loaded_result['result']:\n            __context__['retcode'] = 1\n        return loaded_result\n    if not test and commit_config:\n        if commit_jid:\n            log.info('Committing the JID: %s', str(commit_jid))\n            removed = cancel_commit(commit_jid)\n            log.debug('Cleaned up the commit from the schedule')\n            log.debug(removed['comment'])\n        if loaded_result.get('diff', ''):\n            if commit_in or commit_at:\n                commit_time = __utils__['timeutil.get_time_at'](time_in=commit_in, time_at=commit_in)\n                scheduled_job_name = '__napalm_commit_{}'.format(current_jid)\n                temp_file = salt.utils.files.mkstemp()\n                with salt.utils.files.fopen(temp_file, 'w') as fp_:\n                    fp_.write(loaded_config)\n                scheduled = __salt__['schedule.add'](scheduled_job_name, function='net.load_config', job_kwargs={'filename': temp_file, 'commit_jid': current_jid, 'replace': replace}, once=commit_time)\n                log.debug('Scheduling job')\n                log.debug(scheduled)\n                saved = __salt__['schedule.save']()\n                discarded = _safe_dicard_config(loaded_result, napalm_device)\n                if not discarded['result']:\n                    discarded['comment'] += 'Scheduled the job to be executed at {schedule_ts}, but was unable to discard the config: \\n'.format(schedule_ts=commit_time)\n                    return discarded\n                loaded_result['comment'] = 'Changes discarded for now, and scheduled commit at: {schedule_ts}.\\nThe commit ID is: {current_jid}.\\nTo discard this commit, you can execute: \\n\\nsalt {min_id} net.cancel_commit {current_jid}'.format(schedule_ts=commit_time, min_id=__opts__['id'], current_jid=current_jid)\n                loaded_result['commit_id'] = current_jid\n                return loaded_result\n            log.debug('About to commit:')\n            log.debug(loaded_result['diff'])\n            if revert_in or revert_at:\n                revert_time = __utils__['timeutil.get_time_at'](time_in=revert_in, time_at=revert_at)\n                if __grains__['os'] == 'junos':\n                    if not HAS_JXMLEASE:\n                        loaded_result['comment'] = 'This feature requires the library jxmlease to be installed.\\nTo install, please execute: ``pip install jxmlease``.'\n                        loaded_result['result'] = False\n                        return loaded_result\n                    timestamp_at = __utils__['timeutil.get_timestamp_at'](time_in=revert_in, time_at=revert_at)\n                    minutes = int((timestamp_at - time.time()) / 60)\n                    _comm = __salt__['napalm.junos_commit'](confirm=minutes)\n                    if not _comm['out']:\n                        loaded_result['comment'] = 'Unable to commit confirm: {}'.format(_comm['message'])\n                        loaded_result['result'] = False\n                        discarded = _safe_dicard_config(loaded_result, napalm_device)\n                        if not discarded['result']:\n                            return loaded_result\n                else:\n                    temp_file = salt.utils.files.mkstemp()\n                    running_config = __salt__['net.config'](source='running')['out']['running']\n                    with salt.utils.files.fopen(temp_file, 'w') as fp_:\n                        fp_.write(running_config)\n                    committed = _safe_commit_config(loaded_result, napalm_device)\n                    if not committed['result']:\n                        return loaded_result\n                    scheduled_job_name = '__napalm_commit_{}'.format(current_jid)\n                    scheduled = __salt__['schedule.add'](scheduled_job_name, function='net.load_config', job_kwargs={'filename': temp_file, 'commit_jid': current_jid, 'replace': True}, once=revert_time)\n                    log.debug('Scheduling commit confirmed')\n                    log.debug(scheduled)\n                    saved = __salt__['schedule.save']()\n                loaded_result['comment'] = 'The commit ID is: {current_jid}.\\nThis commit will be reverted at: {schedule_ts}, unless confirmed.\\nTo confirm the commit and avoid reverting, you can execute:\\n\\nsalt {min_id} net.confirm_commit {current_jid}'.format(schedule_ts=revert_time, min_id=__opts__['id'], current_jid=current_jid)\n                loaded_result['commit_id'] = current_jid\n                return loaded_result\n            committed = _safe_commit_config(loaded_result, napalm_device)\n            if not committed['result']:\n                return loaded_result\n        else:\n            discarded = _safe_dicard_config(loaded_result, napalm_device)\n            if not discarded['result']:\n                return loaded_result\n            loaded_result['already_configured'] = True\n            loaded_result['comment'] = 'Already configured.'\n    _explicit_close(napalm_device)\n    if not loaded_result['result']:\n        __context__['retcode'] = 1\n    return loaded_result",
            "def _config_logic(napalm_device, loaded_result, test=False, debug=False, replace=False, commit_config=True, loaded_config=None, commit_in=None, commit_at=None, revert_in=None, revert_at=None, commit_jid=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Builds the config logic for `load_config` and `load_template` functions.\\n    '\n    current_jid = kwargs.get('__pub_jid')\n    if not current_jid:\n        current_jid = '{:%Y%m%d%H%M%S%f}'.format(datetime.datetime.now())\n    loaded_result['already_configured'] = False\n    loaded_result['loaded_config'] = ''\n    if debug:\n        loaded_result['loaded_config'] = loaded_config\n    _compare = compare_config(inherit_napalm_device=napalm_device)\n    if _compare.get('result', False):\n        loaded_result['diff'] = _compare.get('out')\n        loaded_result.pop('out', '')\n    else:\n        loaded_result['diff'] = None\n        loaded_result['result'] = False\n        loaded_result['comment'] = _compare.get('comment')\n        __context__['retcode'] = 1\n        return loaded_result\n    _loaded_res = loaded_result.get('result', False)\n    if not _loaded_res or test:\n        if loaded_result['comment']:\n            loaded_result['comment'] += '\\n'\n        if not loaded_result.get('diff', ''):\n            loaded_result['already_configured'] = True\n        discarded = _safe_dicard_config(loaded_result, napalm_device)\n        if not discarded['result']:\n            return loaded_result\n        loaded_result['comment'] += 'Configuration discarded.'\n        _explicit_close(napalm_device)\n        if not loaded_result['result']:\n            __context__['retcode'] = 1\n        return loaded_result\n    if not test and commit_config:\n        if commit_jid:\n            log.info('Committing the JID: %s', str(commit_jid))\n            removed = cancel_commit(commit_jid)\n            log.debug('Cleaned up the commit from the schedule')\n            log.debug(removed['comment'])\n        if loaded_result.get('diff', ''):\n            if commit_in or commit_at:\n                commit_time = __utils__['timeutil.get_time_at'](time_in=commit_in, time_at=commit_in)\n                scheduled_job_name = '__napalm_commit_{}'.format(current_jid)\n                temp_file = salt.utils.files.mkstemp()\n                with salt.utils.files.fopen(temp_file, 'w') as fp_:\n                    fp_.write(loaded_config)\n                scheduled = __salt__['schedule.add'](scheduled_job_name, function='net.load_config', job_kwargs={'filename': temp_file, 'commit_jid': current_jid, 'replace': replace}, once=commit_time)\n                log.debug('Scheduling job')\n                log.debug(scheduled)\n                saved = __salt__['schedule.save']()\n                discarded = _safe_dicard_config(loaded_result, napalm_device)\n                if not discarded['result']:\n                    discarded['comment'] += 'Scheduled the job to be executed at {schedule_ts}, but was unable to discard the config: \\n'.format(schedule_ts=commit_time)\n                    return discarded\n                loaded_result['comment'] = 'Changes discarded for now, and scheduled commit at: {schedule_ts}.\\nThe commit ID is: {current_jid}.\\nTo discard this commit, you can execute: \\n\\nsalt {min_id} net.cancel_commit {current_jid}'.format(schedule_ts=commit_time, min_id=__opts__['id'], current_jid=current_jid)\n                loaded_result['commit_id'] = current_jid\n                return loaded_result\n            log.debug('About to commit:')\n            log.debug(loaded_result['diff'])\n            if revert_in or revert_at:\n                revert_time = __utils__['timeutil.get_time_at'](time_in=revert_in, time_at=revert_at)\n                if __grains__['os'] == 'junos':\n                    if not HAS_JXMLEASE:\n                        loaded_result['comment'] = 'This feature requires the library jxmlease to be installed.\\nTo install, please execute: ``pip install jxmlease``.'\n                        loaded_result['result'] = False\n                        return loaded_result\n                    timestamp_at = __utils__['timeutil.get_timestamp_at'](time_in=revert_in, time_at=revert_at)\n                    minutes = int((timestamp_at - time.time()) / 60)\n                    _comm = __salt__['napalm.junos_commit'](confirm=minutes)\n                    if not _comm['out']:\n                        loaded_result['comment'] = 'Unable to commit confirm: {}'.format(_comm['message'])\n                        loaded_result['result'] = False\n                        discarded = _safe_dicard_config(loaded_result, napalm_device)\n                        if not discarded['result']:\n                            return loaded_result\n                else:\n                    temp_file = salt.utils.files.mkstemp()\n                    running_config = __salt__['net.config'](source='running')['out']['running']\n                    with salt.utils.files.fopen(temp_file, 'w') as fp_:\n                        fp_.write(running_config)\n                    committed = _safe_commit_config(loaded_result, napalm_device)\n                    if not committed['result']:\n                        return loaded_result\n                    scheduled_job_name = '__napalm_commit_{}'.format(current_jid)\n                    scheduled = __salt__['schedule.add'](scheduled_job_name, function='net.load_config', job_kwargs={'filename': temp_file, 'commit_jid': current_jid, 'replace': True}, once=revert_time)\n                    log.debug('Scheduling commit confirmed')\n                    log.debug(scheduled)\n                    saved = __salt__['schedule.save']()\n                loaded_result['comment'] = 'The commit ID is: {current_jid}.\\nThis commit will be reverted at: {schedule_ts}, unless confirmed.\\nTo confirm the commit and avoid reverting, you can execute:\\n\\nsalt {min_id} net.confirm_commit {current_jid}'.format(schedule_ts=revert_time, min_id=__opts__['id'], current_jid=current_jid)\n                loaded_result['commit_id'] = current_jid\n                return loaded_result\n            committed = _safe_commit_config(loaded_result, napalm_device)\n            if not committed['result']:\n                return loaded_result\n        else:\n            discarded = _safe_dicard_config(loaded_result, napalm_device)\n            if not discarded['result']:\n                return loaded_result\n            loaded_result['already_configured'] = True\n            loaded_result['comment'] = 'Already configured.'\n    _explicit_close(napalm_device)\n    if not loaded_result['result']:\n        __context__['retcode'] = 1\n    return loaded_result",
            "def _config_logic(napalm_device, loaded_result, test=False, debug=False, replace=False, commit_config=True, loaded_config=None, commit_in=None, commit_at=None, revert_in=None, revert_at=None, commit_jid=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Builds the config logic for `load_config` and `load_template` functions.\\n    '\n    current_jid = kwargs.get('__pub_jid')\n    if not current_jid:\n        current_jid = '{:%Y%m%d%H%M%S%f}'.format(datetime.datetime.now())\n    loaded_result['already_configured'] = False\n    loaded_result['loaded_config'] = ''\n    if debug:\n        loaded_result['loaded_config'] = loaded_config\n    _compare = compare_config(inherit_napalm_device=napalm_device)\n    if _compare.get('result', False):\n        loaded_result['diff'] = _compare.get('out')\n        loaded_result.pop('out', '')\n    else:\n        loaded_result['diff'] = None\n        loaded_result['result'] = False\n        loaded_result['comment'] = _compare.get('comment')\n        __context__['retcode'] = 1\n        return loaded_result\n    _loaded_res = loaded_result.get('result', False)\n    if not _loaded_res or test:\n        if loaded_result['comment']:\n            loaded_result['comment'] += '\\n'\n        if not loaded_result.get('diff', ''):\n            loaded_result['already_configured'] = True\n        discarded = _safe_dicard_config(loaded_result, napalm_device)\n        if not discarded['result']:\n            return loaded_result\n        loaded_result['comment'] += 'Configuration discarded.'\n        _explicit_close(napalm_device)\n        if not loaded_result['result']:\n            __context__['retcode'] = 1\n        return loaded_result\n    if not test and commit_config:\n        if commit_jid:\n            log.info('Committing the JID: %s', str(commit_jid))\n            removed = cancel_commit(commit_jid)\n            log.debug('Cleaned up the commit from the schedule')\n            log.debug(removed['comment'])\n        if loaded_result.get('diff', ''):\n            if commit_in or commit_at:\n                commit_time = __utils__['timeutil.get_time_at'](time_in=commit_in, time_at=commit_in)\n                scheduled_job_name = '__napalm_commit_{}'.format(current_jid)\n                temp_file = salt.utils.files.mkstemp()\n                with salt.utils.files.fopen(temp_file, 'w') as fp_:\n                    fp_.write(loaded_config)\n                scheduled = __salt__['schedule.add'](scheduled_job_name, function='net.load_config', job_kwargs={'filename': temp_file, 'commit_jid': current_jid, 'replace': replace}, once=commit_time)\n                log.debug('Scheduling job')\n                log.debug(scheduled)\n                saved = __salt__['schedule.save']()\n                discarded = _safe_dicard_config(loaded_result, napalm_device)\n                if not discarded['result']:\n                    discarded['comment'] += 'Scheduled the job to be executed at {schedule_ts}, but was unable to discard the config: \\n'.format(schedule_ts=commit_time)\n                    return discarded\n                loaded_result['comment'] = 'Changes discarded for now, and scheduled commit at: {schedule_ts}.\\nThe commit ID is: {current_jid}.\\nTo discard this commit, you can execute: \\n\\nsalt {min_id} net.cancel_commit {current_jid}'.format(schedule_ts=commit_time, min_id=__opts__['id'], current_jid=current_jid)\n                loaded_result['commit_id'] = current_jid\n                return loaded_result\n            log.debug('About to commit:')\n            log.debug(loaded_result['diff'])\n            if revert_in or revert_at:\n                revert_time = __utils__['timeutil.get_time_at'](time_in=revert_in, time_at=revert_at)\n                if __grains__['os'] == 'junos':\n                    if not HAS_JXMLEASE:\n                        loaded_result['comment'] = 'This feature requires the library jxmlease to be installed.\\nTo install, please execute: ``pip install jxmlease``.'\n                        loaded_result['result'] = False\n                        return loaded_result\n                    timestamp_at = __utils__['timeutil.get_timestamp_at'](time_in=revert_in, time_at=revert_at)\n                    minutes = int((timestamp_at - time.time()) / 60)\n                    _comm = __salt__['napalm.junos_commit'](confirm=minutes)\n                    if not _comm['out']:\n                        loaded_result['comment'] = 'Unable to commit confirm: {}'.format(_comm['message'])\n                        loaded_result['result'] = False\n                        discarded = _safe_dicard_config(loaded_result, napalm_device)\n                        if not discarded['result']:\n                            return loaded_result\n                else:\n                    temp_file = salt.utils.files.mkstemp()\n                    running_config = __salt__['net.config'](source='running')['out']['running']\n                    with salt.utils.files.fopen(temp_file, 'w') as fp_:\n                        fp_.write(running_config)\n                    committed = _safe_commit_config(loaded_result, napalm_device)\n                    if not committed['result']:\n                        return loaded_result\n                    scheduled_job_name = '__napalm_commit_{}'.format(current_jid)\n                    scheduled = __salt__['schedule.add'](scheduled_job_name, function='net.load_config', job_kwargs={'filename': temp_file, 'commit_jid': current_jid, 'replace': True}, once=revert_time)\n                    log.debug('Scheduling commit confirmed')\n                    log.debug(scheduled)\n                    saved = __salt__['schedule.save']()\n                loaded_result['comment'] = 'The commit ID is: {current_jid}.\\nThis commit will be reverted at: {schedule_ts}, unless confirmed.\\nTo confirm the commit and avoid reverting, you can execute:\\n\\nsalt {min_id} net.confirm_commit {current_jid}'.format(schedule_ts=revert_time, min_id=__opts__['id'], current_jid=current_jid)\n                loaded_result['commit_id'] = current_jid\n                return loaded_result\n            committed = _safe_commit_config(loaded_result, napalm_device)\n            if not committed['result']:\n                return loaded_result\n        else:\n            discarded = _safe_dicard_config(loaded_result, napalm_device)\n            if not discarded['result']:\n                return loaded_result\n            loaded_result['already_configured'] = True\n            loaded_result['comment'] = 'Already configured.'\n    _explicit_close(napalm_device)\n    if not loaded_result['result']:\n        __context__['retcode'] = 1\n    return loaded_result"
        ]
    },
    {
        "func_name": "connected",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef connected(**kwargs):\n    \"\"\"\n    Specifies if the connection to the device succeeded.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.connected\n    \"\"\"\n    return {'out': napalm_device.get('UP', False)}",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef connected(**kwargs):\n    if False:\n        i = 10\n    \"\\n    Specifies if the connection to the device succeeded.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.connected\\n    \"\n    return {'out': napalm_device.get('UP', False)}",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef connected(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Specifies if the connection to the device succeeded.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.connected\\n    \"\n    return {'out': napalm_device.get('UP', False)}",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef connected(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Specifies if the connection to the device succeeded.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.connected\\n    \"\n    return {'out': napalm_device.get('UP', False)}",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef connected(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Specifies if the connection to the device succeeded.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.connected\\n    \"\n    return {'out': napalm_device.get('UP', False)}",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef connected(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Specifies if the connection to the device succeeded.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.connected\\n    \"\n    return {'out': napalm_device.get('UP', False)}"
        ]
    },
    {
        "func_name": "facts",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef facts(**kwargs):\n    \"\"\"\n    Returns characteristics of the network device.\n    :return: a dictionary with the following keys:\n\n        * uptime - Uptime of the device in seconds.\n        * vendor - Manufacturer of the device.\n        * model - Device model.\n        * hostname - Hostname of the device\n        * fqdn - Fqdn of the device\n        * os_version - String with the OS version running on the device.\n        * serial_number - Serial number of the device\n        * interface_list - List of the interfaces of the device\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.facts\n\n    Example output:\n\n    .. code-block:: python\n\n        {\n            'os_version': '13.3R6.5',\n            'uptime': 10117140,\n            'interface_list': [\n                'lc-0/0/0',\n                'pfe-0/0/0',\n                'pfh-0/0/0',\n                'xe-0/0/0',\n                'xe-0/0/1',\n                'xe-0/0/2',\n                'xe-0/0/3',\n                'gr-0/0/10',\n                'ip-0/0/10'\n            ],\n            'vendor': 'Juniper',\n            'serial_number': 'JN131356FBFA',\n            'model': 'MX480',\n            'hostname': 're0.edge05.syd01',\n            'fqdn': 're0.edge05.syd01'\n        }\n    \"\"\"\n    return salt.utils.napalm.call(napalm_device, 'get_facts', **{})",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef facts(**kwargs):\n    if False:\n        i = 10\n    \"\\n    Returns characteristics of the network device.\\n    :return: a dictionary with the following keys:\\n\\n        * uptime - Uptime of the device in seconds.\\n        * vendor - Manufacturer of the device.\\n        * model - Device model.\\n        * hostname - Hostname of the device\\n        * fqdn - Fqdn of the device\\n        * os_version - String with the OS version running on the device.\\n        * serial_number - Serial number of the device\\n        * interface_list - List of the interfaces of the device\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.facts\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'os_version': '13.3R6.5',\\n            'uptime': 10117140,\\n            'interface_list': [\\n                'lc-0/0/0',\\n                'pfe-0/0/0',\\n                'pfh-0/0/0',\\n                'xe-0/0/0',\\n                'xe-0/0/1',\\n                'xe-0/0/2',\\n                'xe-0/0/3',\\n                'gr-0/0/10',\\n                'ip-0/0/10'\\n            ],\\n            'vendor': 'Juniper',\\n            'serial_number': 'JN131356FBFA',\\n            'model': 'MX480',\\n            'hostname': 're0.edge05.syd01',\\n            'fqdn': 're0.edge05.syd01'\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_facts', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef facts(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Returns characteristics of the network device.\\n    :return: a dictionary with the following keys:\\n\\n        * uptime - Uptime of the device in seconds.\\n        * vendor - Manufacturer of the device.\\n        * model - Device model.\\n        * hostname - Hostname of the device\\n        * fqdn - Fqdn of the device\\n        * os_version - String with the OS version running on the device.\\n        * serial_number - Serial number of the device\\n        * interface_list - List of the interfaces of the device\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.facts\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'os_version': '13.3R6.5',\\n            'uptime': 10117140,\\n            'interface_list': [\\n                'lc-0/0/0',\\n                'pfe-0/0/0',\\n                'pfh-0/0/0',\\n                'xe-0/0/0',\\n                'xe-0/0/1',\\n                'xe-0/0/2',\\n                'xe-0/0/3',\\n                'gr-0/0/10',\\n                'ip-0/0/10'\\n            ],\\n            'vendor': 'Juniper',\\n            'serial_number': 'JN131356FBFA',\\n            'model': 'MX480',\\n            'hostname': 're0.edge05.syd01',\\n            'fqdn': 're0.edge05.syd01'\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_facts', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef facts(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Returns characteristics of the network device.\\n    :return: a dictionary with the following keys:\\n\\n        * uptime - Uptime of the device in seconds.\\n        * vendor - Manufacturer of the device.\\n        * model - Device model.\\n        * hostname - Hostname of the device\\n        * fqdn - Fqdn of the device\\n        * os_version - String with the OS version running on the device.\\n        * serial_number - Serial number of the device\\n        * interface_list - List of the interfaces of the device\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.facts\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'os_version': '13.3R6.5',\\n            'uptime': 10117140,\\n            'interface_list': [\\n                'lc-0/0/0',\\n                'pfe-0/0/0',\\n                'pfh-0/0/0',\\n                'xe-0/0/0',\\n                'xe-0/0/1',\\n                'xe-0/0/2',\\n                'xe-0/0/3',\\n                'gr-0/0/10',\\n                'ip-0/0/10'\\n            ],\\n            'vendor': 'Juniper',\\n            'serial_number': 'JN131356FBFA',\\n            'model': 'MX480',\\n            'hostname': 're0.edge05.syd01',\\n            'fqdn': 're0.edge05.syd01'\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_facts', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef facts(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Returns characteristics of the network device.\\n    :return: a dictionary with the following keys:\\n\\n        * uptime - Uptime of the device in seconds.\\n        * vendor - Manufacturer of the device.\\n        * model - Device model.\\n        * hostname - Hostname of the device\\n        * fqdn - Fqdn of the device\\n        * os_version - String with the OS version running on the device.\\n        * serial_number - Serial number of the device\\n        * interface_list - List of the interfaces of the device\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.facts\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'os_version': '13.3R6.5',\\n            'uptime': 10117140,\\n            'interface_list': [\\n                'lc-0/0/0',\\n                'pfe-0/0/0',\\n                'pfh-0/0/0',\\n                'xe-0/0/0',\\n                'xe-0/0/1',\\n                'xe-0/0/2',\\n                'xe-0/0/3',\\n                'gr-0/0/10',\\n                'ip-0/0/10'\\n            ],\\n            'vendor': 'Juniper',\\n            'serial_number': 'JN131356FBFA',\\n            'model': 'MX480',\\n            'hostname': 're0.edge05.syd01',\\n            'fqdn': 're0.edge05.syd01'\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_facts', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef facts(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Returns characteristics of the network device.\\n    :return: a dictionary with the following keys:\\n\\n        * uptime - Uptime of the device in seconds.\\n        * vendor - Manufacturer of the device.\\n        * model - Device model.\\n        * hostname - Hostname of the device\\n        * fqdn - Fqdn of the device\\n        * os_version - String with the OS version running on the device.\\n        * serial_number - Serial number of the device\\n        * interface_list - List of the interfaces of the device\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.facts\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'os_version': '13.3R6.5',\\n            'uptime': 10117140,\\n            'interface_list': [\\n                'lc-0/0/0',\\n                'pfe-0/0/0',\\n                'pfh-0/0/0',\\n                'xe-0/0/0',\\n                'xe-0/0/1',\\n                'xe-0/0/2',\\n                'xe-0/0/3',\\n                'gr-0/0/10',\\n                'ip-0/0/10'\\n            ],\\n            'vendor': 'Juniper',\\n            'serial_number': 'JN131356FBFA',\\n            'model': 'MX480',\\n            'hostname': 're0.edge05.syd01',\\n            'fqdn': 're0.edge05.syd01'\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_facts', **{})"
        ]
    },
    {
        "func_name": "environment",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef environment(**kwargs):\n    \"\"\"\n    Returns the environment of the device.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.environment\n\n\n    Example output:\n\n    .. code-block:: python\n\n        {\n            'fans': {\n                'Bottom Rear Fan': {\n                    'status': True\n                },\n                'Bottom Middle Fan': {\n                    'status': True\n                },\n                'Top Middle Fan': {\n                    'status': True\n                },\n                'Bottom Front Fan': {\n                    'status': True\n                },\n                'Top Front Fan': {\n                    'status': True\n                },\n                'Top Rear Fan': {\n                    'status': True\n                }\n            },\n            'memory': {\n                'available_ram': 16349,\n                'used_ram': 4934\n            },\n            'temperature': {\n               'FPC 0 Exhaust A': {\n                    'is_alert': False,\n                    'temperature': 35.0,\n                    'is_critical': False\n                }\n            },\n            'cpu': {\n                '1': {\n                    '%usage': 19.0\n                },\n                '0': {\n                    '%usage': 35.0\n                }\n            }\n        }\n    \"\"\"\n    return salt.utils.napalm.call(napalm_device, 'get_environment', **{})",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef environment(**kwargs):\n    if False:\n        i = 10\n    \"\\n    Returns the environment of the device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.environment\\n\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'fans': {\\n                'Bottom Rear Fan': {\\n                    'status': True\\n                },\\n                'Bottom Middle Fan': {\\n                    'status': True\\n                },\\n                'Top Middle Fan': {\\n                    'status': True\\n                },\\n                'Bottom Front Fan': {\\n                    'status': True\\n                },\\n                'Top Front Fan': {\\n                    'status': True\\n                },\\n                'Top Rear Fan': {\\n                    'status': True\\n                }\\n            },\\n            'memory': {\\n                'available_ram': 16349,\\n                'used_ram': 4934\\n            },\\n            'temperature': {\\n               'FPC 0 Exhaust A': {\\n                    'is_alert': False,\\n                    'temperature': 35.0,\\n                    'is_critical': False\\n                }\\n            },\\n            'cpu': {\\n                '1': {\\n                    '%usage': 19.0\\n                },\\n                '0': {\\n                    '%usage': 35.0\\n                }\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_environment', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef environment(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Returns the environment of the device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.environment\\n\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'fans': {\\n                'Bottom Rear Fan': {\\n                    'status': True\\n                },\\n                'Bottom Middle Fan': {\\n                    'status': True\\n                },\\n                'Top Middle Fan': {\\n                    'status': True\\n                },\\n                'Bottom Front Fan': {\\n                    'status': True\\n                },\\n                'Top Front Fan': {\\n                    'status': True\\n                },\\n                'Top Rear Fan': {\\n                    'status': True\\n                }\\n            },\\n            'memory': {\\n                'available_ram': 16349,\\n                'used_ram': 4934\\n            },\\n            'temperature': {\\n               'FPC 0 Exhaust A': {\\n                    'is_alert': False,\\n                    'temperature': 35.0,\\n                    'is_critical': False\\n                }\\n            },\\n            'cpu': {\\n                '1': {\\n                    '%usage': 19.0\\n                },\\n                '0': {\\n                    '%usage': 35.0\\n                }\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_environment', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef environment(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Returns the environment of the device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.environment\\n\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'fans': {\\n                'Bottom Rear Fan': {\\n                    'status': True\\n                },\\n                'Bottom Middle Fan': {\\n                    'status': True\\n                },\\n                'Top Middle Fan': {\\n                    'status': True\\n                },\\n                'Bottom Front Fan': {\\n                    'status': True\\n                },\\n                'Top Front Fan': {\\n                    'status': True\\n                },\\n                'Top Rear Fan': {\\n                    'status': True\\n                }\\n            },\\n            'memory': {\\n                'available_ram': 16349,\\n                'used_ram': 4934\\n            },\\n            'temperature': {\\n               'FPC 0 Exhaust A': {\\n                    'is_alert': False,\\n                    'temperature': 35.0,\\n                    'is_critical': False\\n                }\\n            },\\n            'cpu': {\\n                '1': {\\n                    '%usage': 19.0\\n                },\\n                '0': {\\n                    '%usage': 35.0\\n                }\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_environment', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef environment(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Returns the environment of the device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.environment\\n\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'fans': {\\n                'Bottom Rear Fan': {\\n                    'status': True\\n                },\\n                'Bottom Middle Fan': {\\n                    'status': True\\n                },\\n                'Top Middle Fan': {\\n                    'status': True\\n                },\\n                'Bottom Front Fan': {\\n                    'status': True\\n                },\\n                'Top Front Fan': {\\n                    'status': True\\n                },\\n                'Top Rear Fan': {\\n                    'status': True\\n                }\\n            },\\n            'memory': {\\n                'available_ram': 16349,\\n                'used_ram': 4934\\n            },\\n            'temperature': {\\n               'FPC 0 Exhaust A': {\\n                    'is_alert': False,\\n                    'temperature': 35.0,\\n                    'is_critical': False\\n                }\\n            },\\n            'cpu': {\\n                '1': {\\n                    '%usage': 19.0\\n                },\\n                '0': {\\n                    '%usage': 35.0\\n                }\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_environment', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef environment(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Returns the environment of the device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.environment\\n\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'fans': {\\n                'Bottom Rear Fan': {\\n                    'status': True\\n                },\\n                'Bottom Middle Fan': {\\n                    'status': True\\n                },\\n                'Top Middle Fan': {\\n                    'status': True\\n                },\\n                'Bottom Front Fan': {\\n                    'status': True\\n                },\\n                'Top Front Fan': {\\n                    'status': True\\n                },\\n                'Top Rear Fan': {\\n                    'status': True\\n                }\\n            },\\n            'memory': {\\n                'available_ram': 16349,\\n                'used_ram': 4934\\n            },\\n            'temperature': {\\n               'FPC 0 Exhaust A': {\\n                    'is_alert': False,\\n                    'temperature': 35.0,\\n                    'is_critical': False\\n                }\\n            },\\n            'cpu': {\\n                '1': {\\n                    '%usage': 19.0\\n                },\\n                '0': {\\n                    '%usage': 35.0\\n                }\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_environment', **{})"
        ]
    },
    {
        "func_name": "cli",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef cli(*commands, **kwargs):\n    \"\"\"\n    Returns a dictionary with the raw output of all commands passed as arguments.\n\n    commands\n        List of commands to be executed on the device.\n\n    textfsm_parse: ``False``\n        Try parsing the outputs using the TextFSM templates.\n\n        .. versionadded:: 2018.3.0\n\n        .. note::\n            This option can be also specified in the minion configuration\n            file or pillar as ``napalm_cli_textfsm_parse``.\n\n    textfsm_path\n        The path where the TextFSM templates can be found. This option implies\n        the usage of the TextFSM index file.\n        ``textfsm_path`` can be either absolute path on the server,\n        either specified using the following URL mschemes: ``file://``,\n        ``salt://``, ``http://``, ``https://``, ``ftp://``,\n        ``s3://``, ``swift://``.\n\n        .. versionadded:: 2018.3.0\n\n        .. note::\n            This needs to be a directory with a flat structure, having an\n            index file (whose name can be specified using the ``index_file`` option)\n            and a number of TextFSM templates.\n\n        .. note::\n            This option can be also specified in the minion configuration\n            file or pillar as ``textfsm_path``.\n\n    textfsm_template\n        The path to a certain the TextFSM template.\n        This can be specified using the absolute path\n        to the file, or using one of the following URL schemes:\n\n        - ``salt://``, to fetch the template from the Salt fileserver.\n        - ``http://`` or ``https://``\n        - ``ftp://``\n        - ``s3://``\n        - ``swift://``\n\n        .. versionadded:: 2018.3.0\n\n    textfsm_template_dict\n        A dictionary with the mapping between a command\n        and the corresponding TextFSM path to use to extract the data.\n        The TextFSM paths can be specified as in ``textfsm_template``.\n\n        .. versionadded:: 2018.3.0\n\n        .. note::\n            This option can be also specified in the minion configuration\n            file or pillar as ``napalm_cli_textfsm_template_dict``.\n\n    platform_grain_name: ``os``\n        The name of the grain used to identify the platform name\n        in the TextFSM index file. Default: ``os``.\n\n        .. versionadded:: 2018.3.0\n\n        .. note::\n            This option can be also specified in the minion configuration\n            file or pillar as ``textfsm_platform_grain``.\n\n    platform_column_name: ``Platform``\n        The column name used to identify the platform,\n        exactly as specified in the TextFSM index file.\n        Default: ``Platform``.\n\n        .. versionadded:: 2018.3.0\n\n        .. note::\n            This is field is case sensitive, make sure\n            to assign the correct value to this option,\n            exactly as defined in the index file.\n\n        .. note::\n            This option can be also specified in the minion configuration\n            file or pillar as ``textfsm_platform_column_name``.\n\n    index_file: ``index``\n        The name of the TextFSM index file, under the ``textfsm_path``. Default: ``index``.\n\n        .. versionadded:: 2018.3.0\n\n        .. note::\n            This option can be also specified in the minion configuration\n            file or pillar as ``textfsm_index_file``.\n\n    saltenv: ``base``\n        Salt fileserver environment from which to retrieve the file.\n        Ignored if ``textfsm_path`` is not a ``salt://`` URL.\n\n        .. versionadded:: 2018.3.0\n\n    include_empty: ``False``\n        Include empty files under the ``textfsm_path``.\n\n        .. versionadded:: 2018.3.0\n\n    include_pat\n        Glob or regex to narrow down the files cached from the given path.\n        If matching with a regex, the regex must be prefixed with ``E@``,\n        otherwise the expression will be interpreted as a glob.\n\n        .. versionadded:: 2018.3.0\n\n    exclude_pat\n        Glob or regex to exclude certain files from being cached from the given path.\n        If matching with a regex, the regex must be prefixed with ``E@``,\n        otherwise the expression will be interpreted as a glob.\n\n        .. versionadded:: 2018.3.0\n\n        .. note::\n            If used with ``include_pat``, files matching this pattern will be\n            excluded from the subset of files defined by ``include_pat``.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.cli \"show version\" \"show chassis fan\"\n\n    CLI Example with TextFSM template:\n\n    .. code-block:: bash\n\n        salt '*' net.cli textfsm_parse=True textfsm_path=salt://textfsm/\n\n    Example output:\n\n    .. code-block:: python\n\n        {\n            'show version and haiku':  'Hostname: re0.edge01.arn01\n                                          Model: mx480\n                                          Junos: 13.3R6.5\n                                            Help me, Obi-Wan\n                                            I just saw Episode Two\n                                            You're my only hope\n                                         ',\n            'show chassis fan' :   'Item                      Status   RPM     Measurement\n                                      Top Rear Fan              OK       3840    Spinning at intermediate-speed\n                                      Bottom Rear Fan           OK       3840    Spinning at intermediate-speed\n                                      Top Middle Fan            OK       3900    Spinning at intermediate-speed\n                                      Bottom Middle Fan         OK       3840    Spinning at intermediate-speed\n                                      Top Front Fan             OK       3810    Spinning at intermediate-speed\n                                      Bottom Front Fan          OK       3840    Spinning at intermediate-speed\n                                     '\n        }\n\n    Example output with TextFSM parsing:\n\n    .. code-block:: json\n\n        {\n          \"comment\": \"\",\n          \"result\": true,\n          \"out\": {\n            \"sh ver\": [\n              {\n                \"kernel\": \"9.1S3.5\",\n                \"documentation\": \"9.1S3.5\",\n                \"boot\": \"9.1S3.5\",\n                \"crypto\": \"9.1S3.5\",\n                \"chassis\": \"\",\n                \"routing\": \"9.1S3.5\",\n                \"base\": \"9.1S3.5\",\n                \"model\": \"mx960\"\n              }\n            ]\n          }\n        }\n    \"\"\"\n    raw_cli_outputs = salt.utils.napalm.call(napalm_device, 'cli', **{'commands': list(commands)})\n    if not raw_cli_outputs['result']:\n        return raw_cli_outputs\n    textfsm_parse = kwargs.get('textfsm_parse') or __opts__.get('napalm_cli_textfsm_parse') or __pillar__.get('napalm_cli_textfsm_parse', False)\n    if not textfsm_parse:\n        log.debug('No TextFSM parsing requested.')\n        return raw_cli_outputs\n    if 'textfsm.extract' not in __salt__ or 'textfsm.index' not in __salt__:\n        raw_cli_outputs['comment'] += 'Unable to process: is TextFSM installed?'\n        log.error(raw_cli_outputs['comment'])\n        return raw_cli_outputs\n    textfsm_template = kwargs.get('textfsm_template')\n    log.debug('textfsm_template: %s', textfsm_template)\n    textfsm_path = kwargs.get('textfsm_path') or __opts__.get('textfsm_path') or __pillar__.get('textfsm_path')\n    log.debug('textfsm_path: %s', textfsm_path)\n    textfsm_template_dict = kwargs.get('textfsm_template_dict') or __opts__.get('napalm_cli_textfsm_template_dict') or __pillar__.get('napalm_cli_textfsm_template_dict', {})\n    log.debug('TextFSM command-template mapping: %s', textfsm_template_dict)\n    index_file = kwargs.get('index_file') or __opts__.get('textfsm_index_file') or __pillar__.get('textfsm_index_file')\n    log.debug('index_file: %s', index_file)\n    platform_grain_name = kwargs.get('platform_grain_name') or __opts__.get('textfsm_platform_grain') or __pillar__.get('textfsm_platform_grain', 'os')\n    log.debug('platform_grain_name: %s', platform_grain_name)\n    platform_column_name = kwargs.get('platform_column_name') or __opts__.get('textfsm_platform_column_name') or __pillar__.get('textfsm_platform_column_name', 'Platform')\n    log.debug('platform_column_name: %s', platform_column_name)\n    saltenv = kwargs.get('saltenv', 'base')\n    include_empty = kwargs.get('include_empty', False)\n    include_pat = kwargs.get('include_pat')\n    exclude_pat = kwargs.get('exclude_pat')\n    processed_cli_outputs = {'comment': raw_cli_outputs.get('comment', ''), 'result': raw_cli_outputs['result'], 'out': {}}\n    log.debug('Starting to analyse the raw outputs')\n    for command in list(commands):\n        command_output = raw_cli_outputs['out'][command]\n        log.debug('Output from command: %s', command)\n        log.debug(command_output)\n        processed_command_output = None\n        if textfsm_path:\n            log.debug('Using the templates under %s', textfsm_path)\n            processed_cli_output = __salt__['textfsm.index'](command, platform_grain_name=platform_grain_name, platform_column_name=platform_column_name, output=command_output.strip(), textfsm_path=textfsm_path, saltenv=saltenv, include_empty=include_empty, include_pat=include_pat, exclude_pat=exclude_pat)\n            log.debug('Processed CLI output:')\n            log.debug(processed_cli_output)\n            if not processed_cli_output['result']:\n                log.debug('Apparently this did not work, returning the raw output')\n                processed_command_output = command_output\n                processed_cli_outputs['comment'] += '\\nUnable to process the output from {}: {}.'.format(command, processed_cli_output['comment'])\n                log.error(processed_cli_outputs['comment'])\n            elif processed_cli_output['out']:\n                log.debug('All good, %s has a nice output!', command)\n                processed_command_output = processed_cli_output['out']\n            else:\n                comment = '\\nProcessing \"{}\" didn\\'t fail, but didn\\'t return anything either. Dumping raw.'.format(command)\n                processed_cli_outputs['comment'] += comment\n                log.error(comment)\n                processed_command_output = command_output\n        elif textfsm_template or command in textfsm_template_dict:\n            if command in textfsm_template_dict:\n                textfsm_template = textfsm_template_dict[command]\n            log.debug('Using %s to process the command: %s', textfsm_template, command)\n            processed_cli_output = __salt__['textfsm.extract'](textfsm_template, raw_text=command_output, saltenv=saltenv)\n            log.debug('Processed CLI output:')\n            log.debug(processed_cli_output)\n            if not processed_cli_output['result']:\n                log.debug('Apparently this did not work, returning the raw output')\n                processed_command_output = command_output\n                processed_cli_outputs['comment'] += '\\nUnable to process the output from {}: {}'.format(command, processed_cli_output['comment'])\n                log.error(processed_cli_outputs['comment'])\n            elif processed_cli_output['out']:\n                log.debug('All good, %s has a nice output!', command)\n                processed_command_output = processed_cli_output['out']\n            else:\n                log.debug('Processing %s did not fail, but did not return anything either. Dumping raw.', command)\n                processed_command_output = command_output\n        else:\n            log.error('No TextFSM template specified, or no TextFSM path defined')\n            processed_command_output = command_output\n            processed_cli_outputs['comment'] += '\\nUnable to process the output from {}.'.format(command)\n        processed_cli_outputs['out'][command] = processed_command_output\n    processed_cli_outputs['comment'] = processed_cli_outputs['comment'].strip()\n    return processed_cli_outputs",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef cli(*commands, **kwargs):\n    if False:\n        i = 10\n    '\\n    Returns a dictionary with the raw output of all commands passed as arguments.\\n\\n    commands\\n        List of commands to be executed on the device.\\n\\n    textfsm_parse: ``False``\\n        Try parsing the outputs using the TextFSM templates.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``napalm_cli_textfsm_parse``.\\n\\n    textfsm_path\\n        The path where the TextFSM templates can be found. This option implies\\n        the usage of the TextFSM index file.\\n        ``textfsm_path`` can be either absolute path on the server,\\n        either specified using the following URL mschemes: ``file://``,\\n        ``salt://``, ``http://``, ``https://``, ``ftp://``,\\n        ``s3://``, ``swift://``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This needs to be a directory with a flat structure, having an\\n            index file (whose name can be specified using the ``index_file`` option)\\n            and a number of TextFSM templates.\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_path``.\\n\\n    textfsm_template\\n        The path to a certain the TextFSM template.\\n        This can be specified using the absolute path\\n        to the file, or using one of the following URL schemes:\\n\\n        - ``salt://``, to fetch the template from the Salt fileserver.\\n        - ``http://`` or ``https://``\\n        - ``ftp://``\\n        - ``s3://``\\n        - ``swift://``\\n\\n        .. versionadded:: 2018.3.0\\n\\n    textfsm_template_dict\\n        A dictionary with the mapping between a command\\n        and the corresponding TextFSM path to use to extract the data.\\n        The TextFSM paths can be specified as in ``textfsm_template``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``napalm_cli_textfsm_template_dict``.\\n\\n    platform_grain_name: ``os``\\n        The name of the grain used to identify the platform name\\n        in the TextFSM index file. Default: ``os``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_platform_grain``.\\n\\n    platform_column_name: ``Platform``\\n        The column name used to identify the platform,\\n        exactly as specified in the TextFSM index file.\\n        Default: ``Platform``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This is field is case sensitive, make sure\\n            to assign the correct value to this option,\\n            exactly as defined in the index file.\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_platform_column_name``.\\n\\n    index_file: ``index``\\n        The name of the TextFSM index file, under the ``textfsm_path``. Default: ``index``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_index_file``.\\n\\n    saltenv: ``base``\\n        Salt fileserver environment from which to retrieve the file.\\n        Ignored if ``textfsm_path`` is not a ``salt://`` URL.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    include_empty: ``False``\\n        Include empty files under the ``textfsm_path``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    include_pat\\n        Glob or regex to narrow down the files cached from the given path.\\n        If matching with a regex, the regex must be prefixed with ``E@``,\\n        otherwise the expression will be interpreted as a glob.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    exclude_pat\\n        Glob or regex to exclude certain files from being cached from the given path.\\n        If matching with a regex, the regex must be prefixed with ``E@``,\\n        otherwise the expression will be interpreted as a glob.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            If used with ``include_pat``, files matching this pattern will be\\n            excluded from the subset of files defined by ``include_pat``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.cli \"show version\" \"show chassis fan\"\\n\\n    CLI Example with TextFSM template:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.cli textfsm_parse=True textfsm_path=salt://textfsm/\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'show version and haiku\\':  \\'Hostname: re0.edge01.arn01\\n                                          Model: mx480\\n                                          Junos: 13.3R6.5\\n                                            Help me, Obi-Wan\\n                                            I just saw Episode Two\\n                                            You\\'re my only hope\\n                                         \\',\\n            \\'show chassis fan\\' :   \\'Item                      Status   RPM     Measurement\\n                                      Top Rear Fan              OK       3840    Spinning at intermediate-speed\\n                                      Bottom Rear Fan           OK       3840    Spinning at intermediate-speed\\n                                      Top Middle Fan            OK       3900    Spinning at intermediate-speed\\n                                      Bottom Middle Fan         OK       3840    Spinning at intermediate-speed\\n                                      Top Front Fan             OK       3810    Spinning at intermediate-speed\\n                                      Bottom Front Fan          OK       3840    Spinning at intermediate-speed\\n                                     \\'\\n        }\\n\\n    Example output with TextFSM parsing:\\n\\n    .. code-block:: json\\n\\n        {\\n          \"comment\": \"\",\\n          \"result\": true,\\n          \"out\": {\\n            \"sh ver\": [\\n              {\\n                \"kernel\": \"9.1S3.5\",\\n                \"documentation\": \"9.1S3.5\",\\n                \"boot\": \"9.1S3.5\",\\n                \"crypto\": \"9.1S3.5\",\\n                \"chassis\": \"\",\\n                \"routing\": \"9.1S3.5\",\\n                \"base\": \"9.1S3.5\",\\n                \"model\": \"mx960\"\\n              }\\n            ]\\n          }\\n        }\\n    '\n    raw_cli_outputs = salt.utils.napalm.call(napalm_device, 'cli', **{'commands': list(commands)})\n    if not raw_cli_outputs['result']:\n        return raw_cli_outputs\n    textfsm_parse = kwargs.get('textfsm_parse') or __opts__.get('napalm_cli_textfsm_parse') or __pillar__.get('napalm_cli_textfsm_parse', False)\n    if not textfsm_parse:\n        log.debug('No TextFSM parsing requested.')\n        return raw_cli_outputs\n    if 'textfsm.extract' not in __salt__ or 'textfsm.index' not in __salt__:\n        raw_cli_outputs['comment'] += 'Unable to process: is TextFSM installed?'\n        log.error(raw_cli_outputs['comment'])\n        return raw_cli_outputs\n    textfsm_template = kwargs.get('textfsm_template')\n    log.debug('textfsm_template: %s', textfsm_template)\n    textfsm_path = kwargs.get('textfsm_path') or __opts__.get('textfsm_path') or __pillar__.get('textfsm_path')\n    log.debug('textfsm_path: %s', textfsm_path)\n    textfsm_template_dict = kwargs.get('textfsm_template_dict') or __opts__.get('napalm_cli_textfsm_template_dict') or __pillar__.get('napalm_cli_textfsm_template_dict', {})\n    log.debug('TextFSM command-template mapping: %s', textfsm_template_dict)\n    index_file = kwargs.get('index_file') or __opts__.get('textfsm_index_file') or __pillar__.get('textfsm_index_file')\n    log.debug('index_file: %s', index_file)\n    platform_grain_name = kwargs.get('platform_grain_name') or __opts__.get('textfsm_platform_grain') or __pillar__.get('textfsm_platform_grain', 'os')\n    log.debug('platform_grain_name: %s', platform_grain_name)\n    platform_column_name = kwargs.get('platform_column_name') or __opts__.get('textfsm_platform_column_name') or __pillar__.get('textfsm_platform_column_name', 'Platform')\n    log.debug('platform_column_name: %s', platform_column_name)\n    saltenv = kwargs.get('saltenv', 'base')\n    include_empty = kwargs.get('include_empty', False)\n    include_pat = kwargs.get('include_pat')\n    exclude_pat = kwargs.get('exclude_pat')\n    processed_cli_outputs = {'comment': raw_cli_outputs.get('comment', ''), 'result': raw_cli_outputs['result'], 'out': {}}\n    log.debug('Starting to analyse the raw outputs')\n    for command in list(commands):\n        command_output = raw_cli_outputs['out'][command]\n        log.debug('Output from command: %s', command)\n        log.debug(command_output)\n        processed_command_output = None\n        if textfsm_path:\n            log.debug('Using the templates under %s', textfsm_path)\n            processed_cli_output = __salt__['textfsm.index'](command, platform_grain_name=platform_grain_name, platform_column_name=platform_column_name, output=command_output.strip(), textfsm_path=textfsm_path, saltenv=saltenv, include_empty=include_empty, include_pat=include_pat, exclude_pat=exclude_pat)\n            log.debug('Processed CLI output:')\n            log.debug(processed_cli_output)\n            if not processed_cli_output['result']:\n                log.debug('Apparently this did not work, returning the raw output')\n                processed_command_output = command_output\n                processed_cli_outputs['comment'] += '\\nUnable to process the output from {}: {}.'.format(command, processed_cli_output['comment'])\n                log.error(processed_cli_outputs['comment'])\n            elif processed_cli_output['out']:\n                log.debug('All good, %s has a nice output!', command)\n                processed_command_output = processed_cli_output['out']\n            else:\n                comment = '\\nProcessing \"{}\" didn\\'t fail, but didn\\'t return anything either. Dumping raw.'.format(command)\n                processed_cli_outputs['comment'] += comment\n                log.error(comment)\n                processed_command_output = command_output\n        elif textfsm_template or command in textfsm_template_dict:\n            if command in textfsm_template_dict:\n                textfsm_template = textfsm_template_dict[command]\n            log.debug('Using %s to process the command: %s', textfsm_template, command)\n            processed_cli_output = __salt__['textfsm.extract'](textfsm_template, raw_text=command_output, saltenv=saltenv)\n            log.debug('Processed CLI output:')\n            log.debug(processed_cli_output)\n            if not processed_cli_output['result']:\n                log.debug('Apparently this did not work, returning the raw output')\n                processed_command_output = command_output\n                processed_cli_outputs['comment'] += '\\nUnable to process the output from {}: {}'.format(command, processed_cli_output['comment'])\n                log.error(processed_cli_outputs['comment'])\n            elif processed_cli_output['out']:\n                log.debug('All good, %s has a nice output!', command)\n                processed_command_output = processed_cli_output['out']\n            else:\n                log.debug('Processing %s did not fail, but did not return anything either. Dumping raw.', command)\n                processed_command_output = command_output\n        else:\n            log.error('No TextFSM template specified, or no TextFSM path defined')\n            processed_command_output = command_output\n            processed_cli_outputs['comment'] += '\\nUnable to process the output from {}.'.format(command)\n        processed_cli_outputs['out'][command] = processed_command_output\n    processed_cli_outputs['comment'] = processed_cli_outputs['comment'].strip()\n    return processed_cli_outputs",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef cli(*commands, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns a dictionary with the raw output of all commands passed as arguments.\\n\\n    commands\\n        List of commands to be executed on the device.\\n\\n    textfsm_parse: ``False``\\n        Try parsing the outputs using the TextFSM templates.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``napalm_cli_textfsm_parse``.\\n\\n    textfsm_path\\n        The path where the TextFSM templates can be found. This option implies\\n        the usage of the TextFSM index file.\\n        ``textfsm_path`` can be either absolute path on the server,\\n        either specified using the following URL mschemes: ``file://``,\\n        ``salt://``, ``http://``, ``https://``, ``ftp://``,\\n        ``s3://``, ``swift://``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This needs to be a directory with a flat structure, having an\\n            index file (whose name can be specified using the ``index_file`` option)\\n            and a number of TextFSM templates.\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_path``.\\n\\n    textfsm_template\\n        The path to a certain the TextFSM template.\\n        This can be specified using the absolute path\\n        to the file, or using one of the following URL schemes:\\n\\n        - ``salt://``, to fetch the template from the Salt fileserver.\\n        - ``http://`` or ``https://``\\n        - ``ftp://``\\n        - ``s3://``\\n        - ``swift://``\\n\\n        .. versionadded:: 2018.3.0\\n\\n    textfsm_template_dict\\n        A dictionary with the mapping between a command\\n        and the corresponding TextFSM path to use to extract the data.\\n        The TextFSM paths can be specified as in ``textfsm_template``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``napalm_cli_textfsm_template_dict``.\\n\\n    platform_grain_name: ``os``\\n        The name of the grain used to identify the platform name\\n        in the TextFSM index file. Default: ``os``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_platform_grain``.\\n\\n    platform_column_name: ``Platform``\\n        The column name used to identify the platform,\\n        exactly as specified in the TextFSM index file.\\n        Default: ``Platform``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This is field is case sensitive, make sure\\n            to assign the correct value to this option,\\n            exactly as defined in the index file.\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_platform_column_name``.\\n\\n    index_file: ``index``\\n        The name of the TextFSM index file, under the ``textfsm_path``. Default: ``index``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_index_file``.\\n\\n    saltenv: ``base``\\n        Salt fileserver environment from which to retrieve the file.\\n        Ignored if ``textfsm_path`` is not a ``salt://`` URL.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    include_empty: ``False``\\n        Include empty files under the ``textfsm_path``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    include_pat\\n        Glob or regex to narrow down the files cached from the given path.\\n        If matching with a regex, the regex must be prefixed with ``E@``,\\n        otherwise the expression will be interpreted as a glob.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    exclude_pat\\n        Glob or regex to exclude certain files from being cached from the given path.\\n        If matching with a regex, the regex must be prefixed with ``E@``,\\n        otherwise the expression will be interpreted as a glob.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            If used with ``include_pat``, files matching this pattern will be\\n            excluded from the subset of files defined by ``include_pat``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.cli \"show version\" \"show chassis fan\"\\n\\n    CLI Example with TextFSM template:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.cli textfsm_parse=True textfsm_path=salt://textfsm/\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'show version and haiku\\':  \\'Hostname: re0.edge01.arn01\\n                                          Model: mx480\\n                                          Junos: 13.3R6.5\\n                                            Help me, Obi-Wan\\n                                            I just saw Episode Two\\n                                            You\\'re my only hope\\n                                         \\',\\n            \\'show chassis fan\\' :   \\'Item                      Status   RPM     Measurement\\n                                      Top Rear Fan              OK       3840    Spinning at intermediate-speed\\n                                      Bottom Rear Fan           OK       3840    Spinning at intermediate-speed\\n                                      Top Middle Fan            OK       3900    Spinning at intermediate-speed\\n                                      Bottom Middle Fan         OK       3840    Spinning at intermediate-speed\\n                                      Top Front Fan             OK       3810    Spinning at intermediate-speed\\n                                      Bottom Front Fan          OK       3840    Spinning at intermediate-speed\\n                                     \\'\\n        }\\n\\n    Example output with TextFSM parsing:\\n\\n    .. code-block:: json\\n\\n        {\\n          \"comment\": \"\",\\n          \"result\": true,\\n          \"out\": {\\n            \"sh ver\": [\\n              {\\n                \"kernel\": \"9.1S3.5\",\\n                \"documentation\": \"9.1S3.5\",\\n                \"boot\": \"9.1S3.5\",\\n                \"crypto\": \"9.1S3.5\",\\n                \"chassis\": \"\",\\n                \"routing\": \"9.1S3.5\",\\n                \"base\": \"9.1S3.5\",\\n                \"model\": \"mx960\"\\n              }\\n            ]\\n          }\\n        }\\n    '\n    raw_cli_outputs = salt.utils.napalm.call(napalm_device, 'cli', **{'commands': list(commands)})\n    if not raw_cli_outputs['result']:\n        return raw_cli_outputs\n    textfsm_parse = kwargs.get('textfsm_parse') or __opts__.get('napalm_cli_textfsm_parse') or __pillar__.get('napalm_cli_textfsm_parse', False)\n    if not textfsm_parse:\n        log.debug('No TextFSM parsing requested.')\n        return raw_cli_outputs\n    if 'textfsm.extract' not in __salt__ or 'textfsm.index' not in __salt__:\n        raw_cli_outputs['comment'] += 'Unable to process: is TextFSM installed?'\n        log.error(raw_cli_outputs['comment'])\n        return raw_cli_outputs\n    textfsm_template = kwargs.get('textfsm_template')\n    log.debug('textfsm_template: %s', textfsm_template)\n    textfsm_path = kwargs.get('textfsm_path') or __opts__.get('textfsm_path') or __pillar__.get('textfsm_path')\n    log.debug('textfsm_path: %s', textfsm_path)\n    textfsm_template_dict = kwargs.get('textfsm_template_dict') or __opts__.get('napalm_cli_textfsm_template_dict') or __pillar__.get('napalm_cli_textfsm_template_dict', {})\n    log.debug('TextFSM command-template mapping: %s', textfsm_template_dict)\n    index_file = kwargs.get('index_file') or __opts__.get('textfsm_index_file') or __pillar__.get('textfsm_index_file')\n    log.debug('index_file: %s', index_file)\n    platform_grain_name = kwargs.get('platform_grain_name') or __opts__.get('textfsm_platform_grain') or __pillar__.get('textfsm_platform_grain', 'os')\n    log.debug('platform_grain_name: %s', platform_grain_name)\n    platform_column_name = kwargs.get('platform_column_name') or __opts__.get('textfsm_platform_column_name') or __pillar__.get('textfsm_platform_column_name', 'Platform')\n    log.debug('platform_column_name: %s', platform_column_name)\n    saltenv = kwargs.get('saltenv', 'base')\n    include_empty = kwargs.get('include_empty', False)\n    include_pat = kwargs.get('include_pat')\n    exclude_pat = kwargs.get('exclude_pat')\n    processed_cli_outputs = {'comment': raw_cli_outputs.get('comment', ''), 'result': raw_cli_outputs['result'], 'out': {}}\n    log.debug('Starting to analyse the raw outputs')\n    for command in list(commands):\n        command_output = raw_cli_outputs['out'][command]\n        log.debug('Output from command: %s', command)\n        log.debug(command_output)\n        processed_command_output = None\n        if textfsm_path:\n            log.debug('Using the templates under %s', textfsm_path)\n            processed_cli_output = __salt__['textfsm.index'](command, platform_grain_name=platform_grain_name, platform_column_name=platform_column_name, output=command_output.strip(), textfsm_path=textfsm_path, saltenv=saltenv, include_empty=include_empty, include_pat=include_pat, exclude_pat=exclude_pat)\n            log.debug('Processed CLI output:')\n            log.debug(processed_cli_output)\n            if not processed_cli_output['result']:\n                log.debug('Apparently this did not work, returning the raw output')\n                processed_command_output = command_output\n                processed_cli_outputs['comment'] += '\\nUnable to process the output from {}: {}.'.format(command, processed_cli_output['comment'])\n                log.error(processed_cli_outputs['comment'])\n            elif processed_cli_output['out']:\n                log.debug('All good, %s has a nice output!', command)\n                processed_command_output = processed_cli_output['out']\n            else:\n                comment = '\\nProcessing \"{}\" didn\\'t fail, but didn\\'t return anything either. Dumping raw.'.format(command)\n                processed_cli_outputs['comment'] += comment\n                log.error(comment)\n                processed_command_output = command_output\n        elif textfsm_template or command in textfsm_template_dict:\n            if command in textfsm_template_dict:\n                textfsm_template = textfsm_template_dict[command]\n            log.debug('Using %s to process the command: %s', textfsm_template, command)\n            processed_cli_output = __salt__['textfsm.extract'](textfsm_template, raw_text=command_output, saltenv=saltenv)\n            log.debug('Processed CLI output:')\n            log.debug(processed_cli_output)\n            if not processed_cli_output['result']:\n                log.debug('Apparently this did not work, returning the raw output')\n                processed_command_output = command_output\n                processed_cli_outputs['comment'] += '\\nUnable to process the output from {}: {}'.format(command, processed_cli_output['comment'])\n                log.error(processed_cli_outputs['comment'])\n            elif processed_cli_output['out']:\n                log.debug('All good, %s has a nice output!', command)\n                processed_command_output = processed_cli_output['out']\n            else:\n                log.debug('Processing %s did not fail, but did not return anything either. Dumping raw.', command)\n                processed_command_output = command_output\n        else:\n            log.error('No TextFSM template specified, or no TextFSM path defined')\n            processed_command_output = command_output\n            processed_cli_outputs['comment'] += '\\nUnable to process the output from {}.'.format(command)\n        processed_cli_outputs['out'][command] = processed_command_output\n    processed_cli_outputs['comment'] = processed_cli_outputs['comment'].strip()\n    return processed_cli_outputs",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef cli(*commands, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns a dictionary with the raw output of all commands passed as arguments.\\n\\n    commands\\n        List of commands to be executed on the device.\\n\\n    textfsm_parse: ``False``\\n        Try parsing the outputs using the TextFSM templates.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``napalm_cli_textfsm_parse``.\\n\\n    textfsm_path\\n        The path where the TextFSM templates can be found. This option implies\\n        the usage of the TextFSM index file.\\n        ``textfsm_path`` can be either absolute path on the server,\\n        either specified using the following URL mschemes: ``file://``,\\n        ``salt://``, ``http://``, ``https://``, ``ftp://``,\\n        ``s3://``, ``swift://``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This needs to be a directory with a flat structure, having an\\n            index file (whose name can be specified using the ``index_file`` option)\\n            and a number of TextFSM templates.\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_path``.\\n\\n    textfsm_template\\n        The path to a certain the TextFSM template.\\n        This can be specified using the absolute path\\n        to the file, or using one of the following URL schemes:\\n\\n        - ``salt://``, to fetch the template from the Salt fileserver.\\n        - ``http://`` or ``https://``\\n        - ``ftp://``\\n        - ``s3://``\\n        - ``swift://``\\n\\n        .. versionadded:: 2018.3.0\\n\\n    textfsm_template_dict\\n        A dictionary with the mapping between a command\\n        and the corresponding TextFSM path to use to extract the data.\\n        The TextFSM paths can be specified as in ``textfsm_template``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``napalm_cli_textfsm_template_dict``.\\n\\n    platform_grain_name: ``os``\\n        The name of the grain used to identify the platform name\\n        in the TextFSM index file. Default: ``os``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_platform_grain``.\\n\\n    platform_column_name: ``Platform``\\n        The column name used to identify the platform,\\n        exactly as specified in the TextFSM index file.\\n        Default: ``Platform``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This is field is case sensitive, make sure\\n            to assign the correct value to this option,\\n            exactly as defined in the index file.\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_platform_column_name``.\\n\\n    index_file: ``index``\\n        The name of the TextFSM index file, under the ``textfsm_path``. Default: ``index``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_index_file``.\\n\\n    saltenv: ``base``\\n        Salt fileserver environment from which to retrieve the file.\\n        Ignored if ``textfsm_path`` is not a ``salt://`` URL.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    include_empty: ``False``\\n        Include empty files under the ``textfsm_path``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    include_pat\\n        Glob or regex to narrow down the files cached from the given path.\\n        If matching with a regex, the regex must be prefixed with ``E@``,\\n        otherwise the expression will be interpreted as a glob.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    exclude_pat\\n        Glob or regex to exclude certain files from being cached from the given path.\\n        If matching with a regex, the regex must be prefixed with ``E@``,\\n        otherwise the expression will be interpreted as a glob.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            If used with ``include_pat``, files matching this pattern will be\\n            excluded from the subset of files defined by ``include_pat``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.cli \"show version\" \"show chassis fan\"\\n\\n    CLI Example with TextFSM template:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.cli textfsm_parse=True textfsm_path=salt://textfsm/\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'show version and haiku\\':  \\'Hostname: re0.edge01.arn01\\n                                          Model: mx480\\n                                          Junos: 13.3R6.5\\n                                            Help me, Obi-Wan\\n                                            I just saw Episode Two\\n                                            You\\'re my only hope\\n                                         \\',\\n            \\'show chassis fan\\' :   \\'Item                      Status   RPM     Measurement\\n                                      Top Rear Fan              OK       3840    Spinning at intermediate-speed\\n                                      Bottom Rear Fan           OK       3840    Spinning at intermediate-speed\\n                                      Top Middle Fan            OK       3900    Spinning at intermediate-speed\\n                                      Bottom Middle Fan         OK       3840    Spinning at intermediate-speed\\n                                      Top Front Fan             OK       3810    Spinning at intermediate-speed\\n                                      Bottom Front Fan          OK       3840    Spinning at intermediate-speed\\n                                     \\'\\n        }\\n\\n    Example output with TextFSM parsing:\\n\\n    .. code-block:: json\\n\\n        {\\n          \"comment\": \"\",\\n          \"result\": true,\\n          \"out\": {\\n            \"sh ver\": [\\n              {\\n                \"kernel\": \"9.1S3.5\",\\n                \"documentation\": \"9.1S3.5\",\\n                \"boot\": \"9.1S3.5\",\\n                \"crypto\": \"9.1S3.5\",\\n                \"chassis\": \"\",\\n                \"routing\": \"9.1S3.5\",\\n                \"base\": \"9.1S3.5\",\\n                \"model\": \"mx960\"\\n              }\\n            ]\\n          }\\n        }\\n    '\n    raw_cli_outputs = salt.utils.napalm.call(napalm_device, 'cli', **{'commands': list(commands)})\n    if not raw_cli_outputs['result']:\n        return raw_cli_outputs\n    textfsm_parse = kwargs.get('textfsm_parse') or __opts__.get('napalm_cli_textfsm_parse') or __pillar__.get('napalm_cli_textfsm_parse', False)\n    if not textfsm_parse:\n        log.debug('No TextFSM parsing requested.')\n        return raw_cli_outputs\n    if 'textfsm.extract' not in __salt__ or 'textfsm.index' not in __salt__:\n        raw_cli_outputs['comment'] += 'Unable to process: is TextFSM installed?'\n        log.error(raw_cli_outputs['comment'])\n        return raw_cli_outputs\n    textfsm_template = kwargs.get('textfsm_template')\n    log.debug('textfsm_template: %s', textfsm_template)\n    textfsm_path = kwargs.get('textfsm_path') or __opts__.get('textfsm_path') or __pillar__.get('textfsm_path')\n    log.debug('textfsm_path: %s', textfsm_path)\n    textfsm_template_dict = kwargs.get('textfsm_template_dict') or __opts__.get('napalm_cli_textfsm_template_dict') or __pillar__.get('napalm_cli_textfsm_template_dict', {})\n    log.debug('TextFSM command-template mapping: %s', textfsm_template_dict)\n    index_file = kwargs.get('index_file') or __opts__.get('textfsm_index_file') or __pillar__.get('textfsm_index_file')\n    log.debug('index_file: %s', index_file)\n    platform_grain_name = kwargs.get('platform_grain_name') or __opts__.get('textfsm_platform_grain') or __pillar__.get('textfsm_platform_grain', 'os')\n    log.debug('platform_grain_name: %s', platform_grain_name)\n    platform_column_name = kwargs.get('platform_column_name') or __opts__.get('textfsm_platform_column_name') or __pillar__.get('textfsm_platform_column_name', 'Platform')\n    log.debug('platform_column_name: %s', platform_column_name)\n    saltenv = kwargs.get('saltenv', 'base')\n    include_empty = kwargs.get('include_empty', False)\n    include_pat = kwargs.get('include_pat')\n    exclude_pat = kwargs.get('exclude_pat')\n    processed_cli_outputs = {'comment': raw_cli_outputs.get('comment', ''), 'result': raw_cli_outputs['result'], 'out': {}}\n    log.debug('Starting to analyse the raw outputs')\n    for command in list(commands):\n        command_output = raw_cli_outputs['out'][command]\n        log.debug('Output from command: %s', command)\n        log.debug(command_output)\n        processed_command_output = None\n        if textfsm_path:\n            log.debug('Using the templates under %s', textfsm_path)\n            processed_cli_output = __salt__['textfsm.index'](command, platform_grain_name=platform_grain_name, platform_column_name=platform_column_name, output=command_output.strip(), textfsm_path=textfsm_path, saltenv=saltenv, include_empty=include_empty, include_pat=include_pat, exclude_pat=exclude_pat)\n            log.debug('Processed CLI output:')\n            log.debug(processed_cli_output)\n            if not processed_cli_output['result']:\n                log.debug('Apparently this did not work, returning the raw output')\n                processed_command_output = command_output\n                processed_cli_outputs['comment'] += '\\nUnable to process the output from {}: {}.'.format(command, processed_cli_output['comment'])\n                log.error(processed_cli_outputs['comment'])\n            elif processed_cli_output['out']:\n                log.debug('All good, %s has a nice output!', command)\n                processed_command_output = processed_cli_output['out']\n            else:\n                comment = '\\nProcessing \"{}\" didn\\'t fail, but didn\\'t return anything either. Dumping raw.'.format(command)\n                processed_cli_outputs['comment'] += comment\n                log.error(comment)\n                processed_command_output = command_output\n        elif textfsm_template or command in textfsm_template_dict:\n            if command in textfsm_template_dict:\n                textfsm_template = textfsm_template_dict[command]\n            log.debug('Using %s to process the command: %s', textfsm_template, command)\n            processed_cli_output = __salt__['textfsm.extract'](textfsm_template, raw_text=command_output, saltenv=saltenv)\n            log.debug('Processed CLI output:')\n            log.debug(processed_cli_output)\n            if not processed_cli_output['result']:\n                log.debug('Apparently this did not work, returning the raw output')\n                processed_command_output = command_output\n                processed_cli_outputs['comment'] += '\\nUnable to process the output from {}: {}'.format(command, processed_cli_output['comment'])\n                log.error(processed_cli_outputs['comment'])\n            elif processed_cli_output['out']:\n                log.debug('All good, %s has a nice output!', command)\n                processed_command_output = processed_cli_output['out']\n            else:\n                log.debug('Processing %s did not fail, but did not return anything either. Dumping raw.', command)\n                processed_command_output = command_output\n        else:\n            log.error('No TextFSM template specified, or no TextFSM path defined')\n            processed_command_output = command_output\n            processed_cli_outputs['comment'] += '\\nUnable to process the output from {}.'.format(command)\n        processed_cli_outputs['out'][command] = processed_command_output\n    processed_cli_outputs['comment'] = processed_cli_outputs['comment'].strip()\n    return processed_cli_outputs",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef cli(*commands, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns a dictionary with the raw output of all commands passed as arguments.\\n\\n    commands\\n        List of commands to be executed on the device.\\n\\n    textfsm_parse: ``False``\\n        Try parsing the outputs using the TextFSM templates.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``napalm_cli_textfsm_parse``.\\n\\n    textfsm_path\\n        The path where the TextFSM templates can be found. This option implies\\n        the usage of the TextFSM index file.\\n        ``textfsm_path`` can be either absolute path on the server,\\n        either specified using the following URL mschemes: ``file://``,\\n        ``salt://``, ``http://``, ``https://``, ``ftp://``,\\n        ``s3://``, ``swift://``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This needs to be a directory with a flat structure, having an\\n            index file (whose name can be specified using the ``index_file`` option)\\n            and a number of TextFSM templates.\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_path``.\\n\\n    textfsm_template\\n        The path to a certain the TextFSM template.\\n        This can be specified using the absolute path\\n        to the file, or using one of the following URL schemes:\\n\\n        - ``salt://``, to fetch the template from the Salt fileserver.\\n        - ``http://`` or ``https://``\\n        - ``ftp://``\\n        - ``s3://``\\n        - ``swift://``\\n\\n        .. versionadded:: 2018.3.0\\n\\n    textfsm_template_dict\\n        A dictionary with the mapping between a command\\n        and the corresponding TextFSM path to use to extract the data.\\n        The TextFSM paths can be specified as in ``textfsm_template``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``napalm_cli_textfsm_template_dict``.\\n\\n    platform_grain_name: ``os``\\n        The name of the grain used to identify the platform name\\n        in the TextFSM index file. Default: ``os``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_platform_grain``.\\n\\n    platform_column_name: ``Platform``\\n        The column name used to identify the platform,\\n        exactly as specified in the TextFSM index file.\\n        Default: ``Platform``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This is field is case sensitive, make sure\\n            to assign the correct value to this option,\\n            exactly as defined in the index file.\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_platform_column_name``.\\n\\n    index_file: ``index``\\n        The name of the TextFSM index file, under the ``textfsm_path``. Default: ``index``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_index_file``.\\n\\n    saltenv: ``base``\\n        Salt fileserver environment from which to retrieve the file.\\n        Ignored if ``textfsm_path`` is not a ``salt://`` URL.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    include_empty: ``False``\\n        Include empty files under the ``textfsm_path``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    include_pat\\n        Glob or regex to narrow down the files cached from the given path.\\n        If matching with a regex, the regex must be prefixed with ``E@``,\\n        otherwise the expression will be interpreted as a glob.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    exclude_pat\\n        Glob or regex to exclude certain files from being cached from the given path.\\n        If matching with a regex, the regex must be prefixed with ``E@``,\\n        otherwise the expression will be interpreted as a glob.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            If used with ``include_pat``, files matching this pattern will be\\n            excluded from the subset of files defined by ``include_pat``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.cli \"show version\" \"show chassis fan\"\\n\\n    CLI Example with TextFSM template:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.cli textfsm_parse=True textfsm_path=salt://textfsm/\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'show version and haiku\\':  \\'Hostname: re0.edge01.arn01\\n                                          Model: mx480\\n                                          Junos: 13.3R6.5\\n                                            Help me, Obi-Wan\\n                                            I just saw Episode Two\\n                                            You\\'re my only hope\\n                                         \\',\\n            \\'show chassis fan\\' :   \\'Item                      Status   RPM     Measurement\\n                                      Top Rear Fan              OK       3840    Spinning at intermediate-speed\\n                                      Bottom Rear Fan           OK       3840    Spinning at intermediate-speed\\n                                      Top Middle Fan            OK       3900    Spinning at intermediate-speed\\n                                      Bottom Middle Fan         OK       3840    Spinning at intermediate-speed\\n                                      Top Front Fan             OK       3810    Spinning at intermediate-speed\\n                                      Bottom Front Fan          OK       3840    Spinning at intermediate-speed\\n                                     \\'\\n        }\\n\\n    Example output with TextFSM parsing:\\n\\n    .. code-block:: json\\n\\n        {\\n          \"comment\": \"\",\\n          \"result\": true,\\n          \"out\": {\\n            \"sh ver\": [\\n              {\\n                \"kernel\": \"9.1S3.5\",\\n                \"documentation\": \"9.1S3.5\",\\n                \"boot\": \"9.1S3.5\",\\n                \"crypto\": \"9.1S3.5\",\\n                \"chassis\": \"\",\\n                \"routing\": \"9.1S3.5\",\\n                \"base\": \"9.1S3.5\",\\n                \"model\": \"mx960\"\\n              }\\n            ]\\n          }\\n        }\\n    '\n    raw_cli_outputs = salt.utils.napalm.call(napalm_device, 'cli', **{'commands': list(commands)})\n    if not raw_cli_outputs['result']:\n        return raw_cli_outputs\n    textfsm_parse = kwargs.get('textfsm_parse') or __opts__.get('napalm_cli_textfsm_parse') or __pillar__.get('napalm_cli_textfsm_parse', False)\n    if not textfsm_parse:\n        log.debug('No TextFSM parsing requested.')\n        return raw_cli_outputs\n    if 'textfsm.extract' not in __salt__ or 'textfsm.index' not in __salt__:\n        raw_cli_outputs['comment'] += 'Unable to process: is TextFSM installed?'\n        log.error(raw_cli_outputs['comment'])\n        return raw_cli_outputs\n    textfsm_template = kwargs.get('textfsm_template')\n    log.debug('textfsm_template: %s', textfsm_template)\n    textfsm_path = kwargs.get('textfsm_path') or __opts__.get('textfsm_path') or __pillar__.get('textfsm_path')\n    log.debug('textfsm_path: %s', textfsm_path)\n    textfsm_template_dict = kwargs.get('textfsm_template_dict') or __opts__.get('napalm_cli_textfsm_template_dict') or __pillar__.get('napalm_cli_textfsm_template_dict', {})\n    log.debug('TextFSM command-template mapping: %s', textfsm_template_dict)\n    index_file = kwargs.get('index_file') or __opts__.get('textfsm_index_file') or __pillar__.get('textfsm_index_file')\n    log.debug('index_file: %s', index_file)\n    platform_grain_name = kwargs.get('platform_grain_name') or __opts__.get('textfsm_platform_grain') or __pillar__.get('textfsm_platform_grain', 'os')\n    log.debug('platform_grain_name: %s', platform_grain_name)\n    platform_column_name = kwargs.get('platform_column_name') or __opts__.get('textfsm_platform_column_name') or __pillar__.get('textfsm_platform_column_name', 'Platform')\n    log.debug('platform_column_name: %s', platform_column_name)\n    saltenv = kwargs.get('saltenv', 'base')\n    include_empty = kwargs.get('include_empty', False)\n    include_pat = kwargs.get('include_pat')\n    exclude_pat = kwargs.get('exclude_pat')\n    processed_cli_outputs = {'comment': raw_cli_outputs.get('comment', ''), 'result': raw_cli_outputs['result'], 'out': {}}\n    log.debug('Starting to analyse the raw outputs')\n    for command in list(commands):\n        command_output = raw_cli_outputs['out'][command]\n        log.debug('Output from command: %s', command)\n        log.debug(command_output)\n        processed_command_output = None\n        if textfsm_path:\n            log.debug('Using the templates under %s', textfsm_path)\n            processed_cli_output = __salt__['textfsm.index'](command, platform_grain_name=platform_grain_name, platform_column_name=platform_column_name, output=command_output.strip(), textfsm_path=textfsm_path, saltenv=saltenv, include_empty=include_empty, include_pat=include_pat, exclude_pat=exclude_pat)\n            log.debug('Processed CLI output:')\n            log.debug(processed_cli_output)\n            if not processed_cli_output['result']:\n                log.debug('Apparently this did not work, returning the raw output')\n                processed_command_output = command_output\n                processed_cli_outputs['comment'] += '\\nUnable to process the output from {}: {}.'.format(command, processed_cli_output['comment'])\n                log.error(processed_cli_outputs['comment'])\n            elif processed_cli_output['out']:\n                log.debug('All good, %s has a nice output!', command)\n                processed_command_output = processed_cli_output['out']\n            else:\n                comment = '\\nProcessing \"{}\" didn\\'t fail, but didn\\'t return anything either. Dumping raw.'.format(command)\n                processed_cli_outputs['comment'] += comment\n                log.error(comment)\n                processed_command_output = command_output\n        elif textfsm_template or command in textfsm_template_dict:\n            if command in textfsm_template_dict:\n                textfsm_template = textfsm_template_dict[command]\n            log.debug('Using %s to process the command: %s', textfsm_template, command)\n            processed_cli_output = __salt__['textfsm.extract'](textfsm_template, raw_text=command_output, saltenv=saltenv)\n            log.debug('Processed CLI output:')\n            log.debug(processed_cli_output)\n            if not processed_cli_output['result']:\n                log.debug('Apparently this did not work, returning the raw output')\n                processed_command_output = command_output\n                processed_cli_outputs['comment'] += '\\nUnable to process the output from {}: {}'.format(command, processed_cli_output['comment'])\n                log.error(processed_cli_outputs['comment'])\n            elif processed_cli_output['out']:\n                log.debug('All good, %s has a nice output!', command)\n                processed_command_output = processed_cli_output['out']\n            else:\n                log.debug('Processing %s did not fail, but did not return anything either. Dumping raw.', command)\n                processed_command_output = command_output\n        else:\n            log.error('No TextFSM template specified, or no TextFSM path defined')\n            processed_command_output = command_output\n            processed_cli_outputs['comment'] += '\\nUnable to process the output from {}.'.format(command)\n        processed_cli_outputs['out'][command] = processed_command_output\n    processed_cli_outputs['comment'] = processed_cli_outputs['comment'].strip()\n    return processed_cli_outputs",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef cli(*commands, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns a dictionary with the raw output of all commands passed as arguments.\\n\\n    commands\\n        List of commands to be executed on the device.\\n\\n    textfsm_parse: ``False``\\n        Try parsing the outputs using the TextFSM templates.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``napalm_cli_textfsm_parse``.\\n\\n    textfsm_path\\n        The path where the TextFSM templates can be found. This option implies\\n        the usage of the TextFSM index file.\\n        ``textfsm_path`` can be either absolute path on the server,\\n        either specified using the following URL mschemes: ``file://``,\\n        ``salt://``, ``http://``, ``https://``, ``ftp://``,\\n        ``s3://``, ``swift://``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This needs to be a directory with a flat structure, having an\\n            index file (whose name can be specified using the ``index_file`` option)\\n            and a number of TextFSM templates.\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_path``.\\n\\n    textfsm_template\\n        The path to a certain the TextFSM template.\\n        This can be specified using the absolute path\\n        to the file, or using one of the following URL schemes:\\n\\n        - ``salt://``, to fetch the template from the Salt fileserver.\\n        - ``http://`` or ``https://``\\n        - ``ftp://``\\n        - ``s3://``\\n        - ``swift://``\\n\\n        .. versionadded:: 2018.3.0\\n\\n    textfsm_template_dict\\n        A dictionary with the mapping between a command\\n        and the corresponding TextFSM path to use to extract the data.\\n        The TextFSM paths can be specified as in ``textfsm_template``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``napalm_cli_textfsm_template_dict``.\\n\\n    platform_grain_name: ``os``\\n        The name of the grain used to identify the platform name\\n        in the TextFSM index file. Default: ``os``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_platform_grain``.\\n\\n    platform_column_name: ``Platform``\\n        The column name used to identify the platform,\\n        exactly as specified in the TextFSM index file.\\n        Default: ``Platform``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This is field is case sensitive, make sure\\n            to assign the correct value to this option,\\n            exactly as defined in the index file.\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_platform_column_name``.\\n\\n    index_file: ``index``\\n        The name of the TextFSM index file, under the ``textfsm_path``. Default: ``index``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            This option can be also specified in the minion configuration\\n            file or pillar as ``textfsm_index_file``.\\n\\n    saltenv: ``base``\\n        Salt fileserver environment from which to retrieve the file.\\n        Ignored if ``textfsm_path`` is not a ``salt://`` URL.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    include_empty: ``False``\\n        Include empty files under the ``textfsm_path``.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    include_pat\\n        Glob or regex to narrow down the files cached from the given path.\\n        If matching with a regex, the regex must be prefixed with ``E@``,\\n        otherwise the expression will be interpreted as a glob.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    exclude_pat\\n        Glob or regex to exclude certain files from being cached from the given path.\\n        If matching with a regex, the regex must be prefixed with ``E@``,\\n        otherwise the expression will be interpreted as a glob.\\n\\n        .. versionadded:: 2018.3.0\\n\\n        .. note::\\n            If used with ``include_pat``, files matching this pattern will be\\n            excluded from the subset of files defined by ``include_pat``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.cli \"show version\" \"show chassis fan\"\\n\\n    CLI Example with TextFSM template:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.cli textfsm_parse=True textfsm_path=salt://textfsm/\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'show version and haiku\\':  \\'Hostname: re0.edge01.arn01\\n                                          Model: mx480\\n                                          Junos: 13.3R6.5\\n                                            Help me, Obi-Wan\\n                                            I just saw Episode Two\\n                                            You\\'re my only hope\\n                                         \\',\\n            \\'show chassis fan\\' :   \\'Item                      Status   RPM     Measurement\\n                                      Top Rear Fan              OK       3840    Spinning at intermediate-speed\\n                                      Bottom Rear Fan           OK       3840    Spinning at intermediate-speed\\n                                      Top Middle Fan            OK       3900    Spinning at intermediate-speed\\n                                      Bottom Middle Fan         OK       3840    Spinning at intermediate-speed\\n                                      Top Front Fan             OK       3810    Spinning at intermediate-speed\\n                                      Bottom Front Fan          OK       3840    Spinning at intermediate-speed\\n                                     \\'\\n        }\\n\\n    Example output with TextFSM parsing:\\n\\n    .. code-block:: json\\n\\n        {\\n          \"comment\": \"\",\\n          \"result\": true,\\n          \"out\": {\\n            \"sh ver\": [\\n              {\\n                \"kernel\": \"9.1S3.5\",\\n                \"documentation\": \"9.1S3.5\",\\n                \"boot\": \"9.1S3.5\",\\n                \"crypto\": \"9.1S3.5\",\\n                \"chassis\": \"\",\\n                \"routing\": \"9.1S3.5\",\\n                \"base\": \"9.1S3.5\",\\n                \"model\": \"mx960\"\\n              }\\n            ]\\n          }\\n        }\\n    '\n    raw_cli_outputs = salt.utils.napalm.call(napalm_device, 'cli', **{'commands': list(commands)})\n    if not raw_cli_outputs['result']:\n        return raw_cli_outputs\n    textfsm_parse = kwargs.get('textfsm_parse') or __opts__.get('napalm_cli_textfsm_parse') or __pillar__.get('napalm_cli_textfsm_parse', False)\n    if not textfsm_parse:\n        log.debug('No TextFSM parsing requested.')\n        return raw_cli_outputs\n    if 'textfsm.extract' not in __salt__ or 'textfsm.index' not in __salt__:\n        raw_cli_outputs['comment'] += 'Unable to process: is TextFSM installed?'\n        log.error(raw_cli_outputs['comment'])\n        return raw_cli_outputs\n    textfsm_template = kwargs.get('textfsm_template')\n    log.debug('textfsm_template: %s', textfsm_template)\n    textfsm_path = kwargs.get('textfsm_path') or __opts__.get('textfsm_path') or __pillar__.get('textfsm_path')\n    log.debug('textfsm_path: %s', textfsm_path)\n    textfsm_template_dict = kwargs.get('textfsm_template_dict') or __opts__.get('napalm_cli_textfsm_template_dict') or __pillar__.get('napalm_cli_textfsm_template_dict', {})\n    log.debug('TextFSM command-template mapping: %s', textfsm_template_dict)\n    index_file = kwargs.get('index_file') or __opts__.get('textfsm_index_file') or __pillar__.get('textfsm_index_file')\n    log.debug('index_file: %s', index_file)\n    platform_grain_name = kwargs.get('platform_grain_name') or __opts__.get('textfsm_platform_grain') or __pillar__.get('textfsm_platform_grain', 'os')\n    log.debug('platform_grain_name: %s', platform_grain_name)\n    platform_column_name = kwargs.get('platform_column_name') or __opts__.get('textfsm_platform_column_name') or __pillar__.get('textfsm_platform_column_name', 'Platform')\n    log.debug('platform_column_name: %s', platform_column_name)\n    saltenv = kwargs.get('saltenv', 'base')\n    include_empty = kwargs.get('include_empty', False)\n    include_pat = kwargs.get('include_pat')\n    exclude_pat = kwargs.get('exclude_pat')\n    processed_cli_outputs = {'comment': raw_cli_outputs.get('comment', ''), 'result': raw_cli_outputs['result'], 'out': {}}\n    log.debug('Starting to analyse the raw outputs')\n    for command in list(commands):\n        command_output = raw_cli_outputs['out'][command]\n        log.debug('Output from command: %s', command)\n        log.debug(command_output)\n        processed_command_output = None\n        if textfsm_path:\n            log.debug('Using the templates under %s', textfsm_path)\n            processed_cli_output = __salt__['textfsm.index'](command, platform_grain_name=platform_grain_name, platform_column_name=platform_column_name, output=command_output.strip(), textfsm_path=textfsm_path, saltenv=saltenv, include_empty=include_empty, include_pat=include_pat, exclude_pat=exclude_pat)\n            log.debug('Processed CLI output:')\n            log.debug(processed_cli_output)\n            if not processed_cli_output['result']:\n                log.debug('Apparently this did not work, returning the raw output')\n                processed_command_output = command_output\n                processed_cli_outputs['comment'] += '\\nUnable to process the output from {}: {}.'.format(command, processed_cli_output['comment'])\n                log.error(processed_cli_outputs['comment'])\n            elif processed_cli_output['out']:\n                log.debug('All good, %s has a nice output!', command)\n                processed_command_output = processed_cli_output['out']\n            else:\n                comment = '\\nProcessing \"{}\" didn\\'t fail, but didn\\'t return anything either. Dumping raw.'.format(command)\n                processed_cli_outputs['comment'] += comment\n                log.error(comment)\n                processed_command_output = command_output\n        elif textfsm_template or command in textfsm_template_dict:\n            if command in textfsm_template_dict:\n                textfsm_template = textfsm_template_dict[command]\n            log.debug('Using %s to process the command: %s', textfsm_template, command)\n            processed_cli_output = __salt__['textfsm.extract'](textfsm_template, raw_text=command_output, saltenv=saltenv)\n            log.debug('Processed CLI output:')\n            log.debug(processed_cli_output)\n            if not processed_cli_output['result']:\n                log.debug('Apparently this did not work, returning the raw output')\n                processed_command_output = command_output\n                processed_cli_outputs['comment'] += '\\nUnable to process the output from {}: {}'.format(command, processed_cli_output['comment'])\n                log.error(processed_cli_outputs['comment'])\n            elif processed_cli_output['out']:\n                log.debug('All good, %s has a nice output!', command)\n                processed_command_output = processed_cli_output['out']\n            else:\n                log.debug('Processing %s did not fail, but did not return anything either. Dumping raw.', command)\n                processed_command_output = command_output\n        else:\n            log.error('No TextFSM template specified, or no TextFSM path defined')\n            processed_command_output = command_output\n            processed_cli_outputs['comment'] += '\\nUnable to process the output from {}.'.format(command)\n        processed_cli_outputs['out'][command] = processed_command_output\n    processed_cli_outputs['comment'] = processed_cli_outputs['comment'].strip()\n    return processed_cli_outputs"
        ]
    },
    {
        "func_name": "traceroute",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef traceroute(destination, source=None, ttl=None, timeout=None, vrf=None, **kwargs):\n    \"\"\"\n    Calls the method traceroute from the NAPALM driver object and returns a dictionary with the result of the traceroute\n    command executed on the device.\n\n    destination\n        Hostname or address of remote host\n\n    source\n        Source address to use in outgoing traceroute packets\n\n    ttl\n        IP maximum time-to-live value (or IPv6 maximum hop-limit value)\n\n    timeout\n        Number of seconds to wait for response (seconds)\n\n    vrf\n        VRF (routing instance) for traceroute attempt\n\n        .. versionadded:: 2016.11.4\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.traceroute 8.8.8.8\n        salt '*' net.traceroute 8.8.8.8 source=127.0.0.1 ttl=5 timeout=1\n    \"\"\"\n    return salt.utils.napalm.call(napalm_device, 'traceroute', **{'destination': destination, 'source': source, 'ttl': ttl, 'timeout': timeout, 'vrf': vrf})",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef traceroute(destination, source=None, ttl=None, timeout=None, vrf=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Calls the method traceroute from the NAPALM driver object and returns a dictionary with the result of the traceroute\\n    command executed on the device.\\n\\n    destination\\n        Hostname or address of remote host\\n\\n    source\\n        Source address to use in outgoing traceroute packets\\n\\n    ttl\\n        IP maximum time-to-live value (or IPv6 maximum hop-limit value)\\n\\n    timeout\\n        Number of seconds to wait for response (seconds)\\n\\n    vrf\\n        VRF (routing instance) for traceroute attempt\\n\\n        .. versionadded:: 2016.11.4\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.traceroute 8.8.8.8\\n        salt '*' net.traceroute 8.8.8.8 source=127.0.0.1 ttl=5 timeout=1\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'traceroute', **{'destination': destination, 'source': source, 'ttl': ttl, 'timeout': timeout, 'vrf': vrf})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef traceroute(destination, source=None, ttl=None, timeout=None, vrf=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Calls the method traceroute from the NAPALM driver object and returns a dictionary with the result of the traceroute\\n    command executed on the device.\\n\\n    destination\\n        Hostname or address of remote host\\n\\n    source\\n        Source address to use in outgoing traceroute packets\\n\\n    ttl\\n        IP maximum time-to-live value (or IPv6 maximum hop-limit value)\\n\\n    timeout\\n        Number of seconds to wait for response (seconds)\\n\\n    vrf\\n        VRF (routing instance) for traceroute attempt\\n\\n        .. versionadded:: 2016.11.4\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.traceroute 8.8.8.8\\n        salt '*' net.traceroute 8.8.8.8 source=127.0.0.1 ttl=5 timeout=1\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'traceroute', **{'destination': destination, 'source': source, 'ttl': ttl, 'timeout': timeout, 'vrf': vrf})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef traceroute(destination, source=None, ttl=None, timeout=None, vrf=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Calls the method traceroute from the NAPALM driver object and returns a dictionary with the result of the traceroute\\n    command executed on the device.\\n\\n    destination\\n        Hostname or address of remote host\\n\\n    source\\n        Source address to use in outgoing traceroute packets\\n\\n    ttl\\n        IP maximum time-to-live value (or IPv6 maximum hop-limit value)\\n\\n    timeout\\n        Number of seconds to wait for response (seconds)\\n\\n    vrf\\n        VRF (routing instance) for traceroute attempt\\n\\n        .. versionadded:: 2016.11.4\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.traceroute 8.8.8.8\\n        salt '*' net.traceroute 8.8.8.8 source=127.0.0.1 ttl=5 timeout=1\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'traceroute', **{'destination': destination, 'source': source, 'ttl': ttl, 'timeout': timeout, 'vrf': vrf})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef traceroute(destination, source=None, ttl=None, timeout=None, vrf=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Calls the method traceroute from the NAPALM driver object and returns a dictionary with the result of the traceroute\\n    command executed on the device.\\n\\n    destination\\n        Hostname or address of remote host\\n\\n    source\\n        Source address to use in outgoing traceroute packets\\n\\n    ttl\\n        IP maximum time-to-live value (or IPv6 maximum hop-limit value)\\n\\n    timeout\\n        Number of seconds to wait for response (seconds)\\n\\n    vrf\\n        VRF (routing instance) for traceroute attempt\\n\\n        .. versionadded:: 2016.11.4\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.traceroute 8.8.8.8\\n        salt '*' net.traceroute 8.8.8.8 source=127.0.0.1 ttl=5 timeout=1\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'traceroute', **{'destination': destination, 'source': source, 'ttl': ttl, 'timeout': timeout, 'vrf': vrf})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef traceroute(destination, source=None, ttl=None, timeout=None, vrf=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Calls the method traceroute from the NAPALM driver object and returns a dictionary with the result of the traceroute\\n    command executed on the device.\\n\\n    destination\\n        Hostname or address of remote host\\n\\n    source\\n        Source address to use in outgoing traceroute packets\\n\\n    ttl\\n        IP maximum time-to-live value (or IPv6 maximum hop-limit value)\\n\\n    timeout\\n        Number of seconds to wait for response (seconds)\\n\\n    vrf\\n        VRF (routing instance) for traceroute attempt\\n\\n        .. versionadded:: 2016.11.4\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.traceroute 8.8.8.8\\n        salt '*' net.traceroute 8.8.8.8 source=127.0.0.1 ttl=5 timeout=1\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'traceroute', **{'destination': destination, 'source': source, 'ttl': ttl, 'timeout': timeout, 'vrf': vrf})"
        ]
    },
    {
        "func_name": "ping",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef ping(destination, source=None, ttl=None, timeout=None, size=None, count=None, vrf=None, **kwargs):\n    \"\"\"\n    Executes a ping on the network device and returns a dictionary as a result.\n\n    destination\n        Hostname or IP address of remote host\n\n    source\n        Source address of echo request\n\n    ttl\n        IP time-to-live value (IPv6 hop-limit value) (1..255 hops)\n\n    timeout\n        Maximum wait time after sending final packet (seconds)\n\n    size\n        Size of request packets (0..65468 bytes)\n\n    count\n        Number of ping requests to send (1..2000000000 packets)\n\n    vrf\n        VRF (routing instance) for ping attempt\n\n        .. versionadded:: 2016.11.4\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.ping 8.8.8.8\n        salt '*' net.ping 8.8.8.8 ttl=3 size=65468\n        salt '*' net.ping 8.8.8.8 source=127.0.0.1 timeout=1 count=100\n    \"\"\"\n    return salt.utils.napalm.call(napalm_device, 'ping', **{'destination': destination, 'source': source, 'ttl': ttl, 'timeout': timeout, 'size': size, 'count': count, 'vrf': vrf})",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef ping(destination, source=None, ttl=None, timeout=None, size=None, count=None, vrf=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Executes a ping on the network device and returns a dictionary as a result.\\n\\n    destination\\n        Hostname or IP address of remote host\\n\\n    source\\n        Source address of echo request\\n\\n    ttl\\n        IP time-to-live value (IPv6 hop-limit value) (1..255 hops)\\n\\n    timeout\\n        Maximum wait time after sending final packet (seconds)\\n\\n    size\\n        Size of request packets (0..65468 bytes)\\n\\n    count\\n        Number of ping requests to send (1..2000000000 packets)\\n\\n    vrf\\n        VRF (routing instance) for ping attempt\\n\\n        .. versionadded:: 2016.11.4\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.ping 8.8.8.8\\n        salt '*' net.ping 8.8.8.8 ttl=3 size=65468\\n        salt '*' net.ping 8.8.8.8 source=127.0.0.1 timeout=1 count=100\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'ping', **{'destination': destination, 'source': source, 'ttl': ttl, 'timeout': timeout, 'size': size, 'count': count, 'vrf': vrf})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef ping(destination, source=None, ttl=None, timeout=None, size=None, count=None, vrf=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Executes a ping on the network device and returns a dictionary as a result.\\n\\n    destination\\n        Hostname or IP address of remote host\\n\\n    source\\n        Source address of echo request\\n\\n    ttl\\n        IP time-to-live value (IPv6 hop-limit value) (1..255 hops)\\n\\n    timeout\\n        Maximum wait time after sending final packet (seconds)\\n\\n    size\\n        Size of request packets (0..65468 bytes)\\n\\n    count\\n        Number of ping requests to send (1..2000000000 packets)\\n\\n    vrf\\n        VRF (routing instance) for ping attempt\\n\\n        .. versionadded:: 2016.11.4\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.ping 8.8.8.8\\n        salt '*' net.ping 8.8.8.8 ttl=3 size=65468\\n        salt '*' net.ping 8.8.8.8 source=127.0.0.1 timeout=1 count=100\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'ping', **{'destination': destination, 'source': source, 'ttl': ttl, 'timeout': timeout, 'size': size, 'count': count, 'vrf': vrf})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef ping(destination, source=None, ttl=None, timeout=None, size=None, count=None, vrf=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Executes a ping on the network device and returns a dictionary as a result.\\n\\n    destination\\n        Hostname or IP address of remote host\\n\\n    source\\n        Source address of echo request\\n\\n    ttl\\n        IP time-to-live value (IPv6 hop-limit value) (1..255 hops)\\n\\n    timeout\\n        Maximum wait time after sending final packet (seconds)\\n\\n    size\\n        Size of request packets (0..65468 bytes)\\n\\n    count\\n        Number of ping requests to send (1..2000000000 packets)\\n\\n    vrf\\n        VRF (routing instance) for ping attempt\\n\\n        .. versionadded:: 2016.11.4\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.ping 8.8.8.8\\n        salt '*' net.ping 8.8.8.8 ttl=3 size=65468\\n        salt '*' net.ping 8.8.8.8 source=127.0.0.1 timeout=1 count=100\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'ping', **{'destination': destination, 'source': source, 'ttl': ttl, 'timeout': timeout, 'size': size, 'count': count, 'vrf': vrf})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef ping(destination, source=None, ttl=None, timeout=None, size=None, count=None, vrf=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Executes a ping on the network device and returns a dictionary as a result.\\n\\n    destination\\n        Hostname or IP address of remote host\\n\\n    source\\n        Source address of echo request\\n\\n    ttl\\n        IP time-to-live value (IPv6 hop-limit value) (1..255 hops)\\n\\n    timeout\\n        Maximum wait time after sending final packet (seconds)\\n\\n    size\\n        Size of request packets (0..65468 bytes)\\n\\n    count\\n        Number of ping requests to send (1..2000000000 packets)\\n\\n    vrf\\n        VRF (routing instance) for ping attempt\\n\\n        .. versionadded:: 2016.11.4\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.ping 8.8.8.8\\n        salt '*' net.ping 8.8.8.8 ttl=3 size=65468\\n        salt '*' net.ping 8.8.8.8 source=127.0.0.1 timeout=1 count=100\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'ping', **{'destination': destination, 'source': source, 'ttl': ttl, 'timeout': timeout, 'size': size, 'count': count, 'vrf': vrf})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef ping(destination, source=None, ttl=None, timeout=None, size=None, count=None, vrf=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Executes a ping on the network device and returns a dictionary as a result.\\n\\n    destination\\n        Hostname or IP address of remote host\\n\\n    source\\n        Source address of echo request\\n\\n    ttl\\n        IP time-to-live value (IPv6 hop-limit value) (1..255 hops)\\n\\n    timeout\\n        Maximum wait time after sending final packet (seconds)\\n\\n    size\\n        Size of request packets (0..65468 bytes)\\n\\n    count\\n        Number of ping requests to send (1..2000000000 packets)\\n\\n    vrf\\n        VRF (routing instance) for ping attempt\\n\\n        .. versionadded:: 2016.11.4\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.ping 8.8.8.8\\n        salt '*' net.ping 8.8.8.8 ttl=3 size=65468\\n        salt '*' net.ping 8.8.8.8 source=127.0.0.1 timeout=1 count=100\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'ping', **{'destination': destination, 'source': source, 'ttl': ttl, 'timeout': timeout, 'size': size, 'count': count, 'vrf': vrf})"
        ]
    },
    {
        "func_name": "arp",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef arp(interface='', ipaddr='', macaddr='', **kwargs):\n    \"\"\"\n    NAPALM returns a list of dictionaries with details of the ARP entries.\n\n    :param interface: interface name to filter on\n    :param ipaddr: IP address to filter on\n    :param macaddr: MAC address to filter on\n    :return: List of the entries in the ARP table\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.arp\n        salt '*' net.arp macaddr='5c:5e:ab:da:3c:f0'\n\n    Example output:\n\n    .. code-block:: python\n\n        [\n            {\n                'interface' : 'MgmtEth0/RSP0/CPU0/0',\n                'mac'       : '5c:5e:ab:da:3c:f0',\n                'ip'        : '172.17.17.1',\n                'age'       : 1454496274.84\n            },\n            {\n                'interface': 'MgmtEth0/RSP0/CPU0/0',\n                'mac'       : '66:0e:94:96:e0:ff',\n                'ip'        : '172.17.17.2',\n                'age'       : 1435641582.49\n            }\n        ]\n    \"\"\"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_arp_table', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    arp_table = proxy_output.get('out')\n    if interface:\n        arp_table = _filter_list(arp_table, 'interface', interface)\n    if ipaddr:\n        arp_table = _filter_list(arp_table, 'ip', ipaddr)\n    if macaddr:\n        arp_table = _filter_list(arp_table, 'mac', macaddr)\n    proxy_output.update({'out': arp_table})\n    return proxy_output",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef arp(interface='', ipaddr='', macaddr='', **kwargs):\n    if False:\n        i = 10\n    \"\\n    NAPALM returns a list of dictionaries with details of the ARP entries.\\n\\n    :param interface: interface name to filter on\\n    :param ipaddr: IP address to filter on\\n    :param macaddr: MAC address to filter on\\n    :return: List of the entries in the ARP table\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.arp\\n        salt '*' net.arp macaddr='5c:5e:ab:da:3c:f0'\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        [\\n            {\\n                'interface' : 'MgmtEth0/RSP0/CPU0/0',\\n                'mac'       : '5c:5e:ab:da:3c:f0',\\n                'ip'        : '172.17.17.1',\\n                'age'       : 1454496274.84\\n            },\\n            {\\n                'interface': 'MgmtEth0/RSP0/CPU0/0',\\n                'mac'       : '66:0e:94:96:e0:ff',\\n                'ip'        : '172.17.17.2',\\n                'age'       : 1435641582.49\\n            }\\n        ]\\n    \"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_arp_table', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    arp_table = proxy_output.get('out')\n    if interface:\n        arp_table = _filter_list(arp_table, 'interface', interface)\n    if ipaddr:\n        arp_table = _filter_list(arp_table, 'ip', ipaddr)\n    if macaddr:\n        arp_table = _filter_list(arp_table, 'mac', macaddr)\n    proxy_output.update({'out': arp_table})\n    return proxy_output",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef arp(interface='', ipaddr='', macaddr='', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    NAPALM returns a list of dictionaries with details of the ARP entries.\\n\\n    :param interface: interface name to filter on\\n    :param ipaddr: IP address to filter on\\n    :param macaddr: MAC address to filter on\\n    :return: List of the entries in the ARP table\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.arp\\n        salt '*' net.arp macaddr='5c:5e:ab:da:3c:f0'\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        [\\n            {\\n                'interface' : 'MgmtEth0/RSP0/CPU0/0',\\n                'mac'       : '5c:5e:ab:da:3c:f0',\\n                'ip'        : '172.17.17.1',\\n                'age'       : 1454496274.84\\n            },\\n            {\\n                'interface': 'MgmtEth0/RSP0/CPU0/0',\\n                'mac'       : '66:0e:94:96:e0:ff',\\n                'ip'        : '172.17.17.2',\\n                'age'       : 1435641582.49\\n            }\\n        ]\\n    \"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_arp_table', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    arp_table = proxy_output.get('out')\n    if interface:\n        arp_table = _filter_list(arp_table, 'interface', interface)\n    if ipaddr:\n        arp_table = _filter_list(arp_table, 'ip', ipaddr)\n    if macaddr:\n        arp_table = _filter_list(arp_table, 'mac', macaddr)\n    proxy_output.update({'out': arp_table})\n    return proxy_output",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef arp(interface='', ipaddr='', macaddr='', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    NAPALM returns a list of dictionaries with details of the ARP entries.\\n\\n    :param interface: interface name to filter on\\n    :param ipaddr: IP address to filter on\\n    :param macaddr: MAC address to filter on\\n    :return: List of the entries in the ARP table\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.arp\\n        salt '*' net.arp macaddr='5c:5e:ab:da:3c:f0'\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        [\\n            {\\n                'interface' : 'MgmtEth0/RSP0/CPU0/0',\\n                'mac'       : '5c:5e:ab:da:3c:f0',\\n                'ip'        : '172.17.17.1',\\n                'age'       : 1454496274.84\\n            },\\n            {\\n                'interface': 'MgmtEth0/RSP0/CPU0/0',\\n                'mac'       : '66:0e:94:96:e0:ff',\\n                'ip'        : '172.17.17.2',\\n                'age'       : 1435641582.49\\n            }\\n        ]\\n    \"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_arp_table', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    arp_table = proxy_output.get('out')\n    if interface:\n        arp_table = _filter_list(arp_table, 'interface', interface)\n    if ipaddr:\n        arp_table = _filter_list(arp_table, 'ip', ipaddr)\n    if macaddr:\n        arp_table = _filter_list(arp_table, 'mac', macaddr)\n    proxy_output.update({'out': arp_table})\n    return proxy_output",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef arp(interface='', ipaddr='', macaddr='', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    NAPALM returns a list of dictionaries with details of the ARP entries.\\n\\n    :param interface: interface name to filter on\\n    :param ipaddr: IP address to filter on\\n    :param macaddr: MAC address to filter on\\n    :return: List of the entries in the ARP table\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.arp\\n        salt '*' net.arp macaddr='5c:5e:ab:da:3c:f0'\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        [\\n            {\\n                'interface' : 'MgmtEth0/RSP0/CPU0/0',\\n                'mac'       : '5c:5e:ab:da:3c:f0',\\n                'ip'        : '172.17.17.1',\\n                'age'       : 1454496274.84\\n            },\\n            {\\n                'interface': 'MgmtEth0/RSP0/CPU0/0',\\n                'mac'       : '66:0e:94:96:e0:ff',\\n                'ip'        : '172.17.17.2',\\n                'age'       : 1435641582.49\\n            }\\n        ]\\n    \"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_arp_table', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    arp_table = proxy_output.get('out')\n    if interface:\n        arp_table = _filter_list(arp_table, 'interface', interface)\n    if ipaddr:\n        arp_table = _filter_list(arp_table, 'ip', ipaddr)\n    if macaddr:\n        arp_table = _filter_list(arp_table, 'mac', macaddr)\n    proxy_output.update({'out': arp_table})\n    return proxy_output",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef arp(interface='', ipaddr='', macaddr='', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    NAPALM returns a list of dictionaries with details of the ARP entries.\\n\\n    :param interface: interface name to filter on\\n    :param ipaddr: IP address to filter on\\n    :param macaddr: MAC address to filter on\\n    :return: List of the entries in the ARP table\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.arp\\n        salt '*' net.arp macaddr='5c:5e:ab:da:3c:f0'\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        [\\n            {\\n                'interface' : 'MgmtEth0/RSP0/CPU0/0',\\n                'mac'       : '5c:5e:ab:da:3c:f0',\\n                'ip'        : '172.17.17.1',\\n                'age'       : 1454496274.84\\n            },\\n            {\\n                'interface': 'MgmtEth0/RSP0/CPU0/0',\\n                'mac'       : '66:0e:94:96:e0:ff',\\n                'ip'        : '172.17.17.2',\\n                'age'       : 1435641582.49\\n            }\\n        ]\\n    \"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_arp_table', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    arp_table = proxy_output.get('out')\n    if interface:\n        arp_table = _filter_list(arp_table, 'interface', interface)\n    if ipaddr:\n        arp_table = _filter_list(arp_table, 'ip', ipaddr)\n    if macaddr:\n        arp_table = _filter_list(arp_table, 'mac', macaddr)\n    proxy_output.update({'out': arp_table})\n    return proxy_output"
        ]
    },
    {
        "func_name": "ipaddrs",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef ipaddrs(**kwargs):\n    \"\"\"\n    Returns IP addresses configured on the device.\n\n    :return:   A dictionary with the IPv4 and IPv6 addresses of the interfaces.\n        Returns all configured IP addresses on all interfaces as a dictionary\n        of dictionaries.  Keys of the main dictionary represent the name of the\n        interface.  Values of the main dictionary represent are dictionaries\n        that may consist of two keys 'ipv4' and 'ipv6' (one, both or none)\n        which are themselvs dictionaries with the IP addresses as keys.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.ipaddrs\n\n    Example output:\n\n    .. code-block:: python\n\n        {\n            'FastEthernet8': {\n                'ipv4': {\n                    '10.66.43.169': {\n                        'prefix_length': 22\n                    }\n                }\n            },\n            'Loopback555': {\n                'ipv4': {\n                    '192.168.1.1': {\n                        'prefix_length': 24\n                    }\n                },\n                'ipv6': {\n                    '1::1': {\n                        'prefix_length': 64\n                    },\n                    '2001:DB8:1::1': {\n                        'prefix_length': 64\n                    },\n                    'FE80::3': {\n                        'prefix_length': 'N/A'\n                    }\n                }\n            }\n        }\n    \"\"\"\n    return salt.utils.napalm.call(napalm_device, 'get_interfaces_ip', **{})",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef ipaddrs(**kwargs):\n    if False:\n        i = 10\n    \"\\n    Returns IP addresses configured on the device.\\n\\n    :return:   A dictionary with the IPv4 and IPv6 addresses of the interfaces.\\n        Returns all configured IP addresses on all interfaces as a dictionary\\n        of dictionaries.  Keys of the main dictionary represent the name of the\\n        interface.  Values of the main dictionary represent are dictionaries\\n        that may consist of two keys 'ipv4' and 'ipv6' (one, both or none)\\n        which are themselvs dictionaries with the IP addresses as keys.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.ipaddrs\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'FastEthernet8': {\\n                'ipv4': {\\n                    '10.66.43.169': {\\n                        'prefix_length': 22\\n                    }\\n                }\\n            },\\n            'Loopback555': {\\n                'ipv4': {\\n                    '192.168.1.1': {\\n                        'prefix_length': 24\\n                    }\\n                },\\n                'ipv6': {\\n                    '1::1': {\\n                        'prefix_length': 64\\n                    },\\n                    '2001:DB8:1::1': {\\n                        'prefix_length': 64\\n                    },\\n                    'FE80::3': {\\n                        'prefix_length': 'N/A'\\n                    }\\n                }\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_interfaces_ip', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef ipaddrs(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Returns IP addresses configured on the device.\\n\\n    :return:   A dictionary with the IPv4 and IPv6 addresses of the interfaces.\\n        Returns all configured IP addresses on all interfaces as a dictionary\\n        of dictionaries.  Keys of the main dictionary represent the name of the\\n        interface.  Values of the main dictionary represent are dictionaries\\n        that may consist of two keys 'ipv4' and 'ipv6' (one, both or none)\\n        which are themselvs dictionaries with the IP addresses as keys.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.ipaddrs\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'FastEthernet8': {\\n                'ipv4': {\\n                    '10.66.43.169': {\\n                        'prefix_length': 22\\n                    }\\n                }\\n            },\\n            'Loopback555': {\\n                'ipv4': {\\n                    '192.168.1.1': {\\n                        'prefix_length': 24\\n                    }\\n                },\\n                'ipv6': {\\n                    '1::1': {\\n                        'prefix_length': 64\\n                    },\\n                    '2001:DB8:1::1': {\\n                        'prefix_length': 64\\n                    },\\n                    'FE80::3': {\\n                        'prefix_length': 'N/A'\\n                    }\\n                }\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_interfaces_ip', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef ipaddrs(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Returns IP addresses configured on the device.\\n\\n    :return:   A dictionary with the IPv4 and IPv6 addresses of the interfaces.\\n        Returns all configured IP addresses on all interfaces as a dictionary\\n        of dictionaries.  Keys of the main dictionary represent the name of the\\n        interface.  Values of the main dictionary represent are dictionaries\\n        that may consist of two keys 'ipv4' and 'ipv6' (one, both or none)\\n        which are themselvs dictionaries with the IP addresses as keys.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.ipaddrs\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'FastEthernet8': {\\n                'ipv4': {\\n                    '10.66.43.169': {\\n                        'prefix_length': 22\\n                    }\\n                }\\n            },\\n            'Loopback555': {\\n                'ipv4': {\\n                    '192.168.1.1': {\\n                        'prefix_length': 24\\n                    }\\n                },\\n                'ipv6': {\\n                    '1::1': {\\n                        'prefix_length': 64\\n                    },\\n                    '2001:DB8:1::1': {\\n                        'prefix_length': 64\\n                    },\\n                    'FE80::3': {\\n                        'prefix_length': 'N/A'\\n                    }\\n                }\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_interfaces_ip', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef ipaddrs(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Returns IP addresses configured on the device.\\n\\n    :return:   A dictionary with the IPv4 and IPv6 addresses of the interfaces.\\n        Returns all configured IP addresses on all interfaces as a dictionary\\n        of dictionaries.  Keys of the main dictionary represent the name of the\\n        interface.  Values of the main dictionary represent are dictionaries\\n        that may consist of two keys 'ipv4' and 'ipv6' (one, both or none)\\n        which are themselvs dictionaries with the IP addresses as keys.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.ipaddrs\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'FastEthernet8': {\\n                'ipv4': {\\n                    '10.66.43.169': {\\n                        'prefix_length': 22\\n                    }\\n                }\\n            },\\n            'Loopback555': {\\n                'ipv4': {\\n                    '192.168.1.1': {\\n                        'prefix_length': 24\\n                    }\\n                },\\n                'ipv6': {\\n                    '1::1': {\\n                        'prefix_length': 64\\n                    },\\n                    '2001:DB8:1::1': {\\n                        'prefix_length': 64\\n                    },\\n                    'FE80::3': {\\n                        'prefix_length': 'N/A'\\n                    }\\n                }\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_interfaces_ip', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef ipaddrs(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Returns IP addresses configured on the device.\\n\\n    :return:   A dictionary with the IPv4 and IPv6 addresses of the interfaces.\\n        Returns all configured IP addresses on all interfaces as a dictionary\\n        of dictionaries.  Keys of the main dictionary represent the name of the\\n        interface.  Values of the main dictionary represent are dictionaries\\n        that may consist of two keys 'ipv4' and 'ipv6' (one, both or none)\\n        which are themselvs dictionaries with the IP addresses as keys.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.ipaddrs\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'FastEthernet8': {\\n                'ipv4': {\\n                    '10.66.43.169': {\\n                        'prefix_length': 22\\n                    }\\n                }\\n            },\\n            'Loopback555': {\\n                'ipv4': {\\n                    '192.168.1.1': {\\n                        'prefix_length': 24\\n                    }\\n                },\\n                'ipv6': {\\n                    '1::1': {\\n                        'prefix_length': 64\\n                    },\\n                    '2001:DB8:1::1': {\\n                        'prefix_length': 64\\n                    },\\n                    'FE80::3': {\\n                        'prefix_length': 'N/A'\\n                    }\\n                }\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_interfaces_ip', **{})"
        ]
    },
    {
        "func_name": "interfaces",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef interfaces(**kwargs):\n    \"\"\"\n    Returns details of the interfaces on the device.\n\n    :return: Returns a dictionary of dictionaries. The keys for the first\n        dictionary will be the interfaces in the devices.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.interfaces\n\n    Example output:\n\n    .. code-block:: python\n\n        {\n            'Management1': {\n                'is_up': False,\n                'is_enabled': False,\n                'description': '',\n                'last_flapped': -1,\n                'speed': 1000,\n                'mac_address': 'dead:beef:dead',\n            },\n            'Ethernet1':{\n                'is_up': True,\n                'is_enabled': True,\n                'description': 'foo',\n                'last_flapped': 1429978575.1554043,\n                'speed': 1000,\n                'mac_address': 'beef:dead:beef',\n            }\n        }\n    \"\"\"\n    return salt.utils.napalm.call(napalm_device, 'get_interfaces', **{})",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef interfaces(**kwargs):\n    if False:\n        i = 10\n    \"\\n    Returns details of the interfaces on the device.\\n\\n    :return: Returns a dictionary of dictionaries. The keys for the first\\n        dictionary will be the interfaces in the devices.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.interfaces\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'Management1': {\\n                'is_up': False,\\n                'is_enabled': False,\\n                'description': '',\\n                'last_flapped': -1,\\n                'speed': 1000,\\n                'mac_address': 'dead:beef:dead',\\n            },\\n            'Ethernet1':{\\n                'is_up': True,\\n                'is_enabled': True,\\n                'description': 'foo',\\n                'last_flapped': 1429978575.1554043,\\n                'speed': 1000,\\n                'mac_address': 'beef:dead:beef',\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_interfaces', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef interfaces(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Returns details of the interfaces on the device.\\n\\n    :return: Returns a dictionary of dictionaries. The keys for the first\\n        dictionary will be the interfaces in the devices.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.interfaces\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'Management1': {\\n                'is_up': False,\\n                'is_enabled': False,\\n                'description': '',\\n                'last_flapped': -1,\\n                'speed': 1000,\\n                'mac_address': 'dead:beef:dead',\\n            },\\n            'Ethernet1':{\\n                'is_up': True,\\n                'is_enabled': True,\\n                'description': 'foo',\\n                'last_flapped': 1429978575.1554043,\\n                'speed': 1000,\\n                'mac_address': 'beef:dead:beef',\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_interfaces', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef interfaces(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Returns details of the interfaces on the device.\\n\\n    :return: Returns a dictionary of dictionaries. The keys for the first\\n        dictionary will be the interfaces in the devices.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.interfaces\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'Management1': {\\n                'is_up': False,\\n                'is_enabled': False,\\n                'description': '',\\n                'last_flapped': -1,\\n                'speed': 1000,\\n                'mac_address': 'dead:beef:dead',\\n            },\\n            'Ethernet1':{\\n                'is_up': True,\\n                'is_enabled': True,\\n                'description': 'foo',\\n                'last_flapped': 1429978575.1554043,\\n                'speed': 1000,\\n                'mac_address': 'beef:dead:beef',\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_interfaces', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef interfaces(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Returns details of the interfaces on the device.\\n\\n    :return: Returns a dictionary of dictionaries. The keys for the first\\n        dictionary will be the interfaces in the devices.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.interfaces\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'Management1': {\\n                'is_up': False,\\n                'is_enabled': False,\\n                'description': '',\\n                'last_flapped': -1,\\n                'speed': 1000,\\n                'mac_address': 'dead:beef:dead',\\n            },\\n            'Ethernet1':{\\n                'is_up': True,\\n                'is_enabled': True,\\n                'description': 'foo',\\n                'last_flapped': 1429978575.1554043,\\n                'speed': 1000,\\n                'mac_address': 'beef:dead:beef',\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_interfaces', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef interfaces(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Returns details of the interfaces on the device.\\n\\n    :return: Returns a dictionary of dictionaries. The keys for the first\\n        dictionary will be the interfaces in the devices.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.interfaces\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'Management1': {\\n                'is_up': False,\\n                'is_enabled': False,\\n                'description': '',\\n                'last_flapped': -1,\\n                'speed': 1000,\\n                'mac_address': 'dead:beef:dead',\\n            },\\n            'Ethernet1':{\\n                'is_up': True,\\n                'is_enabled': True,\\n                'description': 'foo',\\n                'last_flapped': 1429978575.1554043,\\n                'speed': 1000,\\n                'mac_address': 'beef:dead:beef',\\n            }\\n        }\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_interfaces', **{})"
        ]
    },
    {
        "func_name": "lldp",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef lldp(interface='', **kwargs):\n    \"\"\"\n    Returns a detailed view of the LLDP neighbors.\n\n    :param interface: interface name to filter on\n\n    :return:          A dictionary with the LLDL neighbors. The keys are the\n        interfaces with LLDP activated on.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.lldp\n        salt '*' net.lldp interface='TenGigE0/0/0/8'\n\n    Example output:\n\n    .. code-block:: python\n\n        {\n            'TenGigE0/0/0/8': [\n                {\n                    'parent_interface': 'Bundle-Ether8',\n                    'interface_description': 'TenGigE0/0/0/8',\n                    'remote_chassis_id': '8c60.4f69.e96c',\n                    'remote_system_name': 'switch',\n                    'remote_port': 'Eth2/2/1',\n                    'remote_port_description': 'Ethernet2/2/1',\n                    'remote_system_description': 'Cisco Nexus Operating System (NX-OS) Software 7.1(0)N1(1a)\n                          TAC support: http://www.cisco.com/tac\n                          Copyright (c) 2002-2015, Cisco Systems, Inc. All rights reserved.',\n                    'remote_system_capab': 'B, R',\n                    'remote_system_enable_capab': 'B'\n                }\n            ]\n        }\n    \"\"\"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_lldp_neighbors_detail', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    lldp_neighbors = proxy_output.get('out')\n    if interface:\n        lldp_neighbors = {interface: lldp_neighbors.get(interface)}\n    proxy_output.update({'out': lldp_neighbors})\n    return proxy_output",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef lldp(interface='', **kwargs):\n    if False:\n        i = 10\n    \"\\n    Returns a detailed view of the LLDP neighbors.\\n\\n    :param interface: interface name to filter on\\n\\n    :return:          A dictionary with the LLDL neighbors. The keys are the\\n        interfaces with LLDP activated on.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.lldp\\n        salt '*' net.lldp interface='TenGigE0/0/0/8'\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'TenGigE0/0/0/8': [\\n                {\\n                    'parent_interface': 'Bundle-Ether8',\\n                    'interface_description': 'TenGigE0/0/0/8',\\n                    'remote_chassis_id': '8c60.4f69.e96c',\\n                    'remote_system_name': 'switch',\\n                    'remote_port': 'Eth2/2/1',\\n                    'remote_port_description': 'Ethernet2/2/1',\\n                    'remote_system_description': 'Cisco Nexus Operating System (NX-OS) Software 7.1(0)N1(1a)\\n                          TAC support: http://www.cisco.com/tac\\n                          Copyright (c) 2002-2015, Cisco Systems, Inc. All rights reserved.',\\n                    'remote_system_capab': 'B, R',\\n                    'remote_system_enable_capab': 'B'\\n                }\\n            ]\\n        }\\n    \"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_lldp_neighbors_detail', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    lldp_neighbors = proxy_output.get('out')\n    if interface:\n        lldp_neighbors = {interface: lldp_neighbors.get(interface)}\n    proxy_output.update({'out': lldp_neighbors})\n    return proxy_output",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef lldp(interface='', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Returns a detailed view of the LLDP neighbors.\\n\\n    :param interface: interface name to filter on\\n\\n    :return:          A dictionary with the LLDL neighbors. The keys are the\\n        interfaces with LLDP activated on.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.lldp\\n        salt '*' net.lldp interface='TenGigE0/0/0/8'\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'TenGigE0/0/0/8': [\\n                {\\n                    'parent_interface': 'Bundle-Ether8',\\n                    'interface_description': 'TenGigE0/0/0/8',\\n                    'remote_chassis_id': '8c60.4f69.e96c',\\n                    'remote_system_name': 'switch',\\n                    'remote_port': 'Eth2/2/1',\\n                    'remote_port_description': 'Ethernet2/2/1',\\n                    'remote_system_description': 'Cisco Nexus Operating System (NX-OS) Software 7.1(0)N1(1a)\\n                          TAC support: http://www.cisco.com/tac\\n                          Copyright (c) 2002-2015, Cisco Systems, Inc. All rights reserved.',\\n                    'remote_system_capab': 'B, R',\\n                    'remote_system_enable_capab': 'B'\\n                }\\n            ]\\n        }\\n    \"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_lldp_neighbors_detail', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    lldp_neighbors = proxy_output.get('out')\n    if interface:\n        lldp_neighbors = {interface: lldp_neighbors.get(interface)}\n    proxy_output.update({'out': lldp_neighbors})\n    return proxy_output",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef lldp(interface='', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Returns a detailed view of the LLDP neighbors.\\n\\n    :param interface: interface name to filter on\\n\\n    :return:          A dictionary with the LLDL neighbors. The keys are the\\n        interfaces with LLDP activated on.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.lldp\\n        salt '*' net.lldp interface='TenGigE0/0/0/8'\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'TenGigE0/0/0/8': [\\n                {\\n                    'parent_interface': 'Bundle-Ether8',\\n                    'interface_description': 'TenGigE0/0/0/8',\\n                    'remote_chassis_id': '8c60.4f69.e96c',\\n                    'remote_system_name': 'switch',\\n                    'remote_port': 'Eth2/2/1',\\n                    'remote_port_description': 'Ethernet2/2/1',\\n                    'remote_system_description': 'Cisco Nexus Operating System (NX-OS) Software 7.1(0)N1(1a)\\n                          TAC support: http://www.cisco.com/tac\\n                          Copyright (c) 2002-2015, Cisco Systems, Inc. All rights reserved.',\\n                    'remote_system_capab': 'B, R',\\n                    'remote_system_enable_capab': 'B'\\n                }\\n            ]\\n        }\\n    \"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_lldp_neighbors_detail', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    lldp_neighbors = proxy_output.get('out')\n    if interface:\n        lldp_neighbors = {interface: lldp_neighbors.get(interface)}\n    proxy_output.update({'out': lldp_neighbors})\n    return proxy_output",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef lldp(interface='', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Returns a detailed view of the LLDP neighbors.\\n\\n    :param interface: interface name to filter on\\n\\n    :return:          A dictionary with the LLDL neighbors. The keys are the\\n        interfaces with LLDP activated on.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.lldp\\n        salt '*' net.lldp interface='TenGigE0/0/0/8'\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'TenGigE0/0/0/8': [\\n                {\\n                    'parent_interface': 'Bundle-Ether8',\\n                    'interface_description': 'TenGigE0/0/0/8',\\n                    'remote_chassis_id': '8c60.4f69.e96c',\\n                    'remote_system_name': 'switch',\\n                    'remote_port': 'Eth2/2/1',\\n                    'remote_port_description': 'Ethernet2/2/1',\\n                    'remote_system_description': 'Cisco Nexus Operating System (NX-OS) Software 7.1(0)N1(1a)\\n                          TAC support: http://www.cisco.com/tac\\n                          Copyright (c) 2002-2015, Cisco Systems, Inc. All rights reserved.',\\n                    'remote_system_capab': 'B, R',\\n                    'remote_system_enable_capab': 'B'\\n                }\\n            ]\\n        }\\n    \"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_lldp_neighbors_detail', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    lldp_neighbors = proxy_output.get('out')\n    if interface:\n        lldp_neighbors = {interface: lldp_neighbors.get(interface)}\n    proxy_output.update({'out': lldp_neighbors})\n    return proxy_output",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef lldp(interface='', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Returns a detailed view of the LLDP neighbors.\\n\\n    :param interface: interface name to filter on\\n\\n    :return:          A dictionary with the LLDL neighbors. The keys are the\\n        interfaces with LLDP activated on.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.lldp\\n        salt '*' net.lldp interface='TenGigE0/0/0/8'\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            'TenGigE0/0/0/8': [\\n                {\\n                    'parent_interface': 'Bundle-Ether8',\\n                    'interface_description': 'TenGigE0/0/0/8',\\n                    'remote_chassis_id': '8c60.4f69.e96c',\\n                    'remote_system_name': 'switch',\\n                    'remote_port': 'Eth2/2/1',\\n                    'remote_port_description': 'Ethernet2/2/1',\\n                    'remote_system_description': 'Cisco Nexus Operating System (NX-OS) Software 7.1(0)N1(1a)\\n                          TAC support: http://www.cisco.com/tac\\n                          Copyright (c) 2002-2015, Cisco Systems, Inc. All rights reserved.',\\n                    'remote_system_capab': 'B, R',\\n                    'remote_system_enable_capab': 'B'\\n                }\\n            ]\\n        }\\n    \"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_lldp_neighbors_detail', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    lldp_neighbors = proxy_output.get('out')\n    if interface:\n        lldp_neighbors = {interface: lldp_neighbors.get(interface)}\n    proxy_output.update({'out': lldp_neighbors})\n    return proxy_output"
        ]
    },
    {
        "func_name": "mac",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef mac(address='', interface='', vlan=0, **kwargs):\n    \"\"\"\n    Returns the MAC Address Table on the device.\n\n    :param address:   MAC address to filter on\n    :param interface: Interface name to filter on\n    :param vlan:      VLAN identifier\n    :return:          A list of dictionaries representing the entries in the MAC Address Table\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.mac\n        salt '*' net.mac vlan=10\n\n    Example output:\n\n    .. code-block:: python\n\n        [\n            {\n                'mac'       : '00:1c:58:29:4a:71',\n                'interface' : 'xe-3/0/2',\n                'static'    : False,\n                'active'    : True,\n                'moves'     : 1,\n                'vlan'      : 10,\n                'last_move' : 1454417742.58\n            },\n            {\n                'mac'       : '8c:60:4f:58:e1:c1',\n                'interface' : 'xe-1/0/1',\n                'static'    : False,\n                'active'    : True,\n                'moves'     : 2,\n                'vlan'      : 42,\n                'last_move' : 1453191948.11\n            }\n        ]\n    \"\"\"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_mac_address_table', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    mac_address_table = proxy_output.get('out')\n    if vlan and isinstance(vlan, int):\n        mac_address_table = _filter_list(mac_address_table, 'vlan', vlan)\n    if address:\n        mac_address_table = _filter_list(mac_address_table, 'mac', address)\n    if interface:\n        mac_address_table = _filter_list(mac_address_table, 'interface', interface)\n    proxy_output.update({'out': mac_address_table})\n    return proxy_output",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef mac(address='', interface='', vlan=0, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Returns the MAC Address Table on the device.\\n\\n    :param address:   MAC address to filter on\\n    :param interface: Interface name to filter on\\n    :param vlan:      VLAN identifier\\n    :return:          A list of dictionaries representing the entries in the MAC Address Table\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.mac\\n        salt '*' net.mac vlan=10\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        [\\n            {\\n                'mac'       : '00:1c:58:29:4a:71',\\n                'interface' : 'xe-3/0/2',\\n                'static'    : False,\\n                'active'    : True,\\n                'moves'     : 1,\\n                'vlan'      : 10,\\n                'last_move' : 1454417742.58\\n            },\\n            {\\n                'mac'       : '8c:60:4f:58:e1:c1',\\n                'interface' : 'xe-1/0/1',\\n                'static'    : False,\\n                'active'    : True,\\n                'moves'     : 2,\\n                'vlan'      : 42,\\n                'last_move' : 1453191948.11\\n            }\\n        ]\\n    \"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_mac_address_table', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    mac_address_table = proxy_output.get('out')\n    if vlan and isinstance(vlan, int):\n        mac_address_table = _filter_list(mac_address_table, 'vlan', vlan)\n    if address:\n        mac_address_table = _filter_list(mac_address_table, 'mac', address)\n    if interface:\n        mac_address_table = _filter_list(mac_address_table, 'interface', interface)\n    proxy_output.update({'out': mac_address_table})\n    return proxy_output",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef mac(address='', interface='', vlan=0, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Returns the MAC Address Table on the device.\\n\\n    :param address:   MAC address to filter on\\n    :param interface: Interface name to filter on\\n    :param vlan:      VLAN identifier\\n    :return:          A list of dictionaries representing the entries in the MAC Address Table\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.mac\\n        salt '*' net.mac vlan=10\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        [\\n            {\\n                'mac'       : '00:1c:58:29:4a:71',\\n                'interface' : 'xe-3/0/2',\\n                'static'    : False,\\n                'active'    : True,\\n                'moves'     : 1,\\n                'vlan'      : 10,\\n                'last_move' : 1454417742.58\\n            },\\n            {\\n                'mac'       : '8c:60:4f:58:e1:c1',\\n                'interface' : 'xe-1/0/1',\\n                'static'    : False,\\n                'active'    : True,\\n                'moves'     : 2,\\n                'vlan'      : 42,\\n                'last_move' : 1453191948.11\\n            }\\n        ]\\n    \"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_mac_address_table', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    mac_address_table = proxy_output.get('out')\n    if vlan and isinstance(vlan, int):\n        mac_address_table = _filter_list(mac_address_table, 'vlan', vlan)\n    if address:\n        mac_address_table = _filter_list(mac_address_table, 'mac', address)\n    if interface:\n        mac_address_table = _filter_list(mac_address_table, 'interface', interface)\n    proxy_output.update({'out': mac_address_table})\n    return proxy_output",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef mac(address='', interface='', vlan=0, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Returns the MAC Address Table on the device.\\n\\n    :param address:   MAC address to filter on\\n    :param interface: Interface name to filter on\\n    :param vlan:      VLAN identifier\\n    :return:          A list of dictionaries representing the entries in the MAC Address Table\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.mac\\n        salt '*' net.mac vlan=10\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        [\\n            {\\n                'mac'       : '00:1c:58:29:4a:71',\\n                'interface' : 'xe-3/0/2',\\n                'static'    : False,\\n                'active'    : True,\\n                'moves'     : 1,\\n                'vlan'      : 10,\\n                'last_move' : 1454417742.58\\n            },\\n            {\\n                'mac'       : '8c:60:4f:58:e1:c1',\\n                'interface' : 'xe-1/0/1',\\n                'static'    : False,\\n                'active'    : True,\\n                'moves'     : 2,\\n                'vlan'      : 42,\\n                'last_move' : 1453191948.11\\n            }\\n        ]\\n    \"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_mac_address_table', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    mac_address_table = proxy_output.get('out')\n    if vlan and isinstance(vlan, int):\n        mac_address_table = _filter_list(mac_address_table, 'vlan', vlan)\n    if address:\n        mac_address_table = _filter_list(mac_address_table, 'mac', address)\n    if interface:\n        mac_address_table = _filter_list(mac_address_table, 'interface', interface)\n    proxy_output.update({'out': mac_address_table})\n    return proxy_output",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef mac(address='', interface='', vlan=0, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Returns the MAC Address Table on the device.\\n\\n    :param address:   MAC address to filter on\\n    :param interface: Interface name to filter on\\n    :param vlan:      VLAN identifier\\n    :return:          A list of dictionaries representing the entries in the MAC Address Table\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.mac\\n        salt '*' net.mac vlan=10\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        [\\n            {\\n                'mac'       : '00:1c:58:29:4a:71',\\n                'interface' : 'xe-3/0/2',\\n                'static'    : False,\\n                'active'    : True,\\n                'moves'     : 1,\\n                'vlan'      : 10,\\n                'last_move' : 1454417742.58\\n            },\\n            {\\n                'mac'       : '8c:60:4f:58:e1:c1',\\n                'interface' : 'xe-1/0/1',\\n                'static'    : False,\\n                'active'    : True,\\n                'moves'     : 2,\\n                'vlan'      : 42,\\n                'last_move' : 1453191948.11\\n            }\\n        ]\\n    \"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_mac_address_table', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    mac_address_table = proxy_output.get('out')\n    if vlan and isinstance(vlan, int):\n        mac_address_table = _filter_list(mac_address_table, 'vlan', vlan)\n    if address:\n        mac_address_table = _filter_list(mac_address_table, 'mac', address)\n    if interface:\n        mac_address_table = _filter_list(mac_address_table, 'interface', interface)\n    proxy_output.update({'out': mac_address_table})\n    return proxy_output",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef mac(address='', interface='', vlan=0, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Returns the MAC Address Table on the device.\\n\\n    :param address:   MAC address to filter on\\n    :param interface: Interface name to filter on\\n    :param vlan:      VLAN identifier\\n    :return:          A list of dictionaries representing the entries in the MAC Address Table\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.mac\\n        salt '*' net.mac vlan=10\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        [\\n            {\\n                'mac'       : '00:1c:58:29:4a:71',\\n                'interface' : 'xe-3/0/2',\\n                'static'    : False,\\n                'active'    : True,\\n                'moves'     : 1,\\n                'vlan'      : 10,\\n                'last_move' : 1454417742.58\\n            },\\n            {\\n                'mac'       : '8c:60:4f:58:e1:c1',\\n                'interface' : 'xe-1/0/1',\\n                'static'    : False,\\n                'active'    : True,\\n                'moves'     : 2,\\n                'vlan'      : 42,\\n                'last_move' : 1453191948.11\\n            }\\n        ]\\n    \"\n    proxy_output = salt.utils.napalm.call(napalm_device, 'get_mac_address_table', **{})\n    if not proxy_output.get('result'):\n        return proxy_output\n    mac_address_table = proxy_output.get('out')\n    if vlan and isinstance(vlan, int):\n        mac_address_table = _filter_list(mac_address_table, 'vlan', vlan)\n    if address:\n        mac_address_table = _filter_list(mac_address_table, 'mac', address)\n    if interface:\n        mac_address_table = _filter_list(mac_address_table, 'interface', interface)\n    proxy_output.update({'out': mac_address_table})\n    return proxy_output"
        ]
    },
    {
        "func_name": "config",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef config(source=None, **kwargs):\n    \"\"\"\n    .. versionadded:: 2017.7.0\n\n    Return the whole configuration of the network device. By default, it will\n    return all possible configuration sources supported by the network device.\n    At most, there will be:\n\n    - running config\n    - startup config\n    - candidate config\n\n    To return only one of the configurations, you can use the ``source``\n    argument.\n\n    source\n        Which configuration type you want to display, default is all of them.\n\n        Options:\n\n        - running\n        - candidate\n        - startup\n\n    :return:\n        The object returned is a dictionary with the following keys:\n\n        - running (string): Representation of the native running configuration.\n        - candidate (string): Representation of the native candidate configuration.\n            If the device doesn't differentiate between running and startup\n            configuration this will an empty string.\n        - startup (string): Representation of the native startup configuration.\n            If the device doesn't differentiate between running and startup\n            configuration this will an empty string.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.config\n        salt '*' net.config source=candidate\n    \"\"\"\n    return salt.utils.napalm.call(napalm_device, 'get_config', **{'retrieve': source})",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef config(source=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    Return the whole configuration of the network device. By default, it will\\n    return all possible configuration sources supported by the network device.\\n    At most, there will be:\\n\\n    - running config\\n    - startup config\\n    - candidate config\\n\\n    To return only one of the configurations, you can use the ``source``\\n    argument.\\n\\n    source\\n        Which configuration type you want to display, default is all of them.\\n\\n        Options:\\n\\n        - running\\n        - candidate\\n        - startup\\n\\n    :return:\\n        The object returned is a dictionary with the following keys:\\n\\n        - running (string): Representation of the native running configuration.\\n        - candidate (string): Representation of the native candidate configuration.\\n            If the device doesn't differentiate between running and startup\\n            configuration this will an empty string.\\n        - startup (string): Representation of the native startup configuration.\\n            If the device doesn't differentiate between running and startup\\n            configuration this will an empty string.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.config\\n        salt '*' net.config source=candidate\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_config', **{'retrieve': source})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef config(source=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    Return the whole configuration of the network device. By default, it will\\n    return all possible configuration sources supported by the network device.\\n    At most, there will be:\\n\\n    - running config\\n    - startup config\\n    - candidate config\\n\\n    To return only one of the configurations, you can use the ``source``\\n    argument.\\n\\n    source\\n        Which configuration type you want to display, default is all of them.\\n\\n        Options:\\n\\n        - running\\n        - candidate\\n        - startup\\n\\n    :return:\\n        The object returned is a dictionary with the following keys:\\n\\n        - running (string): Representation of the native running configuration.\\n        - candidate (string): Representation of the native candidate configuration.\\n            If the device doesn't differentiate between running and startup\\n            configuration this will an empty string.\\n        - startup (string): Representation of the native startup configuration.\\n            If the device doesn't differentiate between running and startup\\n            configuration this will an empty string.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.config\\n        salt '*' net.config source=candidate\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_config', **{'retrieve': source})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef config(source=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    Return the whole configuration of the network device. By default, it will\\n    return all possible configuration sources supported by the network device.\\n    At most, there will be:\\n\\n    - running config\\n    - startup config\\n    - candidate config\\n\\n    To return only one of the configurations, you can use the ``source``\\n    argument.\\n\\n    source\\n        Which configuration type you want to display, default is all of them.\\n\\n        Options:\\n\\n        - running\\n        - candidate\\n        - startup\\n\\n    :return:\\n        The object returned is a dictionary with the following keys:\\n\\n        - running (string): Representation of the native running configuration.\\n        - candidate (string): Representation of the native candidate configuration.\\n            If the device doesn't differentiate between running and startup\\n            configuration this will an empty string.\\n        - startup (string): Representation of the native startup configuration.\\n            If the device doesn't differentiate between running and startup\\n            configuration this will an empty string.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.config\\n        salt '*' net.config source=candidate\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_config', **{'retrieve': source})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef config(source=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    Return the whole configuration of the network device. By default, it will\\n    return all possible configuration sources supported by the network device.\\n    At most, there will be:\\n\\n    - running config\\n    - startup config\\n    - candidate config\\n\\n    To return only one of the configurations, you can use the ``source``\\n    argument.\\n\\n    source\\n        Which configuration type you want to display, default is all of them.\\n\\n        Options:\\n\\n        - running\\n        - candidate\\n        - startup\\n\\n    :return:\\n        The object returned is a dictionary with the following keys:\\n\\n        - running (string): Representation of the native running configuration.\\n        - candidate (string): Representation of the native candidate configuration.\\n            If the device doesn't differentiate between running and startup\\n            configuration this will an empty string.\\n        - startup (string): Representation of the native startup configuration.\\n            If the device doesn't differentiate between running and startup\\n            configuration this will an empty string.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.config\\n        salt '*' net.config source=candidate\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_config', **{'retrieve': source})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef config(source=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    Return the whole configuration of the network device. By default, it will\\n    return all possible configuration sources supported by the network device.\\n    At most, there will be:\\n\\n    - running config\\n    - startup config\\n    - candidate config\\n\\n    To return only one of the configurations, you can use the ``source``\\n    argument.\\n\\n    source\\n        Which configuration type you want to display, default is all of them.\\n\\n        Options:\\n\\n        - running\\n        - candidate\\n        - startup\\n\\n    :return:\\n        The object returned is a dictionary with the following keys:\\n\\n        - running (string): Representation of the native running configuration.\\n        - candidate (string): Representation of the native candidate configuration.\\n            If the device doesn't differentiate between running and startup\\n            configuration this will an empty string.\\n        - startup (string): Representation of the native startup configuration.\\n            If the device doesn't differentiate between running and startup\\n            configuration this will an empty string.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.config\\n        salt '*' net.config source=candidate\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_config', **{'retrieve': source})"
        ]
    },
    {
        "func_name": "optics",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef optics(**kwargs):\n    \"\"\"\n    .. versionadded:: 2017.7.0\n\n    Fetches the power usage on the various transceivers installed\n    on the network device (in dBm), and returns a view that conforms with the\n    OpenConfig model openconfig-platform-transceiver.yang.\n\n    :return:\n        Returns a dictionary where the keys are as listed below:\n            * intf_name (unicode)\n                * physical_channels\n                    * channels (list of dicts)\n                        * index (int)\n                        * state\n                            * input_power\n                                * instant (float)\n                                * avg (float)\n                                * min (float)\n                                * max (float)\n                            * output_power\n                                * instant (float)\n                                * avg (float)\n                                * min (float)\n                                * max (float)\n                            * laser_bias_current\n                                * instant (float)\n                                * avg (float)\n                                * min (float)\n                                * max (float)\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.optics\n    \"\"\"\n    return salt.utils.napalm.call(napalm_device, 'get_optics', **{})",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef optics(**kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    Fetches the power usage on the various transceivers installed\\n    on the network device (in dBm), and returns a view that conforms with the\\n    OpenConfig model openconfig-platform-transceiver.yang.\\n\\n    :return:\\n        Returns a dictionary where the keys are as listed below:\\n            * intf_name (unicode)\\n                * physical_channels\\n                    * channels (list of dicts)\\n                        * index (int)\\n                        * state\\n                            * input_power\\n                                * instant (float)\\n                                * avg (float)\\n                                * min (float)\\n                                * max (float)\\n                            * output_power\\n                                * instant (float)\\n                                * avg (float)\\n                                * min (float)\\n                                * max (float)\\n                            * laser_bias_current\\n                                * instant (float)\\n                                * avg (float)\\n                                * min (float)\\n                                * max (float)\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.optics\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_optics', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef optics(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    Fetches the power usage on the various transceivers installed\\n    on the network device (in dBm), and returns a view that conforms with the\\n    OpenConfig model openconfig-platform-transceiver.yang.\\n\\n    :return:\\n        Returns a dictionary where the keys are as listed below:\\n            * intf_name (unicode)\\n                * physical_channels\\n                    * channels (list of dicts)\\n                        * index (int)\\n                        * state\\n                            * input_power\\n                                * instant (float)\\n                                * avg (float)\\n                                * min (float)\\n                                * max (float)\\n                            * output_power\\n                                * instant (float)\\n                                * avg (float)\\n                                * min (float)\\n                                * max (float)\\n                            * laser_bias_current\\n                                * instant (float)\\n                                * avg (float)\\n                                * min (float)\\n                                * max (float)\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.optics\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_optics', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef optics(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    Fetches the power usage on the various transceivers installed\\n    on the network device (in dBm), and returns a view that conforms with the\\n    OpenConfig model openconfig-platform-transceiver.yang.\\n\\n    :return:\\n        Returns a dictionary where the keys are as listed below:\\n            * intf_name (unicode)\\n                * physical_channels\\n                    * channels (list of dicts)\\n                        * index (int)\\n                        * state\\n                            * input_power\\n                                * instant (float)\\n                                * avg (float)\\n                                * min (float)\\n                                * max (float)\\n                            * output_power\\n                                * instant (float)\\n                                * avg (float)\\n                                * min (float)\\n                                * max (float)\\n                            * laser_bias_current\\n                                * instant (float)\\n                                * avg (float)\\n                                * min (float)\\n                                * max (float)\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.optics\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_optics', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef optics(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    Fetches the power usage on the various transceivers installed\\n    on the network device (in dBm), and returns a view that conforms with the\\n    OpenConfig model openconfig-platform-transceiver.yang.\\n\\n    :return:\\n        Returns a dictionary where the keys are as listed below:\\n            * intf_name (unicode)\\n                * physical_channels\\n                    * channels (list of dicts)\\n                        * index (int)\\n                        * state\\n                            * input_power\\n                                * instant (float)\\n                                * avg (float)\\n                                * min (float)\\n                                * max (float)\\n                            * output_power\\n                                * instant (float)\\n                                * avg (float)\\n                                * min (float)\\n                                * max (float)\\n                            * laser_bias_current\\n                                * instant (float)\\n                                * avg (float)\\n                                * min (float)\\n                                * max (float)\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.optics\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_optics', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef optics(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    Fetches the power usage on the various transceivers installed\\n    on the network device (in dBm), and returns a view that conforms with the\\n    OpenConfig model openconfig-platform-transceiver.yang.\\n\\n    :return:\\n        Returns a dictionary where the keys are as listed below:\\n            * intf_name (unicode)\\n                * physical_channels\\n                    * channels (list of dicts)\\n                        * index (int)\\n                        * state\\n                            * input_power\\n                                * instant (float)\\n                                * avg (float)\\n                                * min (float)\\n                                * max (float)\\n                            * output_power\\n                                * instant (float)\\n                                * avg (float)\\n                                * min (float)\\n                                * max (float)\\n                            * laser_bias_current\\n                                * instant (float)\\n                                * avg (float)\\n                                * min (float)\\n                                * max (float)\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.optics\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_optics', **{})"
        ]
    },
    {
        "func_name": "load_config",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef load_config(filename=None, text=None, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, commit_jid=None, inherit_napalm_device=None, saltenv='base', **kwargs):\n    \"\"\"\n    Applies configuration changes on the device. It can be loaded from a file or from inline string.\n    If you send both a filename and a string containing the configuration, the file has higher precedence.\n\n    By default this function will commit the changes. If there are no changes, it does not commit and\n    the flag ``already_configured`` will be set as ``True`` to point this out.\n\n    To avoid committing the configuration, set the argument ``test`` to ``True`` and will discard (dry run).\n\n    To keep the changes but not commit, set ``commit`` to ``False``.\n\n    To replace the config, set ``replace`` to ``True``.\n\n    filename\n        Path to the file containing the desired configuration.\n        This can be specified using the absolute path to the file,\n        or using one of the following URL schemes:\n\n        - ``salt://``, to fetch the template from the Salt fileserver.\n        - ``http://`` or ``https://``\n        - ``ftp://``\n        - ``s3://``\n        - ``swift://``\n\n        .. versionchanged:: 2018.3.0\n\n    text\n        String containing the desired configuration.\n        This argument is ignored when ``filename`` is specified.\n\n    test: False\n        Dry run? If set as ``True``, will apply the config, discard and return the changes. Default: ``False``\n        and will commit the changes on the device.\n\n    commit: True\n        Commit? Default: ``True``.\n\n    debug: False\n        Debug mode. Will insert a new key under the output dictionary, as ``loaded_config`` containing the raw\n        configuration loaded on the device.\n\n        .. versionadded:: 2016.11.2\n\n    replace: False\n        Load and replace the configuration. Default: ``False``.\n\n        .. versionadded:: 2016.11.2\n\n    commit_in: ``None``\n        Commit the changes in a specific number of minutes / hours. Example of\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\n        the changes in 5 hours and 30 minutes).\n\n        .. note::\n            This feature works on any platforms, as it does not rely on the\n            native features of the network operating system.\n\n        .. note::\n            After the command is executed and the ``diff`` is not satisfactory,\n            or for any other reasons you have to discard the commit, you are\n            able to do so using the\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\n            execution function, using the commit ID returned by this function.\n\n        .. warning::\n            Using this feature, Salt will load the exact configuration you\n            expect, however the diff may change in time (i.e., if an user\n            applies a manual configuration change, or a different process or\n            command changes the configuration in the meanwhile).\n\n        .. versionadded:: 2019.2.0\n\n    commit_at: ``None``\n        Commit the changes at a specific time. Example of accepted formats:\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\n        commit at 13:20), ``1:20am``, etc.\n\n        .. note::\n            This feature works on any platforms, as it does not rely on the\n            native features of the network operating system.\n\n        .. note::\n            After the command is executed and the ``diff`` is not satisfactory,\n            or for any other reasons you have to discard the commit, you are\n            able to do so using the\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\n            execution function, using the commit ID returned by this function.\n\n        .. warning::\n            Using this feature, Salt will load the exact configuration you\n            expect, however the diff may change in time (i.e., if an user\n            applies a manual configuration change, or a different process or\n            command changes the configuration in the meanwhile).\n\n        .. versionadded:: 2019.2.0\n\n    revert_in: ``None``\n        Commit and revert the changes in a specific number of minutes / hours.\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\n        the changes in 5 hours and 30 minutes).\n\n        .. note::\n            To confirm the commit, and prevent reverting the changes, you will\n            have to execute the\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\n            function, using the commit ID returned by this function.\n\n        .. warning::\n            This works on any platform, regardless if they have or don't have\n            native capabilities to confirming a commit. However, please be\n            *very* cautious when using this feature: on Junos (as it is the only\n            NAPALM core platform supporting this natively) it executes a commit\n            confirmed as you would do from the command line.\n            All the other platforms don't have this capability natively,\n            therefore the revert is done via Salt. That means, your device needs\n            to be reachable at the moment when Salt will attempt to revert your\n            changes. Be cautious when pushing configuration changes that would\n            prevent you reach the device.\n\n            Similarly, if an user or a different process apply other\n            configuration changes in the meanwhile (between the moment you\n            commit and till the changes are reverted), these changes would be\n            equally reverted, as Salt cannot be aware of them.\n\n        .. versionadded:: 2019.2.0\n\n    revert_at: ``None``\n        Commit and revert the changes at a specific time. Example of accepted\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\n\n        .. note::\n            To confirm the commit, and prevent reverting the changes, you will\n            have to execute the\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\n            function, using the commit ID returned by this function.\n\n        .. warning::\n            This works on any platform, regardless if they have or don't have\n            native capabilities to confirming a commit. However, please be\n            *very* cautious when using this feature: on Junos (as it is the only\n            NAPALM core platform supporting this natively) it executes a commit\n            confirmed as you would do from the command line.\n            All the other platforms don't have this capability natively,\n            therefore the revert is done via Salt. That means, your device needs\n            to be reachable at the moment when Salt will attempt to revert your\n            changes. Be cautious when pushing configuration changes that would\n            prevent you reach the device.\n\n            Similarly, if an user or a different process apply other\n            configuration changes in the meanwhile (between the moment you\n            commit and till the changes are reverted), these changes would be\n            equally reverted, as Salt cannot be aware of them.\n\n        .. versionadded:: 2019.2.0\n\n    saltenv: ``base``\n        Specifies the Salt environment name.\n\n        .. versionadded:: 2018.3.0\n\n    :return: a dictionary having the following keys:\n\n    * result (bool): if the config was applied successfully. It is ``False`` only in case of failure. In case     there are no changes to be applied and successfully performs all operations it is still ``True`` and so will be     the ``already_configured`` flag (example below)\n    * comment (str): a message for the user\n    * already_configured (bool): flag to check if there were no changes applied\n    * loaded_config (str): the configuration loaded on the device. Requires ``debug`` to be set as ``True``\n    * diff (str): returns the config changes applied\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.load_config text='ntp peer 192.168.0.1'\n        salt '*' net.load_config filename='/absolute/path/to/your/file'\n        salt '*' net.load_config filename='/absolute/path/to/your/file' test=True\n        salt '*' net.load_config filename='/absolute/path/to/your/file' commit=False\n\n    Example output:\n\n    .. code-block:: python\n\n        {\n            'comment': 'Configuration discarded.',\n            'already_configured': False,\n            'result': True,\n            'diff': '[edit interfaces xe-0/0/5]+   description \"Adding a description\";'\n        }\n    \"\"\"\n    fun = 'load_merge_candidate'\n    if replace:\n        fun = 'load_replace_candidate'\n    if salt.utils.napalm.not_always_alive(__opts__):\n        napalm_device['CLOSE'] = False\n    if filename:\n        text = __salt__['cp.get_file_str'](filename, saltenv=saltenv)\n        if text is False:\n            ret = {'result': False, 'out': None}\n            ret['comment'] = 'Unable to read from {}. Please specify a valid file or text.'.format(filename)\n            log.error(ret['comment'])\n            return ret\n        if commit_jid:\n            salt.utils.files.safe_rm(filename)\n    _loaded = salt.utils.napalm.call(napalm_device, fun, **{'config': text})\n    return _config_logic(napalm_device, _loaded, test=test, debug=debug, replace=replace, commit_config=commit, loaded_config=text, commit_at=commit_at, commit_in=commit_in, revert_in=revert_in, revert_at=revert_at, commit_jid=commit_jid, **kwargs)",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef load_config(filename=None, text=None, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, commit_jid=None, inherit_napalm_device=None, saltenv='base', **kwargs):\n    if False:\n        i = 10\n    '\\n    Applies configuration changes on the device. It can be loaded from a file or from inline string.\\n    If you send both a filename and a string containing the configuration, the file has higher precedence.\\n\\n    By default this function will commit the changes. If there are no changes, it does not commit and\\n    the flag ``already_configured`` will be set as ``True`` to point this out.\\n\\n    To avoid committing the configuration, set the argument ``test`` to ``True`` and will discard (dry run).\\n\\n    To keep the changes but not commit, set ``commit`` to ``False``.\\n\\n    To replace the config, set ``replace`` to ``True``.\\n\\n    filename\\n        Path to the file containing the desired configuration.\\n        This can be specified using the absolute path to the file,\\n        or using one of the following URL schemes:\\n\\n        - ``salt://``, to fetch the template from the Salt fileserver.\\n        - ``http://`` or ``https://``\\n        - ``ftp://``\\n        - ``s3://``\\n        - ``swift://``\\n\\n        .. versionchanged:: 2018.3.0\\n\\n    text\\n        String containing the desired configuration.\\n        This argument is ignored when ``filename`` is specified.\\n\\n    test: False\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes. Default: ``False``\\n        and will commit the changes on the device.\\n\\n    commit: True\\n        Commit? Default: ``True``.\\n\\n    debug: False\\n        Debug mode. Will insert a new key under the output dictionary, as ``loaded_config`` containing the raw\\n        configuration loaded on the device.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    replace: False\\n        Load and replace the configuration. Default: ``False``.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    commit_in: ``None``\\n        Commit the changes in a specific number of minutes / hours. Example of\\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    commit_at: ``None``\\n        Commit the changes at a specific time. Example of accepted formats:\\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\\n        commit at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_in: ``None``\\n        Commit and revert the changes in a specific number of minutes / hours.\\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_at: ``None``\\n        Commit and revert the changes at a specific time. Example of accepted\\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    saltenv: ``base``\\n        Specifies the Salt environment name.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    :return: a dictionary having the following keys:\\n\\n    * result (bool): if the config was applied successfully. It is ``False`` only in case of failure. In case     there are no changes to be applied and successfully performs all operations it is still ``True`` and so will be     the ``already_configured`` flag (example below)\\n    * comment (str): a message for the user\\n    * already_configured (bool): flag to check if there were no changes applied\\n    * loaded_config (str): the configuration loaded on the device. Requires ``debug`` to be set as ``True``\\n    * diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.load_config text=\\'ntp peer 192.168.0.1\\'\\n        salt \\'*\\' net.load_config filename=\\'/absolute/path/to/your/file\\'\\n        salt \\'*\\' net.load_config filename=\\'/absolute/path/to/your/file\\' test=True\\n        salt \\'*\\' net.load_config filename=\\'/absolute/path/to/your/file\\' commit=False\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'comment\\': \\'Configuration discarded.\\',\\n            \\'already_configured\\': False,\\n            \\'result\\': True,\\n            \\'diff\\': \\'[edit interfaces xe-0/0/5]+   description \"Adding a description\";\\'\\n        }\\n    '\n    fun = 'load_merge_candidate'\n    if replace:\n        fun = 'load_replace_candidate'\n    if salt.utils.napalm.not_always_alive(__opts__):\n        napalm_device['CLOSE'] = False\n    if filename:\n        text = __salt__['cp.get_file_str'](filename, saltenv=saltenv)\n        if text is False:\n            ret = {'result': False, 'out': None}\n            ret['comment'] = 'Unable to read from {}. Please specify a valid file or text.'.format(filename)\n            log.error(ret['comment'])\n            return ret\n        if commit_jid:\n            salt.utils.files.safe_rm(filename)\n    _loaded = salt.utils.napalm.call(napalm_device, fun, **{'config': text})\n    return _config_logic(napalm_device, _loaded, test=test, debug=debug, replace=replace, commit_config=commit, loaded_config=text, commit_at=commit_at, commit_in=commit_in, revert_in=revert_in, revert_at=revert_at, commit_jid=commit_jid, **kwargs)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef load_config(filename=None, text=None, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, commit_jid=None, inherit_napalm_device=None, saltenv='base', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Applies configuration changes on the device. It can be loaded from a file or from inline string.\\n    If you send both a filename and a string containing the configuration, the file has higher precedence.\\n\\n    By default this function will commit the changes. If there are no changes, it does not commit and\\n    the flag ``already_configured`` will be set as ``True`` to point this out.\\n\\n    To avoid committing the configuration, set the argument ``test`` to ``True`` and will discard (dry run).\\n\\n    To keep the changes but not commit, set ``commit`` to ``False``.\\n\\n    To replace the config, set ``replace`` to ``True``.\\n\\n    filename\\n        Path to the file containing the desired configuration.\\n        This can be specified using the absolute path to the file,\\n        or using one of the following URL schemes:\\n\\n        - ``salt://``, to fetch the template from the Salt fileserver.\\n        - ``http://`` or ``https://``\\n        - ``ftp://``\\n        - ``s3://``\\n        - ``swift://``\\n\\n        .. versionchanged:: 2018.3.0\\n\\n    text\\n        String containing the desired configuration.\\n        This argument is ignored when ``filename`` is specified.\\n\\n    test: False\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes. Default: ``False``\\n        and will commit the changes on the device.\\n\\n    commit: True\\n        Commit? Default: ``True``.\\n\\n    debug: False\\n        Debug mode. Will insert a new key under the output dictionary, as ``loaded_config`` containing the raw\\n        configuration loaded on the device.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    replace: False\\n        Load and replace the configuration. Default: ``False``.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    commit_in: ``None``\\n        Commit the changes in a specific number of minutes / hours. Example of\\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    commit_at: ``None``\\n        Commit the changes at a specific time. Example of accepted formats:\\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\\n        commit at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_in: ``None``\\n        Commit and revert the changes in a specific number of minutes / hours.\\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_at: ``None``\\n        Commit and revert the changes at a specific time. Example of accepted\\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    saltenv: ``base``\\n        Specifies the Salt environment name.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    :return: a dictionary having the following keys:\\n\\n    * result (bool): if the config was applied successfully. It is ``False`` only in case of failure. In case     there are no changes to be applied and successfully performs all operations it is still ``True`` and so will be     the ``already_configured`` flag (example below)\\n    * comment (str): a message for the user\\n    * already_configured (bool): flag to check if there were no changes applied\\n    * loaded_config (str): the configuration loaded on the device. Requires ``debug`` to be set as ``True``\\n    * diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.load_config text=\\'ntp peer 192.168.0.1\\'\\n        salt \\'*\\' net.load_config filename=\\'/absolute/path/to/your/file\\'\\n        salt \\'*\\' net.load_config filename=\\'/absolute/path/to/your/file\\' test=True\\n        salt \\'*\\' net.load_config filename=\\'/absolute/path/to/your/file\\' commit=False\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'comment\\': \\'Configuration discarded.\\',\\n            \\'already_configured\\': False,\\n            \\'result\\': True,\\n            \\'diff\\': \\'[edit interfaces xe-0/0/5]+   description \"Adding a description\";\\'\\n        }\\n    '\n    fun = 'load_merge_candidate'\n    if replace:\n        fun = 'load_replace_candidate'\n    if salt.utils.napalm.not_always_alive(__opts__):\n        napalm_device['CLOSE'] = False\n    if filename:\n        text = __salt__['cp.get_file_str'](filename, saltenv=saltenv)\n        if text is False:\n            ret = {'result': False, 'out': None}\n            ret['comment'] = 'Unable to read from {}. Please specify a valid file or text.'.format(filename)\n            log.error(ret['comment'])\n            return ret\n        if commit_jid:\n            salt.utils.files.safe_rm(filename)\n    _loaded = salt.utils.napalm.call(napalm_device, fun, **{'config': text})\n    return _config_logic(napalm_device, _loaded, test=test, debug=debug, replace=replace, commit_config=commit, loaded_config=text, commit_at=commit_at, commit_in=commit_in, revert_in=revert_in, revert_at=revert_at, commit_jid=commit_jid, **kwargs)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef load_config(filename=None, text=None, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, commit_jid=None, inherit_napalm_device=None, saltenv='base', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Applies configuration changes on the device. It can be loaded from a file or from inline string.\\n    If you send both a filename and a string containing the configuration, the file has higher precedence.\\n\\n    By default this function will commit the changes. If there are no changes, it does not commit and\\n    the flag ``already_configured`` will be set as ``True`` to point this out.\\n\\n    To avoid committing the configuration, set the argument ``test`` to ``True`` and will discard (dry run).\\n\\n    To keep the changes but not commit, set ``commit`` to ``False``.\\n\\n    To replace the config, set ``replace`` to ``True``.\\n\\n    filename\\n        Path to the file containing the desired configuration.\\n        This can be specified using the absolute path to the file,\\n        or using one of the following URL schemes:\\n\\n        - ``salt://``, to fetch the template from the Salt fileserver.\\n        - ``http://`` or ``https://``\\n        - ``ftp://``\\n        - ``s3://``\\n        - ``swift://``\\n\\n        .. versionchanged:: 2018.3.0\\n\\n    text\\n        String containing the desired configuration.\\n        This argument is ignored when ``filename`` is specified.\\n\\n    test: False\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes. Default: ``False``\\n        and will commit the changes on the device.\\n\\n    commit: True\\n        Commit? Default: ``True``.\\n\\n    debug: False\\n        Debug mode. Will insert a new key under the output dictionary, as ``loaded_config`` containing the raw\\n        configuration loaded on the device.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    replace: False\\n        Load and replace the configuration. Default: ``False``.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    commit_in: ``None``\\n        Commit the changes in a specific number of minutes / hours. Example of\\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    commit_at: ``None``\\n        Commit the changes at a specific time. Example of accepted formats:\\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\\n        commit at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_in: ``None``\\n        Commit and revert the changes in a specific number of minutes / hours.\\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_at: ``None``\\n        Commit and revert the changes at a specific time. Example of accepted\\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    saltenv: ``base``\\n        Specifies the Salt environment name.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    :return: a dictionary having the following keys:\\n\\n    * result (bool): if the config was applied successfully. It is ``False`` only in case of failure. In case     there are no changes to be applied and successfully performs all operations it is still ``True`` and so will be     the ``already_configured`` flag (example below)\\n    * comment (str): a message for the user\\n    * already_configured (bool): flag to check if there were no changes applied\\n    * loaded_config (str): the configuration loaded on the device. Requires ``debug`` to be set as ``True``\\n    * diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.load_config text=\\'ntp peer 192.168.0.1\\'\\n        salt \\'*\\' net.load_config filename=\\'/absolute/path/to/your/file\\'\\n        salt \\'*\\' net.load_config filename=\\'/absolute/path/to/your/file\\' test=True\\n        salt \\'*\\' net.load_config filename=\\'/absolute/path/to/your/file\\' commit=False\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'comment\\': \\'Configuration discarded.\\',\\n            \\'already_configured\\': False,\\n            \\'result\\': True,\\n            \\'diff\\': \\'[edit interfaces xe-0/0/5]+   description \"Adding a description\";\\'\\n        }\\n    '\n    fun = 'load_merge_candidate'\n    if replace:\n        fun = 'load_replace_candidate'\n    if salt.utils.napalm.not_always_alive(__opts__):\n        napalm_device['CLOSE'] = False\n    if filename:\n        text = __salt__['cp.get_file_str'](filename, saltenv=saltenv)\n        if text is False:\n            ret = {'result': False, 'out': None}\n            ret['comment'] = 'Unable to read from {}. Please specify a valid file or text.'.format(filename)\n            log.error(ret['comment'])\n            return ret\n        if commit_jid:\n            salt.utils.files.safe_rm(filename)\n    _loaded = salt.utils.napalm.call(napalm_device, fun, **{'config': text})\n    return _config_logic(napalm_device, _loaded, test=test, debug=debug, replace=replace, commit_config=commit, loaded_config=text, commit_at=commit_at, commit_in=commit_in, revert_in=revert_in, revert_at=revert_at, commit_jid=commit_jid, **kwargs)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef load_config(filename=None, text=None, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, commit_jid=None, inherit_napalm_device=None, saltenv='base', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Applies configuration changes on the device. It can be loaded from a file or from inline string.\\n    If you send both a filename and a string containing the configuration, the file has higher precedence.\\n\\n    By default this function will commit the changes. If there are no changes, it does not commit and\\n    the flag ``already_configured`` will be set as ``True`` to point this out.\\n\\n    To avoid committing the configuration, set the argument ``test`` to ``True`` and will discard (dry run).\\n\\n    To keep the changes but not commit, set ``commit`` to ``False``.\\n\\n    To replace the config, set ``replace`` to ``True``.\\n\\n    filename\\n        Path to the file containing the desired configuration.\\n        This can be specified using the absolute path to the file,\\n        or using one of the following URL schemes:\\n\\n        - ``salt://``, to fetch the template from the Salt fileserver.\\n        - ``http://`` or ``https://``\\n        - ``ftp://``\\n        - ``s3://``\\n        - ``swift://``\\n\\n        .. versionchanged:: 2018.3.0\\n\\n    text\\n        String containing the desired configuration.\\n        This argument is ignored when ``filename`` is specified.\\n\\n    test: False\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes. Default: ``False``\\n        and will commit the changes on the device.\\n\\n    commit: True\\n        Commit? Default: ``True``.\\n\\n    debug: False\\n        Debug mode. Will insert a new key under the output dictionary, as ``loaded_config`` containing the raw\\n        configuration loaded on the device.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    replace: False\\n        Load and replace the configuration. Default: ``False``.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    commit_in: ``None``\\n        Commit the changes in a specific number of minutes / hours. Example of\\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    commit_at: ``None``\\n        Commit the changes at a specific time. Example of accepted formats:\\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\\n        commit at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_in: ``None``\\n        Commit and revert the changes in a specific number of minutes / hours.\\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_at: ``None``\\n        Commit and revert the changes at a specific time. Example of accepted\\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    saltenv: ``base``\\n        Specifies the Salt environment name.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    :return: a dictionary having the following keys:\\n\\n    * result (bool): if the config was applied successfully. It is ``False`` only in case of failure. In case     there are no changes to be applied and successfully performs all operations it is still ``True`` and so will be     the ``already_configured`` flag (example below)\\n    * comment (str): a message for the user\\n    * already_configured (bool): flag to check if there were no changes applied\\n    * loaded_config (str): the configuration loaded on the device. Requires ``debug`` to be set as ``True``\\n    * diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.load_config text=\\'ntp peer 192.168.0.1\\'\\n        salt \\'*\\' net.load_config filename=\\'/absolute/path/to/your/file\\'\\n        salt \\'*\\' net.load_config filename=\\'/absolute/path/to/your/file\\' test=True\\n        salt \\'*\\' net.load_config filename=\\'/absolute/path/to/your/file\\' commit=False\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'comment\\': \\'Configuration discarded.\\',\\n            \\'already_configured\\': False,\\n            \\'result\\': True,\\n            \\'diff\\': \\'[edit interfaces xe-0/0/5]+   description \"Adding a description\";\\'\\n        }\\n    '\n    fun = 'load_merge_candidate'\n    if replace:\n        fun = 'load_replace_candidate'\n    if salt.utils.napalm.not_always_alive(__opts__):\n        napalm_device['CLOSE'] = False\n    if filename:\n        text = __salt__['cp.get_file_str'](filename, saltenv=saltenv)\n        if text is False:\n            ret = {'result': False, 'out': None}\n            ret['comment'] = 'Unable to read from {}. Please specify a valid file or text.'.format(filename)\n            log.error(ret['comment'])\n            return ret\n        if commit_jid:\n            salt.utils.files.safe_rm(filename)\n    _loaded = salt.utils.napalm.call(napalm_device, fun, **{'config': text})\n    return _config_logic(napalm_device, _loaded, test=test, debug=debug, replace=replace, commit_config=commit, loaded_config=text, commit_at=commit_at, commit_in=commit_in, revert_in=revert_in, revert_at=revert_at, commit_jid=commit_jid, **kwargs)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef load_config(filename=None, text=None, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, commit_jid=None, inherit_napalm_device=None, saltenv='base', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Applies configuration changes on the device. It can be loaded from a file or from inline string.\\n    If you send both a filename and a string containing the configuration, the file has higher precedence.\\n\\n    By default this function will commit the changes. If there are no changes, it does not commit and\\n    the flag ``already_configured`` will be set as ``True`` to point this out.\\n\\n    To avoid committing the configuration, set the argument ``test`` to ``True`` and will discard (dry run).\\n\\n    To keep the changes but not commit, set ``commit`` to ``False``.\\n\\n    To replace the config, set ``replace`` to ``True``.\\n\\n    filename\\n        Path to the file containing the desired configuration.\\n        This can be specified using the absolute path to the file,\\n        or using one of the following URL schemes:\\n\\n        - ``salt://``, to fetch the template from the Salt fileserver.\\n        - ``http://`` or ``https://``\\n        - ``ftp://``\\n        - ``s3://``\\n        - ``swift://``\\n\\n        .. versionchanged:: 2018.3.0\\n\\n    text\\n        String containing the desired configuration.\\n        This argument is ignored when ``filename`` is specified.\\n\\n    test: False\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes. Default: ``False``\\n        and will commit the changes on the device.\\n\\n    commit: True\\n        Commit? Default: ``True``.\\n\\n    debug: False\\n        Debug mode. Will insert a new key under the output dictionary, as ``loaded_config`` containing the raw\\n        configuration loaded on the device.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    replace: False\\n        Load and replace the configuration. Default: ``False``.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    commit_in: ``None``\\n        Commit the changes in a specific number of minutes / hours. Example of\\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    commit_at: ``None``\\n        Commit the changes at a specific time. Example of accepted formats:\\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\\n        commit at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_in: ``None``\\n        Commit and revert the changes in a specific number of minutes / hours.\\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_at: ``None``\\n        Commit and revert the changes at a specific time. Example of accepted\\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    saltenv: ``base``\\n        Specifies the Salt environment name.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    :return: a dictionary having the following keys:\\n\\n    * result (bool): if the config was applied successfully. It is ``False`` only in case of failure. In case     there are no changes to be applied and successfully performs all operations it is still ``True`` and so will be     the ``already_configured`` flag (example below)\\n    * comment (str): a message for the user\\n    * already_configured (bool): flag to check if there were no changes applied\\n    * loaded_config (str): the configuration loaded on the device. Requires ``debug`` to be set as ``True``\\n    * diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.load_config text=\\'ntp peer 192.168.0.1\\'\\n        salt \\'*\\' net.load_config filename=\\'/absolute/path/to/your/file\\'\\n        salt \\'*\\' net.load_config filename=\\'/absolute/path/to/your/file\\' test=True\\n        salt \\'*\\' net.load_config filename=\\'/absolute/path/to/your/file\\' commit=False\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'comment\\': \\'Configuration discarded.\\',\\n            \\'already_configured\\': False,\\n            \\'result\\': True,\\n            \\'diff\\': \\'[edit interfaces xe-0/0/5]+   description \"Adding a description\";\\'\\n        }\\n    '\n    fun = 'load_merge_candidate'\n    if replace:\n        fun = 'load_replace_candidate'\n    if salt.utils.napalm.not_always_alive(__opts__):\n        napalm_device['CLOSE'] = False\n    if filename:\n        text = __salt__['cp.get_file_str'](filename, saltenv=saltenv)\n        if text is False:\n            ret = {'result': False, 'out': None}\n            ret['comment'] = 'Unable to read from {}. Please specify a valid file or text.'.format(filename)\n            log.error(ret['comment'])\n            return ret\n        if commit_jid:\n            salt.utils.files.safe_rm(filename)\n    _loaded = salt.utils.napalm.call(napalm_device, fun, **{'config': text})\n    return _config_logic(napalm_device, _loaded, test=test, debug=debug, replace=replace, commit_config=commit, loaded_config=text, commit_at=commit_at, commit_in=commit_in, revert_in=revert_in, revert_at=revert_at, commit_jid=commit_jid, **kwargs)"
        ]
    },
    {
        "func_name": "load_template",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef load_template(template_name=None, template_source=None, context=None, defaults=None, template_engine='jinja', saltenv='base', template_hash=None, template_hash_name=None, skip_verify=False, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, inherit_napalm_device=None, **template_vars):\n    \"\"\"\n    Renders a configuration template (default: Jinja) and loads the result on the device.\n\n    By default this function will commit the changes. If there are no changes,\n    it does not commit, discards he config and the flag ``already_configured``\n    will be set as ``True`` to point this out.\n\n    To avoid committing the configuration, set the argument ``test`` to ``True``\n    and will discard (dry run).\n\n    To preserve the changes, set ``commit`` to ``False``.\n    However, this is recommended to be used only in exceptional cases\n    when there are applied few consecutive states\n    and/or configuration changes.\n    Otherwise the user might forget that the config DB is locked\n    and the candidate config buffer is not cleared/merged in the running config.\n\n    To replace the config, set ``replace`` to ``True``.\n\n    template_name\n        Identifies path to the template source.\n        The template can be either stored on the local machine, either remotely.\n        The recommended location is under the ``file_roots``\n        as specified in the master config file.\n        For example, let's suppose the ``file_roots`` is configured as:\n\n        .. code-block:: yaml\n\n            file_roots:\n              base:\n                - /etc/salt/states\n\n        Placing the template under ``/etc/salt/states/templates/example.jinja``,\n        it can be used as ``salt://templates/example.jinja``.\n        Alternatively, for local files, the user can specify the absolute path.\n        If remotely, the source can be retrieved via ``http``, ``https`` or ``ftp``.\n\n        Examples:\n\n        - ``salt://my_template.jinja``\n        - ``/absolute/path/to/my_template.jinja``\n        - ``http://example.com/template.cheetah``\n        - ``https:/example.com/template.mako``\n        - ``ftp://example.com/template.py``\n\n        .. versionchanged:: 2019.2.0\n            This argument can now support a list of templates to be rendered.\n            The resulting configuration text is loaded at once, as a single\n            configuration chunk.\n\n    template_source: None\n        Inline config template to be rendered and loaded on the device.\n\n    template_hash: None\n        Hash of the template file. Format: ``{hash_type: 'md5', 'hsum': <md5sum>}``\n\n        .. versionadded:: 2016.11.2\n\n    context: None\n        Overrides default context variables passed to the template.\n\n        .. versionadded:: 2019.2.0\n\n    template_hash_name: None\n        When ``template_hash`` refers to a remote file,\n        this specifies the filename to look for in that file.\n\n        .. versionadded:: 2016.11.2\n\n    saltenv: ``base``\n        Specifies the template environment.\n        This will influence the relative imports inside the templates.\n\n        .. versionadded:: 2016.11.2\n\n    template_engine: jinja\n        The following templates engines are supported:\n\n        - :mod:`cheetah<salt.renderers.cheetah>`\n        - :mod:`genshi<salt.renderers.genshi>`\n        - :mod:`jinja<salt.renderers.jinja>`\n        - :mod:`mako<salt.renderers.mako>`\n        - :mod:`py<salt.renderers.py>`\n        - :mod:`wempy<salt.renderers.wempy>`\n\n        .. versionadded:: 2016.11.2\n\n    skip_verify: True\n        If ``True``, hash verification of remote file sources\n        (``http://``, ``https://``, ``ftp://``) will be skipped,\n        and the ``source_hash`` argument will be ignored.\n\n        .. versionadded:: 2016.11.2\n\n    test: False\n        Dry run? If set to ``True``, will apply the config,\n        discard and return the changes.\n        Default: ``False`` and will commit the changes on the device.\n\n    commit: True\n        Commit? (default: ``True``)\n\n    debug: False\n        Debug mode. Will insert a new key under the output dictionary,\n        as ``loaded_config`` containing the raw result after the template was rendered.\n\n        .. versionadded:: 2016.11.2\n\n    replace: False\n        Load and replace the configuration.\n\n        .. versionadded:: 2016.11.2\n\n    commit_in: ``None``\n        Commit the changes in a specific number of minutes / hours. Example of\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\n        the changes in 5 hours and 30 minutes).\n\n        .. note::\n            This feature works on any platforms, as it does not rely on the\n            native features of the network operating system.\n\n        .. note::\n            After the command is executed and the ``diff`` is not satisfactory,\n            or for any other reasons you have to discard the commit, you are\n            able to do so using the\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\n            execution function, using the commit ID returned by this function.\n\n        .. warning::\n            Using this feature, Salt will load the exact configuration you\n            expect, however the diff may change in time (i.e., if an user\n            applies a manual configuration change, or a different process or\n            command changes the configuration in the meanwhile).\n\n        .. versionadded:: 2019.2.0\n\n    commit_at: ``None``\n        Commit the changes at a specific time. Example of accepted formats:\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\n        commit at 13:20), ``1:20am``, etc.\n\n        .. note::\n            This feature works on any platforms, as it does not rely on the\n            native features of the network operating system.\n\n        .. note::\n            After the command is executed and the ``diff`` is not satisfactory,\n            or for any other reasons you have to discard the commit, you are\n            able to do so using the\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\n            execution function, using the commit ID returned by this function.\n\n        .. warning::\n            Using this feature, Salt will load the exact configuration you\n            expect, however the diff may change in time (i.e., if an user\n            applies a manual configuration change, or a different process or\n            command changes the configuration in the meanwhile).\n\n        .. versionadded:: 2019.2.0\n\n    revert_in: ``None``\n        Commit and revert the changes in a specific number of minutes / hours.\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\n        the changes in 5 hours and 30 minutes).\n\n        .. note::\n            To confirm the commit, and prevent reverting the changes, you will\n            have to execute the\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\n            function, using the commit ID returned by this function.\n\n        .. warning::\n            This works on any platform, regardless if they have or don't have\n            native capabilities to confirming a commit. However, please be\n            *very* cautious when using this feature: on Junos (as it is the only\n            NAPALM core platform supporting this natively) it executes a commit\n            confirmed as you would do from the command line.\n            All the other platforms don't have this capability natively,\n            therefore the revert is done via Salt. That means, your device needs\n            to be reachable at the moment when Salt will attempt to revert your\n            changes. Be cautious when pushing configuration changes that would\n            prevent you reach the device.\n\n            Similarly, if an user or a different process apply other\n            configuration changes in the meanwhile (between the moment you\n            commit and till the changes are reverted), these changes would be\n            equally reverted, as Salt cannot be aware of them.\n\n        .. versionadded:: 2019.2.0\n\n    revert_at: ``None``\n        Commit and revert the changes at a specific time. Example of accepted\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\n\n        .. note::\n            To confirm the commit, and prevent reverting the changes, you will\n            have to execute the\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\n            function, using the commit ID returned by this function.\n\n        .. warning::\n            This works on any platform, regardless if they have or don't have\n            native capabilities to confirming a commit. However, please be\n            *very* cautious when using this feature: on Junos (as it is the only\n            NAPALM core platform supporting this natively) it executes a commit\n            confirmed as you would do from the command line.\n            All the other platforms don't have this capability natively,\n            therefore the revert is done via Salt. That means, your device needs\n            to be reachable at the moment when Salt will attempt to revert your\n            changes. Be cautious when pushing configuration changes that would\n            prevent you reach the device.\n\n            Similarly, if an user or a different process apply other\n            configuration changes in the meanwhile (between the moment you\n            commit and till the changes are reverted), these changes would be\n            equally reverted, as Salt cannot be aware of them.\n\n        .. versionadded:: 2019.2.0\n\n    defaults: None\n        Default variables/context passed to the template.\n\n        .. versionadded:: 2016.11.2\n\n    template_vars\n        Dictionary with the arguments/context to be used when the template is rendered.\n\n        .. note::\n            Do not explicitly specify this argument. This represents any other\n            variable that will be sent to the template rendering system.\n            Please see the examples below!\n\n        .. note::\n            It is more recommended to use the ``context`` argument to avoid\n            conflicts between CLI arguments and template variables.\n\n    :return: a dictionary having the following keys:\n\n    - result (bool): if the config was applied successfully. It is ``False``\n      only in case of failure. In case there are no changes to be applied and\n      successfully performs all operations it is still ``True`` and so will be\n      the ``already_configured`` flag (example below)\n    - comment (str): a message for the user\n    - already_configured (bool): flag to check if there were no changes applied\n    - loaded_config (str): the configuration loaded on the device, after\n      rendering the template. Requires ``debug`` to be set as ``True``\n    - diff (str): returns the config changes applied\n\n    The template can use variables from the ``grains``, ``pillar`` or ``opts``, for example:\n\n    .. code-block:: jinja\n\n        {% set router_model = grains.get('model') -%}\n        {% set router_vendor = grains.get('vendor') -%}\n        {% set os_version = grains.get('version') -%}\n        {% set hostname = pillar.get('proxy', {}).get('host') -%}\n        {% if router_vendor|lower == 'juniper' %}\n        system {\n            host-name {{hostname}};\n        }\n        {% elif router_vendor|lower == 'cisco' %}\n        hostname {{hostname}}\n        {% endif %}\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' net.load_template set_ntp_peers peers=[192.168.0.1]  # uses NAPALM default templates\n\n        # inline template:\n        salt -G 'os:junos' net.load_template template_source='system { host-name {{host_name}}; }'         host_name='MX480.lab'\n\n        # inline template using grains info:\n        salt -G 'os:junos' net.load_template         template_source='system { host-name {{grains.model}}.lab; }'\n        # if the device is a MX480, the command above will set the hostname as: MX480.lab\n\n        # inline template using pillar data:\n        salt -G 'os:junos' net.load_template template_source='system { host-name {{pillar.proxy.host}}; }'\n\n        salt '*' net.load_template https://bit.ly/2OhSgqP hostname=example  # will commit\n        salt '*' net.load_template https://bit.ly/2OhSgqP hostname=example test=True  # dry run\n\n        salt '*' net.load_template salt://templates/example.jinja debug=True  # Using the salt:// URI\n\n        # render a mako template:\n        salt '*' net.load_template salt://templates/example.mako template_engine=mako debug=True\n\n        # render remote template\n        salt -G 'os:junos' net.load_template http://bit.ly/2fReJg7 test=True debug=True peers=['192.168.0.1']\n        salt -G 'os:ios' net.load_template http://bit.ly/2gKOj20 test=True debug=True peers=['192.168.0.1']\n\n        # render multiple templates at once\n        salt '*' net.load_template \"['https://bit.ly/2OhSgqP', 'salt://templates/example.jinja']\" context=\"{'hostname': 'example'}\"\n\n    Example output:\n\n    .. code-block:: python\n\n        {\n            'comment': '',\n            'already_configured': False,\n            'result': True,\n            'diff': '[edit system]+  host-name edge01.bjm01',\n            'loaded_config': 'system { host-name edge01.bjm01; }''\n        }\n    \"\"\"\n    _rendered = ''\n    _loaded = {'result': True, 'comment': '', 'out': None}\n    loaded_config = None\n    if template_engine not in salt.utils.templates.TEMPLATE_REGISTRY:\n        _loaded.update({'result': False, 'comment': 'Invalid templating engine! Choose between: {tpl_eng_opts}'.format(tpl_eng_opts=', '.join(list(salt.utils.templates.TEMPLATE_REGISTRY.keys())))})\n        return _loaded\n    salt_render_prefixes = ('salt://', 'http://', 'https://', 'ftp://')\n    salt_render = False\n    file_exists = False\n    if not isinstance(template_name, (tuple, list)):\n        for salt_render_prefix in salt_render_prefixes:\n            if not salt_render:\n                salt_render = salt_render or template_name.startswith(salt_render_prefix)\n        file_exists = __salt__['file.file_exists'](template_name)\n    if context is None:\n        context = {}\n    context.update(template_vars)\n    if template_source:\n        _rendered = __salt__['file.apply_template_on_contents'](contents=template_source, template=template_engine, context=context, defaults=defaults, saltenv=saltenv)\n        if not isinstance(_rendered, str):\n            if 'result' in _rendered:\n                _loaded['result'] = _rendered['result']\n            else:\n                _loaded['result'] = False\n            if 'comment' in _rendered:\n                _loaded['comment'] = _rendered['comment']\n            else:\n                _loaded['comment'] = 'Error while rendering the template.'\n            return _loaded\n    else:\n        if not isinstance(template_name, (list, tuple)):\n            template_name = [template_name]\n        if template_hash_name and (not isinstance(template_hash_name, (list, tuple))):\n            template_hash_name = [template_hash_name]\n        elif not template_hash_name:\n            template_hash_name = [None] * len(template_name)\n        if template_hash and isinstance(template_hash, str) and (not (template_hash.startswith('salt://') or template_hash.startswith('file://'))):\n            template_hash = [template_hash]\n        elif template_hash and isinstance(template_hash, str) and (template_hash.startswith('salt://') or template_hash.startswith('file://')):\n            template_hash = [template_hash] * len(template_name)\n        elif not template_hash:\n            template_hash = [None] * len(template_name)\n        for (tpl_index, tpl_name) in enumerate(template_name):\n            tpl_hash = template_hash[tpl_index]\n            tpl_hash_name = template_hash_name[tpl_index]\n            _rand_filename = __salt__['random.hash'](tpl_name, 'md5')\n            _temp_file = __salt__['file.join']('/tmp', _rand_filename)\n            _managed = __salt__['file.get_managed'](name=_temp_file, source=tpl_name, source_hash=tpl_hash, source_hash_name=tpl_hash_name, user=None, group=None, mode=None, attrs=None, template=template_engine, context=context, defaults=defaults, saltenv=saltenv, skip_verify=skip_verify)\n            if not isinstance(_managed, (list, tuple)) and isinstance(_managed, str):\n                _loaded['comment'] += _managed\n                _loaded['result'] = False\n            elif isinstance(_managed, (list, tuple)) and (not len(_managed) > 0):\n                _loaded['result'] = False\n                _loaded['comment'] += 'Error while rendering the template.'\n            elif isinstance(_managed, (list, tuple)) and (not len(_managed[0]) > 0):\n                _loaded['result'] = False\n                _loaded['comment'] += _managed[-1]\n            if _loaded['result']:\n                _temp_tpl_file = _managed[0]\n                _temp_tpl_file_exists = __salt__['file.file_exists'](_temp_tpl_file)\n                if not _temp_tpl_file_exists:\n                    _loaded['result'] = False\n                    _loaded['comment'] += 'Error while rendering the template.'\n                    return _loaded\n                _rendered += __salt__['file.read'](_temp_tpl_file)\n                __salt__['file.remove'](_temp_tpl_file)\n            else:\n                return _loaded\n    loaded_config = _rendered\n    if _loaded['result']:\n        fun = 'load_merge_candidate'\n        if replace:\n            fun = 'load_replace_candidate'\n        if salt.utils.napalm.not_always_alive(__opts__):\n            napalm_device['CLOSE'] = False\n        _loaded = salt.utils.napalm.call(napalm_device, fun, **{'config': _rendered})\n    return _config_logic(napalm_device, _loaded, test=test, debug=debug, replace=replace, commit_config=commit, loaded_config=loaded_config, commit_at=commit_at, commit_in=commit_in, revert_in=revert_in, revert_at=revert_at, **template_vars)",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef load_template(template_name=None, template_source=None, context=None, defaults=None, template_engine='jinja', saltenv='base', template_hash=None, template_hash_name=None, skip_verify=False, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, inherit_napalm_device=None, **template_vars):\n    if False:\n        i = 10\n    '\\n    Renders a configuration template (default: Jinja) and loads the result on the device.\\n\\n    By default this function will commit the changes. If there are no changes,\\n    it does not commit, discards he config and the flag ``already_configured``\\n    will be set as ``True`` to point this out.\\n\\n    To avoid committing the configuration, set the argument ``test`` to ``True``\\n    and will discard (dry run).\\n\\n    To preserve the changes, set ``commit`` to ``False``.\\n    However, this is recommended to be used only in exceptional cases\\n    when there are applied few consecutive states\\n    and/or configuration changes.\\n    Otherwise the user might forget that the config DB is locked\\n    and the candidate config buffer is not cleared/merged in the running config.\\n\\n    To replace the config, set ``replace`` to ``True``.\\n\\n    template_name\\n        Identifies path to the template source.\\n        The template can be either stored on the local machine, either remotely.\\n        The recommended location is under the ``file_roots``\\n        as specified in the master config file.\\n        For example, let\\'s suppose the ``file_roots`` is configured as:\\n\\n        .. code-block:: yaml\\n\\n            file_roots:\\n              base:\\n                - /etc/salt/states\\n\\n        Placing the template under ``/etc/salt/states/templates/example.jinja``,\\n        it can be used as ``salt://templates/example.jinja``.\\n        Alternatively, for local files, the user can specify the absolute path.\\n        If remotely, the source can be retrieved via ``http``, ``https`` or ``ftp``.\\n\\n        Examples:\\n\\n        - ``salt://my_template.jinja``\\n        - ``/absolute/path/to/my_template.jinja``\\n        - ``http://example.com/template.cheetah``\\n        - ``https:/example.com/template.mako``\\n        - ``ftp://example.com/template.py``\\n\\n        .. versionchanged:: 2019.2.0\\n            This argument can now support a list of templates to be rendered.\\n            The resulting configuration text is loaded at once, as a single\\n            configuration chunk.\\n\\n    template_source: None\\n        Inline config template to be rendered and loaded on the device.\\n\\n    template_hash: None\\n        Hash of the template file. Format: ``{hash_type: \\'md5\\', \\'hsum\\': <md5sum>}``\\n\\n        .. versionadded:: 2016.11.2\\n\\n    context: None\\n        Overrides default context variables passed to the template.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    template_hash_name: None\\n        When ``template_hash`` refers to a remote file,\\n        this specifies the filename to look for in that file.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    saltenv: ``base``\\n        Specifies the template environment.\\n        This will influence the relative imports inside the templates.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    template_engine: jinja\\n        The following templates engines are supported:\\n\\n        - :mod:`cheetah<salt.renderers.cheetah>`\\n        - :mod:`genshi<salt.renderers.genshi>`\\n        - :mod:`jinja<salt.renderers.jinja>`\\n        - :mod:`mako<salt.renderers.mako>`\\n        - :mod:`py<salt.renderers.py>`\\n        - :mod:`wempy<salt.renderers.wempy>`\\n\\n        .. versionadded:: 2016.11.2\\n\\n    skip_verify: True\\n        If ``True``, hash verification of remote file sources\\n        (``http://``, ``https://``, ``ftp://``) will be skipped,\\n        and the ``source_hash`` argument will be ignored.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    test: False\\n        Dry run? If set to ``True``, will apply the config,\\n        discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: True\\n        Commit? (default: ``True``)\\n\\n    debug: False\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw result after the template was rendered.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    replace: False\\n        Load and replace the configuration.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    commit_in: ``None``\\n        Commit the changes in a specific number of minutes / hours. Example of\\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    commit_at: ``None``\\n        Commit the changes at a specific time. Example of accepted formats:\\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\\n        commit at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_in: ``None``\\n        Commit and revert the changes in a specific number of minutes / hours.\\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_at: ``None``\\n        Commit and revert the changes at a specific time. Example of accepted\\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    defaults: None\\n        Default variables/context passed to the template.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    template_vars\\n        Dictionary with the arguments/context to be used when the template is rendered.\\n\\n        .. note::\\n            Do not explicitly specify this argument. This represents any other\\n            variable that will be sent to the template rendering system.\\n            Please see the examples below!\\n\\n        .. note::\\n            It is more recommended to use the ``context`` argument to avoid\\n            conflicts between CLI arguments and template variables.\\n\\n    :return: a dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is ``False``\\n      only in case of failure. In case there are no changes to be applied and\\n      successfully performs all operations it is still ``True`` and so will be\\n      the ``already_configured`` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - loaded_config (str): the configuration loaded on the device, after\\n      rendering the template. Requires ``debug`` to be set as ``True``\\n    - diff (str): returns the config changes applied\\n\\n    The template can use variables from the ``grains``, ``pillar`` or ``opts``, for example:\\n\\n    .. code-block:: jinja\\n\\n        {% set router_model = grains.get(\\'model\\') -%}\\n        {% set router_vendor = grains.get(\\'vendor\\') -%}\\n        {% set os_version = grains.get(\\'version\\') -%}\\n        {% set hostname = pillar.get(\\'proxy\\', {}).get(\\'host\\') -%}\\n        {% if router_vendor|lower == \\'juniper\\' %}\\n        system {\\n            host-name {{hostname}};\\n        }\\n        {% elif router_vendor|lower == \\'cisco\\' %}\\n        hostname {{hostname}}\\n        {% endif %}\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.load_template set_ntp_peers peers=[192.168.0.1]  # uses NAPALM default templates\\n\\n        # inline template:\\n        salt -G \\'os:junos\\' net.load_template template_source=\\'system { host-name {{host_name}}; }\\'         host_name=\\'MX480.lab\\'\\n\\n        # inline template using grains info:\\n        salt -G \\'os:junos\\' net.load_template         template_source=\\'system { host-name {{grains.model}}.lab; }\\'\\n        # if the device is a MX480, the command above will set the hostname as: MX480.lab\\n\\n        # inline template using pillar data:\\n        salt -G \\'os:junos\\' net.load_template template_source=\\'system { host-name {{pillar.proxy.host}}; }\\'\\n\\n        salt \\'*\\' net.load_template https://bit.ly/2OhSgqP hostname=example  # will commit\\n        salt \\'*\\' net.load_template https://bit.ly/2OhSgqP hostname=example test=True  # dry run\\n\\n        salt \\'*\\' net.load_template salt://templates/example.jinja debug=True  # Using the salt:// URI\\n\\n        # render a mako template:\\n        salt \\'*\\' net.load_template salt://templates/example.mako template_engine=mako debug=True\\n\\n        # render remote template\\n        salt -G \\'os:junos\\' net.load_template http://bit.ly/2fReJg7 test=True debug=True peers=[\\'192.168.0.1\\']\\n        salt -G \\'os:ios\\' net.load_template http://bit.ly/2gKOj20 test=True debug=True peers=[\\'192.168.0.1\\']\\n\\n        # render multiple templates at once\\n        salt \\'*\\' net.load_template \"[\\'https://bit.ly/2OhSgqP\\', \\'salt://templates/example.jinja\\']\" context=\"{\\'hostname\\': \\'example\\'}\"\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'comment\\': \\'\\',\\n            \\'already_configured\\': False,\\n            \\'result\\': True,\\n            \\'diff\\': \\'[edit system]+  host-name edge01.bjm01\\',\\n            \\'loaded_config\\': \\'system { host-name edge01.bjm01; }\\'\\'\\n        }\\n    '\n    _rendered = ''\n    _loaded = {'result': True, 'comment': '', 'out': None}\n    loaded_config = None\n    if template_engine not in salt.utils.templates.TEMPLATE_REGISTRY:\n        _loaded.update({'result': False, 'comment': 'Invalid templating engine! Choose between: {tpl_eng_opts}'.format(tpl_eng_opts=', '.join(list(salt.utils.templates.TEMPLATE_REGISTRY.keys())))})\n        return _loaded\n    salt_render_prefixes = ('salt://', 'http://', 'https://', 'ftp://')\n    salt_render = False\n    file_exists = False\n    if not isinstance(template_name, (tuple, list)):\n        for salt_render_prefix in salt_render_prefixes:\n            if not salt_render:\n                salt_render = salt_render or template_name.startswith(salt_render_prefix)\n        file_exists = __salt__['file.file_exists'](template_name)\n    if context is None:\n        context = {}\n    context.update(template_vars)\n    if template_source:\n        _rendered = __salt__['file.apply_template_on_contents'](contents=template_source, template=template_engine, context=context, defaults=defaults, saltenv=saltenv)\n        if not isinstance(_rendered, str):\n            if 'result' in _rendered:\n                _loaded['result'] = _rendered['result']\n            else:\n                _loaded['result'] = False\n            if 'comment' in _rendered:\n                _loaded['comment'] = _rendered['comment']\n            else:\n                _loaded['comment'] = 'Error while rendering the template.'\n            return _loaded\n    else:\n        if not isinstance(template_name, (list, tuple)):\n            template_name = [template_name]\n        if template_hash_name and (not isinstance(template_hash_name, (list, tuple))):\n            template_hash_name = [template_hash_name]\n        elif not template_hash_name:\n            template_hash_name = [None] * len(template_name)\n        if template_hash and isinstance(template_hash, str) and (not (template_hash.startswith('salt://') or template_hash.startswith('file://'))):\n            template_hash = [template_hash]\n        elif template_hash and isinstance(template_hash, str) and (template_hash.startswith('salt://') or template_hash.startswith('file://')):\n            template_hash = [template_hash] * len(template_name)\n        elif not template_hash:\n            template_hash = [None] * len(template_name)\n        for (tpl_index, tpl_name) in enumerate(template_name):\n            tpl_hash = template_hash[tpl_index]\n            tpl_hash_name = template_hash_name[tpl_index]\n            _rand_filename = __salt__['random.hash'](tpl_name, 'md5')\n            _temp_file = __salt__['file.join']('/tmp', _rand_filename)\n            _managed = __salt__['file.get_managed'](name=_temp_file, source=tpl_name, source_hash=tpl_hash, source_hash_name=tpl_hash_name, user=None, group=None, mode=None, attrs=None, template=template_engine, context=context, defaults=defaults, saltenv=saltenv, skip_verify=skip_verify)\n            if not isinstance(_managed, (list, tuple)) and isinstance(_managed, str):\n                _loaded['comment'] += _managed\n                _loaded['result'] = False\n            elif isinstance(_managed, (list, tuple)) and (not len(_managed) > 0):\n                _loaded['result'] = False\n                _loaded['comment'] += 'Error while rendering the template.'\n            elif isinstance(_managed, (list, tuple)) and (not len(_managed[0]) > 0):\n                _loaded['result'] = False\n                _loaded['comment'] += _managed[-1]\n            if _loaded['result']:\n                _temp_tpl_file = _managed[0]\n                _temp_tpl_file_exists = __salt__['file.file_exists'](_temp_tpl_file)\n                if not _temp_tpl_file_exists:\n                    _loaded['result'] = False\n                    _loaded['comment'] += 'Error while rendering the template.'\n                    return _loaded\n                _rendered += __salt__['file.read'](_temp_tpl_file)\n                __salt__['file.remove'](_temp_tpl_file)\n            else:\n                return _loaded\n    loaded_config = _rendered\n    if _loaded['result']:\n        fun = 'load_merge_candidate'\n        if replace:\n            fun = 'load_replace_candidate'\n        if salt.utils.napalm.not_always_alive(__opts__):\n            napalm_device['CLOSE'] = False\n        _loaded = salt.utils.napalm.call(napalm_device, fun, **{'config': _rendered})\n    return _config_logic(napalm_device, _loaded, test=test, debug=debug, replace=replace, commit_config=commit, loaded_config=loaded_config, commit_at=commit_at, commit_in=commit_in, revert_in=revert_in, revert_at=revert_at, **template_vars)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef load_template(template_name=None, template_source=None, context=None, defaults=None, template_engine='jinja', saltenv='base', template_hash=None, template_hash_name=None, skip_verify=False, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, inherit_napalm_device=None, **template_vars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Renders a configuration template (default: Jinja) and loads the result on the device.\\n\\n    By default this function will commit the changes. If there are no changes,\\n    it does not commit, discards he config and the flag ``already_configured``\\n    will be set as ``True`` to point this out.\\n\\n    To avoid committing the configuration, set the argument ``test`` to ``True``\\n    and will discard (dry run).\\n\\n    To preserve the changes, set ``commit`` to ``False``.\\n    However, this is recommended to be used only in exceptional cases\\n    when there are applied few consecutive states\\n    and/or configuration changes.\\n    Otherwise the user might forget that the config DB is locked\\n    and the candidate config buffer is not cleared/merged in the running config.\\n\\n    To replace the config, set ``replace`` to ``True``.\\n\\n    template_name\\n        Identifies path to the template source.\\n        The template can be either stored on the local machine, either remotely.\\n        The recommended location is under the ``file_roots``\\n        as specified in the master config file.\\n        For example, let\\'s suppose the ``file_roots`` is configured as:\\n\\n        .. code-block:: yaml\\n\\n            file_roots:\\n              base:\\n                - /etc/salt/states\\n\\n        Placing the template under ``/etc/salt/states/templates/example.jinja``,\\n        it can be used as ``salt://templates/example.jinja``.\\n        Alternatively, for local files, the user can specify the absolute path.\\n        If remotely, the source can be retrieved via ``http``, ``https`` or ``ftp``.\\n\\n        Examples:\\n\\n        - ``salt://my_template.jinja``\\n        - ``/absolute/path/to/my_template.jinja``\\n        - ``http://example.com/template.cheetah``\\n        - ``https:/example.com/template.mako``\\n        - ``ftp://example.com/template.py``\\n\\n        .. versionchanged:: 2019.2.0\\n            This argument can now support a list of templates to be rendered.\\n            The resulting configuration text is loaded at once, as a single\\n            configuration chunk.\\n\\n    template_source: None\\n        Inline config template to be rendered and loaded on the device.\\n\\n    template_hash: None\\n        Hash of the template file. Format: ``{hash_type: \\'md5\\', \\'hsum\\': <md5sum>}``\\n\\n        .. versionadded:: 2016.11.2\\n\\n    context: None\\n        Overrides default context variables passed to the template.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    template_hash_name: None\\n        When ``template_hash`` refers to a remote file,\\n        this specifies the filename to look for in that file.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    saltenv: ``base``\\n        Specifies the template environment.\\n        This will influence the relative imports inside the templates.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    template_engine: jinja\\n        The following templates engines are supported:\\n\\n        - :mod:`cheetah<salt.renderers.cheetah>`\\n        - :mod:`genshi<salt.renderers.genshi>`\\n        - :mod:`jinja<salt.renderers.jinja>`\\n        - :mod:`mako<salt.renderers.mako>`\\n        - :mod:`py<salt.renderers.py>`\\n        - :mod:`wempy<salt.renderers.wempy>`\\n\\n        .. versionadded:: 2016.11.2\\n\\n    skip_verify: True\\n        If ``True``, hash verification of remote file sources\\n        (``http://``, ``https://``, ``ftp://``) will be skipped,\\n        and the ``source_hash`` argument will be ignored.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    test: False\\n        Dry run? If set to ``True``, will apply the config,\\n        discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: True\\n        Commit? (default: ``True``)\\n\\n    debug: False\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw result after the template was rendered.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    replace: False\\n        Load and replace the configuration.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    commit_in: ``None``\\n        Commit the changes in a specific number of minutes / hours. Example of\\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    commit_at: ``None``\\n        Commit the changes at a specific time. Example of accepted formats:\\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\\n        commit at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_in: ``None``\\n        Commit and revert the changes in a specific number of minutes / hours.\\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_at: ``None``\\n        Commit and revert the changes at a specific time. Example of accepted\\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    defaults: None\\n        Default variables/context passed to the template.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    template_vars\\n        Dictionary with the arguments/context to be used when the template is rendered.\\n\\n        .. note::\\n            Do not explicitly specify this argument. This represents any other\\n            variable that will be sent to the template rendering system.\\n            Please see the examples below!\\n\\n        .. note::\\n            It is more recommended to use the ``context`` argument to avoid\\n            conflicts between CLI arguments and template variables.\\n\\n    :return: a dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is ``False``\\n      only in case of failure. In case there are no changes to be applied and\\n      successfully performs all operations it is still ``True`` and so will be\\n      the ``already_configured`` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - loaded_config (str): the configuration loaded on the device, after\\n      rendering the template. Requires ``debug`` to be set as ``True``\\n    - diff (str): returns the config changes applied\\n\\n    The template can use variables from the ``grains``, ``pillar`` or ``opts``, for example:\\n\\n    .. code-block:: jinja\\n\\n        {% set router_model = grains.get(\\'model\\') -%}\\n        {% set router_vendor = grains.get(\\'vendor\\') -%}\\n        {% set os_version = grains.get(\\'version\\') -%}\\n        {% set hostname = pillar.get(\\'proxy\\', {}).get(\\'host\\') -%}\\n        {% if router_vendor|lower == \\'juniper\\' %}\\n        system {\\n            host-name {{hostname}};\\n        }\\n        {% elif router_vendor|lower == \\'cisco\\' %}\\n        hostname {{hostname}}\\n        {% endif %}\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.load_template set_ntp_peers peers=[192.168.0.1]  # uses NAPALM default templates\\n\\n        # inline template:\\n        salt -G \\'os:junos\\' net.load_template template_source=\\'system { host-name {{host_name}}; }\\'         host_name=\\'MX480.lab\\'\\n\\n        # inline template using grains info:\\n        salt -G \\'os:junos\\' net.load_template         template_source=\\'system { host-name {{grains.model}}.lab; }\\'\\n        # if the device is a MX480, the command above will set the hostname as: MX480.lab\\n\\n        # inline template using pillar data:\\n        salt -G \\'os:junos\\' net.load_template template_source=\\'system { host-name {{pillar.proxy.host}}; }\\'\\n\\n        salt \\'*\\' net.load_template https://bit.ly/2OhSgqP hostname=example  # will commit\\n        salt \\'*\\' net.load_template https://bit.ly/2OhSgqP hostname=example test=True  # dry run\\n\\n        salt \\'*\\' net.load_template salt://templates/example.jinja debug=True  # Using the salt:// URI\\n\\n        # render a mako template:\\n        salt \\'*\\' net.load_template salt://templates/example.mako template_engine=mako debug=True\\n\\n        # render remote template\\n        salt -G \\'os:junos\\' net.load_template http://bit.ly/2fReJg7 test=True debug=True peers=[\\'192.168.0.1\\']\\n        salt -G \\'os:ios\\' net.load_template http://bit.ly/2gKOj20 test=True debug=True peers=[\\'192.168.0.1\\']\\n\\n        # render multiple templates at once\\n        salt \\'*\\' net.load_template \"[\\'https://bit.ly/2OhSgqP\\', \\'salt://templates/example.jinja\\']\" context=\"{\\'hostname\\': \\'example\\'}\"\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'comment\\': \\'\\',\\n            \\'already_configured\\': False,\\n            \\'result\\': True,\\n            \\'diff\\': \\'[edit system]+  host-name edge01.bjm01\\',\\n            \\'loaded_config\\': \\'system { host-name edge01.bjm01; }\\'\\'\\n        }\\n    '\n    _rendered = ''\n    _loaded = {'result': True, 'comment': '', 'out': None}\n    loaded_config = None\n    if template_engine not in salt.utils.templates.TEMPLATE_REGISTRY:\n        _loaded.update({'result': False, 'comment': 'Invalid templating engine! Choose between: {tpl_eng_opts}'.format(tpl_eng_opts=', '.join(list(salt.utils.templates.TEMPLATE_REGISTRY.keys())))})\n        return _loaded\n    salt_render_prefixes = ('salt://', 'http://', 'https://', 'ftp://')\n    salt_render = False\n    file_exists = False\n    if not isinstance(template_name, (tuple, list)):\n        for salt_render_prefix in salt_render_prefixes:\n            if not salt_render:\n                salt_render = salt_render or template_name.startswith(salt_render_prefix)\n        file_exists = __salt__['file.file_exists'](template_name)\n    if context is None:\n        context = {}\n    context.update(template_vars)\n    if template_source:\n        _rendered = __salt__['file.apply_template_on_contents'](contents=template_source, template=template_engine, context=context, defaults=defaults, saltenv=saltenv)\n        if not isinstance(_rendered, str):\n            if 'result' in _rendered:\n                _loaded['result'] = _rendered['result']\n            else:\n                _loaded['result'] = False\n            if 'comment' in _rendered:\n                _loaded['comment'] = _rendered['comment']\n            else:\n                _loaded['comment'] = 'Error while rendering the template.'\n            return _loaded\n    else:\n        if not isinstance(template_name, (list, tuple)):\n            template_name = [template_name]\n        if template_hash_name and (not isinstance(template_hash_name, (list, tuple))):\n            template_hash_name = [template_hash_name]\n        elif not template_hash_name:\n            template_hash_name = [None] * len(template_name)\n        if template_hash and isinstance(template_hash, str) and (not (template_hash.startswith('salt://') or template_hash.startswith('file://'))):\n            template_hash = [template_hash]\n        elif template_hash and isinstance(template_hash, str) and (template_hash.startswith('salt://') or template_hash.startswith('file://')):\n            template_hash = [template_hash] * len(template_name)\n        elif not template_hash:\n            template_hash = [None] * len(template_name)\n        for (tpl_index, tpl_name) in enumerate(template_name):\n            tpl_hash = template_hash[tpl_index]\n            tpl_hash_name = template_hash_name[tpl_index]\n            _rand_filename = __salt__['random.hash'](tpl_name, 'md5')\n            _temp_file = __salt__['file.join']('/tmp', _rand_filename)\n            _managed = __salt__['file.get_managed'](name=_temp_file, source=tpl_name, source_hash=tpl_hash, source_hash_name=tpl_hash_name, user=None, group=None, mode=None, attrs=None, template=template_engine, context=context, defaults=defaults, saltenv=saltenv, skip_verify=skip_verify)\n            if not isinstance(_managed, (list, tuple)) and isinstance(_managed, str):\n                _loaded['comment'] += _managed\n                _loaded['result'] = False\n            elif isinstance(_managed, (list, tuple)) and (not len(_managed) > 0):\n                _loaded['result'] = False\n                _loaded['comment'] += 'Error while rendering the template.'\n            elif isinstance(_managed, (list, tuple)) and (not len(_managed[0]) > 0):\n                _loaded['result'] = False\n                _loaded['comment'] += _managed[-1]\n            if _loaded['result']:\n                _temp_tpl_file = _managed[0]\n                _temp_tpl_file_exists = __salt__['file.file_exists'](_temp_tpl_file)\n                if not _temp_tpl_file_exists:\n                    _loaded['result'] = False\n                    _loaded['comment'] += 'Error while rendering the template.'\n                    return _loaded\n                _rendered += __salt__['file.read'](_temp_tpl_file)\n                __salt__['file.remove'](_temp_tpl_file)\n            else:\n                return _loaded\n    loaded_config = _rendered\n    if _loaded['result']:\n        fun = 'load_merge_candidate'\n        if replace:\n            fun = 'load_replace_candidate'\n        if salt.utils.napalm.not_always_alive(__opts__):\n            napalm_device['CLOSE'] = False\n        _loaded = salt.utils.napalm.call(napalm_device, fun, **{'config': _rendered})\n    return _config_logic(napalm_device, _loaded, test=test, debug=debug, replace=replace, commit_config=commit, loaded_config=loaded_config, commit_at=commit_at, commit_in=commit_in, revert_in=revert_in, revert_at=revert_at, **template_vars)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef load_template(template_name=None, template_source=None, context=None, defaults=None, template_engine='jinja', saltenv='base', template_hash=None, template_hash_name=None, skip_verify=False, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, inherit_napalm_device=None, **template_vars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Renders a configuration template (default: Jinja) and loads the result on the device.\\n\\n    By default this function will commit the changes. If there are no changes,\\n    it does not commit, discards he config and the flag ``already_configured``\\n    will be set as ``True`` to point this out.\\n\\n    To avoid committing the configuration, set the argument ``test`` to ``True``\\n    and will discard (dry run).\\n\\n    To preserve the changes, set ``commit`` to ``False``.\\n    However, this is recommended to be used only in exceptional cases\\n    when there are applied few consecutive states\\n    and/or configuration changes.\\n    Otherwise the user might forget that the config DB is locked\\n    and the candidate config buffer is not cleared/merged in the running config.\\n\\n    To replace the config, set ``replace`` to ``True``.\\n\\n    template_name\\n        Identifies path to the template source.\\n        The template can be either stored on the local machine, either remotely.\\n        The recommended location is under the ``file_roots``\\n        as specified in the master config file.\\n        For example, let\\'s suppose the ``file_roots`` is configured as:\\n\\n        .. code-block:: yaml\\n\\n            file_roots:\\n              base:\\n                - /etc/salt/states\\n\\n        Placing the template under ``/etc/salt/states/templates/example.jinja``,\\n        it can be used as ``salt://templates/example.jinja``.\\n        Alternatively, for local files, the user can specify the absolute path.\\n        If remotely, the source can be retrieved via ``http``, ``https`` or ``ftp``.\\n\\n        Examples:\\n\\n        - ``salt://my_template.jinja``\\n        - ``/absolute/path/to/my_template.jinja``\\n        - ``http://example.com/template.cheetah``\\n        - ``https:/example.com/template.mako``\\n        - ``ftp://example.com/template.py``\\n\\n        .. versionchanged:: 2019.2.0\\n            This argument can now support a list of templates to be rendered.\\n            The resulting configuration text is loaded at once, as a single\\n            configuration chunk.\\n\\n    template_source: None\\n        Inline config template to be rendered and loaded on the device.\\n\\n    template_hash: None\\n        Hash of the template file. Format: ``{hash_type: \\'md5\\', \\'hsum\\': <md5sum>}``\\n\\n        .. versionadded:: 2016.11.2\\n\\n    context: None\\n        Overrides default context variables passed to the template.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    template_hash_name: None\\n        When ``template_hash`` refers to a remote file,\\n        this specifies the filename to look for in that file.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    saltenv: ``base``\\n        Specifies the template environment.\\n        This will influence the relative imports inside the templates.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    template_engine: jinja\\n        The following templates engines are supported:\\n\\n        - :mod:`cheetah<salt.renderers.cheetah>`\\n        - :mod:`genshi<salt.renderers.genshi>`\\n        - :mod:`jinja<salt.renderers.jinja>`\\n        - :mod:`mako<salt.renderers.mako>`\\n        - :mod:`py<salt.renderers.py>`\\n        - :mod:`wempy<salt.renderers.wempy>`\\n\\n        .. versionadded:: 2016.11.2\\n\\n    skip_verify: True\\n        If ``True``, hash verification of remote file sources\\n        (``http://``, ``https://``, ``ftp://``) will be skipped,\\n        and the ``source_hash`` argument will be ignored.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    test: False\\n        Dry run? If set to ``True``, will apply the config,\\n        discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: True\\n        Commit? (default: ``True``)\\n\\n    debug: False\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw result after the template was rendered.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    replace: False\\n        Load and replace the configuration.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    commit_in: ``None``\\n        Commit the changes in a specific number of minutes / hours. Example of\\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    commit_at: ``None``\\n        Commit the changes at a specific time. Example of accepted formats:\\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\\n        commit at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_in: ``None``\\n        Commit and revert the changes in a specific number of minutes / hours.\\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_at: ``None``\\n        Commit and revert the changes at a specific time. Example of accepted\\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    defaults: None\\n        Default variables/context passed to the template.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    template_vars\\n        Dictionary with the arguments/context to be used when the template is rendered.\\n\\n        .. note::\\n            Do not explicitly specify this argument. This represents any other\\n            variable that will be sent to the template rendering system.\\n            Please see the examples below!\\n\\n        .. note::\\n            It is more recommended to use the ``context`` argument to avoid\\n            conflicts between CLI arguments and template variables.\\n\\n    :return: a dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is ``False``\\n      only in case of failure. In case there are no changes to be applied and\\n      successfully performs all operations it is still ``True`` and so will be\\n      the ``already_configured`` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - loaded_config (str): the configuration loaded on the device, after\\n      rendering the template. Requires ``debug`` to be set as ``True``\\n    - diff (str): returns the config changes applied\\n\\n    The template can use variables from the ``grains``, ``pillar`` or ``opts``, for example:\\n\\n    .. code-block:: jinja\\n\\n        {% set router_model = grains.get(\\'model\\') -%}\\n        {% set router_vendor = grains.get(\\'vendor\\') -%}\\n        {% set os_version = grains.get(\\'version\\') -%}\\n        {% set hostname = pillar.get(\\'proxy\\', {}).get(\\'host\\') -%}\\n        {% if router_vendor|lower == \\'juniper\\' %}\\n        system {\\n            host-name {{hostname}};\\n        }\\n        {% elif router_vendor|lower == \\'cisco\\' %}\\n        hostname {{hostname}}\\n        {% endif %}\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.load_template set_ntp_peers peers=[192.168.0.1]  # uses NAPALM default templates\\n\\n        # inline template:\\n        salt -G \\'os:junos\\' net.load_template template_source=\\'system { host-name {{host_name}}; }\\'         host_name=\\'MX480.lab\\'\\n\\n        # inline template using grains info:\\n        salt -G \\'os:junos\\' net.load_template         template_source=\\'system { host-name {{grains.model}}.lab; }\\'\\n        # if the device is a MX480, the command above will set the hostname as: MX480.lab\\n\\n        # inline template using pillar data:\\n        salt -G \\'os:junos\\' net.load_template template_source=\\'system { host-name {{pillar.proxy.host}}; }\\'\\n\\n        salt \\'*\\' net.load_template https://bit.ly/2OhSgqP hostname=example  # will commit\\n        salt \\'*\\' net.load_template https://bit.ly/2OhSgqP hostname=example test=True  # dry run\\n\\n        salt \\'*\\' net.load_template salt://templates/example.jinja debug=True  # Using the salt:// URI\\n\\n        # render a mako template:\\n        salt \\'*\\' net.load_template salt://templates/example.mako template_engine=mako debug=True\\n\\n        # render remote template\\n        salt -G \\'os:junos\\' net.load_template http://bit.ly/2fReJg7 test=True debug=True peers=[\\'192.168.0.1\\']\\n        salt -G \\'os:ios\\' net.load_template http://bit.ly/2gKOj20 test=True debug=True peers=[\\'192.168.0.1\\']\\n\\n        # render multiple templates at once\\n        salt \\'*\\' net.load_template \"[\\'https://bit.ly/2OhSgqP\\', \\'salt://templates/example.jinja\\']\" context=\"{\\'hostname\\': \\'example\\'}\"\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'comment\\': \\'\\',\\n            \\'already_configured\\': False,\\n            \\'result\\': True,\\n            \\'diff\\': \\'[edit system]+  host-name edge01.bjm01\\',\\n            \\'loaded_config\\': \\'system { host-name edge01.bjm01; }\\'\\'\\n        }\\n    '\n    _rendered = ''\n    _loaded = {'result': True, 'comment': '', 'out': None}\n    loaded_config = None\n    if template_engine not in salt.utils.templates.TEMPLATE_REGISTRY:\n        _loaded.update({'result': False, 'comment': 'Invalid templating engine! Choose between: {tpl_eng_opts}'.format(tpl_eng_opts=', '.join(list(salt.utils.templates.TEMPLATE_REGISTRY.keys())))})\n        return _loaded\n    salt_render_prefixes = ('salt://', 'http://', 'https://', 'ftp://')\n    salt_render = False\n    file_exists = False\n    if not isinstance(template_name, (tuple, list)):\n        for salt_render_prefix in salt_render_prefixes:\n            if not salt_render:\n                salt_render = salt_render or template_name.startswith(salt_render_prefix)\n        file_exists = __salt__['file.file_exists'](template_name)\n    if context is None:\n        context = {}\n    context.update(template_vars)\n    if template_source:\n        _rendered = __salt__['file.apply_template_on_contents'](contents=template_source, template=template_engine, context=context, defaults=defaults, saltenv=saltenv)\n        if not isinstance(_rendered, str):\n            if 'result' in _rendered:\n                _loaded['result'] = _rendered['result']\n            else:\n                _loaded['result'] = False\n            if 'comment' in _rendered:\n                _loaded['comment'] = _rendered['comment']\n            else:\n                _loaded['comment'] = 'Error while rendering the template.'\n            return _loaded\n    else:\n        if not isinstance(template_name, (list, tuple)):\n            template_name = [template_name]\n        if template_hash_name and (not isinstance(template_hash_name, (list, tuple))):\n            template_hash_name = [template_hash_name]\n        elif not template_hash_name:\n            template_hash_name = [None] * len(template_name)\n        if template_hash and isinstance(template_hash, str) and (not (template_hash.startswith('salt://') or template_hash.startswith('file://'))):\n            template_hash = [template_hash]\n        elif template_hash and isinstance(template_hash, str) and (template_hash.startswith('salt://') or template_hash.startswith('file://')):\n            template_hash = [template_hash] * len(template_name)\n        elif not template_hash:\n            template_hash = [None] * len(template_name)\n        for (tpl_index, tpl_name) in enumerate(template_name):\n            tpl_hash = template_hash[tpl_index]\n            tpl_hash_name = template_hash_name[tpl_index]\n            _rand_filename = __salt__['random.hash'](tpl_name, 'md5')\n            _temp_file = __salt__['file.join']('/tmp', _rand_filename)\n            _managed = __salt__['file.get_managed'](name=_temp_file, source=tpl_name, source_hash=tpl_hash, source_hash_name=tpl_hash_name, user=None, group=None, mode=None, attrs=None, template=template_engine, context=context, defaults=defaults, saltenv=saltenv, skip_verify=skip_verify)\n            if not isinstance(_managed, (list, tuple)) and isinstance(_managed, str):\n                _loaded['comment'] += _managed\n                _loaded['result'] = False\n            elif isinstance(_managed, (list, tuple)) and (not len(_managed) > 0):\n                _loaded['result'] = False\n                _loaded['comment'] += 'Error while rendering the template.'\n            elif isinstance(_managed, (list, tuple)) and (not len(_managed[0]) > 0):\n                _loaded['result'] = False\n                _loaded['comment'] += _managed[-1]\n            if _loaded['result']:\n                _temp_tpl_file = _managed[0]\n                _temp_tpl_file_exists = __salt__['file.file_exists'](_temp_tpl_file)\n                if not _temp_tpl_file_exists:\n                    _loaded['result'] = False\n                    _loaded['comment'] += 'Error while rendering the template.'\n                    return _loaded\n                _rendered += __salt__['file.read'](_temp_tpl_file)\n                __salt__['file.remove'](_temp_tpl_file)\n            else:\n                return _loaded\n    loaded_config = _rendered\n    if _loaded['result']:\n        fun = 'load_merge_candidate'\n        if replace:\n            fun = 'load_replace_candidate'\n        if salt.utils.napalm.not_always_alive(__opts__):\n            napalm_device['CLOSE'] = False\n        _loaded = salt.utils.napalm.call(napalm_device, fun, **{'config': _rendered})\n    return _config_logic(napalm_device, _loaded, test=test, debug=debug, replace=replace, commit_config=commit, loaded_config=loaded_config, commit_at=commit_at, commit_in=commit_in, revert_in=revert_in, revert_at=revert_at, **template_vars)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef load_template(template_name=None, template_source=None, context=None, defaults=None, template_engine='jinja', saltenv='base', template_hash=None, template_hash_name=None, skip_verify=False, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, inherit_napalm_device=None, **template_vars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Renders a configuration template (default: Jinja) and loads the result on the device.\\n\\n    By default this function will commit the changes. If there are no changes,\\n    it does not commit, discards he config and the flag ``already_configured``\\n    will be set as ``True`` to point this out.\\n\\n    To avoid committing the configuration, set the argument ``test`` to ``True``\\n    and will discard (dry run).\\n\\n    To preserve the changes, set ``commit`` to ``False``.\\n    However, this is recommended to be used only in exceptional cases\\n    when there are applied few consecutive states\\n    and/or configuration changes.\\n    Otherwise the user might forget that the config DB is locked\\n    and the candidate config buffer is not cleared/merged in the running config.\\n\\n    To replace the config, set ``replace`` to ``True``.\\n\\n    template_name\\n        Identifies path to the template source.\\n        The template can be either stored on the local machine, either remotely.\\n        The recommended location is under the ``file_roots``\\n        as specified in the master config file.\\n        For example, let\\'s suppose the ``file_roots`` is configured as:\\n\\n        .. code-block:: yaml\\n\\n            file_roots:\\n              base:\\n                - /etc/salt/states\\n\\n        Placing the template under ``/etc/salt/states/templates/example.jinja``,\\n        it can be used as ``salt://templates/example.jinja``.\\n        Alternatively, for local files, the user can specify the absolute path.\\n        If remotely, the source can be retrieved via ``http``, ``https`` or ``ftp``.\\n\\n        Examples:\\n\\n        - ``salt://my_template.jinja``\\n        - ``/absolute/path/to/my_template.jinja``\\n        - ``http://example.com/template.cheetah``\\n        - ``https:/example.com/template.mako``\\n        - ``ftp://example.com/template.py``\\n\\n        .. versionchanged:: 2019.2.0\\n            This argument can now support a list of templates to be rendered.\\n            The resulting configuration text is loaded at once, as a single\\n            configuration chunk.\\n\\n    template_source: None\\n        Inline config template to be rendered and loaded on the device.\\n\\n    template_hash: None\\n        Hash of the template file. Format: ``{hash_type: \\'md5\\', \\'hsum\\': <md5sum>}``\\n\\n        .. versionadded:: 2016.11.2\\n\\n    context: None\\n        Overrides default context variables passed to the template.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    template_hash_name: None\\n        When ``template_hash`` refers to a remote file,\\n        this specifies the filename to look for in that file.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    saltenv: ``base``\\n        Specifies the template environment.\\n        This will influence the relative imports inside the templates.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    template_engine: jinja\\n        The following templates engines are supported:\\n\\n        - :mod:`cheetah<salt.renderers.cheetah>`\\n        - :mod:`genshi<salt.renderers.genshi>`\\n        - :mod:`jinja<salt.renderers.jinja>`\\n        - :mod:`mako<salt.renderers.mako>`\\n        - :mod:`py<salt.renderers.py>`\\n        - :mod:`wempy<salt.renderers.wempy>`\\n\\n        .. versionadded:: 2016.11.2\\n\\n    skip_verify: True\\n        If ``True``, hash verification of remote file sources\\n        (``http://``, ``https://``, ``ftp://``) will be skipped,\\n        and the ``source_hash`` argument will be ignored.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    test: False\\n        Dry run? If set to ``True``, will apply the config,\\n        discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: True\\n        Commit? (default: ``True``)\\n\\n    debug: False\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw result after the template was rendered.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    replace: False\\n        Load and replace the configuration.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    commit_in: ``None``\\n        Commit the changes in a specific number of minutes / hours. Example of\\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    commit_at: ``None``\\n        Commit the changes at a specific time. Example of accepted formats:\\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\\n        commit at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_in: ``None``\\n        Commit and revert the changes in a specific number of minutes / hours.\\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_at: ``None``\\n        Commit and revert the changes at a specific time. Example of accepted\\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    defaults: None\\n        Default variables/context passed to the template.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    template_vars\\n        Dictionary with the arguments/context to be used when the template is rendered.\\n\\n        .. note::\\n            Do not explicitly specify this argument. This represents any other\\n            variable that will be sent to the template rendering system.\\n            Please see the examples below!\\n\\n        .. note::\\n            It is more recommended to use the ``context`` argument to avoid\\n            conflicts between CLI arguments and template variables.\\n\\n    :return: a dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is ``False``\\n      only in case of failure. In case there are no changes to be applied and\\n      successfully performs all operations it is still ``True`` and so will be\\n      the ``already_configured`` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - loaded_config (str): the configuration loaded on the device, after\\n      rendering the template. Requires ``debug`` to be set as ``True``\\n    - diff (str): returns the config changes applied\\n\\n    The template can use variables from the ``grains``, ``pillar`` or ``opts``, for example:\\n\\n    .. code-block:: jinja\\n\\n        {% set router_model = grains.get(\\'model\\') -%}\\n        {% set router_vendor = grains.get(\\'vendor\\') -%}\\n        {% set os_version = grains.get(\\'version\\') -%}\\n        {% set hostname = pillar.get(\\'proxy\\', {}).get(\\'host\\') -%}\\n        {% if router_vendor|lower == \\'juniper\\' %}\\n        system {\\n            host-name {{hostname}};\\n        }\\n        {% elif router_vendor|lower == \\'cisco\\' %}\\n        hostname {{hostname}}\\n        {% endif %}\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.load_template set_ntp_peers peers=[192.168.0.1]  # uses NAPALM default templates\\n\\n        # inline template:\\n        salt -G \\'os:junos\\' net.load_template template_source=\\'system { host-name {{host_name}}; }\\'         host_name=\\'MX480.lab\\'\\n\\n        # inline template using grains info:\\n        salt -G \\'os:junos\\' net.load_template         template_source=\\'system { host-name {{grains.model}}.lab; }\\'\\n        # if the device is a MX480, the command above will set the hostname as: MX480.lab\\n\\n        # inline template using pillar data:\\n        salt -G \\'os:junos\\' net.load_template template_source=\\'system { host-name {{pillar.proxy.host}}; }\\'\\n\\n        salt \\'*\\' net.load_template https://bit.ly/2OhSgqP hostname=example  # will commit\\n        salt \\'*\\' net.load_template https://bit.ly/2OhSgqP hostname=example test=True  # dry run\\n\\n        salt \\'*\\' net.load_template salt://templates/example.jinja debug=True  # Using the salt:// URI\\n\\n        # render a mako template:\\n        salt \\'*\\' net.load_template salt://templates/example.mako template_engine=mako debug=True\\n\\n        # render remote template\\n        salt -G \\'os:junos\\' net.load_template http://bit.ly/2fReJg7 test=True debug=True peers=[\\'192.168.0.1\\']\\n        salt -G \\'os:ios\\' net.load_template http://bit.ly/2gKOj20 test=True debug=True peers=[\\'192.168.0.1\\']\\n\\n        # render multiple templates at once\\n        salt \\'*\\' net.load_template \"[\\'https://bit.ly/2OhSgqP\\', \\'salt://templates/example.jinja\\']\" context=\"{\\'hostname\\': \\'example\\'}\"\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'comment\\': \\'\\',\\n            \\'already_configured\\': False,\\n            \\'result\\': True,\\n            \\'diff\\': \\'[edit system]+  host-name edge01.bjm01\\',\\n            \\'loaded_config\\': \\'system { host-name edge01.bjm01; }\\'\\'\\n        }\\n    '\n    _rendered = ''\n    _loaded = {'result': True, 'comment': '', 'out': None}\n    loaded_config = None\n    if template_engine not in salt.utils.templates.TEMPLATE_REGISTRY:\n        _loaded.update({'result': False, 'comment': 'Invalid templating engine! Choose between: {tpl_eng_opts}'.format(tpl_eng_opts=', '.join(list(salt.utils.templates.TEMPLATE_REGISTRY.keys())))})\n        return _loaded\n    salt_render_prefixes = ('salt://', 'http://', 'https://', 'ftp://')\n    salt_render = False\n    file_exists = False\n    if not isinstance(template_name, (tuple, list)):\n        for salt_render_prefix in salt_render_prefixes:\n            if not salt_render:\n                salt_render = salt_render or template_name.startswith(salt_render_prefix)\n        file_exists = __salt__['file.file_exists'](template_name)\n    if context is None:\n        context = {}\n    context.update(template_vars)\n    if template_source:\n        _rendered = __salt__['file.apply_template_on_contents'](contents=template_source, template=template_engine, context=context, defaults=defaults, saltenv=saltenv)\n        if not isinstance(_rendered, str):\n            if 'result' in _rendered:\n                _loaded['result'] = _rendered['result']\n            else:\n                _loaded['result'] = False\n            if 'comment' in _rendered:\n                _loaded['comment'] = _rendered['comment']\n            else:\n                _loaded['comment'] = 'Error while rendering the template.'\n            return _loaded\n    else:\n        if not isinstance(template_name, (list, tuple)):\n            template_name = [template_name]\n        if template_hash_name and (not isinstance(template_hash_name, (list, tuple))):\n            template_hash_name = [template_hash_name]\n        elif not template_hash_name:\n            template_hash_name = [None] * len(template_name)\n        if template_hash and isinstance(template_hash, str) and (not (template_hash.startswith('salt://') or template_hash.startswith('file://'))):\n            template_hash = [template_hash]\n        elif template_hash and isinstance(template_hash, str) and (template_hash.startswith('salt://') or template_hash.startswith('file://')):\n            template_hash = [template_hash] * len(template_name)\n        elif not template_hash:\n            template_hash = [None] * len(template_name)\n        for (tpl_index, tpl_name) in enumerate(template_name):\n            tpl_hash = template_hash[tpl_index]\n            tpl_hash_name = template_hash_name[tpl_index]\n            _rand_filename = __salt__['random.hash'](tpl_name, 'md5')\n            _temp_file = __salt__['file.join']('/tmp', _rand_filename)\n            _managed = __salt__['file.get_managed'](name=_temp_file, source=tpl_name, source_hash=tpl_hash, source_hash_name=tpl_hash_name, user=None, group=None, mode=None, attrs=None, template=template_engine, context=context, defaults=defaults, saltenv=saltenv, skip_verify=skip_verify)\n            if not isinstance(_managed, (list, tuple)) and isinstance(_managed, str):\n                _loaded['comment'] += _managed\n                _loaded['result'] = False\n            elif isinstance(_managed, (list, tuple)) and (not len(_managed) > 0):\n                _loaded['result'] = False\n                _loaded['comment'] += 'Error while rendering the template.'\n            elif isinstance(_managed, (list, tuple)) and (not len(_managed[0]) > 0):\n                _loaded['result'] = False\n                _loaded['comment'] += _managed[-1]\n            if _loaded['result']:\n                _temp_tpl_file = _managed[0]\n                _temp_tpl_file_exists = __salt__['file.file_exists'](_temp_tpl_file)\n                if not _temp_tpl_file_exists:\n                    _loaded['result'] = False\n                    _loaded['comment'] += 'Error while rendering the template.'\n                    return _loaded\n                _rendered += __salt__['file.read'](_temp_tpl_file)\n                __salt__['file.remove'](_temp_tpl_file)\n            else:\n                return _loaded\n    loaded_config = _rendered\n    if _loaded['result']:\n        fun = 'load_merge_candidate'\n        if replace:\n            fun = 'load_replace_candidate'\n        if salt.utils.napalm.not_always_alive(__opts__):\n            napalm_device['CLOSE'] = False\n        _loaded = salt.utils.napalm.call(napalm_device, fun, **{'config': _rendered})\n    return _config_logic(napalm_device, _loaded, test=test, debug=debug, replace=replace, commit_config=commit, loaded_config=loaded_config, commit_at=commit_at, commit_in=commit_in, revert_in=revert_in, revert_at=revert_at, **template_vars)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef load_template(template_name=None, template_source=None, context=None, defaults=None, template_engine='jinja', saltenv='base', template_hash=None, template_hash_name=None, skip_verify=False, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, inherit_napalm_device=None, **template_vars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Renders a configuration template (default: Jinja) and loads the result on the device.\\n\\n    By default this function will commit the changes. If there are no changes,\\n    it does not commit, discards he config and the flag ``already_configured``\\n    will be set as ``True`` to point this out.\\n\\n    To avoid committing the configuration, set the argument ``test`` to ``True``\\n    and will discard (dry run).\\n\\n    To preserve the changes, set ``commit`` to ``False``.\\n    However, this is recommended to be used only in exceptional cases\\n    when there are applied few consecutive states\\n    and/or configuration changes.\\n    Otherwise the user might forget that the config DB is locked\\n    and the candidate config buffer is not cleared/merged in the running config.\\n\\n    To replace the config, set ``replace`` to ``True``.\\n\\n    template_name\\n        Identifies path to the template source.\\n        The template can be either stored on the local machine, either remotely.\\n        The recommended location is under the ``file_roots``\\n        as specified in the master config file.\\n        For example, let\\'s suppose the ``file_roots`` is configured as:\\n\\n        .. code-block:: yaml\\n\\n            file_roots:\\n              base:\\n                - /etc/salt/states\\n\\n        Placing the template under ``/etc/salt/states/templates/example.jinja``,\\n        it can be used as ``salt://templates/example.jinja``.\\n        Alternatively, for local files, the user can specify the absolute path.\\n        If remotely, the source can be retrieved via ``http``, ``https`` or ``ftp``.\\n\\n        Examples:\\n\\n        - ``salt://my_template.jinja``\\n        - ``/absolute/path/to/my_template.jinja``\\n        - ``http://example.com/template.cheetah``\\n        - ``https:/example.com/template.mako``\\n        - ``ftp://example.com/template.py``\\n\\n        .. versionchanged:: 2019.2.0\\n            This argument can now support a list of templates to be rendered.\\n            The resulting configuration text is loaded at once, as a single\\n            configuration chunk.\\n\\n    template_source: None\\n        Inline config template to be rendered and loaded on the device.\\n\\n    template_hash: None\\n        Hash of the template file. Format: ``{hash_type: \\'md5\\', \\'hsum\\': <md5sum>}``\\n\\n        .. versionadded:: 2016.11.2\\n\\n    context: None\\n        Overrides default context variables passed to the template.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    template_hash_name: None\\n        When ``template_hash`` refers to a remote file,\\n        this specifies the filename to look for in that file.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    saltenv: ``base``\\n        Specifies the template environment.\\n        This will influence the relative imports inside the templates.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    template_engine: jinja\\n        The following templates engines are supported:\\n\\n        - :mod:`cheetah<salt.renderers.cheetah>`\\n        - :mod:`genshi<salt.renderers.genshi>`\\n        - :mod:`jinja<salt.renderers.jinja>`\\n        - :mod:`mako<salt.renderers.mako>`\\n        - :mod:`py<salt.renderers.py>`\\n        - :mod:`wempy<salt.renderers.wempy>`\\n\\n        .. versionadded:: 2016.11.2\\n\\n    skip_verify: True\\n        If ``True``, hash verification of remote file sources\\n        (``http://``, ``https://``, ``ftp://``) will be skipped,\\n        and the ``source_hash`` argument will be ignored.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    test: False\\n        Dry run? If set to ``True``, will apply the config,\\n        discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: True\\n        Commit? (default: ``True``)\\n\\n    debug: False\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw result after the template was rendered.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    replace: False\\n        Load and replace the configuration.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    commit_in: ``None``\\n        Commit the changes in a specific number of minutes / hours. Example of\\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    commit_at: ``None``\\n        Commit the changes at a specific time. Example of accepted formats:\\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\\n        commit at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_in: ``None``\\n        Commit and revert the changes in a specific number of minutes / hours.\\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_at: ``None``\\n        Commit and revert the changes at a specific time. Example of accepted\\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    defaults: None\\n        Default variables/context passed to the template.\\n\\n        .. versionadded:: 2016.11.2\\n\\n    template_vars\\n        Dictionary with the arguments/context to be used when the template is rendered.\\n\\n        .. note::\\n            Do not explicitly specify this argument. This represents any other\\n            variable that will be sent to the template rendering system.\\n            Please see the examples below!\\n\\n        .. note::\\n            It is more recommended to use the ``context`` argument to avoid\\n            conflicts between CLI arguments and template variables.\\n\\n    :return: a dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is ``False``\\n      only in case of failure. In case there are no changes to be applied and\\n      successfully performs all operations it is still ``True`` and so will be\\n      the ``already_configured`` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - loaded_config (str): the configuration loaded on the device, after\\n      rendering the template. Requires ``debug`` to be set as ``True``\\n    - diff (str): returns the config changes applied\\n\\n    The template can use variables from the ``grains``, ``pillar`` or ``opts``, for example:\\n\\n    .. code-block:: jinja\\n\\n        {% set router_model = grains.get(\\'model\\') -%}\\n        {% set router_vendor = grains.get(\\'vendor\\') -%}\\n        {% set os_version = grains.get(\\'version\\') -%}\\n        {% set hostname = pillar.get(\\'proxy\\', {}).get(\\'host\\') -%}\\n        {% if router_vendor|lower == \\'juniper\\' %}\\n        system {\\n            host-name {{hostname}};\\n        }\\n        {% elif router_vendor|lower == \\'cisco\\' %}\\n        hostname {{hostname}}\\n        {% endif %}\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.load_template set_ntp_peers peers=[192.168.0.1]  # uses NAPALM default templates\\n\\n        # inline template:\\n        salt -G \\'os:junos\\' net.load_template template_source=\\'system { host-name {{host_name}}; }\\'         host_name=\\'MX480.lab\\'\\n\\n        # inline template using grains info:\\n        salt -G \\'os:junos\\' net.load_template         template_source=\\'system { host-name {{grains.model}}.lab; }\\'\\n        # if the device is a MX480, the command above will set the hostname as: MX480.lab\\n\\n        # inline template using pillar data:\\n        salt -G \\'os:junos\\' net.load_template template_source=\\'system { host-name {{pillar.proxy.host}}; }\\'\\n\\n        salt \\'*\\' net.load_template https://bit.ly/2OhSgqP hostname=example  # will commit\\n        salt \\'*\\' net.load_template https://bit.ly/2OhSgqP hostname=example test=True  # dry run\\n\\n        salt \\'*\\' net.load_template salt://templates/example.jinja debug=True  # Using the salt:// URI\\n\\n        # render a mako template:\\n        salt \\'*\\' net.load_template salt://templates/example.mako template_engine=mako debug=True\\n\\n        # render remote template\\n        salt -G \\'os:junos\\' net.load_template http://bit.ly/2fReJg7 test=True debug=True peers=[\\'192.168.0.1\\']\\n        salt -G \\'os:ios\\' net.load_template http://bit.ly/2gKOj20 test=True debug=True peers=[\\'192.168.0.1\\']\\n\\n        # render multiple templates at once\\n        salt \\'*\\' net.load_template \"[\\'https://bit.ly/2OhSgqP\\', \\'salt://templates/example.jinja\\']\" context=\"{\\'hostname\\': \\'example\\'}\"\\n\\n    Example output:\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'comment\\': \\'\\',\\n            \\'already_configured\\': False,\\n            \\'result\\': True,\\n            \\'diff\\': \\'[edit system]+  host-name edge01.bjm01\\',\\n            \\'loaded_config\\': \\'system { host-name edge01.bjm01; }\\'\\'\\n        }\\n    '\n    _rendered = ''\n    _loaded = {'result': True, 'comment': '', 'out': None}\n    loaded_config = None\n    if template_engine not in salt.utils.templates.TEMPLATE_REGISTRY:\n        _loaded.update({'result': False, 'comment': 'Invalid templating engine! Choose between: {tpl_eng_opts}'.format(tpl_eng_opts=', '.join(list(salt.utils.templates.TEMPLATE_REGISTRY.keys())))})\n        return _loaded\n    salt_render_prefixes = ('salt://', 'http://', 'https://', 'ftp://')\n    salt_render = False\n    file_exists = False\n    if not isinstance(template_name, (tuple, list)):\n        for salt_render_prefix in salt_render_prefixes:\n            if not salt_render:\n                salt_render = salt_render or template_name.startswith(salt_render_prefix)\n        file_exists = __salt__['file.file_exists'](template_name)\n    if context is None:\n        context = {}\n    context.update(template_vars)\n    if template_source:\n        _rendered = __salt__['file.apply_template_on_contents'](contents=template_source, template=template_engine, context=context, defaults=defaults, saltenv=saltenv)\n        if not isinstance(_rendered, str):\n            if 'result' in _rendered:\n                _loaded['result'] = _rendered['result']\n            else:\n                _loaded['result'] = False\n            if 'comment' in _rendered:\n                _loaded['comment'] = _rendered['comment']\n            else:\n                _loaded['comment'] = 'Error while rendering the template.'\n            return _loaded\n    else:\n        if not isinstance(template_name, (list, tuple)):\n            template_name = [template_name]\n        if template_hash_name and (not isinstance(template_hash_name, (list, tuple))):\n            template_hash_name = [template_hash_name]\n        elif not template_hash_name:\n            template_hash_name = [None] * len(template_name)\n        if template_hash and isinstance(template_hash, str) and (not (template_hash.startswith('salt://') or template_hash.startswith('file://'))):\n            template_hash = [template_hash]\n        elif template_hash and isinstance(template_hash, str) and (template_hash.startswith('salt://') or template_hash.startswith('file://')):\n            template_hash = [template_hash] * len(template_name)\n        elif not template_hash:\n            template_hash = [None] * len(template_name)\n        for (tpl_index, tpl_name) in enumerate(template_name):\n            tpl_hash = template_hash[tpl_index]\n            tpl_hash_name = template_hash_name[tpl_index]\n            _rand_filename = __salt__['random.hash'](tpl_name, 'md5')\n            _temp_file = __salt__['file.join']('/tmp', _rand_filename)\n            _managed = __salt__['file.get_managed'](name=_temp_file, source=tpl_name, source_hash=tpl_hash, source_hash_name=tpl_hash_name, user=None, group=None, mode=None, attrs=None, template=template_engine, context=context, defaults=defaults, saltenv=saltenv, skip_verify=skip_verify)\n            if not isinstance(_managed, (list, tuple)) and isinstance(_managed, str):\n                _loaded['comment'] += _managed\n                _loaded['result'] = False\n            elif isinstance(_managed, (list, tuple)) and (not len(_managed) > 0):\n                _loaded['result'] = False\n                _loaded['comment'] += 'Error while rendering the template.'\n            elif isinstance(_managed, (list, tuple)) and (not len(_managed[0]) > 0):\n                _loaded['result'] = False\n                _loaded['comment'] += _managed[-1]\n            if _loaded['result']:\n                _temp_tpl_file = _managed[0]\n                _temp_tpl_file_exists = __salt__['file.file_exists'](_temp_tpl_file)\n                if not _temp_tpl_file_exists:\n                    _loaded['result'] = False\n                    _loaded['comment'] += 'Error while rendering the template.'\n                    return _loaded\n                _rendered += __salt__['file.read'](_temp_tpl_file)\n                __salt__['file.remove'](_temp_tpl_file)\n            else:\n                return _loaded\n    loaded_config = _rendered\n    if _loaded['result']:\n        fun = 'load_merge_candidate'\n        if replace:\n            fun = 'load_replace_candidate'\n        if salt.utils.napalm.not_always_alive(__opts__):\n            napalm_device['CLOSE'] = False\n        _loaded = salt.utils.napalm.call(napalm_device, fun, **{'config': _rendered})\n    return _config_logic(napalm_device, _loaded, test=test, debug=debug, replace=replace, commit_config=commit, loaded_config=loaded_config, commit_at=commit_at, commit_in=commit_in, revert_in=revert_in, revert_at=revert_at, **template_vars)"
        ]
    },
    {
        "func_name": "commit",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef commit(inherit_napalm_device=None, **kwargs):\n    \"\"\"\n    Commits the configuration changes made on the network device.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.commit\n    \"\"\"\n    return salt.utils.napalm.call(napalm_device, 'commit_config', **{})",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef commit(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Commits the configuration changes made on the network device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.commit\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'commit_config', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef commit(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Commits the configuration changes made on the network device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.commit\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'commit_config', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef commit(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Commits the configuration changes made on the network device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.commit\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'commit_config', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef commit(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Commits the configuration changes made on the network device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.commit\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'commit_config', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef commit(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Commits the configuration changes made on the network device.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.commit\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'commit_config', **{})"
        ]
    },
    {
        "func_name": "discard_config",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef discard_config(inherit_napalm_device=None, **kwargs):\n    \"\"\"\n    Discards the changes applied.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.discard_config\n    \"\"\"\n    return salt.utils.napalm.call(napalm_device, 'discard_config', **{})",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef discard_config(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Discards the changes applied.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.discard_config\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'discard_config', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef discard_config(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Discards the changes applied.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.discard_config\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'discard_config', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef discard_config(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Discards the changes applied.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.discard_config\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'discard_config', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef discard_config(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Discards the changes applied.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.discard_config\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'discard_config', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef discard_config(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Discards the changes applied.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.discard_config\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'discard_config', **{})"
        ]
    },
    {
        "func_name": "compare_config",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef compare_config(inherit_napalm_device=None, **kwargs):\n    \"\"\"\n    Returns the difference between the running config and the candidate config.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.compare_config\n    \"\"\"\n    return salt.utils.napalm.call(napalm_device, 'compare_config', **{})",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef compare_config(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Returns the difference between the running config and the candidate config.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.compare_config\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'compare_config', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef compare_config(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Returns the difference between the running config and the candidate config.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.compare_config\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'compare_config', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef compare_config(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Returns the difference between the running config and the candidate config.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.compare_config\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'compare_config', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef compare_config(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Returns the difference between the running config and the candidate config.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.compare_config\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'compare_config', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef compare_config(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Returns the difference between the running config and the candidate config.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.compare_config\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'compare_config', **{})"
        ]
    },
    {
        "func_name": "rollback",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef rollback(inherit_napalm_device=None, **kwargs):\n    \"\"\"\n    Rollbacks the configuration.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.rollback\n    \"\"\"\n    return salt.utils.napalm.call(napalm_device, 'rollback', **{})",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef rollback(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Rollbacks the configuration.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.rollback\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'rollback', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef rollback(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Rollbacks the configuration.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.rollback\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'rollback', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef rollback(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Rollbacks the configuration.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.rollback\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'rollback', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef rollback(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Rollbacks the configuration.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.rollback\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'rollback', **{})",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef rollback(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Rollbacks the configuration.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.rollback\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'rollback', **{})"
        ]
    },
    {
        "func_name": "config_changed",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef config_changed(inherit_napalm_device=None, **kwargs):\n    \"\"\"\n    Will prompt if the configuration has been changed.\n\n    :return: A tuple with a boolean that specifies if the config was changed on the device.    And a string that provides more details of the reason why the configuration was not changed.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.config_changed\n    \"\"\"\n    is_config_changed = False\n    reason = ''\n    try_compare = compare_config(inherit_napalm_device=napalm_device)\n    if try_compare.get('result'):\n        if try_compare.get('out'):\n            is_config_changed = True\n        else:\n            reason = 'Configuration was not changed on the device.'\n    else:\n        reason = try_compare.get('comment')\n    return (is_config_changed, reason)",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef config_changed(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Will prompt if the configuration has been changed.\\n\\n    :return: A tuple with a boolean that specifies if the config was changed on the device.    And a string that provides more details of the reason why the configuration was not changed.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.config_changed\\n    \"\n    is_config_changed = False\n    reason = ''\n    try_compare = compare_config(inherit_napalm_device=napalm_device)\n    if try_compare.get('result'):\n        if try_compare.get('out'):\n            is_config_changed = True\n        else:\n            reason = 'Configuration was not changed on the device.'\n    else:\n        reason = try_compare.get('comment')\n    return (is_config_changed, reason)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef config_changed(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Will prompt if the configuration has been changed.\\n\\n    :return: A tuple with a boolean that specifies if the config was changed on the device.    And a string that provides more details of the reason why the configuration was not changed.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.config_changed\\n    \"\n    is_config_changed = False\n    reason = ''\n    try_compare = compare_config(inherit_napalm_device=napalm_device)\n    if try_compare.get('result'):\n        if try_compare.get('out'):\n            is_config_changed = True\n        else:\n            reason = 'Configuration was not changed on the device.'\n    else:\n        reason = try_compare.get('comment')\n    return (is_config_changed, reason)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef config_changed(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Will prompt if the configuration has been changed.\\n\\n    :return: A tuple with a boolean that specifies if the config was changed on the device.    And a string that provides more details of the reason why the configuration was not changed.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.config_changed\\n    \"\n    is_config_changed = False\n    reason = ''\n    try_compare = compare_config(inherit_napalm_device=napalm_device)\n    if try_compare.get('result'):\n        if try_compare.get('out'):\n            is_config_changed = True\n        else:\n            reason = 'Configuration was not changed on the device.'\n    else:\n        reason = try_compare.get('comment')\n    return (is_config_changed, reason)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef config_changed(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Will prompt if the configuration has been changed.\\n\\n    :return: A tuple with a boolean that specifies if the config was changed on the device.    And a string that provides more details of the reason why the configuration was not changed.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.config_changed\\n    \"\n    is_config_changed = False\n    reason = ''\n    try_compare = compare_config(inherit_napalm_device=napalm_device)\n    if try_compare.get('result'):\n        if try_compare.get('out'):\n            is_config_changed = True\n        else:\n            reason = 'Configuration was not changed on the device.'\n    else:\n        reason = try_compare.get('comment')\n    return (is_config_changed, reason)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef config_changed(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Will prompt if the configuration has been changed.\\n\\n    :return: A tuple with a boolean that specifies if the config was changed on the device.    And a string that provides more details of the reason why the configuration was not changed.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.config_changed\\n    \"\n    is_config_changed = False\n    reason = ''\n    try_compare = compare_config(inherit_napalm_device=napalm_device)\n    if try_compare.get('result'):\n        if try_compare.get('out'):\n            is_config_changed = True\n        else:\n            reason = 'Configuration was not changed on the device.'\n    else:\n        reason = try_compare.get('comment')\n    return (is_config_changed, reason)"
        ]
    },
    {
        "func_name": "config_control",
        "original": "@salt.utils.napalm.proxy_napalm_wrap\ndef config_control(inherit_napalm_device=None, **kwargs):\n    \"\"\"\n    Will check if the configuration was changed.\n    If differences found, will try to commit.\n    In case commit unsuccessful, will try to rollback.\n\n    :return: A tuple with a boolean that specifies if the config was changed/committed/rollbacked on the device.    And a string that provides more details of the reason why the configuration was not committed properly.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.config_control\n    \"\"\"\n    result = True\n    comment = ''\n    (changed, not_changed_rsn) = config_changed(inherit_napalm_device=napalm_device)\n    if not changed:\n        return (changed, not_changed_rsn)\n    try_commit = commit()\n    if not try_commit.get('result'):\n        result = False\n        comment = 'Unable to commit the changes: {reason}.\\nWill try to rollback now!'.format(reason=try_commit.get('comment'))\n        try_rollback = rollback()\n        if not try_rollback.get('result'):\n            comment += '\\nCannot rollback! {reason}'.format(reason=try_rollback.get('comment'))\n    return (result, comment)",
        "mutated": [
            "@salt.utils.napalm.proxy_napalm_wrap\ndef config_control(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Will check if the configuration was changed.\\n    If differences found, will try to commit.\\n    In case commit unsuccessful, will try to rollback.\\n\\n    :return: A tuple with a boolean that specifies if the config was changed/committed/rollbacked on the device.    And a string that provides more details of the reason why the configuration was not committed properly.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.config_control\\n    \"\n    result = True\n    comment = ''\n    (changed, not_changed_rsn) = config_changed(inherit_napalm_device=napalm_device)\n    if not changed:\n        return (changed, not_changed_rsn)\n    try_commit = commit()\n    if not try_commit.get('result'):\n        result = False\n        comment = 'Unable to commit the changes: {reason}.\\nWill try to rollback now!'.format(reason=try_commit.get('comment'))\n        try_rollback = rollback()\n        if not try_rollback.get('result'):\n            comment += '\\nCannot rollback! {reason}'.format(reason=try_rollback.get('comment'))\n    return (result, comment)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef config_control(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Will check if the configuration was changed.\\n    If differences found, will try to commit.\\n    In case commit unsuccessful, will try to rollback.\\n\\n    :return: A tuple with a boolean that specifies if the config was changed/committed/rollbacked on the device.    And a string that provides more details of the reason why the configuration was not committed properly.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.config_control\\n    \"\n    result = True\n    comment = ''\n    (changed, not_changed_rsn) = config_changed(inherit_napalm_device=napalm_device)\n    if not changed:\n        return (changed, not_changed_rsn)\n    try_commit = commit()\n    if not try_commit.get('result'):\n        result = False\n        comment = 'Unable to commit the changes: {reason}.\\nWill try to rollback now!'.format(reason=try_commit.get('comment'))\n        try_rollback = rollback()\n        if not try_rollback.get('result'):\n            comment += '\\nCannot rollback! {reason}'.format(reason=try_rollback.get('comment'))\n    return (result, comment)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef config_control(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Will check if the configuration was changed.\\n    If differences found, will try to commit.\\n    In case commit unsuccessful, will try to rollback.\\n\\n    :return: A tuple with a boolean that specifies if the config was changed/committed/rollbacked on the device.    And a string that provides more details of the reason why the configuration was not committed properly.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.config_control\\n    \"\n    result = True\n    comment = ''\n    (changed, not_changed_rsn) = config_changed(inherit_napalm_device=napalm_device)\n    if not changed:\n        return (changed, not_changed_rsn)\n    try_commit = commit()\n    if not try_commit.get('result'):\n        result = False\n        comment = 'Unable to commit the changes: {reason}.\\nWill try to rollback now!'.format(reason=try_commit.get('comment'))\n        try_rollback = rollback()\n        if not try_rollback.get('result'):\n            comment += '\\nCannot rollback! {reason}'.format(reason=try_rollback.get('comment'))\n    return (result, comment)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef config_control(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Will check if the configuration was changed.\\n    If differences found, will try to commit.\\n    In case commit unsuccessful, will try to rollback.\\n\\n    :return: A tuple with a boolean that specifies if the config was changed/committed/rollbacked on the device.    And a string that provides more details of the reason why the configuration was not committed properly.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.config_control\\n    \"\n    result = True\n    comment = ''\n    (changed, not_changed_rsn) = config_changed(inherit_napalm_device=napalm_device)\n    if not changed:\n        return (changed, not_changed_rsn)\n    try_commit = commit()\n    if not try_commit.get('result'):\n        result = False\n        comment = 'Unable to commit the changes: {reason}.\\nWill try to rollback now!'.format(reason=try_commit.get('comment'))\n        try_rollback = rollback()\n        if not try_rollback.get('result'):\n            comment += '\\nCannot rollback! {reason}'.format(reason=try_rollback.get('comment'))\n    return (result, comment)",
            "@salt.utils.napalm.proxy_napalm_wrap\ndef config_control(inherit_napalm_device=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Will check if the configuration was changed.\\n    If differences found, will try to commit.\\n    In case commit unsuccessful, will try to rollback.\\n\\n    :return: A tuple with a boolean that specifies if the config was changed/committed/rollbacked on the device.    And a string that provides more details of the reason why the configuration was not committed properly.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.config_control\\n    \"\n    result = True\n    comment = ''\n    (changed, not_changed_rsn) = config_changed(inherit_napalm_device=napalm_device)\n    if not changed:\n        return (changed, not_changed_rsn)\n    try_commit = commit()\n    if not try_commit.get('result'):\n        result = False\n        comment = 'Unable to commit the changes: {reason}.\\nWill try to rollback now!'.format(reason=try_commit.get('comment'))\n        try_rollback = rollback()\n        if not try_rollback.get('result'):\n            comment += '\\nCannot rollback! {reason}'.format(reason=try_rollback.get('comment'))\n    return (result, comment)"
        ]
    },
    {
        "func_name": "cancel_commit",
        "original": "def cancel_commit(jid):\n    \"\"\"\n    .. versionadded:: 2019.2.0\n\n    Cancel a commit scheduled to be executed via the ``commit_in`` and\n    ``commit_at`` arguments from the\n    :py:func:`net.load_template <salt.modules.napalm_network.load_template>` or\n    :py:func:`net.load_config <salt.modules.napalm_network.load_config>`\n    execution functions. The commit ID is displayed when the commit is scheduled\n    via the functions named above.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.cancel_commit 20180726083540640360\n    \"\"\"\n    job_name = '__napalm_commit_{}'.format(jid)\n    removed = __salt__['schedule.delete'](job_name)\n    if removed['result']:\n        saved = __salt__['schedule.save']()\n        removed['comment'] = 'Commit #{jid} cancelled.'.format(jid=jid)\n    else:\n        removed['comment'] = 'Unable to find commit #{jid}.'.format(jid=jid)\n    return removed",
        "mutated": [
            "def cancel_commit(jid):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Cancel a commit scheduled to be executed via the ``commit_in`` and\\n    ``commit_at`` arguments from the\\n    :py:func:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :py:func:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit is scheduled\\n    via the functions named above.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.cancel_commit 20180726083540640360\\n    \"\n    job_name = '__napalm_commit_{}'.format(jid)\n    removed = __salt__['schedule.delete'](job_name)\n    if removed['result']:\n        saved = __salt__['schedule.save']()\n        removed['comment'] = 'Commit #{jid} cancelled.'.format(jid=jid)\n    else:\n        removed['comment'] = 'Unable to find commit #{jid}.'.format(jid=jid)\n    return removed",
            "def cancel_commit(jid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Cancel a commit scheduled to be executed via the ``commit_in`` and\\n    ``commit_at`` arguments from the\\n    :py:func:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :py:func:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit is scheduled\\n    via the functions named above.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.cancel_commit 20180726083540640360\\n    \"\n    job_name = '__napalm_commit_{}'.format(jid)\n    removed = __salt__['schedule.delete'](job_name)\n    if removed['result']:\n        saved = __salt__['schedule.save']()\n        removed['comment'] = 'Commit #{jid} cancelled.'.format(jid=jid)\n    else:\n        removed['comment'] = 'Unable to find commit #{jid}.'.format(jid=jid)\n    return removed",
            "def cancel_commit(jid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Cancel a commit scheduled to be executed via the ``commit_in`` and\\n    ``commit_at`` arguments from the\\n    :py:func:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :py:func:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit is scheduled\\n    via the functions named above.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.cancel_commit 20180726083540640360\\n    \"\n    job_name = '__napalm_commit_{}'.format(jid)\n    removed = __salt__['schedule.delete'](job_name)\n    if removed['result']:\n        saved = __salt__['schedule.save']()\n        removed['comment'] = 'Commit #{jid} cancelled.'.format(jid=jid)\n    else:\n        removed['comment'] = 'Unable to find commit #{jid}.'.format(jid=jid)\n    return removed",
            "def cancel_commit(jid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Cancel a commit scheduled to be executed via the ``commit_in`` and\\n    ``commit_at`` arguments from the\\n    :py:func:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :py:func:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit is scheduled\\n    via the functions named above.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.cancel_commit 20180726083540640360\\n    \"\n    job_name = '__napalm_commit_{}'.format(jid)\n    removed = __salt__['schedule.delete'](job_name)\n    if removed['result']:\n        saved = __salt__['schedule.save']()\n        removed['comment'] = 'Commit #{jid} cancelled.'.format(jid=jid)\n    else:\n        removed['comment'] = 'Unable to find commit #{jid}.'.format(jid=jid)\n    return removed",
            "def cancel_commit(jid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Cancel a commit scheduled to be executed via the ``commit_in`` and\\n    ``commit_at`` arguments from the\\n    :py:func:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :py:func:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit is scheduled\\n    via the functions named above.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.cancel_commit 20180726083540640360\\n    \"\n    job_name = '__napalm_commit_{}'.format(jid)\n    removed = __salt__['schedule.delete'](job_name)\n    if removed['result']:\n        saved = __salt__['schedule.save']()\n        removed['comment'] = 'Commit #{jid} cancelled.'.format(jid=jid)\n    else:\n        removed['comment'] = 'Unable to find commit #{jid}.'.format(jid=jid)\n    return removed"
        ]
    },
    {
        "func_name": "confirm_commit",
        "original": "def confirm_commit(jid):\n    \"\"\"\n    .. versionadded:: 2019.2.0\n\n    Confirm a commit scheduled to be reverted via the ``revert_in`` and\n    ``revert_at``  arguments from the\n    :mod:`net.load_template <salt.modules.napalm_network.load_template>` or\n    :mod:`net.load_config <salt.modules.napalm_network.load_config>`\n    execution functions. The commit ID is displayed when the commit confirmed\n    is scheduled via the functions named above.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.confirm_commit 20180726083540640360\n    \"\"\"\n    if __grains__['os'] == 'junos':\n        confirmed = __salt__['napalm.junos_commit']()\n        confirmed['result'] = confirmed.pop('out')\n        confirmed['comment'] = confirmed.pop('message')\n    else:\n        confirmed = cancel_commit(jid)\n    if confirmed['result']:\n        confirmed['comment'] = 'Commit #{jid} confirmed.'.format(jid=jid)\n    return confirmed",
        "mutated": [
            "def confirm_commit(jid):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Confirm a commit scheduled to be reverted via the ``revert_in`` and\\n    ``revert_at``  arguments from the\\n    :mod:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :mod:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit confirmed\\n    is scheduled via the functions named above.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.confirm_commit 20180726083540640360\\n    \"\n    if __grains__['os'] == 'junos':\n        confirmed = __salt__['napalm.junos_commit']()\n        confirmed['result'] = confirmed.pop('out')\n        confirmed['comment'] = confirmed.pop('message')\n    else:\n        confirmed = cancel_commit(jid)\n    if confirmed['result']:\n        confirmed['comment'] = 'Commit #{jid} confirmed.'.format(jid=jid)\n    return confirmed",
            "def confirm_commit(jid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Confirm a commit scheduled to be reverted via the ``revert_in`` and\\n    ``revert_at``  arguments from the\\n    :mod:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :mod:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit confirmed\\n    is scheduled via the functions named above.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.confirm_commit 20180726083540640360\\n    \"\n    if __grains__['os'] == 'junos':\n        confirmed = __salt__['napalm.junos_commit']()\n        confirmed['result'] = confirmed.pop('out')\n        confirmed['comment'] = confirmed.pop('message')\n    else:\n        confirmed = cancel_commit(jid)\n    if confirmed['result']:\n        confirmed['comment'] = 'Commit #{jid} confirmed.'.format(jid=jid)\n    return confirmed",
            "def confirm_commit(jid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Confirm a commit scheduled to be reverted via the ``revert_in`` and\\n    ``revert_at``  arguments from the\\n    :mod:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :mod:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit confirmed\\n    is scheduled via the functions named above.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.confirm_commit 20180726083540640360\\n    \"\n    if __grains__['os'] == 'junos':\n        confirmed = __salt__['napalm.junos_commit']()\n        confirmed['result'] = confirmed.pop('out')\n        confirmed['comment'] = confirmed.pop('message')\n    else:\n        confirmed = cancel_commit(jid)\n    if confirmed['result']:\n        confirmed['comment'] = 'Commit #{jid} confirmed.'.format(jid=jid)\n    return confirmed",
            "def confirm_commit(jid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Confirm a commit scheduled to be reverted via the ``revert_in`` and\\n    ``revert_at``  arguments from the\\n    :mod:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :mod:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit confirmed\\n    is scheduled via the functions named above.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.confirm_commit 20180726083540640360\\n    \"\n    if __grains__['os'] == 'junos':\n        confirmed = __salt__['napalm.junos_commit']()\n        confirmed['result'] = confirmed.pop('out')\n        confirmed['comment'] = confirmed.pop('message')\n    else:\n        confirmed = cancel_commit(jid)\n    if confirmed['result']:\n        confirmed['comment'] = 'Commit #{jid} confirmed.'.format(jid=jid)\n    return confirmed",
            "def confirm_commit(jid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Confirm a commit scheduled to be reverted via the ``revert_in`` and\\n    ``revert_at``  arguments from the\\n    :mod:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :mod:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit confirmed\\n    is scheduled via the functions named above.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.confirm_commit 20180726083540640360\\n    \"\n    if __grains__['os'] == 'junos':\n        confirmed = __salt__['napalm.junos_commit']()\n        confirmed['result'] = confirmed.pop('out')\n        confirmed['comment'] = confirmed.pop('message')\n    else:\n        confirmed = cancel_commit(jid)\n    if confirmed['result']:\n        confirmed['comment'] = 'Commit #{jid} confirmed.'.format(jid=jid)\n    return confirmed"
        ]
    },
    {
        "func_name": "save_config",
        "original": "def save_config(source=None, path=None):\n    \"\"\"\n    .. versionadded:: 2019.2.0\n\n    Save the configuration to a file on the local file system.\n\n    source: ``running``\n        The configuration source. Choose from: ``running``, ``candidate``,\n        ``startup``. Default: ``running``.\n\n    path\n        Absolute path to file where to save the configuration.\n        To push the files to the Master, use\n        :mod:`cp.push <salt.modules.cp.push>` Execution function.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.save_config source=running\n    \"\"\"\n    if not source:\n        source = 'running'\n    if not path:\n        path = salt.utils.files.mkstemp()\n    running_config = __salt__['net.config'](source=source)\n    if not running_config or not running_config['result']:\n        log.error('Unable to retrieve the config')\n        return running_config\n    with salt.utils.files.fopen(path, 'w') as fh_:\n        fh_.write(running_config['out'][source])\n    return {'result': True, 'out': path, 'comment': '{source} config saved to {path}'.format(source=source, path=path)}",
        "mutated": [
            "def save_config(source=None, path=None):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Save the configuration to a file on the local file system.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``,\\n        ``startup``. Default: ``running``.\\n\\n    path\\n        Absolute path to file where to save the configuration.\\n        To push the files to the Master, use\\n        :mod:`cp.push <salt.modules.cp.push>` Execution function.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.save_config source=running\\n    \"\n    if not source:\n        source = 'running'\n    if not path:\n        path = salt.utils.files.mkstemp()\n    running_config = __salt__['net.config'](source=source)\n    if not running_config or not running_config['result']:\n        log.error('Unable to retrieve the config')\n        return running_config\n    with salt.utils.files.fopen(path, 'w') as fh_:\n        fh_.write(running_config['out'][source])\n    return {'result': True, 'out': path, 'comment': '{source} config saved to {path}'.format(source=source, path=path)}",
            "def save_config(source=None, path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Save the configuration to a file on the local file system.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``,\\n        ``startup``. Default: ``running``.\\n\\n    path\\n        Absolute path to file where to save the configuration.\\n        To push the files to the Master, use\\n        :mod:`cp.push <salt.modules.cp.push>` Execution function.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.save_config source=running\\n    \"\n    if not source:\n        source = 'running'\n    if not path:\n        path = salt.utils.files.mkstemp()\n    running_config = __salt__['net.config'](source=source)\n    if not running_config or not running_config['result']:\n        log.error('Unable to retrieve the config')\n        return running_config\n    with salt.utils.files.fopen(path, 'w') as fh_:\n        fh_.write(running_config['out'][source])\n    return {'result': True, 'out': path, 'comment': '{source} config saved to {path}'.format(source=source, path=path)}",
            "def save_config(source=None, path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Save the configuration to a file on the local file system.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``,\\n        ``startup``. Default: ``running``.\\n\\n    path\\n        Absolute path to file where to save the configuration.\\n        To push the files to the Master, use\\n        :mod:`cp.push <salt.modules.cp.push>` Execution function.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.save_config source=running\\n    \"\n    if not source:\n        source = 'running'\n    if not path:\n        path = salt.utils.files.mkstemp()\n    running_config = __salt__['net.config'](source=source)\n    if not running_config or not running_config['result']:\n        log.error('Unable to retrieve the config')\n        return running_config\n    with salt.utils.files.fopen(path, 'w') as fh_:\n        fh_.write(running_config['out'][source])\n    return {'result': True, 'out': path, 'comment': '{source} config saved to {path}'.format(source=source, path=path)}",
            "def save_config(source=None, path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Save the configuration to a file on the local file system.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``,\\n        ``startup``. Default: ``running``.\\n\\n    path\\n        Absolute path to file where to save the configuration.\\n        To push the files to the Master, use\\n        :mod:`cp.push <salt.modules.cp.push>` Execution function.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.save_config source=running\\n    \"\n    if not source:\n        source = 'running'\n    if not path:\n        path = salt.utils.files.mkstemp()\n    running_config = __salt__['net.config'](source=source)\n    if not running_config or not running_config['result']:\n        log.error('Unable to retrieve the config')\n        return running_config\n    with salt.utils.files.fopen(path, 'w') as fh_:\n        fh_.write(running_config['out'][source])\n    return {'result': True, 'out': path, 'comment': '{source} config saved to {path}'.format(source=source, path=path)}",
            "def save_config(source=None, path=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Save the configuration to a file on the local file system.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``,\\n        ``startup``. Default: ``running``.\\n\\n    path\\n        Absolute path to file where to save the configuration.\\n        To push the files to the Master, use\\n        :mod:`cp.push <salt.modules.cp.push>` Execution function.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.save_config source=running\\n    \"\n    if not source:\n        source = 'running'\n    if not path:\n        path = salt.utils.files.mkstemp()\n    running_config = __salt__['net.config'](source=source)\n    if not running_config or not running_config['result']:\n        log.error('Unable to retrieve the config')\n        return running_config\n    with salt.utils.files.fopen(path, 'w') as fh_:\n        fh_.write(running_config['out'][source])\n    return {'result': True, 'out': path, 'comment': '{source} config saved to {path}'.format(source=source, path=path)}"
        ]
    },
    {
        "func_name": "replace_pattern",
        "original": "def replace_pattern(pattern, repl, count=0, flags=8, bufsize=1, append_if_not_found=False, prepend_if_not_found=False, not_found_content=None, search_only=False, show_changes=True, backslash_literal=False, source=None, path=None, test=False, replace=True, debug=False, commit=True):\n    \"\"\"\n    .. versionadded:: 2019.2.0\n\n    Replace occurrences of a pattern in the configuration source. If\n    ``show_changes`` is ``True``, then a diff of what changed will be returned,\n    otherwise a ``True`` will be returned when changes are made, and ``False``\n    when no changes are made.\n    This is a pure Python implementation that wraps Python's :py:func:`~re.sub`.\n\n    pattern\n        A regular expression, to be matched using Python's\n        :py:func:`~re.search`.\n\n    repl\n        The replacement text.\n\n    count: ``0``\n        Maximum number of pattern occurrences to be replaced. If count is a\n        positive integer ``n``, only ``n`` occurrences will be replaced,\n        otherwise all occurrences will be replaced.\n\n    flags (list or int): ``8``\n        A list of flags defined in the ``re`` module documentation from the\n        Python standard library. Each list item should be a string that will\n        correlate to the human-friendly flag name. E.g., ``['IGNORECASE',\n        'MULTILINE']``. Optionally, ``flags`` may be an int, with a value\n        corresponding to the XOR (``|``) of all the desired flags. Defaults to\n        8 (which supports 'MULTILINE').\n\n    bufsize (int or str): ``1``\n        How much of the configuration to buffer into memory at once. The\n        default value ``1`` processes one line at a time. The special value\n        ``file`` may be specified which will read the entire file into memory\n        before processing.\n\n    append_if_not_found: ``False``\n        If set to ``True``, and pattern is not found, then the content will be\n        appended to the file.\n\n    prepend_if_not_found: ``False``\n        If set to ``True`` and pattern is not found, then the content will be\n        prepended to the file.\n\n    not_found_content\n        Content to use for append/prepend if not found. If None (default), uses\n        ``repl``. Useful when ``repl`` uses references to group in pattern.\n\n    search_only: ``False``\n        If set to true, this no changes will be performed on the file, and this\n        function will simply return ``True`` if the pattern was matched, and\n        ``False`` if not.\n\n    show_changes: ``True``\n        If ``True``, return a diff of changes made. Otherwise, return ``True``\n        if changes were made, and ``False`` if not.\n\n    backslash_literal: ``False``\n        Interpret backslashes as literal backslashes for the repl and not\n        escape characters.  This will help when using append/prepend so that\n        the backslashes are not interpreted for the repl on the second run of\n        the state.\n\n    source: ``running``\n        The configuration source. Choose from: ``running``, ``candidate``, or\n        ``startup``. Default: ``running``.\n\n    path\n        Save the temporary configuration to a specific path, then read from\n        there.\n\n    test: ``False``\n        Dry run? If set as ``True``, will apply the config, discard and return\n        the changes. Default: ``False`` and will commit the changes on the\n        device.\n\n    commit: ``True``\n        Commit the configuration changes? Default: ``True``.\n\n    debug: ``False``\n        Debug mode. Will insert a new key in the output dictionary, as\n        ``loaded_config`` containing the raw configuration loaded on the device.\n\n    replace: ``True``\n        Load and replace the configuration. Default: ``True``.\n\n    If an equal sign (``=``) appears in an argument to a Salt command it is\n    interpreted as a keyword argument in the format ``key=val``. That\n    processing can be bypassed in order to pass an equal sign through to the\n    remote shell command by manually specifying the kwarg:\n\n    .. code-block:: bash\n\n        salt '*' net.replace_pattern \"bind-address\\\\s*=\" \"bind-address:\"\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.replace_pattern PREFIX-LIST_NAME new-prefix-list-name\n        salt '*' net.replace_pattern bgp-group-name new-bgp-group-name count=1\n    \"\"\"\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    replace_pattern = __salt__['file.replace'](path, pattern, repl, count=count, flags=flags, bufsize=bufsize, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, not_found_content=not_found_content, search_only=search_only, show_changes=show_changes, backslash_literal=backslash_literal)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)",
        "mutated": [
            "def replace_pattern(pattern, repl, count=0, flags=8, bufsize=1, append_if_not_found=False, prepend_if_not_found=False, not_found_content=None, search_only=False, show_changes=True, backslash_literal=False, source=None, path=None, test=False, replace=True, debug=False, commit=True):\n    if False:\n        i = 10\n    '\\n    .. versionadded:: 2019.2.0\\n\\n    Replace occurrences of a pattern in the configuration source. If\\n    ``show_changes`` is ``True``, then a diff of what changed will be returned,\\n    otherwise a ``True`` will be returned when changes are made, and ``False``\\n    when no changes are made.\\n    This is a pure Python implementation that wraps Python\\'s :py:func:`~re.sub`.\\n\\n    pattern\\n        A regular expression, to be matched using Python\\'s\\n        :py:func:`~re.search`.\\n\\n    repl\\n        The replacement text.\\n\\n    count: ``0``\\n        Maximum number of pattern occurrences to be replaced. If count is a\\n        positive integer ``n``, only ``n`` occurrences will be replaced,\\n        otherwise all occurrences will be replaced.\\n\\n    flags (list or int): ``8``\\n        A list of flags defined in the ``re`` module documentation from the\\n        Python standard library. Each list item should be a string that will\\n        correlate to the human-friendly flag name. E.g., ``[\\'IGNORECASE\\',\\n        \\'MULTILINE\\']``. Optionally, ``flags`` may be an int, with a value\\n        corresponding to the XOR (``|``) of all the desired flags. Defaults to\\n        8 (which supports \\'MULTILINE\\').\\n\\n    bufsize (int or str): ``1``\\n        How much of the configuration to buffer into memory at once. The\\n        default value ``1`` processes one line at a time. The special value\\n        ``file`` may be specified which will read the entire file into memory\\n        before processing.\\n\\n    append_if_not_found: ``False``\\n        If set to ``True``, and pattern is not found, then the content will be\\n        appended to the file.\\n\\n    prepend_if_not_found: ``False``\\n        If set to ``True`` and pattern is not found, then the content will be\\n        prepended to the file.\\n\\n    not_found_content\\n        Content to use for append/prepend if not found. If None (default), uses\\n        ``repl``. Useful when ``repl`` uses references to group in pattern.\\n\\n    search_only: ``False``\\n        If set to true, this no changes will be performed on the file, and this\\n        function will simply return ``True`` if the pattern was matched, and\\n        ``False`` if not.\\n\\n    show_changes: ``True``\\n        If ``True``, return a diff of changes made. Otherwise, return ``True``\\n        if changes were made, and ``False`` if not.\\n\\n    backslash_literal: ``False``\\n        Interpret backslashes as literal backslashes for the repl and not\\n        escape characters.  This will help when using append/prepend so that\\n        the backslashes are not interpreted for the repl on the second run of\\n        the state.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path\\n        Save the temporary configuration to a specific path, then read from\\n        there.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    If an equal sign (``=``) appears in an argument to a Salt command it is\\n    interpreted as a keyword argument in the format ``key=val``. That\\n    processing can be bypassed in order to pass an equal sign through to the\\n    remote shell command by manually specifying the kwarg:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.replace_pattern \"bind-address\\\\s*=\" \"bind-address:\"\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.replace_pattern PREFIX-LIST_NAME new-prefix-list-name\\n        salt \\'*\\' net.replace_pattern bgp-group-name new-bgp-group-name count=1\\n    '\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    replace_pattern = __salt__['file.replace'](path, pattern, repl, count=count, flags=flags, bufsize=bufsize, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, not_found_content=not_found_content, search_only=search_only, show_changes=show_changes, backslash_literal=backslash_literal)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)",
            "def replace_pattern(pattern, repl, count=0, flags=8, bufsize=1, append_if_not_found=False, prepend_if_not_found=False, not_found_content=None, search_only=False, show_changes=True, backslash_literal=False, source=None, path=None, test=False, replace=True, debug=False, commit=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    .. versionadded:: 2019.2.0\\n\\n    Replace occurrences of a pattern in the configuration source. If\\n    ``show_changes`` is ``True``, then a diff of what changed will be returned,\\n    otherwise a ``True`` will be returned when changes are made, and ``False``\\n    when no changes are made.\\n    This is a pure Python implementation that wraps Python\\'s :py:func:`~re.sub`.\\n\\n    pattern\\n        A regular expression, to be matched using Python\\'s\\n        :py:func:`~re.search`.\\n\\n    repl\\n        The replacement text.\\n\\n    count: ``0``\\n        Maximum number of pattern occurrences to be replaced. If count is a\\n        positive integer ``n``, only ``n`` occurrences will be replaced,\\n        otherwise all occurrences will be replaced.\\n\\n    flags (list or int): ``8``\\n        A list of flags defined in the ``re`` module documentation from the\\n        Python standard library. Each list item should be a string that will\\n        correlate to the human-friendly flag name. E.g., ``[\\'IGNORECASE\\',\\n        \\'MULTILINE\\']``. Optionally, ``flags`` may be an int, with a value\\n        corresponding to the XOR (``|``) of all the desired flags. Defaults to\\n        8 (which supports \\'MULTILINE\\').\\n\\n    bufsize (int or str): ``1``\\n        How much of the configuration to buffer into memory at once. The\\n        default value ``1`` processes one line at a time. The special value\\n        ``file`` may be specified which will read the entire file into memory\\n        before processing.\\n\\n    append_if_not_found: ``False``\\n        If set to ``True``, and pattern is not found, then the content will be\\n        appended to the file.\\n\\n    prepend_if_not_found: ``False``\\n        If set to ``True`` and pattern is not found, then the content will be\\n        prepended to the file.\\n\\n    not_found_content\\n        Content to use for append/prepend if not found. If None (default), uses\\n        ``repl``. Useful when ``repl`` uses references to group in pattern.\\n\\n    search_only: ``False``\\n        If set to true, this no changes will be performed on the file, and this\\n        function will simply return ``True`` if the pattern was matched, and\\n        ``False`` if not.\\n\\n    show_changes: ``True``\\n        If ``True``, return a diff of changes made. Otherwise, return ``True``\\n        if changes were made, and ``False`` if not.\\n\\n    backslash_literal: ``False``\\n        Interpret backslashes as literal backslashes for the repl and not\\n        escape characters.  This will help when using append/prepend so that\\n        the backslashes are not interpreted for the repl on the second run of\\n        the state.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path\\n        Save the temporary configuration to a specific path, then read from\\n        there.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    If an equal sign (``=``) appears in an argument to a Salt command it is\\n    interpreted as a keyword argument in the format ``key=val``. That\\n    processing can be bypassed in order to pass an equal sign through to the\\n    remote shell command by manually specifying the kwarg:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.replace_pattern \"bind-address\\\\s*=\" \"bind-address:\"\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.replace_pattern PREFIX-LIST_NAME new-prefix-list-name\\n        salt \\'*\\' net.replace_pattern bgp-group-name new-bgp-group-name count=1\\n    '\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    replace_pattern = __salt__['file.replace'](path, pattern, repl, count=count, flags=flags, bufsize=bufsize, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, not_found_content=not_found_content, search_only=search_only, show_changes=show_changes, backslash_literal=backslash_literal)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)",
            "def replace_pattern(pattern, repl, count=0, flags=8, bufsize=1, append_if_not_found=False, prepend_if_not_found=False, not_found_content=None, search_only=False, show_changes=True, backslash_literal=False, source=None, path=None, test=False, replace=True, debug=False, commit=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    .. versionadded:: 2019.2.0\\n\\n    Replace occurrences of a pattern in the configuration source. If\\n    ``show_changes`` is ``True``, then a diff of what changed will be returned,\\n    otherwise a ``True`` will be returned when changes are made, and ``False``\\n    when no changes are made.\\n    This is a pure Python implementation that wraps Python\\'s :py:func:`~re.sub`.\\n\\n    pattern\\n        A regular expression, to be matched using Python\\'s\\n        :py:func:`~re.search`.\\n\\n    repl\\n        The replacement text.\\n\\n    count: ``0``\\n        Maximum number of pattern occurrences to be replaced. If count is a\\n        positive integer ``n``, only ``n`` occurrences will be replaced,\\n        otherwise all occurrences will be replaced.\\n\\n    flags (list or int): ``8``\\n        A list of flags defined in the ``re`` module documentation from the\\n        Python standard library. Each list item should be a string that will\\n        correlate to the human-friendly flag name. E.g., ``[\\'IGNORECASE\\',\\n        \\'MULTILINE\\']``. Optionally, ``flags`` may be an int, with a value\\n        corresponding to the XOR (``|``) of all the desired flags. Defaults to\\n        8 (which supports \\'MULTILINE\\').\\n\\n    bufsize (int or str): ``1``\\n        How much of the configuration to buffer into memory at once. The\\n        default value ``1`` processes one line at a time. The special value\\n        ``file`` may be specified which will read the entire file into memory\\n        before processing.\\n\\n    append_if_not_found: ``False``\\n        If set to ``True``, and pattern is not found, then the content will be\\n        appended to the file.\\n\\n    prepend_if_not_found: ``False``\\n        If set to ``True`` and pattern is not found, then the content will be\\n        prepended to the file.\\n\\n    not_found_content\\n        Content to use for append/prepend if not found. If None (default), uses\\n        ``repl``. Useful when ``repl`` uses references to group in pattern.\\n\\n    search_only: ``False``\\n        If set to true, this no changes will be performed on the file, and this\\n        function will simply return ``True`` if the pattern was matched, and\\n        ``False`` if not.\\n\\n    show_changes: ``True``\\n        If ``True``, return a diff of changes made. Otherwise, return ``True``\\n        if changes were made, and ``False`` if not.\\n\\n    backslash_literal: ``False``\\n        Interpret backslashes as literal backslashes for the repl and not\\n        escape characters.  This will help when using append/prepend so that\\n        the backslashes are not interpreted for the repl on the second run of\\n        the state.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path\\n        Save the temporary configuration to a specific path, then read from\\n        there.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    If an equal sign (``=``) appears in an argument to a Salt command it is\\n    interpreted as a keyword argument in the format ``key=val``. That\\n    processing can be bypassed in order to pass an equal sign through to the\\n    remote shell command by manually specifying the kwarg:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.replace_pattern \"bind-address\\\\s*=\" \"bind-address:\"\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.replace_pattern PREFIX-LIST_NAME new-prefix-list-name\\n        salt \\'*\\' net.replace_pattern bgp-group-name new-bgp-group-name count=1\\n    '\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    replace_pattern = __salt__['file.replace'](path, pattern, repl, count=count, flags=flags, bufsize=bufsize, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, not_found_content=not_found_content, search_only=search_only, show_changes=show_changes, backslash_literal=backslash_literal)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)",
            "def replace_pattern(pattern, repl, count=0, flags=8, bufsize=1, append_if_not_found=False, prepend_if_not_found=False, not_found_content=None, search_only=False, show_changes=True, backslash_literal=False, source=None, path=None, test=False, replace=True, debug=False, commit=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    .. versionadded:: 2019.2.0\\n\\n    Replace occurrences of a pattern in the configuration source. If\\n    ``show_changes`` is ``True``, then a diff of what changed will be returned,\\n    otherwise a ``True`` will be returned when changes are made, and ``False``\\n    when no changes are made.\\n    This is a pure Python implementation that wraps Python\\'s :py:func:`~re.sub`.\\n\\n    pattern\\n        A regular expression, to be matched using Python\\'s\\n        :py:func:`~re.search`.\\n\\n    repl\\n        The replacement text.\\n\\n    count: ``0``\\n        Maximum number of pattern occurrences to be replaced. If count is a\\n        positive integer ``n``, only ``n`` occurrences will be replaced,\\n        otherwise all occurrences will be replaced.\\n\\n    flags (list or int): ``8``\\n        A list of flags defined in the ``re`` module documentation from the\\n        Python standard library. Each list item should be a string that will\\n        correlate to the human-friendly flag name. E.g., ``[\\'IGNORECASE\\',\\n        \\'MULTILINE\\']``. Optionally, ``flags`` may be an int, with a value\\n        corresponding to the XOR (``|``) of all the desired flags. Defaults to\\n        8 (which supports \\'MULTILINE\\').\\n\\n    bufsize (int or str): ``1``\\n        How much of the configuration to buffer into memory at once. The\\n        default value ``1`` processes one line at a time. The special value\\n        ``file`` may be specified which will read the entire file into memory\\n        before processing.\\n\\n    append_if_not_found: ``False``\\n        If set to ``True``, and pattern is not found, then the content will be\\n        appended to the file.\\n\\n    prepend_if_not_found: ``False``\\n        If set to ``True`` and pattern is not found, then the content will be\\n        prepended to the file.\\n\\n    not_found_content\\n        Content to use for append/prepend if not found. If None (default), uses\\n        ``repl``. Useful when ``repl`` uses references to group in pattern.\\n\\n    search_only: ``False``\\n        If set to true, this no changes will be performed on the file, and this\\n        function will simply return ``True`` if the pattern was matched, and\\n        ``False`` if not.\\n\\n    show_changes: ``True``\\n        If ``True``, return a diff of changes made. Otherwise, return ``True``\\n        if changes were made, and ``False`` if not.\\n\\n    backslash_literal: ``False``\\n        Interpret backslashes as literal backslashes for the repl and not\\n        escape characters.  This will help when using append/prepend so that\\n        the backslashes are not interpreted for the repl on the second run of\\n        the state.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path\\n        Save the temporary configuration to a specific path, then read from\\n        there.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    If an equal sign (``=``) appears in an argument to a Salt command it is\\n    interpreted as a keyword argument in the format ``key=val``. That\\n    processing can be bypassed in order to pass an equal sign through to the\\n    remote shell command by manually specifying the kwarg:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.replace_pattern \"bind-address\\\\s*=\" \"bind-address:\"\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.replace_pattern PREFIX-LIST_NAME new-prefix-list-name\\n        salt \\'*\\' net.replace_pattern bgp-group-name new-bgp-group-name count=1\\n    '\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    replace_pattern = __salt__['file.replace'](path, pattern, repl, count=count, flags=flags, bufsize=bufsize, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, not_found_content=not_found_content, search_only=search_only, show_changes=show_changes, backslash_literal=backslash_literal)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)",
            "def replace_pattern(pattern, repl, count=0, flags=8, bufsize=1, append_if_not_found=False, prepend_if_not_found=False, not_found_content=None, search_only=False, show_changes=True, backslash_literal=False, source=None, path=None, test=False, replace=True, debug=False, commit=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    .. versionadded:: 2019.2.0\\n\\n    Replace occurrences of a pattern in the configuration source. If\\n    ``show_changes`` is ``True``, then a diff of what changed will be returned,\\n    otherwise a ``True`` will be returned when changes are made, and ``False``\\n    when no changes are made.\\n    This is a pure Python implementation that wraps Python\\'s :py:func:`~re.sub`.\\n\\n    pattern\\n        A regular expression, to be matched using Python\\'s\\n        :py:func:`~re.search`.\\n\\n    repl\\n        The replacement text.\\n\\n    count: ``0``\\n        Maximum number of pattern occurrences to be replaced. If count is a\\n        positive integer ``n``, only ``n`` occurrences will be replaced,\\n        otherwise all occurrences will be replaced.\\n\\n    flags (list or int): ``8``\\n        A list of flags defined in the ``re`` module documentation from the\\n        Python standard library. Each list item should be a string that will\\n        correlate to the human-friendly flag name. E.g., ``[\\'IGNORECASE\\',\\n        \\'MULTILINE\\']``. Optionally, ``flags`` may be an int, with a value\\n        corresponding to the XOR (``|``) of all the desired flags. Defaults to\\n        8 (which supports \\'MULTILINE\\').\\n\\n    bufsize (int or str): ``1``\\n        How much of the configuration to buffer into memory at once. The\\n        default value ``1`` processes one line at a time. The special value\\n        ``file`` may be specified which will read the entire file into memory\\n        before processing.\\n\\n    append_if_not_found: ``False``\\n        If set to ``True``, and pattern is not found, then the content will be\\n        appended to the file.\\n\\n    prepend_if_not_found: ``False``\\n        If set to ``True`` and pattern is not found, then the content will be\\n        prepended to the file.\\n\\n    not_found_content\\n        Content to use for append/prepend if not found. If None (default), uses\\n        ``repl``. Useful when ``repl`` uses references to group in pattern.\\n\\n    search_only: ``False``\\n        If set to true, this no changes will be performed on the file, and this\\n        function will simply return ``True`` if the pattern was matched, and\\n        ``False`` if not.\\n\\n    show_changes: ``True``\\n        If ``True``, return a diff of changes made. Otherwise, return ``True``\\n        if changes were made, and ``False`` if not.\\n\\n    backslash_literal: ``False``\\n        Interpret backslashes as literal backslashes for the repl and not\\n        escape characters.  This will help when using append/prepend so that\\n        the backslashes are not interpreted for the repl on the second run of\\n        the state.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path\\n        Save the temporary configuration to a specific path, then read from\\n        there.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    If an equal sign (``=``) appears in an argument to a Salt command it is\\n    interpreted as a keyword argument in the format ``key=val``. That\\n    processing can be bypassed in order to pass an equal sign through to the\\n    remote shell command by manually specifying the kwarg:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.replace_pattern \"bind-address\\\\s*=\" \"bind-address:\"\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' net.replace_pattern PREFIX-LIST_NAME new-prefix-list-name\\n        salt \\'*\\' net.replace_pattern bgp-group-name new-bgp-group-name count=1\\n    '\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    replace_pattern = __salt__['file.replace'](path, pattern, repl, count=count, flags=flags, bufsize=bufsize, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, not_found_content=not_found_content, search_only=search_only, show_changes=show_changes, backslash_literal=backslash_literal)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)"
        ]
    },
    {
        "func_name": "blockreplace",
        "original": "def blockreplace(marker_start, marker_end, content='', append_if_not_found=False, prepend_if_not_found=False, show_changes=True, append_newline=False, source='running', path=None, test=False, commit=True, debug=False, replace=True):\n    \"\"\"\n    .. versionadded:: 2019.2.0\n\n    Replace content of the configuration source, delimited by the line markers.\n\n    A block of content delimited by comments can help you manage several lines\n    without worrying about old entries removal.\n\n    marker_start\n        The line content identifying a line as the start of the content block.\n        Note that the whole line containing this marker will be considered,\n        so whitespace or extra content before or after the marker is included\n        in final output.\n\n    marker_end\n        The line content identifying a line as the end of the content block.\n        Note that the whole line containing this marker will be considered,\n        so whitespace or extra content before or after the marker is included\n        in final output.\n\n    content\n        The content to be used between the two lines identified by\n        ``marker_start`` and ``marker_stop``.\n\n    append_if_not_found: ``False``\n        If markers are not found and set to True then, the markers and content\n        will be appended to the file.\n\n    prepend_if_not_found: ``False``\n        If markers are not found and set to True then, the markers and content\n        will be prepended to the file.\n\n    append_newline: ``False``\n        Controls whether or not a newline is appended to the content block.\n        If the value of this argument is ``True`` then a newline will be added\n        to the content block. If it is ``False``, then a newline will not be\n        added to the content block. If it is ``None`` then a newline will only\n        be added to the content block if it does not already end in a newline.\n\n    show_changes: ``True``\n        Controls how changes are presented. If ``True``, this function will\n        return the of the changes made.\n        If ``False``, then it will return a boolean (``True`` if any changes\n        were made, otherwise False).\n\n    source: ``running``\n        The configuration source. Choose from: ``running``, ``candidate``, or\n        ``startup``. Default: ``running``.\n\n    path: ``None``\n        Save the temporary configuration to a specific path, then read from\n        there. This argument is optional, can be used when you prefers a\n        particular location of the temporary file.\n\n    test: ``False``\n        Dry run? If set as ``True``, will apply the config, discard and return\n        the changes. Default: ``False`` and will commit the changes on the\n        device.\n\n    commit: ``True``\n        Commit the configuration changes? Default: ``True``.\n\n    debug: ``False``\n        Debug mode. Will insert a new key in the output dictionary, as\n        ``loaded_config`` containing the raw configuration loaded on the device.\n\n    replace: ``True``\n        Load and replace the configuration. Default: ``True``.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.blockreplace 'ntp' 'interface' ''\n    \"\"\"\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    replace_pattern = __salt__['file.blockreplace'](path, marker_start=marker_start, marker_end=marker_end, content=content, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, show_changes=show_changes, append_newline=append_newline)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)",
        "mutated": [
            "def blockreplace(marker_start, marker_end, content='', append_if_not_found=False, prepend_if_not_found=False, show_changes=True, append_newline=False, source='running', path=None, test=False, commit=True, debug=False, replace=True):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Replace content of the configuration source, delimited by the line markers.\\n\\n    A block of content delimited by comments can help you manage several lines\\n    without worrying about old entries removal.\\n\\n    marker_start\\n        The line content identifying a line as the start of the content block.\\n        Note that the whole line containing this marker will be considered,\\n        so whitespace or extra content before or after the marker is included\\n        in final output.\\n\\n    marker_end\\n        The line content identifying a line as the end of the content block.\\n        Note that the whole line containing this marker will be considered,\\n        so whitespace or extra content before or after the marker is included\\n        in final output.\\n\\n    content\\n        The content to be used between the two lines identified by\\n        ``marker_start`` and ``marker_stop``.\\n\\n    append_if_not_found: ``False``\\n        If markers are not found and set to True then, the markers and content\\n        will be appended to the file.\\n\\n    prepend_if_not_found: ``False``\\n        If markers are not found and set to True then, the markers and content\\n        will be prepended to the file.\\n\\n    append_newline: ``False``\\n        Controls whether or not a newline is appended to the content block.\\n        If the value of this argument is ``True`` then a newline will be added\\n        to the content block. If it is ``False``, then a newline will not be\\n        added to the content block. If it is ``None`` then a newline will only\\n        be added to the content block if it does not already end in a newline.\\n\\n    show_changes: ``True``\\n        Controls how changes are presented. If ``True``, this function will\\n        return the of the changes made.\\n        If ``False``, then it will return a boolean (``True`` if any changes\\n        were made, otherwise False).\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path: ``None``\\n        Save the temporary configuration to a specific path, then read from\\n        there. This argument is optional, can be used when you prefers a\\n        particular location of the temporary file.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.blockreplace 'ntp' 'interface' ''\\n    \"\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    replace_pattern = __salt__['file.blockreplace'](path, marker_start=marker_start, marker_end=marker_end, content=content, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, show_changes=show_changes, append_newline=append_newline)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)",
            "def blockreplace(marker_start, marker_end, content='', append_if_not_found=False, prepend_if_not_found=False, show_changes=True, append_newline=False, source='running', path=None, test=False, commit=True, debug=False, replace=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Replace content of the configuration source, delimited by the line markers.\\n\\n    A block of content delimited by comments can help you manage several lines\\n    without worrying about old entries removal.\\n\\n    marker_start\\n        The line content identifying a line as the start of the content block.\\n        Note that the whole line containing this marker will be considered,\\n        so whitespace or extra content before or after the marker is included\\n        in final output.\\n\\n    marker_end\\n        The line content identifying a line as the end of the content block.\\n        Note that the whole line containing this marker will be considered,\\n        so whitespace or extra content before or after the marker is included\\n        in final output.\\n\\n    content\\n        The content to be used between the two lines identified by\\n        ``marker_start`` and ``marker_stop``.\\n\\n    append_if_not_found: ``False``\\n        If markers are not found and set to True then, the markers and content\\n        will be appended to the file.\\n\\n    prepend_if_not_found: ``False``\\n        If markers are not found and set to True then, the markers and content\\n        will be prepended to the file.\\n\\n    append_newline: ``False``\\n        Controls whether or not a newline is appended to the content block.\\n        If the value of this argument is ``True`` then a newline will be added\\n        to the content block. If it is ``False``, then a newline will not be\\n        added to the content block. If it is ``None`` then a newline will only\\n        be added to the content block if it does not already end in a newline.\\n\\n    show_changes: ``True``\\n        Controls how changes are presented. If ``True``, this function will\\n        return the of the changes made.\\n        If ``False``, then it will return a boolean (``True`` if any changes\\n        were made, otherwise False).\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path: ``None``\\n        Save the temporary configuration to a specific path, then read from\\n        there. This argument is optional, can be used when you prefers a\\n        particular location of the temporary file.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.blockreplace 'ntp' 'interface' ''\\n    \"\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    replace_pattern = __salt__['file.blockreplace'](path, marker_start=marker_start, marker_end=marker_end, content=content, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, show_changes=show_changes, append_newline=append_newline)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)",
            "def blockreplace(marker_start, marker_end, content='', append_if_not_found=False, prepend_if_not_found=False, show_changes=True, append_newline=False, source='running', path=None, test=False, commit=True, debug=False, replace=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Replace content of the configuration source, delimited by the line markers.\\n\\n    A block of content delimited by comments can help you manage several lines\\n    without worrying about old entries removal.\\n\\n    marker_start\\n        The line content identifying a line as the start of the content block.\\n        Note that the whole line containing this marker will be considered,\\n        so whitespace or extra content before or after the marker is included\\n        in final output.\\n\\n    marker_end\\n        The line content identifying a line as the end of the content block.\\n        Note that the whole line containing this marker will be considered,\\n        so whitespace or extra content before or after the marker is included\\n        in final output.\\n\\n    content\\n        The content to be used between the two lines identified by\\n        ``marker_start`` and ``marker_stop``.\\n\\n    append_if_not_found: ``False``\\n        If markers are not found and set to True then, the markers and content\\n        will be appended to the file.\\n\\n    prepend_if_not_found: ``False``\\n        If markers are not found and set to True then, the markers and content\\n        will be prepended to the file.\\n\\n    append_newline: ``False``\\n        Controls whether or not a newline is appended to the content block.\\n        If the value of this argument is ``True`` then a newline will be added\\n        to the content block. If it is ``False``, then a newline will not be\\n        added to the content block. If it is ``None`` then a newline will only\\n        be added to the content block if it does not already end in a newline.\\n\\n    show_changes: ``True``\\n        Controls how changes are presented. If ``True``, this function will\\n        return the of the changes made.\\n        If ``False``, then it will return a boolean (``True`` if any changes\\n        were made, otherwise False).\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path: ``None``\\n        Save the temporary configuration to a specific path, then read from\\n        there. This argument is optional, can be used when you prefers a\\n        particular location of the temporary file.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.blockreplace 'ntp' 'interface' ''\\n    \"\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    replace_pattern = __salt__['file.blockreplace'](path, marker_start=marker_start, marker_end=marker_end, content=content, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, show_changes=show_changes, append_newline=append_newline)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)",
            "def blockreplace(marker_start, marker_end, content='', append_if_not_found=False, prepend_if_not_found=False, show_changes=True, append_newline=False, source='running', path=None, test=False, commit=True, debug=False, replace=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Replace content of the configuration source, delimited by the line markers.\\n\\n    A block of content delimited by comments can help you manage several lines\\n    without worrying about old entries removal.\\n\\n    marker_start\\n        The line content identifying a line as the start of the content block.\\n        Note that the whole line containing this marker will be considered,\\n        so whitespace or extra content before or after the marker is included\\n        in final output.\\n\\n    marker_end\\n        The line content identifying a line as the end of the content block.\\n        Note that the whole line containing this marker will be considered,\\n        so whitespace or extra content before or after the marker is included\\n        in final output.\\n\\n    content\\n        The content to be used between the two lines identified by\\n        ``marker_start`` and ``marker_stop``.\\n\\n    append_if_not_found: ``False``\\n        If markers are not found and set to True then, the markers and content\\n        will be appended to the file.\\n\\n    prepend_if_not_found: ``False``\\n        If markers are not found and set to True then, the markers and content\\n        will be prepended to the file.\\n\\n    append_newline: ``False``\\n        Controls whether or not a newline is appended to the content block.\\n        If the value of this argument is ``True`` then a newline will be added\\n        to the content block. If it is ``False``, then a newline will not be\\n        added to the content block. If it is ``None`` then a newline will only\\n        be added to the content block if it does not already end in a newline.\\n\\n    show_changes: ``True``\\n        Controls how changes are presented. If ``True``, this function will\\n        return the of the changes made.\\n        If ``False``, then it will return a boolean (``True`` if any changes\\n        were made, otherwise False).\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path: ``None``\\n        Save the temporary configuration to a specific path, then read from\\n        there. This argument is optional, can be used when you prefers a\\n        particular location of the temporary file.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.blockreplace 'ntp' 'interface' ''\\n    \"\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    replace_pattern = __salt__['file.blockreplace'](path, marker_start=marker_start, marker_end=marker_end, content=content, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, show_changes=show_changes, append_newline=append_newline)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)",
            "def blockreplace(marker_start, marker_end, content='', append_if_not_found=False, prepend_if_not_found=False, show_changes=True, append_newline=False, source='running', path=None, test=False, commit=True, debug=False, replace=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Replace content of the configuration source, delimited by the line markers.\\n\\n    A block of content delimited by comments can help you manage several lines\\n    without worrying about old entries removal.\\n\\n    marker_start\\n        The line content identifying a line as the start of the content block.\\n        Note that the whole line containing this marker will be considered,\\n        so whitespace or extra content before or after the marker is included\\n        in final output.\\n\\n    marker_end\\n        The line content identifying a line as the end of the content block.\\n        Note that the whole line containing this marker will be considered,\\n        so whitespace or extra content before or after the marker is included\\n        in final output.\\n\\n    content\\n        The content to be used between the two lines identified by\\n        ``marker_start`` and ``marker_stop``.\\n\\n    append_if_not_found: ``False``\\n        If markers are not found and set to True then, the markers and content\\n        will be appended to the file.\\n\\n    prepend_if_not_found: ``False``\\n        If markers are not found and set to True then, the markers and content\\n        will be prepended to the file.\\n\\n    append_newline: ``False``\\n        Controls whether or not a newline is appended to the content block.\\n        If the value of this argument is ``True`` then a newline will be added\\n        to the content block. If it is ``False``, then a newline will not be\\n        added to the content block. If it is ``None`` then a newline will only\\n        be added to the content block if it does not already end in a newline.\\n\\n    show_changes: ``True``\\n        Controls how changes are presented. If ``True``, this function will\\n        return the of the changes made.\\n        If ``False``, then it will return a boolean (``True`` if any changes\\n        were made, otherwise False).\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path: ``None``\\n        Save the temporary configuration to a specific path, then read from\\n        there. This argument is optional, can be used when you prefers a\\n        particular location of the temporary file.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.blockreplace 'ntp' 'interface' ''\\n    \"\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    replace_pattern = __salt__['file.blockreplace'](path, marker_start=marker_start, marker_end=marker_end, content=content, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, show_changes=show_changes, append_newline=append_newline)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)"
        ]
    },
    {
        "func_name": "patch",
        "original": "def patch(patchfile, options='', saltenv='base', source_hash=None, show_changes=True, source='running', path=None, test=False, commit=True, debug=False, replace=True):\n    \"\"\"\n    .. versionadded:: 2019.2.0\n\n    Apply a patch to the configuration source, and load the result into the\n    running config of the device.\n\n    patchfile\n        A patch file to apply to the configuration source.\n\n    options\n        Options to pass to patch.\n\n    source_hash\n        If the patch file (specified via the ``patchfile`` argument)  is an\n        HTTP(S) or FTP URL and the file exists in the minion's file cache, this\n        option can be passed to keep the minion from re-downloading the file if\n        the cached copy matches the specified hash.\n\n    show_changes: ``True``\n        Controls how changes are presented. If ``True``, this function will\n        return the of the changes made.\n        If ``False``, then it will return a boolean (``True`` if any changes\n        were made, otherwise False).\n\n    source: ``running``\n        The configuration source. Choose from: ``running``, ``candidate``, or\n        ``startup``. Default: ``running``.\n\n    path: ``None``\n        Save the temporary configuration to a specific path, then read from\n        there. This argument is optional, can the user prefers a particular\n        location of the temporary file.\n\n    test: ``False``\n        Dry run? If set as ``True``, will apply the config, discard and return\n        the changes. Default: ``False`` and will commit the changes on the\n        device.\n\n    commit: ``True``\n        Commit the configuration changes? Default: ``True``.\n\n    debug: ``False``\n        Debug mode. Will insert a new key in the output dictionary, as\n        ``loaded_config`` containing the raw configuration loaded on the device.\n\n    replace: ``True``\n        Load and replace the configuration. Default: ``True``.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' net.patch https://example.com/running_config.patch\n    \"\"\"\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    patchfile_cache = __salt__['cp.cache_file'](patchfile)\n    if patchfile_cache is False:\n        return {'out': None, 'result': False, 'comment': 'The file \"{}\" does not exist.'.format(patchfile)}\n    replace_pattern = __salt__['file.patch'](path, patchfile_cache, options=options)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)",
        "mutated": [
            "def patch(patchfile, options='', saltenv='base', source_hash=None, show_changes=True, source='running', path=None, test=False, commit=True, debug=False, replace=True):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Apply a patch to the configuration source, and load the result into the\\n    running config of the device.\\n\\n    patchfile\\n        A patch file to apply to the configuration source.\\n\\n    options\\n        Options to pass to patch.\\n\\n    source_hash\\n        If the patch file (specified via the ``patchfile`` argument)  is an\\n        HTTP(S) or FTP URL and the file exists in the minion's file cache, this\\n        option can be passed to keep the minion from re-downloading the file if\\n        the cached copy matches the specified hash.\\n\\n    show_changes: ``True``\\n        Controls how changes are presented. If ``True``, this function will\\n        return the of the changes made.\\n        If ``False``, then it will return a boolean (``True`` if any changes\\n        were made, otherwise False).\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path: ``None``\\n        Save the temporary configuration to a specific path, then read from\\n        there. This argument is optional, can the user prefers a particular\\n        location of the temporary file.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.patch https://example.com/running_config.patch\\n    \"\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    patchfile_cache = __salt__['cp.cache_file'](patchfile)\n    if patchfile_cache is False:\n        return {'out': None, 'result': False, 'comment': 'The file \"{}\" does not exist.'.format(patchfile)}\n    replace_pattern = __salt__['file.patch'](path, patchfile_cache, options=options)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)",
            "def patch(patchfile, options='', saltenv='base', source_hash=None, show_changes=True, source='running', path=None, test=False, commit=True, debug=False, replace=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Apply a patch to the configuration source, and load the result into the\\n    running config of the device.\\n\\n    patchfile\\n        A patch file to apply to the configuration source.\\n\\n    options\\n        Options to pass to patch.\\n\\n    source_hash\\n        If the patch file (specified via the ``patchfile`` argument)  is an\\n        HTTP(S) or FTP URL and the file exists in the minion's file cache, this\\n        option can be passed to keep the minion from re-downloading the file if\\n        the cached copy matches the specified hash.\\n\\n    show_changes: ``True``\\n        Controls how changes are presented. If ``True``, this function will\\n        return the of the changes made.\\n        If ``False``, then it will return a boolean (``True`` if any changes\\n        were made, otherwise False).\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path: ``None``\\n        Save the temporary configuration to a specific path, then read from\\n        there. This argument is optional, can the user prefers a particular\\n        location of the temporary file.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.patch https://example.com/running_config.patch\\n    \"\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    patchfile_cache = __salt__['cp.cache_file'](patchfile)\n    if patchfile_cache is False:\n        return {'out': None, 'result': False, 'comment': 'The file \"{}\" does not exist.'.format(patchfile)}\n    replace_pattern = __salt__['file.patch'](path, patchfile_cache, options=options)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)",
            "def patch(patchfile, options='', saltenv='base', source_hash=None, show_changes=True, source='running', path=None, test=False, commit=True, debug=False, replace=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Apply a patch to the configuration source, and load the result into the\\n    running config of the device.\\n\\n    patchfile\\n        A patch file to apply to the configuration source.\\n\\n    options\\n        Options to pass to patch.\\n\\n    source_hash\\n        If the patch file (specified via the ``patchfile`` argument)  is an\\n        HTTP(S) or FTP URL and the file exists in the minion's file cache, this\\n        option can be passed to keep the minion from re-downloading the file if\\n        the cached copy matches the specified hash.\\n\\n    show_changes: ``True``\\n        Controls how changes are presented. If ``True``, this function will\\n        return the of the changes made.\\n        If ``False``, then it will return a boolean (``True`` if any changes\\n        were made, otherwise False).\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path: ``None``\\n        Save the temporary configuration to a specific path, then read from\\n        there. This argument is optional, can the user prefers a particular\\n        location of the temporary file.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.patch https://example.com/running_config.patch\\n    \"\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    patchfile_cache = __salt__['cp.cache_file'](patchfile)\n    if patchfile_cache is False:\n        return {'out': None, 'result': False, 'comment': 'The file \"{}\" does not exist.'.format(patchfile)}\n    replace_pattern = __salt__['file.patch'](path, patchfile_cache, options=options)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)",
            "def patch(patchfile, options='', saltenv='base', source_hash=None, show_changes=True, source='running', path=None, test=False, commit=True, debug=False, replace=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Apply a patch to the configuration source, and load the result into the\\n    running config of the device.\\n\\n    patchfile\\n        A patch file to apply to the configuration source.\\n\\n    options\\n        Options to pass to patch.\\n\\n    source_hash\\n        If the patch file (specified via the ``patchfile`` argument)  is an\\n        HTTP(S) or FTP URL and the file exists in the minion's file cache, this\\n        option can be passed to keep the minion from re-downloading the file if\\n        the cached copy matches the specified hash.\\n\\n    show_changes: ``True``\\n        Controls how changes are presented. If ``True``, this function will\\n        return the of the changes made.\\n        If ``False``, then it will return a boolean (``True`` if any changes\\n        were made, otherwise False).\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path: ``None``\\n        Save the temporary configuration to a specific path, then read from\\n        there. This argument is optional, can the user prefers a particular\\n        location of the temporary file.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.patch https://example.com/running_config.patch\\n    \"\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    patchfile_cache = __salt__['cp.cache_file'](patchfile)\n    if patchfile_cache is False:\n        return {'out': None, 'result': False, 'comment': 'The file \"{}\" does not exist.'.format(patchfile)}\n    replace_pattern = __salt__['file.patch'](path, patchfile_cache, options=options)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)",
            "def patch(patchfile, options='', saltenv='base', source_hash=None, show_changes=True, source='running', path=None, test=False, commit=True, debug=False, replace=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Apply a patch to the configuration source, and load the result into the\\n    running config of the device.\\n\\n    patchfile\\n        A patch file to apply to the configuration source.\\n\\n    options\\n        Options to pass to patch.\\n\\n    source_hash\\n        If the patch file (specified via the ``patchfile`` argument)  is an\\n        HTTP(S) or FTP URL and the file exists in the minion's file cache, this\\n        option can be passed to keep the minion from re-downloading the file if\\n        the cached copy matches the specified hash.\\n\\n    show_changes: ``True``\\n        Controls how changes are presented. If ``True``, this function will\\n        return the of the changes made.\\n        If ``False``, then it will return a boolean (``True`` if any changes\\n        were made, otherwise False).\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path: ``None``\\n        Save the temporary configuration to a specific path, then read from\\n        there. This argument is optional, can the user prefers a particular\\n        location of the temporary file.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' net.patch https://example.com/running_config.patch\\n    \"\n    config_saved = save_config(source=source, path=path)\n    if not config_saved or not config_saved['result']:\n        return config_saved\n    path = config_saved['out']\n    patchfile_cache = __salt__['cp.cache_file'](patchfile)\n    if patchfile_cache is False:\n        return {'out': None, 'result': False, 'comment': 'The file \"{}\" does not exist.'.format(patchfile)}\n    replace_pattern = __salt__['file.patch'](path, patchfile_cache, options=options)\n    with salt.utils.files.fopen(path, 'r') as fh_:\n        updated_config = fh_.read()\n    return __salt__['net.load_config'](text=updated_config, test=test, debug=debug, replace=replace, commit=commit)"
        ]
    }
]