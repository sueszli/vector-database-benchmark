[
    {
        "func_name": "delete_last_index_files",
        "original": "def delete_last_index_files(folder_path):\n    files = os.listdir(folder_path)\n    latest_indices = {}\n    for filename in files:\n        (prefix, index) = (filename.split('put')[0], int(filename.split('put')[1].split('.')[0]))\n        if prefix not in latest_indices or index > latest_indices[prefix]:\n            latest_indices[prefix] = index\n    highest_prefix = max(latest_indices, key=lambda key: (latest_indices[key], key))\n    highest_index = latest_indices[highest_prefix]\n    file_to_delete = f'{highest_prefix}put{highest_index}.mp4'\n    file_path = os.path.join(folder_path, file_to_delete)\n    if os.path.exists(file_path):\n        os.remove(file_path)\n        print(f'Deleted: {file_to_delete}')\n    else:\n        print(f'File not found: {file_to_delete}')",
        "mutated": [
            "def delete_last_index_files(folder_path):\n    if False:\n        i = 10\n    files = os.listdir(folder_path)\n    latest_indices = {}\n    for filename in files:\n        (prefix, index) = (filename.split('put')[0], int(filename.split('put')[1].split('.')[0]))\n        if prefix not in latest_indices or index > latest_indices[prefix]:\n            latest_indices[prefix] = index\n    highest_prefix = max(latest_indices, key=lambda key: (latest_indices[key], key))\n    highest_index = latest_indices[highest_prefix]\n    file_to_delete = f'{highest_prefix}put{highest_index}.mp4'\n    file_path = os.path.join(folder_path, file_to_delete)\n    if os.path.exists(file_path):\n        os.remove(file_path)\n        print(f'Deleted: {file_to_delete}')\n    else:\n        print(f'File not found: {file_to_delete}')",
            "def delete_last_index_files(folder_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    files = os.listdir(folder_path)\n    latest_indices = {}\n    for filename in files:\n        (prefix, index) = (filename.split('put')[0], int(filename.split('put')[1].split('.')[0]))\n        if prefix not in latest_indices or index > latest_indices[prefix]:\n            latest_indices[prefix] = index\n    highest_prefix = max(latest_indices, key=lambda key: (latest_indices[key], key))\n    highest_index = latest_indices[highest_prefix]\n    file_to_delete = f'{highest_prefix}put{highest_index}.mp4'\n    file_path = os.path.join(folder_path, file_to_delete)\n    if os.path.exists(file_path):\n        os.remove(file_path)\n        print(f'Deleted: {file_to_delete}')\n    else:\n        print(f'File not found: {file_to_delete}')",
            "def delete_last_index_files(folder_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    files = os.listdir(folder_path)\n    latest_indices = {}\n    for filename in files:\n        (prefix, index) = (filename.split('put')[0], int(filename.split('put')[1].split('.')[0]))\n        if prefix not in latest_indices or index > latest_indices[prefix]:\n            latest_indices[prefix] = index\n    highest_prefix = max(latest_indices, key=lambda key: (latest_indices[key], key))\n    highest_index = latest_indices[highest_prefix]\n    file_to_delete = f'{highest_prefix}put{highest_index}.mp4'\n    file_path = os.path.join(folder_path, file_to_delete)\n    if os.path.exists(file_path):\n        os.remove(file_path)\n        print(f'Deleted: {file_to_delete}')\n    else:\n        print(f'File not found: {file_to_delete}')",
            "def delete_last_index_files(folder_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    files = os.listdir(folder_path)\n    latest_indices = {}\n    for filename in files:\n        (prefix, index) = (filename.split('put')[0], int(filename.split('put')[1].split('.')[0]))\n        if prefix not in latest_indices or index > latest_indices[prefix]:\n            latest_indices[prefix] = index\n    highest_prefix = max(latest_indices, key=lambda key: (latest_indices[key], key))\n    highest_index = latest_indices[highest_prefix]\n    file_to_delete = f'{highest_prefix}put{highest_index}.mp4'\n    file_path = os.path.join(folder_path, file_to_delete)\n    if os.path.exists(file_path):\n        os.remove(file_path)\n        print(f'Deleted: {file_to_delete}')\n    else:\n        print(f'File not found: {file_to_delete}')",
            "def delete_last_index_files(folder_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    files = os.listdir(folder_path)\n    latest_indices = {}\n    for filename in files:\n        (prefix, index) = (filename.split('put')[0], int(filename.split('put')[1].split('.')[0]))\n        if prefix not in latest_indices or index > latest_indices[prefix]:\n            latest_indices[prefix] = index\n    highest_prefix = max(latest_indices, key=lambda key: (latest_indices[key], key))\n    highest_index = latest_indices[highest_prefix]\n    file_to_delete = f'{highest_prefix}put{highest_index}.mp4'\n    file_path = os.path.join(folder_path, file_to_delete)\n    if os.path.exists(file_path):\n        os.remove(file_path)\n        print(f'Deleted: {file_to_delete}')\n    else:\n        print(f'File not found: {file_to_delete}')"
        ]
    },
    {
        "func_name": "record_from_video",
        "original": "def record_from_video(input_video_path, output_dir, out_prefix):\n    mp_drawing = mp.solutions.drawing_utils\n    mp_hands = mp.solutions.hands\n    cap = cv2.VideoCapture(input_video_path)\n    with mp_hands.Hands(min_detection_confidence=0.75, min_tracking_confidence=0.75) as hands:\n        is_recording = False\n        recording_count = 1\n        no_hand_count = 0\n        recording_delay = 20\n        os.makedirs(output_dir, exist_ok=True)\n        start_time_left = None\n        start_time_right = None\n        stop_timer_left = False\n        stop_timer_right = False\n        corner_position = None\n        put_count = 1\n        index_reset = False\n        last_saved_video = None\n        while True:\n            (ret, frame) = cap.read()\n            if not ret:\n                break\n            image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n            results = hands.process(image)\n            if results.multi_hand_landmarks:\n                for hand_landmarks in results.multi_hand_landmarks:\n                    mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)\n                index_finger_tip_landmark = results.multi_hand_landmarks[0].landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP]\n                (height, width, _) = image.shape\n                corner_boundary = int(min(height, width) * 0.25)\n                if index_finger_tip_landmark.x * width < corner_boundary and index_finger_tip_landmark.y * height < corner_boundary:\n                    if not stop_timer_left:\n                        start_time_left = time.time()\n                        stop_timer_left = True\n                        corner_position = 'top_left'\n                        index_reset = False\n                    else:\n                        elapsed_time = time.time() - start_time_left\n                        if elapsed_time >= 0.75:\n                            if is_recording:\n                                out.release()\n                                if last_saved_video != f'{out_prefix}put{recording_count - 1}.mp4':\n                                    print(f'Saved recording {out_prefix}put{recording_count - 1}.mp4')\n                                    last_saved_video = f'{out_prefix}put{recording_count - 1}.mp4'\n                                else:\n                                    os.remove(os.path.join(output_dir, last_saved_video))\n                                    print(f'Discarded recording {last_saved_video}')\n                                no_hand_count = 0\n                                break\n                else:\n                    stop_timer_left = False\n                if not is_recording:\n                    is_recording = True\n                    output_path = os.path.join(output_dir, f'{out_prefix}put{recording_count}.mp4')\n                    out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*'mp4v'), 30, (frame.shape[1], frame.shape[0]))\n                    print(f'Started recording {output_path}')\n                    recording_count += 1\n                    last_saved_video = None\n            elif is_recording:\n                no_hand_count += 1\n                if no_hand_count >= recording_delay:\n                    is_recording = False\n                    out.release()\n                    print(f'Stopped recording {out_prefix}put{recording_count - 1}.mp4')\n                    no_hand_count = 0\n            if is_recording:\n                out.write(frame)\n            cv2.imshow('Hand Tracking', image)\n            if cv2.waitKey(1) & 255 == ord('q'):\n                if is_recording:\n                    out.release()\n                break\n        cap.release()\n        cv2.destroyAllWindows()",
        "mutated": [
            "def record_from_video(input_video_path, output_dir, out_prefix):\n    if False:\n        i = 10\n    mp_drawing = mp.solutions.drawing_utils\n    mp_hands = mp.solutions.hands\n    cap = cv2.VideoCapture(input_video_path)\n    with mp_hands.Hands(min_detection_confidence=0.75, min_tracking_confidence=0.75) as hands:\n        is_recording = False\n        recording_count = 1\n        no_hand_count = 0\n        recording_delay = 20\n        os.makedirs(output_dir, exist_ok=True)\n        start_time_left = None\n        start_time_right = None\n        stop_timer_left = False\n        stop_timer_right = False\n        corner_position = None\n        put_count = 1\n        index_reset = False\n        last_saved_video = None\n        while True:\n            (ret, frame) = cap.read()\n            if not ret:\n                break\n            image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n            results = hands.process(image)\n            if results.multi_hand_landmarks:\n                for hand_landmarks in results.multi_hand_landmarks:\n                    mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)\n                index_finger_tip_landmark = results.multi_hand_landmarks[0].landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP]\n                (height, width, _) = image.shape\n                corner_boundary = int(min(height, width) * 0.25)\n                if index_finger_tip_landmark.x * width < corner_boundary and index_finger_tip_landmark.y * height < corner_boundary:\n                    if not stop_timer_left:\n                        start_time_left = time.time()\n                        stop_timer_left = True\n                        corner_position = 'top_left'\n                        index_reset = False\n                    else:\n                        elapsed_time = time.time() - start_time_left\n                        if elapsed_time >= 0.75:\n                            if is_recording:\n                                out.release()\n                                if last_saved_video != f'{out_prefix}put{recording_count - 1}.mp4':\n                                    print(f'Saved recording {out_prefix}put{recording_count - 1}.mp4')\n                                    last_saved_video = f'{out_prefix}put{recording_count - 1}.mp4'\n                                else:\n                                    os.remove(os.path.join(output_dir, last_saved_video))\n                                    print(f'Discarded recording {last_saved_video}')\n                                no_hand_count = 0\n                                break\n                else:\n                    stop_timer_left = False\n                if not is_recording:\n                    is_recording = True\n                    output_path = os.path.join(output_dir, f'{out_prefix}put{recording_count}.mp4')\n                    out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*'mp4v'), 30, (frame.shape[1], frame.shape[0]))\n                    print(f'Started recording {output_path}')\n                    recording_count += 1\n                    last_saved_video = None\n            elif is_recording:\n                no_hand_count += 1\n                if no_hand_count >= recording_delay:\n                    is_recording = False\n                    out.release()\n                    print(f'Stopped recording {out_prefix}put{recording_count - 1}.mp4')\n                    no_hand_count = 0\n            if is_recording:\n                out.write(frame)\n            cv2.imshow('Hand Tracking', image)\n            if cv2.waitKey(1) & 255 == ord('q'):\n                if is_recording:\n                    out.release()\n                break\n        cap.release()\n        cv2.destroyAllWindows()",
            "def record_from_video(input_video_path, output_dir, out_prefix):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mp_drawing = mp.solutions.drawing_utils\n    mp_hands = mp.solutions.hands\n    cap = cv2.VideoCapture(input_video_path)\n    with mp_hands.Hands(min_detection_confidence=0.75, min_tracking_confidence=0.75) as hands:\n        is_recording = False\n        recording_count = 1\n        no_hand_count = 0\n        recording_delay = 20\n        os.makedirs(output_dir, exist_ok=True)\n        start_time_left = None\n        start_time_right = None\n        stop_timer_left = False\n        stop_timer_right = False\n        corner_position = None\n        put_count = 1\n        index_reset = False\n        last_saved_video = None\n        while True:\n            (ret, frame) = cap.read()\n            if not ret:\n                break\n            image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n            results = hands.process(image)\n            if results.multi_hand_landmarks:\n                for hand_landmarks in results.multi_hand_landmarks:\n                    mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)\n                index_finger_tip_landmark = results.multi_hand_landmarks[0].landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP]\n                (height, width, _) = image.shape\n                corner_boundary = int(min(height, width) * 0.25)\n                if index_finger_tip_landmark.x * width < corner_boundary and index_finger_tip_landmark.y * height < corner_boundary:\n                    if not stop_timer_left:\n                        start_time_left = time.time()\n                        stop_timer_left = True\n                        corner_position = 'top_left'\n                        index_reset = False\n                    else:\n                        elapsed_time = time.time() - start_time_left\n                        if elapsed_time >= 0.75:\n                            if is_recording:\n                                out.release()\n                                if last_saved_video != f'{out_prefix}put{recording_count - 1}.mp4':\n                                    print(f'Saved recording {out_prefix}put{recording_count - 1}.mp4')\n                                    last_saved_video = f'{out_prefix}put{recording_count - 1}.mp4'\n                                else:\n                                    os.remove(os.path.join(output_dir, last_saved_video))\n                                    print(f'Discarded recording {last_saved_video}')\n                                no_hand_count = 0\n                                break\n                else:\n                    stop_timer_left = False\n                if not is_recording:\n                    is_recording = True\n                    output_path = os.path.join(output_dir, f'{out_prefix}put{recording_count}.mp4')\n                    out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*'mp4v'), 30, (frame.shape[1], frame.shape[0]))\n                    print(f'Started recording {output_path}')\n                    recording_count += 1\n                    last_saved_video = None\n            elif is_recording:\n                no_hand_count += 1\n                if no_hand_count >= recording_delay:\n                    is_recording = False\n                    out.release()\n                    print(f'Stopped recording {out_prefix}put{recording_count - 1}.mp4')\n                    no_hand_count = 0\n            if is_recording:\n                out.write(frame)\n            cv2.imshow('Hand Tracking', image)\n            if cv2.waitKey(1) & 255 == ord('q'):\n                if is_recording:\n                    out.release()\n                break\n        cap.release()\n        cv2.destroyAllWindows()",
            "def record_from_video(input_video_path, output_dir, out_prefix):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mp_drawing = mp.solutions.drawing_utils\n    mp_hands = mp.solutions.hands\n    cap = cv2.VideoCapture(input_video_path)\n    with mp_hands.Hands(min_detection_confidence=0.75, min_tracking_confidence=0.75) as hands:\n        is_recording = False\n        recording_count = 1\n        no_hand_count = 0\n        recording_delay = 20\n        os.makedirs(output_dir, exist_ok=True)\n        start_time_left = None\n        start_time_right = None\n        stop_timer_left = False\n        stop_timer_right = False\n        corner_position = None\n        put_count = 1\n        index_reset = False\n        last_saved_video = None\n        while True:\n            (ret, frame) = cap.read()\n            if not ret:\n                break\n            image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n            results = hands.process(image)\n            if results.multi_hand_landmarks:\n                for hand_landmarks in results.multi_hand_landmarks:\n                    mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)\n                index_finger_tip_landmark = results.multi_hand_landmarks[0].landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP]\n                (height, width, _) = image.shape\n                corner_boundary = int(min(height, width) * 0.25)\n                if index_finger_tip_landmark.x * width < corner_boundary and index_finger_tip_landmark.y * height < corner_boundary:\n                    if not stop_timer_left:\n                        start_time_left = time.time()\n                        stop_timer_left = True\n                        corner_position = 'top_left'\n                        index_reset = False\n                    else:\n                        elapsed_time = time.time() - start_time_left\n                        if elapsed_time >= 0.75:\n                            if is_recording:\n                                out.release()\n                                if last_saved_video != f'{out_prefix}put{recording_count - 1}.mp4':\n                                    print(f'Saved recording {out_prefix}put{recording_count - 1}.mp4')\n                                    last_saved_video = f'{out_prefix}put{recording_count - 1}.mp4'\n                                else:\n                                    os.remove(os.path.join(output_dir, last_saved_video))\n                                    print(f'Discarded recording {last_saved_video}')\n                                no_hand_count = 0\n                                break\n                else:\n                    stop_timer_left = False\n                if not is_recording:\n                    is_recording = True\n                    output_path = os.path.join(output_dir, f'{out_prefix}put{recording_count}.mp4')\n                    out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*'mp4v'), 30, (frame.shape[1], frame.shape[0]))\n                    print(f'Started recording {output_path}')\n                    recording_count += 1\n                    last_saved_video = None\n            elif is_recording:\n                no_hand_count += 1\n                if no_hand_count >= recording_delay:\n                    is_recording = False\n                    out.release()\n                    print(f'Stopped recording {out_prefix}put{recording_count - 1}.mp4')\n                    no_hand_count = 0\n            if is_recording:\n                out.write(frame)\n            cv2.imshow('Hand Tracking', image)\n            if cv2.waitKey(1) & 255 == ord('q'):\n                if is_recording:\n                    out.release()\n                break\n        cap.release()\n        cv2.destroyAllWindows()",
            "def record_from_video(input_video_path, output_dir, out_prefix):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mp_drawing = mp.solutions.drawing_utils\n    mp_hands = mp.solutions.hands\n    cap = cv2.VideoCapture(input_video_path)\n    with mp_hands.Hands(min_detection_confidence=0.75, min_tracking_confidence=0.75) as hands:\n        is_recording = False\n        recording_count = 1\n        no_hand_count = 0\n        recording_delay = 20\n        os.makedirs(output_dir, exist_ok=True)\n        start_time_left = None\n        start_time_right = None\n        stop_timer_left = False\n        stop_timer_right = False\n        corner_position = None\n        put_count = 1\n        index_reset = False\n        last_saved_video = None\n        while True:\n            (ret, frame) = cap.read()\n            if not ret:\n                break\n            image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n            results = hands.process(image)\n            if results.multi_hand_landmarks:\n                for hand_landmarks in results.multi_hand_landmarks:\n                    mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)\n                index_finger_tip_landmark = results.multi_hand_landmarks[0].landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP]\n                (height, width, _) = image.shape\n                corner_boundary = int(min(height, width) * 0.25)\n                if index_finger_tip_landmark.x * width < corner_boundary and index_finger_tip_landmark.y * height < corner_boundary:\n                    if not stop_timer_left:\n                        start_time_left = time.time()\n                        stop_timer_left = True\n                        corner_position = 'top_left'\n                        index_reset = False\n                    else:\n                        elapsed_time = time.time() - start_time_left\n                        if elapsed_time >= 0.75:\n                            if is_recording:\n                                out.release()\n                                if last_saved_video != f'{out_prefix}put{recording_count - 1}.mp4':\n                                    print(f'Saved recording {out_prefix}put{recording_count - 1}.mp4')\n                                    last_saved_video = f'{out_prefix}put{recording_count - 1}.mp4'\n                                else:\n                                    os.remove(os.path.join(output_dir, last_saved_video))\n                                    print(f'Discarded recording {last_saved_video}')\n                                no_hand_count = 0\n                                break\n                else:\n                    stop_timer_left = False\n                if not is_recording:\n                    is_recording = True\n                    output_path = os.path.join(output_dir, f'{out_prefix}put{recording_count}.mp4')\n                    out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*'mp4v'), 30, (frame.shape[1], frame.shape[0]))\n                    print(f'Started recording {output_path}')\n                    recording_count += 1\n                    last_saved_video = None\n            elif is_recording:\n                no_hand_count += 1\n                if no_hand_count >= recording_delay:\n                    is_recording = False\n                    out.release()\n                    print(f'Stopped recording {out_prefix}put{recording_count - 1}.mp4')\n                    no_hand_count = 0\n            if is_recording:\n                out.write(frame)\n            cv2.imshow('Hand Tracking', image)\n            if cv2.waitKey(1) & 255 == ord('q'):\n                if is_recording:\n                    out.release()\n                break\n        cap.release()\n        cv2.destroyAllWindows()",
            "def record_from_video(input_video_path, output_dir, out_prefix):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mp_drawing = mp.solutions.drawing_utils\n    mp_hands = mp.solutions.hands\n    cap = cv2.VideoCapture(input_video_path)\n    with mp_hands.Hands(min_detection_confidence=0.75, min_tracking_confidence=0.75) as hands:\n        is_recording = False\n        recording_count = 1\n        no_hand_count = 0\n        recording_delay = 20\n        os.makedirs(output_dir, exist_ok=True)\n        start_time_left = None\n        start_time_right = None\n        stop_timer_left = False\n        stop_timer_right = False\n        corner_position = None\n        put_count = 1\n        index_reset = False\n        last_saved_video = None\n        while True:\n            (ret, frame) = cap.read()\n            if not ret:\n                break\n            image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n            results = hands.process(image)\n            if results.multi_hand_landmarks:\n                for hand_landmarks in results.multi_hand_landmarks:\n                    mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)\n                index_finger_tip_landmark = results.multi_hand_landmarks[0].landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP]\n                (height, width, _) = image.shape\n                corner_boundary = int(min(height, width) * 0.25)\n                if index_finger_tip_landmark.x * width < corner_boundary and index_finger_tip_landmark.y * height < corner_boundary:\n                    if not stop_timer_left:\n                        start_time_left = time.time()\n                        stop_timer_left = True\n                        corner_position = 'top_left'\n                        index_reset = False\n                    else:\n                        elapsed_time = time.time() - start_time_left\n                        if elapsed_time >= 0.75:\n                            if is_recording:\n                                out.release()\n                                if last_saved_video != f'{out_prefix}put{recording_count - 1}.mp4':\n                                    print(f'Saved recording {out_prefix}put{recording_count - 1}.mp4')\n                                    last_saved_video = f'{out_prefix}put{recording_count - 1}.mp4'\n                                else:\n                                    os.remove(os.path.join(output_dir, last_saved_video))\n                                    print(f'Discarded recording {last_saved_video}')\n                                no_hand_count = 0\n                                break\n                else:\n                    stop_timer_left = False\n                if not is_recording:\n                    is_recording = True\n                    output_path = os.path.join(output_dir, f'{out_prefix}put{recording_count}.mp4')\n                    out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*'mp4v'), 30, (frame.shape[1], frame.shape[0]))\n                    print(f'Started recording {output_path}')\n                    recording_count += 1\n                    last_saved_video = None\n            elif is_recording:\n                no_hand_count += 1\n                if no_hand_count >= recording_delay:\n                    is_recording = False\n                    out.release()\n                    print(f'Stopped recording {out_prefix}put{recording_count - 1}.mp4')\n                    no_hand_count = 0\n            if is_recording:\n                out.write(frame)\n            cv2.imshow('Hand Tracking', image)\n            if cv2.waitKey(1) & 255 == ord('q'):\n                if is_recording:\n                    out.release()\n                break\n        cap.release()\n        cv2.destroyAllWindows()"
        ]
    },
    {
        "func_name": "count_videos_per_prefix",
        "original": "def count_videos_per_prefix(folder_path):\n    files = os.listdir(folder_path)\n    video_counts = {}\n    for filename in files:\n        if filename.endswith('.mp4'):\n            prefix = filename.split('put')[0]\n            video_counts[prefix] = video_counts.get(prefix, 0) + 1\n    video_counts_list = [video_counts.get(prefix, 0) for prefix in sorted(set(video_counts.keys()))]\n    return video_counts_list",
        "mutated": [
            "def count_videos_per_prefix(folder_path):\n    if False:\n        i = 10\n    files = os.listdir(folder_path)\n    video_counts = {}\n    for filename in files:\n        if filename.endswith('.mp4'):\n            prefix = filename.split('put')[0]\n            video_counts[prefix] = video_counts.get(prefix, 0) + 1\n    video_counts_list = [video_counts.get(prefix, 0) for prefix in sorted(set(video_counts.keys()))]\n    return video_counts_list",
            "def count_videos_per_prefix(folder_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    files = os.listdir(folder_path)\n    video_counts = {}\n    for filename in files:\n        if filename.endswith('.mp4'):\n            prefix = filename.split('put')[0]\n            video_counts[prefix] = video_counts.get(prefix, 0) + 1\n    video_counts_list = [video_counts.get(prefix, 0) for prefix in sorted(set(video_counts.keys()))]\n    return video_counts_list",
            "def count_videos_per_prefix(folder_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    files = os.listdir(folder_path)\n    video_counts = {}\n    for filename in files:\n        if filename.endswith('.mp4'):\n            prefix = filename.split('put')[0]\n            video_counts[prefix] = video_counts.get(prefix, 0) + 1\n    video_counts_list = [video_counts.get(prefix, 0) for prefix in sorted(set(video_counts.keys()))]\n    return video_counts_list",
            "def count_videos_per_prefix(folder_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    files = os.listdir(folder_path)\n    video_counts = {}\n    for filename in files:\n        if filename.endswith('.mp4'):\n            prefix = filename.split('put')[0]\n            video_counts[prefix] = video_counts.get(prefix, 0) + 1\n    video_counts_list = [video_counts.get(prefix, 0) for prefix in sorted(set(video_counts.keys()))]\n    return video_counts_list",
            "def count_videos_per_prefix(folder_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    files = os.listdir(folder_path)\n    video_counts = {}\n    for filename in files:\n        if filename.endswith('.mp4'):\n            prefix = filename.split('put')[0]\n            video_counts[prefix] = video_counts.get(prefix, 0) + 1\n    video_counts_list = [video_counts.get(prefix, 0) for prefix in sorted(set(video_counts.keys()))]\n    return video_counts_list"
        ]
    },
    {
        "func_name": "record_delete_from_video",
        "original": "def record_delete_from_video(input_video_path, output_dir, out_prefix):\n    record_from_video(input_video_path, output_dir, out_prefix)\n    os.remove(input_video_path)\n    delete_last_index_files(output_dir)\n    video_counts_list = count_videos_per_prefix(output_dir)\n    return video_counts_list",
        "mutated": [
            "def record_delete_from_video(input_video_path, output_dir, out_prefix):\n    if False:\n        i = 10\n    record_from_video(input_video_path, output_dir, out_prefix)\n    os.remove(input_video_path)\n    delete_last_index_files(output_dir)\n    video_counts_list = count_videos_per_prefix(output_dir)\n    return video_counts_list",
            "def record_delete_from_video(input_video_path, output_dir, out_prefix):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    record_from_video(input_video_path, output_dir, out_prefix)\n    os.remove(input_video_path)\n    delete_last_index_files(output_dir)\n    video_counts_list = count_videos_per_prefix(output_dir)\n    return video_counts_list",
            "def record_delete_from_video(input_video_path, output_dir, out_prefix):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    record_from_video(input_video_path, output_dir, out_prefix)\n    os.remove(input_video_path)\n    delete_last_index_files(output_dir)\n    video_counts_list = count_videos_per_prefix(output_dir)\n    return video_counts_list",
            "def record_delete_from_video(input_video_path, output_dir, out_prefix):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    record_from_video(input_video_path, output_dir, out_prefix)\n    os.remove(input_video_path)\n    delete_last_index_files(output_dir)\n    video_counts_list = count_videos_per_prefix(output_dir)\n    return video_counts_list",
            "def record_delete_from_video(input_video_path, output_dir, out_prefix):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    record_from_video(input_video_path, output_dir, out_prefix)\n    os.remove(input_video_path)\n    delete_last_index_files(output_dir)\n    video_counts_list = count_videos_per_prefix(output_dir)\n    return video_counts_list"
        ]
    }
]