"""
Block Recurrent Neural Networks
-------------------------------
"""
from typing import List, Optional, Tuple, Union
import torch
import torch.nn as nn
from darts.logging import get_logger, raise_if_not
from darts.models.forecasting.pl_forecasting_module import PLPastCovariatesModule, io_processor
from darts.models.forecasting.torch_forecasting_model import PastCovariatesTorchModel
logger = get_logger(__name__)

class _BlockRNNModule(PLPastCovariatesModule):

    def __init__(self, name: str, input_size: int, hidden_dim: int, num_layers: int, target_size: int, nr_params: int, num_layers_out_fc: Optional[List]=None, dropout: float=0.0, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        'PyTorch module implementing a block RNN to be used in `BlockRNNModel`.\n\n        PyTorch module implementing a simple block RNN with the specified `name` layer.\n        This module combines a PyTorch RNN module, together with a fully connected network, which maps the\n        last hidden layers to output of the desired size `output_chunk_length` and makes it compatible with\n        `BlockRNNModel`s.\n\n        This module uses an RNN to encode the input sequence, and subsequently uses a fully connected\n        network as the decoder which takes as input the last hidden state of the encoder RNN.\n        The final output of the decoder is a sequence of length `output_chunk_length`. In this sense,\n        the `_BlockRNNModule` produces \'blocks\' of forecasts at a time (which is different\n        from `_RNNModule` used by the `RNNModel`).\n\n        Parameters\n        ----------\n        name\n            The name of the specific PyTorch RNN module ("RNN", "GRU" or "LSTM").\n        input_size\n            The dimensionality of the input time series.\n        hidden_dim\n            The number of features in the hidden state `h` of the RNN module.\n        num_layers\n            The number of recurrent layers.\n        target_size\n            The dimensionality of the output time series.\n        nr_params\n            The number of parameters of the likelihood (or 1 if no likelihood is used).\n        num_layers_out_fc\n            A list containing the dimensions of the hidden layers of the fully connected NN.\n            This network connects the last hidden layer of the PyTorch RNN module to the output.\n        dropout\n            The fraction of neurons that are dropped in all-but-last RNN layers.\n        **kwargs\n            all parameters required for :class:`darts.model.forecasting_models.PLForecastingModule` base class.\n\n        Inputs\n        ------\n        x of shape `(batch_size, input_chunk_length, input_size, nr_params)`\n            Tensor containing the features of the input sequence.\n\n        Outputs\n        -------\n        y of shape `(batch_size, output_chunk_length, target_size, nr_params)`\n            Tensor containing the prediction at the last time step of the sequence.\n        '
        super().__init__(**kwargs)
        self.hidden_dim = hidden_dim
        self.n_layers = num_layers
        self.target_size = target_size
        self.nr_params = nr_params
        num_layers_out_fc = [] if num_layers_out_fc is None else num_layers_out_fc
        self.out_len = self.output_chunk_length
        self.name = name
        self.rnn = getattr(nn, name)(input_size, hidden_dim, num_layers, batch_first=True, dropout=dropout)
        last = hidden_dim
        feats = []
        for feature in num_layers_out_fc + [self.out_len * target_size * nr_params]:
            feats.append(nn.Linear(last, feature))
            last = feature
        self.fc = nn.Sequential(*feats)

    @io_processor
    def forward(self, x_in: Tuple):
        if False:
            i = 10
            return i + 15
        (x, _) = x_in
        batch_size = x.size(0)
        (out, hidden) = self.rnn(x)
        ' Here, we apply the FC network only on the last output point (at the last time step)\n        '
        if self.name == 'LSTM':
            hidden = hidden[0]
        predictions = hidden[-1, :, :]
        predictions = self.fc(predictions)
        predictions = predictions.view(batch_size, self.out_len, self.target_size, self.nr_params)
        return predictions

class BlockRNNModel(PastCovariatesTorchModel):

    def __init__(self, input_chunk_length: int, output_chunk_length: int, model: Union[str, nn.Module]='RNN', hidden_dim: int=25, n_rnn_layers: int=1, hidden_fc_sizes: Optional[List]=None, dropout: float=0.0, **kwargs):
        if False:
            return 10
        'Block Recurrent Neural Network Model (RNNs).\n\n        This is a neural network model that uses an RNN encoder to encode fixed-length input chunks, and\n        a fully connected network to produce fixed-length outputs.\n\n        This model supports past covariates (known for `input_chunk_length` points before prediction time).\n\n        This class provides three variants of RNNs:\n\n        * Vanilla RNN\n\n        * LSTM\n\n        * GRU\n\n        Parameters\n        ----------\n        input_chunk_length\n            The number of time steps that will be fed to the internal forecasting module\n        output_chunk_length\n            Number of time steps to be output by the internal forecasting module.\n        model\n            Either a string specifying the RNN module type ("RNN", "LSTM" or "GRU"),\n            or a PyTorch module with the same specifications as\n            :class:`darts.models.block_rnn_model._BlockRNNModule`.\n        hidden_dim\n            Size for feature maps for each hidden RNN layer (:math:`h_n`).\n            In Darts version <= 0.21, hidden_dim was referred as hidden_size.\n        n_rnn_layers\n            Number of layers in the RNN module.\n        hidden_fc_sizes\n            Sizes of hidden layers connecting the last hidden layer of the RNN module to the output, if any.\n        dropout\n            Fraction of neurons afected by Dropout.\n        **kwargs\n            Optional arguments to initialize the pytorch_lightning.Module, pytorch_lightning.Trainer, and\n            Darts\' :class:`TorchForecastingModel`.\n\n        loss_fn\n            PyTorch loss function used for training.\n            This parameter will be ignored for probabilistic models if the ``likelihood`` parameter is specified.\n            Default: ``torch.nn.MSELoss()``.\n        likelihood\n            One of Darts\' :meth:`Likelihood <darts.utils.likelihood_models.Likelihood>` models to be used for\n            probabilistic forecasts. Default: ``None``.\n        torch_metrics\n            A torch metric or a ``MetricCollection`` used for evaluation. A full list of available metrics can be found\n            at https://torchmetrics.readthedocs.io/en/latest/. Default: ``None``.\n        optimizer_cls\n            The PyTorch optimizer class to be used. Default: ``torch.optim.Adam``.\n        optimizer_kwargs\n            Optionally, some keyword arguments for the PyTorch optimizer (e.g., ``{\'lr\': 1e-3}``\n            for specifying a learning rate). Otherwise the default values of the selected ``optimizer_cls``\n            will be used. Default: ``None``.\n        lr_scheduler_cls\n            Optionally, the PyTorch learning rate scheduler class to be used. Specifying ``None`` corresponds\n            to using a constant learning rate. Default: ``None``.\n        lr_scheduler_kwargs\n            Optionally, some keyword arguments for the PyTorch learning rate scheduler. Default: ``None``.\n        use_reversible_instance_norm\n            Whether to use reversible instance normalization `RINorm` against distribution shift as shown in [1]_.\n            It is only applied to the features of the target series and not the covariates.\n        batch_size\n            Number of time series (input and output sequences) used in each training pass. Default: ``32``.\n        n_epochs\n            Number of epochs over which to train the model. Default: ``100``.\n        model_name\n            Name of the model. Used for creating checkpoints and saving tensorboard data. If not specified,\n            defaults to the following string ``"YYYY-mm-dd_HH_MM_SS_torch_model_run_PID"``, where the initial part\n            of the name is formatted with the local date and time, while PID is the processed ID (preventing models\n            spawned at the same time by different processes to share the same model_name). E.g.,\n            ``"2021-06-14_09_53_32_torch_model_run_44607"``.\n        work_dir\n            Path of the working directory, where to save checkpoints and Tensorboard summaries.\n            Default: current working directory.\n        log_tensorboard\n            If set, use Tensorboard to log the different parameters. The logs will be located in:\n            ``"{work_dir}/darts_logs/{model_name}/logs/"``. Default: ``False``.\n        nr_epochs_val_period\n            Number of epochs to wait before evaluating the validation loss (if a validation\n            ``TimeSeries`` is passed to the :func:`fit()` method). Default: ``1``.\n        force_reset\n            If set to ``True``, any previously-existing model with the same name will be reset (all checkpoints will\n            be discarded). Default: ``False``.\n        save_checkpoints\n            Whether or not to automatically save the untrained model and checkpoints from training.\n            To load the model from checkpoint, call :func:`MyModelClass.load_from_checkpoint()`, where\n            :class:`MyModelClass` is the :class:`TorchForecastingModel` class that was used (such as :class:`TFTModel`,\n            :class:`NBEATSModel`, etc.). If set to ``False``, the model can still be manually saved using\n            :func:`save()` and loaded using :func:`load()`. Default: ``False``.\n        add_encoders\n            A large number of past and future covariates can be automatically generated with `add_encoders`.\n            This can be done by adding multiple pre-defined index encoders and/or custom user-made functions that\n            will be used as index encoders. Additionally, a transformer such as Darts\' :class:`Scaler` can be added to\n            transform the generated covariates. This happens all under one hood and only needs to be specified at\n            model creation.\n            Read :meth:`SequentialEncoder <darts.dataprocessing.encoders.SequentialEncoder>` to find out more about\n            ``add_encoders``. Default: ``None``. An example showing some of ``add_encoders`` features:\n\n            .. highlight:: python\n            .. code-block:: python\n\n                def encode_year(idx):\n                    return (idx.year - 1950) / 50\n\n                add_encoders={\n                    \'cyclic\': {\'future\': [\'month\']},\n                    \'datetime_attribute\': {\'future\': [\'hour\', \'dayofweek\']},\n                    \'position\': {\'past\': [\'relative\'], \'future\': [\'relative\']},\n                    \'custom\': {\'past\': [encode_year]},\n                    \'transformer\': Scaler(),\n                    \'tz\': \'CET\'\n                }\n            ..\n        random_state\n            Control the randomness of the weights initialization. Check this\n            `link <https://scikit-learn.org/stable/glossary.html#term-random_state>`_ for more details.\n            Default: ``None``.\n        pl_trainer_kwargs\n            By default :class:`TorchForecastingModel` creates a PyTorch Lightning Trainer with several useful presets\n            that performs the training, validation and prediction processes. These presets include automatic\n            checkpointing, tensorboard logging, setting the torch device and more.\n            With ``pl_trainer_kwargs`` you can add additional kwargs to instantiate the PyTorch Lightning trainer\n            object. Check the `PL Trainer documentation\n            <https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html>`_ for more information about the\n            supported kwargs. Default: ``None``.\n            Running on GPU(s) is also possible using ``pl_trainer_kwargs`` by specifying keys ``"accelerator",\n            "devices", and "auto_select_gpus"``. Some examples for setting the devices inside the ``pl_trainer_kwargs``\n            dict:\n\n\n            - ``{"accelerator": "cpu"}`` for CPU,\n            - ``{"accelerator": "gpu", "devices": [i]}`` to use only GPU ``i`` (``i`` must be an integer),\n            - ``{"accelerator": "gpu", "devices": -1, "auto_select_gpus": True}`` to use all available GPUS.\n\n            For more info, see here:\n            https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#trainer-flags , and\n            https://pytorch-lightning.readthedocs.io/en/stable/accelerators/gpu_basic.html#train-on-multiple-gpus\n\n            With parameter ``"callbacks"`` you can add custom or PyTorch-Lightning built-in callbacks to Darts\'\n            :class:`TorchForecastingModel`. Below is an example for adding EarlyStopping to the training process.\n            The model will stop training early if the validation loss `val_loss` does not improve beyond\n            specifications. For more information on callbacks, visit:\n            `PyTorch Lightning Callbacks\n            <https://pytorch-lightning.readthedocs.io/en/stable/extensions/callbacks.html>`_\n\n            .. highlight:: python\n            .. code-block:: python\n\n                from pytorch_lightning.callbacks.early_stopping import EarlyStopping\n\n                # stop training when validation loss does not decrease more than 0.05 (`min_delta`) over\n                # a period of 5 epochs (`patience`)\n                my_stopper = EarlyStopping(\n                    monitor="val_loss",\n                    patience=5,\n                    min_delta=0.05,\n                    mode=\'min\',\n                )\n\n                pl_trainer_kwargs={"callbacks": [my_stopper]}\n            ..\n\n            Note that you can also use a custom PyTorch Lightning Trainer for training and prediction with optional\n            parameter ``trainer`` in :func:`fit()` and :func:`predict()`.\n        show_warnings\n            whether to show warnings raised from PyTorch Lightning. Useful to detect potential issues of\n            your forecasting use case. Default: ``False``.\n\n        References\n        ----------\n        .. [1] T. Kim et al. "Reversible Instance Normalization for Accurate Time-Series Forecasting against\n                Distribution Shift", https://openreview.net/forum?id=cGDAkQo1C0p\n\n        Examples\n        --------\n        >>> from darts.datasets import WeatherDataset\n        >>> from darts.models import BlockRNNModel\n        >>> series = WeatherDataset().load()\n        >>> # predicting atmospheric pressure\n        >>> target = series[\'p (mbar)\'][:100]\n        >>> # optionally, use past observed rainfall (pretending to be unknown beyond index 100)\n        >>> past_cov = series[\'rain (mm)\'][:100]\n        >>> # predict 6 pressure values using the 12 past values of pressure and rainfall, as well as the 6 temperature\n        >>> model = BlockRNNModel(\n        >>>     input_chunk_length=12,\n        >>>     output_chunk_length=6,\n        >>>     n_rnn_layers=2,\n        >>>     n_epochs=50,\n        >>> )\n        >>> model.fit(target, past_covariates=past_cov)\n        >>> pred = model.predict(6)\n        >>> pred.values()\n        array([[4.97979827],\n               [3.9707572 ],\n               [5.27869295],\n               [5.19697244],\n               [5.28424783],\n               [5.22497681]])\n\n        .. note::\n            `RNN example notebook <https://unit8co.github.io/darts/examples/04-RNN-examples.html>`_ presents techniques\n            that can be used to improve the forecasts quality compared to this simple usage example.\n        '
        super().__init__(**self._extract_torch_model_params(**self.model_params))
        self.pl_module_params = self._extract_pl_module_params(**self.model_params)
        if model not in ['RNN', 'LSTM', 'GRU']:
            raise_if_not(isinstance(model, nn.Module), '{} is not a valid RNN model.\n Please specify "RNN", "LSTM", "GRU", or give your own PyTorch nn.Module'.format(model.__class__.__name__), logger)
        self.rnn_type_or_module = model
        self.hidden_fc_sizes = hidden_fc_sizes
        self.hidden_dim = hidden_dim
        self.n_rnn_layers = n_rnn_layers
        self.dropout = dropout

    @property
    def supports_multivariate(self) -> bool:
        if False:
            return 10
        return True

    def _create_model(self, train_sample: Tuple[torch.Tensor]) -> torch.nn.Module:
        if False:
            while True:
                i = 10
        input_dim = train_sample[0].shape[1] + (train_sample[1].shape[1] if train_sample[1] is not None else 0)
        output_dim = train_sample[-1].shape[1]
        nr_params = 1 if self.likelihood is None else self.likelihood.num_parameters
        if self.rnn_type_or_module in ['RNN', 'LSTM', 'GRU']:
            hidden_fc_sizes = [] if self.hidden_fc_sizes is None else self.hidden_fc_sizes
            model = _BlockRNNModule(name=self.rnn_type_or_module, input_size=input_dim, target_size=output_dim, nr_params=nr_params, hidden_dim=self.hidden_dim, num_layers=self.n_rnn_layers, num_layers_out_fc=hidden_fc_sizes, dropout=self.dropout, **self.pl_module_params)
        else:
            model = self.rnn_type_or_module
        return model