[
    {
        "func_name": "factor",
        "original": "def factor(n, i, combi, res):\n    \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n        \n        Returns:\n            [list] -- [res]\n        \"\"\"\n    while i * i <= n:\n        if n % i == 0:\n            res += (combi + [i, int(n / i)],)\n            factor(n / i, i, combi + [i], res)\n        i += 1\n    return res",
        "mutated": [
            "def factor(n, i, combi, res):\n    if False:\n        i = 10\n    '[summary]\\n        helper function\\n\\n        Arguments:\\n            n {[int]} -- [number]\\n            i {[int]} -- [to tested divisor]\\n            combi {[list]} -- [catch divisors]\\n            res {[list]} -- [all factors of the number n]\\n        \\n        Returns:\\n            [list] -- [res]\\n        '\n    while i * i <= n:\n        if n % i == 0:\n            res += (combi + [i, int(n / i)],)\n            factor(n / i, i, combi + [i], res)\n        i += 1\n    return res",
            "def factor(n, i, combi, res):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '[summary]\\n        helper function\\n\\n        Arguments:\\n            n {[int]} -- [number]\\n            i {[int]} -- [to tested divisor]\\n            combi {[list]} -- [catch divisors]\\n            res {[list]} -- [all factors of the number n]\\n        \\n        Returns:\\n            [list] -- [res]\\n        '\n    while i * i <= n:\n        if n % i == 0:\n            res += (combi + [i, int(n / i)],)\n            factor(n / i, i, combi + [i], res)\n        i += 1\n    return res",
            "def factor(n, i, combi, res):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '[summary]\\n        helper function\\n\\n        Arguments:\\n            n {[int]} -- [number]\\n            i {[int]} -- [to tested divisor]\\n            combi {[list]} -- [catch divisors]\\n            res {[list]} -- [all factors of the number n]\\n        \\n        Returns:\\n            [list] -- [res]\\n        '\n    while i * i <= n:\n        if n % i == 0:\n            res += (combi + [i, int(n / i)],)\n            factor(n / i, i, combi + [i], res)\n        i += 1\n    return res",
            "def factor(n, i, combi, res):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '[summary]\\n        helper function\\n\\n        Arguments:\\n            n {[int]} -- [number]\\n            i {[int]} -- [to tested divisor]\\n            combi {[list]} -- [catch divisors]\\n            res {[list]} -- [all factors of the number n]\\n        \\n        Returns:\\n            [list] -- [res]\\n        '\n    while i * i <= n:\n        if n % i == 0:\n            res += (combi + [i, int(n / i)],)\n            factor(n / i, i, combi + [i], res)\n        i += 1\n    return res",
            "def factor(n, i, combi, res):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '[summary]\\n        helper function\\n\\n        Arguments:\\n            n {[int]} -- [number]\\n            i {[int]} -- [to tested divisor]\\n            combi {[list]} -- [catch divisors]\\n            res {[list]} -- [all factors of the number n]\\n        \\n        Returns:\\n            [list] -- [res]\\n        '\n    while i * i <= n:\n        if n % i == 0:\n            res += (combi + [i, int(n / i)],)\n            factor(n / i, i, combi + [i], res)\n        i += 1\n    return res"
        ]
    },
    {
        "func_name": "get_factors",
        "original": "def get_factors(n):\n    \"\"\"[summary]\n    \n    Arguments:\n        n {[int]} -- [to analysed number]\n    \n    Returns:\n        [list of lists] -- [all factors of the number n]\n    \"\"\"\n\n    def factor(n, i, combi, res):\n        \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n        \n        Returns:\n            [list] -- [res]\n        \"\"\"\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, int(n / i)],)\n                factor(n / i, i, combi + [i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])",
        "mutated": [
            "def get_factors(n):\n    if False:\n        i = 10\n    '[summary]\\n    \\n    Arguments:\\n        n {[int]} -- [to analysed number]\\n    \\n    Returns:\\n        [list of lists] -- [all factors of the number n]\\n    '\n\n    def factor(n, i, combi, res):\n        \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n        \n        Returns:\n            [list] -- [res]\n        \"\"\"\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, int(n / i)],)\n                factor(n / i, i, combi + [i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])",
            "def get_factors(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '[summary]\\n    \\n    Arguments:\\n        n {[int]} -- [to analysed number]\\n    \\n    Returns:\\n        [list of lists] -- [all factors of the number n]\\n    '\n\n    def factor(n, i, combi, res):\n        \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n        \n        Returns:\n            [list] -- [res]\n        \"\"\"\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, int(n / i)],)\n                factor(n / i, i, combi + [i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])",
            "def get_factors(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '[summary]\\n    \\n    Arguments:\\n        n {[int]} -- [to analysed number]\\n    \\n    Returns:\\n        [list of lists] -- [all factors of the number n]\\n    '\n\n    def factor(n, i, combi, res):\n        \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n        \n        Returns:\n            [list] -- [res]\n        \"\"\"\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, int(n / i)],)\n                factor(n / i, i, combi + [i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])",
            "def get_factors(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '[summary]\\n    \\n    Arguments:\\n        n {[int]} -- [to analysed number]\\n    \\n    Returns:\\n        [list of lists] -- [all factors of the number n]\\n    '\n\n    def factor(n, i, combi, res):\n        \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n        \n        Returns:\n            [list] -- [res]\n        \"\"\"\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, int(n / i)],)\n                factor(n / i, i, combi + [i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])",
            "def get_factors(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '[summary]\\n    \\n    Arguments:\\n        n {[int]} -- [to analysed number]\\n    \\n    Returns:\\n        [list of lists] -- [all factors of the number n]\\n    '\n\n    def factor(n, i, combi, res):\n        \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n        \n        Returns:\n            [list] -- [res]\n        \"\"\"\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, int(n / i)],)\n                factor(n / i, i, combi + [i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])"
        ]
    },
    {
        "func_name": "get_factors_iterative1",
        "original": "def get_factors_iterative1(n):\n    \"\"\"[summary]\n    Computes all factors of n.\n    Translated the function get_factors(...) in\n    a call-stack modell.\n\n    Arguments:\n        n {[int]} -- [to analysed number]\n    \n    Returns:\n        [list of lists] -- [all factors]\n    \"\"\"\n    (todo, res) = ([(n, 2, [])], [])\n    while todo:\n        (n, i, combi) = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, n // i],)\n                (todo.append((n // i, i, combi + [i])),)\n            i += 1\n    return res",
        "mutated": [
            "def get_factors_iterative1(n):\n    if False:\n        i = 10\n    '[summary]\\n    Computes all factors of n.\\n    Translated the function get_factors(...) in\\n    a call-stack modell.\\n\\n    Arguments:\\n        n {[int]} -- [to analysed number]\\n    \\n    Returns:\\n        [list of lists] -- [all factors]\\n    '\n    (todo, res) = ([(n, 2, [])], [])\n    while todo:\n        (n, i, combi) = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, n // i],)\n                (todo.append((n // i, i, combi + [i])),)\n            i += 1\n    return res",
            "def get_factors_iterative1(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '[summary]\\n    Computes all factors of n.\\n    Translated the function get_factors(...) in\\n    a call-stack modell.\\n\\n    Arguments:\\n        n {[int]} -- [to analysed number]\\n    \\n    Returns:\\n        [list of lists] -- [all factors]\\n    '\n    (todo, res) = ([(n, 2, [])], [])\n    while todo:\n        (n, i, combi) = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, n // i],)\n                (todo.append((n // i, i, combi + [i])),)\n            i += 1\n    return res",
            "def get_factors_iterative1(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '[summary]\\n    Computes all factors of n.\\n    Translated the function get_factors(...) in\\n    a call-stack modell.\\n\\n    Arguments:\\n        n {[int]} -- [to analysed number]\\n    \\n    Returns:\\n        [list of lists] -- [all factors]\\n    '\n    (todo, res) = ([(n, 2, [])], [])\n    while todo:\n        (n, i, combi) = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, n // i],)\n                (todo.append((n // i, i, combi + [i])),)\n            i += 1\n    return res",
            "def get_factors_iterative1(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '[summary]\\n    Computes all factors of n.\\n    Translated the function get_factors(...) in\\n    a call-stack modell.\\n\\n    Arguments:\\n        n {[int]} -- [to analysed number]\\n    \\n    Returns:\\n        [list of lists] -- [all factors]\\n    '\n    (todo, res) = ([(n, 2, [])], [])\n    while todo:\n        (n, i, combi) = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, n // i],)\n                (todo.append((n // i, i, combi + [i])),)\n            i += 1\n    return res",
            "def get_factors_iterative1(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '[summary]\\n    Computes all factors of n.\\n    Translated the function get_factors(...) in\\n    a call-stack modell.\\n\\n    Arguments:\\n        n {[int]} -- [to analysed number]\\n    \\n    Returns:\\n        [list of lists] -- [all factors]\\n    '\n    (todo, res) = ([(n, 2, [])], [])\n    while todo:\n        (n, i, combi) = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, n // i],)\n                (todo.append((n // i, i, combi + [i])),)\n            i += 1\n    return res"
        ]
    },
    {
        "func_name": "get_factors_iterative2",
        "original": "def get_factors_iterative2(n):\n    \"\"\"[summary]\n    analog as above\n\n    Arguments:\n        n {[int]} -- [description]\n    \n    Returns:\n        [list of lists] -- [all factors of n]\n    \"\"\"\n    (ans, stack, x) = ([], [], 2)\n    while True:\n        if x > n // x:\n            if not stack:\n                return ans\n            ans.append(stack + [n])\n            x = stack.pop()\n            n *= x\n            x += 1\n        elif n % x == 0:\n            stack.append(x)\n            n //= x\n        else:\n            x += 1",
        "mutated": [
            "def get_factors_iterative2(n):\n    if False:\n        i = 10\n    '[summary]\\n    analog as above\\n\\n    Arguments:\\n        n {[int]} -- [description]\\n    \\n    Returns:\\n        [list of lists] -- [all factors of n]\\n    '\n    (ans, stack, x) = ([], [], 2)\n    while True:\n        if x > n // x:\n            if not stack:\n                return ans\n            ans.append(stack + [n])\n            x = stack.pop()\n            n *= x\n            x += 1\n        elif n % x == 0:\n            stack.append(x)\n            n //= x\n        else:\n            x += 1",
            "def get_factors_iterative2(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '[summary]\\n    analog as above\\n\\n    Arguments:\\n        n {[int]} -- [description]\\n    \\n    Returns:\\n        [list of lists] -- [all factors of n]\\n    '\n    (ans, stack, x) = ([], [], 2)\n    while True:\n        if x > n // x:\n            if not stack:\n                return ans\n            ans.append(stack + [n])\n            x = stack.pop()\n            n *= x\n            x += 1\n        elif n % x == 0:\n            stack.append(x)\n            n //= x\n        else:\n            x += 1",
            "def get_factors_iterative2(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '[summary]\\n    analog as above\\n\\n    Arguments:\\n        n {[int]} -- [description]\\n    \\n    Returns:\\n        [list of lists] -- [all factors of n]\\n    '\n    (ans, stack, x) = ([], [], 2)\n    while True:\n        if x > n // x:\n            if not stack:\n                return ans\n            ans.append(stack + [n])\n            x = stack.pop()\n            n *= x\n            x += 1\n        elif n % x == 0:\n            stack.append(x)\n            n //= x\n        else:\n            x += 1",
            "def get_factors_iterative2(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '[summary]\\n    analog as above\\n\\n    Arguments:\\n        n {[int]} -- [description]\\n    \\n    Returns:\\n        [list of lists] -- [all factors of n]\\n    '\n    (ans, stack, x) = ([], [], 2)\n    while True:\n        if x > n // x:\n            if not stack:\n                return ans\n            ans.append(stack + [n])\n            x = stack.pop()\n            n *= x\n            x += 1\n        elif n % x == 0:\n            stack.append(x)\n            n //= x\n        else:\n            x += 1",
            "def get_factors_iterative2(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '[summary]\\n    analog as above\\n\\n    Arguments:\\n        n {[int]} -- [description]\\n    \\n    Returns:\\n        [list of lists] -- [all factors of n]\\n    '\n    (ans, stack, x) = ([], [], 2)\n    while True:\n        if x > n // x:\n            if not stack:\n                return ans\n            ans.append(stack + [n])\n            x = stack.pop()\n            n *= x\n            x += 1\n        elif n % x == 0:\n            stack.append(x)\n            n //= x\n        else:\n            x += 1"
        ]
    }
]