[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\n    \"\"\"\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)"
        ]
    },
    {
        "func_name": "config",
        "original": "@proxy_napalm_wrap\ndef config(**kwargs):\n    \"\"\"\n    Returns the SNMP configuration\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' snmp.config\n    \"\"\"\n    return salt.utils.napalm.call(napalm_device, 'get_snmp_information', **{})",
        "mutated": [
            "@proxy_napalm_wrap\ndef config(**kwargs):\n    if False:\n        i = 10\n    \"\\n    Returns the SNMP configuration\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' snmp.config\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_snmp_information', **{})",
            "@proxy_napalm_wrap\ndef config(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Returns the SNMP configuration\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' snmp.config\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_snmp_information', **{})",
            "@proxy_napalm_wrap\ndef config(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Returns the SNMP configuration\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' snmp.config\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_snmp_information', **{})",
            "@proxy_napalm_wrap\ndef config(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Returns the SNMP configuration\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' snmp.config\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_snmp_information', **{})",
            "@proxy_napalm_wrap\ndef config(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Returns the SNMP configuration\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' snmp.config\\n    \"\n    return salt.utils.napalm.call(napalm_device, 'get_snmp_information', **{})"
        ]
    },
    {
        "func_name": "remove_config",
        "original": "@proxy_napalm_wrap\ndef remove_config(chassis_id=None, community=None, contact=None, location=None, test=False, commit=True, **kwargs):\n    \"\"\"\n    Removes a configuration element from the SNMP configuration.\n\n    :param chassis_id: (optional) Chassis ID\n\n    :param community: (optional) A dictionary having the following optional keys:\n\n    - acl (if any policy / ACL need to be set)\n    - mode: rw or ro. Default: ro\n\n    :param contact: Contact details\n\n    :param location: Location\n\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\n\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit\n        the config immediately after loading the changes. E.g.: a state loads a\n        couple of parts (add / remove / update) and would not be optimal to\n        commit after each operation.  Also, from the CLI when the user needs to\n        apply the similar changes before committing, can specify commit=False\n        and will not discard the config.\n\n    :raise MergeConfigException: If there is an error on the configuration sent.\n    :return: A dictionary having the following keys:\n\n    - result (bool): if the config was applied successfully. It is `False`\n      only in case of failure. In case there are no changes to be applied\n      and successfully performs all operations it is still `True` and so\n      will be the `already_configured` flag (example below)\n    - comment (str): a message for the user\n    - already_configured (bool): flag to check if there were no changes applied\n    - diff (str): returns the config changes applied\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' snmp.remove_config community='abcd'\n    \"\"\"\n    dic = {'template_name': 'delete_snmp_config', 'test': test, 'commit': commit}\n    if chassis_id:\n        dic['chassis_id'] = chassis_id\n    if community:\n        dic['community'] = community\n    if contact:\n        dic['contact'] = contact\n    if location:\n        dic['location'] = location\n    dic['inherit_napalm_device'] = napalm_device\n    return __salt__['net.load_template'](**dic)",
        "mutated": [
            "@proxy_napalm_wrap\ndef remove_config(chassis_id=None, community=None, contact=None, location=None, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Removes a configuration element from the SNMP configuration.\\n\\n    :param chassis_id: (optional) Chassis ID\\n\\n    :param community: (optional) A dictionary having the following optional keys:\\n\\n    - acl (if any policy / ACL need to be set)\\n    - mode: rw or ro. Default: ro\\n\\n    :param contact: Contact details\\n\\n    :param location: Location\\n\\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\\n\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit\\n        the config immediately after loading the changes. E.g.: a state loads a\\n        couple of parts (add / remove / update) and would not be optimal to\\n        commit after each operation.  Also, from the CLI when the user needs to\\n        apply the similar changes before committing, can specify commit=False\\n        and will not discard the config.\\n\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return: A dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is `False`\\n      only in case of failure. In case there are no changes to be applied\\n      and successfully performs all operations it is still `True` and so\\n      will be the `already_configured` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' snmp.remove_config community='abcd'\\n    \"\n    dic = {'template_name': 'delete_snmp_config', 'test': test, 'commit': commit}\n    if chassis_id:\n        dic['chassis_id'] = chassis_id\n    if community:\n        dic['community'] = community\n    if contact:\n        dic['contact'] = contact\n    if location:\n        dic['location'] = location\n    dic['inherit_napalm_device'] = napalm_device\n    return __salt__['net.load_template'](**dic)",
            "@proxy_napalm_wrap\ndef remove_config(chassis_id=None, community=None, contact=None, location=None, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Removes a configuration element from the SNMP configuration.\\n\\n    :param chassis_id: (optional) Chassis ID\\n\\n    :param community: (optional) A dictionary having the following optional keys:\\n\\n    - acl (if any policy / ACL need to be set)\\n    - mode: rw or ro. Default: ro\\n\\n    :param contact: Contact details\\n\\n    :param location: Location\\n\\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\\n\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit\\n        the config immediately after loading the changes. E.g.: a state loads a\\n        couple of parts (add / remove / update) and would not be optimal to\\n        commit after each operation.  Also, from the CLI when the user needs to\\n        apply the similar changes before committing, can specify commit=False\\n        and will not discard the config.\\n\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return: A dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is `False`\\n      only in case of failure. In case there are no changes to be applied\\n      and successfully performs all operations it is still `True` and so\\n      will be the `already_configured` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' snmp.remove_config community='abcd'\\n    \"\n    dic = {'template_name': 'delete_snmp_config', 'test': test, 'commit': commit}\n    if chassis_id:\n        dic['chassis_id'] = chassis_id\n    if community:\n        dic['community'] = community\n    if contact:\n        dic['contact'] = contact\n    if location:\n        dic['location'] = location\n    dic['inherit_napalm_device'] = napalm_device\n    return __salt__['net.load_template'](**dic)",
            "@proxy_napalm_wrap\ndef remove_config(chassis_id=None, community=None, contact=None, location=None, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Removes a configuration element from the SNMP configuration.\\n\\n    :param chassis_id: (optional) Chassis ID\\n\\n    :param community: (optional) A dictionary having the following optional keys:\\n\\n    - acl (if any policy / ACL need to be set)\\n    - mode: rw or ro. Default: ro\\n\\n    :param contact: Contact details\\n\\n    :param location: Location\\n\\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\\n\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit\\n        the config immediately after loading the changes. E.g.: a state loads a\\n        couple of parts (add / remove / update) and would not be optimal to\\n        commit after each operation.  Also, from the CLI when the user needs to\\n        apply the similar changes before committing, can specify commit=False\\n        and will not discard the config.\\n\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return: A dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is `False`\\n      only in case of failure. In case there are no changes to be applied\\n      and successfully performs all operations it is still `True` and so\\n      will be the `already_configured` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' snmp.remove_config community='abcd'\\n    \"\n    dic = {'template_name': 'delete_snmp_config', 'test': test, 'commit': commit}\n    if chassis_id:\n        dic['chassis_id'] = chassis_id\n    if community:\n        dic['community'] = community\n    if contact:\n        dic['contact'] = contact\n    if location:\n        dic['location'] = location\n    dic['inherit_napalm_device'] = napalm_device\n    return __salt__['net.load_template'](**dic)",
            "@proxy_napalm_wrap\ndef remove_config(chassis_id=None, community=None, contact=None, location=None, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Removes a configuration element from the SNMP configuration.\\n\\n    :param chassis_id: (optional) Chassis ID\\n\\n    :param community: (optional) A dictionary having the following optional keys:\\n\\n    - acl (if any policy / ACL need to be set)\\n    - mode: rw or ro. Default: ro\\n\\n    :param contact: Contact details\\n\\n    :param location: Location\\n\\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\\n\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit\\n        the config immediately after loading the changes. E.g.: a state loads a\\n        couple of parts (add / remove / update) and would not be optimal to\\n        commit after each operation.  Also, from the CLI when the user needs to\\n        apply the similar changes before committing, can specify commit=False\\n        and will not discard the config.\\n\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return: A dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is `False`\\n      only in case of failure. In case there are no changes to be applied\\n      and successfully performs all operations it is still `True` and so\\n      will be the `already_configured` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' snmp.remove_config community='abcd'\\n    \"\n    dic = {'template_name': 'delete_snmp_config', 'test': test, 'commit': commit}\n    if chassis_id:\n        dic['chassis_id'] = chassis_id\n    if community:\n        dic['community'] = community\n    if contact:\n        dic['contact'] = contact\n    if location:\n        dic['location'] = location\n    dic['inherit_napalm_device'] = napalm_device\n    return __salt__['net.load_template'](**dic)",
            "@proxy_napalm_wrap\ndef remove_config(chassis_id=None, community=None, contact=None, location=None, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Removes a configuration element from the SNMP configuration.\\n\\n    :param chassis_id: (optional) Chassis ID\\n\\n    :param community: (optional) A dictionary having the following optional keys:\\n\\n    - acl (if any policy / ACL need to be set)\\n    - mode: rw or ro. Default: ro\\n\\n    :param contact: Contact details\\n\\n    :param location: Location\\n\\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\\n\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit\\n        the config immediately after loading the changes. E.g.: a state loads a\\n        couple of parts (add / remove / update) and would not be optimal to\\n        commit after each operation.  Also, from the CLI when the user needs to\\n        apply the similar changes before committing, can specify commit=False\\n        and will not discard the config.\\n\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return: A dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is `False`\\n      only in case of failure. In case there are no changes to be applied\\n      and successfully performs all operations it is still `True` and so\\n      will be the `already_configured` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' snmp.remove_config community='abcd'\\n    \"\n    dic = {'template_name': 'delete_snmp_config', 'test': test, 'commit': commit}\n    if chassis_id:\n        dic['chassis_id'] = chassis_id\n    if community:\n        dic['community'] = community\n    if contact:\n        dic['contact'] = contact\n    if location:\n        dic['location'] = location\n    dic['inherit_napalm_device'] = napalm_device\n    return __salt__['net.load_template'](**dic)"
        ]
    },
    {
        "func_name": "update_config",
        "original": "@proxy_napalm_wrap\ndef update_config(chassis_id=None, community=None, contact=None, location=None, test=False, commit=True, **kwargs):\n    \"\"\"\n    Updates the SNMP configuration.\n\n    :param chassis_id: (optional) Chassis ID\n    :param community: (optional) A dictionary having the following optional keys:\n\n    - acl (if any policy / ACL need to be set)\n    - mode: rw or ro. Default: ro\n\n    :param contact: Contact details\n    :param location: Location\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit the config immediately\n        after loading the changes. E.g.: a state loads a couple of parts (add / remove / update)\n        and would not be optimal to commit after each operation.\n        Also, from the CLI when the user needs to apply the similar changes before committing,\n        can specify commit=False and will not discard the config.\n    :raise MergeConfigException: If there is an error on the configuration sent.\n    :return a dictionary having the following keys:\n\n    - result (bool): if the config was applied successfully. It is `False` only\n      in case of failure. In case there are no changes to be applied and\n      successfully performs all operations it is still `True` and so will be\n      the `already_configured` flag (example below)\n    - comment (str): a message for the user\n    - already_configured (bool): flag to check if there were no changes applied\n    - diff (str): returns the config changes applied\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt 'edge01.lon01' snmp.update_config location=\"Greenwich, UK\" test=True\n\n    Output example (for the CLI example above):\n\n    .. code-block:: yaml\n\n        edge01.lon01:\n            ----------\n            already_configured:\n                False\n            comment:\n                Configuration discarded.\n            diff:\n                [edit snmp]\n                -  location \"London, UK\";\n                +  location \"Greenwich, UK\";\n            result:\n                True\n    \"\"\"\n    dic = {'template_name': 'snmp_config', 'test': test, 'commit': commit}\n    if chassis_id:\n        dic['chassis_id'] = chassis_id\n    if community:\n        dic['community'] = community\n    if contact:\n        dic['contact'] = contact\n    if location:\n        dic['location'] = location\n    dic['inherit_napalm_device'] = napalm_device\n    return __salt__['net.load_template'](**dic)",
        "mutated": [
            "@proxy_napalm_wrap\ndef update_config(chassis_id=None, community=None, contact=None, location=None, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n    '\\n    Updates the SNMP configuration.\\n\\n    :param chassis_id: (optional) Chassis ID\\n    :param community: (optional) A dictionary having the following optional keys:\\n\\n    - acl (if any policy / ACL need to be set)\\n    - mode: rw or ro. Default: ro\\n\\n    :param contact: Contact details\\n    :param location: Location\\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit the config immediately\\n        after loading the changes. E.g.: a state loads a couple of parts (add / remove / update)\\n        and would not be optimal to commit after each operation.\\n        Also, from the CLI when the user needs to apply the similar changes before committing,\\n        can specify commit=False and will not discard the config.\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return a dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is `False` only\\n      in case of failure. In case there are no changes to be applied and\\n      successfully performs all operations it is still `True` and so will be\\n      the `already_configured` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'edge01.lon01\\' snmp.update_config location=\"Greenwich, UK\" test=True\\n\\n    Output example (for the CLI example above):\\n\\n    .. code-block:: yaml\\n\\n        edge01.lon01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n                Configuration discarded.\\n            diff:\\n                [edit snmp]\\n                -  location \"London, UK\";\\n                +  location \"Greenwich, UK\";\\n            result:\\n                True\\n    '\n    dic = {'template_name': 'snmp_config', 'test': test, 'commit': commit}\n    if chassis_id:\n        dic['chassis_id'] = chassis_id\n    if community:\n        dic['community'] = community\n    if contact:\n        dic['contact'] = contact\n    if location:\n        dic['location'] = location\n    dic['inherit_napalm_device'] = napalm_device\n    return __salt__['net.load_template'](**dic)",
            "@proxy_napalm_wrap\ndef update_config(chassis_id=None, community=None, contact=None, location=None, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Updates the SNMP configuration.\\n\\n    :param chassis_id: (optional) Chassis ID\\n    :param community: (optional) A dictionary having the following optional keys:\\n\\n    - acl (if any policy / ACL need to be set)\\n    - mode: rw or ro. Default: ro\\n\\n    :param contact: Contact details\\n    :param location: Location\\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit the config immediately\\n        after loading the changes. E.g.: a state loads a couple of parts (add / remove / update)\\n        and would not be optimal to commit after each operation.\\n        Also, from the CLI when the user needs to apply the similar changes before committing,\\n        can specify commit=False and will not discard the config.\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return a dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is `False` only\\n      in case of failure. In case there are no changes to be applied and\\n      successfully performs all operations it is still `True` and so will be\\n      the `already_configured` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'edge01.lon01\\' snmp.update_config location=\"Greenwich, UK\" test=True\\n\\n    Output example (for the CLI example above):\\n\\n    .. code-block:: yaml\\n\\n        edge01.lon01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n                Configuration discarded.\\n            diff:\\n                [edit snmp]\\n                -  location \"London, UK\";\\n                +  location \"Greenwich, UK\";\\n            result:\\n                True\\n    '\n    dic = {'template_name': 'snmp_config', 'test': test, 'commit': commit}\n    if chassis_id:\n        dic['chassis_id'] = chassis_id\n    if community:\n        dic['community'] = community\n    if contact:\n        dic['contact'] = contact\n    if location:\n        dic['location'] = location\n    dic['inherit_napalm_device'] = napalm_device\n    return __salt__['net.load_template'](**dic)",
            "@proxy_napalm_wrap\ndef update_config(chassis_id=None, community=None, contact=None, location=None, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Updates the SNMP configuration.\\n\\n    :param chassis_id: (optional) Chassis ID\\n    :param community: (optional) A dictionary having the following optional keys:\\n\\n    - acl (if any policy / ACL need to be set)\\n    - mode: rw or ro. Default: ro\\n\\n    :param contact: Contact details\\n    :param location: Location\\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit the config immediately\\n        after loading the changes. E.g.: a state loads a couple of parts (add / remove / update)\\n        and would not be optimal to commit after each operation.\\n        Also, from the CLI when the user needs to apply the similar changes before committing,\\n        can specify commit=False and will not discard the config.\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return a dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is `False` only\\n      in case of failure. In case there are no changes to be applied and\\n      successfully performs all operations it is still `True` and so will be\\n      the `already_configured` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'edge01.lon01\\' snmp.update_config location=\"Greenwich, UK\" test=True\\n\\n    Output example (for the CLI example above):\\n\\n    .. code-block:: yaml\\n\\n        edge01.lon01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n                Configuration discarded.\\n            diff:\\n                [edit snmp]\\n                -  location \"London, UK\";\\n                +  location \"Greenwich, UK\";\\n            result:\\n                True\\n    '\n    dic = {'template_name': 'snmp_config', 'test': test, 'commit': commit}\n    if chassis_id:\n        dic['chassis_id'] = chassis_id\n    if community:\n        dic['community'] = community\n    if contact:\n        dic['contact'] = contact\n    if location:\n        dic['location'] = location\n    dic['inherit_napalm_device'] = napalm_device\n    return __salt__['net.load_template'](**dic)",
            "@proxy_napalm_wrap\ndef update_config(chassis_id=None, community=None, contact=None, location=None, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Updates the SNMP configuration.\\n\\n    :param chassis_id: (optional) Chassis ID\\n    :param community: (optional) A dictionary having the following optional keys:\\n\\n    - acl (if any policy / ACL need to be set)\\n    - mode: rw or ro. Default: ro\\n\\n    :param contact: Contact details\\n    :param location: Location\\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit the config immediately\\n        after loading the changes. E.g.: a state loads a couple of parts (add / remove / update)\\n        and would not be optimal to commit after each operation.\\n        Also, from the CLI when the user needs to apply the similar changes before committing,\\n        can specify commit=False and will not discard the config.\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return a dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is `False` only\\n      in case of failure. In case there are no changes to be applied and\\n      successfully performs all operations it is still `True` and so will be\\n      the `already_configured` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'edge01.lon01\\' snmp.update_config location=\"Greenwich, UK\" test=True\\n\\n    Output example (for the CLI example above):\\n\\n    .. code-block:: yaml\\n\\n        edge01.lon01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n                Configuration discarded.\\n            diff:\\n                [edit snmp]\\n                -  location \"London, UK\";\\n                +  location \"Greenwich, UK\";\\n            result:\\n                True\\n    '\n    dic = {'template_name': 'snmp_config', 'test': test, 'commit': commit}\n    if chassis_id:\n        dic['chassis_id'] = chassis_id\n    if community:\n        dic['community'] = community\n    if contact:\n        dic['contact'] = contact\n    if location:\n        dic['location'] = location\n    dic['inherit_napalm_device'] = napalm_device\n    return __salt__['net.load_template'](**dic)",
            "@proxy_napalm_wrap\ndef update_config(chassis_id=None, community=None, contact=None, location=None, test=False, commit=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Updates the SNMP configuration.\\n\\n    :param chassis_id: (optional) Chassis ID\\n    :param community: (optional) A dictionary having the following optional keys:\\n\\n    - acl (if any policy / ACL need to be set)\\n    - mode: rw or ro. Default: ro\\n\\n    :param contact: Contact details\\n    :param location: Location\\n    :param test: Dry run? If set as True, will apply the config, discard and return the changes. Default: False\\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit the config immediately\\n        after loading the changes. E.g.: a state loads a couple of parts (add / remove / update)\\n        and would not be optimal to commit after each operation.\\n        Also, from the CLI when the user needs to apply the similar changes before committing,\\n        can specify commit=False and will not discard the config.\\n    :raise MergeConfigException: If there is an error on the configuration sent.\\n    :return a dictionary having the following keys:\\n\\n    - result (bool): if the config was applied successfully. It is `False` only\\n      in case of failure. In case there are no changes to be applied and\\n      successfully performs all operations it is still `True` and so will be\\n      the `already_configured` flag (example below)\\n    - comment (str): a message for the user\\n    - already_configured (bool): flag to check if there were no changes applied\\n    - diff (str): returns the config changes applied\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'edge01.lon01\\' snmp.update_config location=\"Greenwich, UK\" test=True\\n\\n    Output example (for the CLI example above):\\n\\n    .. code-block:: yaml\\n\\n        edge01.lon01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n                Configuration discarded.\\n            diff:\\n                [edit snmp]\\n                -  location \"London, UK\";\\n                +  location \"Greenwich, UK\";\\n            result:\\n                True\\n    '\n    dic = {'template_name': 'snmp_config', 'test': test, 'commit': commit}\n    if chassis_id:\n        dic['chassis_id'] = chassis_id\n    if community:\n        dic['community'] = community\n    if contact:\n        dic['contact'] = contact\n    if location:\n        dic['location'] = location\n    dic['inherit_napalm_device'] = napalm_device\n    return __salt__['net.load_template'](**dic)"
        ]
    }
]