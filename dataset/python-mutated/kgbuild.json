[
    {
        "func_name": "_get_missing_results",
        "original": "def _get_missing_results(results, dest_dir):\n    \"\"\"\n    Return a list of the filenames specified in the ``results`` argument, which\n    are not present in the dest_dir.\n    \"\"\"\n    try:\n        present = set(os.listdir(dest_dir))\n    except OSError as exc:\n        if exc.errno == errno.ENOENT:\n            log.debug(\"pkgbuild.built: dest_dir '%s' does not exist\", dest_dir)\n        elif exc.errno == errno.EACCES:\n            log.error(\"pkgbuilt.built: cannot access dest_dir '%s'\", dest_dir)\n        present = set()\n    return sorted(set(results).difference(present))",
        "mutated": [
            "def _get_missing_results(results, dest_dir):\n    if False:\n        i = 10\n    '\\n    Return a list of the filenames specified in the ``results`` argument, which\\n    are not present in the dest_dir.\\n    '\n    try:\n        present = set(os.listdir(dest_dir))\n    except OSError as exc:\n        if exc.errno == errno.ENOENT:\n            log.debug(\"pkgbuild.built: dest_dir '%s' does not exist\", dest_dir)\n        elif exc.errno == errno.EACCES:\n            log.error(\"pkgbuilt.built: cannot access dest_dir '%s'\", dest_dir)\n        present = set()\n    return sorted(set(results).difference(present))",
            "def _get_missing_results(results, dest_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a list of the filenames specified in the ``results`` argument, which\\n    are not present in the dest_dir.\\n    '\n    try:\n        present = set(os.listdir(dest_dir))\n    except OSError as exc:\n        if exc.errno == errno.ENOENT:\n            log.debug(\"pkgbuild.built: dest_dir '%s' does not exist\", dest_dir)\n        elif exc.errno == errno.EACCES:\n            log.error(\"pkgbuilt.built: cannot access dest_dir '%s'\", dest_dir)\n        present = set()\n    return sorted(set(results).difference(present))",
            "def _get_missing_results(results, dest_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a list of the filenames specified in the ``results`` argument, which\\n    are not present in the dest_dir.\\n    '\n    try:\n        present = set(os.listdir(dest_dir))\n    except OSError as exc:\n        if exc.errno == errno.ENOENT:\n            log.debug(\"pkgbuild.built: dest_dir '%s' does not exist\", dest_dir)\n        elif exc.errno == errno.EACCES:\n            log.error(\"pkgbuilt.built: cannot access dest_dir '%s'\", dest_dir)\n        present = set()\n    return sorted(set(results).difference(present))",
            "def _get_missing_results(results, dest_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a list of the filenames specified in the ``results`` argument, which\\n    are not present in the dest_dir.\\n    '\n    try:\n        present = set(os.listdir(dest_dir))\n    except OSError as exc:\n        if exc.errno == errno.ENOENT:\n            log.debug(\"pkgbuild.built: dest_dir '%s' does not exist\", dest_dir)\n        elif exc.errno == errno.EACCES:\n            log.error(\"pkgbuilt.built: cannot access dest_dir '%s'\", dest_dir)\n        present = set()\n    return sorted(set(results).difference(present))",
            "def _get_missing_results(results, dest_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a list of the filenames specified in the ``results`` argument, which\\n    are not present in the dest_dir.\\n    '\n    try:\n        present = set(os.listdir(dest_dir))\n    except OSError as exc:\n        if exc.errno == errno.ENOENT:\n            log.debug(\"pkgbuild.built: dest_dir '%s' does not exist\", dest_dir)\n        elif exc.errno == errno.EACCES:\n            log.error(\"pkgbuilt.built: cannot access dest_dir '%s'\", dest_dir)\n        present = set()\n    return sorted(set(results).difference(present))"
        ]
    },
    {
        "func_name": "built",
        "original": "def built(name, runas, dest_dir, spec, sources, tgt, template=None, deps=None, env=None, results=None, force=False, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    \"\"\"\n    Ensure that the named package is built and exists in the named directory\n\n    name\n        The name to track the build, the name value is otherwise unused\n\n    runas\n        The user to run the build process as\n\n    dest_dir\n        The directory on the minion to place the built package(s)\n\n    spec\n        The location of the spec file (used for rpms)\n\n    sources\n        The list of package sources\n\n    tgt\n        The target platform to run the build on\n\n    template\n        Run the spec file through a templating engine\n\n        .. versionchanged:: 2015.8.2\n\n            This argument is now optional, allowing for no templating engine to\n            be used if none is desired.\n\n    deps\n        Packages required to ensure that the named package is built\n        can be hosted on either the salt master server or on an HTTP\n        or FTP server.  Both HTTPS and HTTP are supported as well as\n        downloading directly from Amazon S3 compatible URLs with both\n        pre-configured and automatic IAM credentials\n\n    env\n        A dictionary of environment variables to be set prior to execution.\n        Example:\n\n        .. code-block:: yaml\n\n            - env:\n                DEB_BUILD_OPTIONS: 'nocheck'\n\n        .. warning::\n\n            The above illustrates a common PyYAML pitfall, that **yes**,\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\n            boolean ``True`` and ``False`` values, and must be enclosed in\n            quotes to be used as strings. More info on this (and other) PyYAML\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\n\n    results\n        The names of the expected rpms that will be built\n\n    force : False\n        If ``True``, packages will be built even if they already exist in the\n        ``dest_dir``. This is useful when building a package for continuous or\n        nightly package builds.\n\n        .. versionadded:: 2015.8.2\n\n    saltenv\n        The saltenv to use for files downloaded from the salt filesever\n\n    log_dir : /var/log/salt/rpmbuild\n        Root directory for log files created from the build. Logs will be\n        organized by package name, version, OS release, and CPU architecture\n        under this directory.\n\n        .. versionadded:: 2015.8.2\n    \"\"\"\n    ret = {'name': name, 'changes': {}, 'comment': '', 'result': True}\n    if not results:\n        ret['comment'] = \"'results' argument is required\"\n        ret['result'] = False\n        return ret\n    if isinstance(results, str):\n        results = results.split(',')\n    needed = _get_missing_results(results, dest_dir)\n    if not force and (not needed):\n        ret['comment'] = 'All needed packages exist'\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        if force:\n            ret['comment'] = 'Packages will be force-built'\n        else:\n            ret['comment'] = 'The following packages need to be built: '\n            ret['comment'] += ', '.join(needed)\n        return ret\n    if env is not None and (not isinstance(env, dict)):\n        ret['comment'] = \"Invalidly-formatted 'env' parameter. See documentation.\"\n        ret['result'] = False\n        return ret\n    func = 'pkgbuild.build'\n    if __grains__.get('os_family', False) not in ('RedHat', 'Suse'):\n        for res in results:\n            if res.endswith('.rpm'):\n                func = 'rpmbuild.build'\n                break\n    ret['changes'] = __salt__[func](runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv, log_dir)\n    needed = _get_missing_results(results, dest_dir)\n    if needed:\n        ret['comment'] = 'The following packages were not built: '\n        ret['comment'] += ', '.join(needed)\n        ret['result'] = False\n    else:\n        ret['comment'] = 'All needed packages were built'\n    return ret",
        "mutated": [
            "def built(name, runas, dest_dir, spec, sources, tgt, template=None, deps=None, env=None, results=None, force=False, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    if False:\n        i = 10\n    \"\\n    Ensure that the named package is built and exists in the named directory\\n\\n    name\\n        The name to track the build, the name value is otherwise unused\\n\\n    runas\\n        The user to run the build process as\\n\\n    dest_dir\\n        The directory on the minion to place the built package(s)\\n\\n    spec\\n        The location of the spec file (used for rpms)\\n\\n    sources\\n        The list of package sources\\n\\n    tgt\\n        The target platform to run the build on\\n\\n    template\\n        Run the spec file through a templating engine\\n\\n        .. versionchanged:: 2015.8.2\\n\\n            This argument is now optional, allowing for no templating engine to\\n            be used if none is desired.\\n\\n    deps\\n        Packages required to ensure that the named package is built\\n        can be hosted on either the salt master server or on an HTTP\\n        or FTP server.  Both HTTPS and HTTP are supported as well as\\n        downloading directly from Amazon S3 compatible URLs with both\\n        pre-configured and automatic IAM credentials\\n\\n    env\\n        A dictionary of environment variables to be set prior to execution.\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                DEB_BUILD_OPTIONS: 'nocheck'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    results\\n        The names of the expected rpms that will be built\\n\\n    force : False\\n        If ``True``, packages will be built even if they already exist in the\\n        ``dest_dir``. This is useful when building a package for continuous or\\n        nightly package builds.\\n\\n        .. versionadded:: 2015.8.2\\n\\n    saltenv\\n        The saltenv to use for files downloaded from the salt filesever\\n\\n    log_dir : /var/log/salt/rpmbuild\\n        Root directory for log files created from the build. Logs will be\\n        organized by package name, version, OS release, and CPU architecture\\n        under this directory.\\n\\n        .. versionadded:: 2015.8.2\\n    \"\n    ret = {'name': name, 'changes': {}, 'comment': '', 'result': True}\n    if not results:\n        ret['comment'] = \"'results' argument is required\"\n        ret['result'] = False\n        return ret\n    if isinstance(results, str):\n        results = results.split(',')\n    needed = _get_missing_results(results, dest_dir)\n    if not force and (not needed):\n        ret['comment'] = 'All needed packages exist'\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        if force:\n            ret['comment'] = 'Packages will be force-built'\n        else:\n            ret['comment'] = 'The following packages need to be built: '\n            ret['comment'] += ', '.join(needed)\n        return ret\n    if env is not None and (not isinstance(env, dict)):\n        ret['comment'] = \"Invalidly-formatted 'env' parameter. See documentation.\"\n        ret['result'] = False\n        return ret\n    func = 'pkgbuild.build'\n    if __grains__.get('os_family', False) not in ('RedHat', 'Suse'):\n        for res in results:\n            if res.endswith('.rpm'):\n                func = 'rpmbuild.build'\n                break\n    ret['changes'] = __salt__[func](runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv, log_dir)\n    needed = _get_missing_results(results, dest_dir)\n    if needed:\n        ret['comment'] = 'The following packages were not built: '\n        ret['comment'] += ', '.join(needed)\n        ret['result'] = False\n    else:\n        ret['comment'] = 'All needed packages were built'\n    return ret",
            "def built(name, runas, dest_dir, spec, sources, tgt, template=None, deps=None, env=None, results=None, force=False, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Ensure that the named package is built and exists in the named directory\\n\\n    name\\n        The name to track the build, the name value is otherwise unused\\n\\n    runas\\n        The user to run the build process as\\n\\n    dest_dir\\n        The directory on the minion to place the built package(s)\\n\\n    spec\\n        The location of the spec file (used for rpms)\\n\\n    sources\\n        The list of package sources\\n\\n    tgt\\n        The target platform to run the build on\\n\\n    template\\n        Run the spec file through a templating engine\\n\\n        .. versionchanged:: 2015.8.2\\n\\n            This argument is now optional, allowing for no templating engine to\\n            be used if none is desired.\\n\\n    deps\\n        Packages required to ensure that the named package is built\\n        can be hosted on either the salt master server or on an HTTP\\n        or FTP server.  Both HTTPS and HTTP are supported as well as\\n        downloading directly from Amazon S3 compatible URLs with both\\n        pre-configured and automatic IAM credentials\\n\\n    env\\n        A dictionary of environment variables to be set prior to execution.\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                DEB_BUILD_OPTIONS: 'nocheck'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    results\\n        The names of the expected rpms that will be built\\n\\n    force : False\\n        If ``True``, packages will be built even if they already exist in the\\n        ``dest_dir``. This is useful when building a package for continuous or\\n        nightly package builds.\\n\\n        .. versionadded:: 2015.8.2\\n\\n    saltenv\\n        The saltenv to use for files downloaded from the salt filesever\\n\\n    log_dir : /var/log/salt/rpmbuild\\n        Root directory for log files created from the build. Logs will be\\n        organized by package name, version, OS release, and CPU architecture\\n        under this directory.\\n\\n        .. versionadded:: 2015.8.2\\n    \"\n    ret = {'name': name, 'changes': {}, 'comment': '', 'result': True}\n    if not results:\n        ret['comment'] = \"'results' argument is required\"\n        ret['result'] = False\n        return ret\n    if isinstance(results, str):\n        results = results.split(',')\n    needed = _get_missing_results(results, dest_dir)\n    if not force and (not needed):\n        ret['comment'] = 'All needed packages exist'\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        if force:\n            ret['comment'] = 'Packages will be force-built'\n        else:\n            ret['comment'] = 'The following packages need to be built: '\n            ret['comment'] += ', '.join(needed)\n        return ret\n    if env is not None and (not isinstance(env, dict)):\n        ret['comment'] = \"Invalidly-formatted 'env' parameter. See documentation.\"\n        ret['result'] = False\n        return ret\n    func = 'pkgbuild.build'\n    if __grains__.get('os_family', False) not in ('RedHat', 'Suse'):\n        for res in results:\n            if res.endswith('.rpm'):\n                func = 'rpmbuild.build'\n                break\n    ret['changes'] = __salt__[func](runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv, log_dir)\n    needed = _get_missing_results(results, dest_dir)\n    if needed:\n        ret['comment'] = 'The following packages were not built: '\n        ret['comment'] += ', '.join(needed)\n        ret['result'] = False\n    else:\n        ret['comment'] = 'All needed packages were built'\n    return ret",
            "def built(name, runas, dest_dir, spec, sources, tgt, template=None, deps=None, env=None, results=None, force=False, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Ensure that the named package is built and exists in the named directory\\n\\n    name\\n        The name to track the build, the name value is otherwise unused\\n\\n    runas\\n        The user to run the build process as\\n\\n    dest_dir\\n        The directory on the minion to place the built package(s)\\n\\n    spec\\n        The location of the spec file (used for rpms)\\n\\n    sources\\n        The list of package sources\\n\\n    tgt\\n        The target platform to run the build on\\n\\n    template\\n        Run the spec file through a templating engine\\n\\n        .. versionchanged:: 2015.8.2\\n\\n            This argument is now optional, allowing for no templating engine to\\n            be used if none is desired.\\n\\n    deps\\n        Packages required to ensure that the named package is built\\n        can be hosted on either the salt master server or on an HTTP\\n        or FTP server.  Both HTTPS and HTTP are supported as well as\\n        downloading directly from Amazon S3 compatible URLs with both\\n        pre-configured and automatic IAM credentials\\n\\n    env\\n        A dictionary of environment variables to be set prior to execution.\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                DEB_BUILD_OPTIONS: 'nocheck'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    results\\n        The names of the expected rpms that will be built\\n\\n    force : False\\n        If ``True``, packages will be built even if they already exist in the\\n        ``dest_dir``. This is useful when building a package for continuous or\\n        nightly package builds.\\n\\n        .. versionadded:: 2015.8.2\\n\\n    saltenv\\n        The saltenv to use for files downloaded from the salt filesever\\n\\n    log_dir : /var/log/salt/rpmbuild\\n        Root directory for log files created from the build. Logs will be\\n        organized by package name, version, OS release, and CPU architecture\\n        under this directory.\\n\\n        .. versionadded:: 2015.8.2\\n    \"\n    ret = {'name': name, 'changes': {}, 'comment': '', 'result': True}\n    if not results:\n        ret['comment'] = \"'results' argument is required\"\n        ret['result'] = False\n        return ret\n    if isinstance(results, str):\n        results = results.split(',')\n    needed = _get_missing_results(results, dest_dir)\n    if not force and (not needed):\n        ret['comment'] = 'All needed packages exist'\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        if force:\n            ret['comment'] = 'Packages will be force-built'\n        else:\n            ret['comment'] = 'The following packages need to be built: '\n            ret['comment'] += ', '.join(needed)\n        return ret\n    if env is not None and (not isinstance(env, dict)):\n        ret['comment'] = \"Invalidly-formatted 'env' parameter. See documentation.\"\n        ret['result'] = False\n        return ret\n    func = 'pkgbuild.build'\n    if __grains__.get('os_family', False) not in ('RedHat', 'Suse'):\n        for res in results:\n            if res.endswith('.rpm'):\n                func = 'rpmbuild.build'\n                break\n    ret['changes'] = __salt__[func](runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv, log_dir)\n    needed = _get_missing_results(results, dest_dir)\n    if needed:\n        ret['comment'] = 'The following packages were not built: '\n        ret['comment'] += ', '.join(needed)\n        ret['result'] = False\n    else:\n        ret['comment'] = 'All needed packages were built'\n    return ret",
            "def built(name, runas, dest_dir, spec, sources, tgt, template=None, deps=None, env=None, results=None, force=False, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Ensure that the named package is built and exists in the named directory\\n\\n    name\\n        The name to track the build, the name value is otherwise unused\\n\\n    runas\\n        The user to run the build process as\\n\\n    dest_dir\\n        The directory on the minion to place the built package(s)\\n\\n    spec\\n        The location of the spec file (used for rpms)\\n\\n    sources\\n        The list of package sources\\n\\n    tgt\\n        The target platform to run the build on\\n\\n    template\\n        Run the spec file through a templating engine\\n\\n        .. versionchanged:: 2015.8.2\\n\\n            This argument is now optional, allowing for no templating engine to\\n            be used if none is desired.\\n\\n    deps\\n        Packages required to ensure that the named package is built\\n        can be hosted on either the salt master server or on an HTTP\\n        or FTP server.  Both HTTPS and HTTP are supported as well as\\n        downloading directly from Amazon S3 compatible URLs with both\\n        pre-configured and automatic IAM credentials\\n\\n    env\\n        A dictionary of environment variables to be set prior to execution.\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                DEB_BUILD_OPTIONS: 'nocheck'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    results\\n        The names of the expected rpms that will be built\\n\\n    force : False\\n        If ``True``, packages will be built even if they already exist in the\\n        ``dest_dir``. This is useful when building a package for continuous or\\n        nightly package builds.\\n\\n        .. versionadded:: 2015.8.2\\n\\n    saltenv\\n        The saltenv to use for files downloaded from the salt filesever\\n\\n    log_dir : /var/log/salt/rpmbuild\\n        Root directory for log files created from the build. Logs will be\\n        organized by package name, version, OS release, and CPU architecture\\n        under this directory.\\n\\n        .. versionadded:: 2015.8.2\\n    \"\n    ret = {'name': name, 'changes': {}, 'comment': '', 'result': True}\n    if not results:\n        ret['comment'] = \"'results' argument is required\"\n        ret['result'] = False\n        return ret\n    if isinstance(results, str):\n        results = results.split(',')\n    needed = _get_missing_results(results, dest_dir)\n    if not force and (not needed):\n        ret['comment'] = 'All needed packages exist'\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        if force:\n            ret['comment'] = 'Packages will be force-built'\n        else:\n            ret['comment'] = 'The following packages need to be built: '\n            ret['comment'] += ', '.join(needed)\n        return ret\n    if env is not None and (not isinstance(env, dict)):\n        ret['comment'] = \"Invalidly-formatted 'env' parameter. See documentation.\"\n        ret['result'] = False\n        return ret\n    func = 'pkgbuild.build'\n    if __grains__.get('os_family', False) not in ('RedHat', 'Suse'):\n        for res in results:\n            if res.endswith('.rpm'):\n                func = 'rpmbuild.build'\n                break\n    ret['changes'] = __salt__[func](runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv, log_dir)\n    needed = _get_missing_results(results, dest_dir)\n    if needed:\n        ret['comment'] = 'The following packages were not built: '\n        ret['comment'] += ', '.join(needed)\n        ret['result'] = False\n    else:\n        ret['comment'] = 'All needed packages were built'\n    return ret",
            "def built(name, runas, dest_dir, spec, sources, tgt, template=None, deps=None, env=None, results=None, force=False, saltenv='base', log_dir='/var/log/salt/pkgbuild'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Ensure that the named package is built and exists in the named directory\\n\\n    name\\n        The name to track the build, the name value is otherwise unused\\n\\n    runas\\n        The user to run the build process as\\n\\n    dest_dir\\n        The directory on the minion to place the built package(s)\\n\\n    spec\\n        The location of the spec file (used for rpms)\\n\\n    sources\\n        The list of package sources\\n\\n    tgt\\n        The target platform to run the build on\\n\\n    template\\n        Run the spec file through a templating engine\\n\\n        .. versionchanged:: 2015.8.2\\n\\n            This argument is now optional, allowing for no templating engine to\\n            be used if none is desired.\\n\\n    deps\\n        Packages required to ensure that the named package is built\\n        can be hosted on either the salt master server or on an HTTP\\n        or FTP server.  Both HTTPS and HTTP are supported as well as\\n        downloading directly from Amazon S3 compatible URLs with both\\n        pre-configured and automatic IAM credentials\\n\\n    env\\n        A dictionary of environment variables to be set prior to execution.\\n        Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                DEB_BUILD_OPTIONS: 'nocheck'\\n\\n        .. warning::\\n\\n            The above illustrates a common PyYAML pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other) PyYAML\\n            idiosyncrasies can be found :ref:`here <yaml-idiosyncrasies>`.\\n\\n    results\\n        The names of the expected rpms that will be built\\n\\n    force : False\\n        If ``True``, packages will be built even if they already exist in the\\n        ``dest_dir``. This is useful when building a package for continuous or\\n        nightly package builds.\\n\\n        .. versionadded:: 2015.8.2\\n\\n    saltenv\\n        The saltenv to use for files downloaded from the salt filesever\\n\\n    log_dir : /var/log/salt/rpmbuild\\n        Root directory for log files created from the build. Logs will be\\n        organized by package name, version, OS release, and CPU architecture\\n        under this directory.\\n\\n        .. versionadded:: 2015.8.2\\n    \"\n    ret = {'name': name, 'changes': {}, 'comment': '', 'result': True}\n    if not results:\n        ret['comment'] = \"'results' argument is required\"\n        ret['result'] = False\n        return ret\n    if isinstance(results, str):\n        results = results.split(',')\n    needed = _get_missing_results(results, dest_dir)\n    if not force and (not needed):\n        ret['comment'] = 'All needed packages exist'\n        return ret\n    if __opts__['test']:\n        ret['result'] = None\n        if force:\n            ret['comment'] = 'Packages will be force-built'\n        else:\n            ret['comment'] = 'The following packages need to be built: '\n            ret['comment'] += ', '.join(needed)\n        return ret\n    if env is not None and (not isinstance(env, dict)):\n        ret['comment'] = \"Invalidly-formatted 'env' parameter. See documentation.\"\n        ret['result'] = False\n        return ret\n    func = 'pkgbuild.build'\n    if __grains__.get('os_family', False) not in ('RedHat', 'Suse'):\n        for res in results:\n            if res.endswith('.rpm'):\n                func = 'rpmbuild.build'\n                break\n    ret['changes'] = __salt__[func](runas, tgt, dest_dir, spec, sources, deps, env, template, saltenv, log_dir)\n    needed = _get_missing_results(results, dest_dir)\n    if needed:\n        ret['comment'] = 'The following packages were not built: '\n        ret['comment'] += ', '.join(needed)\n        ret['result'] = False\n    else:\n        ret['comment'] = 'All needed packages were built'\n    return ret"
        ]
    },
    {
        "func_name": "repo",
        "original": "def repo(name, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='builder', timeout=15.0):\n    \"\"\"\n    Make a package repository and optionally sign it and packages present\n\n    The name is directory to turn into a repo. This state is best used\n    with onchanges linked to your package building states.\n\n    name\n        The directory to find packages that will be in the repository\n\n    keyid\n        .. versionchanged:: 2016.3.0\n\n        Optional Key ID to use in signing packages and repository.\n        Utilizes Public and Private keys associated with keyid which have\n        been loaded into the minion's Pillar data.\n\n        For example, contents from a Pillar data file with named Public\n        and Private keys as follows:\n\n        .. code-block:: yaml\n\n            gpg_pkg_priv_key: |\n              -----BEGIN PGP PRIVATE KEY BLOCK-----\n              Version: GnuPG v1\n\n              lQO+BFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\n              .\n              .\n              Ebe+8JCQTwqSXPRTzXmy/b5WXDeM79CkLWvuGpXFor76D+ECMRPv/rawukEcNptn\n              R5OmgHqvydEnO4pWbn8JzQO9YX/Us0SMHBVzLC8eIi5ZIopzalvX\n              =JvW8\n              -----END PGP PRIVATE KEY BLOCK-----\n\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\n\n            gpg_pkg_pub_key: |\n              -----BEGIN PGP PUBLIC KEY BLOCK-----\n              Version: GnuPG v1\n\n              mQENBFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\n              .\n              .\n              bYP7t5iwJmQzRMyFInYRt77wkJBPCpJc9FPNebL9vlZcN4zv0KQta+4alcWivvoP\n              4QIxE+/+trC6QRw2m2dHk6aAeq/J0Sc7ilZufwnNA71hf9SzRIwcFXMsLx4iLlki\n              inNqW9c=\n              =s1CX\n              -----END PGP PUBLIC KEY BLOCK-----\n\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\n\n    env\n        .. versionchanged:: 2016.3.0\n\n        A dictionary of environment variables to be utilized in creating the\n        repository. Example:\n\n        .. code-block:: yaml\n\n            - env:\n                OPTIONS: 'ask-passphrase'\n\n        .. warning::\n\n            The above illustrates a common ``PyYAML`` pitfall, that **yes**,\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\n            boolean ``True`` and ``False`` values, and must be enclosed in\n            quotes to be used as strings. More info on this (and other)\n            ``PyYAML`` idiosyncrasies can be found :ref:`here\n            <yaml-idiosyncrasies>`.\n\n            Use of ``OPTIONS`` on some platforms, for example:\n            ``ask-passphrase``, will require ``gpg-agent`` or similar to cache\n            passphrases.\n\n        .. note::\n\n            This parameter is not used for making ``yum`` repositories.\n\n    use_passphrase : False\n        .. versionadded:: 2016.3.0\n\n        Use a passphrase with the signing key presented in ``keyid``.\n        Passphrase is received from Pillar data which could be passed on the\n        command line with ``pillar`` parameter. For example:\n\n        .. code-block:: bash\n\n            pillar='{ \"gpg_passphrase\" : \"my_passphrase\" }'\n\n    gnupghome : /etc/salt/gpgkeys\n        .. versionadded:: 2016.3.0\n\n        Location where GPG related files are stored, used with 'keyid'\n\n    runas : builder\n        .. versionadded:: 2016.3.0\n\n        User to create the repository as, and optionally sign packages.\n\n        .. note::\n\n            Ensure the user has correct permissions to any files and\n            directories which are to be utilized.\n\n    timeout : 15.0\n        .. versionadded:: 2016.3.4\n\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\n\n    \"\"\"\n    ret = {'name': name, 'changes': {}, 'comment': '', 'result': True}\n    if __opts__['test'] is True:\n        ret['result'] = None\n        ret['comment'] = 'Package repo metadata at {} will be refreshed'.format(name)\n        return ret\n    if env is not None and (not isinstance(env, dict)):\n        ret['comment'] = \"Invalidly-formatted 'env' parameter. See documentation.\"\n        return ret\n    func = 'pkgbuild.make_repo'\n    if __grains__.get('os_family', False) not in ('RedHat', 'Suse'):\n        for file in os.listdir(name):\n            if file.endswith('.rpm'):\n                func = 'rpmbuild.make_repo'\n                break\n    res = __salt__[func](name, keyid, env, use_passphrase, gnupghome, runas, timeout)\n    if res['retcode'] > 0:\n        ret['result'] = False\n    else:\n        ret['changes'] = {'refresh': True}\n    if res['stdout'] and res['stderr']:\n        ret['comment'] = '{}\\n{}'.format(res['stdout'], res['stderr'])\n    elif res['stdout']:\n        ret['comment'] = res['stdout']\n    elif res['stderr']:\n        ret['comment'] = res['stderr']\n    return ret",
        "mutated": [
            "def repo(name, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='builder', timeout=15.0):\n    if False:\n        i = 10\n    '\\n    Make a package repository and optionally sign it and packages present\\n\\n    The name is directory to turn into a repo. This state is best used\\n    with onchanges linked to your package building states.\\n\\n    name\\n        The directory to find packages that will be in the repository\\n\\n    keyid\\n        .. versionchanged:: 2016.3.0\\n\\n        Optional Key ID to use in signing packages and repository.\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion\\'s Pillar data.\\n\\n        For example, contents from a Pillar data file with named Public\\n        and Private keys as follows:\\n\\n        .. code-block:: yaml\\n\\n            gpg_pkg_priv_key: |\\n              -----BEGIN PGP PRIVATE KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              lQO+BFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              Ebe+8JCQTwqSXPRTzXmy/b5WXDeM79CkLWvuGpXFor76D+ECMRPv/rawukEcNptn\\n              R5OmgHqvydEnO4pWbn8JzQO9YX/Us0SMHBVzLC8eIi5ZIopzalvX\\n              =JvW8\\n              -----END PGP PRIVATE KEY BLOCK-----\\n\\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\\n\\n            gpg_pkg_pub_key: |\\n              -----BEGIN PGP PUBLIC KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              mQENBFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              bYP7t5iwJmQzRMyFInYRt77wkJBPCpJc9FPNebL9vlZcN4zv0KQta+4alcWivvoP\\n              4QIxE+/+trC6QRw2m2dHk6aAeq/J0Sc7ilZufwnNA71hf9SzRIwcFXMsLx4iLlki\\n              inNqW9c=\\n              =s1CX\\n              -----END PGP PUBLIC KEY BLOCK-----\\n\\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\\n\\n    env\\n        .. versionchanged:: 2016.3.0\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository. Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                OPTIONS: \\'ask-passphrase\\'\\n\\n        .. warning::\\n\\n            The above illustrates a common ``PyYAML`` pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other)\\n            ``PyYAML`` idiosyncrasies can be found :ref:`here\\n            <yaml-idiosyncrasies>`.\\n\\n            Use of ``OPTIONS`` on some platforms, for example:\\n            ``ask-passphrase``, will require ``gpg-agent`` or similar to cache\\n            passphrases.\\n\\n        .. note::\\n\\n            This parameter is not used for making ``yum`` repositories.\\n\\n    use_passphrase : False\\n        .. versionadded:: 2016.3.0\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter. For example:\\n\\n        .. code-block:: bash\\n\\n            pillar=\\'{ \"gpg_passphrase\" : \"my_passphrase\" }\\'\\n\\n    gnupghome : /etc/salt/gpgkeys\\n        .. versionadded:: 2016.3.0\\n\\n        Location where GPG related files are stored, used with \\'keyid\\'\\n\\n    runas : builder\\n        .. versionadded:: 2016.3.0\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n    timeout : 15.0\\n        .. versionadded:: 2016.3.4\\n\\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\\n\\n    '\n    ret = {'name': name, 'changes': {}, 'comment': '', 'result': True}\n    if __opts__['test'] is True:\n        ret['result'] = None\n        ret['comment'] = 'Package repo metadata at {} will be refreshed'.format(name)\n        return ret\n    if env is not None and (not isinstance(env, dict)):\n        ret['comment'] = \"Invalidly-formatted 'env' parameter. See documentation.\"\n        return ret\n    func = 'pkgbuild.make_repo'\n    if __grains__.get('os_family', False) not in ('RedHat', 'Suse'):\n        for file in os.listdir(name):\n            if file.endswith('.rpm'):\n                func = 'rpmbuild.make_repo'\n                break\n    res = __salt__[func](name, keyid, env, use_passphrase, gnupghome, runas, timeout)\n    if res['retcode'] > 0:\n        ret['result'] = False\n    else:\n        ret['changes'] = {'refresh': True}\n    if res['stdout'] and res['stderr']:\n        ret['comment'] = '{}\\n{}'.format(res['stdout'], res['stderr'])\n    elif res['stdout']:\n        ret['comment'] = res['stdout']\n    elif res['stderr']:\n        ret['comment'] = res['stderr']\n    return ret",
            "def repo(name, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='builder', timeout=15.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Make a package repository and optionally sign it and packages present\\n\\n    The name is directory to turn into a repo. This state is best used\\n    with onchanges linked to your package building states.\\n\\n    name\\n        The directory to find packages that will be in the repository\\n\\n    keyid\\n        .. versionchanged:: 2016.3.0\\n\\n        Optional Key ID to use in signing packages and repository.\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion\\'s Pillar data.\\n\\n        For example, contents from a Pillar data file with named Public\\n        and Private keys as follows:\\n\\n        .. code-block:: yaml\\n\\n            gpg_pkg_priv_key: |\\n              -----BEGIN PGP PRIVATE KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              lQO+BFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              Ebe+8JCQTwqSXPRTzXmy/b5WXDeM79CkLWvuGpXFor76D+ECMRPv/rawukEcNptn\\n              R5OmgHqvydEnO4pWbn8JzQO9YX/Us0SMHBVzLC8eIi5ZIopzalvX\\n              =JvW8\\n              -----END PGP PRIVATE KEY BLOCK-----\\n\\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\\n\\n            gpg_pkg_pub_key: |\\n              -----BEGIN PGP PUBLIC KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              mQENBFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              bYP7t5iwJmQzRMyFInYRt77wkJBPCpJc9FPNebL9vlZcN4zv0KQta+4alcWivvoP\\n              4QIxE+/+trC6QRw2m2dHk6aAeq/J0Sc7ilZufwnNA71hf9SzRIwcFXMsLx4iLlki\\n              inNqW9c=\\n              =s1CX\\n              -----END PGP PUBLIC KEY BLOCK-----\\n\\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\\n\\n    env\\n        .. versionchanged:: 2016.3.0\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository. Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                OPTIONS: \\'ask-passphrase\\'\\n\\n        .. warning::\\n\\n            The above illustrates a common ``PyYAML`` pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other)\\n            ``PyYAML`` idiosyncrasies can be found :ref:`here\\n            <yaml-idiosyncrasies>`.\\n\\n            Use of ``OPTIONS`` on some platforms, for example:\\n            ``ask-passphrase``, will require ``gpg-agent`` or similar to cache\\n            passphrases.\\n\\n        .. note::\\n\\n            This parameter is not used for making ``yum`` repositories.\\n\\n    use_passphrase : False\\n        .. versionadded:: 2016.3.0\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter. For example:\\n\\n        .. code-block:: bash\\n\\n            pillar=\\'{ \"gpg_passphrase\" : \"my_passphrase\" }\\'\\n\\n    gnupghome : /etc/salt/gpgkeys\\n        .. versionadded:: 2016.3.0\\n\\n        Location where GPG related files are stored, used with \\'keyid\\'\\n\\n    runas : builder\\n        .. versionadded:: 2016.3.0\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n    timeout : 15.0\\n        .. versionadded:: 2016.3.4\\n\\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\\n\\n    '\n    ret = {'name': name, 'changes': {}, 'comment': '', 'result': True}\n    if __opts__['test'] is True:\n        ret['result'] = None\n        ret['comment'] = 'Package repo metadata at {} will be refreshed'.format(name)\n        return ret\n    if env is not None and (not isinstance(env, dict)):\n        ret['comment'] = \"Invalidly-formatted 'env' parameter. See documentation.\"\n        return ret\n    func = 'pkgbuild.make_repo'\n    if __grains__.get('os_family', False) not in ('RedHat', 'Suse'):\n        for file in os.listdir(name):\n            if file.endswith('.rpm'):\n                func = 'rpmbuild.make_repo'\n                break\n    res = __salt__[func](name, keyid, env, use_passphrase, gnupghome, runas, timeout)\n    if res['retcode'] > 0:\n        ret['result'] = False\n    else:\n        ret['changes'] = {'refresh': True}\n    if res['stdout'] and res['stderr']:\n        ret['comment'] = '{}\\n{}'.format(res['stdout'], res['stderr'])\n    elif res['stdout']:\n        ret['comment'] = res['stdout']\n    elif res['stderr']:\n        ret['comment'] = res['stderr']\n    return ret",
            "def repo(name, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='builder', timeout=15.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Make a package repository and optionally sign it and packages present\\n\\n    The name is directory to turn into a repo. This state is best used\\n    with onchanges linked to your package building states.\\n\\n    name\\n        The directory to find packages that will be in the repository\\n\\n    keyid\\n        .. versionchanged:: 2016.3.0\\n\\n        Optional Key ID to use in signing packages and repository.\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion\\'s Pillar data.\\n\\n        For example, contents from a Pillar data file with named Public\\n        and Private keys as follows:\\n\\n        .. code-block:: yaml\\n\\n            gpg_pkg_priv_key: |\\n              -----BEGIN PGP PRIVATE KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              lQO+BFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              Ebe+8JCQTwqSXPRTzXmy/b5WXDeM79CkLWvuGpXFor76D+ECMRPv/rawukEcNptn\\n              R5OmgHqvydEnO4pWbn8JzQO9YX/Us0SMHBVzLC8eIi5ZIopzalvX\\n              =JvW8\\n              -----END PGP PRIVATE KEY BLOCK-----\\n\\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\\n\\n            gpg_pkg_pub_key: |\\n              -----BEGIN PGP PUBLIC KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              mQENBFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              bYP7t5iwJmQzRMyFInYRt77wkJBPCpJc9FPNebL9vlZcN4zv0KQta+4alcWivvoP\\n              4QIxE+/+trC6QRw2m2dHk6aAeq/J0Sc7ilZufwnNA71hf9SzRIwcFXMsLx4iLlki\\n              inNqW9c=\\n              =s1CX\\n              -----END PGP PUBLIC KEY BLOCK-----\\n\\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\\n\\n    env\\n        .. versionchanged:: 2016.3.0\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository. Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                OPTIONS: \\'ask-passphrase\\'\\n\\n        .. warning::\\n\\n            The above illustrates a common ``PyYAML`` pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other)\\n            ``PyYAML`` idiosyncrasies can be found :ref:`here\\n            <yaml-idiosyncrasies>`.\\n\\n            Use of ``OPTIONS`` on some platforms, for example:\\n            ``ask-passphrase``, will require ``gpg-agent`` or similar to cache\\n            passphrases.\\n\\n        .. note::\\n\\n            This parameter is not used for making ``yum`` repositories.\\n\\n    use_passphrase : False\\n        .. versionadded:: 2016.3.0\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter. For example:\\n\\n        .. code-block:: bash\\n\\n            pillar=\\'{ \"gpg_passphrase\" : \"my_passphrase\" }\\'\\n\\n    gnupghome : /etc/salt/gpgkeys\\n        .. versionadded:: 2016.3.0\\n\\n        Location where GPG related files are stored, used with \\'keyid\\'\\n\\n    runas : builder\\n        .. versionadded:: 2016.3.0\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n    timeout : 15.0\\n        .. versionadded:: 2016.3.4\\n\\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\\n\\n    '\n    ret = {'name': name, 'changes': {}, 'comment': '', 'result': True}\n    if __opts__['test'] is True:\n        ret['result'] = None\n        ret['comment'] = 'Package repo metadata at {} will be refreshed'.format(name)\n        return ret\n    if env is not None and (not isinstance(env, dict)):\n        ret['comment'] = \"Invalidly-formatted 'env' parameter. See documentation.\"\n        return ret\n    func = 'pkgbuild.make_repo'\n    if __grains__.get('os_family', False) not in ('RedHat', 'Suse'):\n        for file in os.listdir(name):\n            if file.endswith('.rpm'):\n                func = 'rpmbuild.make_repo'\n                break\n    res = __salt__[func](name, keyid, env, use_passphrase, gnupghome, runas, timeout)\n    if res['retcode'] > 0:\n        ret['result'] = False\n    else:\n        ret['changes'] = {'refresh': True}\n    if res['stdout'] and res['stderr']:\n        ret['comment'] = '{}\\n{}'.format(res['stdout'], res['stderr'])\n    elif res['stdout']:\n        ret['comment'] = res['stdout']\n    elif res['stderr']:\n        ret['comment'] = res['stderr']\n    return ret",
            "def repo(name, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='builder', timeout=15.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Make a package repository and optionally sign it and packages present\\n\\n    The name is directory to turn into a repo. This state is best used\\n    with onchanges linked to your package building states.\\n\\n    name\\n        The directory to find packages that will be in the repository\\n\\n    keyid\\n        .. versionchanged:: 2016.3.0\\n\\n        Optional Key ID to use in signing packages and repository.\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion\\'s Pillar data.\\n\\n        For example, contents from a Pillar data file with named Public\\n        and Private keys as follows:\\n\\n        .. code-block:: yaml\\n\\n            gpg_pkg_priv_key: |\\n              -----BEGIN PGP PRIVATE KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              lQO+BFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              Ebe+8JCQTwqSXPRTzXmy/b5WXDeM79CkLWvuGpXFor76D+ECMRPv/rawukEcNptn\\n              R5OmgHqvydEnO4pWbn8JzQO9YX/Us0SMHBVzLC8eIi5ZIopzalvX\\n              =JvW8\\n              -----END PGP PRIVATE KEY BLOCK-----\\n\\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\\n\\n            gpg_pkg_pub_key: |\\n              -----BEGIN PGP PUBLIC KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              mQENBFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              bYP7t5iwJmQzRMyFInYRt77wkJBPCpJc9FPNebL9vlZcN4zv0KQta+4alcWivvoP\\n              4QIxE+/+trC6QRw2m2dHk6aAeq/J0Sc7ilZufwnNA71hf9SzRIwcFXMsLx4iLlki\\n              inNqW9c=\\n              =s1CX\\n              -----END PGP PUBLIC KEY BLOCK-----\\n\\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\\n\\n    env\\n        .. versionchanged:: 2016.3.0\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository. Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                OPTIONS: \\'ask-passphrase\\'\\n\\n        .. warning::\\n\\n            The above illustrates a common ``PyYAML`` pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other)\\n            ``PyYAML`` idiosyncrasies can be found :ref:`here\\n            <yaml-idiosyncrasies>`.\\n\\n            Use of ``OPTIONS`` on some platforms, for example:\\n            ``ask-passphrase``, will require ``gpg-agent`` or similar to cache\\n            passphrases.\\n\\n        .. note::\\n\\n            This parameter is not used for making ``yum`` repositories.\\n\\n    use_passphrase : False\\n        .. versionadded:: 2016.3.0\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter. For example:\\n\\n        .. code-block:: bash\\n\\n            pillar=\\'{ \"gpg_passphrase\" : \"my_passphrase\" }\\'\\n\\n    gnupghome : /etc/salt/gpgkeys\\n        .. versionadded:: 2016.3.0\\n\\n        Location where GPG related files are stored, used with \\'keyid\\'\\n\\n    runas : builder\\n        .. versionadded:: 2016.3.0\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n    timeout : 15.0\\n        .. versionadded:: 2016.3.4\\n\\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\\n\\n    '\n    ret = {'name': name, 'changes': {}, 'comment': '', 'result': True}\n    if __opts__['test'] is True:\n        ret['result'] = None\n        ret['comment'] = 'Package repo metadata at {} will be refreshed'.format(name)\n        return ret\n    if env is not None and (not isinstance(env, dict)):\n        ret['comment'] = \"Invalidly-formatted 'env' parameter. See documentation.\"\n        return ret\n    func = 'pkgbuild.make_repo'\n    if __grains__.get('os_family', False) not in ('RedHat', 'Suse'):\n        for file in os.listdir(name):\n            if file.endswith('.rpm'):\n                func = 'rpmbuild.make_repo'\n                break\n    res = __salt__[func](name, keyid, env, use_passphrase, gnupghome, runas, timeout)\n    if res['retcode'] > 0:\n        ret['result'] = False\n    else:\n        ret['changes'] = {'refresh': True}\n    if res['stdout'] and res['stderr']:\n        ret['comment'] = '{}\\n{}'.format(res['stdout'], res['stderr'])\n    elif res['stdout']:\n        ret['comment'] = res['stdout']\n    elif res['stderr']:\n        ret['comment'] = res['stderr']\n    return ret",
            "def repo(name, keyid=None, env=None, use_passphrase=False, gnupghome='/etc/salt/gpgkeys', runas='builder', timeout=15.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Make a package repository and optionally sign it and packages present\\n\\n    The name is directory to turn into a repo. This state is best used\\n    with onchanges linked to your package building states.\\n\\n    name\\n        The directory to find packages that will be in the repository\\n\\n    keyid\\n        .. versionchanged:: 2016.3.0\\n\\n        Optional Key ID to use in signing packages and repository.\\n        Utilizes Public and Private keys associated with keyid which have\\n        been loaded into the minion\\'s Pillar data.\\n\\n        For example, contents from a Pillar data file with named Public\\n        and Private keys as follows:\\n\\n        .. code-block:: yaml\\n\\n            gpg_pkg_priv_key: |\\n              -----BEGIN PGP PRIVATE KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              lQO+BFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              Ebe+8JCQTwqSXPRTzXmy/b5WXDeM79CkLWvuGpXFor76D+ECMRPv/rawukEcNptn\\n              R5OmgHqvydEnO4pWbn8JzQO9YX/Us0SMHBVzLC8eIi5ZIopzalvX\\n              =JvW8\\n              -----END PGP PRIVATE KEY BLOCK-----\\n\\n            gpg_pkg_priv_keyname: gpg_pkg_key.pem\\n\\n            gpg_pkg_pub_key: |\\n              -----BEGIN PGP PUBLIC KEY BLOCK-----\\n              Version: GnuPG v1\\n\\n              mQENBFciIfQBCADAPCtzx7I5Rl32escCMZsPzaEKWe7bIX1em4KCKkBoX47IG54b\\n              w82PCE8Y1jF/9Uk2m3RKVWp3YcLlc7Ap3gj6VO4ysvVz28UbnhPxsIkOlf2cq8qc\\n              .\\n              .\\n              bYP7t5iwJmQzRMyFInYRt77wkJBPCpJc9FPNebL9vlZcN4zv0KQta+4alcWivvoP\\n              4QIxE+/+trC6QRw2m2dHk6aAeq/J0Sc7ilZufwnNA71hf9SzRIwcFXMsLx4iLlki\\n              inNqW9c=\\n              =s1CX\\n              -----END PGP PUBLIC KEY BLOCK-----\\n\\n            gpg_pkg_pub_keyname: gpg_pkg_key.pub\\n\\n    env\\n        .. versionchanged:: 2016.3.0\\n\\n        A dictionary of environment variables to be utilized in creating the\\n        repository. Example:\\n\\n        .. code-block:: yaml\\n\\n            - env:\\n                OPTIONS: \\'ask-passphrase\\'\\n\\n        .. warning::\\n\\n            The above illustrates a common ``PyYAML`` pitfall, that **yes**,\\n            **no**, **on**, **off**, **true**, and **false** are all loaded as\\n            boolean ``True`` and ``False`` values, and must be enclosed in\\n            quotes to be used as strings. More info on this (and other)\\n            ``PyYAML`` idiosyncrasies can be found :ref:`here\\n            <yaml-idiosyncrasies>`.\\n\\n            Use of ``OPTIONS`` on some platforms, for example:\\n            ``ask-passphrase``, will require ``gpg-agent`` or similar to cache\\n            passphrases.\\n\\n        .. note::\\n\\n            This parameter is not used for making ``yum`` repositories.\\n\\n    use_passphrase : False\\n        .. versionadded:: 2016.3.0\\n\\n        Use a passphrase with the signing key presented in ``keyid``.\\n        Passphrase is received from Pillar data which could be passed on the\\n        command line with ``pillar`` parameter. For example:\\n\\n        .. code-block:: bash\\n\\n            pillar=\\'{ \"gpg_passphrase\" : \"my_passphrase\" }\\'\\n\\n    gnupghome : /etc/salt/gpgkeys\\n        .. versionadded:: 2016.3.0\\n\\n        Location where GPG related files are stored, used with \\'keyid\\'\\n\\n    runas : builder\\n        .. versionadded:: 2016.3.0\\n\\n        User to create the repository as, and optionally sign packages.\\n\\n        .. note::\\n\\n            Ensure the user has correct permissions to any files and\\n            directories which are to be utilized.\\n\\n    timeout : 15.0\\n        .. versionadded:: 2016.3.4\\n\\n        Timeout in seconds to wait for the prompt for inputting the passphrase.\\n\\n    '\n    ret = {'name': name, 'changes': {}, 'comment': '', 'result': True}\n    if __opts__['test'] is True:\n        ret['result'] = None\n        ret['comment'] = 'Package repo metadata at {} will be refreshed'.format(name)\n        return ret\n    if env is not None and (not isinstance(env, dict)):\n        ret['comment'] = \"Invalidly-formatted 'env' parameter. See documentation.\"\n        return ret\n    func = 'pkgbuild.make_repo'\n    if __grains__.get('os_family', False) not in ('RedHat', 'Suse'):\n        for file in os.listdir(name):\n            if file.endswith('.rpm'):\n                func = 'rpmbuild.make_repo'\n                break\n    res = __salt__[func](name, keyid, env, use_passphrase, gnupghome, runas, timeout)\n    if res['retcode'] > 0:\n        ret['result'] = False\n    else:\n        ret['changes'] = {'refresh': True}\n    if res['stdout'] and res['stderr']:\n        ret['comment'] = '{}\\n{}'.format(res['stdout'], res['stderr'])\n    elif res['stdout']:\n        ret['comment'] = res['stdout']\n    elif res['stderr']:\n        ret['comment'] = res['stderr']\n    return ret"
        ]
    }
]