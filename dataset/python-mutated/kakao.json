[
    {
        "func_name": "_real_extract",
        "original": "def _real_extract(self, url):\n    video_id = self._match_id(url)\n    api_base = self._API_BASE_TMPL % video_id\n    cdn_api_base = self._CDN_API % video_id\n    query = {'player': 'monet_html5', 'referer': url, 'uuid': '', 'service': 'kakao_tv', 'section': '', 'dteType': 'PC', 'fields': ','.join(['-*', 'tid', 'clipLink', 'displayTitle', 'clip', 'title', 'description', 'channelId', 'createTime', 'duration', 'playCount', 'likeCount', 'commentCount', 'tagList', 'channel', 'name', 'clipChapterThumbnailList', 'thumbnailUrl', 'timeInSec', 'isDefault', 'videoOutputList', 'width', 'height', 'kbps', 'profile', 'label'])}\n    api_json = self._download_json(api_base, video_id, 'Downloading video info')\n    clip_link = api_json['clipLink']\n    clip = clip_link['clip']\n    title = clip.get('title') or clip_link.get('displayTitle')\n    formats = []\n    for fmt in clip.get('videoOutputList') or []:\n        profile_name = fmt.get('profile')\n        if not profile_name or profile_name == 'AUDIO':\n            continue\n        query.update({'profile': profile_name, 'fields': '-*,code,message,url'})\n        try:\n            fmt_url_json = self._download_json(cdn_api_base, video_id, query=query, note='Downloading video URL for profile %s' % profile_name)\n        except ExtractorError as e:\n            if isinstance(e.cause, HTTPError) and e.cause.status == 403:\n                resp = self._parse_json(e.cause.response.read().decode(), video_id)\n                if resp.get('code') == 'GeoBlocked':\n                    self.raise_geo_restricted()\n            raise\n        fmt_url = traverse_obj(fmt_url_json, ('videoLocation', 'url'))\n        if not fmt_url:\n            continue\n        formats.append({'url': fmt_url, 'format_id': profile_name, 'width': int_or_none(fmt.get('width')), 'height': int_or_none(fmt.get('height')), 'format_note': fmt.get('label'), 'filesize': int_or_none(fmt.get('filesize')), 'tbr': int_or_none(fmt.get('kbps'))})\n    thumbs = []\n    for thumb in clip.get('clipChapterThumbnailList') or []:\n        thumbs.append({'url': thumb.get('thumbnailUrl'), 'id': str(thumb.get('timeInSec')), 'preference': -1 if thumb.get('isDefault') else 0})\n    top_thumbnail = clip.get('thumbnailUrl')\n    if top_thumbnail:\n        thumbs.append({'url': top_thumbnail, 'preference': 10})\n    return {'id': video_id, 'title': title, 'description': strip_or_none(clip.get('description')), 'uploader': traverse_obj(clip_link, ('channel', 'name')), 'uploader_id': str_or_none(clip_link.get('channelId')), 'thumbnails': thumbs, 'timestamp': unified_timestamp(clip_link.get('createTime')), 'duration': int_or_none(clip.get('duration')), 'view_count': int_or_none(clip.get('playCount')), 'like_count': int_or_none(clip.get('likeCount')), 'comment_count': int_or_none(clip.get('commentCount')), 'formats': formats, 'tags': clip.get('tagList')}",
        "mutated": [
            "def _real_extract(self, url):\n    if False:\n        i = 10\n    video_id = self._match_id(url)\n    api_base = self._API_BASE_TMPL % video_id\n    cdn_api_base = self._CDN_API % video_id\n    query = {'player': 'monet_html5', 'referer': url, 'uuid': '', 'service': 'kakao_tv', 'section': '', 'dteType': 'PC', 'fields': ','.join(['-*', 'tid', 'clipLink', 'displayTitle', 'clip', 'title', 'description', 'channelId', 'createTime', 'duration', 'playCount', 'likeCount', 'commentCount', 'tagList', 'channel', 'name', 'clipChapterThumbnailList', 'thumbnailUrl', 'timeInSec', 'isDefault', 'videoOutputList', 'width', 'height', 'kbps', 'profile', 'label'])}\n    api_json = self._download_json(api_base, video_id, 'Downloading video info')\n    clip_link = api_json['clipLink']\n    clip = clip_link['clip']\n    title = clip.get('title') or clip_link.get('displayTitle')\n    formats = []\n    for fmt in clip.get('videoOutputList') or []:\n        profile_name = fmt.get('profile')\n        if not profile_name or profile_name == 'AUDIO':\n            continue\n        query.update({'profile': profile_name, 'fields': '-*,code,message,url'})\n        try:\n            fmt_url_json = self._download_json(cdn_api_base, video_id, query=query, note='Downloading video URL for profile %s' % profile_name)\n        except ExtractorError as e:\n            if isinstance(e.cause, HTTPError) and e.cause.status == 403:\n                resp = self._parse_json(e.cause.response.read().decode(), video_id)\n                if resp.get('code') == 'GeoBlocked':\n                    self.raise_geo_restricted()\n            raise\n        fmt_url = traverse_obj(fmt_url_json, ('videoLocation', 'url'))\n        if not fmt_url:\n            continue\n        formats.append({'url': fmt_url, 'format_id': profile_name, 'width': int_or_none(fmt.get('width')), 'height': int_or_none(fmt.get('height')), 'format_note': fmt.get('label'), 'filesize': int_or_none(fmt.get('filesize')), 'tbr': int_or_none(fmt.get('kbps'))})\n    thumbs = []\n    for thumb in clip.get('clipChapterThumbnailList') or []:\n        thumbs.append({'url': thumb.get('thumbnailUrl'), 'id': str(thumb.get('timeInSec')), 'preference': -1 if thumb.get('isDefault') else 0})\n    top_thumbnail = clip.get('thumbnailUrl')\n    if top_thumbnail:\n        thumbs.append({'url': top_thumbnail, 'preference': 10})\n    return {'id': video_id, 'title': title, 'description': strip_or_none(clip.get('description')), 'uploader': traverse_obj(clip_link, ('channel', 'name')), 'uploader_id': str_or_none(clip_link.get('channelId')), 'thumbnails': thumbs, 'timestamp': unified_timestamp(clip_link.get('createTime')), 'duration': int_or_none(clip.get('duration')), 'view_count': int_or_none(clip.get('playCount')), 'like_count': int_or_none(clip.get('likeCount')), 'comment_count': int_or_none(clip.get('commentCount')), 'formats': formats, 'tags': clip.get('tagList')}",
            "def _real_extract(self, url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    video_id = self._match_id(url)\n    api_base = self._API_BASE_TMPL % video_id\n    cdn_api_base = self._CDN_API % video_id\n    query = {'player': 'monet_html5', 'referer': url, 'uuid': '', 'service': 'kakao_tv', 'section': '', 'dteType': 'PC', 'fields': ','.join(['-*', 'tid', 'clipLink', 'displayTitle', 'clip', 'title', 'description', 'channelId', 'createTime', 'duration', 'playCount', 'likeCount', 'commentCount', 'tagList', 'channel', 'name', 'clipChapterThumbnailList', 'thumbnailUrl', 'timeInSec', 'isDefault', 'videoOutputList', 'width', 'height', 'kbps', 'profile', 'label'])}\n    api_json = self._download_json(api_base, video_id, 'Downloading video info')\n    clip_link = api_json['clipLink']\n    clip = clip_link['clip']\n    title = clip.get('title') or clip_link.get('displayTitle')\n    formats = []\n    for fmt in clip.get('videoOutputList') or []:\n        profile_name = fmt.get('profile')\n        if not profile_name or profile_name == 'AUDIO':\n            continue\n        query.update({'profile': profile_name, 'fields': '-*,code,message,url'})\n        try:\n            fmt_url_json = self._download_json(cdn_api_base, video_id, query=query, note='Downloading video URL for profile %s' % profile_name)\n        except ExtractorError as e:\n            if isinstance(e.cause, HTTPError) and e.cause.status == 403:\n                resp = self._parse_json(e.cause.response.read().decode(), video_id)\n                if resp.get('code') == 'GeoBlocked':\n                    self.raise_geo_restricted()\n            raise\n        fmt_url = traverse_obj(fmt_url_json, ('videoLocation', 'url'))\n        if not fmt_url:\n            continue\n        formats.append({'url': fmt_url, 'format_id': profile_name, 'width': int_or_none(fmt.get('width')), 'height': int_or_none(fmt.get('height')), 'format_note': fmt.get('label'), 'filesize': int_or_none(fmt.get('filesize')), 'tbr': int_or_none(fmt.get('kbps'))})\n    thumbs = []\n    for thumb in clip.get('clipChapterThumbnailList') or []:\n        thumbs.append({'url': thumb.get('thumbnailUrl'), 'id': str(thumb.get('timeInSec')), 'preference': -1 if thumb.get('isDefault') else 0})\n    top_thumbnail = clip.get('thumbnailUrl')\n    if top_thumbnail:\n        thumbs.append({'url': top_thumbnail, 'preference': 10})\n    return {'id': video_id, 'title': title, 'description': strip_or_none(clip.get('description')), 'uploader': traverse_obj(clip_link, ('channel', 'name')), 'uploader_id': str_or_none(clip_link.get('channelId')), 'thumbnails': thumbs, 'timestamp': unified_timestamp(clip_link.get('createTime')), 'duration': int_or_none(clip.get('duration')), 'view_count': int_or_none(clip.get('playCount')), 'like_count': int_or_none(clip.get('likeCount')), 'comment_count': int_or_none(clip.get('commentCount')), 'formats': formats, 'tags': clip.get('tagList')}",
            "def _real_extract(self, url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    video_id = self._match_id(url)\n    api_base = self._API_BASE_TMPL % video_id\n    cdn_api_base = self._CDN_API % video_id\n    query = {'player': 'monet_html5', 'referer': url, 'uuid': '', 'service': 'kakao_tv', 'section': '', 'dteType': 'PC', 'fields': ','.join(['-*', 'tid', 'clipLink', 'displayTitle', 'clip', 'title', 'description', 'channelId', 'createTime', 'duration', 'playCount', 'likeCount', 'commentCount', 'tagList', 'channel', 'name', 'clipChapterThumbnailList', 'thumbnailUrl', 'timeInSec', 'isDefault', 'videoOutputList', 'width', 'height', 'kbps', 'profile', 'label'])}\n    api_json = self._download_json(api_base, video_id, 'Downloading video info')\n    clip_link = api_json['clipLink']\n    clip = clip_link['clip']\n    title = clip.get('title') or clip_link.get('displayTitle')\n    formats = []\n    for fmt in clip.get('videoOutputList') or []:\n        profile_name = fmt.get('profile')\n        if not profile_name or profile_name == 'AUDIO':\n            continue\n        query.update({'profile': profile_name, 'fields': '-*,code,message,url'})\n        try:\n            fmt_url_json = self._download_json(cdn_api_base, video_id, query=query, note='Downloading video URL for profile %s' % profile_name)\n        except ExtractorError as e:\n            if isinstance(e.cause, HTTPError) and e.cause.status == 403:\n                resp = self._parse_json(e.cause.response.read().decode(), video_id)\n                if resp.get('code') == 'GeoBlocked':\n                    self.raise_geo_restricted()\n            raise\n        fmt_url = traverse_obj(fmt_url_json, ('videoLocation', 'url'))\n        if not fmt_url:\n            continue\n        formats.append({'url': fmt_url, 'format_id': profile_name, 'width': int_or_none(fmt.get('width')), 'height': int_or_none(fmt.get('height')), 'format_note': fmt.get('label'), 'filesize': int_or_none(fmt.get('filesize')), 'tbr': int_or_none(fmt.get('kbps'))})\n    thumbs = []\n    for thumb in clip.get('clipChapterThumbnailList') or []:\n        thumbs.append({'url': thumb.get('thumbnailUrl'), 'id': str(thumb.get('timeInSec')), 'preference': -1 if thumb.get('isDefault') else 0})\n    top_thumbnail = clip.get('thumbnailUrl')\n    if top_thumbnail:\n        thumbs.append({'url': top_thumbnail, 'preference': 10})\n    return {'id': video_id, 'title': title, 'description': strip_or_none(clip.get('description')), 'uploader': traverse_obj(clip_link, ('channel', 'name')), 'uploader_id': str_or_none(clip_link.get('channelId')), 'thumbnails': thumbs, 'timestamp': unified_timestamp(clip_link.get('createTime')), 'duration': int_or_none(clip.get('duration')), 'view_count': int_or_none(clip.get('playCount')), 'like_count': int_or_none(clip.get('likeCount')), 'comment_count': int_or_none(clip.get('commentCount')), 'formats': formats, 'tags': clip.get('tagList')}",
            "def _real_extract(self, url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    video_id = self._match_id(url)\n    api_base = self._API_BASE_TMPL % video_id\n    cdn_api_base = self._CDN_API % video_id\n    query = {'player': 'monet_html5', 'referer': url, 'uuid': '', 'service': 'kakao_tv', 'section': '', 'dteType': 'PC', 'fields': ','.join(['-*', 'tid', 'clipLink', 'displayTitle', 'clip', 'title', 'description', 'channelId', 'createTime', 'duration', 'playCount', 'likeCount', 'commentCount', 'tagList', 'channel', 'name', 'clipChapterThumbnailList', 'thumbnailUrl', 'timeInSec', 'isDefault', 'videoOutputList', 'width', 'height', 'kbps', 'profile', 'label'])}\n    api_json = self._download_json(api_base, video_id, 'Downloading video info')\n    clip_link = api_json['clipLink']\n    clip = clip_link['clip']\n    title = clip.get('title') or clip_link.get('displayTitle')\n    formats = []\n    for fmt in clip.get('videoOutputList') or []:\n        profile_name = fmt.get('profile')\n        if not profile_name or profile_name == 'AUDIO':\n            continue\n        query.update({'profile': profile_name, 'fields': '-*,code,message,url'})\n        try:\n            fmt_url_json = self._download_json(cdn_api_base, video_id, query=query, note='Downloading video URL for profile %s' % profile_name)\n        except ExtractorError as e:\n            if isinstance(e.cause, HTTPError) and e.cause.status == 403:\n                resp = self._parse_json(e.cause.response.read().decode(), video_id)\n                if resp.get('code') == 'GeoBlocked':\n                    self.raise_geo_restricted()\n            raise\n        fmt_url = traverse_obj(fmt_url_json, ('videoLocation', 'url'))\n        if not fmt_url:\n            continue\n        formats.append({'url': fmt_url, 'format_id': profile_name, 'width': int_or_none(fmt.get('width')), 'height': int_or_none(fmt.get('height')), 'format_note': fmt.get('label'), 'filesize': int_or_none(fmt.get('filesize')), 'tbr': int_or_none(fmt.get('kbps'))})\n    thumbs = []\n    for thumb in clip.get('clipChapterThumbnailList') or []:\n        thumbs.append({'url': thumb.get('thumbnailUrl'), 'id': str(thumb.get('timeInSec')), 'preference': -1 if thumb.get('isDefault') else 0})\n    top_thumbnail = clip.get('thumbnailUrl')\n    if top_thumbnail:\n        thumbs.append({'url': top_thumbnail, 'preference': 10})\n    return {'id': video_id, 'title': title, 'description': strip_or_none(clip.get('description')), 'uploader': traverse_obj(clip_link, ('channel', 'name')), 'uploader_id': str_or_none(clip_link.get('channelId')), 'thumbnails': thumbs, 'timestamp': unified_timestamp(clip_link.get('createTime')), 'duration': int_or_none(clip.get('duration')), 'view_count': int_or_none(clip.get('playCount')), 'like_count': int_or_none(clip.get('likeCount')), 'comment_count': int_or_none(clip.get('commentCount')), 'formats': formats, 'tags': clip.get('tagList')}",
            "def _real_extract(self, url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    video_id = self._match_id(url)\n    api_base = self._API_BASE_TMPL % video_id\n    cdn_api_base = self._CDN_API % video_id\n    query = {'player': 'monet_html5', 'referer': url, 'uuid': '', 'service': 'kakao_tv', 'section': '', 'dteType': 'PC', 'fields': ','.join(['-*', 'tid', 'clipLink', 'displayTitle', 'clip', 'title', 'description', 'channelId', 'createTime', 'duration', 'playCount', 'likeCount', 'commentCount', 'tagList', 'channel', 'name', 'clipChapterThumbnailList', 'thumbnailUrl', 'timeInSec', 'isDefault', 'videoOutputList', 'width', 'height', 'kbps', 'profile', 'label'])}\n    api_json = self._download_json(api_base, video_id, 'Downloading video info')\n    clip_link = api_json['clipLink']\n    clip = clip_link['clip']\n    title = clip.get('title') or clip_link.get('displayTitle')\n    formats = []\n    for fmt in clip.get('videoOutputList') or []:\n        profile_name = fmt.get('profile')\n        if not profile_name or profile_name == 'AUDIO':\n            continue\n        query.update({'profile': profile_name, 'fields': '-*,code,message,url'})\n        try:\n            fmt_url_json = self._download_json(cdn_api_base, video_id, query=query, note='Downloading video URL for profile %s' % profile_name)\n        except ExtractorError as e:\n            if isinstance(e.cause, HTTPError) and e.cause.status == 403:\n                resp = self._parse_json(e.cause.response.read().decode(), video_id)\n                if resp.get('code') == 'GeoBlocked':\n                    self.raise_geo_restricted()\n            raise\n        fmt_url = traverse_obj(fmt_url_json, ('videoLocation', 'url'))\n        if not fmt_url:\n            continue\n        formats.append({'url': fmt_url, 'format_id': profile_name, 'width': int_or_none(fmt.get('width')), 'height': int_or_none(fmt.get('height')), 'format_note': fmt.get('label'), 'filesize': int_or_none(fmt.get('filesize')), 'tbr': int_or_none(fmt.get('kbps'))})\n    thumbs = []\n    for thumb in clip.get('clipChapterThumbnailList') or []:\n        thumbs.append({'url': thumb.get('thumbnailUrl'), 'id': str(thumb.get('timeInSec')), 'preference': -1 if thumb.get('isDefault') else 0})\n    top_thumbnail = clip.get('thumbnailUrl')\n    if top_thumbnail:\n        thumbs.append({'url': top_thumbnail, 'preference': 10})\n    return {'id': video_id, 'title': title, 'description': strip_or_none(clip.get('description')), 'uploader': traverse_obj(clip_link, ('channel', 'name')), 'uploader_id': str_or_none(clip_link.get('channelId')), 'thumbnails': thumbs, 'timestamp': unified_timestamp(clip_link.get('createTime')), 'duration': int_or_none(clip.get('duration')), 'view_count': int_or_none(clip.get('playCount')), 'like_count': int_or_none(clip.get('likeCount')), 'comment_count': int_or_none(clip.get('commentCount')), 'formats': formats, 'tags': clip.get('tagList')}"
        ]
    }
]