from paddle import _legacy_C_ops, in_dynamic_mode
from paddle.base.layer_helper import LayerHelper

def sparse_attention(query, key, value, sparse_csr_offset, sparse_csr_columns, key_padding_mask=None, attn_mask=None, name=None):
    if False:
        print('Hello World!')
    '\n    This operator sparsify the Attention matrix in Transformer module\n    to achieve the effect of reducing memory consumption and computation.\n    The sparse layout is expressed in CSR format and contains two parameters,\n    ``offset`` and ``columns``. The equation is:\n\n    .. math::\n\n        result=softmax(\\frac{ Q * K^T }{\\sqrt{d}}) * V\n\n    where : ``Q``, ``K``, and ``V`` represent the three input parameters of the attention module.\n    The dimensions of the three parameters are the same.\n    ``d`` represents the size of the last dimension of the three parameters.\n\n    Warning:\n        This API is only used in ``CUDA 11.3`` and above versions.\n\n    Args:\n        query(Tensor): The query tensor in the Attention module.\n                        4-D tensor with shape:\n                        [batch_size, num_heads, seq_len, head_dim].\n                        The dtype can be float32 and float64.\n        key(Tensor): The key tensor in the Attention module.\n                        4-D tensor with shape:\n                        [batch_size, num_heads, seq_len, head_dim].\n                        The dtype can be float32 and float64.\n        value(Tensor): The value tensor in the Attention module.\n                        4-D tensor with shape:\n                        [batch_size, num_heads, seq_len, head_dim].\n                        The dtype can be float32 and float64.\n        sparse_csr_offset(Tensor): The sparsity feature in the Attention module\n                        is expressed in the CSR format, and the offset represents\n                        the number of non-zero elements in each row of the matrix.\n                        3-D tensor with shape:\n                        [batch_size, num_heads, seq_len + 1].\n                        The dtype should be int32.\n        sparse_csr_columns(Tensor): The sparsity feature in the Attention module\n                        is expressed in the CSR format, and the columns represent\n                        the column index values of non-zero elements in the matrix.\n                        3-D tensor with shape:\n                        [batch_size, num_heads, sparse_nnz].\n                        The dtype should be int32.\n        key_padding_mask(Tensor, optional):The key padding mask tensor in the Attention module.\n                        2-D tensor with shape: [batch_size, seq_len].\n                        The dtype can be float32 and float64.\n                        A value of 0 means that the position is masked.\n        attn_mask(Tensor, optional):The attention mask tensor in the Attention module.\n                        2-D tensor with shape: [seq_len, seq_len].\n                        The dtype can be float32 and float64.\n                        A value of 0 means that the position is masked.\n        name(str, optional): The default value is None. Normally there is no need for user\n                        to set this property. For more information, please refer to\n                        :ref:`api_guide_Name`.\n\n    Returns:\n        4-D tensor with shape:\n        [batch_size, num_heads, seq_len, head_dim].\n        The dtype can be float32 or float64.\n\n    Examples:\n        .. code-block:: python\n\n            >>> # doctest: +SKIP(\'This API is only used in CUDA11.3 and above.\')\n            >>> import paddle\n\n            >>> paddle.disable_static()\n\n            >>> # `query`, `key` and `value` all have shape [1, 1, 4, 2]\n            >>> query = paddle.to_tensor([[[[0, 1, ], [2, 3],\n            ...                             [0, 1], [2, 3]]]], dtype="float32")\n            >>> key = paddle.to_tensor([[[[0, 1], [2, 3],\n            ...                           [0, 1], [2, 3]]]], dtype="float32")\n            >>> value = paddle.to_tensor([[[[0, 1], [2, 3],\n            ...                             [0, 1], [2, 3]]]], dtype="float32")\n            ...\n            >>> offset = paddle.to_tensor([[[0, 2, 4, 6, 8]]], dtype="int32")\n            >>> columns = paddle.to_tensor([[[0, 1, 0, 1, 2, 3, 2, 3]]], dtype="int32")\n            ...\n            >>> print(offset.shape)\n            [1, 1, 5]\n            >>> print(columns.shape)\n            [1, 1, 8]\n            ...\n            >>> key_padding_mask = paddle.to_tensor([[1, 1, 1, 0]], dtype="float32")\n            >>> attention_mask = paddle.to_tensor([[1, 0, 1, 1],\n            ...                                    [1, 1, 1, 1],\n            ...                                    [1, 1, 1, 1],\n            ...                                    [1, 1, 1, 1]], dtype="float32")\n            >>> output_mask = paddle.nn.functional.sparse_attention(query, key,\n            ...                                                     value, offset, columns,\n            ...                                                     key_padding_mask=key_padding_mask,\n            ...                                                     attn_mask=attention_mask)\n            >>> print(output_mask)\n            Tensor(shape=[1, 1, 4, 2], dtype=float32, place=Place(cpu), stop_gradient=False,\n            [[[[0.        , 1.        ],\n               [1.99830270, 2.99830270],\n               [0.        , 1.        ],\n               [0.        , 1.        ]]]])\n\n            >>> output = paddle.nn.functional.sparse_attention(query, key,\n            ...                                             value, offset, columns)\n            >>> print(output)\n            Tensor(shape=[1, 1, 4, 2], dtype=float32, place=Place(cpu), stop_gradient=False,\n            [[[[1.60885942, 2.60885954],\n               [1.99830270, 2.99830270],\n               [1.60885942, 2.60885954],\n               [1.99830270, 2.99830270]]]])\n    '
    if in_dynamic_mode():
        (result_attention, result_sdd, result_softmax) = _legacy_C_ops.sparse_attention(query, key, value, sparse_csr_offset, sparse_csr_columns, key_padding_mask, attn_mask)
        return result_attention
    helper = LayerHelper('sparse_attention', **locals())
    dtype = helper.input_dtype(input_param_name='Q')
    out = helper.create_variable_for_type_inference(dtype)
    result_sdd = helper.create_variable_for_type_inference(dtype)
    result_softmax = helper.create_variable_for_type_inference(dtype)
    inputs = {'Q': query, 'K': key, 'V': value, 'Offset': sparse_csr_offset, 'Columns': sparse_csr_columns, 'KeyPaddingMask': key_padding_mask, 'AttnMask': attn_mask}
    outputs = {'Out': out, 'SparseDotSdd': result_sdd, 'Softmax': result_softmax}
    helper.append_op(type='sparse_attention', inputs=inputs, outputs=outputs)
    return out