[
    {
        "func_name": "dot",
        "original": "def dot(p1, p2):\n    return p1[0] * p2[0] + p1[1] * p2[1]",
        "mutated": [
            "def dot(p1, p2):\n    if False:\n        i = 10\n    return p1[0] * p2[0] + p1[1] * p2[1]",
            "def dot(p1, p2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return p1[0] * p2[0] + p1[1] * p2[1]",
            "def dot(p1, p2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return p1[0] * p2[0] + p1[1] * p2[1]",
            "def dot(p1, p2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return p1[0] * p2[0] + p1[1] * p2[1]",
            "def dot(p1, p2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return p1[0] * p2[0] + p1[1] * p2[1]"
        ]
    },
    {
        "func_name": "heuristic_estimate",
        "original": "def heuristic_estimate(board, R, C, expected):\n    result = 0\n    for i in xrange(R):\n        for j in xrange(C):\n            val = board[C * i + j]\n            if val == 0:\n                continue\n            (r, c) = expected[val]\n            result += abs(r - i) + abs(c - j)\n    return result",
        "mutated": [
            "def heuristic_estimate(board, R, C, expected):\n    if False:\n        i = 10\n    result = 0\n    for i in xrange(R):\n        for j in xrange(C):\n            val = board[C * i + j]\n            if val == 0:\n                continue\n            (r, c) = expected[val]\n            result += abs(r - i) + abs(c - j)\n    return result",
            "def heuristic_estimate(board, R, C, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    result = 0\n    for i in xrange(R):\n        for j in xrange(C):\n            val = board[C * i + j]\n            if val == 0:\n                continue\n            (r, c) = expected[val]\n            result += abs(r - i) + abs(c - j)\n    return result",
            "def heuristic_estimate(board, R, C, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    result = 0\n    for i in xrange(R):\n        for j in xrange(C):\n            val = board[C * i + j]\n            if val == 0:\n                continue\n            (r, c) = expected[val]\n            result += abs(r - i) + abs(c - j)\n    return result",
            "def heuristic_estimate(board, R, C, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    result = 0\n    for i in xrange(R):\n        for j in xrange(C):\n            val = board[C * i + j]\n            if val == 0:\n                continue\n            (r, c) = expected[val]\n            result += abs(r - i) + abs(c - j)\n    return result",
            "def heuristic_estimate(board, R, C, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    result = 0\n    for i in xrange(R):\n        for j in xrange(C):\n            val = board[C * i + j]\n            if val == 0:\n                continue\n            (r, c) = expected[val]\n            result += abs(r - i) + abs(c - j)\n    return result"
        ]
    },
    {
        "func_name": "slidingPuzzle",
        "original": "def slidingPuzzle(self, board):\n    \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n\n    def dot(p1, p2):\n        return p1[0] * p2[0] + p1[1] * p2[1]\n\n    def heuristic_estimate(board, R, C, expected):\n        result = 0\n        for i in xrange(R):\n            for j in xrange(C):\n                val = board[C * i + j]\n                if val == 0:\n                    continue\n                (r, c) = expected[val]\n                result += abs(r - i) + abs(c - j)\n        return result\n    (R, C) = (len(board), len(board[0]))\n    begin = tuple(itertools.chain(*board))\n    end = tuple(range(1, R * C) + [0])\n    expected = {(C * i + j + 1) % (R * C): (i, j) for i in xrange(R) for j in xrange(C)}\n    min_steps = heuristic_estimate(begin, R, C, expected)\n    (closer, detour) = ([(begin.index(0), begin)], [])\n    lookup = set()\n    while True:\n        if not closer:\n            if not detour:\n                return -1\n            min_steps += 2\n            (closer, detour) = (detour, closer)\n        (zero, board) = closer.pop()\n        if board == end:\n            return min_steps\n        if board not in lookup:\n            lookup.add(board)\n            (r, c) = divmod(zero, C)\n            for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                (i, j) = (r + direction[0], c + direction[1])\n                if 0 <= i < R and 0 <= j < C:\n                    new_zero = i * C + j\n                    tmp = list(board)\n                    (tmp[zero], tmp[new_zero]) = (tmp[new_zero], tmp[zero])\n                    new_board = tuple(tmp)\n                    (r2, c2) = expected[board[new_zero]]\n                    (r1, c1) = divmod(zero, C)\n                    (r0, c0) = divmod(new_zero, C)\n                    is_closer = dot((r1 - r0, c1 - c0), (r2 - r0, c2 - c0)) > 0\n                    (closer if is_closer else detour).append((new_zero, new_board))\n    return min_steps",
        "mutated": [
            "def slidingPuzzle(self, board):\n    if False:\n        i = 10\n    '\\n        :type board: List[List[int]]\\n        :rtype: int\\n        '\n\n    def dot(p1, p2):\n        return p1[0] * p2[0] + p1[1] * p2[1]\n\n    def heuristic_estimate(board, R, C, expected):\n        result = 0\n        for i in xrange(R):\n            for j in xrange(C):\n                val = board[C * i + j]\n                if val == 0:\n                    continue\n                (r, c) = expected[val]\n                result += abs(r - i) + abs(c - j)\n        return result\n    (R, C) = (len(board), len(board[0]))\n    begin = tuple(itertools.chain(*board))\n    end = tuple(range(1, R * C) + [0])\n    expected = {(C * i + j + 1) % (R * C): (i, j) for i in xrange(R) for j in xrange(C)}\n    min_steps = heuristic_estimate(begin, R, C, expected)\n    (closer, detour) = ([(begin.index(0), begin)], [])\n    lookup = set()\n    while True:\n        if not closer:\n            if not detour:\n                return -1\n            min_steps += 2\n            (closer, detour) = (detour, closer)\n        (zero, board) = closer.pop()\n        if board == end:\n            return min_steps\n        if board not in lookup:\n            lookup.add(board)\n            (r, c) = divmod(zero, C)\n            for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                (i, j) = (r + direction[0], c + direction[1])\n                if 0 <= i < R and 0 <= j < C:\n                    new_zero = i * C + j\n                    tmp = list(board)\n                    (tmp[zero], tmp[new_zero]) = (tmp[new_zero], tmp[zero])\n                    new_board = tuple(tmp)\n                    (r2, c2) = expected[board[new_zero]]\n                    (r1, c1) = divmod(zero, C)\n                    (r0, c0) = divmod(new_zero, C)\n                    is_closer = dot((r1 - r0, c1 - c0), (r2 - r0, c2 - c0)) > 0\n                    (closer if is_closer else detour).append((new_zero, new_board))\n    return min_steps",
            "def slidingPuzzle(self, board):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type board: List[List[int]]\\n        :rtype: int\\n        '\n\n    def dot(p1, p2):\n        return p1[0] * p2[0] + p1[1] * p2[1]\n\n    def heuristic_estimate(board, R, C, expected):\n        result = 0\n        for i in xrange(R):\n            for j in xrange(C):\n                val = board[C * i + j]\n                if val == 0:\n                    continue\n                (r, c) = expected[val]\n                result += abs(r - i) + abs(c - j)\n        return result\n    (R, C) = (len(board), len(board[0]))\n    begin = tuple(itertools.chain(*board))\n    end = tuple(range(1, R * C) + [0])\n    expected = {(C * i + j + 1) % (R * C): (i, j) for i in xrange(R) for j in xrange(C)}\n    min_steps = heuristic_estimate(begin, R, C, expected)\n    (closer, detour) = ([(begin.index(0), begin)], [])\n    lookup = set()\n    while True:\n        if not closer:\n            if not detour:\n                return -1\n            min_steps += 2\n            (closer, detour) = (detour, closer)\n        (zero, board) = closer.pop()\n        if board == end:\n            return min_steps\n        if board not in lookup:\n            lookup.add(board)\n            (r, c) = divmod(zero, C)\n            for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                (i, j) = (r + direction[0], c + direction[1])\n                if 0 <= i < R and 0 <= j < C:\n                    new_zero = i * C + j\n                    tmp = list(board)\n                    (tmp[zero], tmp[new_zero]) = (tmp[new_zero], tmp[zero])\n                    new_board = tuple(tmp)\n                    (r2, c2) = expected[board[new_zero]]\n                    (r1, c1) = divmod(zero, C)\n                    (r0, c0) = divmod(new_zero, C)\n                    is_closer = dot((r1 - r0, c1 - c0), (r2 - r0, c2 - c0)) > 0\n                    (closer if is_closer else detour).append((new_zero, new_board))\n    return min_steps",
            "def slidingPuzzle(self, board):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type board: List[List[int]]\\n        :rtype: int\\n        '\n\n    def dot(p1, p2):\n        return p1[0] * p2[0] + p1[1] * p2[1]\n\n    def heuristic_estimate(board, R, C, expected):\n        result = 0\n        for i in xrange(R):\n            for j in xrange(C):\n                val = board[C * i + j]\n                if val == 0:\n                    continue\n                (r, c) = expected[val]\n                result += abs(r - i) + abs(c - j)\n        return result\n    (R, C) = (len(board), len(board[0]))\n    begin = tuple(itertools.chain(*board))\n    end = tuple(range(1, R * C) + [0])\n    expected = {(C * i + j + 1) % (R * C): (i, j) for i in xrange(R) for j in xrange(C)}\n    min_steps = heuristic_estimate(begin, R, C, expected)\n    (closer, detour) = ([(begin.index(0), begin)], [])\n    lookup = set()\n    while True:\n        if not closer:\n            if not detour:\n                return -1\n            min_steps += 2\n            (closer, detour) = (detour, closer)\n        (zero, board) = closer.pop()\n        if board == end:\n            return min_steps\n        if board not in lookup:\n            lookup.add(board)\n            (r, c) = divmod(zero, C)\n            for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                (i, j) = (r + direction[0], c + direction[1])\n                if 0 <= i < R and 0 <= j < C:\n                    new_zero = i * C + j\n                    tmp = list(board)\n                    (tmp[zero], tmp[new_zero]) = (tmp[new_zero], tmp[zero])\n                    new_board = tuple(tmp)\n                    (r2, c2) = expected[board[new_zero]]\n                    (r1, c1) = divmod(zero, C)\n                    (r0, c0) = divmod(new_zero, C)\n                    is_closer = dot((r1 - r0, c1 - c0), (r2 - r0, c2 - c0)) > 0\n                    (closer if is_closer else detour).append((new_zero, new_board))\n    return min_steps",
            "def slidingPuzzle(self, board):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type board: List[List[int]]\\n        :rtype: int\\n        '\n\n    def dot(p1, p2):\n        return p1[0] * p2[0] + p1[1] * p2[1]\n\n    def heuristic_estimate(board, R, C, expected):\n        result = 0\n        for i in xrange(R):\n            for j in xrange(C):\n                val = board[C * i + j]\n                if val == 0:\n                    continue\n                (r, c) = expected[val]\n                result += abs(r - i) + abs(c - j)\n        return result\n    (R, C) = (len(board), len(board[0]))\n    begin = tuple(itertools.chain(*board))\n    end = tuple(range(1, R * C) + [0])\n    expected = {(C * i + j + 1) % (R * C): (i, j) for i in xrange(R) for j in xrange(C)}\n    min_steps = heuristic_estimate(begin, R, C, expected)\n    (closer, detour) = ([(begin.index(0), begin)], [])\n    lookup = set()\n    while True:\n        if not closer:\n            if not detour:\n                return -1\n            min_steps += 2\n            (closer, detour) = (detour, closer)\n        (zero, board) = closer.pop()\n        if board == end:\n            return min_steps\n        if board not in lookup:\n            lookup.add(board)\n            (r, c) = divmod(zero, C)\n            for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                (i, j) = (r + direction[0], c + direction[1])\n                if 0 <= i < R and 0 <= j < C:\n                    new_zero = i * C + j\n                    tmp = list(board)\n                    (tmp[zero], tmp[new_zero]) = (tmp[new_zero], tmp[zero])\n                    new_board = tuple(tmp)\n                    (r2, c2) = expected[board[new_zero]]\n                    (r1, c1) = divmod(zero, C)\n                    (r0, c0) = divmod(new_zero, C)\n                    is_closer = dot((r1 - r0, c1 - c0), (r2 - r0, c2 - c0)) > 0\n                    (closer if is_closer else detour).append((new_zero, new_board))\n    return min_steps",
            "def slidingPuzzle(self, board):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type board: List[List[int]]\\n        :rtype: int\\n        '\n\n    def dot(p1, p2):\n        return p1[0] * p2[0] + p1[1] * p2[1]\n\n    def heuristic_estimate(board, R, C, expected):\n        result = 0\n        for i in xrange(R):\n            for j in xrange(C):\n                val = board[C * i + j]\n                if val == 0:\n                    continue\n                (r, c) = expected[val]\n                result += abs(r - i) + abs(c - j)\n        return result\n    (R, C) = (len(board), len(board[0]))\n    begin = tuple(itertools.chain(*board))\n    end = tuple(range(1, R * C) + [0])\n    expected = {(C * i + j + 1) % (R * C): (i, j) for i in xrange(R) for j in xrange(C)}\n    min_steps = heuristic_estimate(begin, R, C, expected)\n    (closer, detour) = ([(begin.index(0), begin)], [])\n    lookup = set()\n    while True:\n        if not closer:\n            if not detour:\n                return -1\n            min_steps += 2\n            (closer, detour) = (detour, closer)\n        (zero, board) = closer.pop()\n        if board == end:\n            return min_steps\n        if board not in lookup:\n            lookup.add(board)\n            (r, c) = divmod(zero, C)\n            for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                (i, j) = (r + direction[0], c + direction[1])\n                if 0 <= i < R and 0 <= j < C:\n                    new_zero = i * C + j\n                    tmp = list(board)\n                    (tmp[zero], tmp[new_zero]) = (tmp[new_zero], tmp[zero])\n                    new_board = tuple(tmp)\n                    (r2, c2) = expected[board[new_zero]]\n                    (r1, c1) = divmod(zero, C)\n                    (r0, c0) = divmod(new_zero, C)\n                    is_closer = dot((r1 - r0, c1 - c0), (r2 - r0, c2 - c0)) > 0\n                    (closer if is_closer else detour).append((new_zero, new_board))\n    return min_steps"
        ]
    },
    {
        "func_name": "heuristic_estimate",
        "original": "def heuristic_estimate(board, R, C, expected):\n    result = 0\n    for i in xrange(R):\n        for j in xrange(C):\n            val = board[C * i + j]\n            if val == 0:\n                continue\n            (r, c) = expected[val]\n            result += abs(r - i) + abs(c - j)\n    return result",
        "mutated": [
            "def heuristic_estimate(board, R, C, expected):\n    if False:\n        i = 10\n    result = 0\n    for i in xrange(R):\n        for j in xrange(C):\n            val = board[C * i + j]\n            if val == 0:\n                continue\n            (r, c) = expected[val]\n            result += abs(r - i) + abs(c - j)\n    return result",
            "def heuristic_estimate(board, R, C, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    result = 0\n    for i in xrange(R):\n        for j in xrange(C):\n            val = board[C * i + j]\n            if val == 0:\n                continue\n            (r, c) = expected[val]\n            result += abs(r - i) + abs(c - j)\n    return result",
            "def heuristic_estimate(board, R, C, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    result = 0\n    for i in xrange(R):\n        for j in xrange(C):\n            val = board[C * i + j]\n            if val == 0:\n                continue\n            (r, c) = expected[val]\n            result += abs(r - i) + abs(c - j)\n    return result",
            "def heuristic_estimate(board, R, C, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    result = 0\n    for i in xrange(R):\n        for j in xrange(C):\n            val = board[C * i + j]\n            if val == 0:\n                continue\n            (r, c) = expected[val]\n            result += abs(r - i) + abs(c - j)\n    return result",
            "def heuristic_estimate(board, R, C, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    result = 0\n    for i in xrange(R):\n        for j in xrange(C):\n            val = board[C * i + j]\n            if val == 0:\n                continue\n            (r, c) = expected[val]\n            result += abs(r - i) + abs(c - j)\n    return result"
        ]
    },
    {
        "func_name": "slidingPuzzle",
        "original": "def slidingPuzzle(self, board):\n    \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n\n    def heuristic_estimate(board, R, C, expected):\n        result = 0\n        for i in xrange(R):\n            for j in xrange(C):\n                val = board[C * i + j]\n                if val == 0:\n                    continue\n                (r, c) = expected[val]\n                result += abs(r - i) + abs(c - j)\n        return result\n    (R, C) = (len(board), len(board[0]))\n    begin = tuple(itertools.chain(*board))\n    end = tuple(range(1, R * C) + [0])\n    end_wrong = tuple(range(1, R * C - 2) + [R * C - 1, R * C - 2, 0])\n    expected = {(C * i + j + 1) % (R * C): (i, j) for i in xrange(R) for j in xrange(C)}\n    min_heap = [(0, 0, begin.index(0), begin)]\n    lookup = {begin: 0}\n    while min_heap:\n        (f, g, zero, board) = heapq.heappop(min_heap)\n        if board == end:\n            return g\n        if board == end_wrong:\n            return -1\n        if f > lookup[board]:\n            continue\n        (r, c) = divmod(zero, C)\n        for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n            (i, j) = (r + direction[0], c + direction[1])\n            if 0 <= i < R and 0 <= j < C:\n                new_zero = C * i + j\n                tmp = list(board)\n                (tmp[zero], tmp[new_zero]) = (tmp[new_zero], tmp[zero])\n                new_board = tuple(tmp)\n                f = g + 1 + heuristic_estimate(new_board, R, C, expected)\n                if f < lookup.get(new_board, float('inf')):\n                    lookup[new_board] = f\n                    heapq.heappush(min_heap, (f, g + 1, new_zero, new_board))\n    return -1",
        "mutated": [
            "def slidingPuzzle(self, board):\n    if False:\n        i = 10\n    '\\n        :type board: List[List[int]]\\n        :rtype: int\\n        '\n\n    def heuristic_estimate(board, R, C, expected):\n        result = 0\n        for i in xrange(R):\n            for j in xrange(C):\n                val = board[C * i + j]\n                if val == 0:\n                    continue\n                (r, c) = expected[val]\n                result += abs(r - i) + abs(c - j)\n        return result\n    (R, C) = (len(board), len(board[0]))\n    begin = tuple(itertools.chain(*board))\n    end = tuple(range(1, R * C) + [0])\n    end_wrong = tuple(range(1, R * C - 2) + [R * C - 1, R * C - 2, 0])\n    expected = {(C * i + j + 1) % (R * C): (i, j) for i in xrange(R) for j in xrange(C)}\n    min_heap = [(0, 0, begin.index(0), begin)]\n    lookup = {begin: 0}\n    while min_heap:\n        (f, g, zero, board) = heapq.heappop(min_heap)\n        if board == end:\n            return g\n        if board == end_wrong:\n            return -1\n        if f > lookup[board]:\n            continue\n        (r, c) = divmod(zero, C)\n        for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n            (i, j) = (r + direction[0], c + direction[1])\n            if 0 <= i < R and 0 <= j < C:\n                new_zero = C * i + j\n                tmp = list(board)\n                (tmp[zero], tmp[new_zero]) = (tmp[new_zero], tmp[zero])\n                new_board = tuple(tmp)\n                f = g + 1 + heuristic_estimate(new_board, R, C, expected)\n                if f < lookup.get(new_board, float('inf')):\n                    lookup[new_board] = f\n                    heapq.heappush(min_heap, (f, g + 1, new_zero, new_board))\n    return -1",
            "def slidingPuzzle(self, board):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type board: List[List[int]]\\n        :rtype: int\\n        '\n\n    def heuristic_estimate(board, R, C, expected):\n        result = 0\n        for i in xrange(R):\n            for j in xrange(C):\n                val = board[C * i + j]\n                if val == 0:\n                    continue\n                (r, c) = expected[val]\n                result += abs(r - i) + abs(c - j)\n        return result\n    (R, C) = (len(board), len(board[0]))\n    begin = tuple(itertools.chain(*board))\n    end = tuple(range(1, R * C) + [0])\n    end_wrong = tuple(range(1, R * C - 2) + [R * C - 1, R * C - 2, 0])\n    expected = {(C * i + j + 1) % (R * C): (i, j) for i in xrange(R) for j in xrange(C)}\n    min_heap = [(0, 0, begin.index(0), begin)]\n    lookup = {begin: 0}\n    while min_heap:\n        (f, g, zero, board) = heapq.heappop(min_heap)\n        if board == end:\n            return g\n        if board == end_wrong:\n            return -1\n        if f > lookup[board]:\n            continue\n        (r, c) = divmod(zero, C)\n        for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n            (i, j) = (r + direction[0], c + direction[1])\n            if 0 <= i < R and 0 <= j < C:\n                new_zero = C * i + j\n                tmp = list(board)\n                (tmp[zero], tmp[new_zero]) = (tmp[new_zero], tmp[zero])\n                new_board = tuple(tmp)\n                f = g + 1 + heuristic_estimate(new_board, R, C, expected)\n                if f < lookup.get(new_board, float('inf')):\n                    lookup[new_board] = f\n                    heapq.heappush(min_heap, (f, g + 1, new_zero, new_board))\n    return -1",
            "def slidingPuzzle(self, board):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type board: List[List[int]]\\n        :rtype: int\\n        '\n\n    def heuristic_estimate(board, R, C, expected):\n        result = 0\n        for i in xrange(R):\n            for j in xrange(C):\n                val = board[C * i + j]\n                if val == 0:\n                    continue\n                (r, c) = expected[val]\n                result += abs(r - i) + abs(c - j)\n        return result\n    (R, C) = (len(board), len(board[0]))\n    begin = tuple(itertools.chain(*board))\n    end = tuple(range(1, R * C) + [0])\n    end_wrong = tuple(range(1, R * C - 2) + [R * C - 1, R * C - 2, 0])\n    expected = {(C * i + j + 1) % (R * C): (i, j) for i in xrange(R) for j in xrange(C)}\n    min_heap = [(0, 0, begin.index(0), begin)]\n    lookup = {begin: 0}\n    while min_heap:\n        (f, g, zero, board) = heapq.heappop(min_heap)\n        if board == end:\n            return g\n        if board == end_wrong:\n            return -1\n        if f > lookup[board]:\n            continue\n        (r, c) = divmod(zero, C)\n        for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n            (i, j) = (r + direction[0], c + direction[1])\n            if 0 <= i < R and 0 <= j < C:\n                new_zero = C * i + j\n                tmp = list(board)\n                (tmp[zero], tmp[new_zero]) = (tmp[new_zero], tmp[zero])\n                new_board = tuple(tmp)\n                f = g + 1 + heuristic_estimate(new_board, R, C, expected)\n                if f < lookup.get(new_board, float('inf')):\n                    lookup[new_board] = f\n                    heapq.heappush(min_heap, (f, g + 1, new_zero, new_board))\n    return -1",
            "def slidingPuzzle(self, board):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type board: List[List[int]]\\n        :rtype: int\\n        '\n\n    def heuristic_estimate(board, R, C, expected):\n        result = 0\n        for i in xrange(R):\n            for j in xrange(C):\n                val = board[C * i + j]\n                if val == 0:\n                    continue\n                (r, c) = expected[val]\n                result += abs(r - i) + abs(c - j)\n        return result\n    (R, C) = (len(board), len(board[0]))\n    begin = tuple(itertools.chain(*board))\n    end = tuple(range(1, R * C) + [0])\n    end_wrong = tuple(range(1, R * C - 2) + [R * C - 1, R * C - 2, 0])\n    expected = {(C * i + j + 1) % (R * C): (i, j) for i in xrange(R) for j in xrange(C)}\n    min_heap = [(0, 0, begin.index(0), begin)]\n    lookup = {begin: 0}\n    while min_heap:\n        (f, g, zero, board) = heapq.heappop(min_heap)\n        if board == end:\n            return g\n        if board == end_wrong:\n            return -1\n        if f > lookup[board]:\n            continue\n        (r, c) = divmod(zero, C)\n        for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n            (i, j) = (r + direction[0], c + direction[1])\n            if 0 <= i < R and 0 <= j < C:\n                new_zero = C * i + j\n                tmp = list(board)\n                (tmp[zero], tmp[new_zero]) = (tmp[new_zero], tmp[zero])\n                new_board = tuple(tmp)\n                f = g + 1 + heuristic_estimate(new_board, R, C, expected)\n                if f < lookup.get(new_board, float('inf')):\n                    lookup[new_board] = f\n                    heapq.heappush(min_heap, (f, g + 1, new_zero, new_board))\n    return -1",
            "def slidingPuzzle(self, board):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type board: List[List[int]]\\n        :rtype: int\\n        '\n\n    def heuristic_estimate(board, R, C, expected):\n        result = 0\n        for i in xrange(R):\n            for j in xrange(C):\n                val = board[C * i + j]\n                if val == 0:\n                    continue\n                (r, c) = expected[val]\n                result += abs(r - i) + abs(c - j)\n        return result\n    (R, C) = (len(board), len(board[0]))\n    begin = tuple(itertools.chain(*board))\n    end = tuple(range(1, R * C) + [0])\n    end_wrong = tuple(range(1, R * C - 2) + [R * C - 1, R * C - 2, 0])\n    expected = {(C * i + j + 1) % (R * C): (i, j) for i in xrange(R) for j in xrange(C)}\n    min_heap = [(0, 0, begin.index(0), begin)]\n    lookup = {begin: 0}\n    while min_heap:\n        (f, g, zero, board) = heapq.heappop(min_heap)\n        if board == end:\n            return g\n        if board == end_wrong:\n            return -1\n        if f > lookup[board]:\n            continue\n        (r, c) = divmod(zero, C)\n        for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n            (i, j) = (r + direction[0], c + direction[1])\n            if 0 <= i < R and 0 <= j < C:\n                new_zero = C * i + j\n                tmp = list(board)\n                (tmp[zero], tmp[new_zero]) = (tmp[new_zero], tmp[zero])\n                new_board = tuple(tmp)\n                f = g + 1 + heuristic_estimate(new_board, R, C, expected)\n                if f < lookup.get(new_board, float('inf')):\n                    lookup[new_board] = f\n                    heapq.heappush(min_heap, (f, g + 1, new_zero, new_board))\n    return -1"
        ]
    }
]