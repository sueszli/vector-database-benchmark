[
    {
        "func_name": "__init__",
        "original": "def __init__(self, name=None, poolSize=1024):\n    if name is None:\n        self.name = 'particles-%d' % Particles.id\n        Particles.id += 1\n    else:\n        self.name = name\n    ParticleSystem.__init__(self, poolSize)\n    self.node = PhysicalNode(self.name)\n    self.nodePath = NodePath(self.node)\n    self.setRenderParent(self.node)\n    self.node.addPhysical(self)\n    self.factory = None\n    self.factoryType = 'undefined'\n    self.renderer = None\n    self.rendererType = 'undefined'\n    self.emitter = None\n    self.emitterType = 'undefined'\n    self.fEnabled = 0\n    self.geomReference = ''",
        "mutated": [
            "def __init__(self, name=None, poolSize=1024):\n    if False:\n        i = 10\n    if name is None:\n        self.name = 'particles-%d' % Particles.id\n        Particles.id += 1\n    else:\n        self.name = name\n    ParticleSystem.__init__(self, poolSize)\n    self.node = PhysicalNode(self.name)\n    self.nodePath = NodePath(self.node)\n    self.setRenderParent(self.node)\n    self.node.addPhysical(self)\n    self.factory = None\n    self.factoryType = 'undefined'\n    self.renderer = None\n    self.rendererType = 'undefined'\n    self.emitter = None\n    self.emitterType = 'undefined'\n    self.fEnabled = 0\n    self.geomReference = ''",
            "def __init__(self, name=None, poolSize=1024):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if name is None:\n        self.name = 'particles-%d' % Particles.id\n        Particles.id += 1\n    else:\n        self.name = name\n    ParticleSystem.__init__(self, poolSize)\n    self.node = PhysicalNode(self.name)\n    self.nodePath = NodePath(self.node)\n    self.setRenderParent(self.node)\n    self.node.addPhysical(self)\n    self.factory = None\n    self.factoryType = 'undefined'\n    self.renderer = None\n    self.rendererType = 'undefined'\n    self.emitter = None\n    self.emitterType = 'undefined'\n    self.fEnabled = 0\n    self.geomReference = ''",
            "def __init__(self, name=None, poolSize=1024):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if name is None:\n        self.name = 'particles-%d' % Particles.id\n        Particles.id += 1\n    else:\n        self.name = name\n    ParticleSystem.__init__(self, poolSize)\n    self.node = PhysicalNode(self.name)\n    self.nodePath = NodePath(self.node)\n    self.setRenderParent(self.node)\n    self.node.addPhysical(self)\n    self.factory = None\n    self.factoryType = 'undefined'\n    self.renderer = None\n    self.rendererType = 'undefined'\n    self.emitter = None\n    self.emitterType = 'undefined'\n    self.fEnabled = 0\n    self.geomReference = ''",
            "def __init__(self, name=None, poolSize=1024):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if name is None:\n        self.name = 'particles-%d' % Particles.id\n        Particles.id += 1\n    else:\n        self.name = name\n    ParticleSystem.__init__(self, poolSize)\n    self.node = PhysicalNode(self.name)\n    self.nodePath = NodePath(self.node)\n    self.setRenderParent(self.node)\n    self.node.addPhysical(self)\n    self.factory = None\n    self.factoryType = 'undefined'\n    self.renderer = None\n    self.rendererType = 'undefined'\n    self.emitter = None\n    self.emitterType = 'undefined'\n    self.fEnabled = 0\n    self.geomReference = ''",
            "def __init__(self, name=None, poolSize=1024):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if name is None:\n        self.name = 'particles-%d' % Particles.id\n        Particles.id += 1\n    else:\n        self.name = name\n    ParticleSystem.__init__(self, poolSize)\n    self.node = PhysicalNode(self.name)\n    self.nodePath = NodePath(self.node)\n    self.setRenderParent(self.node)\n    self.node.addPhysical(self)\n    self.factory = None\n    self.factoryType = 'undefined'\n    self.renderer = None\n    self.rendererType = 'undefined'\n    self.emitter = None\n    self.emitterType = 'undefined'\n    self.fEnabled = 0\n    self.geomReference = ''"
        ]
    },
    {
        "func_name": "cleanup",
        "original": "def cleanup(self):\n    self.disable()\n    self.clearLinearForces()\n    self.clearAngularForces()\n    self.setRenderParent(self.node)\n    self.node.removePhysical(self)\n    self.nodePath.removeNode()\n    del self.node\n    del self.nodePath\n    del self.factory\n    del self.renderer\n    del self.emitter",
        "mutated": [
            "def cleanup(self):\n    if False:\n        i = 10\n    self.disable()\n    self.clearLinearForces()\n    self.clearAngularForces()\n    self.setRenderParent(self.node)\n    self.node.removePhysical(self)\n    self.nodePath.removeNode()\n    del self.node\n    del self.nodePath\n    del self.factory\n    del self.renderer\n    del self.emitter",
            "def cleanup(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.disable()\n    self.clearLinearForces()\n    self.clearAngularForces()\n    self.setRenderParent(self.node)\n    self.node.removePhysical(self)\n    self.nodePath.removeNode()\n    del self.node\n    del self.nodePath\n    del self.factory\n    del self.renderer\n    del self.emitter",
            "def cleanup(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.disable()\n    self.clearLinearForces()\n    self.clearAngularForces()\n    self.setRenderParent(self.node)\n    self.node.removePhysical(self)\n    self.nodePath.removeNode()\n    del self.node\n    del self.nodePath\n    del self.factory\n    del self.renderer\n    del self.emitter",
            "def cleanup(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.disable()\n    self.clearLinearForces()\n    self.clearAngularForces()\n    self.setRenderParent(self.node)\n    self.node.removePhysical(self)\n    self.nodePath.removeNode()\n    del self.node\n    del self.nodePath\n    del self.factory\n    del self.renderer\n    del self.emitter",
            "def cleanup(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.disable()\n    self.clearLinearForces()\n    self.clearAngularForces()\n    self.setRenderParent(self.node)\n    self.node.removePhysical(self)\n    self.nodePath.removeNode()\n    del self.node\n    del self.nodePath\n    del self.factory\n    del self.renderer\n    del self.emitter"
        ]
    },
    {
        "func_name": "enable",
        "original": "def enable(self):\n    if self.fEnabled == 0:\n        base.physicsMgr.attachPhysical(self)\n        base.particleMgr.attachParticlesystem(self)\n        self.fEnabled = 1",
        "mutated": [
            "def enable(self):\n    if False:\n        i = 10\n    if self.fEnabled == 0:\n        base.physicsMgr.attachPhysical(self)\n        base.particleMgr.attachParticlesystem(self)\n        self.fEnabled = 1",
            "def enable(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.fEnabled == 0:\n        base.physicsMgr.attachPhysical(self)\n        base.particleMgr.attachParticlesystem(self)\n        self.fEnabled = 1",
            "def enable(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.fEnabled == 0:\n        base.physicsMgr.attachPhysical(self)\n        base.particleMgr.attachParticlesystem(self)\n        self.fEnabled = 1",
            "def enable(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.fEnabled == 0:\n        base.physicsMgr.attachPhysical(self)\n        base.particleMgr.attachParticlesystem(self)\n        self.fEnabled = 1",
            "def enable(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.fEnabled == 0:\n        base.physicsMgr.attachPhysical(self)\n        base.particleMgr.attachParticlesystem(self)\n        self.fEnabled = 1"
        ]
    },
    {
        "func_name": "disable",
        "original": "def disable(self):\n    if self.fEnabled == 1:\n        base.physicsMgr.removePhysical(self)\n        base.particleMgr.removeParticlesystem(self)\n        self.fEnabled = 0",
        "mutated": [
            "def disable(self):\n    if False:\n        i = 10\n    if self.fEnabled == 1:\n        base.physicsMgr.removePhysical(self)\n        base.particleMgr.removeParticlesystem(self)\n        self.fEnabled = 0",
            "def disable(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.fEnabled == 1:\n        base.physicsMgr.removePhysical(self)\n        base.particleMgr.removeParticlesystem(self)\n        self.fEnabled = 0",
            "def disable(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.fEnabled == 1:\n        base.physicsMgr.removePhysical(self)\n        base.particleMgr.removeParticlesystem(self)\n        self.fEnabled = 0",
            "def disable(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.fEnabled == 1:\n        base.physicsMgr.removePhysical(self)\n        base.particleMgr.removeParticlesystem(self)\n        self.fEnabled = 0",
            "def disable(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.fEnabled == 1:\n        base.physicsMgr.removePhysical(self)\n        base.particleMgr.removeParticlesystem(self)\n        self.fEnabled = 0"
        ]
    },
    {
        "func_name": "isEnabled",
        "original": "def isEnabled(self):\n    return self.fEnabled",
        "mutated": [
            "def isEnabled(self):\n    if False:\n        i = 10\n    return self.fEnabled",
            "def isEnabled(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.fEnabled",
            "def isEnabled(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.fEnabled",
            "def isEnabled(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.fEnabled",
            "def isEnabled(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.fEnabled"
        ]
    },
    {
        "func_name": "getNode",
        "original": "def getNode(self):\n    return self.node",
        "mutated": [
            "def getNode(self):\n    if False:\n        i = 10\n    return self.node",
            "def getNode(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.node",
            "def getNode(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.node",
            "def getNode(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.node",
            "def getNode(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.node"
        ]
    },
    {
        "func_name": "setFactory",
        "original": "def setFactory(self, type):\n    if self.factoryType == type:\n        return None\n    if self.factory:\n        self.factory = None\n    self.factoryType = type\n    if type == 'PointParticleFactory':\n        self.factory = PointParticleFactory()\n    elif type == 'ZSpinParticleFactory':\n        self.factory = ZSpinParticleFactory()\n    else:\n        print('unknown factory type: %s' % type)\n        return None\n    self.factory.setLifespanBase(0.5)\n    ParticleSystem.setFactory(self, self.factory)",
        "mutated": [
            "def setFactory(self, type):\n    if False:\n        i = 10\n    if self.factoryType == type:\n        return None\n    if self.factory:\n        self.factory = None\n    self.factoryType = type\n    if type == 'PointParticleFactory':\n        self.factory = PointParticleFactory()\n    elif type == 'ZSpinParticleFactory':\n        self.factory = ZSpinParticleFactory()\n    else:\n        print('unknown factory type: %s' % type)\n        return None\n    self.factory.setLifespanBase(0.5)\n    ParticleSystem.setFactory(self, self.factory)",
            "def setFactory(self, type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.factoryType == type:\n        return None\n    if self.factory:\n        self.factory = None\n    self.factoryType = type\n    if type == 'PointParticleFactory':\n        self.factory = PointParticleFactory()\n    elif type == 'ZSpinParticleFactory':\n        self.factory = ZSpinParticleFactory()\n    else:\n        print('unknown factory type: %s' % type)\n        return None\n    self.factory.setLifespanBase(0.5)\n    ParticleSystem.setFactory(self, self.factory)",
            "def setFactory(self, type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.factoryType == type:\n        return None\n    if self.factory:\n        self.factory = None\n    self.factoryType = type\n    if type == 'PointParticleFactory':\n        self.factory = PointParticleFactory()\n    elif type == 'ZSpinParticleFactory':\n        self.factory = ZSpinParticleFactory()\n    else:\n        print('unknown factory type: %s' % type)\n        return None\n    self.factory.setLifespanBase(0.5)\n    ParticleSystem.setFactory(self, self.factory)",
            "def setFactory(self, type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.factoryType == type:\n        return None\n    if self.factory:\n        self.factory = None\n    self.factoryType = type\n    if type == 'PointParticleFactory':\n        self.factory = PointParticleFactory()\n    elif type == 'ZSpinParticleFactory':\n        self.factory = ZSpinParticleFactory()\n    else:\n        print('unknown factory type: %s' % type)\n        return None\n    self.factory.setLifespanBase(0.5)\n    ParticleSystem.setFactory(self, self.factory)",
            "def setFactory(self, type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.factoryType == type:\n        return None\n    if self.factory:\n        self.factory = None\n    self.factoryType = type\n    if type == 'PointParticleFactory':\n        self.factory = PointParticleFactory()\n    elif type == 'ZSpinParticleFactory':\n        self.factory = ZSpinParticleFactory()\n    else:\n        print('unknown factory type: %s' % type)\n        return None\n    self.factory.setLifespanBase(0.5)\n    ParticleSystem.setFactory(self, self.factory)"
        ]
    },
    {
        "func_name": "setRenderer",
        "original": "def setRenderer(self, type):\n    if self.rendererType == type:\n        return None\n    if self.renderer:\n        self.renderer = None\n    self.rendererType = type\n    if type == 'PointParticleRenderer':\n        self.renderer = PointParticleRenderer()\n        self.renderer.setPointSize(1.0)\n    elif type == 'LineParticleRenderer':\n        self.renderer = LineParticleRenderer()\n    elif type == 'GeomParticleRenderer':\n        self.renderer = GeomParticleRenderer()\n        if __dev__:\n            from direct.directtools import DirectSelection\n            npath = NodePath('default-geom')\n            bbox = DirectSelection.DirectBoundingBox(npath)\n            self.renderer.setGeomNode(bbox.lines.node())\n    elif type == 'SparkleParticleRenderer':\n        self.renderer = SparkleParticleRenderer()\n    elif type == 'SpriteParticleRenderer':\n        self.renderer = SpriteParticleRendererExt.SpriteParticleRendererExt()\n    else:\n        print('unknown renderer type: %s' % type)\n        return None\n    ParticleSystem.setRenderer(self, self.renderer)",
        "mutated": [
            "def setRenderer(self, type):\n    if False:\n        i = 10\n    if self.rendererType == type:\n        return None\n    if self.renderer:\n        self.renderer = None\n    self.rendererType = type\n    if type == 'PointParticleRenderer':\n        self.renderer = PointParticleRenderer()\n        self.renderer.setPointSize(1.0)\n    elif type == 'LineParticleRenderer':\n        self.renderer = LineParticleRenderer()\n    elif type == 'GeomParticleRenderer':\n        self.renderer = GeomParticleRenderer()\n        if __dev__:\n            from direct.directtools import DirectSelection\n            npath = NodePath('default-geom')\n            bbox = DirectSelection.DirectBoundingBox(npath)\n            self.renderer.setGeomNode(bbox.lines.node())\n    elif type == 'SparkleParticleRenderer':\n        self.renderer = SparkleParticleRenderer()\n    elif type == 'SpriteParticleRenderer':\n        self.renderer = SpriteParticleRendererExt.SpriteParticleRendererExt()\n    else:\n        print('unknown renderer type: %s' % type)\n        return None\n    ParticleSystem.setRenderer(self, self.renderer)",
            "def setRenderer(self, type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.rendererType == type:\n        return None\n    if self.renderer:\n        self.renderer = None\n    self.rendererType = type\n    if type == 'PointParticleRenderer':\n        self.renderer = PointParticleRenderer()\n        self.renderer.setPointSize(1.0)\n    elif type == 'LineParticleRenderer':\n        self.renderer = LineParticleRenderer()\n    elif type == 'GeomParticleRenderer':\n        self.renderer = GeomParticleRenderer()\n        if __dev__:\n            from direct.directtools import DirectSelection\n            npath = NodePath('default-geom')\n            bbox = DirectSelection.DirectBoundingBox(npath)\n            self.renderer.setGeomNode(bbox.lines.node())\n    elif type == 'SparkleParticleRenderer':\n        self.renderer = SparkleParticleRenderer()\n    elif type == 'SpriteParticleRenderer':\n        self.renderer = SpriteParticleRendererExt.SpriteParticleRendererExt()\n    else:\n        print('unknown renderer type: %s' % type)\n        return None\n    ParticleSystem.setRenderer(self, self.renderer)",
            "def setRenderer(self, type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.rendererType == type:\n        return None\n    if self.renderer:\n        self.renderer = None\n    self.rendererType = type\n    if type == 'PointParticleRenderer':\n        self.renderer = PointParticleRenderer()\n        self.renderer.setPointSize(1.0)\n    elif type == 'LineParticleRenderer':\n        self.renderer = LineParticleRenderer()\n    elif type == 'GeomParticleRenderer':\n        self.renderer = GeomParticleRenderer()\n        if __dev__:\n            from direct.directtools import DirectSelection\n            npath = NodePath('default-geom')\n            bbox = DirectSelection.DirectBoundingBox(npath)\n            self.renderer.setGeomNode(bbox.lines.node())\n    elif type == 'SparkleParticleRenderer':\n        self.renderer = SparkleParticleRenderer()\n    elif type == 'SpriteParticleRenderer':\n        self.renderer = SpriteParticleRendererExt.SpriteParticleRendererExt()\n    else:\n        print('unknown renderer type: %s' % type)\n        return None\n    ParticleSystem.setRenderer(self, self.renderer)",
            "def setRenderer(self, type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.rendererType == type:\n        return None\n    if self.renderer:\n        self.renderer = None\n    self.rendererType = type\n    if type == 'PointParticleRenderer':\n        self.renderer = PointParticleRenderer()\n        self.renderer.setPointSize(1.0)\n    elif type == 'LineParticleRenderer':\n        self.renderer = LineParticleRenderer()\n    elif type == 'GeomParticleRenderer':\n        self.renderer = GeomParticleRenderer()\n        if __dev__:\n            from direct.directtools import DirectSelection\n            npath = NodePath('default-geom')\n            bbox = DirectSelection.DirectBoundingBox(npath)\n            self.renderer.setGeomNode(bbox.lines.node())\n    elif type == 'SparkleParticleRenderer':\n        self.renderer = SparkleParticleRenderer()\n    elif type == 'SpriteParticleRenderer':\n        self.renderer = SpriteParticleRendererExt.SpriteParticleRendererExt()\n    else:\n        print('unknown renderer type: %s' % type)\n        return None\n    ParticleSystem.setRenderer(self, self.renderer)",
            "def setRenderer(self, type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.rendererType == type:\n        return None\n    if self.renderer:\n        self.renderer = None\n    self.rendererType = type\n    if type == 'PointParticleRenderer':\n        self.renderer = PointParticleRenderer()\n        self.renderer.setPointSize(1.0)\n    elif type == 'LineParticleRenderer':\n        self.renderer = LineParticleRenderer()\n    elif type == 'GeomParticleRenderer':\n        self.renderer = GeomParticleRenderer()\n        if __dev__:\n            from direct.directtools import DirectSelection\n            npath = NodePath('default-geom')\n            bbox = DirectSelection.DirectBoundingBox(npath)\n            self.renderer.setGeomNode(bbox.lines.node())\n    elif type == 'SparkleParticleRenderer':\n        self.renderer = SparkleParticleRenderer()\n    elif type == 'SpriteParticleRenderer':\n        self.renderer = SpriteParticleRendererExt.SpriteParticleRendererExt()\n    else:\n        print('unknown renderer type: %s' % type)\n        return None\n    ParticleSystem.setRenderer(self, self.renderer)"
        ]
    },
    {
        "func_name": "setEmitter",
        "original": "def setEmitter(self, type):\n    if self.emitterType == type:\n        return None\n    if self.emitter:\n        self.emitter = None\n    self.emitterType = type\n    if type == 'ArcEmitter':\n        self.emitter = ArcEmitter()\n    elif type == 'BoxEmitter':\n        self.emitter = BoxEmitter()\n    elif type == 'DiscEmitter':\n        self.emitter = DiscEmitter()\n    elif type == 'LineEmitter':\n        self.emitter = LineEmitter()\n    elif type == 'PointEmitter':\n        self.emitter = PointEmitter()\n    elif type == 'RectangleEmitter':\n        self.emitter = RectangleEmitter()\n    elif type == 'RingEmitter':\n        self.emitter = RingEmitter()\n    elif type == 'SphereSurfaceEmitter':\n        self.emitter = SphereSurfaceEmitter()\n    elif type == 'SphereVolumeEmitter':\n        self.emitter = SphereVolumeEmitter()\n        self.emitter.setRadius(1.0)\n    elif type == 'TangentRingEmitter':\n        self.emitter = TangentRingEmitter()\n    else:\n        print('unknown emitter type: %s' % type)\n        return None\n    ParticleSystem.setEmitter(self, self.emitter)",
        "mutated": [
            "def setEmitter(self, type):\n    if False:\n        i = 10\n    if self.emitterType == type:\n        return None\n    if self.emitter:\n        self.emitter = None\n    self.emitterType = type\n    if type == 'ArcEmitter':\n        self.emitter = ArcEmitter()\n    elif type == 'BoxEmitter':\n        self.emitter = BoxEmitter()\n    elif type == 'DiscEmitter':\n        self.emitter = DiscEmitter()\n    elif type == 'LineEmitter':\n        self.emitter = LineEmitter()\n    elif type == 'PointEmitter':\n        self.emitter = PointEmitter()\n    elif type == 'RectangleEmitter':\n        self.emitter = RectangleEmitter()\n    elif type == 'RingEmitter':\n        self.emitter = RingEmitter()\n    elif type == 'SphereSurfaceEmitter':\n        self.emitter = SphereSurfaceEmitter()\n    elif type == 'SphereVolumeEmitter':\n        self.emitter = SphereVolumeEmitter()\n        self.emitter.setRadius(1.0)\n    elif type == 'TangentRingEmitter':\n        self.emitter = TangentRingEmitter()\n    else:\n        print('unknown emitter type: %s' % type)\n        return None\n    ParticleSystem.setEmitter(self, self.emitter)",
            "def setEmitter(self, type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.emitterType == type:\n        return None\n    if self.emitter:\n        self.emitter = None\n    self.emitterType = type\n    if type == 'ArcEmitter':\n        self.emitter = ArcEmitter()\n    elif type == 'BoxEmitter':\n        self.emitter = BoxEmitter()\n    elif type == 'DiscEmitter':\n        self.emitter = DiscEmitter()\n    elif type == 'LineEmitter':\n        self.emitter = LineEmitter()\n    elif type == 'PointEmitter':\n        self.emitter = PointEmitter()\n    elif type == 'RectangleEmitter':\n        self.emitter = RectangleEmitter()\n    elif type == 'RingEmitter':\n        self.emitter = RingEmitter()\n    elif type == 'SphereSurfaceEmitter':\n        self.emitter = SphereSurfaceEmitter()\n    elif type == 'SphereVolumeEmitter':\n        self.emitter = SphereVolumeEmitter()\n        self.emitter.setRadius(1.0)\n    elif type == 'TangentRingEmitter':\n        self.emitter = TangentRingEmitter()\n    else:\n        print('unknown emitter type: %s' % type)\n        return None\n    ParticleSystem.setEmitter(self, self.emitter)",
            "def setEmitter(self, type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.emitterType == type:\n        return None\n    if self.emitter:\n        self.emitter = None\n    self.emitterType = type\n    if type == 'ArcEmitter':\n        self.emitter = ArcEmitter()\n    elif type == 'BoxEmitter':\n        self.emitter = BoxEmitter()\n    elif type == 'DiscEmitter':\n        self.emitter = DiscEmitter()\n    elif type == 'LineEmitter':\n        self.emitter = LineEmitter()\n    elif type == 'PointEmitter':\n        self.emitter = PointEmitter()\n    elif type == 'RectangleEmitter':\n        self.emitter = RectangleEmitter()\n    elif type == 'RingEmitter':\n        self.emitter = RingEmitter()\n    elif type == 'SphereSurfaceEmitter':\n        self.emitter = SphereSurfaceEmitter()\n    elif type == 'SphereVolumeEmitter':\n        self.emitter = SphereVolumeEmitter()\n        self.emitter.setRadius(1.0)\n    elif type == 'TangentRingEmitter':\n        self.emitter = TangentRingEmitter()\n    else:\n        print('unknown emitter type: %s' % type)\n        return None\n    ParticleSystem.setEmitter(self, self.emitter)",
            "def setEmitter(self, type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.emitterType == type:\n        return None\n    if self.emitter:\n        self.emitter = None\n    self.emitterType = type\n    if type == 'ArcEmitter':\n        self.emitter = ArcEmitter()\n    elif type == 'BoxEmitter':\n        self.emitter = BoxEmitter()\n    elif type == 'DiscEmitter':\n        self.emitter = DiscEmitter()\n    elif type == 'LineEmitter':\n        self.emitter = LineEmitter()\n    elif type == 'PointEmitter':\n        self.emitter = PointEmitter()\n    elif type == 'RectangleEmitter':\n        self.emitter = RectangleEmitter()\n    elif type == 'RingEmitter':\n        self.emitter = RingEmitter()\n    elif type == 'SphereSurfaceEmitter':\n        self.emitter = SphereSurfaceEmitter()\n    elif type == 'SphereVolumeEmitter':\n        self.emitter = SphereVolumeEmitter()\n        self.emitter.setRadius(1.0)\n    elif type == 'TangentRingEmitter':\n        self.emitter = TangentRingEmitter()\n    else:\n        print('unknown emitter type: %s' % type)\n        return None\n    ParticleSystem.setEmitter(self, self.emitter)",
            "def setEmitter(self, type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.emitterType == type:\n        return None\n    if self.emitter:\n        self.emitter = None\n    self.emitterType = type\n    if type == 'ArcEmitter':\n        self.emitter = ArcEmitter()\n    elif type == 'BoxEmitter':\n        self.emitter = BoxEmitter()\n    elif type == 'DiscEmitter':\n        self.emitter = DiscEmitter()\n    elif type == 'LineEmitter':\n        self.emitter = LineEmitter()\n    elif type == 'PointEmitter':\n        self.emitter = PointEmitter()\n    elif type == 'RectangleEmitter':\n        self.emitter = RectangleEmitter()\n    elif type == 'RingEmitter':\n        self.emitter = RingEmitter()\n    elif type == 'SphereSurfaceEmitter':\n        self.emitter = SphereSurfaceEmitter()\n    elif type == 'SphereVolumeEmitter':\n        self.emitter = SphereVolumeEmitter()\n        self.emitter.setRadius(1.0)\n    elif type == 'TangentRingEmitter':\n        self.emitter = TangentRingEmitter()\n    else:\n        print('unknown emitter type: %s' % type)\n        return None\n    ParticleSystem.setEmitter(self, self.emitter)"
        ]
    },
    {
        "func_name": "addForce",
        "original": "def addForce(self, force):\n    if force.isLinear():\n        self.addLinearForce(force)\n    else:\n        self.addAngularForce(force)",
        "mutated": [
            "def addForce(self, force):\n    if False:\n        i = 10\n    if force.isLinear():\n        self.addLinearForce(force)\n    else:\n        self.addAngularForce(force)",
            "def addForce(self, force):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if force.isLinear():\n        self.addLinearForce(force)\n    else:\n        self.addAngularForce(force)",
            "def addForce(self, force):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if force.isLinear():\n        self.addLinearForce(force)\n    else:\n        self.addAngularForce(force)",
            "def addForce(self, force):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if force.isLinear():\n        self.addLinearForce(force)\n    else:\n        self.addAngularForce(force)",
            "def addForce(self, force):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if force.isLinear():\n        self.addLinearForce(force)\n    else:\n        self.addAngularForce(force)"
        ]
    },
    {
        "func_name": "removeForce",
        "original": "def removeForce(self, force):\n    if force is None:\n        self.notify.warning('removeForce() - force is None!')\n        return\n    if force.isLinear():\n        self.removeLinearForce(force)\n    else:\n        self.removeAngularForce(force)",
        "mutated": [
            "def removeForce(self, force):\n    if False:\n        i = 10\n    if force is None:\n        self.notify.warning('removeForce() - force is None!')\n        return\n    if force.isLinear():\n        self.removeLinearForce(force)\n    else:\n        self.removeAngularForce(force)",
            "def removeForce(self, force):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if force is None:\n        self.notify.warning('removeForce() - force is None!')\n        return\n    if force.isLinear():\n        self.removeLinearForce(force)\n    else:\n        self.removeAngularForce(force)",
            "def removeForce(self, force):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if force is None:\n        self.notify.warning('removeForce() - force is None!')\n        return\n    if force.isLinear():\n        self.removeLinearForce(force)\n    else:\n        self.removeAngularForce(force)",
            "def removeForce(self, force):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if force is None:\n        self.notify.warning('removeForce() - force is None!')\n        return\n    if force.isLinear():\n        self.removeLinearForce(force)\n    else:\n        self.removeAngularForce(force)",
            "def removeForce(self, force):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if force is None:\n        self.notify.warning('removeForce() - force is None!')\n        return\n    if force.isLinear():\n        self.removeLinearForce(force)\n    else:\n        self.removeAngularForce(force)"
        ]
    },
    {
        "func_name": "setRenderNodePath",
        "original": "def setRenderNodePath(self, nodePath):\n    self.setRenderParent(nodePath.node())",
        "mutated": [
            "def setRenderNodePath(self, nodePath):\n    if False:\n        i = 10\n    self.setRenderParent(nodePath.node())",
            "def setRenderNodePath(self, nodePath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.setRenderParent(nodePath.node())",
            "def setRenderNodePath(self, nodePath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.setRenderParent(nodePath.node())",
            "def setRenderNodePath(self, nodePath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.setRenderParent(nodePath.node())",
            "def setRenderNodePath(self, nodePath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.setRenderParent(nodePath.node())"
        ]
    },
    {
        "func_name": "getName",
        "original": "def getName(self):\n    return self.name",
        "mutated": [
            "def getName(self):\n    if False:\n        i = 10\n    return self.name",
            "def getName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.name",
            "def getName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.name",
            "def getName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.name",
            "def getName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.name"
        ]
    },
    {
        "func_name": "getFactory",
        "original": "def getFactory(self):\n    return self.factory",
        "mutated": [
            "def getFactory(self):\n    if False:\n        i = 10\n    return self.factory",
            "def getFactory(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.factory",
            "def getFactory(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.factory",
            "def getFactory(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.factory",
            "def getFactory(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.factory"
        ]
    },
    {
        "func_name": "getEmitter",
        "original": "def getEmitter(self):\n    return self.emitter",
        "mutated": [
            "def getEmitter(self):\n    if False:\n        i = 10\n    return self.emitter",
            "def getEmitter(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.emitter",
            "def getEmitter(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.emitter",
            "def getEmitter(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.emitter",
            "def getEmitter(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.emitter"
        ]
    },
    {
        "func_name": "getRenderer",
        "original": "def getRenderer(self):\n    return self.renderer",
        "mutated": [
            "def getRenderer(self):\n    if False:\n        i = 10\n    return self.renderer",
            "def getRenderer(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.renderer",
            "def getRenderer(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.renderer",
            "def getRenderer(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.renderer",
            "def getRenderer(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.renderer"
        ]
    },
    {
        "func_name": "printParams",
        "original": "def printParams(self, file=sys.stdout, targ='self'):\n    file.write('# Particles parameters\\n')\n    file.write(targ + '.setFactory(\"' + self.factoryType + '\")\\n')\n    file.write(targ + '.setRenderer(\"' + self.rendererType + '\")\\n')\n    file.write(targ + '.setEmitter(\"' + self.emitterType + '\")\\n')\n    file.write(targ + '.setPoolSize(%d)\\n' % int(self.getPoolSize()))\n    file.write(targ + '.setBirthRate(%.4f)\\n' % self.getBirthRate())\n    file.write(targ + '.setLitterSize(%d)\\n' % int(self.getLitterSize()))\n    file.write(targ + '.setLitterSpread(%d)\\n' % self.getLitterSpread())\n    file.write(targ + '.setSystemLifespan(%.4f)\\n' % self.getSystemLifespan())\n    file.write(targ + '.setLocalVelocityFlag(%d)\\n' % self.getLocalVelocityFlag())\n    file.write(targ + '.setSystemGrowsOlderFlag(%d)\\n' % self.getSystemGrowsOlderFlag())\n    file.write('# Factory parameters\\n')\n    file.write(targ + '.factory.setLifespanBase(%.4f)\\n' % self.factory.getLifespanBase())\n    file.write(targ + '.factory.setLifespanSpread(%.4f)\\n' % self.factory.getLifespanSpread())\n    file.write(targ + '.factory.setMassBase(%.4f)\\n' % self.factory.getMassBase())\n    file.write(targ + '.factory.setMassSpread(%.4f)\\n' % self.factory.getMassSpread())\n    file.write(targ + '.factory.setTerminalVelocityBase(%.4f)\\n' % self.factory.getTerminalVelocityBase())\n    file.write(targ + '.factory.setTerminalVelocitySpread(%.4f)\\n' % self.factory.getTerminalVelocitySpread())\n    if self.factoryType == 'PointParticleFactory':\n        file.write('# Point factory parameters\\n')\n    elif self.factoryType == 'ZSpinParticleFactory':\n        file.write('# Z Spin factory parameters\\n')\n        file.write(targ + '.factory.setInitialAngle(%.4f)\\n' % self.factory.getInitialAngle())\n        file.write(targ + '.factory.setInitialAngleSpread(%.4f)\\n' % self.factory.getInitialAngleSpread())\n        file.write(targ + '.factory.enableAngularVelocity(%d)\\n' % self.factory.getAngularVelocityEnabled())\n        if self.factory.getAngularVelocityEnabled():\n            file.write(targ + '.factory.setAngularVelocity(%.4f)\\n' % self.factory.getAngularVelocity())\n            file.write(targ + '.factory.setAngularVelocitySpread(%.4f)\\n' % self.factory.getAngularVelocitySpread())\n        else:\n            file.write(targ + '.factory.setFinalAngle(%.4f)\\n' % self.factory.getFinalAngle())\n            file.write(targ + '.factory.setFinalAngleSpread(%.4f)\\n' % self.factory.getFinalAngleSpread())\n    elif self.factoryType == 'OrientedParticleFactory':\n        file.write('# Oriented factory parameters\\n')\n        file.write(targ + '.factory.setInitialOrientation(%.4f)\\n' % self.factory.getInitialOrientation())\n        file.write(targ + '.factory.setFinalOrientation(%.4f)\\n' % self.factory.getFinalOrientation())\n    file.write('# Renderer parameters\\n')\n    alphaMode = self.renderer.getAlphaMode()\n    aMode = 'PRALPHANONE'\n    if alphaMode == BaseParticleRenderer.PRALPHANONE:\n        aMode = 'PRALPHANONE'\n    elif alphaMode == BaseParticleRenderer.PRALPHAOUT:\n        aMode = 'PRALPHAOUT'\n    elif alphaMode == BaseParticleRenderer.PRALPHAIN:\n        aMode = 'PRALPHAIN'\n    elif alphaMode == BaseParticleRenderer.PRALPHAINOUT:\n        aMode = 'PRALPHAINOUT'\n    elif alphaMode == BaseParticleRenderer.PRALPHAUSER:\n        aMode = 'PRALPHAUSER'\n    file.write(targ + '.renderer.setAlphaMode(BaseParticleRenderer.' + aMode + ')\\n')\n    file.write(targ + '.renderer.setUserAlpha(%.2f)\\n' % self.renderer.getUserAlpha())\n    if self.rendererType == 'PointParticleRenderer':\n        file.write('# Point parameters\\n')\n        file.write(targ + '.renderer.setPointSize(%.2f)\\n' % self.renderer.getPointSize())\n        sColor = self.renderer.getStartColor()\n        file.write(targ + '.renderer.setStartColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getEndColor()\n        file.write(targ + '.renderer.setEndColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        blendType = self.renderer.getBlendType()\n        bType = 'PPONECOLOR'\n        if blendType == PointParticleRenderer.PPONECOLOR:\n            bType = 'PPONECOLOR'\n        elif blendType == PointParticleRenderer.PPBLENDLIFE:\n            bType = 'PPBLENDLIFE'\n        elif blendType == PointParticleRenderer.PPBLENDVEL:\n            bType = 'PPBLENDVEL'\n        file.write(targ + '.renderer.setBlendType(PointParticleRenderer.' + bType + ')\\n')\n        blendMethod = self.renderer.getBlendMethod()\n        bMethod = 'PPNOBLEND'\n        if blendMethod == BaseParticleRenderer.PPNOBLEND:\n            bMethod = 'PPNOBLEND'\n        elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n            bMethod = 'PPBLENDLINEAR'\n        elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n            bMethod = 'PPBLENDCUBIC'\n        file.write(targ + '.renderer.setBlendMethod(BaseParticleRenderer.' + bMethod + ')\\n')\n    elif self.rendererType == 'LineParticleRenderer':\n        file.write('# Line parameters\\n')\n        sColor = self.renderer.getHeadColor()\n        file.write(targ + '.renderer.setHeadColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getTailColor()\n        file.write(targ + '.renderer.setTailColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sf = self.renderer.getLineScaleFactor()\n        file.write(targ + '.renderer.setLineScaleFactor(%.2f)\\n' % sf)\n    elif self.rendererType == 'GeomParticleRenderer':\n        file.write('# Geom parameters\\n')\n        node = self.renderer.getGeomNode()\n        file.write('geomRef = loader.loadModel(\"' + self.geomReference + '\")\\n')\n        file.write(targ + '.renderer.setGeomNode(geomRef.node())\\n')\n        file.write(targ + '.geomReference = \"' + self.geomReference + '\"\\n')\n        cbmLut = ('MNone', 'MAdd', 'MSubtract', 'MInvSubtract', 'MMin', 'MMax')\n        cboLut = ('OZero', 'OOne', 'OIncomingColor', 'OOneMinusIncomingColor', 'OFbufferColor', 'OOneMinusFbufferColor', 'OIncomingAlpha', 'OOneMinusIncomingAlpha', 'OFbufferAlpha', 'OOneMinusFbufferAlpha', 'OConstantColor', 'OOneMinusConstantColor', 'OConstantAlpha', 'OOneMinusConstantAlpha', 'OIncomingColorSaturate')\n        file.write(targ + '.renderer.setXScaleFlag(%d)\\n' % self.renderer.getXScaleFlag())\n        file.write(targ + '.renderer.setYScaleFlag(%d)\\n' % self.renderer.getYScaleFlag())\n        file.write(targ + '.renderer.setZScaleFlag(%d)\\n' % self.renderer.getZScaleFlag())\n        file.write(targ + '.renderer.setInitialXScale(%.4f)\\n' % self.renderer.getInitialXScale())\n        file.write(targ + '.renderer.setFinalXScale(%.4f)\\n' % self.renderer.getFinalXScale())\n        file.write(targ + '.renderer.setInitialYScale(%.4f)\\n' % self.renderer.getInitialYScale())\n        file.write(targ + '.renderer.setFinalYScale(%.4f)\\n' % self.renderer.getFinalYScale())\n        file.write(targ + '.renderer.setInitialZScale(%.4f)\\n' % self.renderer.getInitialZScale())\n        file.write(targ + '.renderer.setFinalZScale(%.4f)\\n' % self.renderer.getFinalZScale())\n        cbAttrib = self.renderer.getRenderNode().getAttrib(ColorBlendAttrib.getClassType())\n        if cbAttrib:\n            cbMode = cbAttrib.getMode()\n            if cbMode > 0:\n                if cbMode in (ColorBlendAttrib.MAdd, ColorBlendAttrib.MSubtract, ColorBlendAttrib.MInvSubtract):\n                    cboa = cbAttrib.getOperandA()\n                    cbob = cbAttrib.getOperandB()\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s, ColorBlendAttrib.%s, ColorBlendAttrib.%s)\\n' % (cbmLut[cbMode], cboLut[cboa], cboLut[cbob]))\n                else:\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s)\\n' % cbmLut[cbMode])\n        cim = self.renderer.getColorInterpolationManager()\n        segIdList = [int(seg) for seg in cim.getSegmentIdList().split()]\n        for sid in segIdList:\n            seg = cim.getSegment(sid)\n            if seg.isEnabled():\n                t_b = seg.getTimeBegin()\n                t_e = seg.getTimeEnd()\n                mod = seg.isModulated()\n                fun = seg.getFunction()\n                typ = type(fun).__name__\n                if typ == 'ColorInterpolationFunctionConstant':\n                    c_a = fun.getColorA()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addConstant(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionLinear':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addLinear(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionStepwave':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    w_a = fun.getWidthA()\n                    w_b = fun.getWidthB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addStepwave(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(w_a) + ',' + repr(w_b) + ',' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionSinusoid':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    per = fun.getPeriod()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addSinusoid(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(per) + ',' + repr(mod) + ')\\n')\n    elif self.rendererType == 'SparkleParticleRenderer':\n        file.write('# Sparkle parameters\\n')\n        sColor = self.renderer.getCenterColor()\n        file.write(targ + '.renderer.setCenterColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getEdgeColor()\n        file.write(targ + '.renderer.setEdgeColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        file.write(targ + '.renderer.setBirthRadius(%.4f)\\n' % self.renderer.getBirthRadius())\n        file.write(targ + '.renderer.setDeathRadius(%.4f)\\n' % self.renderer.getDeathRadius())\n        lifeScale = self.renderer.getLifeScale()\n        lScale = 'SPNOSCALE'\n        if lifeScale == SparkleParticleRenderer.SPSCALE:\n            lScale = 'SPSCALE'\n        file.write(targ + '.renderer.setLifeScale(SparkleParticleRenderer.' + lScale + ')\\n')\n    elif self.rendererType == 'SpriteParticleRenderer':\n        file.write('# Sprite parameters\\n')\n        if self.renderer.getAnimateFramesEnable():\n            file.write(targ + '.renderer.setAnimateFramesEnable(True)\\n')\n            rate = self.renderer.getAnimateFramesRate()\n            if rate:\n                file.write(targ + '.renderer.setAnimateFramesRate(%.3f)\\n' % rate)\n        animCount = self.renderer.getNumAnims()\n        for x in range(animCount):\n            anim = self.renderer.getAnim(x)\n            if anim.getSourceType() == SpriteAnim.STTexture:\n                file.write(targ + \".renderer.addTextureFromFile('%s')\\n\" % (anim.getTexSource(),))\n            else:\n                file.write(targ + \".renderer.addTextureFromNode('%s','%s')\\n\" % (anim.getModelSource(), anim.getNodeSource()))\n        sColor = self.renderer.getColor()\n        file.write(targ + '.renderer.setColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        file.write(targ + '.renderer.setXScaleFlag(%d)\\n' % self.renderer.getXScaleFlag())\n        file.write(targ + '.renderer.setYScaleFlag(%d)\\n' % self.renderer.getYScaleFlag())\n        file.write(targ + '.renderer.setAnimAngleFlag(%d)\\n' % self.renderer.getAnimAngleFlag())\n        file.write(targ + '.renderer.setInitialXScale(%.4f)\\n' % self.renderer.getInitialXScale())\n        file.write(targ + '.renderer.setFinalXScale(%.4f)\\n' % self.renderer.getFinalXScale())\n        file.write(targ + '.renderer.setInitialYScale(%.4f)\\n' % self.renderer.getInitialYScale())\n        file.write(targ + '.renderer.setFinalYScale(%.4f)\\n' % self.renderer.getFinalYScale())\n        file.write(targ + '.renderer.setNonanimatedTheta(%.4f)\\n' % self.renderer.getNonanimatedTheta())\n        blendMethod = self.renderer.getAlphaBlendMethod()\n        bMethod = 'PPNOBLEND'\n        if blendMethod == BaseParticleRenderer.PPNOBLEND:\n            bMethod = 'PPNOBLEND'\n        elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n            bMethod = 'PPBLENDLINEAR'\n        elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n            bMethod = 'PPBLENDCUBIC'\n        file.write(targ + '.renderer.setAlphaBlendMethod(BaseParticleRenderer.' + bMethod + ')\\n')\n        file.write(targ + '.renderer.setAlphaDisable(%d)\\n' % self.renderer.getAlphaDisable())\n        cbmLut = ('MNone', 'MAdd', 'MSubtract', 'MInvSubtract', 'MMin', 'MMax')\n        cboLut = ('OZero', 'OOne', 'OIncomingColor', 'OOneMinusIncomingColor', 'OFbufferColor', 'OOneMinusFbufferColor', 'OIncomingAlpha', 'OOneMinusIncomingAlpha', 'OFbufferAlpha', 'OOneMinusFbufferAlpha', 'OConstantColor', 'OOneMinusConstantColor', 'OConstantAlpha', 'OOneMinusConstantAlpha', 'OIncomingColorSaturate')\n        cbAttrib = self.renderer.getRenderNode().getAttrib(ColorBlendAttrib.getClassType())\n        if cbAttrib:\n            cbMode = cbAttrib.getMode()\n            if cbMode > 0:\n                if cbMode in (ColorBlendAttrib.MAdd, ColorBlendAttrib.MSubtract, ColorBlendAttrib.MInvSubtract):\n                    cboa = cbAttrib.getOperandA()\n                    cbob = cbAttrib.getOperandB()\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s, ColorBlendAttrib.%s, ColorBlendAttrib.%s)\\n' % (cbmLut[cbMode], cboLut[cboa], cboLut[cbob]))\n                else:\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s)\\n' % cbmLut[cbMode])\n        cim = self.renderer.getColorInterpolationManager()\n        segIdList = [int(seg) for seg in cim.getSegmentIdList().split()]\n        for sid in segIdList:\n            seg = cim.getSegment(sid)\n            if seg.isEnabled():\n                t_b = seg.getTimeBegin()\n                t_e = seg.getTimeEnd()\n                mod = seg.isModulated()\n                fun = seg.getFunction()\n                typ = type(fun).__name__\n                if typ == 'ColorInterpolationFunctionConstant':\n                    c_a = fun.getColorA()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addConstant(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionLinear':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addLinear(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionStepwave':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    w_a = fun.getWidthA()\n                    w_b = fun.getWidthB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addStepwave(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(w_a) + ',' + repr(w_b) + ',' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionSinusoid':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    per = fun.getPeriod()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addSinusoid(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(per) + ',' + repr(mod) + ')\\n')\n    file.write('# Emitter parameters\\n')\n    emissionType = self.emitter.getEmissionType()\n    eType = 'ETEXPLICIT'\n    if emissionType == BaseParticleEmitter.ETEXPLICIT:\n        eType = 'ETEXPLICIT'\n    elif emissionType == BaseParticleEmitter.ETRADIATE:\n        eType = 'ETRADIATE'\n    elif emissionType == BaseParticleEmitter.ETCUSTOM:\n        eType = 'ETCUSTOM'\n    file.write(targ + '.emitter.setEmissionType(BaseParticleEmitter.' + eType + ')\\n')\n    file.write(targ + '.emitter.setAmplitude(%.4f)\\n' % self.emitter.getAmplitude())\n    file.write(targ + '.emitter.setAmplitudeSpread(%.4f)\\n' % self.emitter.getAmplitudeSpread())\n    oForce = self.emitter.getOffsetForce()\n    file.write(targ + '.emitter.setOffsetForce(Vec3(%.4f, %.4f, %.4f))\\n' % (oForce[0], oForce[1], oForce[2]))\n    oForce = self.emitter.getExplicitLaunchVector()\n    file.write(targ + '.emitter.setExplicitLaunchVector(Vec3(%.4f, %.4f, %.4f))\\n' % (oForce[0], oForce[1], oForce[2]))\n    orig = self.emitter.getRadiateOrigin()\n    file.write(targ + '.emitter.setRadiateOrigin(Point3(%.4f, %.4f, %.4f))\\n' % (orig[0], orig[1], orig[2]))\n    if self.emitterType == 'BoxEmitter':\n        file.write('# Box parameters\\n')\n        bound = self.emitter.getMinBound()\n        file.write(targ + '.emitter.setMinBound(Point3(%.4f, %.4f, %.4f))\\n' % (bound[0], bound[1], bound[2]))\n        bound = self.emitter.getMaxBound()\n        file.write(targ + '.emitter.setMaxBound(Point3(%.4f, %.4f, %.4f))\\n' % (bound[0], bound[1], bound[2]))\n    elif self.emitterType == 'DiscEmitter':\n        file.write('# Disc parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        if eType == 'ETCUSTOM':\n            file.write(targ + '.emitter.setOuterAngle(%.4f)\\n' % self.emitter.getOuterAngle())\n            file.write(targ + '.emitter.setInnerAngle(%.4f)\\n' % self.emitter.getInnerAngle())\n            file.write(targ + '.emitter.setOuterMagnitude(%.4f)\\n' % self.emitter.getOuterMagnitude())\n            file.write(targ + '.emitter.setInnerMagnitude(%.4f)\\n' % self.emitter.getInnerMagnitude())\n            file.write(targ + '.emitter.setCubicLerping(%d)\\n' % self.emitter.getCubicLerping())\n    elif self.emitterType == 'LineEmitter':\n        file.write('# Line parameters\\n')\n        point = self.emitter.getEndpoint1()\n        file.write(targ + '.emitter.setEndpoint1(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n        point = self.emitter.getEndpoint2()\n        file.write(targ + '.emitter.setEndpoint2(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n    elif self.emitterType == 'PointEmitter':\n        file.write('# Point parameters\\n')\n        point = self.emitter.getLocation()\n        file.write(targ + '.emitter.setLocation(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n    elif self.emitterType == 'RectangleEmitter':\n        file.write('# Rectangle parameters\\n')\n        point = self.emitter.getMinBound()\n        file.write(targ + '.emitter.setMinBound(Point2(%.4f, %.4f))\\n' % (point[0], point[1]))\n        point = self.emitter.getMaxBound()\n        file.write(targ + '.emitter.setMaxBound(Point2(%.4f, %.4f))\\n' % (point[0], point[1]))\n    elif self.emitterType == 'RingEmitter':\n        file.write('# Ring parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        file.write(targ + '.emitter.setRadiusSpread(%.4f)\\n' % self.emitter.getRadiusSpread())\n        if eType == 'ETCUSTOM':\n            file.write(targ + '.emitter.setAngle(%.4f)\\n' % self.emitter.getAngle())\n    elif self.emitterType == 'SphereSurfaceEmitter':\n        file.write('# Sphere Surface parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n    elif self.emitterType == 'SphereVolumeEmitter':\n        file.write('# Sphere Volume parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n    elif self.emitterType == 'TangentRingEmitter':\n        file.write('# Tangent Ring parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        file.write(targ + '.emitter.setRadiusSpread(%.4f)\\n' % self.emitter.getRadiusSpread())",
        "mutated": [
            "def printParams(self, file=sys.stdout, targ='self'):\n    if False:\n        i = 10\n    file.write('# Particles parameters\\n')\n    file.write(targ + '.setFactory(\"' + self.factoryType + '\")\\n')\n    file.write(targ + '.setRenderer(\"' + self.rendererType + '\")\\n')\n    file.write(targ + '.setEmitter(\"' + self.emitterType + '\")\\n')\n    file.write(targ + '.setPoolSize(%d)\\n' % int(self.getPoolSize()))\n    file.write(targ + '.setBirthRate(%.4f)\\n' % self.getBirthRate())\n    file.write(targ + '.setLitterSize(%d)\\n' % int(self.getLitterSize()))\n    file.write(targ + '.setLitterSpread(%d)\\n' % self.getLitterSpread())\n    file.write(targ + '.setSystemLifespan(%.4f)\\n' % self.getSystemLifespan())\n    file.write(targ + '.setLocalVelocityFlag(%d)\\n' % self.getLocalVelocityFlag())\n    file.write(targ + '.setSystemGrowsOlderFlag(%d)\\n' % self.getSystemGrowsOlderFlag())\n    file.write('# Factory parameters\\n')\n    file.write(targ + '.factory.setLifespanBase(%.4f)\\n' % self.factory.getLifespanBase())\n    file.write(targ + '.factory.setLifespanSpread(%.4f)\\n' % self.factory.getLifespanSpread())\n    file.write(targ + '.factory.setMassBase(%.4f)\\n' % self.factory.getMassBase())\n    file.write(targ + '.factory.setMassSpread(%.4f)\\n' % self.factory.getMassSpread())\n    file.write(targ + '.factory.setTerminalVelocityBase(%.4f)\\n' % self.factory.getTerminalVelocityBase())\n    file.write(targ + '.factory.setTerminalVelocitySpread(%.4f)\\n' % self.factory.getTerminalVelocitySpread())\n    if self.factoryType == 'PointParticleFactory':\n        file.write('# Point factory parameters\\n')\n    elif self.factoryType == 'ZSpinParticleFactory':\n        file.write('# Z Spin factory parameters\\n')\n        file.write(targ + '.factory.setInitialAngle(%.4f)\\n' % self.factory.getInitialAngle())\n        file.write(targ + '.factory.setInitialAngleSpread(%.4f)\\n' % self.factory.getInitialAngleSpread())\n        file.write(targ + '.factory.enableAngularVelocity(%d)\\n' % self.factory.getAngularVelocityEnabled())\n        if self.factory.getAngularVelocityEnabled():\n            file.write(targ + '.factory.setAngularVelocity(%.4f)\\n' % self.factory.getAngularVelocity())\n            file.write(targ + '.factory.setAngularVelocitySpread(%.4f)\\n' % self.factory.getAngularVelocitySpread())\n        else:\n            file.write(targ + '.factory.setFinalAngle(%.4f)\\n' % self.factory.getFinalAngle())\n            file.write(targ + '.factory.setFinalAngleSpread(%.4f)\\n' % self.factory.getFinalAngleSpread())\n    elif self.factoryType == 'OrientedParticleFactory':\n        file.write('# Oriented factory parameters\\n')\n        file.write(targ + '.factory.setInitialOrientation(%.4f)\\n' % self.factory.getInitialOrientation())\n        file.write(targ + '.factory.setFinalOrientation(%.4f)\\n' % self.factory.getFinalOrientation())\n    file.write('# Renderer parameters\\n')\n    alphaMode = self.renderer.getAlphaMode()\n    aMode = 'PRALPHANONE'\n    if alphaMode == BaseParticleRenderer.PRALPHANONE:\n        aMode = 'PRALPHANONE'\n    elif alphaMode == BaseParticleRenderer.PRALPHAOUT:\n        aMode = 'PRALPHAOUT'\n    elif alphaMode == BaseParticleRenderer.PRALPHAIN:\n        aMode = 'PRALPHAIN'\n    elif alphaMode == BaseParticleRenderer.PRALPHAINOUT:\n        aMode = 'PRALPHAINOUT'\n    elif alphaMode == BaseParticleRenderer.PRALPHAUSER:\n        aMode = 'PRALPHAUSER'\n    file.write(targ + '.renderer.setAlphaMode(BaseParticleRenderer.' + aMode + ')\\n')\n    file.write(targ + '.renderer.setUserAlpha(%.2f)\\n' % self.renderer.getUserAlpha())\n    if self.rendererType == 'PointParticleRenderer':\n        file.write('# Point parameters\\n')\n        file.write(targ + '.renderer.setPointSize(%.2f)\\n' % self.renderer.getPointSize())\n        sColor = self.renderer.getStartColor()\n        file.write(targ + '.renderer.setStartColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getEndColor()\n        file.write(targ + '.renderer.setEndColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        blendType = self.renderer.getBlendType()\n        bType = 'PPONECOLOR'\n        if blendType == PointParticleRenderer.PPONECOLOR:\n            bType = 'PPONECOLOR'\n        elif blendType == PointParticleRenderer.PPBLENDLIFE:\n            bType = 'PPBLENDLIFE'\n        elif blendType == PointParticleRenderer.PPBLENDVEL:\n            bType = 'PPBLENDVEL'\n        file.write(targ + '.renderer.setBlendType(PointParticleRenderer.' + bType + ')\\n')\n        blendMethod = self.renderer.getBlendMethod()\n        bMethod = 'PPNOBLEND'\n        if blendMethod == BaseParticleRenderer.PPNOBLEND:\n            bMethod = 'PPNOBLEND'\n        elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n            bMethod = 'PPBLENDLINEAR'\n        elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n            bMethod = 'PPBLENDCUBIC'\n        file.write(targ + '.renderer.setBlendMethod(BaseParticleRenderer.' + bMethod + ')\\n')\n    elif self.rendererType == 'LineParticleRenderer':\n        file.write('# Line parameters\\n')\n        sColor = self.renderer.getHeadColor()\n        file.write(targ + '.renderer.setHeadColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getTailColor()\n        file.write(targ + '.renderer.setTailColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sf = self.renderer.getLineScaleFactor()\n        file.write(targ + '.renderer.setLineScaleFactor(%.2f)\\n' % sf)\n    elif self.rendererType == 'GeomParticleRenderer':\n        file.write('# Geom parameters\\n')\n        node = self.renderer.getGeomNode()\n        file.write('geomRef = loader.loadModel(\"' + self.geomReference + '\")\\n')\n        file.write(targ + '.renderer.setGeomNode(geomRef.node())\\n')\n        file.write(targ + '.geomReference = \"' + self.geomReference + '\"\\n')\n        cbmLut = ('MNone', 'MAdd', 'MSubtract', 'MInvSubtract', 'MMin', 'MMax')\n        cboLut = ('OZero', 'OOne', 'OIncomingColor', 'OOneMinusIncomingColor', 'OFbufferColor', 'OOneMinusFbufferColor', 'OIncomingAlpha', 'OOneMinusIncomingAlpha', 'OFbufferAlpha', 'OOneMinusFbufferAlpha', 'OConstantColor', 'OOneMinusConstantColor', 'OConstantAlpha', 'OOneMinusConstantAlpha', 'OIncomingColorSaturate')\n        file.write(targ + '.renderer.setXScaleFlag(%d)\\n' % self.renderer.getXScaleFlag())\n        file.write(targ + '.renderer.setYScaleFlag(%d)\\n' % self.renderer.getYScaleFlag())\n        file.write(targ + '.renderer.setZScaleFlag(%d)\\n' % self.renderer.getZScaleFlag())\n        file.write(targ + '.renderer.setInitialXScale(%.4f)\\n' % self.renderer.getInitialXScale())\n        file.write(targ + '.renderer.setFinalXScale(%.4f)\\n' % self.renderer.getFinalXScale())\n        file.write(targ + '.renderer.setInitialYScale(%.4f)\\n' % self.renderer.getInitialYScale())\n        file.write(targ + '.renderer.setFinalYScale(%.4f)\\n' % self.renderer.getFinalYScale())\n        file.write(targ + '.renderer.setInitialZScale(%.4f)\\n' % self.renderer.getInitialZScale())\n        file.write(targ + '.renderer.setFinalZScale(%.4f)\\n' % self.renderer.getFinalZScale())\n        cbAttrib = self.renderer.getRenderNode().getAttrib(ColorBlendAttrib.getClassType())\n        if cbAttrib:\n            cbMode = cbAttrib.getMode()\n            if cbMode > 0:\n                if cbMode in (ColorBlendAttrib.MAdd, ColorBlendAttrib.MSubtract, ColorBlendAttrib.MInvSubtract):\n                    cboa = cbAttrib.getOperandA()\n                    cbob = cbAttrib.getOperandB()\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s, ColorBlendAttrib.%s, ColorBlendAttrib.%s)\\n' % (cbmLut[cbMode], cboLut[cboa], cboLut[cbob]))\n                else:\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s)\\n' % cbmLut[cbMode])\n        cim = self.renderer.getColorInterpolationManager()\n        segIdList = [int(seg) for seg in cim.getSegmentIdList().split()]\n        for sid in segIdList:\n            seg = cim.getSegment(sid)\n            if seg.isEnabled():\n                t_b = seg.getTimeBegin()\n                t_e = seg.getTimeEnd()\n                mod = seg.isModulated()\n                fun = seg.getFunction()\n                typ = type(fun).__name__\n                if typ == 'ColorInterpolationFunctionConstant':\n                    c_a = fun.getColorA()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addConstant(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionLinear':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addLinear(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionStepwave':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    w_a = fun.getWidthA()\n                    w_b = fun.getWidthB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addStepwave(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(w_a) + ',' + repr(w_b) + ',' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionSinusoid':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    per = fun.getPeriod()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addSinusoid(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(per) + ',' + repr(mod) + ')\\n')\n    elif self.rendererType == 'SparkleParticleRenderer':\n        file.write('# Sparkle parameters\\n')\n        sColor = self.renderer.getCenterColor()\n        file.write(targ + '.renderer.setCenterColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getEdgeColor()\n        file.write(targ + '.renderer.setEdgeColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        file.write(targ + '.renderer.setBirthRadius(%.4f)\\n' % self.renderer.getBirthRadius())\n        file.write(targ + '.renderer.setDeathRadius(%.4f)\\n' % self.renderer.getDeathRadius())\n        lifeScale = self.renderer.getLifeScale()\n        lScale = 'SPNOSCALE'\n        if lifeScale == SparkleParticleRenderer.SPSCALE:\n            lScale = 'SPSCALE'\n        file.write(targ + '.renderer.setLifeScale(SparkleParticleRenderer.' + lScale + ')\\n')\n    elif self.rendererType == 'SpriteParticleRenderer':\n        file.write('# Sprite parameters\\n')\n        if self.renderer.getAnimateFramesEnable():\n            file.write(targ + '.renderer.setAnimateFramesEnable(True)\\n')\n            rate = self.renderer.getAnimateFramesRate()\n            if rate:\n                file.write(targ + '.renderer.setAnimateFramesRate(%.3f)\\n' % rate)\n        animCount = self.renderer.getNumAnims()\n        for x in range(animCount):\n            anim = self.renderer.getAnim(x)\n            if anim.getSourceType() == SpriteAnim.STTexture:\n                file.write(targ + \".renderer.addTextureFromFile('%s')\\n\" % (anim.getTexSource(),))\n            else:\n                file.write(targ + \".renderer.addTextureFromNode('%s','%s')\\n\" % (anim.getModelSource(), anim.getNodeSource()))\n        sColor = self.renderer.getColor()\n        file.write(targ + '.renderer.setColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        file.write(targ + '.renderer.setXScaleFlag(%d)\\n' % self.renderer.getXScaleFlag())\n        file.write(targ + '.renderer.setYScaleFlag(%d)\\n' % self.renderer.getYScaleFlag())\n        file.write(targ + '.renderer.setAnimAngleFlag(%d)\\n' % self.renderer.getAnimAngleFlag())\n        file.write(targ + '.renderer.setInitialXScale(%.4f)\\n' % self.renderer.getInitialXScale())\n        file.write(targ + '.renderer.setFinalXScale(%.4f)\\n' % self.renderer.getFinalXScale())\n        file.write(targ + '.renderer.setInitialYScale(%.4f)\\n' % self.renderer.getInitialYScale())\n        file.write(targ + '.renderer.setFinalYScale(%.4f)\\n' % self.renderer.getFinalYScale())\n        file.write(targ + '.renderer.setNonanimatedTheta(%.4f)\\n' % self.renderer.getNonanimatedTheta())\n        blendMethod = self.renderer.getAlphaBlendMethod()\n        bMethod = 'PPNOBLEND'\n        if blendMethod == BaseParticleRenderer.PPNOBLEND:\n            bMethod = 'PPNOBLEND'\n        elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n            bMethod = 'PPBLENDLINEAR'\n        elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n            bMethod = 'PPBLENDCUBIC'\n        file.write(targ + '.renderer.setAlphaBlendMethod(BaseParticleRenderer.' + bMethod + ')\\n')\n        file.write(targ + '.renderer.setAlphaDisable(%d)\\n' % self.renderer.getAlphaDisable())\n        cbmLut = ('MNone', 'MAdd', 'MSubtract', 'MInvSubtract', 'MMin', 'MMax')\n        cboLut = ('OZero', 'OOne', 'OIncomingColor', 'OOneMinusIncomingColor', 'OFbufferColor', 'OOneMinusFbufferColor', 'OIncomingAlpha', 'OOneMinusIncomingAlpha', 'OFbufferAlpha', 'OOneMinusFbufferAlpha', 'OConstantColor', 'OOneMinusConstantColor', 'OConstantAlpha', 'OOneMinusConstantAlpha', 'OIncomingColorSaturate')\n        cbAttrib = self.renderer.getRenderNode().getAttrib(ColorBlendAttrib.getClassType())\n        if cbAttrib:\n            cbMode = cbAttrib.getMode()\n            if cbMode > 0:\n                if cbMode in (ColorBlendAttrib.MAdd, ColorBlendAttrib.MSubtract, ColorBlendAttrib.MInvSubtract):\n                    cboa = cbAttrib.getOperandA()\n                    cbob = cbAttrib.getOperandB()\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s, ColorBlendAttrib.%s, ColorBlendAttrib.%s)\\n' % (cbmLut[cbMode], cboLut[cboa], cboLut[cbob]))\n                else:\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s)\\n' % cbmLut[cbMode])\n        cim = self.renderer.getColorInterpolationManager()\n        segIdList = [int(seg) for seg in cim.getSegmentIdList().split()]\n        for sid in segIdList:\n            seg = cim.getSegment(sid)\n            if seg.isEnabled():\n                t_b = seg.getTimeBegin()\n                t_e = seg.getTimeEnd()\n                mod = seg.isModulated()\n                fun = seg.getFunction()\n                typ = type(fun).__name__\n                if typ == 'ColorInterpolationFunctionConstant':\n                    c_a = fun.getColorA()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addConstant(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionLinear':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addLinear(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionStepwave':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    w_a = fun.getWidthA()\n                    w_b = fun.getWidthB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addStepwave(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(w_a) + ',' + repr(w_b) + ',' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionSinusoid':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    per = fun.getPeriod()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addSinusoid(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(per) + ',' + repr(mod) + ')\\n')\n    file.write('# Emitter parameters\\n')\n    emissionType = self.emitter.getEmissionType()\n    eType = 'ETEXPLICIT'\n    if emissionType == BaseParticleEmitter.ETEXPLICIT:\n        eType = 'ETEXPLICIT'\n    elif emissionType == BaseParticleEmitter.ETRADIATE:\n        eType = 'ETRADIATE'\n    elif emissionType == BaseParticleEmitter.ETCUSTOM:\n        eType = 'ETCUSTOM'\n    file.write(targ + '.emitter.setEmissionType(BaseParticleEmitter.' + eType + ')\\n')\n    file.write(targ + '.emitter.setAmplitude(%.4f)\\n' % self.emitter.getAmplitude())\n    file.write(targ + '.emitter.setAmplitudeSpread(%.4f)\\n' % self.emitter.getAmplitudeSpread())\n    oForce = self.emitter.getOffsetForce()\n    file.write(targ + '.emitter.setOffsetForce(Vec3(%.4f, %.4f, %.4f))\\n' % (oForce[0], oForce[1], oForce[2]))\n    oForce = self.emitter.getExplicitLaunchVector()\n    file.write(targ + '.emitter.setExplicitLaunchVector(Vec3(%.4f, %.4f, %.4f))\\n' % (oForce[0], oForce[1], oForce[2]))\n    orig = self.emitter.getRadiateOrigin()\n    file.write(targ + '.emitter.setRadiateOrigin(Point3(%.4f, %.4f, %.4f))\\n' % (orig[0], orig[1], orig[2]))\n    if self.emitterType == 'BoxEmitter':\n        file.write('# Box parameters\\n')\n        bound = self.emitter.getMinBound()\n        file.write(targ + '.emitter.setMinBound(Point3(%.4f, %.4f, %.4f))\\n' % (bound[0], bound[1], bound[2]))\n        bound = self.emitter.getMaxBound()\n        file.write(targ + '.emitter.setMaxBound(Point3(%.4f, %.4f, %.4f))\\n' % (bound[0], bound[1], bound[2]))\n    elif self.emitterType == 'DiscEmitter':\n        file.write('# Disc parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        if eType == 'ETCUSTOM':\n            file.write(targ + '.emitter.setOuterAngle(%.4f)\\n' % self.emitter.getOuterAngle())\n            file.write(targ + '.emitter.setInnerAngle(%.4f)\\n' % self.emitter.getInnerAngle())\n            file.write(targ + '.emitter.setOuterMagnitude(%.4f)\\n' % self.emitter.getOuterMagnitude())\n            file.write(targ + '.emitter.setInnerMagnitude(%.4f)\\n' % self.emitter.getInnerMagnitude())\n            file.write(targ + '.emitter.setCubicLerping(%d)\\n' % self.emitter.getCubicLerping())\n    elif self.emitterType == 'LineEmitter':\n        file.write('# Line parameters\\n')\n        point = self.emitter.getEndpoint1()\n        file.write(targ + '.emitter.setEndpoint1(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n        point = self.emitter.getEndpoint2()\n        file.write(targ + '.emitter.setEndpoint2(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n    elif self.emitterType == 'PointEmitter':\n        file.write('# Point parameters\\n')\n        point = self.emitter.getLocation()\n        file.write(targ + '.emitter.setLocation(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n    elif self.emitterType == 'RectangleEmitter':\n        file.write('# Rectangle parameters\\n')\n        point = self.emitter.getMinBound()\n        file.write(targ + '.emitter.setMinBound(Point2(%.4f, %.4f))\\n' % (point[0], point[1]))\n        point = self.emitter.getMaxBound()\n        file.write(targ + '.emitter.setMaxBound(Point2(%.4f, %.4f))\\n' % (point[0], point[1]))\n    elif self.emitterType == 'RingEmitter':\n        file.write('# Ring parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        file.write(targ + '.emitter.setRadiusSpread(%.4f)\\n' % self.emitter.getRadiusSpread())\n        if eType == 'ETCUSTOM':\n            file.write(targ + '.emitter.setAngle(%.4f)\\n' % self.emitter.getAngle())\n    elif self.emitterType == 'SphereSurfaceEmitter':\n        file.write('# Sphere Surface parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n    elif self.emitterType == 'SphereVolumeEmitter':\n        file.write('# Sphere Volume parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n    elif self.emitterType == 'TangentRingEmitter':\n        file.write('# Tangent Ring parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        file.write(targ + '.emitter.setRadiusSpread(%.4f)\\n' % self.emitter.getRadiusSpread())",
            "def printParams(self, file=sys.stdout, targ='self'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    file.write('# Particles parameters\\n')\n    file.write(targ + '.setFactory(\"' + self.factoryType + '\")\\n')\n    file.write(targ + '.setRenderer(\"' + self.rendererType + '\")\\n')\n    file.write(targ + '.setEmitter(\"' + self.emitterType + '\")\\n')\n    file.write(targ + '.setPoolSize(%d)\\n' % int(self.getPoolSize()))\n    file.write(targ + '.setBirthRate(%.4f)\\n' % self.getBirthRate())\n    file.write(targ + '.setLitterSize(%d)\\n' % int(self.getLitterSize()))\n    file.write(targ + '.setLitterSpread(%d)\\n' % self.getLitterSpread())\n    file.write(targ + '.setSystemLifespan(%.4f)\\n' % self.getSystemLifespan())\n    file.write(targ + '.setLocalVelocityFlag(%d)\\n' % self.getLocalVelocityFlag())\n    file.write(targ + '.setSystemGrowsOlderFlag(%d)\\n' % self.getSystemGrowsOlderFlag())\n    file.write('# Factory parameters\\n')\n    file.write(targ + '.factory.setLifespanBase(%.4f)\\n' % self.factory.getLifespanBase())\n    file.write(targ + '.factory.setLifespanSpread(%.4f)\\n' % self.factory.getLifespanSpread())\n    file.write(targ + '.factory.setMassBase(%.4f)\\n' % self.factory.getMassBase())\n    file.write(targ + '.factory.setMassSpread(%.4f)\\n' % self.factory.getMassSpread())\n    file.write(targ + '.factory.setTerminalVelocityBase(%.4f)\\n' % self.factory.getTerminalVelocityBase())\n    file.write(targ + '.factory.setTerminalVelocitySpread(%.4f)\\n' % self.factory.getTerminalVelocitySpread())\n    if self.factoryType == 'PointParticleFactory':\n        file.write('# Point factory parameters\\n')\n    elif self.factoryType == 'ZSpinParticleFactory':\n        file.write('# Z Spin factory parameters\\n')\n        file.write(targ + '.factory.setInitialAngle(%.4f)\\n' % self.factory.getInitialAngle())\n        file.write(targ + '.factory.setInitialAngleSpread(%.4f)\\n' % self.factory.getInitialAngleSpread())\n        file.write(targ + '.factory.enableAngularVelocity(%d)\\n' % self.factory.getAngularVelocityEnabled())\n        if self.factory.getAngularVelocityEnabled():\n            file.write(targ + '.factory.setAngularVelocity(%.4f)\\n' % self.factory.getAngularVelocity())\n            file.write(targ + '.factory.setAngularVelocitySpread(%.4f)\\n' % self.factory.getAngularVelocitySpread())\n        else:\n            file.write(targ + '.factory.setFinalAngle(%.4f)\\n' % self.factory.getFinalAngle())\n            file.write(targ + '.factory.setFinalAngleSpread(%.4f)\\n' % self.factory.getFinalAngleSpread())\n    elif self.factoryType == 'OrientedParticleFactory':\n        file.write('# Oriented factory parameters\\n')\n        file.write(targ + '.factory.setInitialOrientation(%.4f)\\n' % self.factory.getInitialOrientation())\n        file.write(targ + '.factory.setFinalOrientation(%.4f)\\n' % self.factory.getFinalOrientation())\n    file.write('# Renderer parameters\\n')\n    alphaMode = self.renderer.getAlphaMode()\n    aMode = 'PRALPHANONE'\n    if alphaMode == BaseParticleRenderer.PRALPHANONE:\n        aMode = 'PRALPHANONE'\n    elif alphaMode == BaseParticleRenderer.PRALPHAOUT:\n        aMode = 'PRALPHAOUT'\n    elif alphaMode == BaseParticleRenderer.PRALPHAIN:\n        aMode = 'PRALPHAIN'\n    elif alphaMode == BaseParticleRenderer.PRALPHAINOUT:\n        aMode = 'PRALPHAINOUT'\n    elif alphaMode == BaseParticleRenderer.PRALPHAUSER:\n        aMode = 'PRALPHAUSER'\n    file.write(targ + '.renderer.setAlphaMode(BaseParticleRenderer.' + aMode + ')\\n')\n    file.write(targ + '.renderer.setUserAlpha(%.2f)\\n' % self.renderer.getUserAlpha())\n    if self.rendererType == 'PointParticleRenderer':\n        file.write('# Point parameters\\n')\n        file.write(targ + '.renderer.setPointSize(%.2f)\\n' % self.renderer.getPointSize())\n        sColor = self.renderer.getStartColor()\n        file.write(targ + '.renderer.setStartColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getEndColor()\n        file.write(targ + '.renderer.setEndColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        blendType = self.renderer.getBlendType()\n        bType = 'PPONECOLOR'\n        if blendType == PointParticleRenderer.PPONECOLOR:\n            bType = 'PPONECOLOR'\n        elif blendType == PointParticleRenderer.PPBLENDLIFE:\n            bType = 'PPBLENDLIFE'\n        elif blendType == PointParticleRenderer.PPBLENDVEL:\n            bType = 'PPBLENDVEL'\n        file.write(targ + '.renderer.setBlendType(PointParticleRenderer.' + bType + ')\\n')\n        blendMethod = self.renderer.getBlendMethod()\n        bMethod = 'PPNOBLEND'\n        if blendMethod == BaseParticleRenderer.PPNOBLEND:\n            bMethod = 'PPNOBLEND'\n        elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n            bMethod = 'PPBLENDLINEAR'\n        elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n            bMethod = 'PPBLENDCUBIC'\n        file.write(targ + '.renderer.setBlendMethod(BaseParticleRenderer.' + bMethod + ')\\n')\n    elif self.rendererType == 'LineParticleRenderer':\n        file.write('# Line parameters\\n')\n        sColor = self.renderer.getHeadColor()\n        file.write(targ + '.renderer.setHeadColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getTailColor()\n        file.write(targ + '.renderer.setTailColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sf = self.renderer.getLineScaleFactor()\n        file.write(targ + '.renderer.setLineScaleFactor(%.2f)\\n' % sf)\n    elif self.rendererType == 'GeomParticleRenderer':\n        file.write('# Geom parameters\\n')\n        node = self.renderer.getGeomNode()\n        file.write('geomRef = loader.loadModel(\"' + self.geomReference + '\")\\n')\n        file.write(targ + '.renderer.setGeomNode(geomRef.node())\\n')\n        file.write(targ + '.geomReference = \"' + self.geomReference + '\"\\n')\n        cbmLut = ('MNone', 'MAdd', 'MSubtract', 'MInvSubtract', 'MMin', 'MMax')\n        cboLut = ('OZero', 'OOne', 'OIncomingColor', 'OOneMinusIncomingColor', 'OFbufferColor', 'OOneMinusFbufferColor', 'OIncomingAlpha', 'OOneMinusIncomingAlpha', 'OFbufferAlpha', 'OOneMinusFbufferAlpha', 'OConstantColor', 'OOneMinusConstantColor', 'OConstantAlpha', 'OOneMinusConstantAlpha', 'OIncomingColorSaturate')\n        file.write(targ + '.renderer.setXScaleFlag(%d)\\n' % self.renderer.getXScaleFlag())\n        file.write(targ + '.renderer.setYScaleFlag(%d)\\n' % self.renderer.getYScaleFlag())\n        file.write(targ + '.renderer.setZScaleFlag(%d)\\n' % self.renderer.getZScaleFlag())\n        file.write(targ + '.renderer.setInitialXScale(%.4f)\\n' % self.renderer.getInitialXScale())\n        file.write(targ + '.renderer.setFinalXScale(%.4f)\\n' % self.renderer.getFinalXScale())\n        file.write(targ + '.renderer.setInitialYScale(%.4f)\\n' % self.renderer.getInitialYScale())\n        file.write(targ + '.renderer.setFinalYScale(%.4f)\\n' % self.renderer.getFinalYScale())\n        file.write(targ + '.renderer.setInitialZScale(%.4f)\\n' % self.renderer.getInitialZScale())\n        file.write(targ + '.renderer.setFinalZScale(%.4f)\\n' % self.renderer.getFinalZScale())\n        cbAttrib = self.renderer.getRenderNode().getAttrib(ColorBlendAttrib.getClassType())\n        if cbAttrib:\n            cbMode = cbAttrib.getMode()\n            if cbMode > 0:\n                if cbMode in (ColorBlendAttrib.MAdd, ColorBlendAttrib.MSubtract, ColorBlendAttrib.MInvSubtract):\n                    cboa = cbAttrib.getOperandA()\n                    cbob = cbAttrib.getOperandB()\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s, ColorBlendAttrib.%s, ColorBlendAttrib.%s)\\n' % (cbmLut[cbMode], cboLut[cboa], cboLut[cbob]))\n                else:\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s)\\n' % cbmLut[cbMode])\n        cim = self.renderer.getColorInterpolationManager()\n        segIdList = [int(seg) for seg in cim.getSegmentIdList().split()]\n        for sid in segIdList:\n            seg = cim.getSegment(sid)\n            if seg.isEnabled():\n                t_b = seg.getTimeBegin()\n                t_e = seg.getTimeEnd()\n                mod = seg.isModulated()\n                fun = seg.getFunction()\n                typ = type(fun).__name__\n                if typ == 'ColorInterpolationFunctionConstant':\n                    c_a = fun.getColorA()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addConstant(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionLinear':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addLinear(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionStepwave':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    w_a = fun.getWidthA()\n                    w_b = fun.getWidthB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addStepwave(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(w_a) + ',' + repr(w_b) + ',' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionSinusoid':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    per = fun.getPeriod()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addSinusoid(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(per) + ',' + repr(mod) + ')\\n')\n    elif self.rendererType == 'SparkleParticleRenderer':\n        file.write('# Sparkle parameters\\n')\n        sColor = self.renderer.getCenterColor()\n        file.write(targ + '.renderer.setCenterColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getEdgeColor()\n        file.write(targ + '.renderer.setEdgeColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        file.write(targ + '.renderer.setBirthRadius(%.4f)\\n' % self.renderer.getBirthRadius())\n        file.write(targ + '.renderer.setDeathRadius(%.4f)\\n' % self.renderer.getDeathRadius())\n        lifeScale = self.renderer.getLifeScale()\n        lScale = 'SPNOSCALE'\n        if lifeScale == SparkleParticleRenderer.SPSCALE:\n            lScale = 'SPSCALE'\n        file.write(targ + '.renderer.setLifeScale(SparkleParticleRenderer.' + lScale + ')\\n')\n    elif self.rendererType == 'SpriteParticleRenderer':\n        file.write('# Sprite parameters\\n')\n        if self.renderer.getAnimateFramesEnable():\n            file.write(targ + '.renderer.setAnimateFramesEnable(True)\\n')\n            rate = self.renderer.getAnimateFramesRate()\n            if rate:\n                file.write(targ + '.renderer.setAnimateFramesRate(%.3f)\\n' % rate)\n        animCount = self.renderer.getNumAnims()\n        for x in range(animCount):\n            anim = self.renderer.getAnim(x)\n            if anim.getSourceType() == SpriteAnim.STTexture:\n                file.write(targ + \".renderer.addTextureFromFile('%s')\\n\" % (anim.getTexSource(),))\n            else:\n                file.write(targ + \".renderer.addTextureFromNode('%s','%s')\\n\" % (anim.getModelSource(), anim.getNodeSource()))\n        sColor = self.renderer.getColor()\n        file.write(targ + '.renderer.setColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        file.write(targ + '.renderer.setXScaleFlag(%d)\\n' % self.renderer.getXScaleFlag())\n        file.write(targ + '.renderer.setYScaleFlag(%d)\\n' % self.renderer.getYScaleFlag())\n        file.write(targ + '.renderer.setAnimAngleFlag(%d)\\n' % self.renderer.getAnimAngleFlag())\n        file.write(targ + '.renderer.setInitialXScale(%.4f)\\n' % self.renderer.getInitialXScale())\n        file.write(targ + '.renderer.setFinalXScale(%.4f)\\n' % self.renderer.getFinalXScale())\n        file.write(targ + '.renderer.setInitialYScale(%.4f)\\n' % self.renderer.getInitialYScale())\n        file.write(targ + '.renderer.setFinalYScale(%.4f)\\n' % self.renderer.getFinalYScale())\n        file.write(targ + '.renderer.setNonanimatedTheta(%.4f)\\n' % self.renderer.getNonanimatedTheta())\n        blendMethod = self.renderer.getAlphaBlendMethod()\n        bMethod = 'PPNOBLEND'\n        if blendMethod == BaseParticleRenderer.PPNOBLEND:\n            bMethod = 'PPNOBLEND'\n        elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n            bMethod = 'PPBLENDLINEAR'\n        elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n            bMethod = 'PPBLENDCUBIC'\n        file.write(targ + '.renderer.setAlphaBlendMethod(BaseParticleRenderer.' + bMethod + ')\\n')\n        file.write(targ + '.renderer.setAlphaDisable(%d)\\n' % self.renderer.getAlphaDisable())\n        cbmLut = ('MNone', 'MAdd', 'MSubtract', 'MInvSubtract', 'MMin', 'MMax')\n        cboLut = ('OZero', 'OOne', 'OIncomingColor', 'OOneMinusIncomingColor', 'OFbufferColor', 'OOneMinusFbufferColor', 'OIncomingAlpha', 'OOneMinusIncomingAlpha', 'OFbufferAlpha', 'OOneMinusFbufferAlpha', 'OConstantColor', 'OOneMinusConstantColor', 'OConstantAlpha', 'OOneMinusConstantAlpha', 'OIncomingColorSaturate')\n        cbAttrib = self.renderer.getRenderNode().getAttrib(ColorBlendAttrib.getClassType())\n        if cbAttrib:\n            cbMode = cbAttrib.getMode()\n            if cbMode > 0:\n                if cbMode in (ColorBlendAttrib.MAdd, ColorBlendAttrib.MSubtract, ColorBlendAttrib.MInvSubtract):\n                    cboa = cbAttrib.getOperandA()\n                    cbob = cbAttrib.getOperandB()\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s, ColorBlendAttrib.%s, ColorBlendAttrib.%s)\\n' % (cbmLut[cbMode], cboLut[cboa], cboLut[cbob]))\n                else:\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s)\\n' % cbmLut[cbMode])\n        cim = self.renderer.getColorInterpolationManager()\n        segIdList = [int(seg) for seg in cim.getSegmentIdList().split()]\n        for sid in segIdList:\n            seg = cim.getSegment(sid)\n            if seg.isEnabled():\n                t_b = seg.getTimeBegin()\n                t_e = seg.getTimeEnd()\n                mod = seg.isModulated()\n                fun = seg.getFunction()\n                typ = type(fun).__name__\n                if typ == 'ColorInterpolationFunctionConstant':\n                    c_a = fun.getColorA()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addConstant(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionLinear':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addLinear(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionStepwave':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    w_a = fun.getWidthA()\n                    w_b = fun.getWidthB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addStepwave(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(w_a) + ',' + repr(w_b) + ',' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionSinusoid':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    per = fun.getPeriod()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addSinusoid(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(per) + ',' + repr(mod) + ')\\n')\n    file.write('# Emitter parameters\\n')\n    emissionType = self.emitter.getEmissionType()\n    eType = 'ETEXPLICIT'\n    if emissionType == BaseParticleEmitter.ETEXPLICIT:\n        eType = 'ETEXPLICIT'\n    elif emissionType == BaseParticleEmitter.ETRADIATE:\n        eType = 'ETRADIATE'\n    elif emissionType == BaseParticleEmitter.ETCUSTOM:\n        eType = 'ETCUSTOM'\n    file.write(targ + '.emitter.setEmissionType(BaseParticleEmitter.' + eType + ')\\n')\n    file.write(targ + '.emitter.setAmplitude(%.4f)\\n' % self.emitter.getAmplitude())\n    file.write(targ + '.emitter.setAmplitudeSpread(%.4f)\\n' % self.emitter.getAmplitudeSpread())\n    oForce = self.emitter.getOffsetForce()\n    file.write(targ + '.emitter.setOffsetForce(Vec3(%.4f, %.4f, %.4f))\\n' % (oForce[0], oForce[1], oForce[2]))\n    oForce = self.emitter.getExplicitLaunchVector()\n    file.write(targ + '.emitter.setExplicitLaunchVector(Vec3(%.4f, %.4f, %.4f))\\n' % (oForce[0], oForce[1], oForce[2]))\n    orig = self.emitter.getRadiateOrigin()\n    file.write(targ + '.emitter.setRadiateOrigin(Point3(%.4f, %.4f, %.4f))\\n' % (orig[0], orig[1], orig[2]))\n    if self.emitterType == 'BoxEmitter':\n        file.write('# Box parameters\\n')\n        bound = self.emitter.getMinBound()\n        file.write(targ + '.emitter.setMinBound(Point3(%.4f, %.4f, %.4f))\\n' % (bound[0], bound[1], bound[2]))\n        bound = self.emitter.getMaxBound()\n        file.write(targ + '.emitter.setMaxBound(Point3(%.4f, %.4f, %.4f))\\n' % (bound[0], bound[1], bound[2]))\n    elif self.emitterType == 'DiscEmitter':\n        file.write('# Disc parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        if eType == 'ETCUSTOM':\n            file.write(targ + '.emitter.setOuterAngle(%.4f)\\n' % self.emitter.getOuterAngle())\n            file.write(targ + '.emitter.setInnerAngle(%.4f)\\n' % self.emitter.getInnerAngle())\n            file.write(targ + '.emitter.setOuterMagnitude(%.4f)\\n' % self.emitter.getOuterMagnitude())\n            file.write(targ + '.emitter.setInnerMagnitude(%.4f)\\n' % self.emitter.getInnerMagnitude())\n            file.write(targ + '.emitter.setCubicLerping(%d)\\n' % self.emitter.getCubicLerping())\n    elif self.emitterType == 'LineEmitter':\n        file.write('# Line parameters\\n')\n        point = self.emitter.getEndpoint1()\n        file.write(targ + '.emitter.setEndpoint1(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n        point = self.emitter.getEndpoint2()\n        file.write(targ + '.emitter.setEndpoint2(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n    elif self.emitterType == 'PointEmitter':\n        file.write('# Point parameters\\n')\n        point = self.emitter.getLocation()\n        file.write(targ + '.emitter.setLocation(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n    elif self.emitterType == 'RectangleEmitter':\n        file.write('# Rectangle parameters\\n')\n        point = self.emitter.getMinBound()\n        file.write(targ + '.emitter.setMinBound(Point2(%.4f, %.4f))\\n' % (point[0], point[1]))\n        point = self.emitter.getMaxBound()\n        file.write(targ + '.emitter.setMaxBound(Point2(%.4f, %.4f))\\n' % (point[0], point[1]))\n    elif self.emitterType == 'RingEmitter':\n        file.write('# Ring parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        file.write(targ + '.emitter.setRadiusSpread(%.4f)\\n' % self.emitter.getRadiusSpread())\n        if eType == 'ETCUSTOM':\n            file.write(targ + '.emitter.setAngle(%.4f)\\n' % self.emitter.getAngle())\n    elif self.emitterType == 'SphereSurfaceEmitter':\n        file.write('# Sphere Surface parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n    elif self.emitterType == 'SphereVolumeEmitter':\n        file.write('# Sphere Volume parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n    elif self.emitterType == 'TangentRingEmitter':\n        file.write('# Tangent Ring parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        file.write(targ + '.emitter.setRadiusSpread(%.4f)\\n' % self.emitter.getRadiusSpread())",
            "def printParams(self, file=sys.stdout, targ='self'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    file.write('# Particles parameters\\n')\n    file.write(targ + '.setFactory(\"' + self.factoryType + '\")\\n')\n    file.write(targ + '.setRenderer(\"' + self.rendererType + '\")\\n')\n    file.write(targ + '.setEmitter(\"' + self.emitterType + '\")\\n')\n    file.write(targ + '.setPoolSize(%d)\\n' % int(self.getPoolSize()))\n    file.write(targ + '.setBirthRate(%.4f)\\n' % self.getBirthRate())\n    file.write(targ + '.setLitterSize(%d)\\n' % int(self.getLitterSize()))\n    file.write(targ + '.setLitterSpread(%d)\\n' % self.getLitterSpread())\n    file.write(targ + '.setSystemLifespan(%.4f)\\n' % self.getSystemLifespan())\n    file.write(targ + '.setLocalVelocityFlag(%d)\\n' % self.getLocalVelocityFlag())\n    file.write(targ + '.setSystemGrowsOlderFlag(%d)\\n' % self.getSystemGrowsOlderFlag())\n    file.write('# Factory parameters\\n')\n    file.write(targ + '.factory.setLifespanBase(%.4f)\\n' % self.factory.getLifespanBase())\n    file.write(targ + '.factory.setLifespanSpread(%.4f)\\n' % self.factory.getLifespanSpread())\n    file.write(targ + '.factory.setMassBase(%.4f)\\n' % self.factory.getMassBase())\n    file.write(targ + '.factory.setMassSpread(%.4f)\\n' % self.factory.getMassSpread())\n    file.write(targ + '.factory.setTerminalVelocityBase(%.4f)\\n' % self.factory.getTerminalVelocityBase())\n    file.write(targ + '.factory.setTerminalVelocitySpread(%.4f)\\n' % self.factory.getTerminalVelocitySpread())\n    if self.factoryType == 'PointParticleFactory':\n        file.write('# Point factory parameters\\n')\n    elif self.factoryType == 'ZSpinParticleFactory':\n        file.write('# Z Spin factory parameters\\n')\n        file.write(targ + '.factory.setInitialAngle(%.4f)\\n' % self.factory.getInitialAngle())\n        file.write(targ + '.factory.setInitialAngleSpread(%.4f)\\n' % self.factory.getInitialAngleSpread())\n        file.write(targ + '.factory.enableAngularVelocity(%d)\\n' % self.factory.getAngularVelocityEnabled())\n        if self.factory.getAngularVelocityEnabled():\n            file.write(targ + '.factory.setAngularVelocity(%.4f)\\n' % self.factory.getAngularVelocity())\n            file.write(targ + '.factory.setAngularVelocitySpread(%.4f)\\n' % self.factory.getAngularVelocitySpread())\n        else:\n            file.write(targ + '.factory.setFinalAngle(%.4f)\\n' % self.factory.getFinalAngle())\n            file.write(targ + '.factory.setFinalAngleSpread(%.4f)\\n' % self.factory.getFinalAngleSpread())\n    elif self.factoryType == 'OrientedParticleFactory':\n        file.write('# Oriented factory parameters\\n')\n        file.write(targ + '.factory.setInitialOrientation(%.4f)\\n' % self.factory.getInitialOrientation())\n        file.write(targ + '.factory.setFinalOrientation(%.4f)\\n' % self.factory.getFinalOrientation())\n    file.write('# Renderer parameters\\n')\n    alphaMode = self.renderer.getAlphaMode()\n    aMode = 'PRALPHANONE'\n    if alphaMode == BaseParticleRenderer.PRALPHANONE:\n        aMode = 'PRALPHANONE'\n    elif alphaMode == BaseParticleRenderer.PRALPHAOUT:\n        aMode = 'PRALPHAOUT'\n    elif alphaMode == BaseParticleRenderer.PRALPHAIN:\n        aMode = 'PRALPHAIN'\n    elif alphaMode == BaseParticleRenderer.PRALPHAINOUT:\n        aMode = 'PRALPHAINOUT'\n    elif alphaMode == BaseParticleRenderer.PRALPHAUSER:\n        aMode = 'PRALPHAUSER'\n    file.write(targ + '.renderer.setAlphaMode(BaseParticleRenderer.' + aMode + ')\\n')\n    file.write(targ + '.renderer.setUserAlpha(%.2f)\\n' % self.renderer.getUserAlpha())\n    if self.rendererType == 'PointParticleRenderer':\n        file.write('# Point parameters\\n')\n        file.write(targ + '.renderer.setPointSize(%.2f)\\n' % self.renderer.getPointSize())\n        sColor = self.renderer.getStartColor()\n        file.write(targ + '.renderer.setStartColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getEndColor()\n        file.write(targ + '.renderer.setEndColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        blendType = self.renderer.getBlendType()\n        bType = 'PPONECOLOR'\n        if blendType == PointParticleRenderer.PPONECOLOR:\n            bType = 'PPONECOLOR'\n        elif blendType == PointParticleRenderer.PPBLENDLIFE:\n            bType = 'PPBLENDLIFE'\n        elif blendType == PointParticleRenderer.PPBLENDVEL:\n            bType = 'PPBLENDVEL'\n        file.write(targ + '.renderer.setBlendType(PointParticleRenderer.' + bType + ')\\n')\n        blendMethod = self.renderer.getBlendMethod()\n        bMethod = 'PPNOBLEND'\n        if blendMethod == BaseParticleRenderer.PPNOBLEND:\n            bMethod = 'PPNOBLEND'\n        elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n            bMethod = 'PPBLENDLINEAR'\n        elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n            bMethod = 'PPBLENDCUBIC'\n        file.write(targ + '.renderer.setBlendMethod(BaseParticleRenderer.' + bMethod + ')\\n')\n    elif self.rendererType == 'LineParticleRenderer':\n        file.write('# Line parameters\\n')\n        sColor = self.renderer.getHeadColor()\n        file.write(targ + '.renderer.setHeadColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getTailColor()\n        file.write(targ + '.renderer.setTailColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sf = self.renderer.getLineScaleFactor()\n        file.write(targ + '.renderer.setLineScaleFactor(%.2f)\\n' % sf)\n    elif self.rendererType == 'GeomParticleRenderer':\n        file.write('# Geom parameters\\n')\n        node = self.renderer.getGeomNode()\n        file.write('geomRef = loader.loadModel(\"' + self.geomReference + '\")\\n')\n        file.write(targ + '.renderer.setGeomNode(geomRef.node())\\n')\n        file.write(targ + '.geomReference = \"' + self.geomReference + '\"\\n')\n        cbmLut = ('MNone', 'MAdd', 'MSubtract', 'MInvSubtract', 'MMin', 'MMax')\n        cboLut = ('OZero', 'OOne', 'OIncomingColor', 'OOneMinusIncomingColor', 'OFbufferColor', 'OOneMinusFbufferColor', 'OIncomingAlpha', 'OOneMinusIncomingAlpha', 'OFbufferAlpha', 'OOneMinusFbufferAlpha', 'OConstantColor', 'OOneMinusConstantColor', 'OConstantAlpha', 'OOneMinusConstantAlpha', 'OIncomingColorSaturate')\n        file.write(targ + '.renderer.setXScaleFlag(%d)\\n' % self.renderer.getXScaleFlag())\n        file.write(targ + '.renderer.setYScaleFlag(%d)\\n' % self.renderer.getYScaleFlag())\n        file.write(targ + '.renderer.setZScaleFlag(%d)\\n' % self.renderer.getZScaleFlag())\n        file.write(targ + '.renderer.setInitialXScale(%.4f)\\n' % self.renderer.getInitialXScale())\n        file.write(targ + '.renderer.setFinalXScale(%.4f)\\n' % self.renderer.getFinalXScale())\n        file.write(targ + '.renderer.setInitialYScale(%.4f)\\n' % self.renderer.getInitialYScale())\n        file.write(targ + '.renderer.setFinalYScale(%.4f)\\n' % self.renderer.getFinalYScale())\n        file.write(targ + '.renderer.setInitialZScale(%.4f)\\n' % self.renderer.getInitialZScale())\n        file.write(targ + '.renderer.setFinalZScale(%.4f)\\n' % self.renderer.getFinalZScale())\n        cbAttrib = self.renderer.getRenderNode().getAttrib(ColorBlendAttrib.getClassType())\n        if cbAttrib:\n            cbMode = cbAttrib.getMode()\n            if cbMode > 0:\n                if cbMode in (ColorBlendAttrib.MAdd, ColorBlendAttrib.MSubtract, ColorBlendAttrib.MInvSubtract):\n                    cboa = cbAttrib.getOperandA()\n                    cbob = cbAttrib.getOperandB()\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s, ColorBlendAttrib.%s, ColorBlendAttrib.%s)\\n' % (cbmLut[cbMode], cboLut[cboa], cboLut[cbob]))\n                else:\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s)\\n' % cbmLut[cbMode])\n        cim = self.renderer.getColorInterpolationManager()\n        segIdList = [int(seg) for seg in cim.getSegmentIdList().split()]\n        for sid in segIdList:\n            seg = cim.getSegment(sid)\n            if seg.isEnabled():\n                t_b = seg.getTimeBegin()\n                t_e = seg.getTimeEnd()\n                mod = seg.isModulated()\n                fun = seg.getFunction()\n                typ = type(fun).__name__\n                if typ == 'ColorInterpolationFunctionConstant':\n                    c_a = fun.getColorA()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addConstant(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionLinear':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addLinear(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionStepwave':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    w_a = fun.getWidthA()\n                    w_b = fun.getWidthB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addStepwave(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(w_a) + ',' + repr(w_b) + ',' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionSinusoid':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    per = fun.getPeriod()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addSinusoid(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(per) + ',' + repr(mod) + ')\\n')\n    elif self.rendererType == 'SparkleParticleRenderer':\n        file.write('# Sparkle parameters\\n')\n        sColor = self.renderer.getCenterColor()\n        file.write(targ + '.renderer.setCenterColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getEdgeColor()\n        file.write(targ + '.renderer.setEdgeColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        file.write(targ + '.renderer.setBirthRadius(%.4f)\\n' % self.renderer.getBirthRadius())\n        file.write(targ + '.renderer.setDeathRadius(%.4f)\\n' % self.renderer.getDeathRadius())\n        lifeScale = self.renderer.getLifeScale()\n        lScale = 'SPNOSCALE'\n        if lifeScale == SparkleParticleRenderer.SPSCALE:\n            lScale = 'SPSCALE'\n        file.write(targ + '.renderer.setLifeScale(SparkleParticleRenderer.' + lScale + ')\\n')\n    elif self.rendererType == 'SpriteParticleRenderer':\n        file.write('# Sprite parameters\\n')\n        if self.renderer.getAnimateFramesEnable():\n            file.write(targ + '.renderer.setAnimateFramesEnable(True)\\n')\n            rate = self.renderer.getAnimateFramesRate()\n            if rate:\n                file.write(targ + '.renderer.setAnimateFramesRate(%.3f)\\n' % rate)\n        animCount = self.renderer.getNumAnims()\n        for x in range(animCount):\n            anim = self.renderer.getAnim(x)\n            if anim.getSourceType() == SpriteAnim.STTexture:\n                file.write(targ + \".renderer.addTextureFromFile('%s')\\n\" % (anim.getTexSource(),))\n            else:\n                file.write(targ + \".renderer.addTextureFromNode('%s','%s')\\n\" % (anim.getModelSource(), anim.getNodeSource()))\n        sColor = self.renderer.getColor()\n        file.write(targ + '.renderer.setColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        file.write(targ + '.renderer.setXScaleFlag(%d)\\n' % self.renderer.getXScaleFlag())\n        file.write(targ + '.renderer.setYScaleFlag(%d)\\n' % self.renderer.getYScaleFlag())\n        file.write(targ + '.renderer.setAnimAngleFlag(%d)\\n' % self.renderer.getAnimAngleFlag())\n        file.write(targ + '.renderer.setInitialXScale(%.4f)\\n' % self.renderer.getInitialXScale())\n        file.write(targ + '.renderer.setFinalXScale(%.4f)\\n' % self.renderer.getFinalXScale())\n        file.write(targ + '.renderer.setInitialYScale(%.4f)\\n' % self.renderer.getInitialYScale())\n        file.write(targ + '.renderer.setFinalYScale(%.4f)\\n' % self.renderer.getFinalYScale())\n        file.write(targ + '.renderer.setNonanimatedTheta(%.4f)\\n' % self.renderer.getNonanimatedTheta())\n        blendMethod = self.renderer.getAlphaBlendMethod()\n        bMethod = 'PPNOBLEND'\n        if blendMethod == BaseParticleRenderer.PPNOBLEND:\n            bMethod = 'PPNOBLEND'\n        elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n            bMethod = 'PPBLENDLINEAR'\n        elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n            bMethod = 'PPBLENDCUBIC'\n        file.write(targ + '.renderer.setAlphaBlendMethod(BaseParticleRenderer.' + bMethod + ')\\n')\n        file.write(targ + '.renderer.setAlphaDisable(%d)\\n' % self.renderer.getAlphaDisable())\n        cbmLut = ('MNone', 'MAdd', 'MSubtract', 'MInvSubtract', 'MMin', 'MMax')\n        cboLut = ('OZero', 'OOne', 'OIncomingColor', 'OOneMinusIncomingColor', 'OFbufferColor', 'OOneMinusFbufferColor', 'OIncomingAlpha', 'OOneMinusIncomingAlpha', 'OFbufferAlpha', 'OOneMinusFbufferAlpha', 'OConstantColor', 'OOneMinusConstantColor', 'OConstantAlpha', 'OOneMinusConstantAlpha', 'OIncomingColorSaturate')\n        cbAttrib = self.renderer.getRenderNode().getAttrib(ColorBlendAttrib.getClassType())\n        if cbAttrib:\n            cbMode = cbAttrib.getMode()\n            if cbMode > 0:\n                if cbMode in (ColorBlendAttrib.MAdd, ColorBlendAttrib.MSubtract, ColorBlendAttrib.MInvSubtract):\n                    cboa = cbAttrib.getOperandA()\n                    cbob = cbAttrib.getOperandB()\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s, ColorBlendAttrib.%s, ColorBlendAttrib.%s)\\n' % (cbmLut[cbMode], cboLut[cboa], cboLut[cbob]))\n                else:\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s)\\n' % cbmLut[cbMode])\n        cim = self.renderer.getColorInterpolationManager()\n        segIdList = [int(seg) for seg in cim.getSegmentIdList().split()]\n        for sid in segIdList:\n            seg = cim.getSegment(sid)\n            if seg.isEnabled():\n                t_b = seg.getTimeBegin()\n                t_e = seg.getTimeEnd()\n                mod = seg.isModulated()\n                fun = seg.getFunction()\n                typ = type(fun).__name__\n                if typ == 'ColorInterpolationFunctionConstant':\n                    c_a = fun.getColorA()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addConstant(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionLinear':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addLinear(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionStepwave':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    w_a = fun.getWidthA()\n                    w_b = fun.getWidthB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addStepwave(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(w_a) + ',' + repr(w_b) + ',' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionSinusoid':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    per = fun.getPeriod()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addSinusoid(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(per) + ',' + repr(mod) + ')\\n')\n    file.write('# Emitter parameters\\n')\n    emissionType = self.emitter.getEmissionType()\n    eType = 'ETEXPLICIT'\n    if emissionType == BaseParticleEmitter.ETEXPLICIT:\n        eType = 'ETEXPLICIT'\n    elif emissionType == BaseParticleEmitter.ETRADIATE:\n        eType = 'ETRADIATE'\n    elif emissionType == BaseParticleEmitter.ETCUSTOM:\n        eType = 'ETCUSTOM'\n    file.write(targ + '.emitter.setEmissionType(BaseParticleEmitter.' + eType + ')\\n')\n    file.write(targ + '.emitter.setAmplitude(%.4f)\\n' % self.emitter.getAmplitude())\n    file.write(targ + '.emitter.setAmplitudeSpread(%.4f)\\n' % self.emitter.getAmplitudeSpread())\n    oForce = self.emitter.getOffsetForce()\n    file.write(targ + '.emitter.setOffsetForce(Vec3(%.4f, %.4f, %.4f))\\n' % (oForce[0], oForce[1], oForce[2]))\n    oForce = self.emitter.getExplicitLaunchVector()\n    file.write(targ + '.emitter.setExplicitLaunchVector(Vec3(%.4f, %.4f, %.4f))\\n' % (oForce[0], oForce[1], oForce[2]))\n    orig = self.emitter.getRadiateOrigin()\n    file.write(targ + '.emitter.setRadiateOrigin(Point3(%.4f, %.4f, %.4f))\\n' % (orig[0], orig[1], orig[2]))\n    if self.emitterType == 'BoxEmitter':\n        file.write('# Box parameters\\n')\n        bound = self.emitter.getMinBound()\n        file.write(targ + '.emitter.setMinBound(Point3(%.4f, %.4f, %.4f))\\n' % (bound[0], bound[1], bound[2]))\n        bound = self.emitter.getMaxBound()\n        file.write(targ + '.emitter.setMaxBound(Point3(%.4f, %.4f, %.4f))\\n' % (bound[0], bound[1], bound[2]))\n    elif self.emitterType == 'DiscEmitter':\n        file.write('# Disc parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        if eType == 'ETCUSTOM':\n            file.write(targ + '.emitter.setOuterAngle(%.4f)\\n' % self.emitter.getOuterAngle())\n            file.write(targ + '.emitter.setInnerAngle(%.4f)\\n' % self.emitter.getInnerAngle())\n            file.write(targ + '.emitter.setOuterMagnitude(%.4f)\\n' % self.emitter.getOuterMagnitude())\n            file.write(targ + '.emitter.setInnerMagnitude(%.4f)\\n' % self.emitter.getInnerMagnitude())\n            file.write(targ + '.emitter.setCubicLerping(%d)\\n' % self.emitter.getCubicLerping())\n    elif self.emitterType == 'LineEmitter':\n        file.write('# Line parameters\\n')\n        point = self.emitter.getEndpoint1()\n        file.write(targ + '.emitter.setEndpoint1(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n        point = self.emitter.getEndpoint2()\n        file.write(targ + '.emitter.setEndpoint2(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n    elif self.emitterType == 'PointEmitter':\n        file.write('# Point parameters\\n')\n        point = self.emitter.getLocation()\n        file.write(targ + '.emitter.setLocation(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n    elif self.emitterType == 'RectangleEmitter':\n        file.write('# Rectangle parameters\\n')\n        point = self.emitter.getMinBound()\n        file.write(targ + '.emitter.setMinBound(Point2(%.4f, %.4f))\\n' % (point[0], point[1]))\n        point = self.emitter.getMaxBound()\n        file.write(targ + '.emitter.setMaxBound(Point2(%.4f, %.4f))\\n' % (point[0], point[1]))\n    elif self.emitterType == 'RingEmitter':\n        file.write('# Ring parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        file.write(targ + '.emitter.setRadiusSpread(%.4f)\\n' % self.emitter.getRadiusSpread())\n        if eType == 'ETCUSTOM':\n            file.write(targ + '.emitter.setAngle(%.4f)\\n' % self.emitter.getAngle())\n    elif self.emitterType == 'SphereSurfaceEmitter':\n        file.write('# Sphere Surface parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n    elif self.emitterType == 'SphereVolumeEmitter':\n        file.write('# Sphere Volume parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n    elif self.emitterType == 'TangentRingEmitter':\n        file.write('# Tangent Ring parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        file.write(targ + '.emitter.setRadiusSpread(%.4f)\\n' % self.emitter.getRadiusSpread())",
            "def printParams(self, file=sys.stdout, targ='self'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    file.write('# Particles parameters\\n')\n    file.write(targ + '.setFactory(\"' + self.factoryType + '\")\\n')\n    file.write(targ + '.setRenderer(\"' + self.rendererType + '\")\\n')\n    file.write(targ + '.setEmitter(\"' + self.emitterType + '\")\\n')\n    file.write(targ + '.setPoolSize(%d)\\n' % int(self.getPoolSize()))\n    file.write(targ + '.setBirthRate(%.4f)\\n' % self.getBirthRate())\n    file.write(targ + '.setLitterSize(%d)\\n' % int(self.getLitterSize()))\n    file.write(targ + '.setLitterSpread(%d)\\n' % self.getLitterSpread())\n    file.write(targ + '.setSystemLifespan(%.4f)\\n' % self.getSystemLifespan())\n    file.write(targ + '.setLocalVelocityFlag(%d)\\n' % self.getLocalVelocityFlag())\n    file.write(targ + '.setSystemGrowsOlderFlag(%d)\\n' % self.getSystemGrowsOlderFlag())\n    file.write('# Factory parameters\\n')\n    file.write(targ + '.factory.setLifespanBase(%.4f)\\n' % self.factory.getLifespanBase())\n    file.write(targ + '.factory.setLifespanSpread(%.4f)\\n' % self.factory.getLifespanSpread())\n    file.write(targ + '.factory.setMassBase(%.4f)\\n' % self.factory.getMassBase())\n    file.write(targ + '.factory.setMassSpread(%.4f)\\n' % self.factory.getMassSpread())\n    file.write(targ + '.factory.setTerminalVelocityBase(%.4f)\\n' % self.factory.getTerminalVelocityBase())\n    file.write(targ + '.factory.setTerminalVelocitySpread(%.4f)\\n' % self.factory.getTerminalVelocitySpread())\n    if self.factoryType == 'PointParticleFactory':\n        file.write('# Point factory parameters\\n')\n    elif self.factoryType == 'ZSpinParticleFactory':\n        file.write('# Z Spin factory parameters\\n')\n        file.write(targ + '.factory.setInitialAngle(%.4f)\\n' % self.factory.getInitialAngle())\n        file.write(targ + '.factory.setInitialAngleSpread(%.4f)\\n' % self.factory.getInitialAngleSpread())\n        file.write(targ + '.factory.enableAngularVelocity(%d)\\n' % self.factory.getAngularVelocityEnabled())\n        if self.factory.getAngularVelocityEnabled():\n            file.write(targ + '.factory.setAngularVelocity(%.4f)\\n' % self.factory.getAngularVelocity())\n            file.write(targ + '.factory.setAngularVelocitySpread(%.4f)\\n' % self.factory.getAngularVelocitySpread())\n        else:\n            file.write(targ + '.factory.setFinalAngle(%.4f)\\n' % self.factory.getFinalAngle())\n            file.write(targ + '.factory.setFinalAngleSpread(%.4f)\\n' % self.factory.getFinalAngleSpread())\n    elif self.factoryType == 'OrientedParticleFactory':\n        file.write('# Oriented factory parameters\\n')\n        file.write(targ + '.factory.setInitialOrientation(%.4f)\\n' % self.factory.getInitialOrientation())\n        file.write(targ + '.factory.setFinalOrientation(%.4f)\\n' % self.factory.getFinalOrientation())\n    file.write('# Renderer parameters\\n')\n    alphaMode = self.renderer.getAlphaMode()\n    aMode = 'PRALPHANONE'\n    if alphaMode == BaseParticleRenderer.PRALPHANONE:\n        aMode = 'PRALPHANONE'\n    elif alphaMode == BaseParticleRenderer.PRALPHAOUT:\n        aMode = 'PRALPHAOUT'\n    elif alphaMode == BaseParticleRenderer.PRALPHAIN:\n        aMode = 'PRALPHAIN'\n    elif alphaMode == BaseParticleRenderer.PRALPHAINOUT:\n        aMode = 'PRALPHAINOUT'\n    elif alphaMode == BaseParticleRenderer.PRALPHAUSER:\n        aMode = 'PRALPHAUSER'\n    file.write(targ + '.renderer.setAlphaMode(BaseParticleRenderer.' + aMode + ')\\n')\n    file.write(targ + '.renderer.setUserAlpha(%.2f)\\n' % self.renderer.getUserAlpha())\n    if self.rendererType == 'PointParticleRenderer':\n        file.write('# Point parameters\\n')\n        file.write(targ + '.renderer.setPointSize(%.2f)\\n' % self.renderer.getPointSize())\n        sColor = self.renderer.getStartColor()\n        file.write(targ + '.renderer.setStartColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getEndColor()\n        file.write(targ + '.renderer.setEndColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        blendType = self.renderer.getBlendType()\n        bType = 'PPONECOLOR'\n        if blendType == PointParticleRenderer.PPONECOLOR:\n            bType = 'PPONECOLOR'\n        elif blendType == PointParticleRenderer.PPBLENDLIFE:\n            bType = 'PPBLENDLIFE'\n        elif blendType == PointParticleRenderer.PPBLENDVEL:\n            bType = 'PPBLENDVEL'\n        file.write(targ + '.renderer.setBlendType(PointParticleRenderer.' + bType + ')\\n')\n        blendMethod = self.renderer.getBlendMethod()\n        bMethod = 'PPNOBLEND'\n        if blendMethod == BaseParticleRenderer.PPNOBLEND:\n            bMethod = 'PPNOBLEND'\n        elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n            bMethod = 'PPBLENDLINEAR'\n        elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n            bMethod = 'PPBLENDCUBIC'\n        file.write(targ + '.renderer.setBlendMethod(BaseParticleRenderer.' + bMethod + ')\\n')\n    elif self.rendererType == 'LineParticleRenderer':\n        file.write('# Line parameters\\n')\n        sColor = self.renderer.getHeadColor()\n        file.write(targ + '.renderer.setHeadColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getTailColor()\n        file.write(targ + '.renderer.setTailColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sf = self.renderer.getLineScaleFactor()\n        file.write(targ + '.renderer.setLineScaleFactor(%.2f)\\n' % sf)\n    elif self.rendererType == 'GeomParticleRenderer':\n        file.write('# Geom parameters\\n')\n        node = self.renderer.getGeomNode()\n        file.write('geomRef = loader.loadModel(\"' + self.geomReference + '\")\\n')\n        file.write(targ + '.renderer.setGeomNode(geomRef.node())\\n')\n        file.write(targ + '.geomReference = \"' + self.geomReference + '\"\\n')\n        cbmLut = ('MNone', 'MAdd', 'MSubtract', 'MInvSubtract', 'MMin', 'MMax')\n        cboLut = ('OZero', 'OOne', 'OIncomingColor', 'OOneMinusIncomingColor', 'OFbufferColor', 'OOneMinusFbufferColor', 'OIncomingAlpha', 'OOneMinusIncomingAlpha', 'OFbufferAlpha', 'OOneMinusFbufferAlpha', 'OConstantColor', 'OOneMinusConstantColor', 'OConstantAlpha', 'OOneMinusConstantAlpha', 'OIncomingColorSaturate')\n        file.write(targ + '.renderer.setXScaleFlag(%d)\\n' % self.renderer.getXScaleFlag())\n        file.write(targ + '.renderer.setYScaleFlag(%d)\\n' % self.renderer.getYScaleFlag())\n        file.write(targ + '.renderer.setZScaleFlag(%d)\\n' % self.renderer.getZScaleFlag())\n        file.write(targ + '.renderer.setInitialXScale(%.4f)\\n' % self.renderer.getInitialXScale())\n        file.write(targ + '.renderer.setFinalXScale(%.4f)\\n' % self.renderer.getFinalXScale())\n        file.write(targ + '.renderer.setInitialYScale(%.4f)\\n' % self.renderer.getInitialYScale())\n        file.write(targ + '.renderer.setFinalYScale(%.4f)\\n' % self.renderer.getFinalYScale())\n        file.write(targ + '.renderer.setInitialZScale(%.4f)\\n' % self.renderer.getInitialZScale())\n        file.write(targ + '.renderer.setFinalZScale(%.4f)\\n' % self.renderer.getFinalZScale())\n        cbAttrib = self.renderer.getRenderNode().getAttrib(ColorBlendAttrib.getClassType())\n        if cbAttrib:\n            cbMode = cbAttrib.getMode()\n            if cbMode > 0:\n                if cbMode in (ColorBlendAttrib.MAdd, ColorBlendAttrib.MSubtract, ColorBlendAttrib.MInvSubtract):\n                    cboa = cbAttrib.getOperandA()\n                    cbob = cbAttrib.getOperandB()\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s, ColorBlendAttrib.%s, ColorBlendAttrib.%s)\\n' % (cbmLut[cbMode], cboLut[cboa], cboLut[cbob]))\n                else:\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s)\\n' % cbmLut[cbMode])\n        cim = self.renderer.getColorInterpolationManager()\n        segIdList = [int(seg) for seg in cim.getSegmentIdList().split()]\n        for sid in segIdList:\n            seg = cim.getSegment(sid)\n            if seg.isEnabled():\n                t_b = seg.getTimeBegin()\n                t_e = seg.getTimeEnd()\n                mod = seg.isModulated()\n                fun = seg.getFunction()\n                typ = type(fun).__name__\n                if typ == 'ColorInterpolationFunctionConstant':\n                    c_a = fun.getColorA()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addConstant(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionLinear':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addLinear(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionStepwave':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    w_a = fun.getWidthA()\n                    w_b = fun.getWidthB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addStepwave(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(w_a) + ',' + repr(w_b) + ',' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionSinusoid':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    per = fun.getPeriod()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addSinusoid(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(per) + ',' + repr(mod) + ')\\n')\n    elif self.rendererType == 'SparkleParticleRenderer':\n        file.write('# Sparkle parameters\\n')\n        sColor = self.renderer.getCenterColor()\n        file.write(targ + '.renderer.setCenterColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getEdgeColor()\n        file.write(targ + '.renderer.setEdgeColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        file.write(targ + '.renderer.setBirthRadius(%.4f)\\n' % self.renderer.getBirthRadius())\n        file.write(targ + '.renderer.setDeathRadius(%.4f)\\n' % self.renderer.getDeathRadius())\n        lifeScale = self.renderer.getLifeScale()\n        lScale = 'SPNOSCALE'\n        if lifeScale == SparkleParticleRenderer.SPSCALE:\n            lScale = 'SPSCALE'\n        file.write(targ + '.renderer.setLifeScale(SparkleParticleRenderer.' + lScale + ')\\n')\n    elif self.rendererType == 'SpriteParticleRenderer':\n        file.write('# Sprite parameters\\n')\n        if self.renderer.getAnimateFramesEnable():\n            file.write(targ + '.renderer.setAnimateFramesEnable(True)\\n')\n            rate = self.renderer.getAnimateFramesRate()\n            if rate:\n                file.write(targ + '.renderer.setAnimateFramesRate(%.3f)\\n' % rate)\n        animCount = self.renderer.getNumAnims()\n        for x in range(animCount):\n            anim = self.renderer.getAnim(x)\n            if anim.getSourceType() == SpriteAnim.STTexture:\n                file.write(targ + \".renderer.addTextureFromFile('%s')\\n\" % (anim.getTexSource(),))\n            else:\n                file.write(targ + \".renderer.addTextureFromNode('%s','%s')\\n\" % (anim.getModelSource(), anim.getNodeSource()))\n        sColor = self.renderer.getColor()\n        file.write(targ + '.renderer.setColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        file.write(targ + '.renderer.setXScaleFlag(%d)\\n' % self.renderer.getXScaleFlag())\n        file.write(targ + '.renderer.setYScaleFlag(%d)\\n' % self.renderer.getYScaleFlag())\n        file.write(targ + '.renderer.setAnimAngleFlag(%d)\\n' % self.renderer.getAnimAngleFlag())\n        file.write(targ + '.renderer.setInitialXScale(%.4f)\\n' % self.renderer.getInitialXScale())\n        file.write(targ + '.renderer.setFinalXScale(%.4f)\\n' % self.renderer.getFinalXScale())\n        file.write(targ + '.renderer.setInitialYScale(%.4f)\\n' % self.renderer.getInitialYScale())\n        file.write(targ + '.renderer.setFinalYScale(%.4f)\\n' % self.renderer.getFinalYScale())\n        file.write(targ + '.renderer.setNonanimatedTheta(%.4f)\\n' % self.renderer.getNonanimatedTheta())\n        blendMethod = self.renderer.getAlphaBlendMethod()\n        bMethod = 'PPNOBLEND'\n        if blendMethod == BaseParticleRenderer.PPNOBLEND:\n            bMethod = 'PPNOBLEND'\n        elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n            bMethod = 'PPBLENDLINEAR'\n        elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n            bMethod = 'PPBLENDCUBIC'\n        file.write(targ + '.renderer.setAlphaBlendMethod(BaseParticleRenderer.' + bMethod + ')\\n')\n        file.write(targ + '.renderer.setAlphaDisable(%d)\\n' % self.renderer.getAlphaDisable())\n        cbmLut = ('MNone', 'MAdd', 'MSubtract', 'MInvSubtract', 'MMin', 'MMax')\n        cboLut = ('OZero', 'OOne', 'OIncomingColor', 'OOneMinusIncomingColor', 'OFbufferColor', 'OOneMinusFbufferColor', 'OIncomingAlpha', 'OOneMinusIncomingAlpha', 'OFbufferAlpha', 'OOneMinusFbufferAlpha', 'OConstantColor', 'OOneMinusConstantColor', 'OConstantAlpha', 'OOneMinusConstantAlpha', 'OIncomingColorSaturate')\n        cbAttrib = self.renderer.getRenderNode().getAttrib(ColorBlendAttrib.getClassType())\n        if cbAttrib:\n            cbMode = cbAttrib.getMode()\n            if cbMode > 0:\n                if cbMode in (ColorBlendAttrib.MAdd, ColorBlendAttrib.MSubtract, ColorBlendAttrib.MInvSubtract):\n                    cboa = cbAttrib.getOperandA()\n                    cbob = cbAttrib.getOperandB()\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s, ColorBlendAttrib.%s, ColorBlendAttrib.%s)\\n' % (cbmLut[cbMode], cboLut[cboa], cboLut[cbob]))\n                else:\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s)\\n' % cbmLut[cbMode])\n        cim = self.renderer.getColorInterpolationManager()\n        segIdList = [int(seg) for seg in cim.getSegmentIdList().split()]\n        for sid in segIdList:\n            seg = cim.getSegment(sid)\n            if seg.isEnabled():\n                t_b = seg.getTimeBegin()\n                t_e = seg.getTimeEnd()\n                mod = seg.isModulated()\n                fun = seg.getFunction()\n                typ = type(fun).__name__\n                if typ == 'ColorInterpolationFunctionConstant':\n                    c_a = fun.getColorA()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addConstant(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionLinear':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addLinear(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionStepwave':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    w_a = fun.getWidthA()\n                    w_b = fun.getWidthB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addStepwave(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(w_a) + ',' + repr(w_b) + ',' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionSinusoid':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    per = fun.getPeriod()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addSinusoid(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(per) + ',' + repr(mod) + ')\\n')\n    file.write('# Emitter parameters\\n')\n    emissionType = self.emitter.getEmissionType()\n    eType = 'ETEXPLICIT'\n    if emissionType == BaseParticleEmitter.ETEXPLICIT:\n        eType = 'ETEXPLICIT'\n    elif emissionType == BaseParticleEmitter.ETRADIATE:\n        eType = 'ETRADIATE'\n    elif emissionType == BaseParticleEmitter.ETCUSTOM:\n        eType = 'ETCUSTOM'\n    file.write(targ + '.emitter.setEmissionType(BaseParticleEmitter.' + eType + ')\\n')\n    file.write(targ + '.emitter.setAmplitude(%.4f)\\n' % self.emitter.getAmplitude())\n    file.write(targ + '.emitter.setAmplitudeSpread(%.4f)\\n' % self.emitter.getAmplitudeSpread())\n    oForce = self.emitter.getOffsetForce()\n    file.write(targ + '.emitter.setOffsetForce(Vec3(%.4f, %.4f, %.4f))\\n' % (oForce[0], oForce[1], oForce[2]))\n    oForce = self.emitter.getExplicitLaunchVector()\n    file.write(targ + '.emitter.setExplicitLaunchVector(Vec3(%.4f, %.4f, %.4f))\\n' % (oForce[0], oForce[1], oForce[2]))\n    orig = self.emitter.getRadiateOrigin()\n    file.write(targ + '.emitter.setRadiateOrigin(Point3(%.4f, %.4f, %.4f))\\n' % (orig[0], orig[1], orig[2]))\n    if self.emitterType == 'BoxEmitter':\n        file.write('# Box parameters\\n')\n        bound = self.emitter.getMinBound()\n        file.write(targ + '.emitter.setMinBound(Point3(%.4f, %.4f, %.4f))\\n' % (bound[0], bound[1], bound[2]))\n        bound = self.emitter.getMaxBound()\n        file.write(targ + '.emitter.setMaxBound(Point3(%.4f, %.4f, %.4f))\\n' % (bound[0], bound[1], bound[2]))\n    elif self.emitterType == 'DiscEmitter':\n        file.write('# Disc parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        if eType == 'ETCUSTOM':\n            file.write(targ + '.emitter.setOuterAngle(%.4f)\\n' % self.emitter.getOuterAngle())\n            file.write(targ + '.emitter.setInnerAngle(%.4f)\\n' % self.emitter.getInnerAngle())\n            file.write(targ + '.emitter.setOuterMagnitude(%.4f)\\n' % self.emitter.getOuterMagnitude())\n            file.write(targ + '.emitter.setInnerMagnitude(%.4f)\\n' % self.emitter.getInnerMagnitude())\n            file.write(targ + '.emitter.setCubicLerping(%d)\\n' % self.emitter.getCubicLerping())\n    elif self.emitterType == 'LineEmitter':\n        file.write('# Line parameters\\n')\n        point = self.emitter.getEndpoint1()\n        file.write(targ + '.emitter.setEndpoint1(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n        point = self.emitter.getEndpoint2()\n        file.write(targ + '.emitter.setEndpoint2(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n    elif self.emitterType == 'PointEmitter':\n        file.write('# Point parameters\\n')\n        point = self.emitter.getLocation()\n        file.write(targ + '.emitter.setLocation(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n    elif self.emitterType == 'RectangleEmitter':\n        file.write('# Rectangle parameters\\n')\n        point = self.emitter.getMinBound()\n        file.write(targ + '.emitter.setMinBound(Point2(%.4f, %.4f))\\n' % (point[0], point[1]))\n        point = self.emitter.getMaxBound()\n        file.write(targ + '.emitter.setMaxBound(Point2(%.4f, %.4f))\\n' % (point[0], point[1]))\n    elif self.emitterType == 'RingEmitter':\n        file.write('# Ring parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        file.write(targ + '.emitter.setRadiusSpread(%.4f)\\n' % self.emitter.getRadiusSpread())\n        if eType == 'ETCUSTOM':\n            file.write(targ + '.emitter.setAngle(%.4f)\\n' % self.emitter.getAngle())\n    elif self.emitterType == 'SphereSurfaceEmitter':\n        file.write('# Sphere Surface parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n    elif self.emitterType == 'SphereVolumeEmitter':\n        file.write('# Sphere Volume parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n    elif self.emitterType == 'TangentRingEmitter':\n        file.write('# Tangent Ring parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        file.write(targ + '.emitter.setRadiusSpread(%.4f)\\n' % self.emitter.getRadiusSpread())",
            "def printParams(self, file=sys.stdout, targ='self'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    file.write('# Particles parameters\\n')\n    file.write(targ + '.setFactory(\"' + self.factoryType + '\")\\n')\n    file.write(targ + '.setRenderer(\"' + self.rendererType + '\")\\n')\n    file.write(targ + '.setEmitter(\"' + self.emitterType + '\")\\n')\n    file.write(targ + '.setPoolSize(%d)\\n' % int(self.getPoolSize()))\n    file.write(targ + '.setBirthRate(%.4f)\\n' % self.getBirthRate())\n    file.write(targ + '.setLitterSize(%d)\\n' % int(self.getLitterSize()))\n    file.write(targ + '.setLitterSpread(%d)\\n' % self.getLitterSpread())\n    file.write(targ + '.setSystemLifespan(%.4f)\\n' % self.getSystemLifespan())\n    file.write(targ + '.setLocalVelocityFlag(%d)\\n' % self.getLocalVelocityFlag())\n    file.write(targ + '.setSystemGrowsOlderFlag(%d)\\n' % self.getSystemGrowsOlderFlag())\n    file.write('# Factory parameters\\n')\n    file.write(targ + '.factory.setLifespanBase(%.4f)\\n' % self.factory.getLifespanBase())\n    file.write(targ + '.factory.setLifespanSpread(%.4f)\\n' % self.factory.getLifespanSpread())\n    file.write(targ + '.factory.setMassBase(%.4f)\\n' % self.factory.getMassBase())\n    file.write(targ + '.factory.setMassSpread(%.4f)\\n' % self.factory.getMassSpread())\n    file.write(targ + '.factory.setTerminalVelocityBase(%.4f)\\n' % self.factory.getTerminalVelocityBase())\n    file.write(targ + '.factory.setTerminalVelocitySpread(%.4f)\\n' % self.factory.getTerminalVelocitySpread())\n    if self.factoryType == 'PointParticleFactory':\n        file.write('# Point factory parameters\\n')\n    elif self.factoryType == 'ZSpinParticleFactory':\n        file.write('# Z Spin factory parameters\\n')\n        file.write(targ + '.factory.setInitialAngle(%.4f)\\n' % self.factory.getInitialAngle())\n        file.write(targ + '.factory.setInitialAngleSpread(%.4f)\\n' % self.factory.getInitialAngleSpread())\n        file.write(targ + '.factory.enableAngularVelocity(%d)\\n' % self.factory.getAngularVelocityEnabled())\n        if self.factory.getAngularVelocityEnabled():\n            file.write(targ + '.factory.setAngularVelocity(%.4f)\\n' % self.factory.getAngularVelocity())\n            file.write(targ + '.factory.setAngularVelocitySpread(%.4f)\\n' % self.factory.getAngularVelocitySpread())\n        else:\n            file.write(targ + '.factory.setFinalAngle(%.4f)\\n' % self.factory.getFinalAngle())\n            file.write(targ + '.factory.setFinalAngleSpread(%.4f)\\n' % self.factory.getFinalAngleSpread())\n    elif self.factoryType == 'OrientedParticleFactory':\n        file.write('# Oriented factory parameters\\n')\n        file.write(targ + '.factory.setInitialOrientation(%.4f)\\n' % self.factory.getInitialOrientation())\n        file.write(targ + '.factory.setFinalOrientation(%.4f)\\n' % self.factory.getFinalOrientation())\n    file.write('# Renderer parameters\\n')\n    alphaMode = self.renderer.getAlphaMode()\n    aMode = 'PRALPHANONE'\n    if alphaMode == BaseParticleRenderer.PRALPHANONE:\n        aMode = 'PRALPHANONE'\n    elif alphaMode == BaseParticleRenderer.PRALPHAOUT:\n        aMode = 'PRALPHAOUT'\n    elif alphaMode == BaseParticleRenderer.PRALPHAIN:\n        aMode = 'PRALPHAIN'\n    elif alphaMode == BaseParticleRenderer.PRALPHAINOUT:\n        aMode = 'PRALPHAINOUT'\n    elif alphaMode == BaseParticleRenderer.PRALPHAUSER:\n        aMode = 'PRALPHAUSER'\n    file.write(targ + '.renderer.setAlphaMode(BaseParticleRenderer.' + aMode + ')\\n')\n    file.write(targ + '.renderer.setUserAlpha(%.2f)\\n' % self.renderer.getUserAlpha())\n    if self.rendererType == 'PointParticleRenderer':\n        file.write('# Point parameters\\n')\n        file.write(targ + '.renderer.setPointSize(%.2f)\\n' % self.renderer.getPointSize())\n        sColor = self.renderer.getStartColor()\n        file.write(targ + '.renderer.setStartColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getEndColor()\n        file.write(targ + '.renderer.setEndColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        blendType = self.renderer.getBlendType()\n        bType = 'PPONECOLOR'\n        if blendType == PointParticleRenderer.PPONECOLOR:\n            bType = 'PPONECOLOR'\n        elif blendType == PointParticleRenderer.PPBLENDLIFE:\n            bType = 'PPBLENDLIFE'\n        elif blendType == PointParticleRenderer.PPBLENDVEL:\n            bType = 'PPBLENDVEL'\n        file.write(targ + '.renderer.setBlendType(PointParticleRenderer.' + bType + ')\\n')\n        blendMethod = self.renderer.getBlendMethod()\n        bMethod = 'PPNOBLEND'\n        if blendMethod == BaseParticleRenderer.PPNOBLEND:\n            bMethod = 'PPNOBLEND'\n        elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n            bMethod = 'PPBLENDLINEAR'\n        elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n            bMethod = 'PPBLENDCUBIC'\n        file.write(targ + '.renderer.setBlendMethod(BaseParticleRenderer.' + bMethod + ')\\n')\n    elif self.rendererType == 'LineParticleRenderer':\n        file.write('# Line parameters\\n')\n        sColor = self.renderer.getHeadColor()\n        file.write(targ + '.renderer.setHeadColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getTailColor()\n        file.write(targ + '.renderer.setTailColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sf = self.renderer.getLineScaleFactor()\n        file.write(targ + '.renderer.setLineScaleFactor(%.2f)\\n' % sf)\n    elif self.rendererType == 'GeomParticleRenderer':\n        file.write('# Geom parameters\\n')\n        node = self.renderer.getGeomNode()\n        file.write('geomRef = loader.loadModel(\"' + self.geomReference + '\")\\n')\n        file.write(targ + '.renderer.setGeomNode(geomRef.node())\\n')\n        file.write(targ + '.geomReference = \"' + self.geomReference + '\"\\n')\n        cbmLut = ('MNone', 'MAdd', 'MSubtract', 'MInvSubtract', 'MMin', 'MMax')\n        cboLut = ('OZero', 'OOne', 'OIncomingColor', 'OOneMinusIncomingColor', 'OFbufferColor', 'OOneMinusFbufferColor', 'OIncomingAlpha', 'OOneMinusIncomingAlpha', 'OFbufferAlpha', 'OOneMinusFbufferAlpha', 'OConstantColor', 'OOneMinusConstantColor', 'OConstantAlpha', 'OOneMinusConstantAlpha', 'OIncomingColorSaturate')\n        file.write(targ + '.renderer.setXScaleFlag(%d)\\n' % self.renderer.getXScaleFlag())\n        file.write(targ + '.renderer.setYScaleFlag(%d)\\n' % self.renderer.getYScaleFlag())\n        file.write(targ + '.renderer.setZScaleFlag(%d)\\n' % self.renderer.getZScaleFlag())\n        file.write(targ + '.renderer.setInitialXScale(%.4f)\\n' % self.renderer.getInitialXScale())\n        file.write(targ + '.renderer.setFinalXScale(%.4f)\\n' % self.renderer.getFinalXScale())\n        file.write(targ + '.renderer.setInitialYScale(%.4f)\\n' % self.renderer.getInitialYScale())\n        file.write(targ + '.renderer.setFinalYScale(%.4f)\\n' % self.renderer.getFinalYScale())\n        file.write(targ + '.renderer.setInitialZScale(%.4f)\\n' % self.renderer.getInitialZScale())\n        file.write(targ + '.renderer.setFinalZScale(%.4f)\\n' % self.renderer.getFinalZScale())\n        cbAttrib = self.renderer.getRenderNode().getAttrib(ColorBlendAttrib.getClassType())\n        if cbAttrib:\n            cbMode = cbAttrib.getMode()\n            if cbMode > 0:\n                if cbMode in (ColorBlendAttrib.MAdd, ColorBlendAttrib.MSubtract, ColorBlendAttrib.MInvSubtract):\n                    cboa = cbAttrib.getOperandA()\n                    cbob = cbAttrib.getOperandB()\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s, ColorBlendAttrib.%s, ColorBlendAttrib.%s)\\n' % (cbmLut[cbMode], cboLut[cboa], cboLut[cbob]))\n                else:\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s)\\n' % cbmLut[cbMode])\n        cim = self.renderer.getColorInterpolationManager()\n        segIdList = [int(seg) for seg in cim.getSegmentIdList().split()]\n        for sid in segIdList:\n            seg = cim.getSegment(sid)\n            if seg.isEnabled():\n                t_b = seg.getTimeBegin()\n                t_e = seg.getTimeEnd()\n                mod = seg.isModulated()\n                fun = seg.getFunction()\n                typ = type(fun).__name__\n                if typ == 'ColorInterpolationFunctionConstant':\n                    c_a = fun.getColorA()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addConstant(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionLinear':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addLinear(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionStepwave':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    w_a = fun.getWidthA()\n                    w_b = fun.getWidthB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addStepwave(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(w_a) + ',' + repr(w_b) + ',' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionSinusoid':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    per = fun.getPeriod()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addSinusoid(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(per) + ',' + repr(mod) + ')\\n')\n    elif self.rendererType == 'SparkleParticleRenderer':\n        file.write('# Sparkle parameters\\n')\n        sColor = self.renderer.getCenterColor()\n        file.write(targ + '.renderer.setCenterColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        sColor = self.renderer.getEdgeColor()\n        file.write(targ + '.renderer.setEdgeColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        file.write(targ + '.renderer.setBirthRadius(%.4f)\\n' % self.renderer.getBirthRadius())\n        file.write(targ + '.renderer.setDeathRadius(%.4f)\\n' % self.renderer.getDeathRadius())\n        lifeScale = self.renderer.getLifeScale()\n        lScale = 'SPNOSCALE'\n        if lifeScale == SparkleParticleRenderer.SPSCALE:\n            lScale = 'SPSCALE'\n        file.write(targ + '.renderer.setLifeScale(SparkleParticleRenderer.' + lScale + ')\\n')\n    elif self.rendererType == 'SpriteParticleRenderer':\n        file.write('# Sprite parameters\\n')\n        if self.renderer.getAnimateFramesEnable():\n            file.write(targ + '.renderer.setAnimateFramesEnable(True)\\n')\n            rate = self.renderer.getAnimateFramesRate()\n            if rate:\n                file.write(targ + '.renderer.setAnimateFramesRate(%.3f)\\n' % rate)\n        animCount = self.renderer.getNumAnims()\n        for x in range(animCount):\n            anim = self.renderer.getAnim(x)\n            if anim.getSourceType() == SpriteAnim.STTexture:\n                file.write(targ + \".renderer.addTextureFromFile('%s')\\n\" % (anim.getTexSource(),))\n            else:\n                file.write(targ + \".renderer.addTextureFromNode('%s','%s')\\n\" % (anim.getModelSource(), anim.getNodeSource()))\n        sColor = self.renderer.getColor()\n        file.write(targ + '.renderer.setColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3]))\n        file.write(targ + '.renderer.setXScaleFlag(%d)\\n' % self.renderer.getXScaleFlag())\n        file.write(targ + '.renderer.setYScaleFlag(%d)\\n' % self.renderer.getYScaleFlag())\n        file.write(targ + '.renderer.setAnimAngleFlag(%d)\\n' % self.renderer.getAnimAngleFlag())\n        file.write(targ + '.renderer.setInitialXScale(%.4f)\\n' % self.renderer.getInitialXScale())\n        file.write(targ + '.renderer.setFinalXScale(%.4f)\\n' % self.renderer.getFinalXScale())\n        file.write(targ + '.renderer.setInitialYScale(%.4f)\\n' % self.renderer.getInitialYScale())\n        file.write(targ + '.renderer.setFinalYScale(%.4f)\\n' % self.renderer.getFinalYScale())\n        file.write(targ + '.renderer.setNonanimatedTheta(%.4f)\\n' % self.renderer.getNonanimatedTheta())\n        blendMethod = self.renderer.getAlphaBlendMethod()\n        bMethod = 'PPNOBLEND'\n        if blendMethod == BaseParticleRenderer.PPNOBLEND:\n            bMethod = 'PPNOBLEND'\n        elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n            bMethod = 'PPBLENDLINEAR'\n        elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n            bMethod = 'PPBLENDCUBIC'\n        file.write(targ + '.renderer.setAlphaBlendMethod(BaseParticleRenderer.' + bMethod + ')\\n')\n        file.write(targ + '.renderer.setAlphaDisable(%d)\\n' % self.renderer.getAlphaDisable())\n        cbmLut = ('MNone', 'MAdd', 'MSubtract', 'MInvSubtract', 'MMin', 'MMax')\n        cboLut = ('OZero', 'OOne', 'OIncomingColor', 'OOneMinusIncomingColor', 'OFbufferColor', 'OOneMinusFbufferColor', 'OIncomingAlpha', 'OOneMinusIncomingAlpha', 'OFbufferAlpha', 'OOneMinusFbufferAlpha', 'OConstantColor', 'OOneMinusConstantColor', 'OConstantAlpha', 'OOneMinusConstantAlpha', 'OIncomingColorSaturate')\n        cbAttrib = self.renderer.getRenderNode().getAttrib(ColorBlendAttrib.getClassType())\n        if cbAttrib:\n            cbMode = cbAttrib.getMode()\n            if cbMode > 0:\n                if cbMode in (ColorBlendAttrib.MAdd, ColorBlendAttrib.MSubtract, ColorBlendAttrib.MInvSubtract):\n                    cboa = cbAttrib.getOperandA()\n                    cbob = cbAttrib.getOperandB()\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s, ColorBlendAttrib.%s, ColorBlendAttrib.%s)\\n' % (cbmLut[cbMode], cboLut[cboa], cboLut[cbob]))\n                else:\n                    file.write(targ + '.renderer.setColorBlendMode(ColorBlendAttrib.%s)\\n' % cbmLut[cbMode])\n        cim = self.renderer.getColorInterpolationManager()\n        segIdList = [int(seg) for seg in cim.getSegmentIdList().split()]\n        for sid in segIdList:\n            seg = cim.getSegment(sid)\n            if seg.isEnabled():\n                t_b = seg.getTimeBegin()\n                t_e = seg.getTimeEnd()\n                mod = seg.isModulated()\n                fun = seg.getFunction()\n                typ = type(fun).__name__\n                if typ == 'ColorInterpolationFunctionConstant':\n                    c_a = fun.getColorA()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addConstant(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionLinear':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addLinear(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionStepwave':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    w_a = fun.getWidthA()\n                    w_b = fun.getWidthB()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addStepwave(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(w_a) + ',' + repr(w_b) + ',' + repr(mod) + ')\\n')\n                elif typ == 'ColorInterpolationFunctionSinusoid':\n                    c_a = fun.getColorA()\n                    c_b = fun.getColorB()\n                    per = fun.getPeriod()\n                    file.write(targ + '.renderer.getColorInterpolationManager().addSinusoid(' + repr(t_b) + ',' + repr(t_e) + ',' + 'Vec4(' + repr(c_a[0]) + ',' + repr(c_a[1]) + ',' + repr(c_a[2]) + ',' + repr(c_a[3]) + '),' + 'Vec4(' + repr(c_b[0]) + ',' + repr(c_b[1]) + ',' + repr(c_b[2]) + ',' + repr(c_b[3]) + '),' + repr(per) + ',' + repr(mod) + ')\\n')\n    file.write('# Emitter parameters\\n')\n    emissionType = self.emitter.getEmissionType()\n    eType = 'ETEXPLICIT'\n    if emissionType == BaseParticleEmitter.ETEXPLICIT:\n        eType = 'ETEXPLICIT'\n    elif emissionType == BaseParticleEmitter.ETRADIATE:\n        eType = 'ETRADIATE'\n    elif emissionType == BaseParticleEmitter.ETCUSTOM:\n        eType = 'ETCUSTOM'\n    file.write(targ + '.emitter.setEmissionType(BaseParticleEmitter.' + eType + ')\\n')\n    file.write(targ + '.emitter.setAmplitude(%.4f)\\n' % self.emitter.getAmplitude())\n    file.write(targ + '.emitter.setAmplitudeSpread(%.4f)\\n' % self.emitter.getAmplitudeSpread())\n    oForce = self.emitter.getOffsetForce()\n    file.write(targ + '.emitter.setOffsetForce(Vec3(%.4f, %.4f, %.4f))\\n' % (oForce[0], oForce[1], oForce[2]))\n    oForce = self.emitter.getExplicitLaunchVector()\n    file.write(targ + '.emitter.setExplicitLaunchVector(Vec3(%.4f, %.4f, %.4f))\\n' % (oForce[0], oForce[1], oForce[2]))\n    orig = self.emitter.getRadiateOrigin()\n    file.write(targ + '.emitter.setRadiateOrigin(Point3(%.4f, %.4f, %.4f))\\n' % (orig[0], orig[1], orig[2]))\n    if self.emitterType == 'BoxEmitter':\n        file.write('# Box parameters\\n')\n        bound = self.emitter.getMinBound()\n        file.write(targ + '.emitter.setMinBound(Point3(%.4f, %.4f, %.4f))\\n' % (bound[0], bound[1], bound[2]))\n        bound = self.emitter.getMaxBound()\n        file.write(targ + '.emitter.setMaxBound(Point3(%.4f, %.4f, %.4f))\\n' % (bound[0], bound[1], bound[2]))\n    elif self.emitterType == 'DiscEmitter':\n        file.write('# Disc parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        if eType == 'ETCUSTOM':\n            file.write(targ + '.emitter.setOuterAngle(%.4f)\\n' % self.emitter.getOuterAngle())\n            file.write(targ + '.emitter.setInnerAngle(%.4f)\\n' % self.emitter.getInnerAngle())\n            file.write(targ + '.emitter.setOuterMagnitude(%.4f)\\n' % self.emitter.getOuterMagnitude())\n            file.write(targ + '.emitter.setInnerMagnitude(%.4f)\\n' % self.emitter.getInnerMagnitude())\n            file.write(targ + '.emitter.setCubicLerping(%d)\\n' % self.emitter.getCubicLerping())\n    elif self.emitterType == 'LineEmitter':\n        file.write('# Line parameters\\n')\n        point = self.emitter.getEndpoint1()\n        file.write(targ + '.emitter.setEndpoint1(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n        point = self.emitter.getEndpoint2()\n        file.write(targ + '.emitter.setEndpoint2(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n    elif self.emitterType == 'PointEmitter':\n        file.write('# Point parameters\\n')\n        point = self.emitter.getLocation()\n        file.write(targ + '.emitter.setLocation(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2]))\n    elif self.emitterType == 'RectangleEmitter':\n        file.write('# Rectangle parameters\\n')\n        point = self.emitter.getMinBound()\n        file.write(targ + '.emitter.setMinBound(Point2(%.4f, %.4f))\\n' % (point[0], point[1]))\n        point = self.emitter.getMaxBound()\n        file.write(targ + '.emitter.setMaxBound(Point2(%.4f, %.4f))\\n' % (point[0], point[1]))\n    elif self.emitterType == 'RingEmitter':\n        file.write('# Ring parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        file.write(targ + '.emitter.setRadiusSpread(%.4f)\\n' % self.emitter.getRadiusSpread())\n        if eType == 'ETCUSTOM':\n            file.write(targ + '.emitter.setAngle(%.4f)\\n' % self.emitter.getAngle())\n    elif self.emitterType == 'SphereSurfaceEmitter':\n        file.write('# Sphere Surface parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n    elif self.emitterType == 'SphereVolumeEmitter':\n        file.write('# Sphere Volume parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n    elif self.emitterType == 'TangentRingEmitter':\n        file.write('# Tangent Ring parameters\\n')\n        file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        file.write(targ + '.emitter.setRadiusSpread(%.4f)\\n' % self.emitter.getRadiusSpread())"
        ]
    },
    {
        "func_name": "getPoolSizeRanges",
        "original": "def getPoolSizeRanges(self):\n    litterRange = [max(1, self.getLitterSize() - self.getLitterSpread()), self.getLitterSize(), self.getLitterSize() + self.getLitterSpread()]\n    lifespanRange = [self.factory.getLifespanBase() - self.factory.getLifespanSpread(), self.factory.getLifespanBase(), self.factory.getLifespanBase() + self.factory.getLifespanSpread()]\n    birthRateRange = [self.getBirthRate()] * 3\n    print('Litter Ranges:    %s' % litterRange)\n    print('LifeSpan Ranges:  %s' % lifespanRange)\n    print('BirthRate Ranges: %s' % birthRateRange)\n    return dict(zip(('min', 'median', 'max'), [l * s / b for (l, s, b) in zip(litterRange, lifespanRange, birthRateRange)]))",
        "mutated": [
            "def getPoolSizeRanges(self):\n    if False:\n        i = 10\n    litterRange = [max(1, self.getLitterSize() - self.getLitterSpread()), self.getLitterSize(), self.getLitterSize() + self.getLitterSpread()]\n    lifespanRange = [self.factory.getLifespanBase() - self.factory.getLifespanSpread(), self.factory.getLifespanBase(), self.factory.getLifespanBase() + self.factory.getLifespanSpread()]\n    birthRateRange = [self.getBirthRate()] * 3\n    print('Litter Ranges:    %s' % litterRange)\n    print('LifeSpan Ranges:  %s' % lifespanRange)\n    print('BirthRate Ranges: %s' % birthRateRange)\n    return dict(zip(('min', 'median', 'max'), [l * s / b for (l, s, b) in zip(litterRange, lifespanRange, birthRateRange)]))",
            "def getPoolSizeRanges(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    litterRange = [max(1, self.getLitterSize() - self.getLitterSpread()), self.getLitterSize(), self.getLitterSize() + self.getLitterSpread()]\n    lifespanRange = [self.factory.getLifespanBase() - self.factory.getLifespanSpread(), self.factory.getLifespanBase(), self.factory.getLifespanBase() + self.factory.getLifespanSpread()]\n    birthRateRange = [self.getBirthRate()] * 3\n    print('Litter Ranges:    %s' % litterRange)\n    print('LifeSpan Ranges:  %s' % lifespanRange)\n    print('BirthRate Ranges: %s' % birthRateRange)\n    return dict(zip(('min', 'median', 'max'), [l * s / b for (l, s, b) in zip(litterRange, lifespanRange, birthRateRange)]))",
            "def getPoolSizeRanges(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    litterRange = [max(1, self.getLitterSize() - self.getLitterSpread()), self.getLitterSize(), self.getLitterSize() + self.getLitterSpread()]\n    lifespanRange = [self.factory.getLifespanBase() - self.factory.getLifespanSpread(), self.factory.getLifespanBase(), self.factory.getLifespanBase() + self.factory.getLifespanSpread()]\n    birthRateRange = [self.getBirthRate()] * 3\n    print('Litter Ranges:    %s' % litterRange)\n    print('LifeSpan Ranges:  %s' % lifespanRange)\n    print('BirthRate Ranges: %s' % birthRateRange)\n    return dict(zip(('min', 'median', 'max'), [l * s / b for (l, s, b) in zip(litterRange, lifespanRange, birthRateRange)]))",
            "def getPoolSizeRanges(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    litterRange = [max(1, self.getLitterSize() - self.getLitterSpread()), self.getLitterSize(), self.getLitterSize() + self.getLitterSpread()]\n    lifespanRange = [self.factory.getLifespanBase() - self.factory.getLifespanSpread(), self.factory.getLifespanBase(), self.factory.getLifespanBase() + self.factory.getLifespanSpread()]\n    birthRateRange = [self.getBirthRate()] * 3\n    print('Litter Ranges:    %s' % litterRange)\n    print('LifeSpan Ranges:  %s' % lifespanRange)\n    print('BirthRate Ranges: %s' % birthRateRange)\n    return dict(zip(('min', 'median', 'max'), [l * s / b for (l, s, b) in zip(litterRange, lifespanRange, birthRateRange)]))",
            "def getPoolSizeRanges(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    litterRange = [max(1, self.getLitterSize() - self.getLitterSpread()), self.getLitterSize(), self.getLitterSize() + self.getLitterSpread()]\n    lifespanRange = [self.factory.getLifespanBase() - self.factory.getLifespanSpread(), self.factory.getLifespanBase(), self.factory.getLifespanBase() + self.factory.getLifespanSpread()]\n    birthRateRange = [self.getBirthRate()] * 3\n    print('Litter Ranges:    %s' % litterRange)\n    print('LifeSpan Ranges:  %s' % lifespanRange)\n    print('BirthRate Ranges: %s' % birthRateRange)\n    return dict(zip(('min', 'median', 'max'), [l * s / b for (l, s, b) in zip(litterRange, lifespanRange, birthRateRange)]))"
        ]
    },
    {
        "func_name": "accelerate",
        "original": "def accelerate(self, time, stepCount=1, stepTime=0.0):\n    if time > 0.0:\n        if stepTime == 0.0:\n            stepTime = float(time) / stepCount\n            remainder = 0.0\n        else:\n            stepCount = int(float(time) / stepTime)\n            remainder = time - stepCount * stepTime\n        for step in range(stepCount):\n            base.particleMgr.doParticles(stepTime, self, False)\n            base.physicsMgr.doPhysics(stepTime, self)\n        if remainder:\n            base.particleMgr.doParticles(remainder, self, False)\n            base.physicsMgr.doPhysics(remainder, self)\n        self.render()",
        "mutated": [
            "def accelerate(self, time, stepCount=1, stepTime=0.0):\n    if False:\n        i = 10\n    if time > 0.0:\n        if stepTime == 0.0:\n            stepTime = float(time) / stepCount\n            remainder = 0.0\n        else:\n            stepCount = int(float(time) / stepTime)\n            remainder = time - stepCount * stepTime\n        for step in range(stepCount):\n            base.particleMgr.doParticles(stepTime, self, False)\n            base.physicsMgr.doPhysics(stepTime, self)\n        if remainder:\n            base.particleMgr.doParticles(remainder, self, False)\n            base.physicsMgr.doPhysics(remainder, self)\n        self.render()",
            "def accelerate(self, time, stepCount=1, stepTime=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if time > 0.0:\n        if stepTime == 0.0:\n            stepTime = float(time) / stepCount\n            remainder = 0.0\n        else:\n            stepCount = int(float(time) / stepTime)\n            remainder = time - stepCount * stepTime\n        for step in range(stepCount):\n            base.particleMgr.doParticles(stepTime, self, False)\n            base.physicsMgr.doPhysics(stepTime, self)\n        if remainder:\n            base.particleMgr.doParticles(remainder, self, False)\n            base.physicsMgr.doPhysics(remainder, self)\n        self.render()",
            "def accelerate(self, time, stepCount=1, stepTime=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if time > 0.0:\n        if stepTime == 0.0:\n            stepTime = float(time) / stepCount\n            remainder = 0.0\n        else:\n            stepCount = int(float(time) / stepTime)\n            remainder = time - stepCount * stepTime\n        for step in range(stepCount):\n            base.particleMgr.doParticles(stepTime, self, False)\n            base.physicsMgr.doPhysics(stepTime, self)\n        if remainder:\n            base.particleMgr.doParticles(remainder, self, False)\n            base.physicsMgr.doPhysics(remainder, self)\n        self.render()",
            "def accelerate(self, time, stepCount=1, stepTime=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if time > 0.0:\n        if stepTime == 0.0:\n            stepTime = float(time) / stepCount\n            remainder = 0.0\n        else:\n            stepCount = int(float(time) / stepTime)\n            remainder = time - stepCount * stepTime\n        for step in range(stepCount):\n            base.particleMgr.doParticles(stepTime, self, False)\n            base.physicsMgr.doPhysics(stepTime, self)\n        if remainder:\n            base.particleMgr.doParticles(remainder, self, False)\n            base.physicsMgr.doPhysics(remainder, self)\n        self.render()",
            "def accelerate(self, time, stepCount=1, stepTime=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if time > 0.0:\n        if stepTime == 0.0:\n            stepTime = float(time) / stepCount\n            remainder = 0.0\n        else:\n            stepCount = int(float(time) / stepTime)\n            remainder = time - stepCount * stepTime\n        for step in range(stepCount):\n            base.particleMgr.doParticles(stepTime, self, False)\n            base.physicsMgr.doPhysics(stepTime, self)\n        if remainder:\n            base.particleMgr.doParticles(remainder, self, False)\n            base.physicsMgr.doPhysics(remainder, self)\n        self.render()"
        ]
    }
]