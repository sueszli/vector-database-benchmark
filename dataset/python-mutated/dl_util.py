import os
import tempfile
import textwrap
from typing import Any, Callable
from pyspark import cloudpickle

class FunctionPickler:
    """
    This class provides a way to pickle a function and its arguments.
    It also provides a way to create a script that can run a
    function with arguments if they have them pickled to a file.
    It also provides a way of extracting the conents of a pickle file.
    """

    @staticmethod
    def pickle_fn_and_save(fn: Callable, file_path: str, save_dir: str, *args: Any, **kwargs: Any) -> str:
        if False:
            return 10
        "\n        Given a function and args, this function will pickle them to a file.\n\n        Parameters\n        ----------\n        fn: Callable\n            The picklable function that will be pickled to a file.\n        file_path: str\n            The path where to save the pickled function, args, and kwargs. If it's the\n            empty string, the function will decide on a random name.\n        save_dir: str\n            The directory in which to save the file with the pickled function and arguments.\n            Does nothing if the path is specified. If both file_path and save_dir are empty,\n            the function will write the file to the current working directory with a random\n            name.\n        *args: Any\n            Arguments of fn that will be pickled.\n        **kwargs: Any\n            Key word arguments to fn that will be pickled.\n\n        Returns\n        -------\n        str\n            The path to the file where the function and arguments are pickled.\n        "
        if file_path != '':
            with open(file_path, 'wb') as f:
                cloudpickle.dump((fn, args, kwargs), f)
                return f.name
        if save_dir == '':
            save_dir = os.getcwd()
        with tempfile.NamedTemporaryFile(dir=save_dir, delete=False) as f:
            cloudpickle.dump((fn, args, kwargs), f)
            return f.name

    @staticmethod
    def create_fn_run_script(pickled_fn_path: str, fn_output_path: str, script_path: str, prefix_code: str='', suffix_code: str='') -> str:
        if False:
            print('Hello World!')
        '\n        Given a file containing a pickled function and arguments, this function will create a\n        pytorch file that will execute the function and pickle the functions outputs.\n\n        Parameters\n        ----------\n        pickled_fn_path: str\n            This is the path of the file containing the pickled function, args, and kwargs.\n        fn_output_path: str\n            This is the location where the created file will save the pickled output of\n            the function.\n        script_path: str\n            This is the path which will be used for the created pytorch file.\n        prefix_code: str\n            This contains a string that the user can pass in which will be executed before\n            the code generated by this class to execute the function and save it. If\n            prefix_code is the empty string, nothing will be written before the auto-\n            generated code.\n        suffix_code: str\n            This contains a string of code that the user can pass in which will be executed\n            after the code generated by this class finishes executing. If suffix_code is\n            the empty string, nothing will be written after the auto-generated code.\n\n        Returns\n        -------\n        str\n            The path to the location of the newly created pytorch file.\n        '
        code_snippet = textwrap.dedent(f'\n                    from pyspark import cloudpickle\n                    import os\n\n                    if __name__ == "__main__":\n                        with open("{pickled_fn_path}", "rb") as f:\n                            fn, args, kwargs = cloudpickle.load(f)\n                        output = fn(*args, **kwargs)\n                        with open("{fn_output_path}", "wb") as f:\n                            cloudpickle.dump(output, f)\n                    ')
        with open(script_path, 'w') as f:
            if prefix_code != '':
                f.write(prefix_code)
            f.write(code_snippet)
            if suffix_code != '':
                f.write(suffix_code)
        return script_path

    @staticmethod
    def get_fn_output(fn_output_path: str) -> Any:
        if False:
            for i in range(10):
                print('nop')
        '\n        Given a path to a file with pickled output, this function\n        will unpickle the output and return it to the user.\n\n        Parameters\n        ----------\n        fn_output_path: str\n            The path to the file containing the pickled output of a function.\n\n        Returns\n        -------\n        Any\n            The unpickled output stored in func_output_path\n        '
        with open(fn_output_path, 'rb') as f:
            return cloudpickle.load(f)