[
    {
        "func_name": "on_train_epoch_end",
        "original": "def on_train_epoch_end(self, *args, **kwargs):\n    self.val_batches.append(self.trainer.progress_bar_callback.total_val_batches)",
        "mutated": [
            "def on_train_epoch_end(self, *args, **kwargs):\n    if False:\n        i = 10\n    self.val_batches.append(self.trainer.progress_bar_callback.total_val_batches)",
            "def on_train_epoch_end(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.val_batches.append(self.trainer.progress_bar_callback.total_val_batches)",
            "def on_train_epoch_end(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.val_batches.append(self.trainer.progress_bar_callback.total_val_batches)",
            "def on_train_epoch_end(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.val_batches.append(self.trainer.progress_bar_callback.total_val_batches)",
            "def on_train_epoch_end(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.val_batches.append(self.trainer.progress_bar_callback.total_val_batches)"
        ]
    },
    {
        "func_name": "on_validation_epoch_start",
        "original": "def on_validation_epoch_start(self) -> None:\n    self.val_epoch_calls += 1",
        "mutated": [
            "def on_validation_epoch_start(self) -> None:\n    if False:\n        i = 10\n    self.val_epoch_calls += 1",
            "def on_validation_epoch_start(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.val_epoch_calls += 1",
            "def on_validation_epoch_start(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.val_epoch_calls += 1",
            "def on_validation_epoch_start(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.val_epoch_calls += 1",
            "def on_validation_epoch_start(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.val_epoch_calls += 1"
        ]
    },
    {
        "func_name": "test_check_val_every_n_epoch",
        "original": "@pytest.mark.parametrize(('max_epochs', 'expected_val_loop_calls', 'expected_val_batches'), [(1, 0, [0]), (4, 2, [0, 2, 0, 2]), (5, 2, [0, 2, 0, 2, 0])])\ndef test_check_val_every_n_epoch(tmpdir, max_epochs, expected_val_loop_calls, expected_val_batches):\n\n    class TestModel(BoringModel):\n        val_epoch_calls = 0\n        val_batches = []\n\n        def on_train_epoch_end(self, *args, **kwargs):\n            self.val_batches.append(self.trainer.progress_bar_callback.total_val_batches)\n\n        def on_validation_epoch_start(self) -> None:\n            self.val_epoch_calls += 1\n    model = TestModel()\n    trainer = Trainer(default_root_dir=tmpdir, max_epochs=max_epochs, num_sanity_val_steps=0, limit_val_batches=2, check_val_every_n_epoch=2, logger=False)\n    trainer.fit(model)\n    assert trainer.state.finished, f'Training failed with {trainer.state}'\n    assert model.val_epoch_calls == expected_val_loop_calls\n    assert model.val_batches == expected_val_batches",
        "mutated": [
            "@pytest.mark.parametrize(('max_epochs', 'expected_val_loop_calls', 'expected_val_batches'), [(1, 0, [0]), (4, 2, [0, 2, 0, 2]), (5, 2, [0, 2, 0, 2, 0])])\ndef test_check_val_every_n_epoch(tmpdir, max_epochs, expected_val_loop_calls, expected_val_batches):\n    if False:\n        i = 10\n\n    class TestModel(BoringModel):\n        val_epoch_calls = 0\n        val_batches = []\n\n        def on_train_epoch_end(self, *args, **kwargs):\n            self.val_batches.append(self.trainer.progress_bar_callback.total_val_batches)\n\n        def on_validation_epoch_start(self) -> None:\n            self.val_epoch_calls += 1\n    model = TestModel()\n    trainer = Trainer(default_root_dir=tmpdir, max_epochs=max_epochs, num_sanity_val_steps=0, limit_val_batches=2, check_val_every_n_epoch=2, logger=False)\n    trainer.fit(model)\n    assert trainer.state.finished, f'Training failed with {trainer.state}'\n    assert model.val_epoch_calls == expected_val_loop_calls\n    assert model.val_batches == expected_val_batches",
            "@pytest.mark.parametrize(('max_epochs', 'expected_val_loop_calls', 'expected_val_batches'), [(1, 0, [0]), (4, 2, [0, 2, 0, 2]), (5, 2, [0, 2, 0, 2, 0])])\ndef test_check_val_every_n_epoch(tmpdir, max_epochs, expected_val_loop_calls, expected_val_batches):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class TestModel(BoringModel):\n        val_epoch_calls = 0\n        val_batches = []\n\n        def on_train_epoch_end(self, *args, **kwargs):\n            self.val_batches.append(self.trainer.progress_bar_callback.total_val_batches)\n\n        def on_validation_epoch_start(self) -> None:\n            self.val_epoch_calls += 1\n    model = TestModel()\n    trainer = Trainer(default_root_dir=tmpdir, max_epochs=max_epochs, num_sanity_val_steps=0, limit_val_batches=2, check_val_every_n_epoch=2, logger=False)\n    trainer.fit(model)\n    assert trainer.state.finished, f'Training failed with {trainer.state}'\n    assert model.val_epoch_calls == expected_val_loop_calls\n    assert model.val_batches == expected_val_batches",
            "@pytest.mark.parametrize(('max_epochs', 'expected_val_loop_calls', 'expected_val_batches'), [(1, 0, [0]), (4, 2, [0, 2, 0, 2]), (5, 2, [0, 2, 0, 2, 0])])\ndef test_check_val_every_n_epoch(tmpdir, max_epochs, expected_val_loop_calls, expected_val_batches):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class TestModel(BoringModel):\n        val_epoch_calls = 0\n        val_batches = []\n\n        def on_train_epoch_end(self, *args, **kwargs):\n            self.val_batches.append(self.trainer.progress_bar_callback.total_val_batches)\n\n        def on_validation_epoch_start(self) -> None:\n            self.val_epoch_calls += 1\n    model = TestModel()\n    trainer = Trainer(default_root_dir=tmpdir, max_epochs=max_epochs, num_sanity_val_steps=0, limit_val_batches=2, check_val_every_n_epoch=2, logger=False)\n    trainer.fit(model)\n    assert trainer.state.finished, f'Training failed with {trainer.state}'\n    assert model.val_epoch_calls == expected_val_loop_calls\n    assert model.val_batches == expected_val_batches",
            "@pytest.mark.parametrize(('max_epochs', 'expected_val_loop_calls', 'expected_val_batches'), [(1, 0, [0]), (4, 2, [0, 2, 0, 2]), (5, 2, [0, 2, 0, 2, 0])])\ndef test_check_val_every_n_epoch(tmpdir, max_epochs, expected_val_loop_calls, expected_val_batches):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class TestModel(BoringModel):\n        val_epoch_calls = 0\n        val_batches = []\n\n        def on_train_epoch_end(self, *args, **kwargs):\n            self.val_batches.append(self.trainer.progress_bar_callback.total_val_batches)\n\n        def on_validation_epoch_start(self) -> None:\n            self.val_epoch_calls += 1\n    model = TestModel()\n    trainer = Trainer(default_root_dir=tmpdir, max_epochs=max_epochs, num_sanity_val_steps=0, limit_val_batches=2, check_val_every_n_epoch=2, logger=False)\n    trainer.fit(model)\n    assert trainer.state.finished, f'Training failed with {trainer.state}'\n    assert model.val_epoch_calls == expected_val_loop_calls\n    assert model.val_batches == expected_val_batches",
            "@pytest.mark.parametrize(('max_epochs', 'expected_val_loop_calls', 'expected_val_batches'), [(1, 0, [0]), (4, 2, [0, 2, 0, 2]), (5, 2, [0, 2, 0, 2, 0])])\ndef test_check_val_every_n_epoch(tmpdir, max_epochs, expected_val_loop_calls, expected_val_batches):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class TestModel(BoringModel):\n        val_epoch_calls = 0\n        val_batches = []\n\n        def on_train_epoch_end(self, *args, **kwargs):\n            self.val_batches.append(self.trainer.progress_bar_callback.total_val_batches)\n\n        def on_validation_epoch_start(self) -> None:\n            self.val_epoch_calls += 1\n    model = TestModel()\n    trainer = Trainer(default_root_dir=tmpdir, max_epochs=max_epochs, num_sanity_val_steps=0, limit_val_batches=2, check_val_every_n_epoch=2, logger=False)\n    trainer.fit(model)\n    assert trainer.state.finished, f'Training failed with {trainer.state}'\n    assert model.val_epoch_calls == expected_val_loop_calls\n    assert model.val_batches == expected_val_batches"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    super().__init__()\n    self.validation_called_at_step = set()",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    super().__init__()\n    self.validation_called_at_step = set()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__()\n    self.validation_called_at_step = set()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__()\n    self.validation_called_at_step = set()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__()\n    self.validation_called_at_step = set()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__()\n    self.validation_called_at_step = set()"
        ]
    },
    {
        "func_name": "validation_step",
        "original": "def validation_step(self, *args):\n    self.validation_called_at_step.add(self.global_step)\n    return super().validation_step(*args)",
        "mutated": [
            "def validation_step(self, *args):\n    if False:\n        i = 10\n    self.validation_called_at_step.add(self.global_step)\n    return super().validation_step(*args)",
            "def validation_step(self, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.validation_called_at_step.add(self.global_step)\n    return super().validation_step(*args)",
            "def validation_step(self, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.validation_called_at_step.add(self.global_step)\n    return super().validation_step(*args)",
            "def validation_step(self, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.validation_called_at_step.add(self.global_step)\n    return super().validation_step(*args)",
            "def validation_step(self, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.validation_called_at_step.add(self.global_step)\n    return super().validation_step(*args)"
        ]
    },
    {
        "func_name": "train_dataloader",
        "original": "def train_dataloader(self):\n    return DataLoader(RandomDataset(32, data_samples_train))",
        "mutated": [
            "def train_dataloader(self):\n    if False:\n        i = 10\n    return DataLoader(RandomDataset(32, data_samples_train))",
            "def train_dataloader(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return DataLoader(RandomDataset(32, data_samples_train))",
            "def train_dataloader(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return DataLoader(RandomDataset(32, data_samples_train))",
            "def train_dataloader(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return DataLoader(RandomDataset(32, data_samples_train))",
            "def train_dataloader(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return DataLoader(RandomDataset(32, data_samples_train))"
        ]
    },
    {
        "func_name": "test_check_val_every_n_epoch_with_max_steps",
        "original": "def test_check_val_every_n_epoch_with_max_steps(tmpdir):\n    data_samples_train = 2\n    check_val_every_n_epoch = 3\n    max_epochs = 4\n\n    class TestModel(BoringModel):\n\n        def __init__(self):\n            super().__init__()\n            self.validation_called_at_step = set()\n\n        def validation_step(self, *args):\n            self.validation_called_at_step.add(self.global_step)\n            return super().validation_step(*args)\n\n        def train_dataloader(self):\n            return DataLoader(RandomDataset(32, data_samples_train))\n    model = TestModel()\n    trainer = Trainer(default_root_dir=tmpdir, max_steps=data_samples_train * max_epochs, check_val_every_n_epoch=check_val_every_n_epoch, num_sanity_val_steps=0)\n    trainer.fit(model)\n    assert trainer.current_epoch == max_epochs\n    assert trainer.global_step == max_epochs * data_samples_train\n    assert list(model.validation_called_at_step) == [data_samples_train * check_val_every_n_epoch]",
        "mutated": [
            "def test_check_val_every_n_epoch_with_max_steps(tmpdir):\n    if False:\n        i = 10\n    data_samples_train = 2\n    check_val_every_n_epoch = 3\n    max_epochs = 4\n\n    class TestModel(BoringModel):\n\n        def __init__(self):\n            super().__init__()\n            self.validation_called_at_step = set()\n\n        def validation_step(self, *args):\n            self.validation_called_at_step.add(self.global_step)\n            return super().validation_step(*args)\n\n        def train_dataloader(self):\n            return DataLoader(RandomDataset(32, data_samples_train))\n    model = TestModel()\n    trainer = Trainer(default_root_dir=tmpdir, max_steps=data_samples_train * max_epochs, check_val_every_n_epoch=check_val_every_n_epoch, num_sanity_val_steps=0)\n    trainer.fit(model)\n    assert trainer.current_epoch == max_epochs\n    assert trainer.global_step == max_epochs * data_samples_train\n    assert list(model.validation_called_at_step) == [data_samples_train * check_val_every_n_epoch]",
            "def test_check_val_every_n_epoch_with_max_steps(tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    data_samples_train = 2\n    check_val_every_n_epoch = 3\n    max_epochs = 4\n\n    class TestModel(BoringModel):\n\n        def __init__(self):\n            super().__init__()\n            self.validation_called_at_step = set()\n\n        def validation_step(self, *args):\n            self.validation_called_at_step.add(self.global_step)\n            return super().validation_step(*args)\n\n        def train_dataloader(self):\n            return DataLoader(RandomDataset(32, data_samples_train))\n    model = TestModel()\n    trainer = Trainer(default_root_dir=tmpdir, max_steps=data_samples_train * max_epochs, check_val_every_n_epoch=check_val_every_n_epoch, num_sanity_val_steps=0)\n    trainer.fit(model)\n    assert trainer.current_epoch == max_epochs\n    assert trainer.global_step == max_epochs * data_samples_train\n    assert list(model.validation_called_at_step) == [data_samples_train * check_val_every_n_epoch]",
            "def test_check_val_every_n_epoch_with_max_steps(tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    data_samples_train = 2\n    check_val_every_n_epoch = 3\n    max_epochs = 4\n\n    class TestModel(BoringModel):\n\n        def __init__(self):\n            super().__init__()\n            self.validation_called_at_step = set()\n\n        def validation_step(self, *args):\n            self.validation_called_at_step.add(self.global_step)\n            return super().validation_step(*args)\n\n        def train_dataloader(self):\n            return DataLoader(RandomDataset(32, data_samples_train))\n    model = TestModel()\n    trainer = Trainer(default_root_dir=tmpdir, max_steps=data_samples_train * max_epochs, check_val_every_n_epoch=check_val_every_n_epoch, num_sanity_val_steps=0)\n    trainer.fit(model)\n    assert trainer.current_epoch == max_epochs\n    assert trainer.global_step == max_epochs * data_samples_train\n    assert list(model.validation_called_at_step) == [data_samples_train * check_val_every_n_epoch]",
            "def test_check_val_every_n_epoch_with_max_steps(tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    data_samples_train = 2\n    check_val_every_n_epoch = 3\n    max_epochs = 4\n\n    class TestModel(BoringModel):\n\n        def __init__(self):\n            super().__init__()\n            self.validation_called_at_step = set()\n\n        def validation_step(self, *args):\n            self.validation_called_at_step.add(self.global_step)\n            return super().validation_step(*args)\n\n        def train_dataloader(self):\n            return DataLoader(RandomDataset(32, data_samples_train))\n    model = TestModel()\n    trainer = Trainer(default_root_dir=tmpdir, max_steps=data_samples_train * max_epochs, check_val_every_n_epoch=check_val_every_n_epoch, num_sanity_val_steps=0)\n    trainer.fit(model)\n    assert trainer.current_epoch == max_epochs\n    assert trainer.global_step == max_epochs * data_samples_train\n    assert list(model.validation_called_at_step) == [data_samples_train * check_val_every_n_epoch]",
            "def test_check_val_every_n_epoch_with_max_steps(tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    data_samples_train = 2\n    check_val_every_n_epoch = 3\n    max_epochs = 4\n\n    class TestModel(BoringModel):\n\n        def __init__(self):\n            super().__init__()\n            self.validation_called_at_step = set()\n\n        def validation_step(self, *args):\n            self.validation_called_at_step.add(self.global_step)\n            return super().validation_step(*args)\n\n        def train_dataloader(self):\n            return DataLoader(RandomDataset(32, data_samples_train))\n    model = TestModel()\n    trainer = Trainer(default_root_dir=tmpdir, max_steps=data_samples_train * max_epochs, check_val_every_n_epoch=check_val_every_n_epoch, num_sanity_val_steps=0)\n    trainer.fit(model)\n    assert trainer.current_epoch == max_epochs\n    assert trainer.global_step == max_epochs * data_samples_train\n    assert list(model.validation_called_at_step) == [data_samples_train * check_val_every_n_epoch]"
        ]
    }
]