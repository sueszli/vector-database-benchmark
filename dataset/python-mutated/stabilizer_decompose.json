[
    {
        "func_name": "synth_stabilizer_layers",
        "original": "def synth_stabilizer_layers(stab, cz_synth_func=_default_cz_synth_func, cz_func_reverse_qubits=False, validate=False):\n    \"\"\"Synthesis of a stabilizer state into layers.\n\n    It provides a similar decomposition to the synthesis described in Lemma 8 of Bravyi and Maslov,\n    without the initial Hadamard-free sub-circuit which do not affect the stabilizer state.\n\n    For example, a 5-qubit stabilizer state is decomposed into the following layers:\n\n    .. parsed-literal::\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240       \u251c\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n        q_1: \u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241       \u251c\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n        q_2: \u25242 H2 \u251c\u25242 S1 \u251c\u25242 CZ \u251c\u25242 H1 \u251c\u25242 Pauli \u251c\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n        q_3: \u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243       \u251c\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\n        q_4: \u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244       \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Args:\n        stab (StabilizerState): a stabilizer state.\n        cz_synth_func (Callable): a function to decompose the CZ sub-circuit.\n            It gets as input a boolean symmetric matrix, and outputs a QuantumCircuit.\n        validate (Boolean): if True, validates the synthesis process.\n        cz_func_reverse_qubits (Boolean): True only if cz_synth_func is synth_cz_depth_line_mr,\n            since this function returns a circuit that reverts the order of qubits.\n\n    Return:\n        QuantumCircuit: a circuit implementation of the stabilizer state.\n\n    Raises:\n        QiskitError: if the input is not a StabilizerState.\n\n    Reference:\n        1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n           structure of the Clifford group*,\n           `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\n    \"\"\"\n    if not isinstance(stab, StabilizerState):\n        raise QiskitError('The input is not a StabilizerState.')\n    cliff = stab.clifford\n    num_qubits = cliff.num_qubits\n    if cz_func_reverse_qubits:\n        cliff0 = _reverse_clifford(cliff)\n    else:\n        cliff0 = cliff\n    (H1_circ, cliff1) = _create_graph_state(cliff0, validate=validate)\n    (H2_circ, CZ1_circ, S1_circ, _) = _decompose_graph_state(cliff1, validate=validate, cz_synth_func=cz_synth_func)\n    qubit_list = list(range(num_qubits))\n    layeredCircuit = QuantumCircuit(num_qubits)\n    layeredCircuit.append(H2_circ, qubit_list)\n    layeredCircuit.append(S1_circ, qubit_list)\n    layeredCircuit.append(CZ1_circ, qubit_list)\n    if cz_func_reverse_qubits:\n        H1_circ = H1_circ.reverse_bits()\n    layeredCircuit.append(H1_circ, qubit_list)\n    from qiskit.quantum_info.operators.symplectic import Clifford\n    clifford_target = Clifford(layeredCircuit)\n    pauli_circ = _calc_pauli_diff_stabilizer(cliff, clifford_target)\n    layeredCircuit.append(pauli_circ, qubit_list)\n    return layeredCircuit",
        "mutated": [
            "def synth_stabilizer_layers(stab, cz_synth_func=_default_cz_synth_func, cz_func_reverse_qubits=False, validate=False):\n    if False:\n        i = 10\n    'Synthesis of a stabilizer state into layers.\\n\\n    It provides a similar decomposition to the synthesis described in Lemma 8 of Bravyi and Maslov,\\n    without the initial Hadamard-free sub-circuit which do not affect the stabilizer state.\\n\\n    For example, a 5-qubit stabilizer state is decomposed into the following layers:\\n\\n    .. parsed-literal::\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240       \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_1: \u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241       \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_2: \u25242 H2 \u251c\u25242 S1 \u251c\u25242 CZ \u251c\u25242 H1 \u251c\u25242 Pauli \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_3: \u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243       \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_4: \u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244       \u251c\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Args:\\n        stab (StabilizerState): a stabilizer state.\\n        cz_synth_func (Callable): a function to decompose the CZ sub-circuit.\\n            It gets as input a boolean symmetric matrix, and outputs a QuantumCircuit.\\n        validate (Boolean): if True, validates the synthesis process.\\n        cz_func_reverse_qubits (Boolean): True only if cz_synth_func is synth_cz_depth_line_mr,\\n            since this function returns a circuit that reverts the order of qubits.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the stabilizer state.\\n\\n    Raises:\\n        QiskitError: if the input is not a StabilizerState.\\n\\n    Reference:\\n        1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\\n           structure of the Clifford group*,\\n           `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\\n    '\n    if not isinstance(stab, StabilizerState):\n        raise QiskitError('The input is not a StabilizerState.')\n    cliff = stab.clifford\n    num_qubits = cliff.num_qubits\n    if cz_func_reverse_qubits:\n        cliff0 = _reverse_clifford(cliff)\n    else:\n        cliff0 = cliff\n    (H1_circ, cliff1) = _create_graph_state(cliff0, validate=validate)\n    (H2_circ, CZ1_circ, S1_circ, _) = _decompose_graph_state(cliff1, validate=validate, cz_synth_func=cz_synth_func)\n    qubit_list = list(range(num_qubits))\n    layeredCircuit = QuantumCircuit(num_qubits)\n    layeredCircuit.append(H2_circ, qubit_list)\n    layeredCircuit.append(S1_circ, qubit_list)\n    layeredCircuit.append(CZ1_circ, qubit_list)\n    if cz_func_reverse_qubits:\n        H1_circ = H1_circ.reverse_bits()\n    layeredCircuit.append(H1_circ, qubit_list)\n    from qiskit.quantum_info.operators.symplectic import Clifford\n    clifford_target = Clifford(layeredCircuit)\n    pauli_circ = _calc_pauli_diff_stabilizer(cliff, clifford_target)\n    layeredCircuit.append(pauli_circ, qubit_list)\n    return layeredCircuit",
            "def synth_stabilizer_layers(stab, cz_synth_func=_default_cz_synth_func, cz_func_reverse_qubits=False, validate=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Synthesis of a stabilizer state into layers.\\n\\n    It provides a similar decomposition to the synthesis described in Lemma 8 of Bravyi and Maslov,\\n    without the initial Hadamard-free sub-circuit which do not affect the stabilizer state.\\n\\n    For example, a 5-qubit stabilizer state is decomposed into the following layers:\\n\\n    .. parsed-literal::\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240       \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_1: \u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241       \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_2: \u25242 H2 \u251c\u25242 S1 \u251c\u25242 CZ \u251c\u25242 H1 \u251c\u25242 Pauli \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_3: \u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243       \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_4: \u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244       \u251c\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Args:\\n        stab (StabilizerState): a stabilizer state.\\n        cz_synth_func (Callable): a function to decompose the CZ sub-circuit.\\n            It gets as input a boolean symmetric matrix, and outputs a QuantumCircuit.\\n        validate (Boolean): if True, validates the synthesis process.\\n        cz_func_reverse_qubits (Boolean): True only if cz_synth_func is synth_cz_depth_line_mr,\\n            since this function returns a circuit that reverts the order of qubits.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the stabilizer state.\\n\\n    Raises:\\n        QiskitError: if the input is not a StabilizerState.\\n\\n    Reference:\\n        1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\\n           structure of the Clifford group*,\\n           `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\\n    '\n    if not isinstance(stab, StabilizerState):\n        raise QiskitError('The input is not a StabilizerState.')\n    cliff = stab.clifford\n    num_qubits = cliff.num_qubits\n    if cz_func_reverse_qubits:\n        cliff0 = _reverse_clifford(cliff)\n    else:\n        cliff0 = cliff\n    (H1_circ, cliff1) = _create_graph_state(cliff0, validate=validate)\n    (H2_circ, CZ1_circ, S1_circ, _) = _decompose_graph_state(cliff1, validate=validate, cz_synth_func=cz_synth_func)\n    qubit_list = list(range(num_qubits))\n    layeredCircuit = QuantumCircuit(num_qubits)\n    layeredCircuit.append(H2_circ, qubit_list)\n    layeredCircuit.append(S1_circ, qubit_list)\n    layeredCircuit.append(CZ1_circ, qubit_list)\n    if cz_func_reverse_qubits:\n        H1_circ = H1_circ.reverse_bits()\n    layeredCircuit.append(H1_circ, qubit_list)\n    from qiskit.quantum_info.operators.symplectic import Clifford\n    clifford_target = Clifford(layeredCircuit)\n    pauli_circ = _calc_pauli_diff_stabilizer(cliff, clifford_target)\n    layeredCircuit.append(pauli_circ, qubit_list)\n    return layeredCircuit",
            "def synth_stabilizer_layers(stab, cz_synth_func=_default_cz_synth_func, cz_func_reverse_qubits=False, validate=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Synthesis of a stabilizer state into layers.\\n\\n    It provides a similar decomposition to the synthesis described in Lemma 8 of Bravyi and Maslov,\\n    without the initial Hadamard-free sub-circuit which do not affect the stabilizer state.\\n\\n    For example, a 5-qubit stabilizer state is decomposed into the following layers:\\n\\n    .. parsed-literal::\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240       \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_1: \u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241       \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_2: \u25242 H2 \u251c\u25242 S1 \u251c\u25242 CZ \u251c\u25242 H1 \u251c\u25242 Pauli \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_3: \u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243       \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_4: \u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244       \u251c\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Args:\\n        stab (StabilizerState): a stabilizer state.\\n        cz_synth_func (Callable): a function to decompose the CZ sub-circuit.\\n            It gets as input a boolean symmetric matrix, and outputs a QuantumCircuit.\\n        validate (Boolean): if True, validates the synthesis process.\\n        cz_func_reverse_qubits (Boolean): True only if cz_synth_func is synth_cz_depth_line_mr,\\n            since this function returns a circuit that reverts the order of qubits.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the stabilizer state.\\n\\n    Raises:\\n        QiskitError: if the input is not a StabilizerState.\\n\\n    Reference:\\n        1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\\n           structure of the Clifford group*,\\n           `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\\n    '\n    if not isinstance(stab, StabilizerState):\n        raise QiskitError('The input is not a StabilizerState.')\n    cliff = stab.clifford\n    num_qubits = cliff.num_qubits\n    if cz_func_reverse_qubits:\n        cliff0 = _reverse_clifford(cliff)\n    else:\n        cliff0 = cliff\n    (H1_circ, cliff1) = _create_graph_state(cliff0, validate=validate)\n    (H2_circ, CZ1_circ, S1_circ, _) = _decompose_graph_state(cliff1, validate=validate, cz_synth_func=cz_synth_func)\n    qubit_list = list(range(num_qubits))\n    layeredCircuit = QuantumCircuit(num_qubits)\n    layeredCircuit.append(H2_circ, qubit_list)\n    layeredCircuit.append(S1_circ, qubit_list)\n    layeredCircuit.append(CZ1_circ, qubit_list)\n    if cz_func_reverse_qubits:\n        H1_circ = H1_circ.reverse_bits()\n    layeredCircuit.append(H1_circ, qubit_list)\n    from qiskit.quantum_info.operators.symplectic import Clifford\n    clifford_target = Clifford(layeredCircuit)\n    pauli_circ = _calc_pauli_diff_stabilizer(cliff, clifford_target)\n    layeredCircuit.append(pauli_circ, qubit_list)\n    return layeredCircuit",
            "def synth_stabilizer_layers(stab, cz_synth_func=_default_cz_synth_func, cz_func_reverse_qubits=False, validate=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Synthesis of a stabilizer state into layers.\\n\\n    It provides a similar decomposition to the synthesis described in Lemma 8 of Bravyi and Maslov,\\n    without the initial Hadamard-free sub-circuit which do not affect the stabilizer state.\\n\\n    For example, a 5-qubit stabilizer state is decomposed into the following layers:\\n\\n    .. parsed-literal::\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240       \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_1: \u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241       \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_2: \u25242 H2 \u251c\u25242 S1 \u251c\u25242 CZ \u251c\u25242 H1 \u251c\u25242 Pauli \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_3: \u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243       \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_4: \u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244       \u251c\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Args:\\n        stab (StabilizerState): a stabilizer state.\\n        cz_synth_func (Callable): a function to decompose the CZ sub-circuit.\\n            It gets as input a boolean symmetric matrix, and outputs a QuantumCircuit.\\n        validate (Boolean): if True, validates the synthesis process.\\n        cz_func_reverse_qubits (Boolean): True only if cz_synth_func is synth_cz_depth_line_mr,\\n            since this function returns a circuit that reverts the order of qubits.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the stabilizer state.\\n\\n    Raises:\\n        QiskitError: if the input is not a StabilizerState.\\n\\n    Reference:\\n        1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\\n           structure of the Clifford group*,\\n           `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\\n    '\n    if not isinstance(stab, StabilizerState):\n        raise QiskitError('The input is not a StabilizerState.')\n    cliff = stab.clifford\n    num_qubits = cliff.num_qubits\n    if cz_func_reverse_qubits:\n        cliff0 = _reverse_clifford(cliff)\n    else:\n        cliff0 = cliff\n    (H1_circ, cliff1) = _create_graph_state(cliff0, validate=validate)\n    (H2_circ, CZ1_circ, S1_circ, _) = _decompose_graph_state(cliff1, validate=validate, cz_synth_func=cz_synth_func)\n    qubit_list = list(range(num_qubits))\n    layeredCircuit = QuantumCircuit(num_qubits)\n    layeredCircuit.append(H2_circ, qubit_list)\n    layeredCircuit.append(S1_circ, qubit_list)\n    layeredCircuit.append(CZ1_circ, qubit_list)\n    if cz_func_reverse_qubits:\n        H1_circ = H1_circ.reverse_bits()\n    layeredCircuit.append(H1_circ, qubit_list)\n    from qiskit.quantum_info.operators.symplectic import Clifford\n    clifford_target = Clifford(layeredCircuit)\n    pauli_circ = _calc_pauli_diff_stabilizer(cliff, clifford_target)\n    layeredCircuit.append(pauli_circ, qubit_list)\n    return layeredCircuit",
            "def synth_stabilizer_layers(stab, cz_synth_func=_default_cz_synth_func, cz_func_reverse_qubits=False, validate=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Synthesis of a stabilizer state into layers.\\n\\n    It provides a similar decomposition to the synthesis described in Lemma 8 of Bravyi and Maslov,\\n    without the initial Hadamard-free sub-circuit which do not affect the stabilizer state.\\n\\n    For example, a 5-qubit stabilizer state is decomposed into the following layers:\\n\\n    .. parsed-literal::\\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n        q_0: \u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240    \u251c\u25240       \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_1: \u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241    \u251c\u25241       \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_2: \u25242 H2 \u251c\u25242 S1 \u251c\u25242 CZ \u251c\u25242 H1 \u251c\u25242 Pauli \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_3: \u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243    \u251c\u25243       \u251c\\n             \u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502     \u2502\u2502        \u2502\\n        q_4: \u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244    \u251c\u25244       \u251c\\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n    Args:\\n        stab (StabilizerState): a stabilizer state.\\n        cz_synth_func (Callable): a function to decompose the CZ sub-circuit.\\n            It gets as input a boolean symmetric matrix, and outputs a QuantumCircuit.\\n        validate (Boolean): if True, validates the synthesis process.\\n        cz_func_reverse_qubits (Boolean): True only if cz_synth_func is synth_cz_depth_line_mr,\\n            since this function returns a circuit that reverts the order of qubits.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the stabilizer state.\\n\\n    Raises:\\n        QiskitError: if the input is not a StabilizerState.\\n\\n    Reference:\\n        1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\\n           structure of the Clifford group*,\\n           `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\\n    '\n    if not isinstance(stab, StabilizerState):\n        raise QiskitError('The input is not a StabilizerState.')\n    cliff = stab.clifford\n    num_qubits = cliff.num_qubits\n    if cz_func_reverse_qubits:\n        cliff0 = _reverse_clifford(cliff)\n    else:\n        cliff0 = cliff\n    (H1_circ, cliff1) = _create_graph_state(cliff0, validate=validate)\n    (H2_circ, CZ1_circ, S1_circ, _) = _decompose_graph_state(cliff1, validate=validate, cz_synth_func=cz_synth_func)\n    qubit_list = list(range(num_qubits))\n    layeredCircuit = QuantumCircuit(num_qubits)\n    layeredCircuit.append(H2_circ, qubit_list)\n    layeredCircuit.append(S1_circ, qubit_list)\n    layeredCircuit.append(CZ1_circ, qubit_list)\n    if cz_func_reverse_qubits:\n        H1_circ = H1_circ.reverse_bits()\n    layeredCircuit.append(H1_circ, qubit_list)\n    from qiskit.quantum_info.operators.symplectic import Clifford\n    clifford_target = Clifford(layeredCircuit)\n    pauli_circ = _calc_pauli_diff_stabilizer(cliff, clifford_target)\n    layeredCircuit.append(pauli_circ, qubit_list)\n    return layeredCircuit"
        ]
    },
    {
        "func_name": "_calc_pauli_diff_stabilizer",
        "original": "def _calc_pauli_diff_stabilizer(cliff, cliff_target):\n    \"\"\"Given two Cliffords whose stabilizers differ by a Pauli, we find this Pauli.\"\"\"\n    from qiskit.quantum_info.operators.symplectic import Pauli\n    num_qubits = cliff.num_qubits\n    if cliff.num_qubits != cliff_target.num_qubits:\n        raise QiskitError('num_qubits is not the same for the original clifford and the target.')\n    stab_gen = StabilizerState(cliff).clifford.to_dict()['stabilizer']\n    ts = StabilizerState(cliff_target)\n    phase_destab = [False] * num_qubits\n    phase_stab = [ts.expectation_value(Pauli(stab_gen[i])) == -1 for i in range(num_qubits)]\n    phase = []\n    phase.extend(phase_destab)\n    phase.extend(phase_stab)\n    phase = np.array(phase, dtype=int)\n    A = cliff.symplectic_matrix.astype(int)\n    Ainv = calc_inverse_matrix(A)\n    C = np.matmul(Ainv, phase) % 2\n    pauli_circ = QuantumCircuit(num_qubits, name='Pauli')\n    for k in range(num_qubits):\n        destab = C[k]\n        stab = C[k + num_qubits]\n        if stab and destab:\n            pauli_circ.y(k)\n        elif stab:\n            pauli_circ.x(k)\n        elif destab:\n            pauli_circ.z(k)\n    return pauli_circ",
        "mutated": [
            "def _calc_pauli_diff_stabilizer(cliff, cliff_target):\n    if False:\n        i = 10\n    'Given two Cliffords whose stabilizers differ by a Pauli, we find this Pauli.'\n    from qiskit.quantum_info.operators.symplectic import Pauli\n    num_qubits = cliff.num_qubits\n    if cliff.num_qubits != cliff_target.num_qubits:\n        raise QiskitError('num_qubits is not the same for the original clifford and the target.')\n    stab_gen = StabilizerState(cliff).clifford.to_dict()['stabilizer']\n    ts = StabilizerState(cliff_target)\n    phase_destab = [False] * num_qubits\n    phase_stab = [ts.expectation_value(Pauli(stab_gen[i])) == -1 for i in range(num_qubits)]\n    phase = []\n    phase.extend(phase_destab)\n    phase.extend(phase_stab)\n    phase = np.array(phase, dtype=int)\n    A = cliff.symplectic_matrix.astype(int)\n    Ainv = calc_inverse_matrix(A)\n    C = np.matmul(Ainv, phase) % 2\n    pauli_circ = QuantumCircuit(num_qubits, name='Pauli')\n    for k in range(num_qubits):\n        destab = C[k]\n        stab = C[k + num_qubits]\n        if stab and destab:\n            pauli_circ.y(k)\n        elif stab:\n            pauli_circ.x(k)\n        elif destab:\n            pauli_circ.z(k)\n    return pauli_circ",
            "def _calc_pauli_diff_stabilizer(cliff, cliff_target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Given two Cliffords whose stabilizers differ by a Pauli, we find this Pauli.'\n    from qiskit.quantum_info.operators.symplectic import Pauli\n    num_qubits = cliff.num_qubits\n    if cliff.num_qubits != cliff_target.num_qubits:\n        raise QiskitError('num_qubits is not the same for the original clifford and the target.')\n    stab_gen = StabilizerState(cliff).clifford.to_dict()['stabilizer']\n    ts = StabilizerState(cliff_target)\n    phase_destab = [False] * num_qubits\n    phase_stab = [ts.expectation_value(Pauli(stab_gen[i])) == -1 for i in range(num_qubits)]\n    phase = []\n    phase.extend(phase_destab)\n    phase.extend(phase_stab)\n    phase = np.array(phase, dtype=int)\n    A = cliff.symplectic_matrix.astype(int)\n    Ainv = calc_inverse_matrix(A)\n    C = np.matmul(Ainv, phase) % 2\n    pauli_circ = QuantumCircuit(num_qubits, name='Pauli')\n    for k in range(num_qubits):\n        destab = C[k]\n        stab = C[k + num_qubits]\n        if stab and destab:\n            pauli_circ.y(k)\n        elif stab:\n            pauli_circ.x(k)\n        elif destab:\n            pauli_circ.z(k)\n    return pauli_circ",
            "def _calc_pauli_diff_stabilizer(cliff, cliff_target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Given two Cliffords whose stabilizers differ by a Pauli, we find this Pauli.'\n    from qiskit.quantum_info.operators.symplectic import Pauli\n    num_qubits = cliff.num_qubits\n    if cliff.num_qubits != cliff_target.num_qubits:\n        raise QiskitError('num_qubits is not the same for the original clifford and the target.')\n    stab_gen = StabilizerState(cliff).clifford.to_dict()['stabilizer']\n    ts = StabilizerState(cliff_target)\n    phase_destab = [False] * num_qubits\n    phase_stab = [ts.expectation_value(Pauli(stab_gen[i])) == -1 for i in range(num_qubits)]\n    phase = []\n    phase.extend(phase_destab)\n    phase.extend(phase_stab)\n    phase = np.array(phase, dtype=int)\n    A = cliff.symplectic_matrix.astype(int)\n    Ainv = calc_inverse_matrix(A)\n    C = np.matmul(Ainv, phase) % 2\n    pauli_circ = QuantumCircuit(num_qubits, name='Pauli')\n    for k in range(num_qubits):\n        destab = C[k]\n        stab = C[k + num_qubits]\n        if stab and destab:\n            pauli_circ.y(k)\n        elif stab:\n            pauli_circ.x(k)\n        elif destab:\n            pauli_circ.z(k)\n    return pauli_circ",
            "def _calc_pauli_diff_stabilizer(cliff, cliff_target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Given two Cliffords whose stabilizers differ by a Pauli, we find this Pauli.'\n    from qiskit.quantum_info.operators.symplectic import Pauli\n    num_qubits = cliff.num_qubits\n    if cliff.num_qubits != cliff_target.num_qubits:\n        raise QiskitError('num_qubits is not the same for the original clifford and the target.')\n    stab_gen = StabilizerState(cliff).clifford.to_dict()['stabilizer']\n    ts = StabilizerState(cliff_target)\n    phase_destab = [False] * num_qubits\n    phase_stab = [ts.expectation_value(Pauli(stab_gen[i])) == -1 for i in range(num_qubits)]\n    phase = []\n    phase.extend(phase_destab)\n    phase.extend(phase_stab)\n    phase = np.array(phase, dtype=int)\n    A = cliff.symplectic_matrix.astype(int)\n    Ainv = calc_inverse_matrix(A)\n    C = np.matmul(Ainv, phase) % 2\n    pauli_circ = QuantumCircuit(num_qubits, name='Pauli')\n    for k in range(num_qubits):\n        destab = C[k]\n        stab = C[k + num_qubits]\n        if stab and destab:\n            pauli_circ.y(k)\n        elif stab:\n            pauli_circ.x(k)\n        elif destab:\n            pauli_circ.z(k)\n    return pauli_circ",
            "def _calc_pauli_diff_stabilizer(cliff, cliff_target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Given two Cliffords whose stabilizers differ by a Pauli, we find this Pauli.'\n    from qiskit.quantum_info.operators.symplectic import Pauli\n    num_qubits = cliff.num_qubits\n    if cliff.num_qubits != cliff_target.num_qubits:\n        raise QiskitError('num_qubits is not the same for the original clifford and the target.')\n    stab_gen = StabilizerState(cliff).clifford.to_dict()['stabilizer']\n    ts = StabilizerState(cliff_target)\n    phase_destab = [False] * num_qubits\n    phase_stab = [ts.expectation_value(Pauli(stab_gen[i])) == -1 for i in range(num_qubits)]\n    phase = []\n    phase.extend(phase_destab)\n    phase.extend(phase_stab)\n    phase = np.array(phase, dtype=int)\n    A = cliff.symplectic_matrix.astype(int)\n    Ainv = calc_inverse_matrix(A)\n    C = np.matmul(Ainv, phase) % 2\n    pauli_circ = QuantumCircuit(num_qubits, name='Pauli')\n    for k in range(num_qubits):\n        destab = C[k]\n        stab = C[k + num_qubits]\n        if stab and destab:\n            pauli_circ.y(k)\n        elif stab:\n            pauli_circ.x(k)\n        elif destab:\n            pauli_circ.z(k)\n    return pauli_circ"
        ]
    },
    {
        "func_name": "synth_stabilizer_depth_lnn",
        "original": "def synth_stabilizer_depth_lnn(stab):\n    \"\"\"Synthesis of an n-qubit stabilizer state for linear-nearest neighbour connectivity,\n    in 2-qubit depth 2*n+2 and two distinct CX layers, using CX and phase gates (S, Sdg or Z).\n\n    Args:\n        stab (StabilizerState): a stabilizer state.\n\n    Return:\n        QuantumCircuit: a circuit implementation of the stabilizer state.\n\n    Reference:\n        1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\n           structure of the Clifford group*,\n           `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\n        2. Dmitri Maslov, Martin Roetteler,\n           *Shorter stabilizer circuits via Bruhat decomposition and quantum circuit transformations*,\n           `arXiv:1705.09176 <https://arxiv.org/abs/1705.09176>`_.\n    \"\"\"\n    circ = synth_stabilizer_layers(stab, cz_synth_func=synth_cz_depth_line_mr, cz_func_reverse_qubits=True)\n    return circ",
        "mutated": [
            "def synth_stabilizer_depth_lnn(stab):\n    if False:\n        i = 10\n    'Synthesis of an n-qubit stabilizer state for linear-nearest neighbour connectivity,\\n    in 2-qubit depth 2*n+2 and two distinct CX layers, using CX and phase gates (S, Sdg or Z).\\n\\n    Args:\\n        stab (StabilizerState): a stabilizer state.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the stabilizer state.\\n\\n    Reference:\\n        1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\\n           structure of the Clifford group*,\\n           `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\\n        2. Dmitri Maslov, Martin Roetteler,\\n           *Shorter stabilizer circuits via Bruhat decomposition and quantum circuit transformations*,\\n           `arXiv:1705.09176 <https://arxiv.org/abs/1705.09176>`_.\\n    '\n    circ = synth_stabilizer_layers(stab, cz_synth_func=synth_cz_depth_line_mr, cz_func_reverse_qubits=True)\n    return circ",
            "def synth_stabilizer_depth_lnn(stab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Synthesis of an n-qubit stabilizer state for linear-nearest neighbour connectivity,\\n    in 2-qubit depth 2*n+2 and two distinct CX layers, using CX and phase gates (S, Sdg or Z).\\n\\n    Args:\\n        stab (StabilizerState): a stabilizer state.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the stabilizer state.\\n\\n    Reference:\\n        1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\\n           structure of the Clifford group*,\\n           `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\\n        2. Dmitri Maslov, Martin Roetteler,\\n           *Shorter stabilizer circuits via Bruhat decomposition and quantum circuit transformations*,\\n           `arXiv:1705.09176 <https://arxiv.org/abs/1705.09176>`_.\\n    '\n    circ = synth_stabilizer_layers(stab, cz_synth_func=synth_cz_depth_line_mr, cz_func_reverse_qubits=True)\n    return circ",
            "def synth_stabilizer_depth_lnn(stab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Synthesis of an n-qubit stabilizer state for linear-nearest neighbour connectivity,\\n    in 2-qubit depth 2*n+2 and two distinct CX layers, using CX and phase gates (S, Sdg or Z).\\n\\n    Args:\\n        stab (StabilizerState): a stabilizer state.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the stabilizer state.\\n\\n    Reference:\\n        1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\\n           structure of the Clifford group*,\\n           `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\\n        2. Dmitri Maslov, Martin Roetteler,\\n           *Shorter stabilizer circuits via Bruhat decomposition and quantum circuit transformations*,\\n           `arXiv:1705.09176 <https://arxiv.org/abs/1705.09176>`_.\\n    '\n    circ = synth_stabilizer_layers(stab, cz_synth_func=synth_cz_depth_line_mr, cz_func_reverse_qubits=True)\n    return circ",
            "def synth_stabilizer_depth_lnn(stab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Synthesis of an n-qubit stabilizer state for linear-nearest neighbour connectivity,\\n    in 2-qubit depth 2*n+2 and two distinct CX layers, using CX and phase gates (S, Sdg or Z).\\n\\n    Args:\\n        stab (StabilizerState): a stabilizer state.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the stabilizer state.\\n\\n    Reference:\\n        1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\\n           structure of the Clifford group*,\\n           `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\\n        2. Dmitri Maslov, Martin Roetteler,\\n           *Shorter stabilizer circuits via Bruhat decomposition and quantum circuit transformations*,\\n           `arXiv:1705.09176 <https://arxiv.org/abs/1705.09176>`_.\\n    '\n    circ = synth_stabilizer_layers(stab, cz_synth_func=synth_cz_depth_line_mr, cz_func_reverse_qubits=True)\n    return circ",
            "def synth_stabilizer_depth_lnn(stab):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Synthesis of an n-qubit stabilizer state for linear-nearest neighbour connectivity,\\n    in 2-qubit depth 2*n+2 and two distinct CX layers, using CX and phase gates (S, Sdg or Z).\\n\\n    Args:\\n        stab (StabilizerState): a stabilizer state.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the stabilizer state.\\n\\n    Reference:\\n        1. S. Bravyi, D. Maslov, *Hadamard-free circuits expose the\\n           structure of the Clifford group*,\\n           `arXiv:2003.09412 [quant-ph] <https://arxiv.org/abs/2003.09412>`_\\n        2. Dmitri Maslov, Martin Roetteler,\\n           *Shorter stabilizer circuits via Bruhat decomposition and quantum circuit transformations*,\\n           `arXiv:1705.09176 <https://arxiv.org/abs/1705.09176>`_.\\n    '\n    circ = synth_stabilizer_layers(stab, cz_synth_func=synth_cz_depth_line_mr, cz_func_reverse_qubits=True)\n    return circ"
        ]
    }
]