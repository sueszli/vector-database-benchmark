[
    {
        "func_name": "read_geojson",
        "original": "def read_geojson(file):\n    \"\"\"\n    file : str, path to file with the geojson with the polygon and the cat rate\n    loc_dat : dict, contains for each zone the polygon and the rates of the local cat\n    \"\"\"\n    with open(file) as f:\n        gj = geojson.load(f)\n    zones = gj['features']\n    loc_cat = {}\n    for zone in zones:\n        if 'rate_cat' in zone['properties'].keys():\n            cat_rates = zone['properties']['rate_cat']\n        else:\n            cat_rates = False\n        loc_cat.update({zone['properties']['id']: {'cat_rates': cat_rates, 'poly': zone['geometry']['coordinates']}})\n    return loc_cat",
        "mutated": [
            "def read_geojson(file):\n    if False:\n        i = 10\n    '\\n    file : str, path to file with the geojson with the polygon and the cat rate\\n    loc_dat : dict, contains for each zone the polygon and the rates of the local cat\\n    '\n    with open(file) as f:\n        gj = geojson.load(f)\n    zones = gj['features']\n    loc_cat = {}\n    for zone in zones:\n        if 'rate_cat' in zone['properties'].keys():\n            cat_rates = zone['properties']['rate_cat']\n        else:\n            cat_rates = False\n        loc_cat.update({zone['properties']['id']: {'cat_rates': cat_rates, 'poly': zone['geometry']['coordinates']}})\n    return loc_cat",
            "def read_geojson(file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    file : str, path to file with the geojson with the polygon and the cat rate\\n    loc_dat : dict, contains for each zone the polygon and the rates of the local cat\\n    '\n    with open(file) as f:\n        gj = geojson.load(f)\n    zones = gj['features']\n    loc_cat = {}\n    for zone in zones:\n        if 'rate_cat' in zone['properties'].keys():\n            cat_rates = zone['properties']['rate_cat']\n        else:\n            cat_rates = False\n        loc_cat.update({zone['properties']['id']: {'cat_rates': cat_rates, 'poly': zone['geometry']['coordinates']}})\n    return loc_cat",
            "def read_geojson(file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    file : str, path to file with the geojson with the polygon and the cat rate\\n    loc_dat : dict, contains for each zone the polygon and the rates of the local cat\\n    '\n    with open(file) as f:\n        gj = geojson.load(f)\n    zones = gj['features']\n    loc_cat = {}\n    for zone in zones:\n        if 'rate_cat' in zone['properties'].keys():\n            cat_rates = zone['properties']['rate_cat']\n        else:\n            cat_rates = False\n        loc_cat.update({zone['properties']['id']: {'cat_rates': cat_rates, 'poly': zone['geometry']['coordinates']}})\n    return loc_cat",
            "def read_geojson(file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    file : str, path to file with the geojson with the polygon and the cat rate\\n    loc_dat : dict, contains for each zone the polygon and the rates of the local cat\\n    '\n    with open(file) as f:\n        gj = geojson.load(f)\n    zones = gj['features']\n    loc_cat = {}\n    for zone in zones:\n        if 'rate_cat' in zone['properties'].keys():\n            cat_rates = zone['properties']['rate_cat']\n        else:\n            cat_rates = False\n        loc_cat.update({zone['properties']['id']: {'cat_rates': cat_rates, 'poly': zone['geometry']['coordinates']}})\n    return loc_cat",
            "def read_geojson(file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    file : str, path to file with the geojson with the polygon and the cat rate\\n    loc_dat : dict, contains for each zone the polygon and the rates of the local cat\\n    '\n    with open(file) as f:\n        gj = geojson.load(f)\n    zones = gj['features']\n    loc_cat = {}\n    for zone in zones:\n        if 'rate_cat' in zone['properties'].keys():\n            cat_rates = zone['properties']['rate_cat']\n        else:\n            cat_rates = False\n        loc_cat.update({zone['properties']['id']: {'cat_rates': cat_rates, 'poly': zone['geometry']['coordinates']}})\n    return loc_cat"
        ]
    },
    {
        "func_name": "get_model_rate",
        "original": "def get_model_rate(poly, OQ_entry_faults, OQ_entry_scenarios, pts_list, bin_mag, param, faults_data, faults_names, index_faults_in_scenario, local_zone_mfd):\n    \"\"\"\n    poly : polypath , polygon of the zone\n    OQ_entry_faults : list, rates and info on each single fault rupture\n    OQ_entry_scenarios : list, rates and info on each complex fault rupture\n    pts_list : dict, info and rates of the bg points\n    param : dict, parameters used in this run\n    bin_mag : list, bining in magnitude\n    faults_data : dict, data of the faults\n    faults_names : list , list of the names of the faults\n    index_faults_in_scenario : list, list of the indexes of faults for each scenario\n    local_zone_mfd : list, mfd of the bg seismicity if bg was (or is) a uiform zone\n\n    \"\"\"\n    rate_bg = np.zeros_like(bin_mag)\n    smooth = np.zeros_like(bin_mag)\n    if param['main']['background']['option_bg'] == 'smooth':\n        txt_no_bg = ''\n        for lon_lat in pts_list.keys():\n            lon = float(lon_lat.split('_')[0])\n            lat = float(lon_lat.split('_')[1])\n            if poly.contains_point((lon, lat)) == 1:\n                scaled_mfd = pts_list[lon_lat]['scaled_mfd']\n                mfd_smooth = pts_list[lon_lat]['mfd_smooth']\n                i_mag = 0\n                for r in scaled_mfd:\n                    rate_bg[i_mag] += r\n                    i_mag += 1\n                i_mag = 0\n                for r in mfd_smooth:\n                    smooth[i_mag] += r\n                    i_mag += 1\n    elif param['main']['background']['option_bg'] == 'zone':\n        txt_no_bg = ''\n        rate_bg = local_zone_mfd\n    else:\n        txt_no_bg = ' BG NOT INCLUDED'\n    rate_faults = np.zeros_like(bin_mag)\n    for (index_fault, fault_name) in zip(range(len(faults_names)), faults_names):\n        f_in = False\n        stop_loop = False\n        while stop_loop == False:\n            lons = faults_data[index_fault]['lon']\n            lats = faults_data[index_fault]['lat']\n            for (lon, lat) in zip(lons, lats):\n                if poly.contains_point((lon, lat)) == 1:\n                    f_in = True\n                    stop_loop = True\n            stop_loop = True\n        if f_in == True:\n            i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n            MFD = OQ_entry_faults[i_MFD]\n            i_mag = 0\n            for r in MFD:\n                rate_faults[i_mag] += MFD[i_mag]\n                i_mag += 1\n    if len(index_faults_in_scenario) != 0:\n        index_scenario = 0\n        for index_faults_in_sc in index_faults_in_scenario:\n            faults_in_poly = 0\n            for index_fault in index_faults_in_sc[0]:\n                f_in = False\n                stop_loop = False\n                while stop_loop == False:\n                    lons = faults_data[index_fault]['lon']\n                    lats = faults_data[index_fault]['lat']\n                    for (lon, lat) in zip(lons, lats):\n                        if poly.contains_point((lon, lat)) == 1:\n                            f_in = True\n                            stop_loop = True\n                    stop_loop = True\n                if f_in == True:\n                    faults_in_poly += 1\n            if faults_in_poly != 0:\n                MFD = OQ_entry_scenarios[index_scenario]\n                i_mag = 0\n                for r in MFD:\n                    rate_faults[i_mag] += MFD[i_mag] * float(faults_in_poly) / float(len(index_faults_in_sc[0]))\n                    i_mag += 1\n            index_scenario += 1\n    return (txt_no_bg, rate_faults, rate_bg, smooth)",
        "mutated": [
            "def get_model_rate(poly, OQ_entry_faults, OQ_entry_scenarios, pts_list, bin_mag, param, faults_data, faults_names, index_faults_in_scenario, local_zone_mfd):\n    if False:\n        i = 10\n    '\\n    poly : polypath , polygon of the zone\\n    OQ_entry_faults : list, rates and info on each single fault rupture\\n    OQ_entry_scenarios : list, rates and info on each complex fault rupture\\n    pts_list : dict, info and rates of the bg points\\n    param : dict, parameters used in this run\\n    bin_mag : list, bining in magnitude\\n    faults_data : dict, data of the faults\\n    faults_names : list , list of the names of the faults\\n    index_faults_in_scenario : list, list of the indexes of faults for each scenario\\n    local_zone_mfd : list, mfd of the bg seismicity if bg was (or is) a uiform zone\\n\\n    '\n    rate_bg = np.zeros_like(bin_mag)\n    smooth = np.zeros_like(bin_mag)\n    if param['main']['background']['option_bg'] == 'smooth':\n        txt_no_bg = ''\n        for lon_lat in pts_list.keys():\n            lon = float(lon_lat.split('_')[0])\n            lat = float(lon_lat.split('_')[1])\n            if poly.contains_point((lon, lat)) == 1:\n                scaled_mfd = pts_list[lon_lat]['scaled_mfd']\n                mfd_smooth = pts_list[lon_lat]['mfd_smooth']\n                i_mag = 0\n                for r in scaled_mfd:\n                    rate_bg[i_mag] += r\n                    i_mag += 1\n                i_mag = 0\n                for r in mfd_smooth:\n                    smooth[i_mag] += r\n                    i_mag += 1\n    elif param['main']['background']['option_bg'] == 'zone':\n        txt_no_bg = ''\n        rate_bg = local_zone_mfd\n    else:\n        txt_no_bg = ' BG NOT INCLUDED'\n    rate_faults = np.zeros_like(bin_mag)\n    for (index_fault, fault_name) in zip(range(len(faults_names)), faults_names):\n        f_in = False\n        stop_loop = False\n        while stop_loop == False:\n            lons = faults_data[index_fault]['lon']\n            lats = faults_data[index_fault]['lat']\n            for (lon, lat) in zip(lons, lats):\n                if poly.contains_point((lon, lat)) == 1:\n                    f_in = True\n                    stop_loop = True\n            stop_loop = True\n        if f_in == True:\n            i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n            MFD = OQ_entry_faults[i_MFD]\n            i_mag = 0\n            for r in MFD:\n                rate_faults[i_mag] += MFD[i_mag]\n                i_mag += 1\n    if len(index_faults_in_scenario) != 0:\n        index_scenario = 0\n        for index_faults_in_sc in index_faults_in_scenario:\n            faults_in_poly = 0\n            for index_fault in index_faults_in_sc[0]:\n                f_in = False\n                stop_loop = False\n                while stop_loop == False:\n                    lons = faults_data[index_fault]['lon']\n                    lats = faults_data[index_fault]['lat']\n                    for (lon, lat) in zip(lons, lats):\n                        if poly.contains_point((lon, lat)) == 1:\n                            f_in = True\n                            stop_loop = True\n                    stop_loop = True\n                if f_in == True:\n                    faults_in_poly += 1\n            if faults_in_poly != 0:\n                MFD = OQ_entry_scenarios[index_scenario]\n                i_mag = 0\n                for r in MFD:\n                    rate_faults[i_mag] += MFD[i_mag] * float(faults_in_poly) / float(len(index_faults_in_sc[0]))\n                    i_mag += 1\n            index_scenario += 1\n    return (txt_no_bg, rate_faults, rate_bg, smooth)",
            "def get_model_rate(poly, OQ_entry_faults, OQ_entry_scenarios, pts_list, bin_mag, param, faults_data, faults_names, index_faults_in_scenario, local_zone_mfd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    poly : polypath , polygon of the zone\\n    OQ_entry_faults : list, rates and info on each single fault rupture\\n    OQ_entry_scenarios : list, rates and info on each complex fault rupture\\n    pts_list : dict, info and rates of the bg points\\n    param : dict, parameters used in this run\\n    bin_mag : list, bining in magnitude\\n    faults_data : dict, data of the faults\\n    faults_names : list , list of the names of the faults\\n    index_faults_in_scenario : list, list of the indexes of faults for each scenario\\n    local_zone_mfd : list, mfd of the bg seismicity if bg was (or is) a uiform zone\\n\\n    '\n    rate_bg = np.zeros_like(bin_mag)\n    smooth = np.zeros_like(bin_mag)\n    if param['main']['background']['option_bg'] == 'smooth':\n        txt_no_bg = ''\n        for lon_lat in pts_list.keys():\n            lon = float(lon_lat.split('_')[0])\n            lat = float(lon_lat.split('_')[1])\n            if poly.contains_point((lon, lat)) == 1:\n                scaled_mfd = pts_list[lon_lat]['scaled_mfd']\n                mfd_smooth = pts_list[lon_lat]['mfd_smooth']\n                i_mag = 0\n                for r in scaled_mfd:\n                    rate_bg[i_mag] += r\n                    i_mag += 1\n                i_mag = 0\n                for r in mfd_smooth:\n                    smooth[i_mag] += r\n                    i_mag += 1\n    elif param['main']['background']['option_bg'] == 'zone':\n        txt_no_bg = ''\n        rate_bg = local_zone_mfd\n    else:\n        txt_no_bg = ' BG NOT INCLUDED'\n    rate_faults = np.zeros_like(bin_mag)\n    for (index_fault, fault_name) in zip(range(len(faults_names)), faults_names):\n        f_in = False\n        stop_loop = False\n        while stop_loop == False:\n            lons = faults_data[index_fault]['lon']\n            lats = faults_data[index_fault]['lat']\n            for (lon, lat) in zip(lons, lats):\n                if poly.contains_point((lon, lat)) == 1:\n                    f_in = True\n                    stop_loop = True\n            stop_loop = True\n        if f_in == True:\n            i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n            MFD = OQ_entry_faults[i_MFD]\n            i_mag = 0\n            for r in MFD:\n                rate_faults[i_mag] += MFD[i_mag]\n                i_mag += 1\n    if len(index_faults_in_scenario) != 0:\n        index_scenario = 0\n        for index_faults_in_sc in index_faults_in_scenario:\n            faults_in_poly = 0\n            for index_fault in index_faults_in_sc[0]:\n                f_in = False\n                stop_loop = False\n                while stop_loop == False:\n                    lons = faults_data[index_fault]['lon']\n                    lats = faults_data[index_fault]['lat']\n                    for (lon, lat) in zip(lons, lats):\n                        if poly.contains_point((lon, lat)) == 1:\n                            f_in = True\n                            stop_loop = True\n                    stop_loop = True\n                if f_in == True:\n                    faults_in_poly += 1\n            if faults_in_poly != 0:\n                MFD = OQ_entry_scenarios[index_scenario]\n                i_mag = 0\n                for r in MFD:\n                    rate_faults[i_mag] += MFD[i_mag] * float(faults_in_poly) / float(len(index_faults_in_sc[0]))\n                    i_mag += 1\n            index_scenario += 1\n    return (txt_no_bg, rate_faults, rate_bg, smooth)",
            "def get_model_rate(poly, OQ_entry_faults, OQ_entry_scenarios, pts_list, bin_mag, param, faults_data, faults_names, index_faults_in_scenario, local_zone_mfd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    poly : polypath , polygon of the zone\\n    OQ_entry_faults : list, rates and info on each single fault rupture\\n    OQ_entry_scenarios : list, rates and info on each complex fault rupture\\n    pts_list : dict, info and rates of the bg points\\n    param : dict, parameters used in this run\\n    bin_mag : list, bining in magnitude\\n    faults_data : dict, data of the faults\\n    faults_names : list , list of the names of the faults\\n    index_faults_in_scenario : list, list of the indexes of faults for each scenario\\n    local_zone_mfd : list, mfd of the bg seismicity if bg was (or is) a uiform zone\\n\\n    '\n    rate_bg = np.zeros_like(bin_mag)\n    smooth = np.zeros_like(bin_mag)\n    if param['main']['background']['option_bg'] == 'smooth':\n        txt_no_bg = ''\n        for lon_lat in pts_list.keys():\n            lon = float(lon_lat.split('_')[0])\n            lat = float(lon_lat.split('_')[1])\n            if poly.contains_point((lon, lat)) == 1:\n                scaled_mfd = pts_list[lon_lat]['scaled_mfd']\n                mfd_smooth = pts_list[lon_lat]['mfd_smooth']\n                i_mag = 0\n                for r in scaled_mfd:\n                    rate_bg[i_mag] += r\n                    i_mag += 1\n                i_mag = 0\n                for r in mfd_smooth:\n                    smooth[i_mag] += r\n                    i_mag += 1\n    elif param['main']['background']['option_bg'] == 'zone':\n        txt_no_bg = ''\n        rate_bg = local_zone_mfd\n    else:\n        txt_no_bg = ' BG NOT INCLUDED'\n    rate_faults = np.zeros_like(bin_mag)\n    for (index_fault, fault_name) in zip(range(len(faults_names)), faults_names):\n        f_in = False\n        stop_loop = False\n        while stop_loop == False:\n            lons = faults_data[index_fault]['lon']\n            lats = faults_data[index_fault]['lat']\n            for (lon, lat) in zip(lons, lats):\n                if poly.contains_point((lon, lat)) == 1:\n                    f_in = True\n                    stop_loop = True\n            stop_loop = True\n        if f_in == True:\n            i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n            MFD = OQ_entry_faults[i_MFD]\n            i_mag = 0\n            for r in MFD:\n                rate_faults[i_mag] += MFD[i_mag]\n                i_mag += 1\n    if len(index_faults_in_scenario) != 0:\n        index_scenario = 0\n        for index_faults_in_sc in index_faults_in_scenario:\n            faults_in_poly = 0\n            for index_fault in index_faults_in_sc[0]:\n                f_in = False\n                stop_loop = False\n                while stop_loop == False:\n                    lons = faults_data[index_fault]['lon']\n                    lats = faults_data[index_fault]['lat']\n                    for (lon, lat) in zip(lons, lats):\n                        if poly.contains_point((lon, lat)) == 1:\n                            f_in = True\n                            stop_loop = True\n                    stop_loop = True\n                if f_in == True:\n                    faults_in_poly += 1\n            if faults_in_poly != 0:\n                MFD = OQ_entry_scenarios[index_scenario]\n                i_mag = 0\n                for r in MFD:\n                    rate_faults[i_mag] += MFD[i_mag] * float(faults_in_poly) / float(len(index_faults_in_sc[0]))\n                    i_mag += 1\n            index_scenario += 1\n    return (txt_no_bg, rate_faults, rate_bg, smooth)",
            "def get_model_rate(poly, OQ_entry_faults, OQ_entry_scenarios, pts_list, bin_mag, param, faults_data, faults_names, index_faults_in_scenario, local_zone_mfd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    poly : polypath , polygon of the zone\\n    OQ_entry_faults : list, rates and info on each single fault rupture\\n    OQ_entry_scenarios : list, rates and info on each complex fault rupture\\n    pts_list : dict, info and rates of the bg points\\n    param : dict, parameters used in this run\\n    bin_mag : list, bining in magnitude\\n    faults_data : dict, data of the faults\\n    faults_names : list , list of the names of the faults\\n    index_faults_in_scenario : list, list of the indexes of faults for each scenario\\n    local_zone_mfd : list, mfd of the bg seismicity if bg was (or is) a uiform zone\\n\\n    '\n    rate_bg = np.zeros_like(bin_mag)\n    smooth = np.zeros_like(bin_mag)\n    if param['main']['background']['option_bg'] == 'smooth':\n        txt_no_bg = ''\n        for lon_lat in pts_list.keys():\n            lon = float(lon_lat.split('_')[0])\n            lat = float(lon_lat.split('_')[1])\n            if poly.contains_point((lon, lat)) == 1:\n                scaled_mfd = pts_list[lon_lat]['scaled_mfd']\n                mfd_smooth = pts_list[lon_lat]['mfd_smooth']\n                i_mag = 0\n                for r in scaled_mfd:\n                    rate_bg[i_mag] += r\n                    i_mag += 1\n                i_mag = 0\n                for r in mfd_smooth:\n                    smooth[i_mag] += r\n                    i_mag += 1\n    elif param['main']['background']['option_bg'] == 'zone':\n        txt_no_bg = ''\n        rate_bg = local_zone_mfd\n    else:\n        txt_no_bg = ' BG NOT INCLUDED'\n    rate_faults = np.zeros_like(bin_mag)\n    for (index_fault, fault_name) in zip(range(len(faults_names)), faults_names):\n        f_in = False\n        stop_loop = False\n        while stop_loop == False:\n            lons = faults_data[index_fault]['lon']\n            lats = faults_data[index_fault]['lat']\n            for (lon, lat) in zip(lons, lats):\n                if poly.contains_point((lon, lat)) == 1:\n                    f_in = True\n                    stop_loop = True\n            stop_loop = True\n        if f_in == True:\n            i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n            MFD = OQ_entry_faults[i_MFD]\n            i_mag = 0\n            for r in MFD:\n                rate_faults[i_mag] += MFD[i_mag]\n                i_mag += 1\n    if len(index_faults_in_scenario) != 0:\n        index_scenario = 0\n        for index_faults_in_sc in index_faults_in_scenario:\n            faults_in_poly = 0\n            for index_fault in index_faults_in_sc[0]:\n                f_in = False\n                stop_loop = False\n                while stop_loop == False:\n                    lons = faults_data[index_fault]['lon']\n                    lats = faults_data[index_fault]['lat']\n                    for (lon, lat) in zip(lons, lats):\n                        if poly.contains_point((lon, lat)) == 1:\n                            f_in = True\n                            stop_loop = True\n                    stop_loop = True\n                if f_in == True:\n                    faults_in_poly += 1\n            if faults_in_poly != 0:\n                MFD = OQ_entry_scenarios[index_scenario]\n                i_mag = 0\n                for r in MFD:\n                    rate_faults[i_mag] += MFD[i_mag] * float(faults_in_poly) / float(len(index_faults_in_sc[0]))\n                    i_mag += 1\n            index_scenario += 1\n    return (txt_no_bg, rate_faults, rate_bg, smooth)",
            "def get_model_rate(poly, OQ_entry_faults, OQ_entry_scenarios, pts_list, bin_mag, param, faults_data, faults_names, index_faults_in_scenario, local_zone_mfd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    poly : polypath , polygon of the zone\\n    OQ_entry_faults : list, rates and info on each single fault rupture\\n    OQ_entry_scenarios : list, rates and info on each complex fault rupture\\n    pts_list : dict, info and rates of the bg points\\n    param : dict, parameters used in this run\\n    bin_mag : list, bining in magnitude\\n    faults_data : dict, data of the faults\\n    faults_names : list , list of the names of the faults\\n    index_faults_in_scenario : list, list of the indexes of faults for each scenario\\n    local_zone_mfd : list, mfd of the bg seismicity if bg was (or is) a uiform zone\\n\\n    '\n    rate_bg = np.zeros_like(bin_mag)\n    smooth = np.zeros_like(bin_mag)\n    if param['main']['background']['option_bg'] == 'smooth':\n        txt_no_bg = ''\n        for lon_lat in pts_list.keys():\n            lon = float(lon_lat.split('_')[0])\n            lat = float(lon_lat.split('_')[1])\n            if poly.contains_point((lon, lat)) == 1:\n                scaled_mfd = pts_list[lon_lat]['scaled_mfd']\n                mfd_smooth = pts_list[lon_lat]['mfd_smooth']\n                i_mag = 0\n                for r in scaled_mfd:\n                    rate_bg[i_mag] += r\n                    i_mag += 1\n                i_mag = 0\n                for r in mfd_smooth:\n                    smooth[i_mag] += r\n                    i_mag += 1\n    elif param['main']['background']['option_bg'] == 'zone':\n        txt_no_bg = ''\n        rate_bg = local_zone_mfd\n    else:\n        txt_no_bg = ' BG NOT INCLUDED'\n    rate_faults = np.zeros_like(bin_mag)\n    for (index_fault, fault_name) in zip(range(len(faults_names)), faults_names):\n        f_in = False\n        stop_loop = False\n        while stop_loop == False:\n            lons = faults_data[index_fault]['lon']\n            lats = faults_data[index_fault]['lat']\n            for (lon, lat) in zip(lons, lats):\n                if poly.contains_point((lon, lat)) == 1:\n                    f_in = True\n                    stop_loop = True\n            stop_loop = True\n        if f_in == True:\n            i_MFD = np.where(np.array(faults_names) == fault_name)[0][0]\n            MFD = OQ_entry_faults[i_MFD]\n            i_mag = 0\n            for r in MFD:\n                rate_faults[i_mag] += MFD[i_mag]\n                i_mag += 1\n    if len(index_faults_in_scenario) != 0:\n        index_scenario = 0\n        for index_faults_in_sc in index_faults_in_scenario:\n            faults_in_poly = 0\n            for index_fault in index_faults_in_sc[0]:\n                f_in = False\n                stop_loop = False\n                while stop_loop == False:\n                    lons = faults_data[index_fault]['lon']\n                    lats = faults_data[index_fault]['lat']\n                    for (lon, lat) in zip(lons, lats):\n                        if poly.contains_point((lon, lat)) == 1:\n                            f_in = True\n                            stop_loop = True\n                    stop_loop = True\n                if f_in == True:\n                    faults_in_poly += 1\n            if faults_in_poly != 0:\n                MFD = OQ_entry_scenarios[index_scenario]\n                i_mag = 0\n                for r in MFD:\n                    rate_faults[i_mag] += MFD[i_mag] * float(faults_in_poly) / float(len(index_faults_in_sc[0]))\n                    i_mag += 1\n            index_scenario += 1\n    return (txt_no_bg, rate_faults, rate_bg, smooth)"
        ]
    }
]