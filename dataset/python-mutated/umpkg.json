[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    Confine this module to yum based systems\n    \"\"\"\n    if __opts__.get('yum_provider') == 'yumpkg_api':\n        return (False, 'Module yumpkg: yumpkg_api provider not available')\n    try:\n        os_grain = __grains__['os'].lower()\n        os_family = __grains__['os_family'].lower()\n    except Exception:\n        return (False, 'Module yumpkg: no yum based system detected')\n    enabled = ('amazon', 'xcp', 'xenserver', 'virtuozzolinux', 'virtuozzo', 'issabel pbx', 'openeuler')\n    if os_family == 'redhat' or os_grain in enabled:\n        if _yum() is None:\n            return (False, 'DNF nor YUM found')\n        return __virtualname__\n    return (False, 'Module yumpkg: no yum based system detected')",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    Confine this module to yum based systems\\n    '\n    if __opts__.get('yum_provider') == 'yumpkg_api':\n        return (False, 'Module yumpkg: yumpkg_api provider not available')\n    try:\n        os_grain = __grains__['os'].lower()\n        os_family = __grains__['os_family'].lower()\n    except Exception:\n        return (False, 'Module yumpkg: no yum based system detected')\n    enabled = ('amazon', 'xcp', 'xenserver', 'virtuozzolinux', 'virtuozzo', 'issabel pbx', 'openeuler')\n    if os_family == 'redhat' or os_grain in enabled:\n        if _yum() is None:\n            return (False, 'DNF nor YUM found')\n        return __virtualname__\n    return (False, 'Module yumpkg: no yum based system detected')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Confine this module to yum based systems\\n    '\n    if __opts__.get('yum_provider') == 'yumpkg_api':\n        return (False, 'Module yumpkg: yumpkg_api provider not available')\n    try:\n        os_grain = __grains__['os'].lower()\n        os_family = __grains__['os_family'].lower()\n    except Exception:\n        return (False, 'Module yumpkg: no yum based system detected')\n    enabled = ('amazon', 'xcp', 'xenserver', 'virtuozzolinux', 'virtuozzo', 'issabel pbx', 'openeuler')\n    if os_family == 'redhat' or os_grain in enabled:\n        if _yum() is None:\n            return (False, 'DNF nor YUM found')\n        return __virtualname__\n    return (False, 'Module yumpkg: no yum based system detected')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Confine this module to yum based systems\\n    '\n    if __opts__.get('yum_provider') == 'yumpkg_api':\n        return (False, 'Module yumpkg: yumpkg_api provider not available')\n    try:\n        os_grain = __grains__['os'].lower()\n        os_family = __grains__['os_family'].lower()\n    except Exception:\n        return (False, 'Module yumpkg: no yum based system detected')\n    enabled = ('amazon', 'xcp', 'xenserver', 'virtuozzolinux', 'virtuozzo', 'issabel pbx', 'openeuler')\n    if os_family == 'redhat' or os_grain in enabled:\n        if _yum() is None:\n            return (False, 'DNF nor YUM found')\n        return __virtualname__\n    return (False, 'Module yumpkg: no yum based system detected')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Confine this module to yum based systems\\n    '\n    if __opts__.get('yum_provider') == 'yumpkg_api':\n        return (False, 'Module yumpkg: yumpkg_api provider not available')\n    try:\n        os_grain = __grains__['os'].lower()\n        os_family = __grains__['os_family'].lower()\n    except Exception:\n        return (False, 'Module yumpkg: no yum based system detected')\n    enabled = ('amazon', 'xcp', 'xenserver', 'virtuozzolinux', 'virtuozzo', 'issabel pbx', 'openeuler')\n    if os_family == 'redhat' or os_grain in enabled:\n        if _yum() is None:\n            return (False, 'DNF nor YUM found')\n        return __virtualname__\n    return (False, 'Module yumpkg: no yum based system detected')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Confine this module to yum based systems\\n    '\n    if __opts__.get('yum_provider') == 'yumpkg_api':\n        return (False, 'Module yumpkg: yumpkg_api provider not available')\n    try:\n        os_grain = __grains__['os'].lower()\n        os_family = __grains__['os_family'].lower()\n    except Exception:\n        return (False, 'Module yumpkg: no yum based system detected')\n    enabled = ('amazon', 'xcp', 'xenserver', 'virtuozzolinux', 'virtuozzo', 'issabel pbx', 'openeuler')\n    if os_family == 'redhat' or os_grain in enabled:\n        if _yum() is None:\n            return (False, 'DNF nor YUM found')\n        return __virtualname__\n    return (False, 'Module yumpkg: no yum based system detected')"
        ]
    },
    {
        "func_name": "_strip_headers",
        "original": "def _strip_headers(output, *args):\n    if not args:\n        args_lc = ('installed packages', 'available packages', 'available upgrades', 'updated packages', 'upgraded packages')\n    else:\n        args_lc = [x.lower() for x in args]\n    ret = ''\n    for line in salt.utils.itertools.split(output, '\\n'):\n        if line.lower() not in args_lc:\n            ret += line + '\\n'\n    return ret",
        "mutated": [
            "def _strip_headers(output, *args):\n    if False:\n        i = 10\n    if not args:\n        args_lc = ('installed packages', 'available packages', 'available upgrades', 'updated packages', 'upgraded packages')\n    else:\n        args_lc = [x.lower() for x in args]\n    ret = ''\n    for line in salt.utils.itertools.split(output, '\\n'):\n        if line.lower() not in args_lc:\n            ret += line + '\\n'\n    return ret",
            "def _strip_headers(output, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not args:\n        args_lc = ('installed packages', 'available packages', 'available upgrades', 'updated packages', 'upgraded packages')\n    else:\n        args_lc = [x.lower() for x in args]\n    ret = ''\n    for line in salt.utils.itertools.split(output, '\\n'):\n        if line.lower() not in args_lc:\n            ret += line + '\\n'\n    return ret",
            "def _strip_headers(output, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not args:\n        args_lc = ('installed packages', 'available packages', 'available upgrades', 'updated packages', 'upgraded packages')\n    else:\n        args_lc = [x.lower() for x in args]\n    ret = ''\n    for line in salt.utils.itertools.split(output, '\\n'):\n        if line.lower() not in args_lc:\n            ret += line + '\\n'\n    return ret",
            "def _strip_headers(output, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not args:\n        args_lc = ('installed packages', 'available packages', 'available upgrades', 'updated packages', 'upgraded packages')\n    else:\n        args_lc = [x.lower() for x in args]\n    ret = ''\n    for line in salt.utils.itertools.split(output, '\\n'):\n        if line.lower() not in args_lc:\n            ret += line + '\\n'\n    return ret",
            "def _strip_headers(output, *args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not args:\n        args_lc = ('installed packages', 'available packages', 'available upgrades', 'updated packages', 'upgraded packages')\n    else:\n        args_lc = [x.lower() for x in args]\n    ret = ''\n    for line in salt.utils.itertools.split(output, '\\n'):\n        if line.lower() not in args_lc:\n            ret += line + '\\n'\n    return ret"
        ]
    },
    {
        "func_name": "_get_copr_repo",
        "original": "def _get_copr_repo(copr):\n    copr = copr.split(':', 1)[1]\n    copr = copr.split('/', 1)\n    return f'copr:copr.fedorainfracloud.org:{copr[0]}:{copr[1]}'",
        "mutated": [
            "def _get_copr_repo(copr):\n    if False:\n        i = 10\n    copr = copr.split(':', 1)[1]\n    copr = copr.split('/', 1)\n    return f'copr:copr.fedorainfracloud.org:{copr[0]}:{copr[1]}'",
            "def _get_copr_repo(copr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    copr = copr.split(':', 1)[1]\n    copr = copr.split('/', 1)\n    return f'copr:copr.fedorainfracloud.org:{copr[0]}:{copr[1]}'",
            "def _get_copr_repo(copr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    copr = copr.split(':', 1)[1]\n    copr = copr.split('/', 1)\n    return f'copr:copr.fedorainfracloud.org:{copr[0]}:{copr[1]}'",
            "def _get_copr_repo(copr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    copr = copr.split(':', 1)[1]\n    copr = copr.split('/', 1)\n    return f'copr:copr.fedorainfracloud.org:{copr[0]}:{copr[1]}'",
            "def _get_copr_repo(copr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    copr = copr.split(':', 1)[1]\n    copr = copr.split('/', 1)\n    return f'copr:copr.fedorainfracloud.org:{copr[0]}:{copr[1]}'"
        ]
    },
    {
        "func_name": "_get_hold",
        "original": "def _get_hold(line, pattern=__HOLD_PATTERN, full=True):\n    \"\"\"\n    Resolve a package name from a line containing the hold expression. If the\n    regex is not matched, None is returned.\n\n    yum ==> 2:vim-enhanced-7.4.629-5.el6.*\n    dnf ==> vim-enhanced-2:7.4.827-1.fc22.*\n    \"\"\"\n    if full:\n        if _yum() in ('dnf', 'dnf5'):\n            lock_re = f'({pattern}-\\\\S+)'\n        else:\n            lock_re = f'(\\\\d+:{pattern}-\\\\S+)'\n    elif _yum() in ('dnf', 'dnf5'):\n        lock_re = f'({pattern}-\\\\S+)'\n    else:\n        lock_re = f'\\\\d+:({pattern}-\\\\S+)'\n    match = re.search(lock_re, line)\n    if match:\n        if not full:\n            woarch = match.group(1).rsplit('.', 1)[0]\n            worel = woarch.rsplit('-', 1)[0]\n            return worel.rsplit('-', 1)[0]\n        else:\n            return match.group(1)\n    return None",
        "mutated": [
            "def _get_hold(line, pattern=__HOLD_PATTERN, full=True):\n    if False:\n        i = 10\n    '\\n    Resolve a package name from a line containing the hold expression. If the\\n    regex is not matched, None is returned.\\n\\n    yum ==> 2:vim-enhanced-7.4.629-5.el6.*\\n    dnf ==> vim-enhanced-2:7.4.827-1.fc22.*\\n    '\n    if full:\n        if _yum() in ('dnf', 'dnf5'):\n            lock_re = f'({pattern}-\\\\S+)'\n        else:\n            lock_re = f'(\\\\d+:{pattern}-\\\\S+)'\n    elif _yum() in ('dnf', 'dnf5'):\n        lock_re = f'({pattern}-\\\\S+)'\n    else:\n        lock_re = f'\\\\d+:({pattern}-\\\\S+)'\n    match = re.search(lock_re, line)\n    if match:\n        if not full:\n            woarch = match.group(1).rsplit('.', 1)[0]\n            worel = woarch.rsplit('-', 1)[0]\n            return worel.rsplit('-', 1)[0]\n        else:\n            return match.group(1)\n    return None",
            "def _get_hold(line, pattern=__HOLD_PATTERN, full=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Resolve a package name from a line containing the hold expression. If the\\n    regex is not matched, None is returned.\\n\\n    yum ==> 2:vim-enhanced-7.4.629-5.el6.*\\n    dnf ==> vim-enhanced-2:7.4.827-1.fc22.*\\n    '\n    if full:\n        if _yum() in ('dnf', 'dnf5'):\n            lock_re = f'({pattern}-\\\\S+)'\n        else:\n            lock_re = f'(\\\\d+:{pattern}-\\\\S+)'\n    elif _yum() in ('dnf', 'dnf5'):\n        lock_re = f'({pattern}-\\\\S+)'\n    else:\n        lock_re = f'\\\\d+:({pattern}-\\\\S+)'\n    match = re.search(lock_re, line)\n    if match:\n        if not full:\n            woarch = match.group(1).rsplit('.', 1)[0]\n            worel = woarch.rsplit('-', 1)[0]\n            return worel.rsplit('-', 1)[0]\n        else:\n            return match.group(1)\n    return None",
            "def _get_hold(line, pattern=__HOLD_PATTERN, full=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Resolve a package name from a line containing the hold expression. If the\\n    regex is not matched, None is returned.\\n\\n    yum ==> 2:vim-enhanced-7.4.629-5.el6.*\\n    dnf ==> vim-enhanced-2:7.4.827-1.fc22.*\\n    '\n    if full:\n        if _yum() in ('dnf', 'dnf5'):\n            lock_re = f'({pattern}-\\\\S+)'\n        else:\n            lock_re = f'(\\\\d+:{pattern}-\\\\S+)'\n    elif _yum() in ('dnf', 'dnf5'):\n        lock_re = f'({pattern}-\\\\S+)'\n    else:\n        lock_re = f'\\\\d+:({pattern}-\\\\S+)'\n    match = re.search(lock_re, line)\n    if match:\n        if not full:\n            woarch = match.group(1).rsplit('.', 1)[0]\n            worel = woarch.rsplit('-', 1)[0]\n            return worel.rsplit('-', 1)[0]\n        else:\n            return match.group(1)\n    return None",
            "def _get_hold(line, pattern=__HOLD_PATTERN, full=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Resolve a package name from a line containing the hold expression. If the\\n    regex is not matched, None is returned.\\n\\n    yum ==> 2:vim-enhanced-7.4.629-5.el6.*\\n    dnf ==> vim-enhanced-2:7.4.827-1.fc22.*\\n    '\n    if full:\n        if _yum() in ('dnf', 'dnf5'):\n            lock_re = f'({pattern}-\\\\S+)'\n        else:\n            lock_re = f'(\\\\d+:{pattern}-\\\\S+)'\n    elif _yum() in ('dnf', 'dnf5'):\n        lock_re = f'({pattern}-\\\\S+)'\n    else:\n        lock_re = f'\\\\d+:({pattern}-\\\\S+)'\n    match = re.search(lock_re, line)\n    if match:\n        if not full:\n            woarch = match.group(1).rsplit('.', 1)[0]\n            worel = woarch.rsplit('-', 1)[0]\n            return worel.rsplit('-', 1)[0]\n        else:\n            return match.group(1)\n    return None",
            "def _get_hold(line, pattern=__HOLD_PATTERN, full=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Resolve a package name from a line containing the hold expression. If the\\n    regex is not matched, None is returned.\\n\\n    yum ==> 2:vim-enhanced-7.4.629-5.el6.*\\n    dnf ==> vim-enhanced-2:7.4.827-1.fc22.*\\n    '\n    if full:\n        if _yum() in ('dnf', 'dnf5'):\n            lock_re = f'({pattern}-\\\\S+)'\n        else:\n            lock_re = f'(\\\\d+:{pattern}-\\\\S+)'\n    elif _yum() in ('dnf', 'dnf5'):\n        lock_re = f'({pattern}-\\\\S+)'\n    else:\n        lock_re = f'\\\\d+:({pattern}-\\\\S+)'\n    match = re.search(lock_re, line)\n    if match:\n        if not full:\n            woarch = match.group(1).rsplit('.', 1)[0]\n            worel = woarch.rsplit('-', 1)[0]\n            return worel.rsplit('-', 1)[0]\n        else:\n            return match.group(1)\n    return None"
        ]
    },
    {
        "func_name": "_check",
        "original": "def _check(file):\n    return os.path.exists(file) and os.access(file, os.F_OK | os.X_OK) and (not os.path.isdir(file))",
        "mutated": [
            "def _check(file):\n    if False:\n        i = 10\n    return os.path.exists(file) and os.access(file, os.F_OK | os.X_OK) and (not os.path.isdir(file))",
            "def _check(file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return os.path.exists(file) and os.access(file, os.F_OK | os.X_OK) and (not os.path.isdir(file))",
            "def _check(file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return os.path.exists(file) and os.access(file, os.F_OK | os.X_OK) and (not os.path.isdir(file))",
            "def _check(file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return os.path.exists(file) and os.access(file, os.F_OK | os.X_OK) and (not os.path.isdir(file))",
            "def _check(file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return os.path.exists(file) and os.access(file, os.F_OK | os.X_OK) and (not os.path.isdir(file))"
        ]
    },
    {
        "func_name": "_yum",
        "original": "def _yum():\n    \"\"\"\n    Determine package manager name (yum or dnf[5]),\n    depending on the executable existence in $PATH.\n    \"\"\"\n    import os\n\n    def _check(file):\n        return os.path.exists(file) and os.access(file, os.F_OK | os.X_OK) and (not os.path.isdir(file))\n    try:\n        context = __context__\n    except NameError:\n        context = {}\n    contextkey = 'yum_bin'\n    if contextkey not in context:\n        for dir in os.environ.get('PATH', os.defpath).split(os.pathsep):\n            if _check(os.path.join(dir, 'dnf5')):\n                context[contextkey] = 'dnf5'\n                break\n            elif _check(os.path.join(dir, 'dnf')):\n                context[contextkey] = 'dnf'\n                break\n            elif _check(os.path.join(dir, 'tdnf')):\n                context[contextkey] = 'tdnf'\n                break\n            elif _check(os.path.join(dir, 'yum')):\n                context[contextkey] = 'yum'\n                break\n    return context.get(contextkey)",
        "mutated": [
            "def _yum():\n    if False:\n        i = 10\n    '\\n    Determine package manager name (yum or dnf[5]),\\n    depending on the executable existence in $PATH.\\n    '\n    import os\n\n    def _check(file):\n        return os.path.exists(file) and os.access(file, os.F_OK | os.X_OK) and (not os.path.isdir(file))\n    try:\n        context = __context__\n    except NameError:\n        context = {}\n    contextkey = 'yum_bin'\n    if contextkey not in context:\n        for dir in os.environ.get('PATH', os.defpath).split(os.pathsep):\n            if _check(os.path.join(dir, 'dnf5')):\n                context[contextkey] = 'dnf5'\n                break\n            elif _check(os.path.join(dir, 'dnf')):\n                context[contextkey] = 'dnf'\n                break\n            elif _check(os.path.join(dir, 'tdnf')):\n                context[contextkey] = 'tdnf'\n                break\n            elif _check(os.path.join(dir, 'yum')):\n                context[contextkey] = 'yum'\n                break\n    return context.get(contextkey)",
            "def _yum():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Determine package manager name (yum or dnf[5]),\\n    depending on the executable existence in $PATH.\\n    '\n    import os\n\n    def _check(file):\n        return os.path.exists(file) and os.access(file, os.F_OK | os.X_OK) and (not os.path.isdir(file))\n    try:\n        context = __context__\n    except NameError:\n        context = {}\n    contextkey = 'yum_bin'\n    if contextkey not in context:\n        for dir in os.environ.get('PATH', os.defpath).split(os.pathsep):\n            if _check(os.path.join(dir, 'dnf5')):\n                context[contextkey] = 'dnf5'\n                break\n            elif _check(os.path.join(dir, 'dnf')):\n                context[contextkey] = 'dnf'\n                break\n            elif _check(os.path.join(dir, 'tdnf')):\n                context[contextkey] = 'tdnf'\n                break\n            elif _check(os.path.join(dir, 'yum')):\n                context[contextkey] = 'yum'\n                break\n    return context.get(contextkey)",
            "def _yum():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Determine package manager name (yum or dnf[5]),\\n    depending on the executable existence in $PATH.\\n    '\n    import os\n\n    def _check(file):\n        return os.path.exists(file) and os.access(file, os.F_OK | os.X_OK) and (not os.path.isdir(file))\n    try:\n        context = __context__\n    except NameError:\n        context = {}\n    contextkey = 'yum_bin'\n    if contextkey not in context:\n        for dir in os.environ.get('PATH', os.defpath).split(os.pathsep):\n            if _check(os.path.join(dir, 'dnf5')):\n                context[contextkey] = 'dnf5'\n                break\n            elif _check(os.path.join(dir, 'dnf')):\n                context[contextkey] = 'dnf'\n                break\n            elif _check(os.path.join(dir, 'tdnf')):\n                context[contextkey] = 'tdnf'\n                break\n            elif _check(os.path.join(dir, 'yum')):\n                context[contextkey] = 'yum'\n                break\n    return context.get(contextkey)",
            "def _yum():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Determine package manager name (yum or dnf[5]),\\n    depending on the executable existence in $PATH.\\n    '\n    import os\n\n    def _check(file):\n        return os.path.exists(file) and os.access(file, os.F_OK | os.X_OK) and (not os.path.isdir(file))\n    try:\n        context = __context__\n    except NameError:\n        context = {}\n    contextkey = 'yum_bin'\n    if contextkey not in context:\n        for dir in os.environ.get('PATH', os.defpath).split(os.pathsep):\n            if _check(os.path.join(dir, 'dnf5')):\n                context[contextkey] = 'dnf5'\n                break\n            elif _check(os.path.join(dir, 'dnf')):\n                context[contextkey] = 'dnf'\n                break\n            elif _check(os.path.join(dir, 'tdnf')):\n                context[contextkey] = 'tdnf'\n                break\n            elif _check(os.path.join(dir, 'yum')):\n                context[contextkey] = 'yum'\n                break\n    return context.get(contextkey)",
            "def _yum():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Determine package manager name (yum or dnf[5]),\\n    depending on the executable existence in $PATH.\\n    '\n    import os\n\n    def _check(file):\n        return os.path.exists(file) and os.access(file, os.F_OK | os.X_OK) and (not os.path.isdir(file))\n    try:\n        context = __context__\n    except NameError:\n        context = {}\n    contextkey = 'yum_bin'\n    if contextkey not in context:\n        for dir in os.environ.get('PATH', os.defpath).split(os.pathsep):\n            if _check(os.path.join(dir, 'dnf5')):\n                context[contextkey] = 'dnf5'\n                break\n            elif _check(os.path.join(dir, 'dnf')):\n                context[contextkey] = 'dnf'\n                break\n            elif _check(os.path.join(dir, 'tdnf')):\n                context[contextkey] = 'tdnf'\n                break\n            elif _check(os.path.join(dir, 'yum')):\n                context[contextkey] = 'yum'\n                break\n    return context.get(contextkey)"
        ]
    },
    {
        "func_name": "_call_yum",
        "original": "def _call_yum(args, **kwargs):\n    \"\"\"\n    Call yum/dnf.\n    \"\"\"\n    params = {'output_loglevel': 'trace', 'python_shell': False, 'env': salt.utils.environment.get_module_environment(globals())}\n    params.update(kwargs)\n    cmd = []\n    if salt.utils.systemd.has_scope(__context__) and __salt__['config.get']('systemd.scope', True):\n        cmd.extend(['systemd-run', '--scope'])\n    cmd.append(_yum())\n    cmd.extend(args)\n    return __salt__['cmd.run_all'](cmd, **params)",
        "mutated": [
            "def _call_yum(args, **kwargs):\n    if False:\n        i = 10\n    '\\n    Call yum/dnf.\\n    '\n    params = {'output_loglevel': 'trace', 'python_shell': False, 'env': salt.utils.environment.get_module_environment(globals())}\n    params.update(kwargs)\n    cmd = []\n    if salt.utils.systemd.has_scope(__context__) and __salt__['config.get']('systemd.scope', True):\n        cmd.extend(['systemd-run', '--scope'])\n    cmd.append(_yum())\n    cmd.extend(args)\n    return __salt__['cmd.run_all'](cmd, **params)",
            "def _call_yum(args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Call yum/dnf.\\n    '\n    params = {'output_loglevel': 'trace', 'python_shell': False, 'env': salt.utils.environment.get_module_environment(globals())}\n    params.update(kwargs)\n    cmd = []\n    if salt.utils.systemd.has_scope(__context__) and __salt__['config.get']('systemd.scope', True):\n        cmd.extend(['systemd-run', '--scope'])\n    cmd.append(_yum())\n    cmd.extend(args)\n    return __salt__['cmd.run_all'](cmd, **params)",
            "def _call_yum(args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Call yum/dnf.\\n    '\n    params = {'output_loglevel': 'trace', 'python_shell': False, 'env': salt.utils.environment.get_module_environment(globals())}\n    params.update(kwargs)\n    cmd = []\n    if salt.utils.systemd.has_scope(__context__) and __salt__['config.get']('systemd.scope', True):\n        cmd.extend(['systemd-run', '--scope'])\n    cmd.append(_yum())\n    cmd.extend(args)\n    return __salt__['cmd.run_all'](cmd, **params)",
            "def _call_yum(args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Call yum/dnf.\\n    '\n    params = {'output_loglevel': 'trace', 'python_shell': False, 'env': salt.utils.environment.get_module_environment(globals())}\n    params.update(kwargs)\n    cmd = []\n    if salt.utils.systemd.has_scope(__context__) and __salt__['config.get']('systemd.scope', True):\n        cmd.extend(['systemd-run', '--scope'])\n    cmd.append(_yum())\n    cmd.extend(args)\n    return __salt__['cmd.run_all'](cmd, **params)",
            "def _call_yum(args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Call yum/dnf.\\n    '\n    params = {'output_loglevel': 'trace', 'python_shell': False, 'env': salt.utils.environment.get_module_environment(globals())}\n    params.update(kwargs)\n    cmd = []\n    if salt.utils.systemd.has_scope(__context__) and __salt__['config.get']('systemd.scope', True):\n        cmd.extend(['systemd-run', '--scope'])\n    cmd.append(_yum())\n    cmd.extend(args)\n    return __salt__['cmd.run_all'](cmd, **params)"
        ]
    },
    {
        "func_name": "_yum_pkginfo",
        "original": "def _yum_pkginfo(output):\n    \"\"\"\n    Parse yum/dnf output (which could contain irregular line breaks if package\n    names are long) retrieving the name, version, etc., and return a list of\n    pkginfo namedtuples.\n    \"\"\"\n    cur = {}\n    keys = itertools.cycle(('name', 'version', 'repoid'))\n    values = salt.utils.itertools.split(_strip_headers(output))\n    osarch = __grains__['osarch']\n    for (key, value) in zip(keys, values):\n        if key == 'name':\n            try:\n                (cur['name'], cur['arch']) = value.rsplit('.', 1)\n            except ValueError:\n                cur['name'] = value\n                cur['arch'] = osarch\n            cur['name'] = salt.utils.pkg.rpm.resolve_name(cur['name'], cur['arch'], osarch)\n        else:\n            if key == 'version':\n                value = value.rstrip('-')\n            elif key == 'repoid':\n                value = value.lstrip('@')\n            cur[key] = value\n            if key == 'repoid':\n                pkginfo = salt.utils.pkg.rpm.pkginfo(**cur)\n                cur = {}\n                if pkginfo is not None:\n                    yield pkginfo",
        "mutated": [
            "def _yum_pkginfo(output):\n    if False:\n        i = 10\n    '\\n    Parse yum/dnf output (which could contain irregular line breaks if package\\n    names are long) retrieving the name, version, etc., and return a list of\\n    pkginfo namedtuples.\\n    '\n    cur = {}\n    keys = itertools.cycle(('name', 'version', 'repoid'))\n    values = salt.utils.itertools.split(_strip_headers(output))\n    osarch = __grains__['osarch']\n    for (key, value) in zip(keys, values):\n        if key == 'name':\n            try:\n                (cur['name'], cur['arch']) = value.rsplit('.', 1)\n            except ValueError:\n                cur['name'] = value\n                cur['arch'] = osarch\n            cur['name'] = salt.utils.pkg.rpm.resolve_name(cur['name'], cur['arch'], osarch)\n        else:\n            if key == 'version':\n                value = value.rstrip('-')\n            elif key == 'repoid':\n                value = value.lstrip('@')\n            cur[key] = value\n            if key == 'repoid':\n                pkginfo = salt.utils.pkg.rpm.pkginfo(**cur)\n                cur = {}\n                if pkginfo is not None:\n                    yield pkginfo",
            "def _yum_pkginfo(output):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Parse yum/dnf output (which could contain irregular line breaks if package\\n    names are long) retrieving the name, version, etc., and return a list of\\n    pkginfo namedtuples.\\n    '\n    cur = {}\n    keys = itertools.cycle(('name', 'version', 'repoid'))\n    values = salt.utils.itertools.split(_strip_headers(output))\n    osarch = __grains__['osarch']\n    for (key, value) in zip(keys, values):\n        if key == 'name':\n            try:\n                (cur['name'], cur['arch']) = value.rsplit('.', 1)\n            except ValueError:\n                cur['name'] = value\n                cur['arch'] = osarch\n            cur['name'] = salt.utils.pkg.rpm.resolve_name(cur['name'], cur['arch'], osarch)\n        else:\n            if key == 'version':\n                value = value.rstrip('-')\n            elif key == 'repoid':\n                value = value.lstrip('@')\n            cur[key] = value\n            if key == 'repoid':\n                pkginfo = salt.utils.pkg.rpm.pkginfo(**cur)\n                cur = {}\n                if pkginfo is not None:\n                    yield pkginfo",
            "def _yum_pkginfo(output):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Parse yum/dnf output (which could contain irregular line breaks if package\\n    names are long) retrieving the name, version, etc., and return a list of\\n    pkginfo namedtuples.\\n    '\n    cur = {}\n    keys = itertools.cycle(('name', 'version', 'repoid'))\n    values = salt.utils.itertools.split(_strip_headers(output))\n    osarch = __grains__['osarch']\n    for (key, value) in zip(keys, values):\n        if key == 'name':\n            try:\n                (cur['name'], cur['arch']) = value.rsplit('.', 1)\n            except ValueError:\n                cur['name'] = value\n                cur['arch'] = osarch\n            cur['name'] = salt.utils.pkg.rpm.resolve_name(cur['name'], cur['arch'], osarch)\n        else:\n            if key == 'version':\n                value = value.rstrip('-')\n            elif key == 'repoid':\n                value = value.lstrip('@')\n            cur[key] = value\n            if key == 'repoid':\n                pkginfo = salt.utils.pkg.rpm.pkginfo(**cur)\n                cur = {}\n                if pkginfo is not None:\n                    yield pkginfo",
            "def _yum_pkginfo(output):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Parse yum/dnf output (which could contain irregular line breaks if package\\n    names are long) retrieving the name, version, etc., and return a list of\\n    pkginfo namedtuples.\\n    '\n    cur = {}\n    keys = itertools.cycle(('name', 'version', 'repoid'))\n    values = salt.utils.itertools.split(_strip_headers(output))\n    osarch = __grains__['osarch']\n    for (key, value) in zip(keys, values):\n        if key == 'name':\n            try:\n                (cur['name'], cur['arch']) = value.rsplit('.', 1)\n            except ValueError:\n                cur['name'] = value\n                cur['arch'] = osarch\n            cur['name'] = salt.utils.pkg.rpm.resolve_name(cur['name'], cur['arch'], osarch)\n        else:\n            if key == 'version':\n                value = value.rstrip('-')\n            elif key == 'repoid':\n                value = value.lstrip('@')\n            cur[key] = value\n            if key == 'repoid':\n                pkginfo = salt.utils.pkg.rpm.pkginfo(**cur)\n                cur = {}\n                if pkginfo is not None:\n                    yield pkginfo",
            "def _yum_pkginfo(output):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Parse yum/dnf output (which could contain irregular line breaks if package\\n    names are long) retrieving the name, version, etc., and return a list of\\n    pkginfo namedtuples.\\n    '\n    cur = {}\n    keys = itertools.cycle(('name', 'version', 'repoid'))\n    values = salt.utils.itertools.split(_strip_headers(output))\n    osarch = __grains__['osarch']\n    for (key, value) in zip(keys, values):\n        if key == 'name':\n            try:\n                (cur['name'], cur['arch']) = value.rsplit('.', 1)\n            except ValueError:\n                cur['name'] = value\n                cur['arch'] = osarch\n            cur['name'] = salt.utils.pkg.rpm.resolve_name(cur['name'], cur['arch'], osarch)\n        else:\n            if key == 'version':\n                value = value.rstrip('-')\n            elif key == 'repoid':\n                value = value.lstrip('@')\n            cur[key] = value\n            if key == 'repoid':\n                pkginfo = salt.utils.pkg.rpm.pkginfo(**cur)\n                cur = {}\n                if pkginfo is not None:\n                    yield pkginfo"
        ]
    },
    {
        "func_name": "_versionlock_pkg",
        "original": "def _versionlock_pkg(grains=None):\n    \"\"\"\n    Determine versionlock plugin package name\n    \"\"\"\n    if grains is None:\n        grains = __grains__\n    if _yum() in ('dnf', 'dnf5'):\n        if grains['os'].lower() == 'fedora':\n            return 'python3-dnf-plugin-versionlock' if int(grains.get('osrelease')) >= 26 else 'python3-dnf-plugins-extras-versionlock'\n        if int(grains.get('osmajorrelease')) >= 8:\n            return 'python3-dnf-plugin-versionlock'\n        return 'python2-dnf-plugin-versionlock'\n    elif _yum() == 'tdnf':\n        raise SaltInvocationError('Cannot proceed, no versionlock for tdnf')\n    else:\n        return 'yum-plugin-versionlock'",
        "mutated": [
            "def _versionlock_pkg(grains=None):\n    if False:\n        i = 10\n    '\\n    Determine versionlock plugin package name\\n    '\n    if grains is None:\n        grains = __grains__\n    if _yum() in ('dnf', 'dnf5'):\n        if grains['os'].lower() == 'fedora':\n            return 'python3-dnf-plugin-versionlock' if int(grains.get('osrelease')) >= 26 else 'python3-dnf-plugins-extras-versionlock'\n        if int(grains.get('osmajorrelease')) >= 8:\n            return 'python3-dnf-plugin-versionlock'\n        return 'python2-dnf-plugin-versionlock'\n    elif _yum() == 'tdnf':\n        raise SaltInvocationError('Cannot proceed, no versionlock for tdnf')\n    else:\n        return 'yum-plugin-versionlock'",
            "def _versionlock_pkg(grains=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Determine versionlock plugin package name\\n    '\n    if grains is None:\n        grains = __grains__\n    if _yum() in ('dnf', 'dnf5'):\n        if grains['os'].lower() == 'fedora':\n            return 'python3-dnf-plugin-versionlock' if int(grains.get('osrelease')) >= 26 else 'python3-dnf-plugins-extras-versionlock'\n        if int(grains.get('osmajorrelease')) >= 8:\n            return 'python3-dnf-plugin-versionlock'\n        return 'python2-dnf-plugin-versionlock'\n    elif _yum() == 'tdnf':\n        raise SaltInvocationError('Cannot proceed, no versionlock for tdnf')\n    else:\n        return 'yum-plugin-versionlock'",
            "def _versionlock_pkg(grains=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Determine versionlock plugin package name\\n    '\n    if grains is None:\n        grains = __grains__\n    if _yum() in ('dnf', 'dnf5'):\n        if grains['os'].lower() == 'fedora':\n            return 'python3-dnf-plugin-versionlock' if int(grains.get('osrelease')) >= 26 else 'python3-dnf-plugins-extras-versionlock'\n        if int(grains.get('osmajorrelease')) >= 8:\n            return 'python3-dnf-plugin-versionlock'\n        return 'python2-dnf-plugin-versionlock'\n    elif _yum() == 'tdnf':\n        raise SaltInvocationError('Cannot proceed, no versionlock for tdnf')\n    else:\n        return 'yum-plugin-versionlock'",
            "def _versionlock_pkg(grains=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Determine versionlock plugin package name\\n    '\n    if grains is None:\n        grains = __grains__\n    if _yum() in ('dnf', 'dnf5'):\n        if grains['os'].lower() == 'fedora':\n            return 'python3-dnf-plugin-versionlock' if int(grains.get('osrelease')) >= 26 else 'python3-dnf-plugins-extras-versionlock'\n        if int(grains.get('osmajorrelease')) >= 8:\n            return 'python3-dnf-plugin-versionlock'\n        return 'python2-dnf-plugin-versionlock'\n    elif _yum() == 'tdnf':\n        raise SaltInvocationError('Cannot proceed, no versionlock for tdnf')\n    else:\n        return 'yum-plugin-versionlock'",
            "def _versionlock_pkg(grains=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Determine versionlock plugin package name\\n    '\n    if grains is None:\n        grains = __grains__\n    if _yum() in ('dnf', 'dnf5'):\n        if grains['os'].lower() == 'fedora':\n            return 'python3-dnf-plugin-versionlock' if int(grains.get('osrelease')) >= 26 else 'python3-dnf-plugins-extras-versionlock'\n        if int(grains.get('osmajorrelease')) >= 8:\n            return 'python3-dnf-plugin-versionlock'\n        return 'python2-dnf-plugin-versionlock'\n    elif _yum() == 'tdnf':\n        raise SaltInvocationError('Cannot proceed, no versionlock for tdnf')\n    else:\n        return 'yum-plugin-versionlock'"
        ]
    },
    {
        "func_name": "_check_versionlock",
        "original": "def _check_versionlock():\n    \"\"\"\n    Ensure that the appropriate versionlock plugin is present\n    \"\"\"\n    vl_plugin = _versionlock_pkg()\n    if vl_plugin not in list_pkgs():\n        raise SaltInvocationError(f'Cannot proceed, {vl_plugin} is not installed.')",
        "mutated": [
            "def _check_versionlock():\n    if False:\n        i = 10\n    '\\n    Ensure that the appropriate versionlock plugin is present\\n    '\n    vl_plugin = _versionlock_pkg()\n    if vl_plugin not in list_pkgs():\n        raise SaltInvocationError(f'Cannot proceed, {vl_plugin} is not installed.')",
            "def _check_versionlock():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Ensure that the appropriate versionlock plugin is present\\n    '\n    vl_plugin = _versionlock_pkg()\n    if vl_plugin not in list_pkgs():\n        raise SaltInvocationError(f'Cannot proceed, {vl_plugin} is not installed.')",
            "def _check_versionlock():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Ensure that the appropriate versionlock plugin is present\\n    '\n    vl_plugin = _versionlock_pkg()\n    if vl_plugin not in list_pkgs():\n        raise SaltInvocationError(f'Cannot proceed, {vl_plugin} is not installed.')",
            "def _check_versionlock():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Ensure that the appropriate versionlock plugin is present\\n    '\n    vl_plugin = _versionlock_pkg()\n    if vl_plugin not in list_pkgs():\n        raise SaltInvocationError(f'Cannot proceed, {vl_plugin} is not installed.')",
            "def _check_versionlock():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Ensure that the appropriate versionlock plugin is present\\n    '\n    vl_plugin = _versionlock_pkg()\n    if vl_plugin not in list_pkgs():\n        raise SaltInvocationError(f'Cannot proceed, {vl_plugin} is not installed.')"
        ]
    },
    {
        "func_name": "_get_options",
        "original": "def _get_options(**kwargs):\n    \"\"\"\n    Returns a list of options to be used in the yum/dnf[5] command, based on the\n    kwargs passed.\n    \"\"\"\n    fromrepo = kwargs.pop('fromrepo', '')\n    repo = kwargs.pop('repo', '')\n    disablerepo = kwargs.pop('disablerepo', '')\n    enablerepo = kwargs.pop('enablerepo', '')\n    disableexcludes = kwargs.pop('disableexcludes', '')\n    branch = kwargs.pop('branch', '')\n    setopt = kwargs.pop('setopt', None)\n    if setopt is None:\n        setopt = []\n    else:\n        setopt = salt.utils.args.split_input(setopt)\n    get_extra_options = kwargs.pop('get_extra_options', False)\n    if repo and (not fromrepo):\n        fromrepo = repo\n    ret = []\n    if fromrepo:\n        log.info(\"Restricting to repo '%s'\", fromrepo)\n        ret.extend(['--disablerepo=*', f'--enablerepo={fromrepo}'])\n    else:\n        if disablerepo:\n            targets = [disablerepo] if not isinstance(disablerepo, list) else disablerepo\n            log.info('Disabling repo(s): %s', ', '.join(targets))\n            ret.extend([f'--disablerepo={x}' for x in targets])\n        if enablerepo:\n            targets = [enablerepo] if not isinstance(enablerepo, list) else enablerepo\n            log.info('Enabling repo(s): %s', ', '.join(targets))\n            ret.extend([f'--enablerepo={x}' for x in targets])\n    if disableexcludes:\n        log.info(\"Disabling excludes for '%s'\", disableexcludes)\n        ret.append(f'--disableexcludes={disableexcludes}')\n    if branch:\n        log.info(\"Adding branch '%s'\", branch)\n        ret.append(f'--branch={branch}')\n    for item in setopt:\n        ret.extend(['--setopt', str(item)])\n    if get_extra_options:\n        for key in sorted(kwargs):\n            if key.startswith('__'):\n                continue\n            value = kwargs[key]\n            if isinstance(value, str):\n                log.info('Found extra option --%s=%s', key, value)\n                ret.append(f'--{key}={value}')\n            elif value is True:\n                log.info('Found extra option --%s', key)\n                ret.append(f'--{key}')\n        if ret:\n            log.info('Adding extra options: %s', ret)\n    return ret",
        "mutated": [
            "def _get_options(**kwargs):\n    if False:\n        i = 10\n    '\\n    Returns a list of options to be used in the yum/dnf[5] command, based on the\\n    kwargs passed.\\n    '\n    fromrepo = kwargs.pop('fromrepo', '')\n    repo = kwargs.pop('repo', '')\n    disablerepo = kwargs.pop('disablerepo', '')\n    enablerepo = kwargs.pop('enablerepo', '')\n    disableexcludes = kwargs.pop('disableexcludes', '')\n    branch = kwargs.pop('branch', '')\n    setopt = kwargs.pop('setopt', None)\n    if setopt is None:\n        setopt = []\n    else:\n        setopt = salt.utils.args.split_input(setopt)\n    get_extra_options = kwargs.pop('get_extra_options', False)\n    if repo and (not fromrepo):\n        fromrepo = repo\n    ret = []\n    if fromrepo:\n        log.info(\"Restricting to repo '%s'\", fromrepo)\n        ret.extend(['--disablerepo=*', f'--enablerepo={fromrepo}'])\n    else:\n        if disablerepo:\n            targets = [disablerepo] if not isinstance(disablerepo, list) else disablerepo\n            log.info('Disabling repo(s): %s', ', '.join(targets))\n            ret.extend([f'--disablerepo={x}' for x in targets])\n        if enablerepo:\n            targets = [enablerepo] if not isinstance(enablerepo, list) else enablerepo\n            log.info('Enabling repo(s): %s', ', '.join(targets))\n            ret.extend([f'--enablerepo={x}' for x in targets])\n    if disableexcludes:\n        log.info(\"Disabling excludes for '%s'\", disableexcludes)\n        ret.append(f'--disableexcludes={disableexcludes}')\n    if branch:\n        log.info(\"Adding branch '%s'\", branch)\n        ret.append(f'--branch={branch}')\n    for item in setopt:\n        ret.extend(['--setopt', str(item)])\n    if get_extra_options:\n        for key in sorted(kwargs):\n            if key.startswith('__'):\n                continue\n            value = kwargs[key]\n            if isinstance(value, str):\n                log.info('Found extra option --%s=%s', key, value)\n                ret.append(f'--{key}={value}')\n            elif value is True:\n                log.info('Found extra option --%s', key)\n                ret.append(f'--{key}')\n        if ret:\n            log.info('Adding extra options: %s', ret)\n    return ret",
            "def _get_options(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns a list of options to be used in the yum/dnf[5] command, based on the\\n    kwargs passed.\\n    '\n    fromrepo = kwargs.pop('fromrepo', '')\n    repo = kwargs.pop('repo', '')\n    disablerepo = kwargs.pop('disablerepo', '')\n    enablerepo = kwargs.pop('enablerepo', '')\n    disableexcludes = kwargs.pop('disableexcludes', '')\n    branch = kwargs.pop('branch', '')\n    setopt = kwargs.pop('setopt', None)\n    if setopt is None:\n        setopt = []\n    else:\n        setopt = salt.utils.args.split_input(setopt)\n    get_extra_options = kwargs.pop('get_extra_options', False)\n    if repo and (not fromrepo):\n        fromrepo = repo\n    ret = []\n    if fromrepo:\n        log.info(\"Restricting to repo '%s'\", fromrepo)\n        ret.extend(['--disablerepo=*', f'--enablerepo={fromrepo}'])\n    else:\n        if disablerepo:\n            targets = [disablerepo] if not isinstance(disablerepo, list) else disablerepo\n            log.info('Disabling repo(s): %s', ', '.join(targets))\n            ret.extend([f'--disablerepo={x}' for x in targets])\n        if enablerepo:\n            targets = [enablerepo] if not isinstance(enablerepo, list) else enablerepo\n            log.info('Enabling repo(s): %s', ', '.join(targets))\n            ret.extend([f'--enablerepo={x}' for x in targets])\n    if disableexcludes:\n        log.info(\"Disabling excludes for '%s'\", disableexcludes)\n        ret.append(f'--disableexcludes={disableexcludes}')\n    if branch:\n        log.info(\"Adding branch '%s'\", branch)\n        ret.append(f'--branch={branch}')\n    for item in setopt:\n        ret.extend(['--setopt', str(item)])\n    if get_extra_options:\n        for key in sorted(kwargs):\n            if key.startswith('__'):\n                continue\n            value = kwargs[key]\n            if isinstance(value, str):\n                log.info('Found extra option --%s=%s', key, value)\n                ret.append(f'--{key}={value}')\n            elif value is True:\n                log.info('Found extra option --%s', key)\n                ret.append(f'--{key}')\n        if ret:\n            log.info('Adding extra options: %s', ret)\n    return ret",
            "def _get_options(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns a list of options to be used in the yum/dnf[5] command, based on the\\n    kwargs passed.\\n    '\n    fromrepo = kwargs.pop('fromrepo', '')\n    repo = kwargs.pop('repo', '')\n    disablerepo = kwargs.pop('disablerepo', '')\n    enablerepo = kwargs.pop('enablerepo', '')\n    disableexcludes = kwargs.pop('disableexcludes', '')\n    branch = kwargs.pop('branch', '')\n    setopt = kwargs.pop('setopt', None)\n    if setopt is None:\n        setopt = []\n    else:\n        setopt = salt.utils.args.split_input(setopt)\n    get_extra_options = kwargs.pop('get_extra_options', False)\n    if repo and (not fromrepo):\n        fromrepo = repo\n    ret = []\n    if fromrepo:\n        log.info(\"Restricting to repo '%s'\", fromrepo)\n        ret.extend(['--disablerepo=*', f'--enablerepo={fromrepo}'])\n    else:\n        if disablerepo:\n            targets = [disablerepo] if not isinstance(disablerepo, list) else disablerepo\n            log.info('Disabling repo(s): %s', ', '.join(targets))\n            ret.extend([f'--disablerepo={x}' for x in targets])\n        if enablerepo:\n            targets = [enablerepo] if not isinstance(enablerepo, list) else enablerepo\n            log.info('Enabling repo(s): %s', ', '.join(targets))\n            ret.extend([f'--enablerepo={x}' for x in targets])\n    if disableexcludes:\n        log.info(\"Disabling excludes for '%s'\", disableexcludes)\n        ret.append(f'--disableexcludes={disableexcludes}')\n    if branch:\n        log.info(\"Adding branch '%s'\", branch)\n        ret.append(f'--branch={branch}')\n    for item in setopt:\n        ret.extend(['--setopt', str(item)])\n    if get_extra_options:\n        for key in sorted(kwargs):\n            if key.startswith('__'):\n                continue\n            value = kwargs[key]\n            if isinstance(value, str):\n                log.info('Found extra option --%s=%s', key, value)\n                ret.append(f'--{key}={value}')\n            elif value is True:\n                log.info('Found extra option --%s', key)\n                ret.append(f'--{key}')\n        if ret:\n            log.info('Adding extra options: %s', ret)\n    return ret",
            "def _get_options(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns a list of options to be used in the yum/dnf[5] command, based on the\\n    kwargs passed.\\n    '\n    fromrepo = kwargs.pop('fromrepo', '')\n    repo = kwargs.pop('repo', '')\n    disablerepo = kwargs.pop('disablerepo', '')\n    enablerepo = kwargs.pop('enablerepo', '')\n    disableexcludes = kwargs.pop('disableexcludes', '')\n    branch = kwargs.pop('branch', '')\n    setopt = kwargs.pop('setopt', None)\n    if setopt is None:\n        setopt = []\n    else:\n        setopt = salt.utils.args.split_input(setopt)\n    get_extra_options = kwargs.pop('get_extra_options', False)\n    if repo and (not fromrepo):\n        fromrepo = repo\n    ret = []\n    if fromrepo:\n        log.info(\"Restricting to repo '%s'\", fromrepo)\n        ret.extend(['--disablerepo=*', f'--enablerepo={fromrepo}'])\n    else:\n        if disablerepo:\n            targets = [disablerepo] if not isinstance(disablerepo, list) else disablerepo\n            log.info('Disabling repo(s): %s', ', '.join(targets))\n            ret.extend([f'--disablerepo={x}' for x in targets])\n        if enablerepo:\n            targets = [enablerepo] if not isinstance(enablerepo, list) else enablerepo\n            log.info('Enabling repo(s): %s', ', '.join(targets))\n            ret.extend([f'--enablerepo={x}' for x in targets])\n    if disableexcludes:\n        log.info(\"Disabling excludes for '%s'\", disableexcludes)\n        ret.append(f'--disableexcludes={disableexcludes}')\n    if branch:\n        log.info(\"Adding branch '%s'\", branch)\n        ret.append(f'--branch={branch}')\n    for item in setopt:\n        ret.extend(['--setopt', str(item)])\n    if get_extra_options:\n        for key in sorted(kwargs):\n            if key.startswith('__'):\n                continue\n            value = kwargs[key]\n            if isinstance(value, str):\n                log.info('Found extra option --%s=%s', key, value)\n                ret.append(f'--{key}={value}')\n            elif value is True:\n                log.info('Found extra option --%s', key)\n                ret.append(f'--{key}')\n        if ret:\n            log.info('Adding extra options: %s', ret)\n    return ret",
            "def _get_options(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns a list of options to be used in the yum/dnf[5] command, based on the\\n    kwargs passed.\\n    '\n    fromrepo = kwargs.pop('fromrepo', '')\n    repo = kwargs.pop('repo', '')\n    disablerepo = kwargs.pop('disablerepo', '')\n    enablerepo = kwargs.pop('enablerepo', '')\n    disableexcludes = kwargs.pop('disableexcludes', '')\n    branch = kwargs.pop('branch', '')\n    setopt = kwargs.pop('setopt', None)\n    if setopt is None:\n        setopt = []\n    else:\n        setopt = salt.utils.args.split_input(setopt)\n    get_extra_options = kwargs.pop('get_extra_options', False)\n    if repo and (not fromrepo):\n        fromrepo = repo\n    ret = []\n    if fromrepo:\n        log.info(\"Restricting to repo '%s'\", fromrepo)\n        ret.extend(['--disablerepo=*', f'--enablerepo={fromrepo}'])\n    else:\n        if disablerepo:\n            targets = [disablerepo] if not isinstance(disablerepo, list) else disablerepo\n            log.info('Disabling repo(s): %s', ', '.join(targets))\n            ret.extend([f'--disablerepo={x}' for x in targets])\n        if enablerepo:\n            targets = [enablerepo] if not isinstance(enablerepo, list) else enablerepo\n            log.info('Enabling repo(s): %s', ', '.join(targets))\n            ret.extend([f'--enablerepo={x}' for x in targets])\n    if disableexcludes:\n        log.info(\"Disabling excludes for '%s'\", disableexcludes)\n        ret.append(f'--disableexcludes={disableexcludes}')\n    if branch:\n        log.info(\"Adding branch '%s'\", branch)\n        ret.append(f'--branch={branch}')\n    for item in setopt:\n        ret.extend(['--setopt', str(item)])\n    if get_extra_options:\n        for key in sorted(kwargs):\n            if key.startswith('__'):\n                continue\n            value = kwargs[key]\n            if isinstance(value, str):\n                log.info('Found extra option --%s=%s', key, value)\n                ret.append(f'--{key}={value}')\n            elif value is True:\n                log.info('Found extra option --%s', key)\n                ret.append(f'--{key}')\n        if ret:\n            log.info('Adding extra options: %s', ret)\n    return ret"
        ]
    },
    {
        "func_name": "_get_yum_config",
        "original": "def _get_yum_config(strict_parser=True):\n    \"\"\"\n    Returns a dict representing the yum config options and values.\n\n    We try to pull all of the yum config options into a standard dict object.\n    This is currently only used to get the reposdir settings, but could be used\n    for other things if needed.\n\n    If the yum python library is available, use that, which will give us all of\n    the options, including all of the defaults not specified in the yum config.\n    Additionally, they will all be of the correct object type.\n\n    If the yum library is not available, we try to read the yum.conf\n    directly ourselves with a minimal set of \"defaults\".\n    \"\"\"\n    conf = {'reposdir': ['/etc/yum/repos.d', '/etc/yum.repos.d']}\n    if HAS_YUM:\n        try:\n            yb = yum.YumBase()\n            yb.preconf.init_plugins = False\n            for (name, value) in yb.conf.items():\n                conf[name] = value\n        except (AttributeError, yum.Errors.ConfigError) as exc:\n            raise CommandExecutionError(f'Could not query yum config: {exc}')\n        except yum.Errors.YumBaseError as yum_base_error:\n            raise CommandExecutionError(f'Error accessing yum or rpmdb: {yum_base_error}')\n    else:\n        fn = None\n        paths = ('/etc/yum/yum.conf', '/etc/yum.conf', '/etc/dnf/dnf.conf', '/etc/tdnf/tdnf.conf')\n        for path in paths:\n            if os.path.exists(path):\n                fn = path\n                break\n        if not fn:\n            raise CommandExecutionError(f'No suitable yum config file found in: {paths}')\n        cp = configparser.ConfigParser(strict=strict_parser)\n        try:\n            cp.read(fn)\n        except OSError as exc:\n            raise CommandExecutionError(f'Unable to read from {fn}: {exc}')\n        if cp.has_section('main'):\n            for opt in cp.options('main'):\n                if opt in ('reposdir', 'commands', 'excludes'):\n                    conf[opt] = [x.strip() for x in cp.get('main', opt).split(',')]\n                else:\n                    conf[opt] = cp.get('main', opt)\n        else:\n            log.warning('Could not find [main] section in %s, using internal defaults', fn)\n    return conf",
        "mutated": [
            "def _get_yum_config(strict_parser=True):\n    if False:\n        i = 10\n    '\\n    Returns a dict representing the yum config options and values.\\n\\n    We try to pull all of the yum config options into a standard dict object.\\n    This is currently only used to get the reposdir settings, but could be used\\n    for other things if needed.\\n\\n    If the yum python library is available, use that, which will give us all of\\n    the options, including all of the defaults not specified in the yum config.\\n    Additionally, they will all be of the correct object type.\\n\\n    If the yum library is not available, we try to read the yum.conf\\n    directly ourselves with a minimal set of \"defaults\".\\n    '\n    conf = {'reposdir': ['/etc/yum/repos.d', '/etc/yum.repos.d']}\n    if HAS_YUM:\n        try:\n            yb = yum.YumBase()\n            yb.preconf.init_plugins = False\n            for (name, value) in yb.conf.items():\n                conf[name] = value\n        except (AttributeError, yum.Errors.ConfigError) as exc:\n            raise CommandExecutionError(f'Could not query yum config: {exc}')\n        except yum.Errors.YumBaseError as yum_base_error:\n            raise CommandExecutionError(f'Error accessing yum or rpmdb: {yum_base_error}')\n    else:\n        fn = None\n        paths = ('/etc/yum/yum.conf', '/etc/yum.conf', '/etc/dnf/dnf.conf', '/etc/tdnf/tdnf.conf')\n        for path in paths:\n            if os.path.exists(path):\n                fn = path\n                break\n        if not fn:\n            raise CommandExecutionError(f'No suitable yum config file found in: {paths}')\n        cp = configparser.ConfigParser(strict=strict_parser)\n        try:\n            cp.read(fn)\n        except OSError as exc:\n            raise CommandExecutionError(f'Unable to read from {fn}: {exc}')\n        if cp.has_section('main'):\n            for opt in cp.options('main'):\n                if opt in ('reposdir', 'commands', 'excludes'):\n                    conf[opt] = [x.strip() for x in cp.get('main', opt).split(',')]\n                else:\n                    conf[opt] = cp.get('main', opt)\n        else:\n            log.warning('Could not find [main] section in %s, using internal defaults', fn)\n    return conf",
            "def _get_yum_config(strict_parser=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns a dict representing the yum config options and values.\\n\\n    We try to pull all of the yum config options into a standard dict object.\\n    This is currently only used to get the reposdir settings, but could be used\\n    for other things if needed.\\n\\n    If the yum python library is available, use that, which will give us all of\\n    the options, including all of the defaults not specified in the yum config.\\n    Additionally, they will all be of the correct object type.\\n\\n    If the yum library is not available, we try to read the yum.conf\\n    directly ourselves with a minimal set of \"defaults\".\\n    '\n    conf = {'reposdir': ['/etc/yum/repos.d', '/etc/yum.repos.d']}\n    if HAS_YUM:\n        try:\n            yb = yum.YumBase()\n            yb.preconf.init_plugins = False\n            for (name, value) in yb.conf.items():\n                conf[name] = value\n        except (AttributeError, yum.Errors.ConfigError) as exc:\n            raise CommandExecutionError(f'Could not query yum config: {exc}')\n        except yum.Errors.YumBaseError as yum_base_error:\n            raise CommandExecutionError(f'Error accessing yum or rpmdb: {yum_base_error}')\n    else:\n        fn = None\n        paths = ('/etc/yum/yum.conf', '/etc/yum.conf', '/etc/dnf/dnf.conf', '/etc/tdnf/tdnf.conf')\n        for path in paths:\n            if os.path.exists(path):\n                fn = path\n                break\n        if not fn:\n            raise CommandExecutionError(f'No suitable yum config file found in: {paths}')\n        cp = configparser.ConfigParser(strict=strict_parser)\n        try:\n            cp.read(fn)\n        except OSError as exc:\n            raise CommandExecutionError(f'Unable to read from {fn}: {exc}')\n        if cp.has_section('main'):\n            for opt in cp.options('main'):\n                if opt in ('reposdir', 'commands', 'excludes'):\n                    conf[opt] = [x.strip() for x in cp.get('main', opt).split(',')]\n                else:\n                    conf[opt] = cp.get('main', opt)\n        else:\n            log.warning('Could not find [main] section in %s, using internal defaults', fn)\n    return conf",
            "def _get_yum_config(strict_parser=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns a dict representing the yum config options and values.\\n\\n    We try to pull all of the yum config options into a standard dict object.\\n    This is currently only used to get the reposdir settings, but could be used\\n    for other things if needed.\\n\\n    If the yum python library is available, use that, which will give us all of\\n    the options, including all of the defaults not specified in the yum config.\\n    Additionally, they will all be of the correct object type.\\n\\n    If the yum library is not available, we try to read the yum.conf\\n    directly ourselves with a minimal set of \"defaults\".\\n    '\n    conf = {'reposdir': ['/etc/yum/repos.d', '/etc/yum.repos.d']}\n    if HAS_YUM:\n        try:\n            yb = yum.YumBase()\n            yb.preconf.init_plugins = False\n            for (name, value) in yb.conf.items():\n                conf[name] = value\n        except (AttributeError, yum.Errors.ConfigError) as exc:\n            raise CommandExecutionError(f'Could not query yum config: {exc}')\n        except yum.Errors.YumBaseError as yum_base_error:\n            raise CommandExecutionError(f'Error accessing yum or rpmdb: {yum_base_error}')\n    else:\n        fn = None\n        paths = ('/etc/yum/yum.conf', '/etc/yum.conf', '/etc/dnf/dnf.conf', '/etc/tdnf/tdnf.conf')\n        for path in paths:\n            if os.path.exists(path):\n                fn = path\n                break\n        if not fn:\n            raise CommandExecutionError(f'No suitable yum config file found in: {paths}')\n        cp = configparser.ConfigParser(strict=strict_parser)\n        try:\n            cp.read(fn)\n        except OSError as exc:\n            raise CommandExecutionError(f'Unable to read from {fn}: {exc}')\n        if cp.has_section('main'):\n            for opt in cp.options('main'):\n                if opt in ('reposdir', 'commands', 'excludes'):\n                    conf[opt] = [x.strip() for x in cp.get('main', opt).split(',')]\n                else:\n                    conf[opt] = cp.get('main', opt)\n        else:\n            log.warning('Could not find [main] section in %s, using internal defaults', fn)\n    return conf",
            "def _get_yum_config(strict_parser=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns a dict representing the yum config options and values.\\n\\n    We try to pull all of the yum config options into a standard dict object.\\n    This is currently only used to get the reposdir settings, but could be used\\n    for other things if needed.\\n\\n    If the yum python library is available, use that, which will give us all of\\n    the options, including all of the defaults not specified in the yum config.\\n    Additionally, they will all be of the correct object type.\\n\\n    If the yum library is not available, we try to read the yum.conf\\n    directly ourselves with a minimal set of \"defaults\".\\n    '\n    conf = {'reposdir': ['/etc/yum/repos.d', '/etc/yum.repos.d']}\n    if HAS_YUM:\n        try:\n            yb = yum.YumBase()\n            yb.preconf.init_plugins = False\n            for (name, value) in yb.conf.items():\n                conf[name] = value\n        except (AttributeError, yum.Errors.ConfigError) as exc:\n            raise CommandExecutionError(f'Could not query yum config: {exc}')\n        except yum.Errors.YumBaseError as yum_base_error:\n            raise CommandExecutionError(f'Error accessing yum or rpmdb: {yum_base_error}')\n    else:\n        fn = None\n        paths = ('/etc/yum/yum.conf', '/etc/yum.conf', '/etc/dnf/dnf.conf', '/etc/tdnf/tdnf.conf')\n        for path in paths:\n            if os.path.exists(path):\n                fn = path\n                break\n        if not fn:\n            raise CommandExecutionError(f'No suitable yum config file found in: {paths}')\n        cp = configparser.ConfigParser(strict=strict_parser)\n        try:\n            cp.read(fn)\n        except OSError as exc:\n            raise CommandExecutionError(f'Unable to read from {fn}: {exc}')\n        if cp.has_section('main'):\n            for opt in cp.options('main'):\n                if opt in ('reposdir', 'commands', 'excludes'):\n                    conf[opt] = [x.strip() for x in cp.get('main', opt).split(',')]\n                else:\n                    conf[opt] = cp.get('main', opt)\n        else:\n            log.warning('Could not find [main] section in %s, using internal defaults', fn)\n    return conf",
            "def _get_yum_config(strict_parser=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns a dict representing the yum config options and values.\\n\\n    We try to pull all of the yum config options into a standard dict object.\\n    This is currently only used to get the reposdir settings, but could be used\\n    for other things if needed.\\n\\n    If the yum python library is available, use that, which will give us all of\\n    the options, including all of the defaults not specified in the yum config.\\n    Additionally, they will all be of the correct object type.\\n\\n    If the yum library is not available, we try to read the yum.conf\\n    directly ourselves with a minimal set of \"defaults\".\\n    '\n    conf = {'reposdir': ['/etc/yum/repos.d', '/etc/yum.repos.d']}\n    if HAS_YUM:\n        try:\n            yb = yum.YumBase()\n            yb.preconf.init_plugins = False\n            for (name, value) in yb.conf.items():\n                conf[name] = value\n        except (AttributeError, yum.Errors.ConfigError) as exc:\n            raise CommandExecutionError(f'Could not query yum config: {exc}')\n        except yum.Errors.YumBaseError as yum_base_error:\n            raise CommandExecutionError(f'Error accessing yum or rpmdb: {yum_base_error}')\n    else:\n        fn = None\n        paths = ('/etc/yum/yum.conf', '/etc/yum.conf', '/etc/dnf/dnf.conf', '/etc/tdnf/tdnf.conf')\n        for path in paths:\n            if os.path.exists(path):\n                fn = path\n                break\n        if not fn:\n            raise CommandExecutionError(f'No suitable yum config file found in: {paths}')\n        cp = configparser.ConfigParser(strict=strict_parser)\n        try:\n            cp.read(fn)\n        except OSError as exc:\n            raise CommandExecutionError(f'Unable to read from {fn}: {exc}')\n        if cp.has_section('main'):\n            for opt in cp.options('main'):\n                if opt in ('reposdir', 'commands', 'excludes'):\n                    conf[opt] = [x.strip() for x in cp.get('main', opt).split(',')]\n                else:\n                    conf[opt] = cp.get('main', opt)\n        else:\n            log.warning('Could not find [main] section in %s, using internal defaults', fn)\n    return conf"
        ]
    },
    {
        "func_name": "_get_yum_config_value",
        "original": "def _get_yum_config_value(name, strict_config=True):\n    \"\"\"\n    Look for a specific config variable and return its value\n    \"\"\"\n    conf = _get_yum_config(strict_config)\n    if name in conf.keys():\n        return conf.get(name)\n    return None",
        "mutated": [
            "def _get_yum_config_value(name, strict_config=True):\n    if False:\n        i = 10\n    '\\n    Look for a specific config variable and return its value\\n    '\n    conf = _get_yum_config(strict_config)\n    if name in conf.keys():\n        return conf.get(name)\n    return None",
            "def _get_yum_config_value(name, strict_config=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Look for a specific config variable and return its value\\n    '\n    conf = _get_yum_config(strict_config)\n    if name in conf.keys():\n        return conf.get(name)\n    return None",
            "def _get_yum_config_value(name, strict_config=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Look for a specific config variable and return its value\\n    '\n    conf = _get_yum_config(strict_config)\n    if name in conf.keys():\n        return conf.get(name)\n    return None",
            "def _get_yum_config_value(name, strict_config=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Look for a specific config variable and return its value\\n    '\n    conf = _get_yum_config(strict_config)\n    if name in conf.keys():\n        return conf.get(name)\n    return None",
            "def _get_yum_config_value(name, strict_config=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Look for a specific config variable and return its value\\n    '\n    conf = _get_yum_config(strict_config)\n    if name in conf.keys():\n        return conf.get(name)\n    return None"
        ]
    },
    {
        "func_name": "_normalize_basedir",
        "original": "def _normalize_basedir(basedir=None, strict_config=True):\n    \"\"\"\n    Takes a basedir argument as a string or a list. If the string or list is\n    empty, then look up the default from the 'reposdir' option in the yum\n    config.\n\n    Returns a list of directories.\n    \"\"\"\n    if isinstance(basedir, str):\n        basedir = [x.strip() for x in basedir.split(',')]\n    if basedir is None:\n        basedir = []\n    if not basedir:\n        basedir = _get_yum_config_value('reposdir', strict_config)\n    if not isinstance(basedir, list) or not basedir:\n        raise SaltInvocationError('Could not determine any repo directories')\n    return basedir",
        "mutated": [
            "def _normalize_basedir(basedir=None, strict_config=True):\n    if False:\n        i = 10\n    \"\\n    Takes a basedir argument as a string or a list. If the string or list is\\n    empty, then look up the default from the 'reposdir' option in the yum\\n    config.\\n\\n    Returns a list of directories.\\n    \"\n    if isinstance(basedir, str):\n        basedir = [x.strip() for x in basedir.split(',')]\n    if basedir is None:\n        basedir = []\n    if not basedir:\n        basedir = _get_yum_config_value('reposdir', strict_config)\n    if not isinstance(basedir, list) or not basedir:\n        raise SaltInvocationError('Could not determine any repo directories')\n    return basedir",
            "def _normalize_basedir(basedir=None, strict_config=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Takes a basedir argument as a string or a list. If the string or list is\\n    empty, then look up the default from the 'reposdir' option in the yum\\n    config.\\n\\n    Returns a list of directories.\\n    \"\n    if isinstance(basedir, str):\n        basedir = [x.strip() for x in basedir.split(',')]\n    if basedir is None:\n        basedir = []\n    if not basedir:\n        basedir = _get_yum_config_value('reposdir', strict_config)\n    if not isinstance(basedir, list) or not basedir:\n        raise SaltInvocationError('Could not determine any repo directories')\n    return basedir",
            "def _normalize_basedir(basedir=None, strict_config=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Takes a basedir argument as a string or a list. If the string or list is\\n    empty, then look up the default from the 'reposdir' option in the yum\\n    config.\\n\\n    Returns a list of directories.\\n    \"\n    if isinstance(basedir, str):\n        basedir = [x.strip() for x in basedir.split(',')]\n    if basedir is None:\n        basedir = []\n    if not basedir:\n        basedir = _get_yum_config_value('reposdir', strict_config)\n    if not isinstance(basedir, list) or not basedir:\n        raise SaltInvocationError('Could not determine any repo directories')\n    return basedir",
            "def _normalize_basedir(basedir=None, strict_config=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Takes a basedir argument as a string or a list. If the string or list is\\n    empty, then look up the default from the 'reposdir' option in the yum\\n    config.\\n\\n    Returns a list of directories.\\n    \"\n    if isinstance(basedir, str):\n        basedir = [x.strip() for x in basedir.split(',')]\n    if basedir is None:\n        basedir = []\n    if not basedir:\n        basedir = _get_yum_config_value('reposdir', strict_config)\n    if not isinstance(basedir, list) or not basedir:\n        raise SaltInvocationError('Could not determine any repo directories')\n    return basedir",
            "def _normalize_basedir(basedir=None, strict_config=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Takes a basedir argument as a string or a list. If the string or list is\\n    empty, then look up the default from the 'reposdir' option in the yum\\n    config.\\n\\n    Returns a list of directories.\\n    \"\n    if isinstance(basedir, str):\n        basedir = [x.strip() for x in basedir.split(',')]\n    if basedir is None:\n        basedir = []\n    if not basedir:\n        basedir = _get_yum_config_value('reposdir', strict_config)\n    if not isinstance(basedir, list) or not basedir:\n        raise SaltInvocationError('Could not determine any repo directories')\n    return basedir"
        ]
    },
    {
        "func_name": "normalize_name",
        "original": "def normalize_name(name):\n    \"\"\"\n    Strips the architecture from the specified package name, if necessary.\n    Circumstances where this would be done include:\n\n    * If the arch is 32 bit and the package name ends in a 32-bit arch.\n    * If the arch matches the OS arch, or is ``noarch``.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.normalize_name zsh.x86_64\n    \"\"\"\n    try:\n        arch = name.rsplit(PKG_ARCH_SEPARATOR, 1)[-1]\n        if arch not in salt.utils.pkg.rpm.ARCHES + ('noarch',):\n            return name\n    except ValueError:\n        return name\n    if arch in (__grains__['osarch'], 'noarch') or salt.utils.pkg.rpm.check_32(arch, osarch=__grains__['osarch']):\n        return name[:-(len(arch) + 1)]\n    return name",
        "mutated": [
            "def normalize_name(name):\n    if False:\n        i = 10\n    \"\\n    Strips the architecture from the specified package name, if necessary.\\n    Circumstances where this would be done include:\\n\\n    * If the arch is 32 bit and the package name ends in a 32-bit arch.\\n    * If the arch matches the OS arch, or is ``noarch``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.normalize_name zsh.x86_64\\n    \"\n    try:\n        arch = name.rsplit(PKG_ARCH_SEPARATOR, 1)[-1]\n        if arch not in salt.utils.pkg.rpm.ARCHES + ('noarch',):\n            return name\n    except ValueError:\n        return name\n    if arch in (__grains__['osarch'], 'noarch') or salt.utils.pkg.rpm.check_32(arch, osarch=__grains__['osarch']):\n        return name[:-(len(arch) + 1)]\n    return name",
            "def normalize_name(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Strips the architecture from the specified package name, if necessary.\\n    Circumstances where this would be done include:\\n\\n    * If the arch is 32 bit and the package name ends in a 32-bit arch.\\n    * If the arch matches the OS arch, or is ``noarch``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.normalize_name zsh.x86_64\\n    \"\n    try:\n        arch = name.rsplit(PKG_ARCH_SEPARATOR, 1)[-1]\n        if arch not in salt.utils.pkg.rpm.ARCHES + ('noarch',):\n            return name\n    except ValueError:\n        return name\n    if arch in (__grains__['osarch'], 'noarch') or salt.utils.pkg.rpm.check_32(arch, osarch=__grains__['osarch']):\n        return name[:-(len(arch) + 1)]\n    return name",
            "def normalize_name(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Strips the architecture from the specified package name, if necessary.\\n    Circumstances where this would be done include:\\n\\n    * If the arch is 32 bit and the package name ends in a 32-bit arch.\\n    * If the arch matches the OS arch, or is ``noarch``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.normalize_name zsh.x86_64\\n    \"\n    try:\n        arch = name.rsplit(PKG_ARCH_SEPARATOR, 1)[-1]\n        if arch not in salt.utils.pkg.rpm.ARCHES + ('noarch',):\n            return name\n    except ValueError:\n        return name\n    if arch in (__grains__['osarch'], 'noarch') or salt.utils.pkg.rpm.check_32(arch, osarch=__grains__['osarch']):\n        return name[:-(len(arch) + 1)]\n    return name",
            "def normalize_name(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Strips the architecture from the specified package name, if necessary.\\n    Circumstances where this would be done include:\\n\\n    * If the arch is 32 bit and the package name ends in a 32-bit arch.\\n    * If the arch matches the OS arch, or is ``noarch``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.normalize_name zsh.x86_64\\n    \"\n    try:\n        arch = name.rsplit(PKG_ARCH_SEPARATOR, 1)[-1]\n        if arch not in salt.utils.pkg.rpm.ARCHES + ('noarch',):\n            return name\n    except ValueError:\n        return name\n    if arch in (__grains__['osarch'], 'noarch') or salt.utils.pkg.rpm.check_32(arch, osarch=__grains__['osarch']):\n        return name[:-(len(arch) + 1)]\n    return name",
            "def normalize_name(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Strips the architecture from the specified package name, if necessary.\\n    Circumstances where this would be done include:\\n\\n    * If the arch is 32 bit and the package name ends in a 32-bit arch.\\n    * If the arch matches the OS arch, or is ``noarch``.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.normalize_name zsh.x86_64\\n    \"\n    try:\n        arch = name.rsplit(PKG_ARCH_SEPARATOR, 1)[-1]\n        if arch not in salt.utils.pkg.rpm.ARCHES + ('noarch',):\n            return name\n    except ValueError:\n        return name\n    if arch in (__grains__['osarch'], 'noarch') or salt.utils.pkg.rpm.check_32(arch, osarch=__grains__['osarch']):\n        return name[:-(len(arch) + 1)]\n    return name"
        ]
    },
    {
        "func_name": "parse_arch",
        "original": "def parse_arch(name):\n    \"\"\"\n    Parse name and architecture from the specified package name.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.parse_arch zsh.x86_64\n    \"\"\"\n    (_name, _arch) = (None, None)\n    try:\n        (_name, _arch) = name.rsplit(PKG_ARCH_SEPARATOR, 1)\n    except ValueError:\n        pass\n    if _arch not in salt.utils.pkg.rpm.ARCHES + ('noarch',):\n        _name = name\n        _arch = None\n    return {'name': _name, 'arch': _arch}",
        "mutated": [
            "def parse_arch(name):\n    if False:\n        i = 10\n    \"\\n    Parse name and architecture from the specified package name.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.parse_arch zsh.x86_64\\n    \"\n    (_name, _arch) = (None, None)\n    try:\n        (_name, _arch) = name.rsplit(PKG_ARCH_SEPARATOR, 1)\n    except ValueError:\n        pass\n    if _arch not in salt.utils.pkg.rpm.ARCHES + ('noarch',):\n        _name = name\n        _arch = None\n    return {'name': _name, 'arch': _arch}",
            "def parse_arch(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Parse name and architecture from the specified package name.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.parse_arch zsh.x86_64\\n    \"\n    (_name, _arch) = (None, None)\n    try:\n        (_name, _arch) = name.rsplit(PKG_ARCH_SEPARATOR, 1)\n    except ValueError:\n        pass\n    if _arch not in salt.utils.pkg.rpm.ARCHES + ('noarch',):\n        _name = name\n        _arch = None\n    return {'name': _name, 'arch': _arch}",
            "def parse_arch(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Parse name and architecture from the specified package name.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.parse_arch zsh.x86_64\\n    \"\n    (_name, _arch) = (None, None)\n    try:\n        (_name, _arch) = name.rsplit(PKG_ARCH_SEPARATOR, 1)\n    except ValueError:\n        pass\n    if _arch not in salt.utils.pkg.rpm.ARCHES + ('noarch',):\n        _name = name\n        _arch = None\n    return {'name': _name, 'arch': _arch}",
            "def parse_arch(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Parse name and architecture from the specified package name.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.parse_arch zsh.x86_64\\n    \"\n    (_name, _arch) = (None, None)\n    try:\n        (_name, _arch) = name.rsplit(PKG_ARCH_SEPARATOR, 1)\n    except ValueError:\n        pass\n    if _arch not in salt.utils.pkg.rpm.ARCHES + ('noarch',):\n        _name = name\n        _arch = None\n    return {'name': _name, 'arch': _arch}",
            "def parse_arch(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Parse name and architecture from the specified package name.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.parse_arch zsh.x86_64\\n    \"\n    (_name, _arch) = (None, None)\n    try:\n        (_name, _arch) = name.rsplit(PKG_ARCH_SEPARATOR, 1)\n    except ValueError:\n        pass\n    if _arch not in salt.utils.pkg.rpm.ARCHES + ('noarch',):\n        _name = name\n        _arch = None\n    return {'name': _name, 'arch': _arch}"
        ]
    },
    {
        "func_name": "_check_cur",
        "original": "def _check_cur(pkg):\n    if pkg.name in cur_pkgs:\n        for installed_version in cur_pkgs[pkg.name]:\n            if salt.utils.versions.compare(ver1=installed_version, oper='>=', ver2=pkg.version, cmp_func=version_cmp):\n                return False\n        return True\n    else:\n        return True",
        "mutated": [
            "def _check_cur(pkg):\n    if False:\n        i = 10\n    if pkg.name in cur_pkgs:\n        for installed_version in cur_pkgs[pkg.name]:\n            if salt.utils.versions.compare(ver1=installed_version, oper='>=', ver2=pkg.version, cmp_func=version_cmp):\n                return False\n        return True\n    else:\n        return True",
            "def _check_cur(pkg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if pkg.name in cur_pkgs:\n        for installed_version in cur_pkgs[pkg.name]:\n            if salt.utils.versions.compare(ver1=installed_version, oper='>=', ver2=pkg.version, cmp_func=version_cmp):\n                return False\n        return True\n    else:\n        return True",
            "def _check_cur(pkg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if pkg.name in cur_pkgs:\n        for installed_version in cur_pkgs[pkg.name]:\n            if salt.utils.versions.compare(ver1=installed_version, oper='>=', ver2=pkg.version, cmp_func=version_cmp):\n                return False\n        return True\n    else:\n        return True",
            "def _check_cur(pkg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if pkg.name in cur_pkgs:\n        for installed_version in cur_pkgs[pkg.name]:\n            if salt.utils.versions.compare(ver1=installed_version, oper='>=', ver2=pkg.version, cmp_func=version_cmp):\n                return False\n        return True\n    else:\n        return True",
            "def _check_cur(pkg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if pkg.name in cur_pkgs:\n        for installed_version in cur_pkgs[pkg.name]:\n            if salt.utils.versions.compare(ver1=installed_version, oper='>=', ver2=pkg.version, cmp_func=version_cmp):\n                return False\n        return True\n    else:\n        return True"
        ]
    },
    {
        "func_name": "latest_version",
        "original": "def latest_version(*names, **kwargs):\n    \"\"\"\n    Return the latest version of the named package available for upgrade or\n    installation. If more than one package name is specified, a dict of\n    name/version pairs is returned.\n\n    If the latest version of a given package is already installed, an empty\n    string will be returned for that package.\n\n    A specific repo can be requested using the ``fromrepo`` keyword argument,\n    and the ``disableexcludes`` option is also supported.\n\n    .. versionadded:: 2014.7.0\n        Support for the ``disableexcludes`` option\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.latest_version <package name>\n        salt '*' pkg.latest_version <package name> fromrepo=epel-testing\n        salt '*' pkg.latest_version <package name> disableexcludes=main\n        salt '*' pkg.latest_version <package1> <package2> <package3> ...\n    \"\"\"\n    refresh = salt.utils.data.is_true(kwargs.pop('refresh', True))\n    if not names:\n        return ''\n    options = _get_options(**kwargs)\n    if refresh:\n        refresh_db(**kwargs)\n    cur_pkgs = list_pkgs(versions_as_list=True)\n    cmd = ['--quiet']\n    cmd.extend(options)\n    cmd.extend(['list', 'available'])\n    cmd.extend(names)\n    out = _call_yum(cmd, ignore_retcode=True)\n    if out['retcode'] != 0:\n        if out['stderr']:\n            if not all([x in cur_pkgs for x in names]):\n                log.error('Problem encountered getting latest version for the following package(s): %s. Stderr follows: \\n%s', ', '.join(names), out['stderr'])\n        updates = []\n    else:\n        updates = sorted(_yum_pkginfo(out['stdout']), key=lambda pkginfo: LooseVersion(pkginfo.version), reverse=True)\n\n    def _check_cur(pkg):\n        if pkg.name in cur_pkgs:\n            for installed_version in cur_pkgs[pkg.name]:\n                if salt.utils.versions.compare(ver1=installed_version, oper='>=', ver2=pkg.version, cmp_func=version_cmp):\n                    return False\n            return True\n        else:\n            return True\n    ret = {}\n    for name in names:\n        try:\n            arch = name.rsplit('.', 1)[-1]\n            if arch not in salt.utils.pkg.rpm.ARCHES:\n                arch = __grains__['osarch']\n        except ValueError:\n            arch = __grains__['osarch']\n        for pkg in (x for x in updates if x.name == name):\n            if pkg.arch == 'noarch' or pkg.arch == arch or salt.utils.pkg.rpm.check_32(pkg.arch):\n                if _check_cur(pkg):\n                    ret[name] = pkg.version\n                    break\n        else:\n            ret[name] = ''\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret",
        "mutated": [
            "def latest_version(*names, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Return the latest version of the named package available for upgrade or\\n    installation. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    If the latest version of a given package is already installed, an empty\\n    string will be returned for that package.\\n\\n    A specific repo can be requested using the ``fromrepo`` keyword argument,\\n    and the ``disableexcludes`` option is also supported.\\n\\n    .. versionadded:: 2014.7.0\\n        Support for the ``disableexcludes`` option\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.latest_version <package name>\\n        salt '*' pkg.latest_version <package name> fromrepo=epel-testing\\n        salt '*' pkg.latest_version <package name> disableexcludes=main\\n        salt '*' pkg.latest_version <package1> <package2> <package3> ...\\n    \"\n    refresh = salt.utils.data.is_true(kwargs.pop('refresh', True))\n    if not names:\n        return ''\n    options = _get_options(**kwargs)\n    if refresh:\n        refresh_db(**kwargs)\n    cur_pkgs = list_pkgs(versions_as_list=True)\n    cmd = ['--quiet']\n    cmd.extend(options)\n    cmd.extend(['list', 'available'])\n    cmd.extend(names)\n    out = _call_yum(cmd, ignore_retcode=True)\n    if out['retcode'] != 0:\n        if out['stderr']:\n            if not all([x in cur_pkgs for x in names]):\n                log.error('Problem encountered getting latest version for the following package(s): %s. Stderr follows: \\n%s', ', '.join(names), out['stderr'])\n        updates = []\n    else:\n        updates = sorted(_yum_pkginfo(out['stdout']), key=lambda pkginfo: LooseVersion(pkginfo.version), reverse=True)\n\n    def _check_cur(pkg):\n        if pkg.name in cur_pkgs:\n            for installed_version in cur_pkgs[pkg.name]:\n                if salt.utils.versions.compare(ver1=installed_version, oper='>=', ver2=pkg.version, cmp_func=version_cmp):\n                    return False\n            return True\n        else:\n            return True\n    ret = {}\n    for name in names:\n        try:\n            arch = name.rsplit('.', 1)[-1]\n            if arch not in salt.utils.pkg.rpm.ARCHES:\n                arch = __grains__['osarch']\n        except ValueError:\n            arch = __grains__['osarch']\n        for pkg in (x for x in updates if x.name == name):\n            if pkg.arch == 'noarch' or pkg.arch == arch or salt.utils.pkg.rpm.check_32(pkg.arch):\n                if _check_cur(pkg):\n                    ret[name] = pkg.version\n                    break\n        else:\n            ret[name] = ''\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret",
            "def latest_version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Return the latest version of the named package available for upgrade or\\n    installation. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    If the latest version of a given package is already installed, an empty\\n    string will be returned for that package.\\n\\n    A specific repo can be requested using the ``fromrepo`` keyword argument,\\n    and the ``disableexcludes`` option is also supported.\\n\\n    .. versionadded:: 2014.7.0\\n        Support for the ``disableexcludes`` option\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.latest_version <package name>\\n        salt '*' pkg.latest_version <package name> fromrepo=epel-testing\\n        salt '*' pkg.latest_version <package name> disableexcludes=main\\n        salt '*' pkg.latest_version <package1> <package2> <package3> ...\\n    \"\n    refresh = salt.utils.data.is_true(kwargs.pop('refresh', True))\n    if not names:\n        return ''\n    options = _get_options(**kwargs)\n    if refresh:\n        refresh_db(**kwargs)\n    cur_pkgs = list_pkgs(versions_as_list=True)\n    cmd = ['--quiet']\n    cmd.extend(options)\n    cmd.extend(['list', 'available'])\n    cmd.extend(names)\n    out = _call_yum(cmd, ignore_retcode=True)\n    if out['retcode'] != 0:\n        if out['stderr']:\n            if not all([x in cur_pkgs for x in names]):\n                log.error('Problem encountered getting latest version for the following package(s): %s. Stderr follows: \\n%s', ', '.join(names), out['stderr'])\n        updates = []\n    else:\n        updates = sorted(_yum_pkginfo(out['stdout']), key=lambda pkginfo: LooseVersion(pkginfo.version), reverse=True)\n\n    def _check_cur(pkg):\n        if pkg.name in cur_pkgs:\n            for installed_version in cur_pkgs[pkg.name]:\n                if salt.utils.versions.compare(ver1=installed_version, oper='>=', ver2=pkg.version, cmp_func=version_cmp):\n                    return False\n            return True\n        else:\n            return True\n    ret = {}\n    for name in names:\n        try:\n            arch = name.rsplit('.', 1)[-1]\n            if arch not in salt.utils.pkg.rpm.ARCHES:\n                arch = __grains__['osarch']\n        except ValueError:\n            arch = __grains__['osarch']\n        for pkg in (x for x in updates if x.name == name):\n            if pkg.arch == 'noarch' or pkg.arch == arch or salt.utils.pkg.rpm.check_32(pkg.arch):\n                if _check_cur(pkg):\n                    ret[name] = pkg.version\n                    break\n        else:\n            ret[name] = ''\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret",
            "def latest_version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Return the latest version of the named package available for upgrade or\\n    installation. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    If the latest version of a given package is already installed, an empty\\n    string will be returned for that package.\\n\\n    A specific repo can be requested using the ``fromrepo`` keyword argument,\\n    and the ``disableexcludes`` option is also supported.\\n\\n    .. versionadded:: 2014.7.0\\n        Support for the ``disableexcludes`` option\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.latest_version <package name>\\n        salt '*' pkg.latest_version <package name> fromrepo=epel-testing\\n        salt '*' pkg.latest_version <package name> disableexcludes=main\\n        salt '*' pkg.latest_version <package1> <package2> <package3> ...\\n    \"\n    refresh = salt.utils.data.is_true(kwargs.pop('refresh', True))\n    if not names:\n        return ''\n    options = _get_options(**kwargs)\n    if refresh:\n        refresh_db(**kwargs)\n    cur_pkgs = list_pkgs(versions_as_list=True)\n    cmd = ['--quiet']\n    cmd.extend(options)\n    cmd.extend(['list', 'available'])\n    cmd.extend(names)\n    out = _call_yum(cmd, ignore_retcode=True)\n    if out['retcode'] != 0:\n        if out['stderr']:\n            if not all([x in cur_pkgs for x in names]):\n                log.error('Problem encountered getting latest version for the following package(s): %s. Stderr follows: \\n%s', ', '.join(names), out['stderr'])\n        updates = []\n    else:\n        updates = sorted(_yum_pkginfo(out['stdout']), key=lambda pkginfo: LooseVersion(pkginfo.version), reverse=True)\n\n    def _check_cur(pkg):\n        if pkg.name in cur_pkgs:\n            for installed_version in cur_pkgs[pkg.name]:\n                if salt.utils.versions.compare(ver1=installed_version, oper='>=', ver2=pkg.version, cmp_func=version_cmp):\n                    return False\n            return True\n        else:\n            return True\n    ret = {}\n    for name in names:\n        try:\n            arch = name.rsplit('.', 1)[-1]\n            if arch not in salt.utils.pkg.rpm.ARCHES:\n                arch = __grains__['osarch']\n        except ValueError:\n            arch = __grains__['osarch']\n        for pkg in (x for x in updates if x.name == name):\n            if pkg.arch == 'noarch' or pkg.arch == arch or salt.utils.pkg.rpm.check_32(pkg.arch):\n                if _check_cur(pkg):\n                    ret[name] = pkg.version\n                    break\n        else:\n            ret[name] = ''\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret",
            "def latest_version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Return the latest version of the named package available for upgrade or\\n    installation. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    If the latest version of a given package is already installed, an empty\\n    string will be returned for that package.\\n\\n    A specific repo can be requested using the ``fromrepo`` keyword argument,\\n    and the ``disableexcludes`` option is also supported.\\n\\n    .. versionadded:: 2014.7.0\\n        Support for the ``disableexcludes`` option\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.latest_version <package name>\\n        salt '*' pkg.latest_version <package name> fromrepo=epel-testing\\n        salt '*' pkg.latest_version <package name> disableexcludes=main\\n        salt '*' pkg.latest_version <package1> <package2> <package3> ...\\n    \"\n    refresh = salt.utils.data.is_true(kwargs.pop('refresh', True))\n    if not names:\n        return ''\n    options = _get_options(**kwargs)\n    if refresh:\n        refresh_db(**kwargs)\n    cur_pkgs = list_pkgs(versions_as_list=True)\n    cmd = ['--quiet']\n    cmd.extend(options)\n    cmd.extend(['list', 'available'])\n    cmd.extend(names)\n    out = _call_yum(cmd, ignore_retcode=True)\n    if out['retcode'] != 0:\n        if out['stderr']:\n            if not all([x in cur_pkgs for x in names]):\n                log.error('Problem encountered getting latest version for the following package(s): %s. Stderr follows: \\n%s', ', '.join(names), out['stderr'])\n        updates = []\n    else:\n        updates = sorted(_yum_pkginfo(out['stdout']), key=lambda pkginfo: LooseVersion(pkginfo.version), reverse=True)\n\n    def _check_cur(pkg):\n        if pkg.name in cur_pkgs:\n            for installed_version in cur_pkgs[pkg.name]:\n                if salt.utils.versions.compare(ver1=installed_version, oper='>=', ver2=pkg.version, cmp_func=version_cmp):\n                    return False\n            return True\n        else:\n            return True\n    ret = {}\n    for name in names:\n        try:\n            arch = name.rsplit('.', 1)[-1]\n            if arch not in salt.utils.pkg.rpm.ARCHES:\n                arch = __grains__['osarch']\n        except ValueError:\n            arch = __grains__['osarch']\n        for pkg in (x for x in updates if x.name == name):\n            if pkg.arch == 'noarch' or pkg.arch == arch or salt.utils.pkg.rpm.check_32(pkg.arch):\n                if _check_cur(pkg):\n                    ret[name] = pkg.version\n                    break\n        else:\n            ret[name] = ''\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret",
            "def latest_version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Return the latest version of the named package available for upgrade or\\n    installation. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    If the latest version of a given package is already installed, an empty\\n    string will be returned for that package.\\n\\n    A specific repo can be requested using the ``fromrepo`` keyword argument,\\n    and the ``disableexcludes`` option is also supported.\\n\\n    .. versionadded:: 2014.7.0\\n        Support for the ``disableexcludes`` option\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.latest_version <package name>\\n        salt '*' pkg.latest_version <package name> fromrepo=epel-testing\\n        salt '*' pkg.latest_version <package name> disableexcludes=main\\n        salt '*' pkg.latest_version <package1> <package2> <package3> ...\\n    \"\n    refresh = salt.utils.data.is_true(kwargs.pop('refresh', True))\n    if not names:\n        return ''\n    options = _get_options(**kwargs)\n    if refresh:\n        refresh_db(**kwargs)\n    cur_pkgs = list_pkgs(versions_as_list=True)\n    cmd = ['--quiet']\n    cmd.extend(options)\n    cmd.extend(['list', 'available'])\n    cmd.extend(names)\n    out = _call_yum(cmd, ignore_retcode=True)\n    if out['retcode'] != 0:\n        if out['stderr']:\n            if not all([x in cur_pkgs for x in names]):\n                log.error('Problem encountered getting latest version for the following package(s): %s. Stderr follows: \\n%s', ', '.join(names), out['stderr'])\n        updates = []\n    else:\n        updates = sorted(_yum_pkginfo(out['stdout']), key=lambda pkginfo: LooseVersion(pkginfo.version), reverse=True)\n\n    def _check_cur(pkg):\n        if pkg.name in cur_pkgs:\n            for installed_version in cur_pkgs[pkg.name]:\n                if salt.utils.versions.compare(ver1=installed_version, oper='>=', ver2=pkg.version, cmp_func=version_cmp):\n                    return False\n            return True\n        else:\n            return True\n    ret = {}\n    for name in names:\n        try:\n            arch = name.rsplit('.', 1)[-1]\n            if arch not in salt.utils.pkg.rpm.ARCHES:\n                arch = __grains__['osarch']\n        except ValueError:\n            arch = __grains__['osarch']\n        for pkg in (x for x in updates if x.name == name):\n            if pkg.arch == 'noarch' or pkg.arch == arch or salt.utils.pkg.rpm.check_32(pkg.arch):\n                if _check_cur(pkg):\n                    ret[name] = pkg.version\n                    break\n        else:\n            ret[name] = ''\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret"
        ]
    },
    {
        "func_name": "upgrade_available",
        "original": "def upgrade_available(name, **kwargs):\n    \"\"\"\n    Check whether or not an upgrade is available for a given package\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.upgrade_available <package name>\n    \"\"\"\n    return latest_version(name, **kwargs) != ''",
        "mutated": [
            "def upgrade_available(name, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Check whether or not an upgrade is available for a given package\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade_available <package name>\\n    \"\n    return latest_version(name, **kwargs) != ''",
            "def upgrade_available(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Check whether or not an upgrade is available for a given package\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade_available <package name>\\n    \"\n    return latest_version(name, **kwargs) != ''",
            "def upgrade_available(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Check whether or not an upgrade is available for a given package\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade_available <package name>\\n    \"\n    return latest_version(name, **kwargs) != ''",
            "def upgrade_available(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Check whether or not an upgrade is available for a given package\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade_available <package name>\\n    \"\n    return latest_version(name, **kwargs) != ''",
            "def upgrade_available(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Check whether or not an upgrade is available for a given package\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade_available <package name>\\n    \"\n    return latest_version(name, **kwargs) != ''"
        ]
    },
    {
        "func_name": "version",
        "original": "def version(*names, **kwargs):\n    \"\"\"\n    Returns a string representing the package version or an empty string if not\n    installed. If more than one package name is specified, a dict of\n    name/version pairs is returned.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.version <package name>\n        salt '*' pkg.version <package1> <package2> <package3> ...\n    \"\"\"\n    return __salt__['pkg_resource.version'](*names, **kwargs)",
        "mutated": [
            "def version(*names, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Returns a string representing the package version or an empty string if not\\n    installed. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version <package name>\\n        salt '*' pkg.version <package1> <package2> <package3> ...\\n    \"\n    return __salt__['pkg_resource.version'](*names, **kwargs)",
            "def version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Returns a string representing the package version or an empty string if not\\n    installed. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version <package name>\\n        salt '*' pkg.version <package1> <package2> <package3> ...\\n    \"\n    return __salt__['pkg_resource.version'](*names, **kwargs)",
            "def version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Returns a string representing the package version or an empty string if not\\n    installed. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version <package name>\\n        salt '*' pkg.version <package1> <package2> <package3> ...\\n    \"\n    return __salt__['pkg_resource.version'](*names, **kwargs)",
            "def version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Returns a string representing the package version or an empty string if not\\n    installed. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version <package name>\\n        salt '*' pkg.version <package1> <package2> <package3> ...\\n    \"\n    return __salt__['pkg_resource.version'](*names, **kwargs)",
            "def version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Returns a string representing the package version or an empty string if not\\n    installed. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version <package name>\\n        salt '*' pkg.version <package1> <package2> <package3> ...\\n    \"\n    return __salt__['pkg_resource.version'](*names, **kwargs)"
        ]
    },
    {
        "func_name": "version_cmp",
        "original": "def version_cmp(pkg1, pkg2, ignore_epoch=False, **kwargs):\n    \"\"\"\n    .. versionadded:: 2015.5.4\n\n    Do a cmp-style comparison on two packages. Return -1 if pkg1 < pkg2, 0 if\n    pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem\n    making the comparison.\n\n    ignore_epoch : False\n        Set to ``True`` to ignore the epoch when comparing versions\n\n        .. versionadded:: 2015.8.10,2016.3.2\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.version_cmp '0.2-001' '0.2.0.1-002'\n    \"\"\"\n    return __salt__['lowpkg.version_cmp'](pkg1, pkg2, ignore_epoch=ignore_epoch)",
        "mutated": [
            "def version_cmp(pkg1, pkg2, ignore_epoch=False, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2015.5.4\\n\\n    Do a cmp-style comparison on two packages. Return -1 if pkg1 < pkg2, 0 if\\n    pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem\\n    making the comparison.\\n\\n    ignore_epoch : False\\n        Set to ``True`` to ignore the epoch when comparing versions\\n\\n        .. versionadded:: 2015.8.10,2016.3.2\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version_cmp '0.2-001' '0.2.0.1-002'\\n    \"\n    return __salt__['lowpkg.version_cmp'](pkg1, pkg2, ignore_epoch=ignore_epoch)",
            "def version_cmp(pkg1, pkg2, ignore_epoch=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2015.5.4\\n\\n    Do a cmp-style comparison on two packages. Return -1 if pkg1 < pkg2, 0 if\\n    pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem\\n    making the comparison.\\n\\n    ignore_epoch : False\\n        Set to ``True`` to ignore the epoch when comparing versions\\n\\n        .. versionadded:: 2015.8.10,2016.3.2\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version_cmp '0.2-001' '0.2.0.1-002'\\n    \"\n    return __salt__['lowpkg.version_cmp'](pkg1, pkg2, ignore_epoch=ignore_epoch)",
            "def version_cmp(pkg1, pkg2, ignore_epoch=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2015.5.4\\n\\n    Do a cmp-style comparison on two packages. Return -1 if pkg1 < pkg2, 0 if\\n    pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem\\n    making the comparison.\\n\\n    ignore_epoch : False\\n        Set to ``True`` to ignore the epoch when comparing versions\\n\\n        .. versionadded:: 2015.8.10,2016.3.2\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version_cmp '0.2-001' '0.2.0.1-002'\\n    \"\n    return __salt__['lowpkg.version_cmp'](pkg1, pkg2, ignore_epoch=ignore_epoch)",
            "def version_cmp(pkg1, pkg2, ignore_epoch=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2015.5.4\\n\\n    Do a cmp-style comparison on two packages. Return -1 if pkg1 < pkg2, 0 if\\n    pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem\\n    making the comparison.\\n\\n    ignore_epoch : False\\n        Set to ``True`` to ignore the epoch when comparing versions\\n\\n        .. versionadded:: 2015.8.10,2016.3.2\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version_cmp '0.2-001' '0.2.0.1-002'\\n    \"\n    return __salt__['lowpkg.version_cmp'](pkg1, pkg2, ignore_epoch=ignore_epoch)",
            "def version_cmp(pkg1, pkg2, ignore_epoch=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2015.5.4\\n\\n    Do a cmp-style comparison on two packages. Return -1 if pkg1 < pkg2, 0 if\\n    pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem\\n    making the comparison.\\n\\n    ignore_epoch : False\\n        Set to ``True`` to ignore the epoch when comparing versions\\n\\n        .. versionadded:: 2015.8.10,2016.3.2\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version_cmp '0.2-001' '0.2.0.1-002'\\n    \"\n    return __salt__['lowpkg.version_cmp'](pkg1, pkg2, ignore_epoch=ignore_epoch)"
        ]
    },
    {
        "func_name": "_list_pkgs_from_context",
        "original": "def _list_pkgs_from_context(versions_as_list, contextkey, attr):\n    \"\"\"\n    Use pkg list from __context__\n    \"\"\"\n    return __salt__['pkg_resource.format_pkg_list'](__context__[contextkey], versions_as_list, attr)",
        "mutated": [
            "def _list_pkgs_from_context(versions_as_list, contextkey, attr):\n    if False:\n        i = 10\n    '\\n    Use pkg list from __context__\\n    '\n    return __salt__['pkg_resource.format_pkg_list'](__context__[contextkey], versions_as_list, attr)",
            "def _list_pkgs_from_context(versions_as_list, contextkey, attr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Use pkg list from __context__\\n    '\n    return __salt__['pkg_resource.format_pkg_list'](__context__[contextkey], versions_as_list, attr)",
            "def _list_pkgs_from_context(versions_as_list, contextkey, attr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Use pkg list from __context__\\n    '\n    return __salt__['pkg_resource.format_pkg_list'](__context__[contextkey], versions_as_list, attr)",
            "def _list_pkgs_from_context(versions_as_list, contextkey, attr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Use pkg list from __context__\\n    '\n    return __salt__['pkg_resource.format_pkg_list'](__context__[contextkey], versions_as_list, attr)",
            "def _list_pkgs_from_context(versions_as_list, contextkey, attr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Use pkg list from __context__\\n    '\n    return __salt__['pkg_resource.format_pkg_list'](__context__[contextkey], versions_as_list, attr)"
        ]
    },
    {
        "func_name": "list_pkgs",
        "original": "def list_pkgs(versions_as_list=False, **kwargs):\n    \"\"\"\n    List the packages currently installed as a dict. By default, the dict\n    contains versions as a comma separated string::\n\n        {'<package_name>': '<version>[,<version>...]'}\n\n    versions_as_list:\n        If set to true, the versions are provided as a list\n\n        {'<package_name>': ['<version>', '<version>']}\n\n    attr:\n        If a list of package attributes is specified, returned value will\n        contain them in addition to version, eg.::\n\n        {'<package_name>': [{'version' : 'version', 'arch' : 'arch'}]}\n\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\n        ``install_date``, ``install_date_time_t``.\n\n        If ``all`` is specified, all valid attributes will be returned.\n\n            .. versionadded:: 2018.3.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.list_pkgs\n        salt '*' pkg.list_pkgs attr=version,arch\n        salt '*' pkg.list_pkgs attr='[\"version\", \"arch\"]'\n    \"\"\"\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    attr = kwargs.get('attr')\n    if attr is not None and attr != 'all':\n        attr = salt.utils.args.split_input(attr)\n    contextkey = 'pkg.list_pkgs'\n    if contextkey in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list, contextkey, attr)\n    ret = {}\n    cmd = ['rpm', '-qa', '--nodigest', '--nosignature', '--queryformat', salt.utils.pkg.rpm.QUERYFORMAT.replace('%{REPOID}', '(none)') + '\\n']\n    output = __salt__['cmd.run'](cmd, python_shell=False, output_loglevel='trace')\n    for line in output.splitlines():\n        pkginfo = salt.utils.pkg.rpm.parse_pkginfo(line, osarch=__grains__['osarch'])\n        if pkginfo is not None:\n            pkgver = pkginfo.version\n            epoch = None\n            release = None\n            if ':' in pkgver:\n                (epoch, pkgver) = pkgver.split(':', 1)\n            if '-' in pkgver:\n                (pkgver, release) = pkgver.split('-', 1)\n            all_attr = {'epoch': epoch, 'version': pkgver, 'release': release, 'arch': pkginfo.arch, 'install_date': pkginfo.install_date, 'install_date_time_t': pkginfo.install_date_time_t}\n            __salt__['pkg_resource.add_pkg'](ret, pkginfo.name, all_attr)\n    for pkgname in ret:\n        ret[pkgname] = sorted(ret[pkgname], key=lambda d: d['version'])\n    __context__[contextkey] = ret\n    return __salt__['pkg_resource.format_pkg_list'](__context__[contextkey], versions_as_list, attr)",
        "mutated": [
            "def list_pkgs(versions_as_list=False, **kwargs):\n    if False:\n        i = 10\n    '\\n    List the packages currently installed as a dict. By default, the dict\\n    contains versions as a comma separated string::\\n\\n        {\\'<package_name>\\': \\'<version>[,<version>...]\\'}\\n\\n    versions_as_list:\\n        If set to true, the versions are provided as a list\\n\\n        {\\'<package_name>\\': [\\'<version>\\', \\'<version>\\']}\\n\\n    attr:\\n        If a list of package attributes is specified, returned value will\\n        contain them in addition to version, eg.::\\n\\n        {\\'<package_name>\\': [{\\'version\\' : \\'version\\', \\'arch\\' : \\'arch\\'}]}\\n\\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\\n        ``install_date``, ``install_date_time_t``.\\n\\n        If ``all`` is specified, all valid attributes will be returned.\\n\\n            .. versionadded:: 2018.3.0\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.list_pkgs\\n        salt \\'*\\' pkg.list_pkgs attr=version,arch\\n        salt \\'*\\' pkg.list_pkgs attr=\\'[\"version\", \"arch\"]\\'\\n    '\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    attr = kwargs.get('attr')\n    if attr is not None and attr != 'all':\n        attr = salt.utils.args.split_input(attr)\n    contextkey = 'pkg.list_pkgs'\n    if contextkey in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list, contextkey, attr)\n    ret = {}\n    cmd = ['rpm', '-qa', '--nodigest', '--nosignature', '--queryformat', salt.utils.pkg.rpm.QUERYFORMAT.replace('%{REPOID}', '(none)') + '\\n']\n    output = __salt__['cmd.run'](cmd, python_shell=False, output_loglevel='trace')\n    for line in output.splitlines():\n        pkginfo = salt.utils.pkg.rpm.parse_pkginfo(line, osarch=__grains__['osarch'])\n        if pkginfo is not None:\n            pkgver = pkginfo.version\n            epoch = None\n            release = None\n            if ':' in pkgver:\n                (epoch, pkgver) = pkgver.split(':', 1)\n            if '-' in pkgver:\n                (pkgver, release) = pkgver.split('-', 1)\n            all_attr = {'epoch': epoch, 'version': pkgver, 'release': release, 'arch': pkginfo.arch, 'install_date': pkginfo.install_date, 'install_date_time_t': pkginfo.install_date_time_t}\n            __salt__['pkg_resource.add_pkg'](ret, pkginfo.name, all_attr)\n    for pkgname in ret:\n        ret[pkgname] = sorted(ret[pkgname], key=lambda d: d['version'])\n    __context__[contextkey] = ret\n    return __salt__['pkg_resource.format_pkg_list'](__context__[contextkey], versions_as_list, attr)",
            "def list_pkgs(versions_as_list=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    List the packages currently installed as a dict. By default, the dict\\n    contains versions as a comma separated string::\\n\\n        {\\'<package_name>\\': \\'<version>[,<version>...]\\'}\\n\\n    versions_as_list:\\n        If set to true, the versions are provided as a list\\n\\n        {\\'<package_name>\\': [\\'<version>\\', \\'<version>\\']}\\n\\n    attr:\\n        If a list of package attributes is specified, returned value will\\n        contain them in addition to version, eg.::\\n\\n        {\\'<package_name>\\': [{\\'version\\' : \\'version\\', \\'arch\\' : \\'arch\\'}]}\\n\\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\\n        ``install_date``, ``install_date_time_t``.\\n\\n        If ``all`` is specified, all valid attributes will be returned.\\n\\n            .. versionadded:: 2018.3.0\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.list_pkgs\\n        salt \\'*\\' pkg.list_pkgs attr=version,arch\\n        salt \\'*\\' pkg.list_pkgs attr=\\'[\"version\", \"arch\"]\\'\\n    '\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    attr = kwargs.get('attr')\n    if attr is not None and attr != 'all':\n        attr = salt.utils.args.split_input(attr)\n    contextkey = 'pkg.list_pkgs'\n    if contextkey in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list, contextkey, attr)\n    ret = {}\n    cmd = ['rpm', '-qa', '--nodigest', '--nosignature', '--queryformat', salt.utils.pkg.rpm.QUERYFORMAT.replace('%{REPOID}', '(none)') + '\\n']\n    output = __salt__['cmd.run'](cmd, python_shell=False, output_loglevel='trace')\n    for line in output.splitlines():\n        pkginfo = salt.utils.pkg.rpm.parse_pkginfo(line, osarch=__grains__['osarch'])\n        if pkginfo is not None:\n            pkgver = pkginfo.version\n            epoch = None\n            release = None\n            if ':' in pkgver:\n                (epoch, pkgver) = pkgver.split(':', 1)\n            if '-' in pkgver:\n                (pkgver, release) = pkgver.split('-', 1)\n            all_attr = {'epoch': epoch, 'version': pkgver, 'release': release, 'arch': pkginfo.arch, 'install_date': pkginfo.install_date, 'install_date_time_t': pkginfo.install_date_time_t}\n            __salt__['pkg_resource.add_pkg'](ret, pkginfo.name, all_attr)\n    for pkgname in ret:\n        ret[pkgname] = sorted(ret[pkgname], key=lambda d: d['version'])\n    __context__[contextkey] = ret\n    return __salt__['pkg_resource.format_pkg_list'](__context__[contextkey], versions_as_list, attr)",
            "def list_pkgs(versions_as_list=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    List the packages currently installed as a dict. By default, the dict\\n    contains versions as a comma separated string::\\n\\n        {\\'<package_name>\\': \\'<version>[,<version>...]\\'}\\n\\n    versions_as_list:\\n        If set to true, the versions are provided as a list\\n\\n        {\\'<package_name>\\': [\\'<version>\\', \\'<version>\\']}\\n\\n    attr:\\n        If a list of package attributes is specified, returned value will\\n        contain them in addition to version, eg.::\\n\\n        {\\'<package_name>\\': [{\\'version\\' : \\'version\\', \\'arch\\' : \\'arch\\'}]}\\n\\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\\n        ``install_date``, ``install_date_time_t``.\\n\\n        If ``all`` is specified, all valid attributes will be returned.\\n\\n            .. versionadded:: 2018.3.0\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.list_pkgs\\n        salt \\'*\\' pkg.list_pkgs attr=version,arch\\n        salt \\'*\\' pkg.list_pkgs attr=\\'[\"version\", \"arch\"]\\'\\n    '\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    attr = kwargs.get('attr')\n    if attr is not None and attr != 'all':\n        attr = salt.utils.args.split_input(attr)\n    contextkey = 'pkg.list_pkgs'\n    if contextkey in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list, contextkey, attr)\n    ret = {}\n    cmd = ['rpm', '-qa', '--nodigest', '--nosignature', '--queryformat', salt.utils.pkg.rpm.QUERYFORMAT.replace('%{REPOID}', '(none)') + '\\n']\n    output = __salt__['cmd.run'](cmd, python_shell=False, output_loglevel='trace')\n    for line in output.splitlines():\n        pkginfo = salt.utils.pkg.rpm.parse_pkginfo(line, osarch=__grains__['osarch'])\n        if pkginfo is not None:\n            pkgver = pkginfo.version\n            epoch = None\n            release = None\n            if ':' in pkgver:\n                (epoch, pkgver) = pkgver.split(':', 1)\n            if '-' in pkgver:\n                (pkgver, release) = pkgver.split('-', 1)\n            all_attr = {'epoch': epoch, 'version': pkgver, 'release': release, 'arch': pkginfo.arch, 'install_date': pkginfo.install_date, 'install_date_time_t': pkginfo.install_date_time_t}\n            __salt__['pkg_resource.add_pkg'](ret, pkginfo.name, all_attr)\n    for pkgname in ret:\n        ret[pkgname] = sorted(ret[pkgname], key=lambda d: d['version'])\n    __context__[contextkey] = ret\n    return __salt__['pkg_resource.format_pkg_list'](__context__[contextkey], versions_as_list, attr)",
            "def list_pkgs(versions_as_list=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    List the packages currently installed as a dict. By default, the dict\\n    contains versions as a comma separated string::\\n\\n        {\\'<package_name>\\': \\'<version>[,<version>...]\\'}\\n\\n    versions_as_list:\\n        If set to true, the versions are provided as a list\\n\\n        {\\'<package_name>\\': [\\'<version>\\', \\'<version>\\']}\\n\\n    attr:\\n        If a list of package attributes is specified, returned value will\\n        contain them in addition to version, eg.::\\n\\n        {\\'<package_name>\\': [{\\'version\\' : \\'version\\', \\'arch\\' : \\'arch\\'}]}\\n\\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\\n        ``install_date``, ``install_date_time_t``.\\n\\n        If ``all`` is specified, all valid attributes will be returned.\\n\\n            .. versionadded:: 2018.3.0\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.list_pkgs\\n        salt \\'*\\' pkg.list_pkgs attr=version,arch\\n        salt \\'*\\' pkg.list_pkgs attr=\\'[\"version\", \"arch\"]\\'\\n    '\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    attr = kwargs.get('attr')\n    if attr is not None and attr != 'all':\n        attr = salt.utils.args.split_input(attr)\n    contextkey = 'pkg.list_pkgs'\n    if contextkey in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list, contextkey, attr)\n    ret = {}\n    cmd = ['rpm', '-qa', '--nodigest', '--nosignature', '--queryformat', salt.utils.pkg.rpm.QUERYFORMAT.replace('%{REPOID}', '(none)') + '\\n']\n    output = __salt__['cmd.run'](cmd, python_shell=False, output_loglevel='trace')\n    for line in output.splitlines():\n        pkginfo = salt.utils.pkg.rpm.parse_pkginfo(line, osarch=__grains__['osarch'])\n        if pkginfo is not None:\n            pkgver = pkginfo.version\n            epoch = None\n            release = None\n            if ':' in pkgver:\n                (epoch, pkgver) = pkgver.split(':', 1)\n            if '-' in pkgver:\n                (pkgver, release) = pkgver.split('-', 1)\n            all_attr = {'epoch': epoch, 'version': pkgver, 'release': release, 'arch': pkginfo.arch, 'install_date': pkginfo.install_date, 'install_date_time_t': pkginfo.install_date_time_t}\n            __salt__['pkg_resource.add_pkg'](ret, pkginfo.name, all_attr)\n    for pkgname in ret:\n        ret[pkgname] = sorted(ret[pkgname], key=lambda d: d['version'])\n    __context__[contextkey] = ret\n    return __salt__['pkg_resource.format_pkg_list'](__context__[contextkey], versions_as_list, attr)",
            "def list_pkgs(versions_as_list=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    List the packages currently installed as a dict. By default, the dict\\n    contains versions as a comma separated string::\\n\\n        {\\'<package_name>\\': \\'<version>[,<version>...]\\'}\\n\\n    versions_as_list:\\n        If set to true, the versions are provided as a list\\n\\n        {\\'<package_name>\\': [\\'<version>\\', \\'<version>\\']}\\n\\n    attr:\\n        If a list of package attributes is specified, returned value will\\n        contain them in addition to version, eg.::\\n\\n        {\\'<package_name>\\': [{\\'version\\' : \\'version\\', \\'arch\\' : \\'arch\\'}]}\\n\\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\\n        ``install_date``, ``install_date_time_t``.\\n\\n        If ``all`` is specified, all valid attributes will be returned.\\n\\n            .. versionadded:: 2018.3.0\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.list_pkgs\\n        salt \\'*\\' pkg.list_pkgs attr=version,arch\\n        salt \\'*\\' pkg.list_pkgs attr=\\'[\"version\", \"arch\"]\\'\\n    '\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    attr = kwargs.get('attr')\n    if attr is not None and attr != 'all':\n        attr = salt.utils.args.split_input(attr)\n    contextkey = 'pkg.list_pkgs'\n    if contextkey in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list, contextkey, attr)\n    ret = {}\n    cmd = ['rpm', '-qa', '--nodigest', '--nosignature', '--queryformat', salt.utils.pkg.rpm.QUERYFORMAT.replace('%{REPOID}', '(none)') + '\\n']\n    output = __salt__['cmd.run'](cmd, python_shell=False, output_loglevel='trace')\n    for line in output.splitlines():\n        pkginfo = salt.utils.pkg.rpm.parse_pkginfo(line, osarch=__grains__['osarch'])\n        if pkginfo is not None:\n            pkgver = pkginfo.version\n            epoch = None\n            release = None\n            if ':' in pkgver:\n                (epoch, pkgver) = pkgver.split(':', 1)\n            if '-' in pkgver:\n                (pkgver, release) = pkgver.split('-', 1)\n            all_attr = {'epoch': epoch, 'version': pkgver, 'release': release, 'arch': pkginfo.arch, 'install_date': pkginfo.install_date, 'install_date_time_t': pkginfo.install_date_time_t}\n            __salt__['pkg_resource.add_pkg'](ret, pkginfo.name, all_attr)\n    for pkgname in ret:\n        ret[pkgname] = sorted(ret[pkgname], key=lambda d: d['version'])\n    __context__[contextkey] = ret\n    return __salt__['pkg_resource.format_pkg_list'](__context__[contextkey], versions_as_list, attr)"
        ]
    },
    {
        "func_name": "_check_args",
        "original": "def _check_args(args, name):\n    \"\"\"\n        Do glob matching on args and return True if a match was found.\n        Otherwise, return False\n        \"\"\"\n    for arg in args:\n        if fnmatch.fnmatch(name, arg):\n            return True\n    return False",
        "mutated": [
            "def _check_args(args, name):\n    if False:\n        i = 10\n    '\\n        Do glob matching on args and return True if a match was found.\\n        Otherwise, return False\\n        '\n    for arg in args:\n        if fnmatch.fnmatch(name, arg):\n            return True\n    return False",
            "def _check_args(args, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Do glob matching on args and return True if a match was found.\\n        Otherwise, return False\\n        '\n    for arg in args:\n        if fnmatch.fnmatch(name, arg):\n            return True\n    return False",
            "def _check_args(args, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Do glob matching on args and return True if a match was found.\\n        Otherwise, return False\\n        '\n    for arg in args:\n        if fnmatch.fnmatch(name, arg):\n            return True\n    return False",
            "def _check_args(args, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Do glob matching on args and return True if a match was found.\\n        Otherwise, return False\\n        '\n    for arg in args:\n        if fnmatch.fnmatch(name, arg):\n            return True\n    return False",
            "def _check_args(args, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Do glob matching on args and return True if a match was found.\\n        Otherwise, return False\\n        '\n    for arg in args:\n        if fnmatch.fnmatch(name, arg):\n            return True\n    return False"
        ]
    },
    {
        "func_name": "_parse_output",
        "original": "def _parse_output(output, strict=False):\n    for pkg in _yum_pkginfo(output):\n        if strict and (pkg.repoid not in repos or not _check_args(args, pkg.name)):\n            continue\n        repo_dict = ret.setdefault(pkg.repoid, {})\n        version_list = repo_dict.setdefault(pkg.name, set())\n        version_list.add(pkg.version)",
        "mutated": [
            "def _parse_output(output, strict=False):\n    if False:\n        i = 10\n    for pkg in _yum_pkginfo(output):\n        if strict and (pkg.repoid not in repos or not _check_args(args, pkg.name)):\n            continue\n        repo_dict = ret.setdefault(pkg.repoid, {})\n        version_list = repo_dict.setdefault(pkg.name, set())\n        version_list.add(pkg.version)",
            "def _parse_output(output, strict=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for pkg in _yum_pkginfo(output):\n        if strict and (pkg.repoid not in repos or not _check_args(args, pkg.name)):\n            continue\n        repo_dict = ret.setdefault(pkg.repoid, {})\n        version_list = repo_dict.setdefault(pkg.name, set())\n        version_list.add(pkg.version)",
            "def _parse_output(output, strict=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for pkg in _yum_pkginfo(output):\n        if strict and (pkg.repoid not in repos or not _check_args(args, pkg.name)):\n            continue\n        repo_dict = ret.setdefault(pkg.repoid, {})\n        version_list = repo_dict.setdefault(pkg.name, set())\n        version_list.add(pkg.version)",
            "def _parse_output(output, strict=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for pkg in _yum_pkginfo(output):\n        if strict and (pkg.repoid not in repos or not _check_args(args, pkg.name)):\n            continue\n        repo_dict = ret.setdefault(pkg.repoid, {})\n        version_list = repo_dict.setdefault(pkg.name, set())\n        version_list.add(pkg.version)",
            "def _parse_output(output, strict=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for pkg in _yum_pkginfo(output):\n        if strict and (pkg.repoid not in repos or not _check_args(args, pkg.name)):\n            continue\n        repo_dict = ret.setdefault(pkg.repoid, {})\n        version_list = repo_dict.setdefault(pkg.name, set())\n        version_list.add(pkg.version)"
        ]
    },
    {
        "func_name": "list_repo_pkgs",
        "original": "def list_repo_pkgs(*args, **kwargs):\n    \"\"\"\n    .. versionadded:: 2014.1.0\n    .. versionchanged:: 2014.7.0\n        All available versions of each package are now returned. This required\n        a slight modification to the structure of the return dict. The return\n        data shown below reflects the updated return dict structure. Note that\n        packages which are version-locked using :py:mod:`pkg.hold\n        <salt.modules.yumpkg.hold>` will only show the currently-installed\n        version, as locking a package will make other versions appear\n        unavailable to yum/dnf.\n    .. versionchanged:: 2017.7.0\n        By default, the versions for each package are no longer organized by\n        repository. To get results organized by repository, use\n        ``byrepo=True``.\n\n    Returns all available packages. Optionally, package names (and name globs)\n    can be passed and the results will be filtered to packages matching those\n    names. This is recommended as it speeds up the function considerably.\n\n    .. warning::\n        Running this function on RHEL/CentOS 6 and earlier will be more\n        resource-intensive, as the version of yum that ships with older\n        RHEL/CentOS has no yum subcommand for listing packages from a\n        repository. Thus, a ``yum list installed`` and ``yum list available``\n        are run, which generates a lot of output, which must then be analyzed\n        to determine which package information to include in the return data.\n\n    This function can be helpful in discovering the version or repo to specify\n    in a :mod:`pkg.installed <salt.states.pkg.installed>` state.\n\n    The return data will be a dictionary mapping package names to a list of\n    version numbers, ordered from newest to oldest. If ``byrepo`` is set to\n    ``True``, then the return dictionary will contain repository names at the\n    top level, and each repository will map packages to lists of version\n    numbers. For example:\n\n    .. code-block:: python\n\n        # With byrepo=False (default)\n        {\n            'bash': ['4.1.2-15.el6_5.2',\n                     '4.1.2-15.el6_5.1',\n                     '4.1.2-15.el6_4'],\n            'kernel': ['2.6.32-431.29.2.el6',\n                       '2.6.32-431.23.3.el6',\n                       '2.6.32-431.20.5.el6',\n                       '2.6.32-431.20.3.el6',\n                       '2.6.32-431.17.1.el6',\n                       '2.6.32-431.11.2.el6',\n                       '2.6.32-431.5.1.el6',\n                       '2.6.32-431.3.1.el6',\n                       '2.6.32-431.1.2.0.1.el6',\n                       '2.6.32-431.el6']\n        }\n        # With byrepo=True\n        {\n            'base': {\n                'bash': ['4.1.2-15.el6_4'],\n                'kernel': ['2.6.32-431.el6']\n            },\n            'updates': {\n                'bash': ['4.1.2-15.el6_5.2', '4.1.2-15.el6_5.1'],\n                'kernel': ['2.6.32-431.29.2.el6',\n                           '2.6.32-431.23.3.el6',\n                           '2.6.32-431.20.5.el6',\n                           '2.6.32-431.20.3.el6',\n                           '2.6.32-431.17.1.el6',\n                           '2.6.32-431.11.2.el6',\n                           '2.6.32-431.5.1.el6',\n                           '2.6.32-431.3.1.el6',\n                           '2.6.32-431.1.2.0.1.el6']\n            }\n        }\n\n    fromrepo : None\n        Only include results from the specified repo(s). Multiple repos can be\n        specified, comma-separated.\n\n    enablerepo (ignored if ``fromrepo`` is specified)\n        Specify a disabled package repository (or repositories) to enable.\n        (e.g., ``yum --enablerepo='somerepo'``)\n\n        .. versionadded:: 2017.7.0\n\n    disablerepo (ignored if ``fromrepo`` is specified)\n        Specify an enabled package repository (or repositories) to disable.\n        (e.g., ``yum --disablerepo='somerepo'``)\n\n        .. versionadded:: 2017.7.0\n\n    byrepo : False\n        When ``True``, the return data for each package will be organized by\n        repository.\n\n        .. versionadded:: 2017.7.0\n\n    cacheonly : False\n        When ``True``, the repo information will be retrieved from the cached\n        repo metadata. This is equivalent to passing the ``-C`` option to\n        yum/dnf.\n\n        .. versionadded:: 2017.7.0\n\n    setopt\n        A comma-separated or Python list of key=value options. This list will\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\n        that is run.\n\n        .. versionadded:: 2019.2.0\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' pkg.list_repo_pkgs\n        salt '*' pkg.list_repo_pkgs foo bar baz\n        salt '*' pkg.list_repo_pkgs 'samba4*' fromrepo=base,updates\n        salt '*' pkg.list_repo_pkgs 'python2-*' byrepo=True\n    \"\"\"\n    byrepo = kwargs.pop('byrepo', False)\n    cacheonly = kwargs.pop('cacheonly', False)\n    fromrepo = kwargs.pop('fromrepo', '') or ''\n    disablerepo = kwargs.pop('disablerepo', '') or ''\n    enablerepo = kwargs.pop('enablerepo', '') or ''\n    repo_arg = _get_options(fromrepo=fromrepo, **kwargs)\n    if fromrepo and (not isinstance(fromrepo, list)):\n        try:\n            fromrepo = [x.strip() for x in fromrepo.split(',')]\n        except AttributeError:\n            fromrepo = [x.strip() for x in str(fromrepo).split(',')]\n    if disablerepo and (not isinstance(disablerepo, list)):\n        try:\n            disablerepo = [x.strip() for x in disablerepo.split(',') if x != '*']\n        except AttributeError:\n            disablerepo = [x.strip() for x in str(disablerepo).split(',') if x != '*']\n    if enablerepo and (not isinstance(enablerepo, list)):\n        try:\n            enablerepo = [x.strip() for x in enablerepo.split(',') if x != '*']\n        except AttributeError:\n            enablerepo = [x.strip() for x in str(enablerepo).split(',') if x != '*']\n    if fromrepo:\n        repos = fromrepo\n    else:\n        repos = [repo_name for (repo_name, repo_info) in list_repos(**kwargs).items() if repo_name in enablerepo or (repo_name not in disablerepo and str(repo_info.get('enabled', '1')) == '1')]\n    ret = {}\n\n    def _check_args(args, name):\n        \"\"\"\n        Do glob matching on args and return True if a match was found.\n        Otherwise, return False\n        \"\"\"\n        for arg in args:\n            if fnmatch.fnmatch(name, arg):\n                return True\n        return False\n\n    def _parse_output(output, strict=False):\n        for pkg in _yum_pkginfo(output):\n            if strict and (pkg.repoid not in repos or not _check_args(args, pkg.name)):\n                continue\n            repo_dict = ret.setdefault(pkg.repoid, {})\n            version_list = repo_dict.setdefault(pkg.name, set())\n            version_list.add(pkg.version)\n    yum_version = None if _yum() != 'yum' else LooseVersion(__salt__['cmd.run'](['yum', '--version'], python_shell=False).splitlines()[0].strip())\n    if yum_version and yum_version < LooseVersion('3.2.13'):\n        cmd_prefix = ['--quiet']\n        if cacheonly:\n            cmd_prefix.append('-C')\n        cmd_prefix.append('list')\n        for pkg_src in ('installed', 'available'):\n            out = _call_yum(cmd_prefix + [pkg_src], ignore_retcode=True)\n            if out['retcode'] == 0:\n                _parse_output(out['stdout'], strict=True)\n    elif yum_version and yum_version < LooseVersion('3.4.3'):\n        cmd_prefix = ['--quiet', '--showduplicates']\n        if cacheonly:\n            cmd_prefix.append('-C')\n        cmd_prefix.append('list')\n        for pkg_src in ('installed', 'available'):\n            out = _call_yum(cmd_prefix + [pkg_src], ignore_retcode=True)\n            if out['retcode'] == 0:\n                _parse_output(out['stdout'], strict=True)\n    else:\n        for repo in repos:\n            if _yum() == 'tdnf':\n                cmd = ['--quiet', f'--enablerepo={repo}', 'list']\n            else:\n                cmd = ['--quiet', '--showduplicates', 'repository-packages', repo, 'list']\n            if cacheonly:\n                cmd.append('-C')\n            cmd.extend(args)\n            out = _call_yum(cmd, ignore_retcode=True)\n            if out['retcode'] != 0 and 'Error:' in out['stdout']:\n                continue\n            _parse_output(out['stdout'])\n    if byrepo:\n        for reponame in ret:\n            for pkgname in ret[reponame]:\n                sorted_versions = sorted((LooseVersion(x) for x in ret[reponame][pkgname]), reverse=True)\n                ret[reponame][pkgname] = [x.vstring for x in sorted_versions]\n        return ret\n    else:\n        byrepo_ret = {}\n        for reponame in ret:\n            for pkgname in ret[reponame]:\n                byrepo_ret.setdefault(pkgname, []).extend(ret[reponame][pkgname])\n        for pkgname in byrepo_ret:\n            sorted_versions = sorted((LooseVersion(x) for x in byrepo_ret[pkgname]), reverse=True)\n            byrepo_ret[pkgname] = [x.vstring for x in sorted_versions]\n        return byrepo_ret",
        "mutated": [
            "def list_repo_pkgs(*args, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2014.1.0\\n    .. versionchanged:: 2014.7.0\\n        All available versions of each package are now returned. This required\\n        a slight modification to the structure of the return dict. The return\\n        data shown below reflects the updated return dict structure. Note that\\n        packages which are version-locked using :py:mod:`pkg.hold\\n        <salt.modules.yumpkg.hold>` will only show the currently-installed\\n        version, as locking a package will make other versions appear\\n        unavailable to yum/dnf.\\n    .. versionchanged:: 2017.7.0\\n        By default, the versions for each package are no longer organized by\\n        repository. To get results organized by repository, use\\n        ``byrepo=True``.\\n\\n    Returns all available packages. Optionally, package names (and name globs)\\n    can be passed and the results will be filtered to packages matching those\\n    names. This is recommended as it speeds up the function considerably.\\n\\n    .. warning::\\n        Running this function on RHEL/CentOS 6 and earlier will be more\\n        resource-intensive, as the version of yum that ships with older\\n        RHEL/CentOS has no yum subcommand for listing packages from a\\n        repository. Thus, a ``yum list installed`` and ``yum list available``\\n        are run, which generates a lot of output, which must then be analyzed\\n        to determine which package information to include in the return data.\\n\\n    This function can be helpful in discovering the version or repo to specify\\n    in a :mod:`pkg.installed <salt.states.pkg.installed>` state.\\n\\n    The return data will be a dictionary mapping package names to a list of\\n    version numbers, ordered from newest to oldest. If ``byrepo`` is set to\\n    ``True``, then the return dictionary will contain repository names at the\\n    top level, and each repository will map packages to lists of version\\n    numbers. For example:\\n\\n    .. code-block:: python\\n\\n        # With byrepo=False (default)\\n        {\\n            'bash': ['4.1.2-15.el6_5.2',\\n                     '4.1.2-15.el6_5.1',\\n                     '4.1.2-15.el6_4'],\\n            'kernel': ['2.6.32-431.29.2.el6',\\n                       '2.6.32-431.23.3.el6',\\n                       '2.6.32-431.20.5.el6',\\n                       '2.6.32-431.20.3.el6',\\n                       '2.6.32-431.17.1.el6',\\n                       '2.6.32-431.11.2.el6',\\n                       '2.6.32-431.5.1.el6',\\n                       '2.6.32-431.3.1.el6',\\n                       '2.6.32-431.1.2.0.1.el6',\\n                       '2.6.32-431.el6']\\n        }\\n        # With byrepo=True\\n        {\\n            'base': {\\n                'bash': ['4.1.2-15.el6_4'],\\n                'kernel': ['2.6.32-431.el6']\\n            },\\n            'updates': {\\n                'bash': ['4.1.2-15.el6_5.2', '4.1.2-15.el6_5.1'],\\n                'kernel': ['2.6.32-431.29.2.el6',\\n                           '2.6.32-431.23.3.el6',\\n                           '2.6.32-431.20.5.el6',\\n                           '2.6.32-431.20.3.el6',\\n                           '2.6.32-431.17.1.el6',\\n                           '2.6.32-431.11.2.el6',\\n                           '2.6.32-431.5.1.el6',\\n                           '2.6.32-431.3.1.el6',\\n                           '2.6.32-431.1.2.0.1.el6']\\n            }\\n        }\\n\\n    fromrepo : None\\n        Only include results from the specified repo(s). Multiple repos can be\\n        specified, comma-separated.\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 2017.7.0\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo='somerepo'``)\\n\\n        .. versionadded:: 2017.7.0\\n\\n    byrepo : False\\n        When ``True``, the return data for each package will be organized by\\n        repository.\\n\\n        .. versionadded:: 2017.7.0\\n\\n    cacheonly : False\\n        When ``True``, the repo information will be retrieved from the cached\\n        repo metadata. This is equivalent to passing the ``-C`` option to\\n        yum/dnf.\\n\\n        .. versionadded:: 2017.7.0\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_repo_pkgs\\n        salt '*' pkg.list_repo_pkgs foo bar baz\\n        salt '*' pkg.list_repo_pkgs 'samba4*' fromrepo=base,updates\\n        salt '*' pkg.list_repo_pkgs 'python2-*' byrepo=True\\n    \"\n    byrepo = kwargs.pop('byrepo', False)\n    cacheonly = kwargs.pop('cacheonly', False)\n    fromrepo = kwargs.pop('fromrepo', '') or ''\n    disablerepo = kwargs.pop('disablerepo', '') or ''\n    enablerepo = kwargs.pop('enablerepo', '') or ''\n    repo_arg = _get_options(fromrepo=fromrepo, **kwargs)\n    if fromrepo and (not isinstance(fromrepo, list)):\n        try:\n            fromrepo = [x.strip() for x in fromrepo.split(',')]\n        except AttributeError:\n            fromrepo = [x.strip() for x in str(fromrepo).split(',')]\n    if disablerepo and (not isinstance(disablerepo, list)):\n        try:\n            disablerepo = [x.strip() for x in disablerepo.split(',') if x != '*']\n        except AttributeError:\n            disablerepo = [x.strip() for x in str(disablerepo).split(',') if x != '*']\n    if enablerepo and (not isinstance(enablerepo, list)):\n        try:\n            enablerepo = [x.strip() for x in enablerepo.split(',') if x != '*']\n        except AttributeError:\n            enablerepo = [x.strip() for x in str(enablerepo).split(',') if x != '*']\n    if fromrepo:\n        repos = fromrepo\n    else:\n        repos = [repo_name for (repo_name, repo_info) in list_repos(**kwargs).items() if repo_name in enablerepo or (repo_name not in disablerepo and str(repo_info.get('enabled', '1')) == '1')]\n    ret = {}\n\n    def _check_args(args, name):\n        \"\"\"\n        Do glob matching on args and return True if a match was found.\n        Otherwise, return False\n        \"\"\"\n        for arg in args:\n            if fnmatch.fnmatch(name, arg):\n                return True\n        return False\n\n    def _parse_output(output, strict=False):\n        for pkg in _yum_pkginfo(output):\n            if strict and (pkg.repoid not in repos or not _check_args(args, pkg.name)):\n                continue\n            repo_dict = ret.setdefault(pkg.repoid, {})\n            version_list = repo_dict.setdefault(pkg.name, set())\n            version_list.add(pkg.version)\n    yum_version = None if _yum() != 'yum' else LooseVersion(__salt__['cmd.run'](['yum', '--version'], python_shell=False).splitlines()[0].strip())\n    if yum_version and yum_version < LooseVersion('3.2.13'):\n        cmd_prefix = ['--quiet']\n        if cacheonly:\n            cmd_prefix.append('-C')\n        cmd_prefix.append('list')\n        for pkg_src in ('installed', 'available'):\n            out = _call_yum(cmd_prefix + [pkg_src], ignore_retcode=True)\n            if out['retcode'] == 0:\n                _parse_output(out['stdout'], strict=True)\n    elif yum_version and yum_version < LooseVersion('3.4.3'):\n        cmd_prefix = ['--quiet', '--showduplicates']\n        if cacheonly:\n            cmd_prefix.append('-C')\n        cmd_prefix.append('list')\n        for pkg_src in ('installed', 'available'):\n            out = _call_yum(cmd_prefix + [pkg_src], ignore_retcode=True)\n            if out['retcode'] == 0:\n                _parse_output(out['stdout'], strict=True)\n    else:\n        for repo in repos:\n            if _yum() == 'tdnf':\n                cmd = ['--quiet', f'--enablerepo={repo}', 'list']\n            else:\n                cmd = ['--quiet', '--showduplicates', 'repository-packages', repo, 'list']\n            if cacheonly:\n                cmd.append('-C')\n            cmd.extend(args)\n            out = _call_yum(cmd, ignore_retcode=True)\n            if out['retcode'] != 0 and 'Error:' in out['stdout']:\n                continue\n            _parse_output(out['stdout'])\n    if byrepo:\n        for reponame in ret:\n            for pkgname in ret[reponame]:\n                sorted_versions = sorted((LooseVersion(x) for x in ret[reponame][pkgname]), reverse=True)\n                ret[reponame][pkgname] = [x.vstring for x in sorted_versions]\n        return ret\n    else:\n        byrepo_ret = {}\n        for reponame in ret:\n            for pkgname in ret[reponame]:\n                byrepo_ret.setdefault(pkgname, []).extend(ret[reponame][pkgname])\n        for pkgname in byrepo_ret:\n            sorted_versions = sorted((LooseVersion(x) for x in byrepo_ret[pkgname]), reverse=True)\n            byrepo_ret[pkgname] = [x.vstring for x in sorted_versions]\n        return byrepo_ret",
            "def list_repo_pkgs(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2014.1.0\\n    .. versionchanged:: 2014.7.0\\n        All available versions of each package are now returned. This required\\n        a slight modification to the structure of the return dict. The return\\n        data shown below reflects the updated return dict structure. Note that\\n        packages which are version-locked using :py:mod:`pkg.hold\\n        <salt.modules.yumpkg.hold>` will only show the currently-installed\\n        version, as locking a package will make other versions appear\\n        unavailable to yum/dnf.\\n    .. versionchanged:: 2017.7.0\\n        By default, the versions for each package are no longer organized by\\n        repository. To get results organized by repository, use\\n        ``byrepo=True``.\\n\\n    Returns all available packages. Optionally, package names (and name globs)\\n    can be passed and the results will be filtered to packages matching those\\n    names. This is recommended as it speeds up the function considerably.\\n\\n    .. warning::\\n        Running this function on RHEL/CentOS 6 and earlier will be more\\n        resource-intensive, as the version of yum that ships with older\\n        RHEL/CentOS has no yum subcommand for listing packages from a\\n        repository. Thus, a ``yum list installed`` and ``yum list available``\\n        are run, which generates a lot of output, which must then be analyzed\\n        to determine which package information to include in the return data.\\n\\n    This function can be helpful in discovering the version or repo to specify\\n    in a :mod:`pkg.installed <salt.states.pkg.installed>` state.\\n\\n    The return data will be a dictionary mapping package names to a list of\\n    version numbers, ordered from newest to oldest. If ``byrepo`` is set to\\n    ``True``, then the return dictionary will contain repository names at the\\n    top level, and each repository will map packages to lists of version\\n    numbers. For example:\\n\\n    .. code-block:: python\\n\\n        # With byrepo=False (default)\\n        {\\n            'bash': ['4.1.2-15.el6_5.2',\\n                     '4.1.2-15.el6_5.1',\\n                     '4.1.2-15.el6_4'],\\n            'kernel': ['2.6.32-431.29.2.el6',\\n                       '2.6.32-431.23.3.el6',\\n                       '2.6.32-431.20.5.el6',\\n                       '2.6.32-431.20.3.el6',\\n                       '2.6.32-431.17.1.el6',\\n                       '2.6.32-431.11.2.el6',\\n                       '2.6.32-431.5.1.el6',\\n                       '2.6.32-431.3.1.el6',\\n                       '2.6.32-431.1.2.0.1.el6',\\n                       '2.6.32-431.el6']\\n        }\\n        # With byrepo=True\\n        {\\n            'base': {\\n                'bash': ['4.1.2-15.el6_4'],\\n                'kernel': ['2.6.32-431.el6']\\n            },\\n            'updates': {\\n                'bash': ['4.1.2-15.el6_5.2', '4.1.2-15.el6_5.1'],\\n                'kernel': ['2.6.32-431.29.2.el6',\\n                           '2.6.32-431.23.3.el6',\\n                           '2.6.32-431.20.5.el6',\\n                           '2.6.32-431.20.3.el6',\\n                           '2.6.32-431.17.1.el6',\\n                           '2.6.32-431.11.2.el6',\\n                           '2.6.32-431.5.1.el6',\\n                           '2.6.32-431.3.1.el6',\\n                           '2.6.32-431.1.2.0.1.el6']\\n            }\\n        }\\n\\n    fromrepo : None\\n        Only include results from the specified repo(s). Multiple repos can be\\n        specified, comma-separated.\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 2017.7.0\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo='somerepo'``)\\n\\n        .. versionadded:: 2017.7.0\\n\\n    byrepo : False\\n        When ``True``, the return data for each package will be organized by\\n        repository.\\n\\n        .. versionadded:: 2017.7.0\\n\\n    cacheonly : False\\n        When ``True``, the repo information will be retrieved from the cached\\n        repo metadata. This is equivalent to passing the ``-C`` option to\\n        yum/dnf.\\n\\n        .. versionadded:: 2017.7.0\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_repo_pkgs\\n        salt '*' pkg.list_repo_pkgs foo bar baz\\n        salt '*' pkg.list_repo_pkgs 'samba4*' fromrepo=base,updates\\n        salt '*' pkg.list_repo_pkgs 'python2-*' byrepo=True\\n    \"\n    byrepo = kwargs.pop('byrepo', False)\n    cacheonly = kwargs.pop('cacheonly', False)\n    fromrepo = kwargs.pop('fromrepo', '') or ''\n    disablerepo = kwargs.pop('disablerepo', '') or ''\n    enablerepo = kwargs.pop('enablerepo', '') or ''\n    repo_arg = _get_options(fromrepo=fromrepo, **kwargs)\n    if fromrepo and (not isinstance(fromrepo, list)):\n        try:\n            fromrepo = [x.strip() for x in fromrepo.split(',')]\n        except AttributeError:\n            fromrepo = [x.strip() for x in str(fromrepo).split(',')]\n    if disablerepo and (not isinstance(disablerepo, list)):\n        try:\n            disablerepo = [x.strip() for x in disablerepo.split(',') if x != '*']\n        except AttributeError:\n            disablerepo = [x.strip() for x in str(disablerepo).split(',') if x != '*']\n    if enablerepo and (not isinstance(enablerepo, list)):\n        try:\n            enablerepo = [x.strip() for x in enablerepo.split(',') if x != '*']\n        except AttributeError:\n            enablerepo = [x.strip() for x in str(enablerepo).split(',') if x != '*']\n    if fromrepo:\n        repos = fromrepo\n    else:\n        repos = [repo_name for (repo_name, repo_info) in list_repos(**kwargs).items() if repo_name in enablerepo or (repo_name not in disablerepo and str(repo_info.get('enabled', '1')) == '1')]\n    ret = {}\n\n    def _check_args(args, name):\n        \"\"\"\n        Do glob matching on args and return True if a match was found.\n        Otherwise, return False\n        \"\"\"\n        for arg in args:\n            if fnmatch.fnmatch(name, arg):\n                return True\n        return False\n\n    def _parse_output(output, strict=False):\n        for pkg in _yum_pkginfo(output):\n            if strict and (pkg.repoid not in repos or not _check_args(args, pkg.name)):\n                continue\n            repo_dict = ret.setdefault(pkg.repoid, {})\n            version_list = repo_dict.setdefault(pkg.name, set())\n            version_list.add(pkg.version)\n    yum_version = None if _yum() != 'yum' else LooseVersion(__salt__['cmd.run'](['yum', '--version'], python_shell=False).splitlines()[0].strip())\n    if yum_version and yum_version < LooseVersion('3.2.13'):\n        cmd_prefix = ['--quiet']\n        if cacheonly:\n            cmd_prefix.append('-C')\n        cmd_prefix.append('list')\n        for pkg_src in ('installed', 'available'):\n            out = _call_yum(cmd_prefix + [pkg_src], ignore_retcode=True)\n            if out['retcode'] == 0:\n                _parse_output(out['stdout'], strict=True)\n    elif yum_version and yum_version < LooseVersion('3.4.3'):\n        cmd_prefix = ['--quiet', '--showduplicates']\n        if cacheonly:\n            cmd_prefix.append('-C')\n        cmd_prefix.append('list')\n        for pkg_src in ('installed', 'available'):\n            out = _call_yum(cmd_prefix + [pkg_src], ignore_retcode=True)\n            if out['retcode'] == 0:\n                _parse_output(out['stdout'], strict=True)\n    else:\n        for repo in repos:\n            if _yum() == 'tdnf':\n                cmd = ['--quiet', f'--enablerepo={repo}', 'list']\n            else:\n                cmd = ['--quiet', '--showduplicates', 'repository-packages', repo, 'list']\n            if cacheonly:\n                cmd.append('-C')\n            cmd.extend(args)\n            out = _call_yum(cmd, ignore_retcode=True)\n            if out['retcode'] != 0 and 'Error:' in out['stdout']:\n                continue\n            _parse_output(out['stdout'])\n    if byrepo:\n        for reponame in ret:\n            for pkgname in ret[reponame]:\n                sorted_versions = sorted((LooseVersion(x) for x in ret[reponame][pkgname]), reverse=True)\n                ret[reponame][pkgname] = [x.vstring for x in sorted_versions]\n        return ret\n    else:\n        byrepo_ret = {}\n        for reponame in ret:\n            for pkgname in ret[reponame]:\n                byrepo_ret.setdefault(pkgname, []).extend(ret[reponame][pkgname])\n        for pkgname in byrepo_ret:\n            sorted_versions = sorted((LooseVersion(x) for x in byrepo_ret[pkgname]), reverse=True)\n            byrepo_ret[pkgname] = [x.vstring for x in sorted_versions]\n        return byrepo_ret",
            "def list_repo_pkgs(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2014.1.0\\n    .. versionchanged:: 2014.7.0\\n        All available versions of each package are now returned. This required\\n        a slight modification to the structure of the return dict. The return\\n        data shown below reflects the updated return dict structure. Note that\\n        packages which are version-locked using :py:mod:`pkg.hold\\n        <salt.modules.yumpkg.hold>` will only show the currently-installed\\n        version, as locking a package will make other versions appear\\n        unavailable to yum/dnf.\\n    .. versionchanged:: 2017.7.0\\n        By default, the versions for each package are no longer organized by\\n        repository. To get results organized by repository, use\\n        ``byrepo=True``.\\n\\n    Returns all available packages. Optionally, package names (and name globs)\\n    can be passed and the results will be filtered to packages matching those\\n    names. This is recommended as it speeds up the function considerably.\\n\\n    .. warning::\\n        Running this function on RHEL/CentOS 6 and earlier will be more\\n        resource-intensive, as the version of yum that ships with older\\n        RHEL/CentOS has no yum subcommand for listing packages from a\\n        repository. Thus, a ``yum list installed`` and ``yum list available``\\n        are run, which generates a lot of output, which must then be analyzed\\n        to determine which package information to include in the return data.\\n\\n    This function can be helpful in discovering the version or repo to specify\\n    in a :mod:`pkg.installed <salt.states.pkg.installed>` state.\\n\\n    The return data will be a dictionary mapping package names to a list of\\n    version numbers, ordered from newest to oldest. If ``byrepo`` is set to\\n    ``True``, then the return dictionary will contain repository names at the\\n    top level, and each repository will map packages to lists of version\\n    numbers. For example:\\n\\n    .. code-block:: python\\n\\n        # With byrepo=False (default)\\n        {\\n            'bash': ['4.1.2-15.el6_5.2',\\n                     '4.1.2-15.el6_5.1',\\n                     '4.1.2-15.el6_4'],\\n            'kernel': ['2.6.32-431.29.2.el6',\\n                       '2.6.32-431.23.3.el6',\\n                       '2.6.32-431.20.5.el6',\\n                       '2.6.32-431.20.3.el6',\\n                       '2.6.32-431.17.1.el6',\\n                       '2.6.32-431.11.2.el6',\\n                       '2.6.32-431.5.1.el6',\\n                       '2.6.32-431.3.1.el6',\\n                       '2.6.32-431.1.2.0.1.el6',\\n                       '2.6.32-431.el6']\\n        }\\n        # With byrepo=True\\n        {\\n            'base': {\\n                'bash': ['4.1.2-15.el6_4'],\\n                'kernel': ['2.6.32-431.el6']\\n            },\\n            'updates': {\\n                'bash': ['4.1.2-15.el6_5.2', '4.1.2-15.el6_5.1'],\\n                'kernel': ['2.6.32-431.29.2.el6',\\n                           '2.6.32-431.23.3.el6',\\n                           '2.6.32-431.20.5.el6',\\n                           '2.6.32-431.20.3.el6',\\n                           '2.6.32-431.17.1.el6',\\n                           '2.6.32-431.11.2.el6',\\n                           '2.6.32-431.5.1.el6',\\n                           '2.6.32-431.3.1.el6',\\n                           '2.6.32-431.1.2.0.1.el6']\\n            }\\n        }\\n\\n    fromrepo : None\\n        Only include results from the specified repo(s). Multiple repos can be\\n        specified, comma-separated.\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 2017.7.0\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo='somerepo'``)\\n\\n        .. versionadded:: 2017.7.0\\n\\n    byrepo : False\\n        When ``True``, the return data for each package will be organized by\\n        repository.\\n\\n        .. versionadded:: 2017.7.0\\n\\n    cacheonly : False\\n        When ``True``, the repo information will be retrieved from the cached\\n        repo metadata. This is equivalent to passing the ``-C`` option to\\n        yum/dnf.\\n\\n        .. versionadded:: 2017.7.0\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_repo_pkgs\\n        salt '*' pkg.list_repo_pkgs foo bar baz\\n        salt '*' pkg.list_repo_pkgs 'samba4*' fromrepo=base,updates\\n        salt '*' pkg.list_repo_pkgs 'python2-*' byrepo=True\\n    \"\n    byrepo = kwargs.pop('byrepo', False)\n    cacheonly = kwargs.pop('cacheonly', False)\n    fromrepo = kwargs.pop('fromrepo', '') or ''\n    disablerepo = kwargs.pop('disablerepo', '') or ''\n    enablerepo = kwargs.pop('enablerepo', '') or ''\n    repo_arg = _get_options(fromrepo=fromrepo, **kwargs)\n    if fromrepo and (not isinstance(fromrepo, list)):\n        try:\n            fromrepo = [x.strip() for x in fromrepo.split(',')]\n        except AttributeError:\n            fromrepo = [x.strip() for x in str(fromrepo).split(',')]\n    if disablerepo and (not isinstance(disablerepo, list)):\n        try:\n            disablerepo = [x.strip() for x in disablerepo.split(',') if x != '*']\n        except AttributeError:\n            disablerepo = [x.strip() for x in str(disablerepo).split(',') if x != '*']\n    if enablerepo and (not isinstance(enablerepo, list)):\n        try:\n            enablerepo = [x.strip() for x in enablerepo.split(',') if x != '*']\n        except AttributeError:\n            enablerepo = [x.strip() for x in str(enablerepo).split(',') if x != '*']\n    if fromrepo:\n        repos = fromrepo\n    else:\n        repos = [repo_name for (repo_name, repo_info) in list_repos(**kwargs).items() if repo_name in enablerepo or (repo_name not in disablerepo and str(repo_info.get('enabled', '1')) == '1')]\n    ret = {}\n\n    def _check_args(args, name):\n        \"\"\"\n        Do glob matching on args and return True if a match was found.\n        Otherwise, return False\n        \"\"\"\n        for arg in args:\n            if fnmatch.fnmatch(name, arg):\n                return True\n        return False\n\n    def _parse_output(output, strict=False):\n        for pkg in _yum_pkginfo(output):\n            if strict and (pkg.repoid not in repos or not _check_args(args, pkg.name)):\n                continue\n            repo_dict = ret.setdefault(pkg.repoid, {})\n            version_list = repo_dict.setdefault(pkg.name, set())\n            version_list.add(pkg.version)\n    yum_version = None if _yum() != 'yum' else LooseVersion(__salt__['cmd.run'](['yum', '--version'], python_shell=False).splitlines()[0].strip())\n    if yum_version and yum_version < LooseVersion('3.2.13'):\n        cmd_prefix = ['--quiet']\n        if cacheonly:\n            cmd_prefix.append('-C')\n        cmd_prefix.append('list')\n        for pkg_src in ('installed', 'available'):\n            out = _call_yum(cmd_prefix + [pkg_src], ignore_retcode=True)\n            if out['retcode'] == 0:\n                _parse_output(out['stdout'], strict=True)\n    elif yum_version and yum_version < LooseVersion('3.4.3'):\n        cmd_prefix = ['--quiet', '--showduplicates']\n        if cacheonly:\n            cmd_prefix.append('-C')\n        cmd_prefix.append('list')\n        for pkg_src in ('installed', 'available'):\n            out = _call_yum(cmd_prefix + [pkg_src], ignore_retcode=True)\n            if out['retcode'] == 0:\n                _parse_output(out['stdout'], strict=True)\n    else:\n        for repo in repos:\n            if _yum() == 'tdnf':\n                cmd = ['--quiet', f'--enablerepo={repo}', 'list']\n            else:\n                cmd = ['--quiet', '--showduplicates', 'repository-packages', repo, 'list']\n            if cacheonly:\n                cmd.append('-C')\n            cmd.extend(args)\n            out = _call_yum(cmd, ignore_retcode=True)\n            if out['retcode'] != 0 and 'Error:' in out['stdout']:\n                continue\n            _parse_output(out['stdout'])\n    if byrepo:\n        for reponame in ret:\n            for pkgname in ret[reponame]:\n                sorted_versions = sorted((LooseVersion(x) for x in ret[reponame][pkgname]), reverse=True)\n                ret[reponame][pkgname] = [x.vstring for x in sorted_versions]\n        return ret\n    else:\n        byrepo_ret = {}\n        for reponame in ret:\n            for pkgname in ret[reponame]:\n                byrepo_ret.setdefault(pkgname, []).extend(ret[reponame][pkgname])\n        for pkgname in byrepo_ret:\n            sorted_versions = sorted((LooseVersion(x) for x in byrepo_ret[pkgname]), reverse=True)\n            byrepo_ret[pkgname] = [x.vstring for x in sorted_versions]\n        return byrepo_ret",
            "def list_repo_pkgs(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2014.1.0\\n    .. versionchanged:: 2014.7.0\\n        All available versions of each package are now returned. This required\\n        a slight modification to the structure of the return dict. The return\\n        data shown below reflects the updated return dict structure. Note that\\n        packages which are version-locked using :py:mod:`pkg.hold\\n        <salt.modules.yumpkg.hold>` will only show the currently-installed\\n        version, as locking a package will make other versions appear\\n        unavailable to yum/dnf.\\n    .. versionchanged:: 2017.7.0\\n        By default, the versions for each package are no longer organized by\\n        repository. To get results organized by repository, use\\n        ``byrepo=True``.\\n\\n    Returns all available packages. Optionally, package names (and name globs)\\n    can be passed and the results will be filtered to packages matching those\\n    names. This is recommended as it speeds up the function considerably.\\n\\n    .. warning::\\n        Running this function on RHEL/CentOS 6 and earlier will be more\\n        resource-intensive, as the version of yum that ships with older\\n        RHEL/CentOS has no yum subcommand for listing packages from a\\n        repository. Thus, a ``yum list installed`` and ``yum list available``\\n        are run, which generates a lot of output, which must then be analyzed\\n        to determine which package information to include in the return data.\\n\\n    This function can be helpful in discovering the version or repo to specify\\n    in a :mod:`pkg.installed <salt.states.pkg.installed>` state.\\n\\n    The return data will be a dictionary mapping package names to a list of\\n    version numbers, ordered from newest to oldest. If ``byrepo`` is set to\\n    ``True``, then the return dictionary will contain repository names at the\\n    top level, and each repository will map packages to lists of version\\n    numbers. For example:\\n\\n    .. code-block:: python\\n\\n        # With byrepo=False (default)\\n        {\\n            'bash': ['4.1.2-15.el6_5.2',\\n                     '4.1.2-15.el6_5.1',\\n                     '4.1.2-15.el6_4'],\\n            'kernel': ['2.6.32-431.29.2.el6',\\n                       '2.6.32-431.23.3.el6',\\n                       '2.6.32-431.20.5.el6',\\n                       '2.6.32-431.20.3.el6',\\n                       '2.6.32-431.17.1.el6',\\n                       '2.6.32-431.11.2.el6',\\n                       '2.6.32-431.5.1.el6',\\n                       '2.6.32-431.3.1.el6',\\n                       '2.6.32-431.1.2.0.1.el6',\\n                       '2.6.32-431.el6']\\n        }\\n        # With byrepo=True\\n        {\\n            'base': {\\n                'bash': ['4.1.2-15.el6_4'],\\n                'kernel': ['2.6.32-431.el6']\\n            },\\n            'updates': {\\n                'bash': ['4.1.2-15.el6_5.2', '4.1.2-15.el6_5.1'],\\n                'kernel': ['2.6.32-431.29.2.el6',\\n                           '2.6.32-431.23.3.el6',\\n                           '2.6.32-431.20.5.el6',\\n                           '2.6.32-431.20.3.el6',\\n                           '2.6.32-431.17.1.el6',\\n                           '2.6.32-431.11.2.el6',\\n                           '2.6.32-431.5.1.el6',\\n                           '2.6.32-431.3.1.el6',\\n                           '2.6.32-431.1.2.0.1.el6']\\n            }\\n        }\\n\\n    fromrepo : None\\n        Only include results from the specified repo(s). Multiple repos can be\\n        specified, comma-separated.\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 2017.7.0\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo='somerepo'``)\\n\\n        .. versionadded:: 2017.7.0\\n\\n    byrepo : False\\n        When ``True``, the return data for each package will be organized by\\n        repository.\\n\\n        .. versionadded:: 2017.7.0\\n\\n    cacheonly : False\\n        When ``True``, the repo information will be retrieved from the cached\\n        repo metadata. This is equivalent to passing the ``-C`` option to\\n        yum/dnf.\\n\\n        .. versionadded:: 2017.7.0\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_repo_pkgs\\n        salt '*' pkg.list_repo_pkgs foo bar baz\\n        salt '*' pkg.list_repo_pkgs 'samba4*' fromrepo=base,updates\\n        salt '*' pkg.list_repo_pkgs 'python2-*' byrepo=True\\n    \"\n    byrepo = kwargs.pop('byrepo', False)\n    cacheonly = kwargs.pop('cacheonly', False)\n    fromrepo = kwargs.pop('fromrepo', '') or ''\n    disablerepo = kwargs.pop('disablerepo', '') or ''\n    enablerepo = kwargs.pop('enablerepo', '') or ''\n    repo_arg = _get_options(fromrepo=fromrepo, **kwargs)\n    if fromrepo and (not isinstance(fromrepo, list)):\n        try:\n            fromrepo = [x.strip() for x in fromrepo.split(',')]\n        except AttributeError:\n            fromrepo = [x.strip() for x in str(fromrepo).split(',')]\n    if disablerepo and (not isinstance(disablerepo, list)):\n        try:\n            disablerepo = [x.strip() for x in disablerepo.split(',') if x != '*']\n        except AttributeError:\n            disablerepo = [x.strip() for x in str(disablerepo).split(',') if x != '*']\n    if enablerepo and (not isinstance(enablerepo, list)):\n        try:\n            enablerepo = [x.strip() for x in enablerepo.split(',') if x != '*']\n        except AttributeError:\n            enablerepo = [x.strip() for x in str(enablerepo).split(',') if x != '*']\n    if fromrepo:\n        repos = fromrepo\n    else:\n        repos = [repo_name for (repo_name, repo_info) in list_repos(**kwargs).items() if repo_name in enablerepo or (repo_name not in disablerepo and str(repo_info.get('enabled', '1')) == '1')]\n    ret = {}\n\n    def _check_args(args, name):\n        \"\"\"\n        Do glob matching on args and return True if a match was found.\n        Otherwise, return False\n        \"\"\"\n        for arg in args:\n            if fnmatch.fnmatch(name, arg):\n                return True\n        return False\n\n    def _parse_output(output, strict=False):\n        for pkg in _yum_pkginfo(output):\n            if strict and (pkg.repoid not in repos or not _check_args(args, pkg.name)):\n                continue\n            repo_dict = ret.setdefault(pkg.repoid, {})\n            version_list = repo_dict.setdefault(pkg.name, set())\n            version_list.add(pkg.version)\n    yum_version = None if _yum() != 'yum' else LooseVersion(__salt__['cmd.run'](['yum', '--version'], python_shell=False).splitlines()[0].strip())\n    if yum_version and yum_version < LooseVersion('3.2.13'):\n        cmd_prefix = ['--quiet']\n        if cacheonly:\n            cmd_prefix.append('-C')\n        cmd_prefix.append('list')\n        for pkg_src in ('installed', 'available'):\n            out = _call_yum(cmd_prefix + [pkg_src], ignore_retcode=True)\n            if out['retcode'] == 0:\n                _parse_output(out['stdout'], strict=True)\n    elif yum_version and yum_version < LooseVersion('3.4.3'):\n        cmd_prefix = ['--quiet', '--showduplicates']\n        if cacheonly:\n            cmd_prefix.append('-C')\n        cmd_prefix.append('list')\n        for pkg_src in ('installed', 'available'):\n            out = _call_yum(cmd_prefix + [pkg_src], ignore_retcode=True)\n            if out['retcode'] == 0:\n                _parse_output(out['stdout'], strict=True)\n    else:\n        for repo in repos:\n            if _yum() == 'tdnf':\n                cmd = ['--quiet', f'--enablerepo={repo}', 'list']\n            else:\n                cmd = ['--quiet', '--showduplicates', 'repository-packages', repo, 'list']\n            if cacheonly:\n                cmd.append('-C')\n            cmd.extend(args)\n            out = _call_yum(cmd, ignore_retcode=True)\n            if out['retcode'] != 0 and 'Error:' in out['stdout']:\n                continue\n            _parse_output(out['stdout'])\n    if byrepo:\n        for reponame in ret:\n            for pkgname in ret[reponame]:\n                sorted_versions = sorted((LooseVersion(x) for x in ret[reponame][pkgname]), reverse=True)\n                ret[reponame][pkgname] = [x.vstring for x in sorted_versions]\n        return ret\n    else:\n        byrepo_ret = {}\n        for reponame in ret:\n            for pkgname in ret[reponame]:\n                byrepo_ret.setdefault(pkgname, []).extend(ret[reponame][pkgname])\n        for pkgname in byrepo_ret:\n            sorted_versions = sorted((LooseVersion(x) for x in byrepo_ret[pkgname]), reverse=True)\n            byrepo_ret[pkgname] = [x.vstring for x in sorted_versions]\n        return byrepo_ret",
            "def list_repo_pkgs(*args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2014.1.0\\n    .. versionchanged:: 2014.7.0\\n        All available versions of each package are now returned. This required\\n        a slight modification to the structure of the return dict. The return\\n        data shown below reflects the updated return dict structure. Note that\\n        packages which are version-locked using :py:mod:`pkg.hold\\n        <salt.modules.yumpkg.hold>` will only show the currently-installed\\n        version, as locking a package will make other versions appear\\n        unavailable to yum/dnf.\\n    .. versionchanged:: 2017.7.0\\n        By default, the versions for each package are no longer organized by\\n        repository. To get results organized by repository, use\\n        ``byrepo=True``.\\n\\n    Returns all available packages. Optionally, package names (and name globs)\\n    can be passed and the results will be filtered to packages matching those\\n    names. This is recommended as it speeds up the function considerably.\\n\\n    .. warning::\\n        Running this function on RHEL/CentOS 6 and earlier will be more\\n        resource-intensive, as the version of yum that ships with older\\n        RHEL/CentOS has no yum subcommand for listing packages from a\\n        repository. Thus, a ``yum list installed`` and ``yum list available``\\n        are run, which generates a lot of output, which must then be analyzed\\n        to determine which package information to include in the return data.\\n\\n    This function can be helpful in discovering the version or repo to specify\\n    in a :mod:`pkg.installed <salt.states.pkg.installed>` state.\\n\\n    The return data will be a dictionary mapping package names to a list of\\n    version numbers, ordered from newest to oldest. If ``byrepo`` is set to\\n    ``True``, then the return dictionary will contain repository names at the\\n    top level, and each repository will map packages to lists of version\\n    numbers. For example:\\n\\n    .. code-block:: python\\n\\n        # With byrepo=False (default)\\n        {\\n            'bash': ['4.1.2-15.el6_5.2',\\n                     '4.1.2-15.el6_5.1',\\n                     '4.1.2-15.el6_4'],\\n            'kernel': ['2.6.32-431.29.2.el6',\\n                       '2.6.32-431.23.3.el6',\\n                       '2.6.32-431.20.5.el6',\\n                       '2.6.32-431.20.3.el6',\\n                       '2.6.32-431.17.1.el6',\\n                       '2.6.32-431.11.2.el6',\\n                       '2.6.32-431.5.1.el6',\\n                       '2.6.32-431.3.1.el6',\\n                       '2.6.32-431.1.2.0.1.el6',\\n                       '2.6.32-431.el6']\\n        }\\n        # With byrepo=True\\n        {\\n            'base': {\\n                'bash': ['4.1.2-15.el6_4'],\\n                'kernel': ['2.6.32-431.el6']\\n            },\\n            'updates': {\\n                'bash': ['4.1.2-15.el6_5.2', '4.1.2-15.el6_5.1'],\\n                'kernel': ['2.6.32-431.29.2.el6',\\n                           '2.6.32-431.23.3.el6',\\n                           '2.6.32-431.20.5.el6',\\n                           '2.6.32-431.20.3.el6',\\n                           '2.6.32-431.17.1.el6',\\n                           '2.6.32-431.11.2.el6',\\n                           '2.6.32-431.5.1.el6',\\n                           '2.6.32-431.3.1.el6',\\n                           '2.6.32-431.1.2.0.1.el6']\\n            }\\n        }\\n\\n    fromrepo : None\\n        Only include results from the specified repo(s). Multiple repos can be\\n        specified, comma-separated.\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 2017.7.0\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo='somerepo'``)\\n\\n        .. versionadded:: 2017.7.0\\n\\n    byrepo : False\\n        When ``True``, the return data for each package will be organized by\\n        repository.\\n\\n        .. versionadded:: 2017.7.0\\n\\n    cacheonly : False\\n        When ``True``, the repo information will be retrieved from the cached\\n        repo metadata. This is equivalent to passing the ``-C`` option to\\n        yum/dnf.\\n\\n        .. versionadded:: 2017.7.0\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_repo_pkgs\\n        salt '*' pkg.list_repo_pkgs foo bar baz\\n        salt '*' pkg.list_repo_pkgs 'samba4*' fromrepo=base,updates\\n        salt '*' pkg.list_repo_pkgs 'python2-*' byrepo=True\\n    \"\n    byrepo = kwargs.pop('byrepo', False)\n    cacheonly = kwargs.pop('cacheonly', False)\n    fromrepo = kwargs.pop('fromrepo', '') or ''\n    disablerepo = kwargs.pop('disablerepo', '') or ''\n    enablerepo = kwargs.pop('enablerepo', '') or ''\n    repo_arg = _get_options(fromrepo=fromrepo, **kwargs)\n    if fromrepo and (not isinstance(fromrepo, list)):\n        try:\n            fromrepo = [x.strip() for x in fromrepo.split(',')]\n        except AttributeError:\n            fromrepo = [x.strip() for x in str(fromrepo).split(',')]\n    if disablerepo and (not isinstance(disablerepo, list)):\n        try:\n            disablerepo = [x.strip() for x in disablerepo.split(',') if x != '*']\n        except AttributeError:\n            disablerepo = [x.strip() for x in str(disablerepo).split(',') if x != '*']\n    if enablerepo and (not isinstance(enablerepo, list)):\n        try:\n            enablerepo = [x.strip() for x in enablerepo.split(',') if x != '*']\n        except AttributeError:\n            enablerepo = [x.strip() for x in str(enablerepo).split(',') if x != '*']\n    if fromrepo:\n        repos = fromrepo\n    else:\n        repos = [repo_name for (repo_name, repo_info) in list_repos(**kwargs).items() if repo_name in enablerepo or (repo_name not in disablerepo and str(repo_info.get('enabled', '1')) == '1')]\n    ret = {}\n\n    def _check_args(args, name):\n        \"\"\"\n        Do glob matching on args and return True if a match was found.\n        Otherwise, return False\n        \"\"\"\n        for arg in args:\n            if fnmatch.fnmatch(name, arg):\n                return True\n        return False\n\n    def _parse_output(output, strict=False):\n        for pkg in _yum_pkginfo(output):\n            if strict and (pkg.repoid not in repos or not _check_args(args, pkg.name)):\n                continue\n            repo_dict = ret.setdefault(pkg.repoid, {})\n            version_list = repo_dict.setdefault(pkg.name, set())\n            version_list.add(pkg.version)\n    yum_version = None if _yum() != 'yum' else LooseVersion(__salt__['cmd.run'](['yum', '--version'], python_shell=False).splitlines()[0].strip())\n    if yum_version and yum_version < LooseVersion('3.2.13'):\n        cmd_prefix = ['--quiet']\n        if cacheonly:\n            cmd_prefix.append('-C')\n        cmd_prefix.append('list')\n        for pkg_src in ('installed', 'available'):\n            out = _call_yum(cmd_prefix + [pkg_src], ignore_retcode=True)\n            if out['retcode'] == 0:\n                _parse_output(out['stdout'], strict=True)\n    elif yum_version and yum_version < LooseVersion('3.4.3'):\n        cmd_prefix = ['--quiet', '--showduplicates']\n        if cacheonly:\n            cmd_prefix.append('-C')\n        cmd_prefix.append('list')\n        for pkg_src in ('installed', 'available'):\n            out = _call_yum(cmd_prefix + [pkg_src], ignore_retcode=True)\n            if out['retcode'] == 0:\n                _parse_output(out['stdout'], strict=True)\n    else:\n        for repo in repos:\n            if _yum() == 'tdnf':\n                cmd = ['--quiet', f'--enablerepo={repo}', 'list']\n            else:\n                cmd = ['--quiet', '--showduplicates', 'repository-packages', repo, 'list']\n            if cacheonly:\n                cmd.append('-C')\n            cmd.extend(args)\n            out = _call_yum(cmd, ignore_retcode=True)\n            if out['retcode'] != 0 and 'Error:' in out['stdout']:\n                continue\n            _parse_output(out['stdout'])\n    if byrepo:\n        for reponame in ret:\n            for pkgname in ret[reponame]:\n                sorted_versions = sorted((LooseVersion(x) for x in ret[reponame][pkgname]), reverse=True)\n                ret[reponame][pkgname] = [x.vstring for x in sorted_versions]\n        return ret\n    else:\n        byrepo_ret = {}\n        for reponame in ret:\n            for pkgname in ret[reponame]:\n                byrepo_ret.setdefault(pkgname, []).extend(ret[reponame][pkgname])\n        for pkgname in byrepo_ret:\n            sorted_versions = sorted((LooseVersion(x) for x in byrepo_ret[pkgname]), reverse=True)\n            byrepo_ret[pkgname] = [x.vstring for x in sorted_versions]\n        return byrepo_ret"
        ]
    },
    {
        "func_name": "list_upgrades",
        "original": "def list_upgrades(refresh=True, **kwargs):\n    \"\"\"\n    Check whether or not an upgrade is available for all packages\n\n    The ``fromrepo``, ``enablerepo``, and ``disablerepo`` arguments are\n    supported, as used in pkg states, and the ``disableexcludes`` option is\n    also supported.\n\n    .. versionadded:: 2014.7.0\n        Support for the ``disableexcludes`` option\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.list_upgrades\n    \"\"\"\n    options = _get_options(**kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(check_update=False, **kwargs)\n    cmd = ['--quiet']\n    cmd.extend(options)\n    cmd.extend(['list', 'upgrades' if _yum() in ('dnf', 'dnf5') else 'updates'])\n    out = _call_yum(cmd, ignore_retcode=True)\n    if out['retcode'] != 0 and 'Error:' in out:\n        return {}\n    return {x.name: x.version for x in _yum_pkginfo(out['stdout'])}",
        "mutated": [
            "def list_upgrades(refresh=True, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Check whether or not an upgrade is available for all packages\\n\\n    The ``fromrepo``, ``enablerepo``, and ``disablerepo`` arguments are\\n    supported, as used in pkg states, and the ``disableexcludes`` option is\\n    also supported.\\n\\n    .. versionadded:: 2014.7.0\\n        Support for the ``disableexcludes`` option\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_upgrades\\n    \"\n    options = _get_options(**kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(check_update=False, **kwargs)\n    cmd = ['--quiet']\n    cmd.extend(options)\n    cmd.extend(['list', 'upgrades' if _yum() in ('dnf', 'dnf5') else 'updates'])\n    out = _call_yum(cmd, ignore_retcode=True)\n    if out['retcode'] != 0 and 'Error:' in out:\n        return {}\n    return {x.name: x.version for x in _yum_pkginfo(out['stdout'])}",
            "def list_upgrades(refresh=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Check whether or not an upgrade is available for all packages\\n\\n    The ``fromrepo``, ``enablerepo``, and ``disablerepo`` arguments are\\n    supported, as used in pkg states, and the ``disableexcludes`` option is\\n    also supported.\\n\\n    .. versionadded:: 2014.7.0\\n        Support for the ``disableexcludes`` option\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_upgrades\\n    \"\n    options = _get_options(**kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(check_update=False, **kwargs)\n    cmd = ['--quiet']\n    cmd.extend(options)\n    cmd.extend(['list', 'upgrades' if _yum() in ('dnf', 'dnf5') else 'updates'])\n    out = _call_yum(cmd, ignore_retcode=True)\n    if out['retcode'] != 0 and 'Error:' in out:\n        return {}\n    return {x.name: x.version for x in _yum_pkginfo(out['stdout'])}",
            "def list_upgrades(refresh=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Check whether or not an upgrade is available for all packages\\n\\n    The ``fromrepo``, ``enablerepo``, and ``disablerepo`` arguments are\\n    supported, as used in pkg states, and the ``disableexcludes`` option is\\n    also supported.\\n\\n    .. versionadded:: 2014.7.0\\n        Support for the ``disableexcludes`` option\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_upgrades\\n    \"\n    options = _get_options(**kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(check_update=False, **kwargs)\n    cmd = ['--quiet']\n    cmd.extend(options)\n    cmd.extend(['list', 'upgrades' if _yum() in ('dnf', 'dnf5') else 'updates'])\n    out = _call_yum(cmd, ignore_retcode=True)\n    if out['retcode'] != 0 and 'Error:' in out:\n        return {}\n    return {x.name: x.version for x in _yum_pkginfo(out['stdout'])}",
            "def list_upgrades(refresh=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Check whether or not an upgrade is available for all packages\\n\\n    The ``fromrepo``, ``enablerepo``, and ``disablerepo`` arguments are\\n    supported, as used in pkg states, and the ``disableexcludes`` option is\\n    also supported.\\n\\n    .. versionadded:: 2014.7.0\\n        Support for the ``disableexcludes`` option\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_upgrades\\n    \"\n    options = _get_options(**kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(check_update=False, **kwargs)\n    cmd = ['--quiet']\n    cmd.extend(options)\n    cmd.extend(['list', 'upgrades' if _yum() in ('dnf', 'dnf5') else 'updates'])\n    out = _call_yum(cmd, ignore_retcode=True)\n    if out['retcode'] != 0 and 'Error:' in out:\n        return {}\n    return {x.name: x.version for x in _yum_pkginfo(out['stdout'])}",
            "def list_upgrades(refresh=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Check whether or not an upgrade is available for all packages\\n\\n    The ``fromrepo``, ``enablerepo``, and ``disablerepo`` arguments are\\n    supported, as used in pkg states, and the ``disableexcludes`` option is\\n    also supported.\\n\\n    .. versionadded:: 2014.7.0\\n        Support for the ``disableexcludes`` option\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_upgrades\\n    \"\n    options = _get_options(**kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(check_update=False, **kwargs)\n    cmd = ['--quiet']\n    cmd.extend(options)\n    cmd.extend(['list', 'upgrades' if _yum() in ('dnf', 'dnf5') else 'updates'])\n    out = _call_yum(cmd, ignore_retcode=True)\n    if out['retcode'] != 0 and 'Error:' in out:\n        return {}\n    return {x.name: x.version for x in _yum_pkginfo(out['stdout'])}"
        ]
    },
    {
        "func_name": "list_downloaded",
        "original": "def list_downloaded(**kwargs):\n    \"\"\"\n    .. versionadded:: 2017.7.0\n\n    List prefetched packages downloaded by Yum in the local disk.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.list_downloaded\n    \"\"\"\n    CACHE_DIR = os.path.join('/var/cache/', _yum())\n    ret = {}\n    for (root, dirnames, filenames) in salt.utils.path.os_walk(CACHE_DIR):\n        for filename in fnmatch.filter(filenames, '*.rpm'):\n            package_path = os.path.join(root, filename)\n            pkg_info = __salt__['lowpkg.bin_pkg_info'](package_path)\n            pkg_timestamp = int(os.path.getctime(package_path))\n            ret.setdefault(pkg_info['name'], {})[pkg_info['version']] = {'path': package_path, 'size': os.path.getsize(package_path), 'creation_date_time_t': pkg_timestamp, 'creation_date_time': datetime.datetime.fromtimestamp(pkg_timestamp).isoformat()}\n    return ret",
        "mutated": [
            "def list_downloaded(**kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    List prefetched packages downloaded by Yum in the local disk.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_downloaded\\n    \"\n    CACHE_DIR = os.path.join('/var/cache/', _yum())\n    ret = {}\n    for (root, dirnames, filenames) in salt.utils.path.os_walk(CACHE_DIR):\n        for filename in fnmatch.filter(filenames, '*.rpm'):\n            package_path = os.path.join(root, filename)\n            pkg_info = __salt__['lowpkg.bin_pkg_info'](package_path)\n            pkg_timestamp = int(os.path.getctime(package_path))\n            ret.setdefault(pkg_info['name'], {})[pkg_info['version']] = {'path': package_path, 'size': os.path.getsize(package_path), 'creation_date_time_t': pkg_timestamp, 'creation_date_time': datetime.datetime.fromtimestamp(pkg_timestamp).isoformat()}\n    return ret",
            "def list_downloaded(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    List prefetched packages downloaded by Yum in the local disk.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_downloaded\\n    \"\n    CACHE_DIR = os.path.join('/var/cache/', _yum())\n    ret = {}\n    for (root, dirnames, filenames) in salt.utils.path.os_walk(CACHE_DIR):\n        for filename in fnmatch.filter(filenames, '*.rpm'):\n            package_path = os.path.join(root, filename)\n            pkg_info = __salt__['lowpkg.bin_pkg_info'](package_path)\n            pkg_timestamp = int(os.path.getctime(package_path))\n            ret.setdefault(pkg_info['name'], {})[pkg_info['version']] = {'path': package_path, 'size': os.path.getsize(package_path), 'creation_date_time_t': pkg_timestamp, 'creation_date_time': datetime.datetime.fromtimestamp(pkg_timestamp).isoformat()}\n    return ret",
            "def list_downloaded(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    List prefetched packages downloaded by Yum in the local disk.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_downloaded\\n    \"\n    CACHE_DIR = os.path.join('/var/cache/', _yum())\n    ret = {}\n    for (root, dirnames, filenames) in salt.utils.path.os_walk(CACHE_DIR):\n        for filename in fnmatch.filter(filenames, '*.rpm'):\n            package_path = os.path.join(root, filename)\n            pkg_info = __salt__['lowpkg.bin_pkg_info'](package_path)\n            pkg_timestamp = int(os.path.getctime(package_path))\n            ret.setdefault(pkg_info['name'], {})[pkg_info['version']] = {'path': package_path, 'size': os.path.getsize(package_path), 'creation_date_time_t': pkg_timestamp, 'creation_date_time': datetime.datetime.fromtimestamp(pkg_timestamp).isoformat()}\n    return ret",
            "def list_downloaded(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    List prefetched packages downloaded by Yum in the local disk.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_downloaded\\n    \"\n    CACHE_DIR = os.path.join('/var/cache/', _yum())\n    ret = {}\n    for (root, dirnames, filenames) in salt.utils.path.os_walk(CACHE_DIR):\n        for filename in fnmatch.filter(filenames, '*.rpm'):\n            package_path = os.path.join(root, filename)\n            pkg_info = __salt__['lowpkg.bin_pkg_info'](package_path)\n            pkg_timestamp = int(os.path.getctime(package_path))\n            ret.setdefault(pkg_info['name'], {})[pkg_info['version']] = {'path': package_path, 'size': os.path.getsize(package_path), 'creation_date_time_t': pkg_timestamp, 'creation_date_time': datetime.datetime.fromtimestamp(pkg_timestamp).isoformat()}\n    return ret",
            "def list_downloaded(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    List prefetched packages downloaded by Yum in the local disk.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_downloaded\\n    \"\n    CACHE_DIR = os.path.join('/var/cache/', _yum())\n    ret = {}\n    for (root, dirnames, filenames) in salt.utils.path.os_walk(CACHE_DIR):\n        for filename in fnmatch.filter(filenames, '*.rpm'):\n            package_path = os.path.join(root, filename)\n            pkg_info = __salt__['lowpkg.bin_pkg_info'](package_path)\n            pkg_timestamp = int(os.path.getctime(package_path))\n            ret.setdefault(pkg_info['name'], {})[pkg_info['version']] = {'path': package_path, 'size': os.path.getsize(package_path), 'creation_date_time_t': pkg_timestamp, 'creation_date_time': datetime.datetime.fromtimestamp(pkg_timestamp).isoformat()}\n    return ret"
        ]
    },
    {
        "func_name": "info_installed",
        "original": "def info_installed(*names, **kwargs):\n    \"\"\"\n    .. versionadded:: 2015.8.1\n\n    Return the information of the named package(s), installed on the system.\n\n    :param all_versions:\n        Include information for all versions of the packages installed on the minion.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.info_installed <package1>\n        salt '*' pkg.info_installed <package1> <package2> <package3> ...\n        salt '*' pkg.info_installed <package1> <package2> <package3> all_versions=True\n    \"\"\"\n    all_versions = kwargs.get('all_versions', False)\n    ret = dict()\n    for (pkg_name, pkgs_nfo) in __salt__['lowpkg.info'](*names, **kwargs).items():\n        pkg_nfo = pkgs_nfo if all_versions else [pkgs_nfo]\n        for _nfo in pkg_nfo:\n            t_nfo = dict()\n            for (key, value) in _nfo.items():\n                if key == 'source_rpm':\n                    t_nfo['source'] = value\n                else:\n                    t_nfo[key] = value\n            if not all_versions:\n                ret[pkg_name] = t_nfo\n            else:\n                ret.setdefault(pkg_name, []).append(t_nfo)\n    return ret",
        "mutated": [
            "def info_installed(*names, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2015.8.1\\n\\n    Return the information of the named package(s), installed on the system.\\n\\n    :param all_versions:\\n        Include information for all versions of the packages installed on the minion.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.info_installed <package1>\\n        salt '*' pkg.info_installed <package1> <package2> <package3> ...\\n        salt '*' pkg.info_installed <package1> <package2> <package3> all_versions=True\\n    \"\n    all_versions = kwargs.get('all_versions', False)\n    ret = dict()\n    for (pkg_name, pkgs_nfo) in __salt__['lowpkg.info'](*names, **kwargs).items():\n        pkg_nfo = pkgs_nfo if all_versions else [pkgs_nfo]\n        for _nfo in pkg_nfo:\n            t_nfo = dict()\n            for (key, value) in _nfo.items():\n                if key == 'source_rpm':\n                    t_nfo['source'] = value\n                else:\n                    t_nfo[key] = value\n            if not all_versions:\n                ret[pkg_name] = t_nfo\n            else:\n                ret.setdefault(pkg_name, []).append(t_nfo)\n    return ret",
            "def info_installed(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2015.8.1\\n\\n    Return the information of the named package(s), installed on the system.\\n\\n    :param all_versions:\\n        Include information for all versions of the packages installed on the minion.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.info_installed <package1>\\n        salt '*' pkg.info_installed <package1> <package2> <package3> ...\\n        salt '*' pkg.info_installed <package1> <package2> <package3> all_versions=True\\n    \"\n    all_versions = kwargs.get('all_versions', False)\n    ret = dict()\n    for (pkg_name, pkgs_nfo) in __salt__['lowpkg.info'](*names, **kwargs).items():\n        pkg_nfo = pkgs_nfo if all_versions else [pkgs_nfo]\n        for _nfo in pkg_nfo:\n            t_nfo = dict()\n            for (key, value) in _nfo.items():\n                if key == 'source_rpm':\n                    t_nfo['source'] = value\n                else:\n                    t_nfo[key] = value\n            if not all_versions:\n                ret[pkg_name] = t_nfo\n            else:\n                ret.setdefault(pkg_name, []).append(t_nfo)\n    return ret",
            "def info_installed(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2015.8.1\\n\\n    Return the information of the named package(s), installed on the system.\\n\\n    :param all_versions:\\n        Include information for all versions of the packages installed on the minion.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.info_installed <package1>\\n        salt '*' pkg.info_installed <package1> <package2> <package3> ...\\n        salt '*' pkg.info_installed <package1> <package2> <package3> all_versions=True\\n    \"\n    all_versions = kwargs.get('all_versions', False)\n    ret = dict()\n    for (pkg_name, pkgs_nfo) in __salt__['lowpkg.info'](*names, **kwargs).items():\n        pkg_nfo = pkgs_nfo if all_versions else [pkgs_nfo]\n        for _nfo in pkg_nfo:\n            t_nfo = dict()\n            for (key, value) in _nfo.items():\n                if key == 'source_rpm':\n                    t_nfo['source'] = value\n                else:\n                    t_nfo[key] = value\n            if not all_versions:\n                ret[pkg_name] = t_nfo\n            else:\n                ret.setdefault(pkg_name, []).append(t_nfo)\n    return ret",
            "def info_installed(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2015.8.1\\n\\n    Return the information of the named package(s), installed on the system.\\n\\n    :param all_versions:\\n        Include information for all versions of the packages installed on the minion.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.info_installed <package1>\\n        salt '*' pkg.info_installed <package1> <package2> <package3> ...\\n        salt '*' pkg.info_installed <package1> <package2> <package3> all_versions=True\\n    \"\n    all_versions = kwargs.get('all_versions', False)\n    ret = dict()\n    for (pkg_name, pkgs_nfo) in __salt__['lowpkg.info'](*names, **kwargs).items():\n        pkg_nfo = pkgs_nfo if all_versions else [pkgs_nfo]\n        for _nfo in pkg_nfo:\n            t_nfo = dict()\n            for (key, value) in _nfo.items():\n                if key == 'source_rpm':\n                    t_nfo['source'] = value\n                else:\n                    t_nfo[key] = value\n            if not all_versions:\n                ret[pkg_name] = t_nfo\n            else:\n                ret.setdefault(pkg_name, []).append(t_nfo)\n    return ret",
            "def info_installed(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2015.8.1\\n\\n    Return the information of the named package(s), installed on the system.\\n\\n    :param all_versions:\\n        Include information for all versions of the packages installed on the minion.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.info_installed <package1>\\n        salt '*' pkg.info_installed <package1> <package2> <package3> ...\\n        salt '*' pkg.info_installed <package1> <package2> <package3> all_versions=True\\n    \"\n    all_versions = kwargs.get('all_versions', False)\n    ret = dict()\n    for (pkg_name, pkgs_nfo) in __salt__['lowpkg.info'](*names, **kwargs).items():\n        pkg_nfo = pkgs_nfo if all_versions else [pkgs_nfo]\n        for _nfo in pkg_nfo:\n            t_nfo = dict()\n            for (key, value) in _nfo.items():\n                if key == 'source_rpm':\n                    t_nfo['source'] = value\n                else:\n                    t_nfo[key] = value\n            if not all_versions:\n                ret[pkg_name] = t_nfo\n            else:\n                ret.setdefault(pkg_name, []).append(t_nfo)\n    return ret"
        ]
    },
    {
        "func_name": "refresh_db",
        "original": "def refresh_db(**kwargs):\n    \"\"\"\n    Check the yum repos for updated packages\n\n    Returns:\n\n    - ``True``: Updates are available\n    - ``False``: An error occurred\n    - ``None``: No updates are available\n\n    repo\n        Refresh just the specified repo\n\n    disablerepo\n        Do not refresh the specified repo\n\n    enablerepo\n        Refresh a disabled repo using this option\n\n    branch\n        Add the specified branch when refreshing\n\n    disableexcludes\n        Disable the excludes defined in your config files. Takes one of three\n        options:\n        - ``all`` - disable all excludes\n        - ``main`` - disable excludes defined in [main] in yum.conf\n        - ``repoid`` - disable excludes defined for that repo\n\n    setopt\n        A comma-separated or Python list of key=value options. This list will\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\n        that is run.\n\n        .. versionadded:: 2019.2.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.refresh_db\n    \"\"\"\n    salt.utils.pkg.clear_rtag(__opts__)\n    retcodes = {100: True, 0: None, 1: False}\n    ret = True\n    check_update_ = kwargs.pop('check_update', True)\n    options = _get_options(**kwargs)\n    clean_cmd = ['--quiet', '--assumeyes', 'clean', 'expire-cache']\n    clean_cmd.extend(options)\n    _call_yum(clean_cmd, ignore_retcode=True)\n    if check_update_:\n        update_cmd = ['--quiet', '--assumeyes', 'check-update']\n        if __grains__.get('os_family') == 'RedHat' and __grains__.get('osmajorrelease') == 7:\n            update_cmd.append('--setopt=autocheck_running_kernel=false')\n        update_cmd.extend(options)\n        ret = retcodes.get(_call_yum(update_cmd, ignore_retcode=True)['retcode'], False)\n    return ret",
        "mutated": [
            "def refresh_db(**kwargs):\n    if False:\n        i = 10\n    \"\\n    Check the yum repos for updated packages\\n\\n    Returns:\\n\\n    - ``True``: Updates are available\\n    - ``False``: An error occurred\\n    - ``None``: No updates are available\\n\\n    repo\\n        Refresh just the specified repo\\n\\n    disablerepo\\n        Do not refresh the specified repo\\n\\n    enablerepo\\n        Refresh a disabled repo using this option\\n\\n    branch\\n        Add the specified branch when refreshing\\n\\n    disableexcludes\\n        Disable the excludes defined in your config files. Takes one of three\\n        options:\\n        - ``all`` - disable all excludes\\n        - ``main`` - disable excludes defined in [main] in yum.conf\\n        - ``repoid`` - disable excludes defined for that repo\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.refresh_db\\n    \"\n    salt.utils.pkg.clear_rtag(__opts__)\n    retcodes = {100: True, 0: None, 1: False}\n    ret = True\n    check_update_ = kwargs.pop('check_update', True)\n    options = _get_options(**kwargs)\n    clean_cmd = ['--quiet', '--assumeyes', 'clean', 'expire-cache']\n    clean_cmd.extend(options)\n    _call_yum(clean_cmd, ignore_retcode=True)\n    if check_update_:\n        update_cmd = ['--quiet', '--assumeyes', 'check-update']\n        if __grains__.get('os_family') == 'RedHat' and __grains__.get('osmajorrelease') == 7:\n            update_cmd.append('--setopt=autocheck_running_kernel=false')\n        update_cmd.extend(options)\n        ret = retcodes.get(_call_yum(update_cmd, ignore_retcode=True)['retcode'], False)\n    return ret",
            "def refresh_db(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Check the yum repos for updated packages\\n\\n    Returns:\\n\\n    - ``True``: Updates are available\\n    - ``False``: An error occurred\\n    - ``None``: No updates are available\\n\\n    repo\\n        Refresh just the specified repo\\n\\n    disablerepo\\n        Do not refresh the specified repo\\n\\n    enablerepo\\n        Refresh a disabled repo using this option\\n\\n    branch\\n        Add the specified branch when refreshing\\n\\n    disableexcludes\\n        Disable the excludes defined in your config files. Takes one of three\\n        options:\\n        - ``all`` - disable all excludes\\n        - ``main`` - disable excludes defined in [main] in yum.conf\\n        - ``repoid`` - disable excludes defined for that repo\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.refresh_db\\n    \"\n    salt.utils.pkg.clear_rtag(__opts__)\n    retcodes = {100: True, 0: None, 1: False}\n    ret = True\n    check_update_ = kwargs.pop('check_update', True)\n    options = _get_options(**kwargs)\n    clean_cmd = ['--quiet', '--assumeyes', 'clean', 'expire-cache']\n    clean_cmd.extend(options)\n    _call_yum(clean_cmd, ignore_retcode=True)\n    if check_update_:\n        update_cmd = ['--quiet', '--assumeyes', 'check-update']\n        if __grains__.get('os_family') == 'RedHat' and __grains__.get('osmajorrelease') == 7:\n            update_cmd.append('--setopt=autocheck_running_kernel=false')\n        update_cmd.extend(options)\n        ret = retcodes.get(_call_yum(update_cmd, ignore_retcode=True)['retcode'], False)\n    return ret",
            "def refresh_db(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Check the yum repos for updated packages\\n\\n    Returns:\\n\\n    - ``True``: Updates are available\\n    - ``False``: An error occurred\\n    - ``None``: No updates are available\\n\\n    repo\\n        Refresh just the specified repo\\n\\n    disablerepo\\n        Do not refresh the specified repo\\n\\n    enablerepo\\n        Refresh a disabled repo using this option\\n\\n    branch\\n        Add the specified branch when refreshing\\n\\n    disableexcludes\\n        Disable the excludes defined in your config files. Takes one of three\\n        options:\\n        - ``all`` - disable all excludes\\n        - ``main`` - disable excludes defined in [main] in yum.conf\\n        - ``repoid`` - disable excludes defined for that repo\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.refresh_db\\n    \"\n    salt.utils.pkg.clear_rtag(__opts__)\n    retcodes = {100: True, 0: None, 1: False}\n    ret = True\n    check_update_ = kwargs.pop('check_update', True)\n    options = _get_options(**kwargs)\n    clean_cmd = ['--quiet', '--assumeyes', 'clean', 'expire-cache']\n    clean_cmd.extend(options)\n    _call_yum(clean_cmd, ignore_retcode=True)\n    if check_update_:\n        update_cmd = ['--quiet', '--assumeyes', 'check-update']\n        if __grains__.get('os_family') == 'RedHat' and __grains__.get('osmajorrelease') == 7:\n            update_cmd.append('--setopt=autocheck_running_kernel=false')\n        update_cmd.extend(options)\n        ret = retcodes.get(_call_yum(update_cmd, ignore_retcode=True)['retcode'], False)\n    return ret",
            "def refresh_db(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Check the yum repos for updated packages\\n\\n    Returns:\\n\\n    - ``True``: Updates are available\\n    - ``False``: An error occurred\\n    - ``None``: No updates are available\\n\\n    repo\\n        Refresh just the specified repo\\n\\n    disablerepo\\n        Do not refresh the specified repo\\n\\n    enablerepo\\n        Refresh a disabled repo using this option\\n\\n    branch\\n        Add the specified branch when refreshing\\n\\n    disableexcludes\\n        Disable the excludes defined in your config files. Takes one of three\\n        options:\\n        - ``all`` - disable all excludes\\n        - ``main`` - disable excludes defined in [main] in yum.conf\\n        - ``repoid`` - disable excludes defined for that repo\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.refresh_db\\n    \"\n    salt.utils.pkg.clear_rtag(__opts__)\n    retcodes = {100: True, 0: None, 1: False}\n    ret = True\n    check_update_ = kwargs.pop('check_update', True)\n    options = _get_options(**kwargs)\n    clean_cmd = ['--quiet', '--assumeyes', 'clean', 'expire-cache']\n    clean_cmd.extend(options)\n    _call_yum(clean_cmd, ignore_retcode=True)\n    if check_update_:\n        update_cmd = ['--quiet', '--assumeyes', 'check-update']\n        if __grains__.get('os_family') == 'RedHat' and __grains__.get('osmajorrelease') == 7:\n            update_cmd.append('--setopt=autocheck_running_kernel=false')\n        update_cmd.extend(options)\n        ret = retcodes.get(_call_yum(update_cmd, ignore_retcode=True)['retcode'], False)\n    return ret",
            "def refresh_db(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Check the yum repos for updated packages\\n\\n    Returns:\\n\\n    - ``True``: Updates are available\\n    - ``False``: An error occurred\\n    - ``None``: No updates are available\\n\\n    repo\\n        Refresh just the specified repo\\n\\n    disablerepo\\n        Do not refresh the specified repo\\n\\n    enablerepo\\n        Refresh a disabled repo using this option\\n\\n    branch\\n        Add the specified branch when refreshing\\n\\n    disableexcludes\\n        Disable the excludes defined in your config files. Takes one of three\\n        options:\\n        - ``all`` - disable all excludes\\n        - ``main`` - disable excludes defined in [main] in yum.conf\\n        - ``repoid`` - disable excludes defined for that repo\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.refresh_db\\n    \"\n    salt.utils.pkg.clear_rtag(__opts__)\n    retcodes = {100: True, 0: None, 1: False}\n    ret = True\n    check_update_ = kwargs.pop('check_update', True)\n    options = _get_options(**kwargs)\n    clean_cmd = ['--quiet', '--assumeyes', 'clean', 'expire-cache']\n    clean_cmd.extend(options)\n    _call_yum(clean_cmd, ignore_retcode=True)\n    if check_update_:\n        update_cmd = ['--quiet', '--assumeyes', 'check-update']\n        if __grains__.get('os_family') == 'RedHat' and __grains__.get('osmajorrelease') == 7:\n            update_cmd.append('--setopt=autocheck_running_kernel=false')\n        update_cmd.extend(options)\n        ret = retcodes.get(_call_yum(update_cmd, ignore_retcode=True)['retcode'], False)\n    return ret"
        ]
    },
    {
        "func_name": "clean_metadata",
        "original": "def clean_metadata(**kwargs):\n    \"\"\"\n    .. versionadded:: 2014.1.0\n\n    Cleans local yum metadata. Functionally identical to :mod:`refresh_db()\n    <salt.modules.yumpkg.refresh_db>`.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.clean_metadata\n    \"\"\"\n    return refresh_db(**kwargs)",
        "mutated": [
            "def clean_metadata(**kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    Cleans local yum metadata. Functionally identical to :mod:`refresh_db()\\n    <salt.modules.yumpkg.refresh_db>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.clean_metadata\\n    \"\n    return refresh_db(**kwargs)",
            "def clean_metadata(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    Cleans local yum metadata. Functionally identical to :mod:`refresh_db()\\n    <salt.modules.yumpkg.refresh_db>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.clean_metadata\\n    \"\n    return refresh_db(**kwargs)",
            "def clean_metadata(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    Cleans local yum metadata. Functionally identical to :mod:`refresh_db()\\n    <salt.modules.yumpkg.refresh_db>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.clean_metadata\\n    \"\n    return refresh_db(**kwargs)",
            "def clean_metadata(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    Cleans local yum metadata. Functionally identical to :mod:`refresh_db()\\n    <salt.modules.yumpkg.refresh_db>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.clean_metadata\\n    \"\n    return refresh_db(**kwargs)",
            "def clean_metadata(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    Cleans local yum metadata. Functionally identical to :mod:`refresh_db()\\n    <salt.modules.yumpkg.refresh_db>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.clean_metadata\\n    \"\n    return refresh_db(**kwargs)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, *args, **kwargs):\n    super().__init__()\n    self._args = args\n    self._kwargs = kwargs",
        "mutated": [
            "def __init__(self, *args, **kwargs):\n    if False:\n        i = 10\n    super().__init__()\n    self._args = args\n    self._kwargs = kwargs",
            "def __init__(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__()\n    self._args = args\n    self._kwargs = kwargs",
            "def __init__(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__()\n    self._args = args\n    self._kwargs = kwargs",
            "def __init__(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__()\n    self._args = args\n    self._kwargs = kwargs",
            "def __init__(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__()\n    self._args = args\n    self._kwargs = kwargs"
        ]
    },
    {
        "func_name": "_load",
        "original": "def _load(self, key):\n    self._load_all()\n    return True",
        "mutated": [
            "def _load(self, key):\n    if False:\n        i = 10\n    self._load_all()\n    return True",
            "def _load(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._load_all()\n    return True",
            "def _load(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._load_all()\n    return True",
            "def _load(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._load_all()\n    return True",
            "def _load(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._load_all()\n    return True"
        ]
    },
    {
        "func_name": "_load_all",
        "original": "def _load_all(self):\n    self._dict = list_repo_pkgs(*self._args, **self._kwargs)\n    self.loaded = True",
        "mutated": [
            "def _load_all(self):\n    if False:\n        i = 10\n    self._dict = list_repo_pkgs(*self._args, **self._kwargs)\n    self.loaded = True",
            "def _load_all(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._dict = list_repo_pkgs(*self._args, **self._kwargs)\n    self.loaded = True",
            "def _load_all(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._dict = list_repo_pkgs(*self._args, **self._kwargs)\n    self.loaded = True",
            "def _load_all(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._dict = list_repo_pkgs(*self._args, **self._kwargs)\n    self.loaded = True",
            "def _load_all(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._dict = list_repo_pkgs(*self._args, **self._kwargs)\n    self.loaded = True"
        ]
    },
    {
        "func_name": "_add_common_args",
        "original": "def _add_common_args(cmd):\n    \"\"\"\n        DRY function to add args common to all yum/dnf commands\n        \"\"\"\n    cmd.extend(options)\n    if skip_verify:\n        cmd.append('--nogpgcheck')\n    if downloadonly:\n        if _yum() != 'dnf5':\n            cmd.append('--downloadonly')",
        "mutated": [
            "def _add_common_args(cmd):\n    if False:\n        i = 10\n    '\\n        DRY function to add args common to all yum/dnf commands\\n        '\n    cmd.extend(options)\n    if skip_verify:\n        cmd.append('--nogpgcheck')\n    if downloadonly:\n        if _yum() != 'dnf5':\n            cmd.append('--downloadonly')",
            "def _add_common_args(cmd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        DRY function to add args common to all yum/dnf commands\\n        '\n    cmd.extend(options)\n    if skip_verify:\n        cmd.append('--nogpgcheck')\n    if downloadonly:\n        if _yum() != 'dnf5':\n            cmd.append('--downloadonly')",
            "def _add_common_args(cmd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        DRY function to add args common to all yum/dnf commands\\n        '\n    cmd.extend(options)\n    if skip_verify:\n        cmd.append('--nogpgcheck')\n    if downloadonly:\n        if _yum() != 'dnf5':\n            cmd.append('--downloadonly')",
            "def _add_common_args(cmd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        DRY function to add args common to all yum/dnf commands\\n        '\n    cmd.extend(options)\n    if skip_verify:\n        cmd.append('--nogpgcheck')\n    if downloadonly:\n        if _yum() != 'dnf5':\n            cmd.append('--downloadonly')",
            "def _add_common_args(cmd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        DRY function to add args common to all yum/dnf commands\\n        '\n    cmd.extend(options)\n    if skip_verify:\n        cmd.append('--nogpgcheck')\n    if downloadonly:\n        if _yum() != 'dnf5':\n            cmd.append('--downloadonly')"
        ]
    },
    {
        "func_name": "_temporarily_unhold",
        "original": "@contextlib.contextmanager\ndef _temporarily_unhold(pkgs, targets):\n    \"\"\"\n        Temporarily unhold packages that need to be updated. Add any\n        successfully-removed ones (and any packages not in the list of current\n        holds) to the list of targets.\n        \"\"\"\n    to_unhold = {}\n    for (pkgname, pkgstr) in pkgs:\n        if pkgname in holds:\n            if update_holds:\n                to_unhold[pkgname] = pkgstr\n            else:\n                unhold_prevented.append(pkgname)\n        else:\n            targets.append(pkgstr)\n    if not to_unhold:\n        yield\n    else:\n        log.debug('Unholding packages: %s', ', '.join(to_unhold))\n        try:\n            unhold_names = list(to_unhold.keys())\n            for (unheld_pkg, outcome) in unhold(pkgs=unhold_names).items():\n                if outcome['result']:\n                    targets.append(to_unhold[unheld_pkg])\n                else:\n                    errors.append(unheld_pkg)\n            yield\n        except Exception as exc:\n            errors.append('Error encountered unholding packages {}: {}'.format(', '.join(to_unhold), exc))\n        finally:\n            hold(pkgs=unhold_names)",
        "mutated": [
            "@contextlib.contextmanager\ndef _temporarily_unhold(pkgs, targets):\n    if False:\n        i = 10\n    '\\n        Temporarily unhold packages that need to be updated. Add any\\n        successfully-removed ones (and any packages not in the list of current\\n        holds) to the list of targets.\\n        '\n    to_unhold = {}\n    for (pkgname, pkgstr) in pkgs:\n        if pkgname in holds:\n            if update_holds:\n                to_unhold[pkgname] = pkgstr\n            else:\n                unhold_prevented.append(pkgname)\n        else:\n            targets.append(pkgstr)\n    if not to_unhold:\n        yield\n    else:\n        log.debug('Unholding packages: %s', ', '.join(to_unhold))\n        try:\n            unhold_names = list(to_unhold.keys())\n            for (unheld_pkg, outcome) in unhold(pkgs=unhold_names).items():\n                if outcome['result']:\n                    targets.append(to_unhold[unheld_pkg])\n                else:\n                    errors.append(unheld_pkg)\n            yield\n        except Exception as exc:\n            errors.append('Error encountered unholding packages {}: {}'.format(', '.join(to_unhold), exc))\n        finally:\n            hold(pkgs=unhold_names)",
            "@contextlib.contextmanager\ndef _temporarily_unhold(pkgs, targets):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Temporarily unhold packages that need to be updated. Add any\\n        successfully-removed ones (and any packages not in the list of current\\n        holds) to the list of targets.\\n        '\n    to_unhold = {}\n    for (pkgname, pkgstr) in pkgs:\n        if pkgname in holds:\n            if update_holds:\n                to_unhold[pkgname] = pkgstr\n            else:\n                unhold_prevented.append(pkgname)\n        else:\n            targets.append(pkgstr)\n    if not to_unhold:\n        yield\n    else:\n        log.debug('Unholding packages: %s', ', '.join(to_unhold))\n        try:\n            unhold_names = list(to_unhold.keys())\n            for (unheld_pkg, outcome) in unhold(pkgs=unhold_names).items():\n                if outcome['result']:\n                    targets.append(to_unhold[unheld_pkg])\n                else:\n                    errors.append(unheld_pkg)\n            yield\n        except Exception as exc:\n            errors.append('Error encountered unholding packages {}: {}'.format(', '.join(to_unhold), exc))\n        finally:\n            hold(pkgs=unhold_names)",
            "@contextlib.contextmanager\ndef _temporarily_unhold(pkgs, targets):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Temporarily unhold packages that need to be updated. Add any\\n        successfully-removed ones (and any packages not in the list of current\\n        holds) to the list of targets.\\n        '\n    to_unhold = {}\n    for (pkgname, pkgstr) in pkgs:\n        if pkgname in holds:\n            if update_holds:\n                to_unhold[pkgname] = pkgstr\n            else:\n                unhold_prevented.append(pkgname)\n        else:\n            targets.append(pkgstr)\n    if not to_unhold:\n        yield\n    else:\n        log.debug('Unholding packages: %s', ', '.join(to_unhold))\n        try:\n            unhold_names = list(to_unhold.keys())\n            for (unheld_pkg, outcome) in unhold(pkgs=unhold_names).items():\n                if outcome['result']:\n                    targets.append(to_unhold[unheld_pkg])\n                else:\n                    errors.append(unheld_pkg)\n            yield\n        except Exception as exc:\n            errors.append('Error encountered unholding packages {}: {}'.format(', '.join(to_unhold), exc))\n        finally:\n            hold(pkgs=unhold_names)",
            "@contextlib.contextmanager\ndef _temporarily_unhold(pkgs, targets):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Temporarily unhold packages that need to be updated. Add any\\n        successfully-removed ones (and any packages not in the list of current\\n        holds) to the list of targets.\\n        '\n    to_unhold = {}\n    for (pkgname, pkgstr) in pkgs:\n        if pkgname in holds:\n            if update_holds:\n                to_unhold[pkgname] = pkgstr\n            else:\n                unhold_prevented.append(pkgname)\n        else:\n            targets.append(pkgstr)\n    if not to_unhold:\n        yield\n    else:\n        log.debug('Unholding packages: %s', ', '.join(to_unhold))\n        try:\n            unhold_names = list(to_unhold.keys())\n            for (unheld_pkg, outcome) in unhold(pkgs=unhold_names).items():\n                if outcome['result']:\n                    targets.append(to_unhold[unheld_pkg])\n                else:\n                    errors.append(unheld_pkg)\n            yield\n        except Exception as exc:\n            errors.append('Error encountered unholding packages {}: {}'.format(', '.join(to_unhold), exc))\n        finally:\n            hold(pkgs=unhold_names)",
            "@contextlib.contextmanager\ndef _temporarily_unhold(pkgs, targets):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Temporarily unhold packages that need to be updated. Add any\\n        successfully-removed ones (and any packages not in the list of current\\n        holds) to the list of targets.\\n        '\n    to_unhold = {}\n    for (pkgname, pkgstr) in pkgs:\n        if pkgname in holds:\n            if update_holds:\n                to_unhold[pkgname] = pkgstr\n            else:\n                unhold_prevented.append(pkgname)\n        else:\n            targets.append(pkgstr)\n    if not to_unhold:\n        yield\n    else:\n        log.debug('Unholding packages: %s', ', '.join(to_unhold))\n        try:\n            unhold_names = list(to_unhold.keys())\n            for (unheld_pkg, outcome) in unhold(pkgs=unhold_names).items():\n                if outcome['result']:\n                    targets.append(to_unhold[unheld_pkg])\n                else:\n                    errors.append(unheld_pkg)\n            yield\n        except Exception as exc:\n            errors.append('Error encountered unholding packages {}: {}'.format(', '.join(to_unhold), exc))\n        finally:\n            hold(pkgs=unhold_names)"
        ]
    },
    {
        "func_name": "install",
        "original": "def install(name=None, refresh=False, skip_verify=False, pkgs=None, sources=None, downloadonly=False, reinstall=False, normalize=True, update_holds=False, saltenv='base', ignore_epoch=False, **kwargs):\n    \"\"\"\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\n        isolate commands which modify installed packages from the\n        ``salt-minion`` daemon's control group. This is done to keep systemd\n        from killing any yum/dnf commands spawned by Salt when the\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\n        ``False`` (no quotes).\n\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\n\n    Install the passed package(s), add refresh=True to clean the yum database\n    before package is installed.\n\n    name\n        The name of the package to be installed. Note that this parameter is\n        ignored if either \"pkgs\" or \"sources\" is passed. Additionally, please\n        note that this option can only be used to install packages from a\n        software repository. To install a package file manually, use the\n        \"sources\" option.\n\n        32-bit packages can be installed on 64-bit systems by appending the\n        architecture designation (``.i686``, ``.i586``, etc.) to the end of the\n        package name.\n\n        CLI Example:\n\n        .. code-block:: bash\n\n            salt '*' pkg.install <package name>\n\n    refresh\n        Whether or not to update the yum database before executing.\n\n    reinstall\n        Specifying reinstall=True will use ``yum reinstall`` rather than\n        ``yum install`` for requested packages that are already installed.\n\n        If a version is specified with the requested package, then\n        ``yum reinstall`` will only be used if the installed version\n        matches the requested version.\n\n        Works with ``sources`` when the package header of the source can be\n        matched to the name and version of an installed package.\n\n        .. versionadded:: 2014.7.0\n\n    skip_verify\n        Skip the GPG verification check (e.g., ``--nogpgcheck``)\n\n    downloadonly\n        Only download the packages, do not install.\n\n    version\n        Install a specific version of the package, e.g. 1.2.3-4.el5. Ignored\n        if \"pkgs\" or \"sources\" is passed.\n\n        .. versionchanged:: 2018.3.0\n            version can now contain comparison operators (e.g. ``>1.2.3``,\n            ``<=2.0``, etc.)\n\n    update_holds : False\n        If ``True``, and this function would update the package version, any\n        packages held using the yum/dnf \"versionlock\" plugin will be unheld so\n        that they can be updated. Otherwise, if this function attempts to\n        update a held package, the held package(s) will be skipped and an\n        error will be raised.\n\n        .. versionadded:: 2016.11.0\n\n    setopt\n        A comma-separated or Python list of key=value options. This list will\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\n        that is run.\n\n        CLI Example:\n\n        .. code-block:: bash\n\n            salt '*' pkg.install foo setopt='obsoletes=0,plugins=0'\n\n        .. versionadded:: 2019.2.0\n\n    Repository Options:\n\n    fromrepo\n        Specify a package repository (or repositories) from which to install.\n        (e.g., ``yum --disablerepo='*' --enablerepo='somerepo'``)\n\n    enablerepo (ignored if ``fromrepo`` is specified)\n        Specify a disabled package repository (or repositories) to enable.\n        (e.g., ``yum --enablerepo='somerepo'``)\n\n    disablerepo (ignored if ``fromrepo`` is specified)\n        Specify an enabled package repository (or repositories) to disable.\n        (e.g., ``yum --disablerepo='somerepo'``)\n\n    disableexcludes\n        Disable exclude from main, for a repo or for everything.\n        (e.g., ``yum --disableexcludes='main'``)\n\n        .. versionadded:: 2014.7.0\n\n    ignore_epoch : False\n        Only used when the version of a package is specified using a comparison\n        operator (e.g. ``>4.1``). If set to ``True``, then the epoch will be\n        ignored when comparing the currently-installed version to the desired\n        version.\n\n        .. versionadded:: 2018.3.0\n\n\n    Multiple Package Installation Options:\n\n    pkgs\n        A list of packages to install from a software repository. Must be\n        passed as a python list. A specific version number can be specified\n        by using a single-element dict representing the package and its\n        version.\n\n        CLI Examples:\n\n        .. code-block:: bash\n\n            salt '*' pkg.install pkgs='[\"foo\", \"bar\"]'\n            salt '*' pkg.install pkgs='[\"foo\", {\"bar\": \"1.2.3-4.el5\"}]'\n\n    sources\n        A list of RPM packages to install. Must be passed as a list of dicts,\n        with the keys being package names, and the values being the source URI\n        or local path to the package.\n\n        CLI Example:\n\n        .. code-block:: bash\n\n            salt '*' pkg.install sources='[{\"foo\": \"salt://foo.rpm\"}, {\"bar\": \"salt://bar.rpm\"}]'\n\n    normalize : True\n        Normalize the package name by removing the architecture. This is useful\n        for poorly created packages which might include the architecture as an\n        actual part of the name such as kernel modules which match a specific\n        kernel version.\n\n        .. code-block:: bash\n\n            salt -G role:nsd pkg.install gpfs.gplbin-2.6.32-279.31.1.el6.x86_64 normalize=False\n\n        .. versionadded:: 2014.7.0\n\n    split_arch : True\n        If set to False it prevents package name normalization more strict way\n        than ``normalize`` set to ``False`` does.\n\n        .. versionadded:: 3006.0\n\n    diff_attr:\n        If a list of package attributes is specified, returned value will\n        contain them, eg.::\n\n            {'<package>': {\n                'old': {\n                    'version': '<old-version>',\n                    'arch': '<old-arch>'},\n\n                'new': {\n                    'version': '<new-version>',\n                    'arch': '<new-arch>'}}}\n\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\n        ``install_date``, ``install_date_time_t``.\n\n        If ``all`` is specified, all valid attributes will be returned.\n\n        .. versionadded:: 2018.3.0\n\n    Returns a dict containing the new package names and versions::\n\n        {'<package>': {'old': '<old-version>',\n                       'new': '<new-version>'}}\n\n    If an attribute list in diff_attr is specified, the dict will also contain\n    any specified attribute, eg.::\n\n        {'<package>': {\n            'old': {\n                'version': '<old-version>',\n                'arch': '<old-arch>'},\n\n            'new': {\n                'version': '<new-version>',\n                'arch': '<new-arch>'}}}\n    \"\"\"\n    if 'version' in kwargs:\n        kwargs['version'] = str(kwargs['version'])\n    options = _get_options(**kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(**kwargs)\n    reinstall = salt.utils.data.is_true(reinstall)\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, saltenv=saltenv, normalize=normalize and kwargs.get('split_arch', True), **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    diff_attr = kwargs.get('diff_attr')\n    old = list_pkgs(versions_as_list=False, attr=diff_attr) if not downloadonly else list_downloaded()\n    old_as_list = list_pkgs(versions_as_list=True) if not downloadonly else list_downloaded()\n    to_install = []\n    to_downgrade = []\n    to_reinstall = []\n    _available = {}\n    if pkg_type == 'repository':\n        has_wildcards = []\n        has_comparison = []\n        for (pkgname, pkgver) in pkg_params.items():\n            try:\n                if '*' in pkgver:\n                    has_wildcards.append(pkgname)\n                elif pkgver.startswith('<') or pkgver.startswith('>'):\n                    has_comparison.append(pkgname)\n            except (TypeError, ValueError):\n                continue\n        _available = AvailablePackages(*has_wildcards + has_comparison, byrepo=False, **kwargs)\n        pkg_params_items = pkg_params.items()\n    elif pkg_type == 'advisory':\n        pkg_params_items = []\n        cur_patches = list_patches()\n        for advisory_id in pkg_params:\n            if advisory_id not in cur_patches:\n                raise CommandExecutionError(f'Advisory id \"{advisory_id}\" not found')\n            else:\n                pkg_params_items.append(advisory_id)\n    else:\n        pkg_params_items = []\n        for pkg_source in pkg_params:\n            if 'lowpkg.bin_pkg_info' in __salt__:\n                rpm_info = __salt__['lowpkg.bin_pkg_info'](pkg_source)\n            else:\n                rpm_info = None\n            if rpm_info is None:\n                log.error('pkg.install: Unable to get rpm information for %s. Version comparisons will be unavailable, and return data may be inaccurate if reinstall=True.', pkg_source)\n                pkg_params_items.append([pkg_source])\n            else:\n                pkg_params_items.append([rpm_info['name'], pkg_source, rpm_info['version']])\n    errors = []\n    for pkg_item_list in pkg_params_items:\n        if pkg_type == 'repository':\n            (pkgname, version_num) = pkg_item_list\n        elif pkg_type == 'advisory':\n            pkgname = pkg_item_list\n            version_num = None\n        else:\n            try:\n                (pkgname, pkgpath, version_num) = pkg_item_list\n            except ValueError:\n                pkgname = None\n                pkgpath = pkg_item_list[0]\n                version_num = None\n        if version_num is None:\n            if pkg_type == 'repository':\n                if reinstall and pkgname in old:\n                    to_reinstall.append((pkgname, pkgname))\n                else:\n                    to_install.append((pkgname, pkgname))\n            elif pkg_type == 'advisory':\n                to_install.append((pkgname, pkgname))\n            else:\n                to_install.append((pkgname, pkgpath))\n        else:\n            if pkg_type == 'repository':\n                version_num = version_num.lstrip('=')\n                if pkgname in has_comparison:\n                    candidates = _available.get(pkgname, [])\n                    target = salt.utils.pkg.match_version(version_num, candidates, cmp_func=version_cmp, ignore_epoch=ignore_epoch)\n                    if target is None:\n                        errors.append(\"No version matching '{}{}' could be found (available: {})\".format(pkgname, version_num, ', '.join(candidates) if candidates else None))\n                        continue\n                    else:\n                        version_num = target\n                if _yum() == 'yum':\n                    if ignore_epoch is True:\n                        version_num = version_num.split(':', 1)[-1]\n                arch = ''\n                try:\n                    (namepart, archpart) = pkgname.rsplit('.', 1)\n                except ValueError:\n                    pass\n                else:\n                    if archpart in salt.utils.pkg.rpm.ARCHES and (archpart != __grains__['osarch'] or kwargs.get('split_arch', True)):\n                        arch = '.' + archpart\n                        pkgname = namepart\n                if '*' in version_num:\n                    candidates = _available.get(pkgname, [])\n                    match = salt.utils.itertools.fnmatch_multiple(candidates, version_num)\n                    if match is not None:\n                        version_num = match\n                    else:\n                        errors.append(\"No version matching '{}' found for package '{}' (available: {})\".format(version_num, pkgname, ', '.join(candidates) if candidates else 'none'))\n                        continue\n                if ignore_epoch is True:\n                    pkgstr = f'{pkgname}-{version_num}{arch}'\n                else:\n                    pkgstr = '{}-{}{}'.format(pkgname, version_num.split(':', 1)[-1], arch)\n            else:\n                pkgstr = pkgpath\n            cver = old_as_list.get(pkgname, [])\n            if reinstall and cver:\n                for ver in cver:\n                    if salt.utils.versions.compare(ver1=version_num, oper='==', ver2=ver, cmp_func=version_cmp, ignore_epoch=ignore_epoch):\n                        to_reinstall.append((pkgname, pkgstr))\n                        break\n            elif not cver:\n                to_install.append((pkgname, pkgstr))\n            else:\n                for ver in cver:\n                    if salt.utils.versions.compare(ver1=version_num, oper='>=', ver2=ver, cmp_func=version_cmp, ignore_epoch=ignore_epoch):\n                        to_install.append((pkgname, pkgstr))\n                        break\n                else:\n                    if pkgname is not None:\n                        if re.match('^kernel(|-devel)$', pkgname):\n                            to_install.append((pkgname, pkgstr))\n                        else:\n                            to_downgrade.append((pkgname, pkgstr))\n\n    def _add_common_args(cmd):\n        \"\"\"\n        DRY function to add args common to all yum/dnf commands\n        \"\"\"\n        cmd.extend(options)\n        if skip_verify:\n            cmd.append('--nogpgcheck')\n        if downloadonly:\n            if _yum() != 'dnf5':\n                cmd.append('--downloadonly')\n    try:\n        holds = list_holds(full=False)\n    except SaltInvocationError:\n        holds = []\n        log.debug('Failed to get holds, versionlock plugin is probably not installed')\n    unhold_prevented = []\n\n    @contextlib.contextmanager\n    def _temporarily_unhold(pkgs, targets):\n        \"\"\"\n        Temporarily unhold packages that need to be updated. Add any\n        successfully-removed ones (and any packages not in the list of current\n        holds) to the list of targets.\n        \"\"\"\n        to_unhold = {}\n        for (pkgname, pkgstr) in pkgs:\n            if pkgname in holds:\n                if update_holds:\n                    to_unhold[pkgname] = pkgstr\n                else:\n                    unhold_prevented.append(pkgname)\n            else:\n                targets.append(pkgstr)\n        if not to_unhold:\n            yield\n        else:\n            log.debug('Unholding packages: %s', ', '.join(to_unhold))\n            try:\n                unhold_names = list(to_unhold.keys())\n                for (unheld_pkg, outcome) in unhold(pkgs=unhold_names).items():\n                    if outcome['result']:\n                        targets.append(to_unhold[unheld_pkg])\n                    else:\n                        errors.append(unheld_pkg)\n                yield\n            except Exception as exc:\n                errors.append('Error encountered unholding packages {}: {}'.format(', '.join(to_unhold), exc))\n            finally:\n                hold(pkgs=unhold_names)\n    targets = []\n    with _temporarily_unhold(to_install, targets):\n        if targets:\n            if pkg_type == 'advisory':\n                targets = [f'--advisory={t}' for t in targets]\n            cmd = ['-y']\n            if _yum() == 'dnf':\n                cmd.extend(['--best', '--allowerasing'])\n            _add_common_args(cmd)\n            cmd.append('install' if pkg_type != 'advisory' else 'update')\n            if _yum() == 'dnf5':\n                cmd.extend(['--best', '--allowerasing'])\n            cmd.extend(targets)\n            out = _call_yum(cmd, ignore_retcode=False, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    targets = []\n    with _temporarily_unhold(to_downgrade, targets):\n        if targets:\n            cmd = ['-y']\n            _add_common_args(cmd)\n            cmd.append('downgrade')\n            cmd.extend(targets)\n            out = _call_yum(cmd, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    targets = []\n    with _temporarily_unhold(to_reinstall, targets):\n        if targets:\n            cmd = ['-y']\n            _add_common_args(cmd)\n            cmd.append('reinstall')\n            cmd.extend(targets)\n            out = _call_yum(cmd, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs(versions_as_list=False, attr=diff_attr) if not downloadonly else list_downloaded()\n    ret = salt.utils.data.compare_dicts(old, new)\n    for (pkgname, _) in to_reinstall:\n        if pkgname not in ret or pkgname in old:\n            ret.update({pkgname: {'old': old.get(pkgname, ''), 'new': new.get(pkgname, '')}})\n    if unhold_prevented:\n        errors.append(\"The following package(s) could not be updated because they are being held: {}. Set 'update_holds' to True to temporarily unhold these packages so that they can be updated.\".format(', '.join(unhold_prevented)))\n    if errors:\n        raise CommandExecutionError('Error occurred installing{} package(s)'.format('/reinstalling' if to_reinstall else ''), info={'errors': errors, 'changes': ret})\n    return ret",
        "mutated": [
            "def install(name=None, refresh=False, skip_verify=False, pkgs=None, sources=None, downloadonly=False, reinstall=False, normalize=True, update_holds=False, saltenv='base', ignore_epoch=False, **kwargs):\n    if False:\n        i = 10\n    '\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    Install the passed package(s), add refresh=True to clean the yum database\\n    before package is installed.\\n\\n    name\\n        The name of the package to be installed. Note that this parameter is\\n        ignored if either \"pkgs\" or \"sources\" is passed. Additionally, please\\n        note that this option can only be used to install packages from a\\n        software repository. To install a package file manually, use the\\n        \"sources\" option.\\n\\n        32-bit packages can be installed on 64-bit systems by appending the\\n        architecture designation (``.i686``, ``.i586``, etc.) to the end of the\\n        package name.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install <package name>\\n\\n    refresh\\n        Whether or not to update the yum database before executing.\\n\\n    reinstall\\n        Specifying reinstall=True will use ``yum reinstall`` rather than\\n        ``yum install`` for requested packages that are already installed.\\n\\n        If a version is specified with the requested package, then\\n        ``yum reinstall`` will only be used if the installed version\\n        matches the requested version.\\n\\n        Works with ``sources`` when the package header of the source can be\\n        matched to the name and version of an installed package.\\n\\n        .. versionadded:: 2014.7.0\\n\\n    skip_verify\\n        Skip the GPG verification check (e.g., ``--nogpgcheck``)\\n\\n    downloadonly\\n        Only download the packages, do not install.\\n\\n    version\\n        Install a specific version of the package, e.g. 1.2.3-4.el5. Ignored\\n        if \"pkgs\" or \"sources\" is passed.\\n\\n        .. versionchanged:: 2018.3.0\\n            version can now contain comparison operators (e.g. ``>1.2.3``,\\n            ``<=2.0``, etc.)\\n\\n    update_holds : False\\n        If ``True``, and this function would update the package version, any\\n        packages held using the yum/dnf \"versionlock\" plugin will be unheld so\\n        that they can be updated. Otherwise, if this function attempts to\\n        update a held package, the held package(s) will be skipped and an\\n        error will be raised.\\n\\n        .. versionadded:: 2016.11.0\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install foo setopt=\\'obsoletes=0,plugins=0\\'\\n\\n        .. versionadded:: 2019.2.0\\n\\n    Repository Options:\\n\\n    fromrepo\\n        Specify a package repository (or repositories) from which to install.\\n        (e.g., ``yum --disablerepo=\\'*\\' --enablerepo=\\'somerepo\\'``)\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo=\\'somerepo\\'``)\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo=\\'somerepo\\'``)\\n\\n    disableexcludes\\n        Disable exclude from main, for a repo or for everything.\\n        (e.g., ``yum --disableexcludes=\\'main\\'``)\\n\\n        .. versionadded:: 2014.7.0\\n\\n    ignore_epoch : False\\n        Only used when the version of a package is specified using a comparison\\n        operator (e.g. ``>4.1``). If set to ``True``, then the epoch will be\\n        ignored when comparing the currently-installed version to the desired\\n        version.\\n\\n        .. versionadded:: 2018.3.0\\n\\n\\n    Multiple Package Installation Options:\\n\\n    pkgs\\n        A list of packages to install from a software repository. Must be\\n        passed as a python list. A specific version number can be specified\\n        by using a single-element dict representing the package and its\\n        version.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install pkgs=\\'[\"foo\", \"bar\"]\\'\\n            salt \\'*\\' pkg.install pkgs=\\'[\"foo\", {\"bar\": \"1.2.3-4.el5\"}]\\'\\n\\n    sources\\n        A list of RPM packages to install. Must be passed as a list of dicts,\\n        with the keys being package names, and the values being the source URI\\n        or local path to the package.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install sources=\\'[{\"foo\": \"salt://foo.rpm\"}, {\"bar\": \"salt://bar.rpm\"}]\\'\\n\\n    normalize : True\\n        Normalize the package name by removing the architecture. This is useful\\n        for poorly created packages which might include the architecture as an\\n        actual part of the name such as kernel modules which match a specific\\n        kernel version.\\n\\n        .. code-block:: bash\\n\\n            salt -G role:nsd pkg.install gpfs.gplbin-2.6.32-279.31.1.el6.x86_64 normalize=False\\n\\n        .. versionadded:: 2014.7.0\\n\\n    split_arch : True\\n        If set to False it prevents package name normalization more strict way\\n        than ``normalize`` set to ``False`` does.\\n\\n        .. versionadded:: 3006.0\\n\\n    diff_attr:\\n        If a list of package attributes is specified, returned value will\\n        contain them, eg.::\\n\\n            {\\'<package>\\': {\\n                \\'old\\': {\\n                    \\'version\\': \\'<old-version>\\',\\n                    \\'arch\\': \\'<old-arch>\\'},\\n\\n                \\'new\\': {\\n                    \\'version\\': \\'<new-version>\\',\\n                    \\'arch\\': \\'<new-arch>\\'}}}\\n\\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\\n        ``install_date``, ``install_date_time_t``.\\n\\n        If ``all`` is specified, all valid attributes will be returned.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    Returns a dict containing the new package names and versions::\\n\\n        {\\'<package>\\': {\\'old\\': \\'<old-version>\\',\\n                       \\'new\\': \\'<new-version>\\'}}\\n\\n    If an attribute list in diff_attr is specified, the dict will also contain\\n    any specified attribute, eg.::\\n\\n        {\\'<package>\\': {\\n            \\'old\\': {\\n                \\'version\\': \\'<old-version>\\',\\n                \\'arch\\': \\'<old-arch>\\'},\\n\\n            \\'new\\': {\\n                \\'version\\': \\'<new-version>\\',\\n                \\'arch\\': \\'<new-arch>\\'}}}\\n    '\n    if 'version' in kwargs:\n        kwargs['version'] = str(kwargs['version'])\n    options = _get_options(**kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(**kwargs)\n    reinstall = salt.utils.data.is_true(reinstall)\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, saltenv=saltenv, normalize=normalize and kwargs.get('split_arch', True), **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    diff_attr = kwargs.get('diff_attr')\n    old = list_pkgs(versions_as_list=False, attr=diff_attr) if not downloadonly else list_downloaded()\n    old_as_list = list_pkgs(versions_as_list=True) if not downloadonly else list_downloaded()\n    to_install = []\n    to_downgrade = []\n    to_reinstall = []\n    _available = {}\n    if pkg_type == 'repository':\n        has_wildcards = []\n        has_comparison = []\n        for (pkgname, pkgver) in pkg_params.items():\n            try:\n                if '*' in pkgver:\n                    has_wildcards.append(pkgname)\n                elif pkgver.startswith('<') or pkgver.startswith('>'):\n                    has_comparison.append(pkgname)\n            except (TypeError, ValueError):\n                continue\n        _available = AvailablePackages(*has_wildcards + has_comparison, byrepo=False, **kwargs)\n        pkg_params_items = pkg_params.items()\n    elif pkg_type == 'advisory':\n        pkg_params_items = []\n        cur_patches = list_patches()\n        for advisory_id in pkg_params:\n            if advisory_id not in cur_patches:\n                raise CommandExecutionError(f'Advisory id \"{advisory_id}\" not found')\n            else:\n                pkg_params_items.append(advisory_id)\n    else:\n        pkg_params_items = []\n        for pkg_source in pkg_params:\n            if 'lowpkg.bin_pkg_info' in __salt__:\n                rpm_info = __salt__['lowpkg.bin_pkg_info'](pkg_source)\n            else:\n                rpm_info = None\n            if rpm_info is None:\n                log.error('pkg.install: Unable to get rpm information for %s. Version comparisons will be unavailable, and return data may be inaccurate if reinstall=True.', pkg_source)\n                pkg_params_items.append([pkg_source])\n            else:\n                pkg_params_items.append([rpm_info['name'], pkg_source, rpm_info['version']])\n    errors = []\n    for pkg_item_list in pkg_params_items:\n        if pkg_type == 'repository':\n            (pkgname, version_num) = pkg_item_list\n        elif pkg_type == 'advisory':\n            pkgname = pkg_item_list\n            version_num = None\n        else:\n            try:\n                (pkgname, pkgpath, version_num) = pkg_item_list\n            except ValueError:\n                pkgname = None\n                pkgpath = pkg_item_list[0]\n                version_num = None\n        if version_num is None:\n            if pkg_type == 'repository':\n                if reinstall and pkgname in old:\n                    to_reinstall.append((pkgname, pkgname))\n                else:\n                    to_install.append((pkgname, pkgname))\n            elif pkg_type == 'advisory':\n                to_install.append((pkgname, pkgname))\n            else:\n                to_install.append((pkgname, pkgpath))\n        else:\n            if pkg_type == 'repository':\n                version_num = version_num.lstrip('=')\n                if pkgname in has_comparison:\n                    candidates = _available.get(pkgname, [])\n                    target = salt.utils.pkg.match_version(version_num, candidates, cmp_func=version_cmp, ignore_epoch=ignore_epoch)\n                    if target is None:\n                        errors.append(\"No version matching '{}{}' could be found (available: {})\".format(pkgname, version_num, ', '.join(candidates) if candidates else None))\n                        continue\n                    else:\n                        version_num = target\n                if _yum() == 'yum':\n                    if ignore_epoch is True:\n                        version_num = version_num.split(':', 1)[-1]\n                arch = ''\n                try:\n                    (namepart, archpart) = pkgname.rsplit('.', 1)\n                except ValueError:\n                    pass\n                else:\n                    if archpart in salt.utils.pkg.rpm.ARCHES and (archpart != __grains__['osarch'] or kwargs.get('split_arch', True)):\n                        arch = '.' + archpart\n                        pkgname = namepart\n                if '*' in version_num:\n                    candidates = _available.get(pkgname, [])\n                    match = salt.utils.itertools.fnmatch_multiple(candidates, version_num)\n                    if match is not None:\n                        version_num = match\n                    else:\n                        errors.append(\"No version matching '{}' found for package '{}' (available: {})\".format(version_num, pkgname, ', '.join(candidates) if candidates else 'none'))\n                        continue\n                if ignore_epoch is True:\n                    pkgstr = f'{pkgname}-{version_num}{arch}'\n                else:\n                    pkgstr = '{}-{}{}'.format(pkgname, version_num.split(':', 1)[-1], arch)\n            else:\n                pkgstr = pkgpath\n            cver = old_as_list.get(pkgname, [])\n            if reinstall and cver:\n                for ver in cver:\n                    if salt.utils.versions.compare(ver1=version_num, oper='==', ver2=ver, cmp_func=version_cmp, ignore_epoch=ignore_epoch):\n                        to_reinstall.append((pkgname, pkgstr))\n                        break\n            elif not cver:\n                to_install.append((pkgname, pkgstr))\n            else:\n                for ver in cver:\n                    if salt.utils.versions.compare(ver1=version_num, oper='>=', ver2=ver, cmp_func=version_cmp, ignore_epoch=ignore_epoch):\n                        to_install.append((pkgname, pkgstr))\n                        break\n                else:\n                    if pkgname is not None:\n                        if re.match('^kernel(|-devel)$', pkgname):\n                            to_install.append((pkgname, pkgstr))\n                        else:\n                            to_downgrade.append((pkgname, pkgstr))\n\n    def _add_common_args(cmd):\n        \"\"\"\n        DRY function to add args common to all yum/dnf commands\n        \"\"\"\n        cmd.extend(options)\n        if skip_verify:\n            cmd.append('--nogpgcheck')\n        if downloadonly:\n            if _yum() != 'dnf5':\n                cmd.append('--downloadonly')\n    try:\n        holds = list_holds(full=False)\n    except SaltInvocationError:\n        holds = []\n        log.debug('Failed to get holds, versionlock plugin is probably not installed')\n    unhold_prevented = []\n\n    @contextlib.contextmanager\n    def _temporarily_unhold(pkgs, targets):\n        \"\"\"\n        Temporarily unhold packages that need to be updated. Add any\n        successfully-removed ones (and any packages not in the list of current\n        holds) to the list of targets.\n        \"\"\"\n        to_unhold = {}\n        for (pkgname, pkgstr) in pkgs:\n            if pkgname in holds:\n                if update_holds:\n                    to_unhold[pkgname] = pkgstr\n                else:\n                    unhold_prevented.append(pkgname)\n            else:\n                targets.append(pkgstr)\n        if not to_unhold:\n            yield\n        else:\n            log.debug('Unholding packages: %s', ', '.join(to_unhold))\n            try:\n                unhold_names = list(to_unhold.keys())\n                for (unheld_pkg, outcome) in unhold(pkgs=unhold_names).items():\n                    if outcome['result']:\n                        targets.append(to_unhold[unheld_pkg])\n                    else:\n                        errors.append(unheld_pkg)\n                yield\n            except Exception as exc:\n                errors.append('Error encountered unholding packages {}: {}'.format(', '.join(to_unhold), exc))\n            finally:\n                hold(pkgs=unhold_names)\n    targets = []\n    with _temporarily_unhold(to_install, targets):\n        if targets:\n            if pkg_type == 'advisory':\n                targets = [f'--advisory={t}' for t in targets]\n            cmd = ['-y']\n            if _yum() == 'dnf':\n                cmd.extend(['--best', '--allowerasing'])\n            _add_common_args(cmd)\n            cmd.append('install' if pkg_type != 'advisory' else 'update')\n            if _yum() == 'dnf5':\n                cmd.extend(['--best', '--allowerasing'])\n            cmd.extend(targets)\n            out = _call_yum(cmd, ignore_retcode=False, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    targets = []\n    with _temporarily_unhold(to_downgrade, targets):\n        if targets:\n            cmd = ['-y']\n            _add_common_args(cmd)\n            cmd.append('downgrade')\n            cmd.extend(targets)\n            out = _call_yum(cmd, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    targets = []\n    with _temporarily_unhold(to_reinstall, targets):\n        if targets:\n            cmd = ['-y']\n            _add_common_args(cmd)\n            cmd.append('reinstall')\n            cmd.extend(targets)\n            out = _call_yum(cmd, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs(versions_as_list=False, attr=diff_attr) if not downloadonly else list_downloaded()\n    ret = salt.utils.data.compare_dicts(old, new)\n    for (pkgname, _) in to_reinstall:\n        if pkgname not in ret or pkgname in old:\n            ret.update({pkgname: {'old': old.get(pkgname, ''), 'new': new.get(pkgname, '')}})\n    if unhold_prevented:\n        errors.append(\"The following package(s) could not be updated because they are being held: {}. Set 'update_holds' to True to temporarily unhold these packages so that they can be updated.\".format(', '.join(unhold_prevented)))\n    if errors:\n        raise CommandExecutionError('Error occurred installing{} package(s)'.format('/reinstalling' if to_reinstall else ''), info={'errors': errors, 'changes': ret})\n    return ret",
            "def install(name=None, refresh=False, skip_verify=False, pkgs=None, sources=None, downloadonly=False, reinstall=False, normalize=True, update_holds=False, saltenv='base', ignore_epoch=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    Install the passed package(s), add refresh=True to clean the yum database\\n    before package is installed.\\n\\n    name\\n        The name of the package to be installed. Note that this parameter is\\n        ignored if either \"pkgs\" or \"sources\" is passed. Additionally, please\\n        note that this option can only be used to install packages from a\\n        software repository. To install a package file manually, use the\\n        \"sources\" option.\\n\\n        32-bit packages can be installed on 64-bit systems by appending the\\n        architecture designation (``.i686``, ``.i586``, etc.) to the end of the\\n        package name.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install <package name>\\n\\n    refresh\\n        Whether or not to update the yum database before executing.\\n\\n    reinstall\\n        Specifying reinstall=True will use ``yum reinstall`` rather than\\n        ``yum install`` for requested packages that are already installed.\\n\\n        If a version is specified with the requested package, then\\n        ``yum reinstall`` will only be used if the installed version\\n        matches the requested version.\\n\\n        Works with ``sources`` when the package header of the source can be\\n        matched to the name and version of an installed package.\\n\\n        .. versionadded:: 2014.7.0\\n\\n    skip_verify\\n        Skip the GPG verification check (e.g., ``--nogpgcheck``)\\n\\n    downloadonly\\n        Only download the packages, do not install.\\n\\n    version\\n        Install a specific version of the package, e.g. 1.2.3-4.el5. Ignored\\n        if \"pkgs\" or \"sources\" is passed.\\n\\n        .. versionchanged:: 2018.3.0\\n            version can now contain comparison operators (e.g. ``>1.2.3``,\\n            ``<=2.0``, etc.)\\n\\n    update_holds : False\\n        If ``True``, and this function would update the package version, any\\n        packages held using the yum/dnf \"versionlock\" plugin will be unheld so\\n        that they can be updated. Otherwise, if this function attempts to\\n        update a held package, the held package(s) will be skipped and an\\n        error will be raised.\\n\\n        .. versionadded:: 2016.11.0\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install foo setopt=\\'obsoletes=0,plugins=0\\'\\n\\n        .. versionadded:: 2019.2.0\\n\\n    Repository Options:\\n\\n    fromrepo\\n        Specify a package repository (or repositories) from which to install.\\n        (e.g., ``yum --disablerepo=\\'*\\' --enablerepo=\\'somerepo\\'``)\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo=\\'somerepo\\'``)\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo=\\'somerepo\\'``)\\n\\n    disableexcludes\\n        Disable exclude from main, for a repo or for everything.\\n        (e.g., ``yum --disableexcludes=\\'main\\'``)\\n\\n        .. versionadded:: 2014.7.0\\n\\n    ignore_epoch : False\\n        Only used when the version of a package is specified using a comparison\\n        operator (e.g. ``>4.1``). If set to ``True``, then the epoch will be\\n        ignored when comparing the currently-installed version to the desired\\n        version.\\n\\n        .. versionadded:: 2018.3.0\\n\\n\\n    Multiple Package Installation Options:\\n\\n    pkgs\\n        A list of packages to install from a software repository. Must be\\n        passed as a python list. A specific version number can be specified\\n        by using a single-element dict representing the package and its\\n        version.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install pkgs=\\'[\"foo\", \"bar\"]\\'\\n            salt \\'*\\' pkg.install pkgs=\\'[\"foo\", {\"bar\": \"1.2.3-4.el5\"}]\\'\\n\\n    sources\\n        A list of RPM packages to install. Must be passed as a list of dicts,\\n        with the keys being package names, and the values being the source URI\\n        or local path to the package.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install sources=\\'[{\"foo\": \"salt://foo.rpm\"}, {\"bar\": \"salt://bar.rpm\"}]\\'\\n\\n    normalize : True\\n        Normalize the package name by removing the architecture. This is useful\\n        for poorly created packages which might include the architecture as an\\n        actual part of the name such as kernel modules which match a specific\\n        kernel version.\\n\\n        .. code-block:: bash\\n\\n            salt -G role:nsd pkg.install gpfs.gplbin-2.6.32-279.31.1.el6.x86_64 normalize=False\\n\\n        .. versionadded:: 2014.7.0\\n\\n    split_arch : True\\n        If set to False it prevents package name normalization more strict way\\n        than ``normalize`` set to ``False`` does.\\n\\n        .. versionadded:: 3006.0\\n\\n    diff_attr:\\n        If a list of package attributes is specified, returned value will\\n        contain them, eg.::\\n\\n            {\\'<package>\\': {\\n                \\'old\\': {\\n                    \\'version\\': \\'<old-version>\\',\\n                    \\'arch\\': \\'<old-arch>\\'},\\n\\n                \\'new\\': {\\n                    \\'version\\': \\'<new-version>\\',\\n                    \\'arch\\': \\'<new-arch>\\'}}}\\n\\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\\n        ``install_date``, ``install_date_time_t``.\\n\\n        If ``all`` is specified, all valid attributes will be returned.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    Returns a dict containing the new package names and versions::\\n\\n        {\\'<package>\\': {\\'old\\': \\'<old-version>\\',\\n                       \\'new\\': \\'<new-version>\\'}}\\n\\n    If an attribute list in diff_attr is specified, the dict will also contain\\n    any specified attribute, eg.::\\n\\n        {\\'<package>\\': {\\n            \\'old\\': {\\n                \\'version\\': \\'<old-version>\\',\\n                \\'arch\\': \\'<old-arch>\\'},\\n\\n            \\'new\\': {\\n                \\'version\\': \\'<new-version>\\',\\n                \\'arch\\': \\'<new-arch>\\'}}}\\n    '\n    if 'version' in kwargs:\n        kwargs['version'] = str(kwargs['version'])\n    options = _get_options(**kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(**kwargs)\n    reinstall = salt.utils.data.is_true(reinstall)\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, saltenv=saltenv, normalize=normalize and kwargs.get('split_arch', True), **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    diff_attr = kwargs.get('diff_attr')\n    old = list_pkgs(versions_as_list=False, attr=diff_attr) if not downloadonly else list_downloaded()\n    old_as_list = list_pkgs(versions_as_list=True) if not downloadonly else list_downloaded()\n    to_install = []\n    to_downgrade = []\n    to_reinstall = []\n    _available = {}\n    if pkg_type == 'repository':\n        has_wildcards = []\n        has_comparison = []\n        for (pkgname, pkgver) in pkg_params.items():\n            try:\n                if '*' in pkgver:\n                    has_wildcards.append(pkgname)\n                elif pkgver.startswith('<') or pkgver.startswith('>'):\n                    has_comparison.append(pkgname)\n            except (TypeError, ValueError):\n                continue\n        _available = AvailablePackages(*has_wildcards + has_comparison, byrepo=False, **kwargs)\n        pkg_params_items = pkg_params.items()\n    elif pkg_type == 'advisory':\n        pkg_params_items = []\n        cur_patches = list_patches()\n        for advisory_id in pkg_params:\n            if advisory_id not in cur_patches:\n                raise CommandExecutionError(f'Advisory id \"{advisory_id}\" not found')\n            else:\n                pkg_params_items.append(advisory_id)\n    else:\n        pkg_params_items = []\n        for pkg_source in pkg_params:\n            if 'lowpkg.bin_pkg_info' in __salt__:\n                rpm_info = __salt__['lowpkg.bin_pkg_info'](pkg_source)\n            else:\n                rpm_info = None\n            if rpm_info is None:\n                log.error('pkg.install: Unable to get rpm information for %s. Version comparisons will be unavailable, and return data may be inaccurate if reinstall=True.', pkg_source)\n                pkg_params_items.append([pkg_source])\n            else:\n                pkg_params_items.append([rpm_info['name'], pkg_source, rpm_info['version']])\n    errors = []\n    for pkg_item_list in pkg_params_items:\n        if pkg_type == 'repository':\n            (pkgname, version_num) = pkg_item_list\n        elif pkg_type == 'advisory':\n            pkgname = pkg_item_list\n            version_num = None\n        else:\n            try:\n                (pkgname, pkgpath, version_num) = pkg_item_list\n            except ValueError:\n                pkgname = None\n                pkgpath = pkg_item_list[0]\n                version_num = None\n        if version_num is None:\n            if pkg_type == 'repository':\n                if reinstall and pkgname in old:\n                    to_reinstall.append((pkgname, pkgname))\n                else:\n                    to_install.append((pkgname, pkgname))\n            elif pkg_type == 'advisory':\n                to_install.append((pkgname, pkgname))\n            else:\n                to_install.append((pkgname, pkgpath))\n        else:\n            if pkg_type == 'repository':\n                version_num = version_num.lstrip('=')\n                if pkgname in has_comparison:\n                    candidates = _available.get(pkgname, [])\n                    target = salt.utils.pkg.match_version(version_num, candidates, cmp_func=version_cmp, ignore_epoch=ignore_epoch)\n                    if target is None:\n                        errors.append(\"No version matching '{}{}' could be found (available: {})\".format(pkgname, version_num, ', '.join(candidates) if candidates else None))\n                        continue\n                    else:\n                        version_num = target\n                if _yum() == 'yum':\n                    if ignore_epoch is True:\n                        version_num = version_num.split(':', 1)[-1]\n                arch = ''\n                try:\n                    (namepart, archpart) = pkgname.rsplit('.', 1)\n                except ValueError:\n                    pass\n                else:\n                    if archpart in salt.utils.pkg.rpm.ARCHES and (archpart != __grains__['osarch'] or kwargs.get('split_arch', True)):\n                        arch = '.' + archpart\n                        pkgname = namepart\n                if '*' in version_num:\n                    candidates = _available.get(pkgname, [])\n                    match = salt.utils.itertools.fnmatch_multiple(candidates, version_num)\n                    if match is not None:\n                        version_num = match\n                    else:\n                        errors.append(\"No version matching '{}' found for package '{}' (available: {})\".format(version_num, pkgname, ', '.join(candidates) if candidates else 'none'))\n                        continue\n                if ignore_epoch is True:\n                    pkgstr = f'{pkgname}-{version_num}{arch}'\n                else:\n                    pkgstr = '{}-{}{}'.format(pkgname, version_num.split(':', 1)[-1], arch)\n            else:\n                pkgstr = pkgpath\n            cver = old_as_list.get(pkgname, [])\n            if reinstall and cver:\n                for ver in cver:\n                    if salt.utils.versions.compare(ver1=version_num, oper='==', ver2=ver, cmp_func=version_cmp, ignore_epoch=ignore_epoch):\n                        to_reinstall.append((pkgname, pkgstr))\n                        break\n            elif not cver:\n                to_install.append((pkgname, pkgstr))\n            else:\n                for ver in cver:\n                    if salt.utils.versions.compare(ver1=version_num, oper='>=', ver2=ver, cmp_func=version_cmp, ignore_epoch=ignore_epoch):\n                        to_install.append((pkgname, pkgstr))\n                        break\n                else:\n                    if pkgname is not None:\n                        if re.match('^kernel(|-devel)$', pkgname):\n                            to_install.append((pkgname, pkgstr))\n                        else:\n                            to_downgrade.append((pkgname, pkgstr))\n\n    def _add_common_args(cmd):\n        \"\"\"\n        DRY function to add args common to all yum/dnf commands\n        \"\"\"\n        cmd.extend(options)\n        if skip_verify:\n            cmd.append('--nogpgcheck')\n        if downloadonly:\n            if _yum() != 'dnf5':\n                cmd.append('--downloadonly')\n    try:\n        holds = list_holds(full=False)\n    except SaltInvocationError:\n        holds = []\n        log.debug('Failed to get holds, versionlock plugin is probably not installed')\n    unhold_prevented = []\n\n    @contextlib.contextmanager\n    def _temporarily_unhold(pkgs, targets):\n        \"\"\"\n        Temporarily unhold packages that need to be updated. Add any\n        successfully-removed ones (and any packages not in the list of current\n        holds) to the list of targets.\n        \"\"\"\n        to_unhold = {}\n        for (pkgname, pkgstr) in pkgs:\n            if pkgname in holds:\n                if update_holds:\n                    to_unhold[pkgname] = pkgstr\n                else:\n                    unhold_prevented.append(pkgname)\n            else:\n                targets.append(pkgstr)\n        if not to_unhold:\n            yield\n        else:\n            log.debug('Unholding packages: %s', ', '.join(to_unhold))\n            try:\n                unhold_names = list(to_unhold.keys())\n                for (unheld_pkg, outcome) in unhold(pkgs=unhold_names).items():\n                    if outcome['result']:\n                        targets.append(to_unhold[unheld_pkg])\n                    else:\n                        errors.append(unheld_pkg)\n                yield\n            except Exception as exc:\n                errors.append('Error encountered unholding packages {}: {}'.format(', '.join(to_unhold), exc))\n            finally:\n                hold(pkgs=unhold_names)\n    targets = []\n    with _temporarily_unhold(to_install, targets):\n        if targets:\n            if pkg_type == 'advisory':\n                targets = [f'--advisory={t}' for t in targets]\n            cmd = ['-y']\n            if _yum() == 'dnf':\n                cmd.extend(['--best', '--allowerasing'])\n            _add_common_args(cmd)\n            cmd.append('install' if pkg_type != 'advisory' else 'update')\n            if _yum() == 'dnf5':\n                cmd.extend(['--best', '--allowerasing'])\n            cmd.extend(targets)\n            out = _call_yum(cmd, ignore_retcode=False, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    targets = []\n    with _temporarily_unhold(to_downgrade, targets):\n        if targets:\n            cmd = ['-y']\n            _add_common_args(cmd)\n            cmd.append('downgrade')\n            cmd.extend(targets)\n            out = _call_yum(cmd, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    targets = []\n    with _temporarily_unhold(to_reinstall, targets):\n        if targets:\n            cmd = ['-y']\n            _add_common_args(cmd)\n            cmd.append('reinstall')\n            cmd.extend(targets)\n            out = _call_yum(cmd, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs(versions_as_list=False, attr=diff_attr) if not downloadonly else list_downloaded()\n    ret = salt.utils.data.compare_dicts(old, new)\n    for (pkgname, _) in to_reinstall:\n        if pkgname not in ret or pkgname in old:\n            ret.update({pkgname: {'old': old.get(pkgname, ''), 'new': new.get(pkgname, '')}})\n    if unhold_prevented:\n        errors.append(\"The following package(s) could not be updated because they are being held: {}. Set 'update_holds' to True to temporarily unhold these packages so that they can be updated.\".format(', '.join(unhold_prevented)))\n    if errors:\n        raise CommandExecutionError('Error occurred installing{} package(s)'.format('/reinstalling' if to_reinstall else ''), info={'errors': errors, 'changes': ret})\n    return ret",
            "def install(name=None, refresh=False, skip_verify=False, pkgs=None, sources=None, downloadonly=False, reinstall=False, normalize=True, update_holds=False, saltenv='base', ignore_epoch=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    Install the passed package(s), add refresh=True to clean the yum database\\n    before package is installed.\\n\\n    name\\n        The name of the package to be installed. Note that this parameter is\\n        ignored if either \"pkgs\" or \"sources\" is passed. Additionally, please\\n        note that this option can only be used to install packages from a\\n        software repository. To install a package file manually, use the\\n        \"sources\" option.\\n\\n        32-bit packages can be installed on 64-bit systems by appending the\\n        architecture designation (``.i686``, ``.i586``, etc.) to the end of the\\n        package name.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install <package name>\\n\\n    refresh\\n        Whether or not to update the yum database before executing.\\n\\n    reinstall\\n        Specifying reinstall=True will use ``yum reinstall`` rather than\\n        ``yum install`` for requested packages that are already installed.\\n\\n        If a version is specified with the requested package, then\\n        ``yum reinstall`` will only be used if the installed version\\n        matches the requested version.\\n\\n        Works with ``sources`` when the package header of the source can be\\n        matched to the name and version of an installed package.\\n\\n        .. versionadded:: 2014.7.0\\n\\n    skip_verify\\n        Skip the GPG verification check (e.g., ``--nogpgcheck``)\\n\\n    downloadonly\\n        Only download the packages, do not install.\\n\\n    version\\n        Install a specific version of the package, e.g. 1.2.3-4.el5. Ignored\\n        if \"pkgs\" or \"sources\" is passed.\\n\\n        .. versionchanged:: 2018.3.0\\n            version can now contain comparison operators (e.g. ``>1.2.3``,\\n            ``<=2.0``, etc.)\\n\\n    update_holds : False\\n        If ``True``, and this function would update the package version, any\\n        packages held using the yum/dnf \"versionlock\" plugin will be unheld so\\n        that they can be updated. Otherwise, if this function attempts to\\n        update a held package, the held package(s) will be skipped and an\\n        error will be raised.\\n\\n        .. versionadded:: 2016.11.0\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install foo setopt=\\'obsoletes=0,plugins=0\\'\\n\\n        .. versionadded:: 2019.2.0\\n\\n    Repository Options:\\n\\n    fromrepo\\n        Specify a package repository (or repositories) from which to install.\\n        (e.g., ``yum --disablerepo=\\'*\\' --enablerepo=\\'somerepo\\'``)\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo=\\'somerepo\\'``)\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo=\\'somerepo\\'``)\\n\\n    disableexcludes\\n        Disable exclude from main, for a repo or for everything.\\n        (e.g., ``yum --disableexcludes=\\'main\\'``)\\n\\n        .. versionadded:: 2014.7.0\\n\\n    ignore_epoch : False\\n        Only used when the version of a package is specified using a comparison\\n        operator (e.g. ``>4.1``). If set to ``True``, then the epoch will be\\n        ignored when comparing the currently-installed version to the desired\\n        version.\\n\\n        .. versionadded:: 2018.3.0\\n\\n\\n    Multiple Package Installation Options:\\n\\n    pkgs\\n        A list of packages to install from a software repository. Must be\\n        passed as a python list. A specific version number can be specified\\n        by using a single-element dict representing the package and its\\n        version.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install pkgs=\\'[\"foo\", \"bar\"]\\'\\n            salt \\'*\\' pkg.install pkgs=\\'[\"foo\", {\"bar\": \"1.2.3-4.el5\"}]\\'\\n\\n    sources\\n        A list of RPM packages to install. Must be passed as a list of dicts,\\n        with the keys being package names, and the values being the source URI\\n        or local path to the package.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install sources=\\'[{\"foo\": \"salt://foo.rpm\"}, {\"bar\": \"salt://bar.rpm\"}]\\'\\n\\n    normalize : True\\n        Normalize the package name by removing the architecture. This is useful\\n        for poorly created packages which might include the architecture as an\\n        actual part of the name such as kernel modules which match a specific\\n        kernel version.\\n\\n        .. code-block:: bash\\n\\n            salt -G role:nsd pkg.install gpfs.gplbin-2.6.32-279.31.1.el6.x86_64 normalize=False\\n\\n        .. versionadded:: 2014.7.0\\n\\n    split_arch : True\\n        If set to False it prevents package name normalization more strict way\\n        than ``normalize`` set to ``False`` does.\\n\\n        .. versionadded:: 3006.0\\n\\n    diff_attr:\\n        If a list of package attributes is specified, returned value will\\n        contain them, eg.::\\n\\n            {\\'<package>\\': {\\n                \\'old\\': {\\n                    \\'version\\': \\'<old-version>\\',\\n                    \\'arch\\': \\'<old-arch>\\'},\\n\\n                \\'new\\': {\\n                    \\'version\\': \\'<new-version>\\',\\n                    \\'arch\\': \\'<new-arch>\\'}}}\\n\\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\\n        ``install_date``, ``install_date_time_t``.\\n\\n        If ``all`` is specified, all valid attributes will be returned.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    Returns a dict containing the new package names and versions::\\n\\n        {\\'<package>\\': {\\'old\\': \\'<old-version>\\',\\n                       \\'new\\': \\'<new-version>\\'}}\\n\\n    If an attribute list in diff_attr is specified, the dict will also contain\\n    any specified attribute, eg.::\\n\\n        {\\'<package>\\': {\\n            \\'old\\': {\\n                \\'version\\': \\'<old-version>\\',\\n                \\'arch\\': \\'<old-arch>\\'},\\n\\n            \\'new\\': {\\n                \\'version\\': \\'<new-version>\\',\\n                \\'arch\\': \\'<new-arch>\\'}}}\\n    '\n    if 'version' in kwargs:\n        kwargs['version'] = str(kwargs['version'])\n    options = _get_options(**kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(**kwargs)\n    reinstall = salt.utils.data.is_true(reinstall)\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, saltenv=saltenv, normalize=normalize and kwargs.get('split_arch', True), **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    diff_attr = kwargs.get('diff_attr')\n    old = list_pkgs(versions_as_list=False, attr=diff_attr) if not downloadonly else list_downloaded()\n    old_as_list = list_pkgs(versions_as_list=True) if not downloadonly else list_downloaded()\n    to_install = []\n    to_downgrade = []\n    to_reinstall = []\n    _available = {}\n    if pkg_type == 'repository':\n        has_wildcards = []\n        has_comparison = []\n        for (pkgname, pkgver) in pkg_params.items():\n            try:\n                if '*' in pkgver:\n                    has_wildcards.append(pkgname)\n                elif pkgver.startswith('<') or pkgver.startswith('>'):\n                    has_comparison.append(pkgname)\n            except (TypeError, ValueError):\n                continue\n        _available = AvailablePackages(*has_wildcards + has_comparison, byrepo=False, **kwargs)\n        pkg_params_items = pkg_params.items()\n    elif pkg_type == 'advisory':\n        pkg_params_items = []\n        cur_patches = list_patches()\n        for advisory_id in pkg_params:\n            if advisory_id not in cur_patches:\n                raise CommandExecutionError(f'Advisory id \"{advisory_id}\" not found')\n            else:\n                pkg_params_items.append(advisory_id)\n    else:\n        pkg_params_items = []\n        for pkg_source in pkg_params:\n            if 'lowpkg.bin_pkg_info' in __salt__:\n                rpm_info = __salt__['lowpkg.bin_pkg_info'](pkg_source)\n            else:\n                rpm_info = None\n            if rpm_info is None:\n                log.error('pkg.install: Unable to get rpm information for %s. Version comparisons will be unavailable, and return data may be inaccurate if reinstall=True.', pkg_source)\n                pkg_params_items.append([pkg_source])\n            else:\n                pkg_params_items.append([rpm_info['name'], pkg_source, rpm_info['version']])\n    errors = []\n    for pkg_item_list in pkg_params_items:\n        if pkg_type == 'repository':\n            (pkgname, version_num) = pkg_item_list\n        elif pkg_type == 'advisory':\n            pkgname = pkg_item_list\n            version_num = None\n        else:\n            try:\n                (pkgname, pkgpath, version_num) = pkg_item_list\n            except ValueError:\n                pkgname = None\n                pkgpath = pkg_item_list[0]\n                version_num = None\n        if version_num is None:\n            if pkg_type == 'repository':\n                if reinstall and pkgname in old:\n                    to_reinstall.append((pkgname, pkgname))\n                else:\n                    to_install.append((pkgname, pkgname))\n            elif pkg_type == 'advisory':\n                to_install.append((pkgname, pkgname))\n            else:\n                to_install.append((pkgname, pkgpath))\n        else:\n            if pkg_type == 'repository':\n                version_num = version_num.lstrip('=')\n                if pkgname in has_comparison:\n                    candidates = _available.get(pkgname, [])\n                    target = salt.utils.pkg.match_version(version_num, candidates, cmp_func=version_cmp, ignore_epoch=ignore_epoch)\n                    if target is None:\n                        errors.append(\"No version matching '{}{}' could be found (available: {})\".format(pkgname, version_num, ', '.join(candidates) if candidates else None))\n                        continue\n                    else:\n                        version_num = target\n                if _yum() == 'yum':\n                    if ignore_epoch is True:\n                        version_num = version_num.split(':', 1)[-1]\n                arch = ''\n                try:\n                    (namepart, archpart) = pkgname.rsplit('.', 1)\n                except ValueError:\n                    pass\n                else:\n                    if archpart in salt.utils.pkg.rpm.ARCHES and (archpart != __grains__['osarch'] or kwargs.get('split_arch', True)):\n                        arch = '.' + archpart\n                        pkgname = namepart\n                if '*' in version_num:\n                    candidates = _available.get(pkgname, [])\n                    match = salt.utils.itertools.fnmatch_multiple(candidates, version_num)\n                    if match is not None:\n                        version_num = match\n                    else:\n                        errors.append(\"No version matching '{}' found for package '{}' (available: {})\".format(version_num, pkgname, ', '.join(candidates) if candidates else 'none'))\n                        continue\n                if ignore_epoch is True:\n                    pkgstr = f'{pkgname}-{version_num}{arch}'\n                else:\n                    pkgstr = '{}-{}{}'.format(pkgname, version_num.split(':', 1)[-1], arch)\n            else:\n                pkgstr = pkgpath\n            cver = old_as_list.get(pkgname, [])\n            if reinstall and cver:\n                for ver in cver:\n                    if salt.utils.versions.compare(ver1=version_num, oper='==', ver2=ver, cmp_func=version_cmp, ignore_epoch=ignore_epoch):\n                        to_reinstall.append((pkgname, pkgstr))\n                        break\n            elif not cver:\n                to_install.append((pkgname, pkgstr))\n            else:\n                for ver in cver:\n                    if salt.utils.versions.compare(ver1=version_num, oper='>=', ver2=ver, cmp_func=version_cmp, ignore_epoch=ignore_epoch):\n                        to_install.append((pkgname, pkgstr))\n                        break\n                else:\n                    if pkgname is not None:\n                        if re.match('^kernel(|-devel)$', pkgname):\n                            to_install.append((pkgname, pkgstr))\n                        else:\n                            to_downgrade.append((pkgname, pkgstr))\n\n    def _add_common_args(cmd):\n        \"\"\"\n        DRY function to add args common to all yum/dnf commands\n        \"\"\"\n        cmd.extend(options)\n        if skip_verify:\n            cmd.append('--nogpgcheck')\n        if downloadonly:\n            if _yum() != 'dnf5':\n                cmd.append('--downloadonly')\n    try:\n        holds = list_holds(full=False)\n    except SaltInvocationError:\n        holds = []\n        log.debug('Failed to get holds, versionlock plugin is probably not installed')\n    unhold_prevented = []\n\n    @contextlib.contextmanager\n    def _temporarily_unhold(pkgs, targets):\n        \"\"\"\n        Temporarily unhold packages that need to be updated. Add any\n        successfully-removed ones (and any packages not in the list of current\n        holds) to the list of targets.\n        \"\"\"\n        to_unhold = {}\n        for (pkgname, pkgstr) in pkgs:\n            if pkgname in holds:\n                if update_holds:\n                    to_unhold[pkgname] = pkgstr\n                else:\n                    unhold_prevented.append(pkgname)\n            else:\n                targets.append(pkgstr)\n        if not to_unhold:\n            yield\n        else:\n            log.debug('Unholding packages: %s', ', '.join(to_unhold))\n            try:\n                unhold_names = list(to_unhold.keys())\n                for (unheld_pkg, outcome) in unhold(pkgs=unhold_names).items():\n                    if outcome['result']:\n                        targets.append(to_unhold[unheld_pkg])\n                    else:\n                        errors.append(unheld_pkg)\n                yield\n            except Exception as exc:\n                errors.append('Error encountered unholding packages {}: {}'.format(', '.join(to_unhold), exc))\n            finally:\n                hold(pkgs=unhold_names)\n    targets = []\n    with _temporarily_unhold(to_install, targets):\n        if targets:\n            if pkg_type == 'advisory':\n                targets = [f'--advisory={t}' for t in targets]\n            cmd = ['-y']\n            if _yum() == 'dnf':\n                cmd.extend(['--best', '--allowerasing'])\n            _add_common_args(cmd)\n            cmd.append('install' if pkg_type != 'advisory' else 'update')\n            if _yum() == 'dnf5':\n                cmd.extend(['--best', '--allowerasing'])\n            cmd.extend(targets)\n            out = _call_yum(cmd, ignore_retcode=False, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    targets = []\n    with _temporarily_unhold(to_downgrade, targets):\n        if targets:\n            cmd = ['-y']\n            _add_common_args(cmd)\n            cmd.append('downgrade')\n            cmd.extend(targets)\n            out = _call_yum(cmd, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    targets = []\n    with _temporarily_unhold(to_reinstall, targets):\n        if targets:\n            cmd = ['-y']\n            _add_common_args(cmd)\n            cmd.append('reinstall')\n            cmd.extend(targets)\n            out = _call_yum(cmd, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs(versions_as_list=False, attr=diff_attr) if not downloadonly else list_downloaded()\n    ret = salt.utils.data.compare_dicts(old, new)\n    for (pkgname, _) in to_reinstall:\n        if pkgname not in ret or pkgname in old:\n            ret.update({pkgname: {'old': old.get(pkgname, ''), 'new': new.get(pkgname, '')}})\n    if unhold_prevented:\n        errors.append(\"The following package(s) could not be updated because they are being held: {}. Set 'update_holds' to True to temporarily unhold these packages so that they can be updated.\".format(', '.join(unhold_prevented)))\n    if errors:\n        raise CommandExecutionError('Error occurred installing{} package(s)'.format('/reinstalling' if to_reinstall else ''), info={'errors': errors, 'changes': ret})\n    return ret",
            "def install(name=None, refresh=False, skip_verify=False, pkgs=None, sources=None, downloadonly=False, reinstall=False, normalize=True, update_holds=False, saltenv='base', ignore_epoch=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    Install the passed package(s), add refresh=True to clean the yum database\\n    before package is installed.\\n\\n    name\\n        The name of the package to be installed. Note that this parameter is\\n        ignored if either \"pkgs\" or \"sources\" is passed. Additionally, please\\n        note that this option can only be used to install packages from a\\n        software repository. To install a package file manually, use the\\n        \"sources\" option.\\n\\n        32-bit packages can be installed on 64-bit systems by appending the\\n        architecture designation (``.i686``, ``.i586``, etc.) to the end of the\\n        package name.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install <package name>\\n\\n    refresh\\n        Whether or not to update the yum database before executing.\\n\\n    reinstall\\n        Specifying reinstall=True will use ``yum reinstall`` rather than\\n        ``yum install`` for requested packages that are already installed.\\n\\n        If a version is specified with the requested package, then\\n        ``yum reinstall`` will only be used if the installed version\\n        matches the requested version.\\n\\n        Works with ``sources`` when the package header of the source can be\\n        matched to the name and version of an installed package.\\n\\n        .. versionadded:: 2014.7.0\\n\\n    skip_verify\\n        Skip the GPG verification check (e.g., ``--nogpgcheck``)\\n\\n    downloadonly\\n        Only download the packages, do not install.\\n\\n    version\\n        Install a specific version of the package, e.g. 1.2.3-4.el5. Ignored\\n        if \"pkgs\" or \"sources\" is passed.\\n\\n        .. versionchanged:: 2018.3.0\\n            version can now contain comparison operators (e.g. ``>1.2.3``,\\n            ``<=2.0``, etc.)\\n\\n    update_holds : False\\n        If ``True``, and this function would update the package version, any\\n        packages held using the yum/dnf \"versionlock\" plugin will be unheld so\\n        that they can be updated. Otherwise, if this function attempts to\\n        update a held package, the held package(s) will be skipped and an\\n        error will be raised.\\n\\n        .. versionadded:: 2016.11.0\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install foo setopt=\\'obsoletes=0,plugins=0\\'\\n\\n        .. versionadded:: 2019.2.0\\n\\n    Repository Options:\\n\\n    fromrepo\\n        Specify a package repository (or repositories) from which to install.\\n        (e.g., ``yum --disablerepo=\\'*\\' --enablerepo=\\'somerepo\\'``)\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo=\\'somerepo\\'``)\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo=\\'somerepo\\'``)\\n\\n    disableexcludes\\n        Disable exclude from main, for a repo or for everything.\\n        (e.g., ``yum --disableexcludes=\\'main\\'``)\\n\\n        .. versionadded:: 2014.7.0\\n\\n    ignore_epoch : False\\n        Only used when the version of a package is specified using a comparison\\n        operator (e.g. ``>4.1``). If set to ``True``, then the epoch will be\\n        ignored when comparing the currently-installed version to the desired\\n        version.\\n\\n        .. versionadded:: 2018.3.0\\n\\n\\n    Multiple Package Installation Options:\\n\\n    pkgs\\n        A list of packages to install from a software repository. Must be\\n        passed as a python list. A specific version number can be specified\\n        by using a single-element dict representing the package and its\\n        version.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install pkgs=\\'[\"foo\", \"bar\"]\\'\\n            salt \\'*\\' pkg.install pkgs=\\'[\"foo\", {\"bar\": \"1.2.3-4.el5\"}]\\'\\n\\n    sources\\n        A list of RPM packages to install. Must be passed as a list of dicts,\\n        with the keys being package names, and the values being the source URI\\n        or local path to the package.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install sources=\\'[{\"foo\": \"salt://foo.rpm\"}, {\"bar\": \"salt://bar.rpm\"}]\\'\\n\\n    normalize : True\\n        Normalize the package name by removing the architecture. This is useful\\n        for poorly created packages which might include the architecture as an\\n        actual part of the name such as kernel modules which match a specific\\n        kernel version.\\n\\n        .. code-block:: bash\\n\\n            salt -G role:nsd pkg.install gpfs.gplbin-2.6.32-279.31.1.el6.x86_64 normalize=False\\n\\n        .. versionadded:: 2014.7.0\\n\\n    split_arch : True\\n        If set to False it prevents package name normalization more strict way\\n        than ``normalize`` set to ``False`` does.\\n\\n        .. versionadded:: 3006.0\\n\\n    diff_attr:\\n        If a list of package attributes is specified, returned value will\\n        contain them, eg.::\\n\\n            {\\'<package>\\': {\\n                \\'old\\': {\\n                    \\'version\\': \\'<old-version>\\',\\n                    \\'arch\\': \\'<old-arch>\\'},\\n\\n                \\'new\\': {\\n                    \\'version\\': \\'<new-version>\\',\\n                    \\'arch\\': \\'<new-arch>\\'}}}\\n\\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\\n        ``install_date``, ``install_date_time_t``.\\n\\n        If ``all`` is specified, all valid attributes will be returned.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    Returns a dict containing the new package names and versions::\\n\\n        {\\'<package>\\': {\\'old\\': \\'<old-version>\\',\\n                       \\'new\\': \\'<new-version>\\'}}\\n\\n    If an attribute list in diff_attr is specified, the dict will also contain\\n    any specified attribute, eg.::\\n\\n        {\\'<package>\\': {\\n            \\'old\\': {\\n                \\'version\\': \\'<old-version>\\',\\n                \\'arch\\': \\'<old-arch>\\'},\\n\\n            \\'new\\': {\\n                \\'version\\': \\'<new-version>\\',\\n                \\'arch\\': \\'<new-arch>\\'}}}\\n    '\n    if 'version' in kwargs:\n        kwargs['version'] = str(kwargs['version'])\n    options = _get_options(**kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(**kwargs)\n    reinstall = salt.utils.data.is_true(reinstall)\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, saltenv=saltenv, normalize=normalize and kwargs.get('split_arch', True), **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    diff_attr = kwargs.get('diff_attr')\n    old = list_pkgs(versions_as_list=False, attr=diff_attr) if not downloadonly else list_downloaded()\n    old_as_list = list_pkgs(versions_as_list=True) if not downloadonly else list_downloaded()\n    to_install = []\n    to_downgrade = []\n    to_reinstall = []\n    _available = {}\n    if pkg_type == 'repository':\n        has_wildcards = []\n        has_comparison = []\n        for (pkgname, pkgver) in pkg_params.items():\n            try:\n                if '*' in pkgver:\n                    has_wildcards.append(pkgname)\n                elif pkgver.startswith('<') or pkgver.startswith('>'):\n                    has_comparison.append(pkgname)\n            except (TypeError, ValueError):\n                continue\n        _available = AvailablePackages(*has_wildcards + has_comparison, byrepo=False, **kwargs)\n        pkg_params_items = pkg_params.items()\n    elif pkg_type == 'advisory':\n        pkg_params_items = []\n        cur_patches = list_patches()\n        for advisory_id in pkg_params:\n            if advisory_id not in cur_patches:\n                raise CommandExecutionError(f'Advisory id \"{advisory_id}\" not found')\n            else:\n                pkg_params_items.append(advisory_id)\n    else:\n        pkg_params_items = []\n        for pkg_source in pkg_params:\n            if 'lowpkg.bin_pkg_info' in __salt__:\n                rpm_info = __salt__['lowpkg.bin_pkg_info'](pkg_source)\n            else:\n                rpm_info = None\n            if rpm_info is None:\n                log.error('pkg.install: Unable to get rpm information for %s. Version comparisons will be unavailable, and return data may be inaccurate if reinstall=True.', pkg_source)\n                pkg_params_items.append([pkg_source])\n            else:\n                pkg_params_items.append([rpm_info['name'], pkg_source, rpm_info['version']])\n    errors = []\n    for pkg_item_list in pkg_params_items:\n        if pkg_type == 'repository':\n            (pkgname, version_num) = pkg_item_list\n        elif pkg_type == 'advisory':\n            pkgname = pkg_item_list\n            version_num = None\n        else:\n            try:\n                (pkgname, pkgpath, version_num) = pkg_item_list\n            except ValueError:\n                pkgname = None\n                pkgpath = pkg_item_list[0]\n                version_num = None\n        if version_num is None:\n            if pkg_type == 'repository':\n                if reinstall and pkgname in old:\n                    to_reinstall.append((pkgname, pkgname))\n                else:\n                    to_install.append((pkgname, pkgname))\n            elif pkg_type == 'advisory':\n                to_install.append((pkgname, pkgname))\n            else:\n                to_install.append((pkgname, pkgpath))\n        else:\n            if pkg_type == 'repository':\n                version_num = version_num.lstrip('=')\n                if pkgname in has_comparison:\n                    candidates = _available.get(pkgname, [])\n                    target = salt.utils.pkg.match_version(version_num, candidates, cmp_func=version_cmp, ignore_epoch=ignore_epoch)\n                    if target is None:\n                        errors.append(\"No version matching '{}{}' could be found (available: {})\".format(pkgname, version_num, ', '.join(candidates) if candidates else None))\n                        continue\n                    else:\n                        version_num = target\n                if _yum() == 'yum':\n                    if ignore_epoch is True:\n                        version_num = version_num.split(':', 1)[-1]\n                arch = ''\n                try:\n                    (namepart, archpart) = pkgname.rsplit('.', 1)\n                except ValueError:\n                    pass\n                else:\n                    if archpart in salt.utils.pkg.rpm.ARCHES and (archpart != __grains__['osarch'] or kwargs.get('split_arch', True)):\n                        arch = '.' + archpart\n                        pkgname = namepart\n                if '*' in version_num:\n                    candidates = _available.get(pkgname, [])\n                    match = salt.utils.itertools.fnmatch_multiple(candidates, version_num)\n                    if match is not None:\n                        version_num = match\n                    else:\n                        errors.append(\"No version matching '{}' found for package '{}' (available: {})\".format(version_num, pkgname, ', '.join(candidates) if candidates else 'none'))\n                        continue\n                if ignore_epoch is True:\n                    pkgstr = f'{pkgname}-{version_num}{arch}'\n                else:\n                    pkgstr = '{}-{}{}'.format(pkgname, version_num.split(':', 1)[-1], arch)\n            else:\n                pkgstr = pkgpath\n            cver = old_as_list.get(pkgname, [])\n            if reinstall and cver:\n                for ver in cver:\n                    if salt.utils.versions.compare(ver1=version_num, oper='==', ver2=ver, cmp_func=version_cmp, ignore_epoch=ignore_epoch):\n                        to_reinstall.append((pkgname, pkgstr))\n                        break\n            elif not cver:\n                to_install.append((pkgname, pkgstr))\n            else:\n                for ver in cver:\n                    if salt.utils.versions.compare(ver1=version_num, oper='>=', ver2=ver, cmp_func=version_cmp, ignore_epoch=ignore_epoch):\n                        to_install.append((pkgname, pkgstr))\n                        break\n                else:\n                    if pkgname is not None:\n                        if re.match('^kernel(|-devel)$', pkgname):\n                            to_install.append((pkgname, pkgstr))\n                        else:\n                            to_downgrade.append((pkgname, pkgstr))\n\n    def _add_common_args(cmd):\n        \"\"\"\n        DRY function to add args common to all yum/dnf commands\n        \"\"\"\n        cmd.extend(options)\n        if skip_verify:\n            cmd.append('--nogpgcheck')\n        if downloadonly:\n            if _yum() != 'dnf5':\n                cmd.append('--downloadonly')\n    try:\n        holds = list_holds(full=False)\n    except SaltInvocationError:\n        holds = []\n        log.debug('Failed to get holds, versionlock plugin is probably not installed')\n    unhold_prevented = []\n\n    @contextlib.contextmanager\n    def _temporarily_unhold(pkgs, targets):\n        \"\"\"\n        Temporarily unhold packages that need to be updated. Add any\n        successfully-removed ones (and any packages not in the list of current\n        holds) to the list of targets.\n        \"\"\"\n        to_unhold = {}\n        for (pkgname, pkgstr) in pkgs:\n            if pkgname in holds:\n                if update_holds:\n                    to_unhold[pkgname] = pkgstr\n                else:\n                    unhold_prevented.append(pkgname)\n            else:\n                targets.append(pkgstr)\n        if not to_unhold:\n            yield\n        else:\n            log.debug('Unholding packages: %s', ', '.join(to_unhold))\n            try:\n                unhold_names = list(to_unhold.keys())\n                for (unheld_pkg, outcome) in unhold(pkgs=unhold_names).items():\n                    if outcome['result']:\n                        targets.append(to_unhold[unheld_pkg])\n                    else:\n                        errors.append(unheld_pkg)\n                yield\n            except Exception as exc:\n                errors.append('Error encountered unholding packages {}: {}'.format(', '.join(to_unhold), exc))\n            finally:\n                hold(pkgs=unhold_names)\n    targets = []\n    with _temporarily_unhold(to_install, targets):\n        if targets:\n            if pkg_type == 'advisory':\n                targets = [f'--advisory={t}' for t in targets]\n            cmd = ['-y']\n            if _yum() == 'dnf':\n                cmd.extend(['--best', '--allowerasing'])\n            _add_common_args(cmd)\n            cmd.append('install' if pkg_type != 'advisory' else 'update')\n            if _yum() == 'dnf5':\n                cmd.extend(['--best', '--allowerasing'])\n            cmd.extend(targets)\n            out = _call_yum(cmd, ignore_retcode=False, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    targets = []\n    with _temporarily_unhold(to_downgrade, targets):\n        if targets:\n            cmd = ['-y']\n            _add_common_args(cmd)\n            cmd.append('downgrade')\n            cmd.extend(targets)\n            out = _call_yum(cmd, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    targets = []\n    with _temporarily_unhold(to_reinstall, targets):\n        if targets:\n            cmd = ['-y']\n            _add_common_args(cmd)\n            cmd.append('reinstall')\n            cmd.extend(targets)\n            out = _call_yum(cmd, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs(versions_as_list=False, attr=diff_attr) if not downloadonly else list_downloaded()\n    ret = salt.utils.data.compare_dicts(old, new)\n    for (pkgname, _) in to_reinstall:\n        if pkgname not in ret or pkgname in old:\n            ret.update({pkgname: {'old': old.get(pkgname, ''), 'new': new.get(pkgname, '')}})\n    if unhold_prevented:\n        errors.append(\"The following package(s) could not be updated because they are being held: {}. Set 'update_holds' to True to temporarily unhold these packages so that they can be updated.\".format(', '.join(unhold_prevented)))\n    if errors:\n        raise CommandExecutionError('Error occurred installing{} package(s)'.format('/reinstalling' if to_reinstall else ''), info={'errors': errors, 'changes': ret})\n    return ret",
            "def install(name=None, refresh=False, skip_verify=False, pkgs=None, sources=None, downloadonly=False, reinstall=False, normalize=True, update_holds=False, saltenv='base', ignore_epoch=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    Install the passed package(s), add refresh=True to clean the yum database\\n    before package is installed.\\n\\n    name\\n        The name of the package to be installed. Note that this parameter is\\n        ignored if either \"pkgs\" or \"sources\" is passed. Additionally, please\\n        note that this option can only be used to install packages from a\\n        software repository. To install a package file manually, use the\\n        \"sources\" option.\\n\\n        32-bit packages can be installed on 64-bit systems by appending the\\n        architecture designation (``.i686``, ``.i586``, etc.) to the end of the\\n        package name.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install <package name>\\n\\n    refresh\\n        Whether or not to update the yum database before executing.\\n\\n    reinstall\\n        Specifying reinstall=True will use ``yum reinstall`` rather than\\n        ``yum install`` for requested packages that are already installed.\\n\\n        If a version is specified with the requested package, then\\n        ``yum reinstall`` will only be used if the installed version\\n        matches the requested version.\\n\\n        Works with ``sources`` when the package header of the source can be\\n        matched to the name and version of an installed package.\\n\\n        .. versionadded:: 2014.7.0\\n\\n    skip_verify\\n        Skip the GPG verification check (e.g., ``--nogpgcheck``)\\n\\n    downloadonly\\n        Only download the packages, do not install.\\n\\n    version\\n        Install a specific version of the package, e.g. 1.2.3-4.el5. Ignored\\n        if \"pkgs\" or \"sources\" is passed.\\n\\n        .. versionchanged:: 2018.3.0\\n            version can now contain comparison operators (e.g. ``>1.2.3``,\\n            ``<=2.0``, etc.)\\n\\n    update_holds : False\\n        If ``True``, and this function would update the package version, any\\n        packages held using the yum/dnf \"versionlock\" plugin will be unheld so\\n        that they can be updated. Otherwise, if this function attempts to\\n        update a held package, the held package(s) will be skipped and an\\n        error will be raised.\\n\\n        .. versionadded:: 2016.11.0\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install foo setopt=\\'obsoletes=0,plugins=0\\'\\n\\n        .. versionadded:: 2019.2.0\\n\\n    Repository Options:\\n\\n    fromrepo\\n        Specify a package repository (or repositories) from which to install.\\n        (e.g., ``yum --disablerepo=\\'*\\' --enablerepo=\\'somerepo\\'``)\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo=\\'somerepo\\'``)\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo=\\'somerepo\\'``)\\n\\n    disableexcludes\\n        Disable exclude from main, for a repo or for everything.\\n        (e.g., ``yum --disableexcludes=\\'main\\'``)\\n\\n        .. versionadded:: 2014.7.0\\n\\n    ignore_epoch : False\\n        Only used when the version of a package is specified using a comparison\\n        operator (e.g. ``>4.1``). If set to ``True``, then the epoch will be\\n        ignored when comparing the currently-installed version to the desired\\n        version.\\n\\n        .. versionadded:: 2018.3.0\\n\\n\\n    Multiple Package Installation Options:\\n\\n    pkgs\\n        A list of packages to install from a software repository. Must be\\n        passed as a python list. A specific version number can be specified\\n        by using a single-element dict representing the package and its\\n        version.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install pkgs=\\'[\"foo\", \"bar\"]\\'\\n            salt \\'*\\' pkg.install pkgs=\\'[\"foo\", {\"bar\": \"1.2.3-4.el5\"}]\\'\\n\\n    sources\\n        A list of RPM packages to install. Must be passed as a list of dicts,\\n        with the keys being package names, and the values being the source URI\\n        or local path to the package.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.install sources=\\'[{\"foo\": \"salt://foo.rpm\"}, {\"bar\": \"salt://bar.rpm\"}]\\'\\n\\n    normalize : True\\n        Normalize the package name by removing the architecture. This is useful\\n        for poorly created packages which might include the architecture as an\\n        actual part of the name such as kernel modules which match a specific\\n        kernel version.\\n\\n        .. code-block:: bash\\n\\n            salt -G role:nsd pkg.install gpfs.gplbin-2.6.32-279.31.1.el6.x86_64 normalize=False\\n\\n        .. versionadded:: 2014.7.0\\n\\n    split_arch : True\\n        If set to False it prevents package name normalization more strict way\\n        than ``normalize`` set to ``False`` does.\\n\\n        .. versionadded:: 3006.0\\n\\n    diff_attr:\\n        If a list of package attributes is specified, returned value will\\n        contain them, eg.::\\n\\n            {\\'<package>\\': {\\n                \\'old\\': {\\n                    \\'version\\': \\'<old-version>\\',\\n                    \\'arch\\': \\'<old-arch>\\'},\\n\\n                \\'new\\': {\\n                    \\'version\\': \\'<new-version>\\',\\n                    \\'arch\\': \\'<new-arch>\\'}}}\\n\\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\\n        ``install_date``, ``install_date_time_t``.\\n\\n        If ``all`` is specified, all valid attributes will be returned.\\n\\n        .. versionadded:: 2018.3.0\\n\\n    Returns a dict containing the new package names and versions::\\n\\n        {\\'<package>\\': {\\'old\\': \\'<old-version>\\',\\n                       \\'new\\': \\'<new-version>\\'}}\\n\\n    If an attribute list in diff_attr is specified, the dict will also contain\\n    any specified attribute, eg.::\\n\\n        {\\'<package>\\': {\\n            \\'old\\': {\\n                \\'version\\': \\'<old-version>\\',\\n                \\'arch\\': \\'<old-arch>\\'},\\n\\n            \\'new\\': {\\n                \\'version\\': \\'<new-version>\\',\\n                \\'arch\\': \\'<new-arch>\\'}}}\\n    '\n    if 'version' in kwargs:\n        kwargs['version'] = str(kwargs['version'])\n    options = _get_options(**kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(**kwargs)\n    reinstall = salt.utils.data.is_true(reinstall)\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, saltenv=saltenv, normalize=normalize and kwargs.get('split_arch', True), **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    diff_attr = kwargs.get('diff_attr')\n    old = list_pkgs(versions_as_list=False, attr=diff_attr) if not downloadonly else list_downloaded()\n    old_as_list = list_pkgs(versions_as_list=True) if not downloadonly else list_downloaded()\n    to_install = []\n    to_downgrade = []\n    to_reinstall = []\n    _available = {}\n    if pkg_type == 'repository':\n        has_wildcards = []\n        has_comparison = []\n        for (pkgname, pkgver) in pkg_params.items():\n            try:\n                if '*' in pkgver:\n                    has_wildcards.append(pkgname)\n                elif pkgver.startswith('<') or pkgver.startswith('>'):\n                    has_comparison.append(pkgname)\n            except (TypeError, ValueError):\n                continue\n        _available = AvailablePackages(*has_wildcards + has_comparison, byrepo=False, **kwargs)\n        pkg_params_items = pkg_params.items()\n    elif pkg_type == 'advisory':\n        pkg_params_items = []\n        cur_patches = list_patches()\n        for advisory_id in pkg_params:\n            if advisory_id not in cur_patches:\n                raise CommandExecutionError(f'Advisory id \"{advisory_id}\" not found')\n            else:\n                pkg_params_items.append(advisory_id)\n    else:\n        pkg_params_items = []\n        for pkg_source in pkg_params:\n            if 'lowpkg.bin_pkg_info' in __salt__:\n                rpm_info = __salt__['lowpkg.bin_pkg_info'](pkg_source)\n            else:\n                rpm_info = None\n            if rpm_info is None:\n                log.error('pkg.install: Unable to get rpm information for %s. Version comparisons will be unavailable, and return data may be inaccurate if reinstall=True.', pkg_source)\n                pkg_params_items.append([pkg_source])\n            else:\n                pkg_params_items.append([rpm_info['name'], pkg_source, rpm_info['version']])\n    errors = []\n    for pkg_item_list in pkg_params_items:\n        if pkg_type == 'repository':\n            (pkgname, version_num) = pkg_item_list\n        elif pkg_type == 'advisory':\n            pkgname = pkg_item_list\n            version_num = None\n        else:\n            try:\n                (pkgname, pkgpath, version_num) = pkg_item_list\n            except ValueError:\n                pkgname = None\n                pkgpath = pkg_item_list[0]\n                version_num = None\n        if version_num is None:\n            if pkg_type == 'repository':\n                if reinstall and pkgname in old:\n                    to_reinstall.append((pkgname, pkgname))\n                else:\n                    to_install.append((pkgname, pkgname))\n            elif pkg_type == 'advisory':\n                to_install.append((pkgname, pkgname))\n            else:\n                to_install.append((pkgname, pkgpath))\n        else:\n            if pkg_type == 'repository':\n                version_num = version_num.lstrip('=')\n                if pkgname in has_comparison:\n                    candidates = _available.get(pkgname, [])\n                    target = salt.utils.pkg.match_version(version_num, candidates, cmp_func=version_cmp, ignore_epoch=ignore_epoch)\n                    if target is None:\n                        errors.append(\"No version matching '{}{}' could be found (available: {})\".format(pkgname, version_num, ', '.join(candidates) if candidates else None))\n                        continue\n                    else:\n                        version_num = target\n                if _yum() == 'yum':\n                    if ignore_epoch is True:\n                        version_num = version_num.split(':', 1)[-1]\n                arch = ''\n                try:\n                    (namepart, archpart) = pkgname.rsplit('.', 1)\n                except ValueError:\n                    pass\n                else:\n                    if archpart in salt.utils.pkg.rpm.ARCHES and (archpart != __grains__['osarch'] or kwargs.get('split_arch', True)):\n                        arch = '.' + archpart\n                        pkgname = namepart\n                if '*' in version_num:\n                    candidates = _available.get(pkgname, [])\n                    match = salt.utils.itertools.fnmatch_multiple(candidates, version_num)\n                    if match is not None:\n                        version_num = match\n                    else:\n                        errors.append(\"No version matching '{}' found for package '{}' (available: {})\".format(version_num, pkgname, ', '.join(candidates) if candidates else 'none'))\n                        continue\n                if ignore_epoch is True:\n                    pkgstr = f'{pkgname}-{version_num}{arch}'\n                else:\n                    pkgstr = '{}-{}{}'.format(pkgname, version_num.split(':', 1)[-1], arch)\n            else:\n                pkgstr = pkgpath\n            cver = old_as_list.get(pkgname, [])\n            if reinstall and cver:\n                for ver in cver:\n                    if salt.utils.versions.compare(ver1=version_num, oper='==', ver2=ver, cmp_func=version_cmp, ignore_epoch=ignore_epoch):\n                        to_reinstall.append((pkgname, pkgstr))\n                        break\n            elif not cver:\n                to_install.append((pkgname, pkgstr))\n            else:\n                for ver in cver:\n                    if salt.utils.versions.compare(ver1=version_num, oper='>=', ver2=ver, cmp_func=version_cmp, ignore_epoch=ignore_epoch):\n                        to_install.append((pkgname, pkgstr))\n                        break\n                else:\n                    if pkgname is not None:\n                        if re.match('^kernel(|-devel)$', pkgname):\n                            to_install.append((pkgname, pkgstr))\n                        else:\n                            to_downgrade.append((pkgname, pkgstr))\n\n    def _add_common_args(cmd):\n        \"\"\"\n        DRY function to add args common to all yum/dnf commands\n        \"\"\"\n        cmd.extend(options)\n        if skip_verify:\n            cmd.append('--nogpgcheck')\n        if downloadonly:\n            if _yum() != 'dnf5':\n                cmd.append('--downloadonly')\n    try:\n        holds = list_holds(full=False)\n    except SaltInvocationError:\n        holds = []\n        log.debug('Failed to get holds, versionlock plugin is probably not installed')\n    unhold_prevented = []\n\n    @contextlib.contextmanager\n    def _temporarily_unhold(pkgs, targets):\n        \"\"\"\n        Temporarily unhold packages that need to be updated. Add any\n        successfully-removed ones (and any packages not in the list of current\n        holds) to the list of targets.\n        \"\"\"\n        to_unhold = {}\n        for (pkgname, pkgstr) in pkgs:\n            if pkgname in holds:\n                if update_holds:\n                    to_unhold[pkgname] = pkgstr\n                else:\n                    unhold_prevented.append(pkgname)\n            else:\n                targets.append(pkgstr)\n        if not to_unhold:\n            yield\n        else:\n            log.debug('Unholding packages: %s', ', '.join(to_unhold))\n            try:\n                unhold_names = list(to_unhold.keys())\n                for (unheld_pkg, outcome) in unhold(pkgs=unhold_names).items():\n                    if outcome['result']:\n                        targets.append(to_unhold[unheld_pkg])\n                    else:\n                        errors.append(unheld_pkg)\n                yield\n            except Exception as exc:\n                errors.append('Error encountered unholding packages {}: {}'.format(', '.join(to_unhold), exc))\n            finally:\n                hold(pkgs=unhold_names)\n    targets = []\n    with _temporarily_unhold(to_install, targets):\n        if targets:\n            if pkg_type == 'advisory':\n                targets = [f'--advisory={t}' for t in targets]\n            cmd = ['-y']\n            if _yum() == 'dnf':\n                cmd.extend(['--best', '--allowerasing'])\n            _add_common_args(cmd)\n            cmd.append('install' if pkg_type != 'advisory' else 'update')\n            if _yum() == 'dnf5':\n                cmd.extend(['--best', '--allowerasing'])\n            cmd.extend(targets)\n            out = _call_yum(cmd, ignore_retcode=False, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    targets = []\n    with _temporarily_unhold(to_downgrade, targets):\n        if targets:\n            cmd = ['-y']\n            _add_common_args(cmd)\n            cmd.append('downgrade')\n            cmd.extend(targets)\n            out = _call_yum(cmd, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    targets = []\n    with _temporarily_unhold(to_reinstall, targets):\n        if targets:\n            cmd = ['-y']\n            _add_common_args(cmd)\n            cmd.append('reinstall')\n            cmd.extend(targets)\n            out = _call_yum(cmd, redirect_stderr=True)\n            if out['retcode'] != 0:\n                errors.append(out['stdout'])\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs(versions_as_list=False, attr=diff_attr) if not downloadonly else list_downloaded()\n    ret = salt.utils.data.compare_dicts(old, new)\n    for (pkgname, _) in to_reinstall:\n        if pkgname not in ret or pkgname in old:\n            ret.update({pkgname: {'old': old.get(pkgname, ''), 'new': new.get(pkgname, '')}})\n    if unhold_prevented:\n        errors.append(\"The following package(s) could not be updated because they are being held: {}. Set 'update_holds' to True to temporarily unhold these packages so that they can be updated.\".format(', '.join(unhold_prevented)))\n    if errors:\n        raise CommandExecutionError('Error occurred installing{} package(s)'.format('/reinstalling' if to_reinstall else ''), info={'errors': errors, 'changes': ret})\n    return ret"
        ]
    },
    {
        "func_name": "upgrade",
        "original": "def upgrade(name=None, pkgs=None, refresh=True, skip_verify=False, normalize=True, minimal=False, obsoletes=True, diff_attr=None, **kwargs):\n    \"\"\"\n    Run a full system upgrade (a ``yum upgrade`` or ``dnf upgrade``), or\n    upgrade specified packages. If the packages aren't installed, they will\n    not be installed.\n\n    .. versionchanged:: 2014.7.0\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\n        isolate commands which modify installed packages from the\n        ``salt-minion`` daemon's control group. This is done to keep systemd\n        from killing any yum/dnf commands spawned by Salt when the\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\n        ``False`` (no quotes).\n\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\n\n    .. versionchanged:: 2019.2.0\n        Added ``obsoletes`` and ``minimal`` arguments\n\n    Returns a dictionary containing the changes:\n\n    .. code-block:: python\n\n        {'<package>':  {'old': '<old-version>',\n                        'new': '<new-version>'}}\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.upgrade\n        salt '*' pkg.upgrade name=openssl\n\n    Repository Options:\n\n    fromrepo\n        Specify a package repository (or repositories) from which to install.\n        (e.g., ``yum --disablerepo='*' --enablerepo='somerepo'``)\n\n    enablerepo (ignored if ``fromrepo`` is specified)\n        Specify a disabled package repository (or repositories) to enable.\n        (e.g., ``yum --enablerepo='somerepo'``)\n\n    disablerepo (ignored if ``fromrepo`` is specified)\n        Specify an enabled package repository (or repositories) to disable.\n        (e.g., ``yum --disablerepo='somerepo'``)\n\n    disableexcludes\n        Disable exclude from main, for a repo or for everything.\n        (e.g., ``yum --disableexcludes='main'``)\n\n        .. versionadded:: 2014.7.0\n\n    name\n        The name of the package to be upgraded. Note that this parameter is\n        ignored if \"pkgs\" is passed.\n\n        32-bit packages can be upgraded on 64-bit systems by appending the\n        architecture designation (``.i686``, ``.i586``, etc.) to the end of the\n        package name.\n\n        Warning: if you forget 'name=' and run pkg.upgrade openssl, ALL packages\n        are upgraded. This will be addressed in next releases.\n\n        CLI Example:\n\n        .. code-block:: bash\n\n            salt '*' pkg.upgrade name=openssl\n\n        .. versionadded:: 2016.3.0\n\n    pkgs\n        A list of packages to upgrade from a software repository. Must be\n        passed as a python list. A specific version number can be specified\n        by using a single-element dict representing the package and its\n        version. If the package was not already installed on the system,\n        it will not be installed.\n\n        CLI Examples:\n\n        .. code-block:: bash\n\n            salt '*' pkg.upgrade pkgs='[\"foo\", \"bar\"]'\n            salt '*' pkg.upgrade pkgs='[\"foo\", {\"bar\": \"1.2.3-4.el5\"}]'\n\n        .. versionadded:: 2016.3.0\n\n    normalize : True\n        Normalize the package name by removing the architecture. This is useful\n        for poorly created packages which might include the architecture as an\n        actual part of the name such as kernel modules which match a specific\n        kernel version.\n\n        .. code-block:: bash\n\n            salt -G role:nsd pkg.upgrade gpfs.gplbin-2.6.32-279.31.1.el6.x86_64 normalize=False\n\n        .. versionadded:: 2016.3.0\n\n    minimal : False\n        Use upgrade-minimal instead of upgrade (e.g., ``yum upgrade-minimal``)\n        Goes to the 'newest' package match which fixes a problem that affects your system.\n\n        .. code-block:: bash\n\n            salt '*' pkg.upgrade minimal=True\n\n        .. versionadded:: 2019.2.0\n\n    obsoletes : True\n        Controls whether yum/dnf should take obsoletes into account and remove them.\n        If set to ``False`` yum will use ``update`` instead of ``upgrade``\n        and dnf will be run with ``--obsoletes=False``\n\n        .. code-block:: bash\n\n            salt '*' pkg.upgrade obsoletes=False\n\n        .. versionadded:: 2019.2.0\n\n    setopt\n        A comma-separated or Python list of key=value options. This list will\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\n        that is run.\n\n        .. versionadded:: 2019.2.0\n\n    diff_attr:\n        If a list of package attributes is specified, returned value will\n        contain them, eg.::\n\n            {'<package>': {\n                'old': {\n                    'version': '<old-version>',\n                    'arch': '<old-arch>'},\n\n                'new': {\n                    'version': '<new-version>',\n                    'arch': '<new-arch>'}}}\n\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\n        ``install_date``, ``install_date_time_t``.\n\n        If ``all`` is specified, all valid attributes will be returned.\n\n        .. versionadded:: 3006.0\n\n    .. note::\n        To add extra arguments to the ``yum upgrade`` command, pass them as key\n        word arguments. For arguments without assignments, pass ``True``\n\n    .. code-block:: bash\n\n        salt '*' pkg.upgrade security=True exclude='kernel*'\n    \"\"\"\n    if _yum() in ('dnf', 'dnf5') and (not obsoletes):\n        _setopt = [opt for opt in salt.utils.args.split_input(kwargs.pop('setopt', [])) if not opt.startswith('obsoletes=')]\n        _setopt.append('obsoletes=False')\n        kwargs['setopt'] = _setopt\n    options = _get_options(get_extra_options=True, **kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(**kwargs)\n    old = list_pkgs(attr=diff_attr)\n    targets = []\n    if name or pkgs:\n        try:\n            pkg_params = __salt__['pkg_resource.parse_targets'](name=name, pkgs=pkgs, sources=None, normalize=normalize, **kwargs)[0]\n        except MinionError as exc:\n            raise CommandExecutionError(exc)\n        if pkg_params:\n            targets.extend(pkg_params)\n    cmd = ['--quiet', '-y']\n    cmd.extend(options)\n    if skip_verify:\n        cmd.append('--nogpgcheck')\n    if obsoletes:\n        cmd.append('upgrade' if not minimal else 'upgrade-minimal')\n    elif _yum() in ('dnf', 'dnf5'):\n        cmd.append('upgrade' if not minimal else 'upgrade-minimal')\n    else:\n        cmd.append('update' if not minimal else 'update-minimal')\n    cmd.extend(targets)\n    result = _call_yum(cmd)\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs(attr=diff_attr)\n    ret = salt.utils.data.compare_dicts(old, new)\n    if result['retcode'] != 0:\n        raise CommandExecutionError('Problem encountered upgrading packages', info={'changes': ret, 'result': result})\n    return ret",
        "mutated": [
            "def upgrade(name=None, pkgs=None, refresh=True, skip_verify=False, normalize=True, minimal=False, obsoletes=True, diff_attr=None, **kwargs):\n    if False:\n        i = 10\n    '\\n    Run a full system upgrade (a ``yum upgrade`` or ``dnf upgrade``), or\\n    upgrade specified packages. If the packages aren\\'t installed, they will\\n    not be installed.\\n\\n    .. versionchanged:: 2014.7.0\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    .. versionchanged:: 2019.2.0\\n        Added ``obsoletes`` and ``minimal`` arguments\\n\\n    Returns a dictionary containing the changes:\\n\\n    .. code-block:: python\\n\\n        {\\'<package>\\':  {\\'old\\': \\'<old-version>\\',\\n                        \\'new\\': \\'<new-version>\\'}}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.upgrade\\n        salt \\'*\\' pkg.upgrade name=openssl\\n\\n    Repository Options:\\n\\n    fromrepo\\n        Specify a package repository (or repositories) from which to install.\\n        (e.g., ``yum --disablerepo=\\'*\\' --enablerepo=\\'somerepo\\'``)\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo=\\'somerepo\\'``)\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo=\\'somerepo\\'``)\\n\\n    disableexcludes\\n        Disable exclude from main, for a repo or for everything.\\n        (e.g., ``yum --disableexcludes=\\'main\\'``)\\n\\n        .. versionadded:: 2014.7.0\\n\\n    name\\n        The name of the package to be upgraded. Note that this parameter is\\n        ignored if \"pkgs\" is passed.\\n\\n        32-bit packages can be upgraded on 64-bit systems by appending the\\n        architecture designation (``.i686``, ``.i586``, etc.) to the end of the\\n        package name.\\n\\n        Warning: if you forget \\'name=\\' and run pkg.upgrade openssl, ALL packages\\n        are upgraded. This will be addressed in next releases.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade name=openssl\\n\\n        .. versionadded:: 2016.3.0\\n\\n    pkgs\\n        A list of packages to upgrade from a software repository. Must be\\n        passed as a python list. A specific version number can be specified\\n        by using a single-element dict representing the package and its\\n        version. If the package was not already installed on the system,\\n        it will not be installed.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade pkgs=\\'[\"foo\", \"bar\"]\\'\\n            salt \\'*\\' pkg.upgrade pkgs=\\'[\"foo\", {\"bar\": \"1.2.3-4.el5\"}]\\'\\n\\n        .. versionadded:: 2016.3.0\\n\\n    normalize : True\\n        Normalize the package name by removing the architecture. This is useful\\n        for poorly created packages which might include the architecture as an\\n        actual part of the name such as kernel modules which match a specific\\n        kernel version.\\n\\n        .. code-block:: bash\\n\\n            salt -G role:nsd pkg.upgrade gpfs.gplbin-2.6.32-279.31.1.el6.x86_64 normalize=False\\n\\n        .. versionadded:: 2016.3.0\\n\\n    minimal : False\\n        Use upgrade-minimal instead of upgrade (e.g., ``yum upgrade-minimal``)\\n        Goes to the \\'newest\\' package match which fixes a problem that affects your system.\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade minimal=True\\n\\n        .. versionadded:: 2019.2.0\\n\\n    obsoletes : True\\n        Controls whether yum/dnf should take obsoletes into account and remove them.\\n        If set to ``False`` yum will use ``update`` instead of ``upgrade``\\n        and dnf will be run with ``--obsoletes=False``\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade obsoletes=False\\n\\n        .. versionadded:: 2019.2.0\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    diff_attr:\\n        If a list of package attributes is specified, returned value will\\n        contain them, eg.::\\n\\n            {\\'<package>\\': {\\n                \\'old\\': {\\n                    \\'version\\': \\'<old-version>\\',\\n                    \\'arch\\': \\'<old-arch>\\'},\\n\\n                \\'new\\': {\\n                    \\'version\\': \\'<new-version>\\',\\n                    \\'arch\\': \\'<new-arch>\\'}}}\\n\\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\\n        ``install_date``, ``install_date_time_t``.\\n\\n        If ``all`` is specified, all valid attributes will be returned.\\n\\n        .. versionadded:: 3006.0\\n\\n    .. note::\\n        To add extra arguments to the ``yum upgrade`` command, pass them as key\\n        word arguments. For arguments without assignments, pass ``True``\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.upgrade security=True exclude=\\'kernel*\\'\\n    '\n    if _yum() in ('dnf', 'dnf5') and (not obsoletes):\n        _setopt = [opt for opt in salt.utils.args.split_input(kwargs.pop('setopt', [])) if not opt.startswith('obsoletes=')]\n        _setopt.append('obsoletes=False')\n        kwargs['setopt'] = _setopt\n    options = _get_options(get_extra_options=True, **kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(**kwargs)\n    old = list_pkgs(attr=diff_attr)\n    targets = []\n    if name or pkgs:\n        try:\n            pkg_params = __salt__['pkg_resource.parse_targets'](name=name, pkgs=pkgs, sources=None, normalize=normalize, **kwargs)[0]\n        except MinionError as exc:\n            raise CommandExecutionError(exc)\n        if pkg_params:\n            targets.extend(pkg_params)\n    cmd = ['--quiet', '-y']\n    cmd.extend(options)\n    if skip_verify:\n        cmd.append('--nogpgcheck')\n    if obsoletes:\n        cmd.append('upgrade' if not minimal else 'upgrade-minimal')\n    elif _yum() in ('dnf', 'dnf5'):\n        cmd.append('upgrade' if not minimal else 'upgrade-minimal')\n    else:\n        cmd.append('update' if not minimal else 'update-minimal')\n    cmd.extend(targets)\n    result = _call_yum(cmd)\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs(attr=diff_attr)\n    ret = salt.utils.data.compare_dicts(old, new)\n    if result['retcode'] != 0:\n        raise CommandExecutionError('Problem encountered upgrading packages', info={'changes': ret, 'result': result})\n    return ret",
            "def upgrade(name=None, pkgs=None, refresh=True, skip_verify=False, normalize=True, minimal=False, obsoletes=True, diff_attr=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Run a full system upgrade (a ``yum upgrade`` or ``dnf upgrade``), or\\n    upgrade specified packages. If the packages aren\\'t installed, they will\\n    not be installed.\\n\\n    .. versionchanged:: 2014.7.0\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    .. versionchanged:: 2019.2.0\\n        Added ``obsoletes`` and ``minimal`` arguments\\n\\n    Returns a dictionary containing the changes:\\n\\n    .. code-block:: python\\n\\n        {\\'<package>\\':  {\\'old\\': \\'<old-version>\\',\\n                        \\'new\\': \\'<new-version>\\'}}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.upgrade\\n        salt \\'*\\' pkg.upgrade name=openssl\\n\\n    Repository Options:\\n\\n    fromrepo\\n        Specify a package repository (or repositories) from which to install.\\n        (e.g., ``yum --disablerepo=\\'*\\' --enablerepo=\\'somerepo\\'``)\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo=\\'somerepo\\'``)\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo=\\'somerepo\\'``)\\n\\n    disableexcludes\\n        Disable exclude from main, for a repo or for everything.\\n        (e.g., ``yum --disableexcludes=\\'main\\'``)\\n\\n        .. versionadded:: 2014.7.0\\n\\n    name\\n        The name of the package to be upgraded. Note that this parameter is\\n        ignored if \"pkgs\" is passed.\\n\\n        32-bit packages can be upgraded on 64-bit systems by appending the\\n        architecture designation (``.i686``, ``.i586``, etc.) to the end of the\\n        package name.\\n\\n        Warning: if you forget \\'name=\\' and run pkg.upgrade openssl, ALL packages\\n        are upgraded. This will be addressed in next releases.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade name=openssl\\n\\n        .. versionadded:: 2016.3.0\\n\\n    pkgs\\n        A list of packages to upgrade from a software repository. Must be\\n        passed as a python list. A specific version number can be specified\\n        by using a single-element dict representing the package and its\\n        version. If the package was not already installed on the system,\\n        it will not be installed.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade pkgs=\\'[\"foo\", \"bar\"]\\'\\n            salt \\'*\\' pkg.upgrade pkgs=\\'[\"foo\", {\"bar\": \"1.2.3-4.el5\"}]\\'\\n\\n        .. versionadded:: 2016.3.0\\n\\n    normalize : True\\n        Normalize the package name by removing the architecture. This is useful\\n        for poorly created packages which might include the architecture as an\\n        actual part of the name such as kernel modules which match a specific\\n        kernel version.\\n\\n        .. code-block:: bash\\n\\n            salt -G role:nsd pkg.upgrade gpfs.gplbin-2.6.32-279.31.1.el6.x86_64 normalize=False\\n\\n        .. versionadded:: 2016.3.0\\n\\n    minimal : False\\n        Use upgrade-minimal instead of upgrade (e.g., ``yum upgrade-minimal``)\\n        Goes to the \\'newest\\' package match which fixes a problem that affects your system.\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade minimal=True\\n\\n        .. versionadded:: 2019.2.0\\n\\n    obsoletes : True\\n        Controls whether yum/dnf should take obsoletes into account and remove them.\\n        If set to ``False`` yum will use ``update`` instead of ``upgrade``\\n        and dnf will be run with ``--obsoletes=False``\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade obsoletes=False\\n\\n        .. versionadded:: 2019.2.0\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    diff_attr:\\n        If a list of package attributes is specified, returned value will\\n        contain them, eg.::\\n\\n            {\\'<package>\\': {\\n                \\'old\\': {\\n                    \\'version\\': \\'<old-version>\\',\\n                    \\'arch\\': \\'<old-arch>\\'},\\n\\n                \\'new\\': {\\n                    \\'version\\': \\'<new-version>\\',\\n                    \\'arch\\': \\'<new-arch>\\'}}}\\n\\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\\n        ``install_date``, ``install_date_time_t``.\\n\\n        If ``all`` is specified, all valid attributes will be returned.\\n\\n        .. versionadded:: 3006.0\\n\\n    .. note::\\n        To add extra arguments to the ``yum upgrade`` command, pass them as key\\n        word arguments. For arguments without assignments, pass ``True``\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.upgrade security=True exclude=\\'kernel*\\'\\n    '\n    if _yum() in ('dnf', 'dnf5') and (not obsoletes):\n        _setopt = [opt for opt in salt.utils.args.split_input(kwargs.pop('setopt', [])) if not opt.startswith('obsoletes=')]\n        _setopt.append('obsoletes=False')\n        kwargs['setopt'] = _setopt\n    options = _get_options(get_extra_options=True, **kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(**kwargs)\n    old = list_pkgs(attr=diff_attr)\n    targets = []\n    if name or pkgs:\n        try:\n            pkg_params = __salt__['pkg_resource.parse_targets'](name=name, pkgs=pkgs, sources=None, normalize=normalize, **kwargs)[0]\n        except MinionError as exc:\n            raise CommandExecutionError(exc)\n        if pkg_params:\n            targets.extend(pkg_params)\n    cmd = ['--quiet', '-y']\n    cmd.extend(options)\n    if skip_verify:\n        cmd.append('--nogpgcheck')\n    if obsoletes:\n        cmd.append('upgrade' if not minimal else 'upgrade-minimal')\n    elif _yum() in ('dnf', 'dnf5'):\n        cmd.append('upgrade' if not minimal else 'upgrade-minimal')\n    else:\n        cmd.append('update' if not minimal else 'update-minimal')\n    cmd.extend(targets)\n    result = _call_yum(cmd)\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs(attr=diff_attr)\n    ret = salt.utils.data.compare_dicts(old, new)\n    if result['retcode'] != 0:\n        raise CommandExecutionError('Problem encountered upgrading packages', info={'changes': ret, 'result': result})\n    return ret",
            "def upgrade(name=None, pkgs=None, refresh=True, skip_verify=False, normalize=True, minimal=False, obsoletes=True, diff_attr=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Run a full system upgrade (a ``yum upgrade`` or ``dnf upgrade``), or\\n    upgrade specified packages. If the packages aren\\'t installed, they will\\n    not be installed.\\n\\n    .. versionchanged:: 2014.7.0\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    .. versionchanged:: 2019.2.0\\n        Added ``obsoletes`` and ``minimal`` arguments\\n\\n    Returns a dictionary containing the changes:\\n\\n    .. code-block:: python\\n\\n        {\\'<package>\\':  {\\'old\\': \\'<old-version>\\',\\n                        \\'new\\': \\'<new-version>\\'}}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.upgrade\\n        salt \\'*\\' pkg.upgrade name=openssl\\n\\n    Repository Options:\\n\\n    fromrepo\\n        Specify a package repository (or repositories) from which to install.\\n        (e.g., ``yum --disablerepo=\\'*\\' --enablerepo=\\'somerepo\\'``)\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo=\\'somerepo\\'``)\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo=\\'somerepo\\'``)\\n\\n    disableexcludes\\n        Disable exclude from main, for a repo or for everything.\\n        (e.g., ``yum --disableexcludes=\\'main\\'``)\\n\\n        .. versionadded:: 2014.7.0\\n\\n    name\\n        The name of the package to be upgraded. Note that this parameter is\\n        ignored if \"pkgs\" is passed.\\n\\n        32-bit packages can be upgraded on 64-bit systems by appending the\\n        architecture designation (``.i686``, ``.i586``, etc.) to the end of the\\n        package name.\\n\\n        Warning: if you forget \\'name=\\' and run pkg.upgrade openssl, ALL packages\\n        are upgraded. This will be addressed in next releases.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade name=openssl\\n\\n        .. versionadded:: 2016.3.0\\n\\n    pkgs\\n        A list of packages to upgrade from a software repository. Must be\\n        passed as a python list. A specific version number can be specified\\n        by using a single-element dict representing the package and its\\n        version. If the package was not already installed on the system,\\n        it will not be installed.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade pkgs=\\'[\"foo\", \"bar\"]\\'\\n            salt \\'*\\' pkg.upgrade pkgs=\\'[\"foo\", {\"bar\": \"1.2.3-4.el5\"}]\\'\\n\\n        .. versionadded:: 2016.3.0\\n\\n    normalize : True\\n        Normalize the package name by removing the architecture. This is useful\\n        for poorly created packages which might include the architecture as an\\n        actual part of the name such as kernel modules which match a specific\\n        kernel version.\\n\\n        .. code-block:: bash\\n\\n            salt -G role:nsd pkg.upgrade gpfs.gplbin-2.6.32-279.31.1.el6.x86_64 normalize=False\\n\\n        .. versionadded:: 2016.3.0\\n\\n    minimal : False\\n        Use upgrade-minimal instead of upgrade (e.g., ``yum upgrade-minimal``)\\n        Goes to the \\'newest\\' package match which fixes a problem that affects your system.\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade minimal=True\\n\\n        .. versionadded:: 2019.2.0\\n\\n    obsoletes : True\\n        Controls whether yum/dnf should take obsoletes into account and remove them.\\n        If set to ``False`` yum will use ``update`` instead of ``upgrade``\\n        and dnf will be run with ``--obsoletes=False``\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade obsoletes=False\\n\\n        .. versionadded:: 2019.2.0\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    diff_attr:\\n        If a list of package attributes is specified, returned value will\\n        contain them, eg.::\\n\\n            {\\'<package>\\': {\\n                \\'old\\': {\\n                    \\'version\\': \\'<old-version>\\',\\n                    \\'arch\\': \\'<old-arch>\\'},\\n\\n                \\'new\\': {\\n                    \\'version\\': \\'<new-version>\\',\\n                    \\'arch\\': \\'<new-arch>\\'}}}\\n\\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\\n        ``install_date``, ``install_date_time_t``.\\n\\n        If ``all`` is specified, all valid attributes will be returned.\\n\\n        .. versionadded:: 3006.0\\n\\n    .. note::\\n        To add extra arguments to the ``yum upgrade`` command, pass them as key\\n        word arguments. For arguments without assignments, pass ``True``\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.upgrade security=True exclude=\\'kernel*\\'\\n    '\n    if _yum() in ('dnf', 'dnf5') and (not obsoletes):\n        _setopt = [opt for opt in salt.utils.args.split_input(kwargs.pop('setopt', [])) if not opt.startswith('obsoletes=')]\n        _setopt.append('obsoletes=False')\n        kwargs['setopt'] = _setopt\n    options = _get_options(get_extra_options=True, **kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(**kwargs)\n    old = list_pkgs(attr=diff_attr)\n    targets = []\n    if name or pkgs:\n        try:\n            pkg_params = __salt__['pkg_resource.parse_targets'](name=name, pkgs=pkgs, sources=None, normalize=normalize, **kwargs)[0]\n        except MinionError as exc:\n            raise CommandExecutionError(exc)\n        if pkg_params:\n            targets.extend(pkg_params)\n    cmd = ['--quiet', '-y']\n    cmd.extend(options)\n    if skip_verify:\n        cmd.append('--nogpgcheck')\n    if obsoletes:\n        cmd.append('upgrade' if not minimal else 'upgrade-minimal')\n    elif _yum() in ('dnf', 'dnf5'):\n        cmd.append('upgrade' if not minimal else 'upgrade-minimal')\n    else:\n        cmd.append('update' if not minimal else 'update-minimal')\n    cmd.extend(targets)\n    result = _call_yum(cmd)\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs(attr=diff_attr)\n    ret = salt.utils.data.compare_dicts(old, new)\n    if result['retcode'] != 0:\n        raise CommandExecutionError('Problem encountered upgrading packages', info={'changes': ret, 'result': result})\n    return ret",
            "def upgrade(name=None, pkgs=None, refresh=True, skip_verify=False, normalize=True, minimal=False, obsoletes=True, diff_attr=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Run a full system upgrade (a ``yum upgrade`` or ``dnf upgrade``), or\\n    upgrade specified packages. If the packages aren\\'t installed, they will\\n    not be installed.\\n\\n    .. versionchanged:: 2014.7.0\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    .. versionchanged:: 2019.2.0\\n        Added ``obsoletes`` and ``minimal`` arguments\\n\\n    Returns a dictionary containing the changes:\\n\\n    .. code-block:: python\\n\\n        {\\'<package>\\':  {\\'old\\': \\'<old-version>\\',\\n                        \\'new\\': \\'<new-version>\\'}}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.upgrade\\n        salt \\'*\\' pkg.upgrade name=openssl\\n\\n    Repository Options:\\n\\n    fromrepo\\n        Specify a package repository (or repositories) from which to install.\\n        (e.g., ``yum --disablerepo=\\'*\\' --enablerepo=\\'somerepo\\'``)\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo=\\'somerepo\\'``)\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo=\\'somerepo\\'``)\\n\\n    disableexcludes\\n        Disable exclude from main, for a repo or for everything.\\n        (e.g., ``yum --disableexcludes=\\'main\\'``)\\n\\n        .. versionadded:: 2014.7.0\\n\\n    name\\n        The name of the package to be upgraded. Note that this parameter is\\n        ignored if \"pkgs\" is passed.\\n\\n        32-bit packages can be upgraded on 64-bit systems by appending the\\n        architecture designation (``.i686``, ``.i586``, etc.) to the end of the\\n        package name.\\n\\n        Warning: if you forget \\'name=\\' and run pkg.upgrade openssl, ALL packages\\n        are upgraded. This will be addressed in next releases.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade name=openssl\\n\\n        .. versionadded:: 2016.3.0\\n\\n    pkgs\\n        A list of packages to upgrade from a software repository. Must be\\n        passed as a python list. A specific version number can be specified\\n        by using a single-element dict representing the package and its\\n        version. If the package was not already installed on the system,\\n        it will not be installed.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade pkgs=\\'[\"foo\", \"bar\"]\\'\\n            salt \\'*\\' pkg.upgrade pkgs=\\'[\"foo\", {\"bar\": \"1.2.3-4.el5\"}]\\'\\n\\n        .. versionadded:: 2016.3.0\\n\\n    normalize : True\\n        Normalize the package name by removing the architecture. This is useful\\n        for poorly created packages which might include the architecture as an\\n        actual part of the name such as kernel modules which match a specific\\n        kernel version.\\n\\n        .. code-block:: bash\\n\\n            salt -G role:nsd pkg.upgrade gpfs.gplbin-2.6.32-279.31.1.el6.x86_64 normalize=False\\n\\n        .. versionadded:: 2016.3.0\\n\\n    minimal : False\\n        Use upgrade-minimal instead of upgrade (e.g., ``yum upgrade-minimal``)\\n        Goes to the \\'newest\\' package match which fixes a problem that affects your system.\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade minimal=True\\n\\n        .. versionadded:: 2019.2.0\\n\\n    obsoletes : True\\n        Controls whether yum/dnf should take obsoletes into account and remove them.\\n        If set to ``False`` yum will use ``update`` instead of ``upgrade``\\n        and dnf will be run with ``--obsoletes=False``\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade obsoletes=False\\n\\n        .. versionadded:: 2019.2.0\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    diff_attr:\\n        If a list of package attributes is specified, returned value will\\n        contain them, eg.::\\n\\n            {\\'<package>\\': {\\n                \\'old\\': {\\n                    \\'version\\': \\'<old-version>\\',\\n                    \\'arch\\': \\'<old-arch>\\'},\\n\\n                \\'new\\': {\\n                    \\'version\\': \\'<new-version>\\',\\n                    \\'arch\\': \\'<new-arch>\\'}}}\\n\\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\\n        ``install_date``, ``install_date_time_t``.\\n\\n        If ``all`` is specified, all valid attributes will be returned.\\n\\n        .. versionadded:: 3006.0\\n\\n    .. note::\\n        To add extra arguments to the ``yum upgrade`` command, pass them as key\\n        word arguments. For arguments without assignments, pass ``True``\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.upgrade security=True exclude=\\'kernel*\\'\\n    '\n    if _yum() in ('dnf', 'dnf5') and (not obsoletes):\n        _setopt = [opt for opt in salt.utils.args.split_input(kwargs.pop('setopt', [])) if not opt.startswith('obsoletes=')]\n        _setopt.append('obsoletes=False')\n        kwargs['setopt'] = _setopt\n    options = _get_options(get_extra_options=True, **kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(**kwargs)\n    old = list_pkgs(attr=diff_attr)\n    targets = []\n    if name or pkgs:\n        try:\n            pkg_params = __salt__['pkg_resource.parse_targets'](name=name, pkgs=pkgs, sources=None, normalize=normalize, **kwargs)[0]\n        except MinionError as exc:\n            raise CommandExecutionError(exc)\n        if pkg_params:\n            targets.extend(pkg_params)\n    cmd = ['--quiet', '-y']\n    cmd.extend(options)\n    if skip_verify:\n        cmd.append('--nogpgcheck')\n    if obsoletes:\n        cmd.append('upgrade' if not minimal else 'upgrade-minimal')\n    elif _yum() in ('dnf', 'dnf5'):\n        cmd.append('upgrade' if not minimal else 'upgrade-minimal')\n    else:\n        cmd.append('update' if not minimal else 'update-minimal')\n    cmd.extend(targets)\n    result = _call_yum(cmd)\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs(attr=diff_attr)\n    ret = salt.utils.data.compare_dicts(old, new)\n    if result['retcode'] != 0:\n        raise CommandExecutionError('Problem encountered upgrading packages', info={'changes': ret, 'result': result})\n    return ret",
            "def upgrade(name=None, pkgs=None, refresh=True, skip_verify=False, normalize=True, minimal=False, obsoletes=True, diff_attr=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Run a full system upgrade (a ``yum upgrade`` or ``dnf upgrade``), or\\n    upgrade specified packages. If the packages aren\\'t installed, they will\\n    not be installed.\\n\\n    .. versionchanged:: 2014.7.0\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    .. versionchanged:: 2019.2.0\\n        Added ``obsoletes`` and ``minimal`` arguments\\n\\n    Returns a dictionary containing the changes:\\n\\n    .. code-block:: python\\n\\n        {\\'<package>\\':  {\\'old\\': \\'<old-version>\\',\\n                        \\'new\\': \\'<new-version>\\'}}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.upgrade\\n        salt \\'*\\' pkg.upgrade name=openssl\\n\\n    Repository Options:\\n\\n    fromrepo\\n        Specify a package repository (or repositories) from which to install.\\n        (e.g., ``yum --disablerepo=\\'*\\' --enablerepo=\\'somerepo\\'``)\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo=\\'somerepo\\'``)\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo=\\'somerepo\\'``)\\n\\n    disableexcludes\\n        Disable exclude from main, for a repo or for everything.\\n        (e.g., ``yum --disableexcludes=\\'main\\'``)\\n\\n        .. versionadded:: 2014.7.0\\n\\n    name\\n        The name of the package to be upgraded. Note that this parameter is\\n        ignored if \"pkgs\" is passed.\\n\\n        32-bit packages can be upgraded on 64-bit systems by appending the\\n        architecture designation (``.i686``, ``.i586``, etc.) to the end of the\\n        package name.\\n\\n        Warning: if you forget \\'name=\\' and run pkg.upgrade openssl, ALL packages\\n        are upgraded. This will be addressed in next releases.\\n\\n        CLI Example:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade name=openssl\\n\\n        .. versionadded:: 2016.3.0\\n\\n    pkgs\\n        A list of packages to upgrade from a software repository. Must be\\n        passed as a python list. A specific version number can be specified\\n        by using a single-element dict representing the package and its\\n        version. If the package was not already installed on the system,\\n        it will not be installed.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade pkgs=\\'[\"foo\", \"bar\"]\\'\\n            salt \\'*\\' pkg.upgrade pkgs=\\'[\"foo\", {\"bar\": \"1.2.3-4.el5\"}]\\'\\n\\n        .. versionadded:: 2016.3.0\\n\\n    normalize : True\\n        Normalize the package name by removing the architecture. This is useful\\n        for poorly created packages which might include the architecture as an\\n        actual part of the name such as kernel modules which match a specific\\n        kernel version.\\n\\n        .. code-block:: bash\\n\\n            salt -G role:nsd pkg.upgrade gpfs.gplbin-2.6.32-279.31.1.el6.x86_64 normalize=False\\n\\n        .. versionadded:: 2016.3.0\\n\\n    minimal : False\\n        Use upgrade-minimal instead of upgrade (e.g., ``yum upgrade-minimal``)\\n        Goes to the \\'newest\\' package match which fixes a problem that affects your system.\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade minimal=True\\n\\n        .. versionadded:: 2019.2.0\\n\\n    obsoletes : True\\n        Controls whether yum/dnf should take obsoletes into account and remove them.\\n        If set to ``False`` yum will use ``update`` instead of ``upgrade``\\n        and dnf will be run with ``--obsoletes=False``\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.upgrade obsoletes=False\\n\\n        .. versionadded:: 2019.2.0\\n\\n    setopt\\n        A comma-separated or Python list of key=value options. This list will\\n        be expanded and ``--setopt`` prepended to each in the yum/dnf command\\n        that is run.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    diff_attr:\\n        If a list of package attributes is specified, returned value will\\n        contain them, eg.::\\n\\n            {\\'<package>\\': {\\n                \\'old\\': {\\n                    \\'version\\': \\'<old-version>\\',\\n                    \\'arch\\': \\'<old-arch>\\'},\\n\\n                \\'new\\': {\\n                    \\'version\\': \\'<new-version>\\',\\n                    \\'arch\\': \\'<new-arch>\\'}}}\\n\\n        Valid attributes are: ``epoch``, ``version``, ``release``, ``arch``,\\n        ``install_date``, ``install_date_time_t``.\\n\\n        If ``all`` is specified, all valid attributes will be returned.\\n\\n        .. versionadded:: 3006.0\\n\\n    .. note::\\n        To add extra arguments to the ``yum upgrade`` command, pass them as key\\n        word arguments. For arguments without assignments, pass ``True``\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.upgrade security=True exclude=\\'kernel*\\'\\n    '\n    if _yum() in ('dnf', 'dnf5') and (not obsoletes):\n        _setopt = [opt for opt in salt.utils.args.split_input(kwargs.pop('setopt', [])) if not opt.startswith('obsoletes=')]\n        _setopt.append('obsoletes=False')\n        kwargs['setopt'] = _setopt\n    options = _get_options(get_extra_options=True, **kwargs)\n    if salt.utils.data.is_true(refresh):\n        refresh_db(**kwargs)\n    old = list_pkgs(attr=diff_attr)\n    targets = []\n    if name or pkgs:\n        try:\n            pkg_params = __salt__['pkg_resource.parse_targets'](name=name, pkgs=pkgs, sources=None, normalize=normalize, **kwargs)[0]\n        except MinionError as exc:\n            raise CommandExecutionError(exc)\n        if pkg_params:\n            targets.extend(pkg_params)\n    cmd = ['--quiet', '-y']\n    cmd.extend(options)\n    if skip_verify:\n        cmd.append('--nogpgcheck')\n    if obsoletes:\n        cmd.append('upgrade' if not minimal else 'upgrade-minimal')\n    elif _yum() in ('dnf', 'dnf5'):\n        cmd.append('upgrade' if not minimal else 'upgrade-minimal')\n    else:\n        cmd.append('update' if not minimal else 'update-minimal')\n    cmd.extend(targets)\n    result = _call_yum(cmd)\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs(attr=diff_attr)\n    ret = salt.utils.data.compare_dicts(old, new)\n    if result['retcode'] != 0:\n        raise CommandExecutionError('Problem encountered upgrading packages', info={'changes': ret, 'result': result})\n    return ret"
        ]
    },
    {
        "func_name": "update",
        "original": "def update(name=None, pkgs=None, refresh=True, skip_verify=False, normalize=True, minimal=False, obsoletes=False, **kwargs):\n    \"\"\"\n    .. versionadded:: 2019.2.0\n\n    Calls :py:func:`pkg.upgrade <salt.modules.yumpkg.upgrade>` with\n    ``obsoletes=False``. Mirrors the CLI behavior of ``yum update``.\n    See :py:func:`pkg.upgrade <salt.modules.yumpkg.upgrade>` for\n    further documentation.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.update\n    \"\"\"\n    return upgrade(name, pkgs, refresh, skip_verify, normalize, minimal, obsoletes, **kwargs)",
        "mutated": [
            "def update(name=None, pkgs=None, refresh=True, skip_verify=False, normalize=True, minimal=False, obsoletes=False, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Calls :py:func:`pkg.upgrade <salt.modules.yumpkg.upgrade>` with\\n    ``obsoletes=False``. Mirrors the CLI behavior of ``yum update``.\\n    See :py:func:`pkg.upgrade <salt.modules.yumpkg.upgrade>` for\\n    further documentation.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.update\\n    \"\n    return upgrade(name, pkgs, refresh, skip_verify, normalize, minimal, obsoletes, **kwargs)",
            "def update(name=None, pkgs=None, refresh=True, skip_verify=False, normalize=True, minimal=False, obsoletes=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Calls :py:func:`pkg.upgrade <salt.modules.yumpkg.upgrade>` with\\n    ``obsoletes=False``. Mirrors the CLI behavior of ``yum update``.\\n    See :py:func:`pkg.upgrade <salt.modules.yumpkg.upgrade>` for\\n    further documentation.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.update\\n    \"\n    return upgrade(name, pkgs, refresh, skip_verify, normalize, minimal, obsoletes, **kwargs)",
            "def update(name=None, pkgs=None, refresh=True, skip_verify=False, normalize=True, minimal=False, obsoletes=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Calls :py:func:`pkg.upgrade <salt.modules.yumpkg.upgrade>` with\\n    ``obsoletes=False``. Mirrors the CLI behavior of ``yum update``.\\n    See :py:func:`pkg.upgrade <salt.modules.yumpkg.upgrade>` for\\n    further documentation.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.update\\n    \"\n    return upgrade(name, pkgs, refresh, skip_verify, normalize, minimal, obsoletes, **kwargs)",
            "def update(name=None, pkgs=None, refresh=True, skip_verify=False, normalize=True, minimal=False, obsoletes=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Calls :py:func:`pkg.upgrade <salt.modules.yumpkg.upgrade>` with\\n    ``obsoletes=False``. Mirrors the CLI behavior of ``yum update``.\\n    See :py:func:`pkg.upgrade <salt.modules.yumpkg.upgrade>` for\\n    further documentation.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.update\\n    \"\n    return upgrade(name, pkgs, refresh, skip_verify, normalize, minimal, obsoletes, **kwargs)",
            "def update(name=None, pkgs=None, refresh=True, skip_verify=False, normalize=True, minimal=False, obsoletes=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Calls :py:func:`pkg.upgrade <salt.modules.yumpkg.upgrade>` with\\n    ``obsoletes=False``. Mirrors the CLI behavior of ``yum update``.\\n    See :py:func:`pkg.upgrade <salt.modules.yumpkg.upgrade>` for\\n    further documentation.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.update\\n    \"\n    return upgrade(name, pkgs, refresh, skip_verify, normalize, minimal, obsoletes, **kwargs)"
        ]
    },
    {
        "func_name": "remove",
        "original": "def remove(name=None, pkgs=None, **kwargs):\n    \"\"\"\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\n        isolate commands which modify installed packages from the\n        ``salt-minion`` daemon's control group. This is done to keep systemd\n        from killing any yum/dnf commands spawned by Salt when the\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\n        ``False`` (no quotes).\n\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\n\n    Remove packages\n\n    name\n        The name of the package to be removed\n\n\n    Multiple Package Options:\n\n    pkgs\n        A list of packages to delete. Must be passed as a python list. The\n        ``name`` parameter will be ignored if this option is passed.\n\n    .. versionadded:: 0.16.0\n\n    split_arch : True\n        If set to False it prevents package name normalization by removing arch.\n\n        .. versionadded:: 3006.0\n\n\n    Returns a dict containing the changes.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.remove <package name>\n        salt '*' pkg.remove <package1>,<package2>,<package3>\n        salt '*' pkg.remove pkgs='[\"foo\", \"bar\"]'\n    \"\"\"\n    try:\n        pkg_params = __salt__['pkg_resource.parse_targets'](name, pkgs)[0]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = []\n    pkg_params = salt.utils.pkg.match_wildcard(old, pkg_params)\n    for target in pkg_params:\n        if target not in old:\n            continue\n        version_to_remove = pkg_params[target]\n        if target in old and (not version_to_remove):\n            targets.append(target)\n        elif target in old and version_to_remove in old[target].split(','):\n            arch = ''\n            pkgname = target\n            try:\n                (namepart, archpart) = pkgname.rsplit('.', 1)\n            except ValueError:\n                pass\n            else:\n                if archpart in salt.utils.pkg.rpm.ARCHES and (archpart != __grains__['osarch'] or kwargs.get('split_arch', True)):\n                    arch = '.' + archpart\n                    pkgname = namepart\n            targets.append('{}-{}{}'.format(pkgname, version_to_remove.split(':', 1)[-1], arch))\n    if not targets:\n        return {}\n    out = _call_yum(['-y', 'remove'] + targets)\n    if out['retcode'] != 0 and out['stderr']:\n        errors = [out['stderr']]\n    else:\n        errors = []\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Error occurred removing package(s)', info={'errors': errors, 'changes': ret})\n    return ret",
        "mutated": [
            "def remove(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n    '\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    Remove packages\\n\\n    name\\n        The name of the package to be removed\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n    split_arch : True\\n        If set to False it prevents package name normalization by removing arch.\\n\\n        .. versionadded:: 3006.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.remove <package name>\\n        salt \\'*\\' pkg.remove <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.remove pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    try:\n        pkg_params = __salt__['pkg_resource.parse_targets'](name, pkgs)[0]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = []\n    pkg_params = salt.utils.pkg.match_wildcard(old, pkg_params)\n    for target in pkg_params:\n        if target not in old:\n            continue\n        version_to_remove = pkg_params[target]\n        if target in old and (not version_to_remove):\n            targets.append(target)\n        elif target in old and version_to_remove in old[target].split(','):\n            arch = ''\n            pkgname = target\n            try:\n                (namepart, archpart) = pkgname.rsplit('.', 1)\n            except ValueError:\n                pass\n            else:\n                if archpart in salt.utils.pkg.rpm.ARCHES and (archpart != __grains__['osarch'] or kwargs.get('split_arch', True)):\n                    arch = '.' + archpart\n                    pkgname = namepart\n            targets.append('{}-{}{}'.format(pkgname, version_to_remove.split(':', 1)[-1], arch))\n    if not targets:\n        return {}\n    out = _call_yum(['-y', 'remove'] + targets)\n    if out['retcode'] != 0 and out['stderr']:\n        errors = [out['stderr']]\n    else:\n        errors = []\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Error occurred removing package(s)', info={'errors': errors, 'changes': ret})\n    return ret",
            "def remove(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    Remove packages\\n\\n    name\\n        The name of the package to be removed\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n    split_arch : True\\n        If set to False it prevents package name normalization by removing arch.\\n\\n        .. versionadded:: 3006.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.remove <package name>\\n        salt \\'*\\' pkg.remove <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.remove pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    try:\n        pkg_params = __salt__['pkg_resource.parse_targets'](name, pkgs)[0]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = []\n    pkg_params = salt.utils.pkg.match_wildcard(old, pkg_params)\n    for target in pkg_params:\n        if target not in old:\n            continue\n        version_to_remove = pkg_params[target]\n        if target in old and (not version_to_remove):\n            targets.append(target)\n        elif target in old and version_to_remove in old[target].split(','):\n            arch = ''\n            pkgname = target\n            try:\n                (namepart, archpart) = pkgname.rsplit('.', 1)\n            except ValueError:\n                pass\n            else:\n                if archpart in salt.utils.pkg.rpm.ARCHES and (archpart != __grains__['osarch'] or kwargs.get('split_arch', True)):\n                    arch = '.' + archpart\n                    pkgname = namepart\n            targets.append('{}-{}{}'.format(pkgname, version_to_remove.split(':', 1)[-1], arch))\n    if not targets:\n        return {}\n    out = _call_yum(['-y', 'remove'] + targets)\n    if out['retcode'] != 0 and out['stderr']:\n        errors = [out['stderr']]\n    else:\n        errors = []\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Error occurred removing package(s)', info={'errors': errors, 'changes': ret})\n    return ret",
            "def remove(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    Remove packages\\n\\n    name\\n        The name of the package to be removed\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n    split_arch : True\\n        If set to False it prevents package name normalization by removing arch.\\n\\n        .. versionadded:: 3006.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.remove <package name>\\n        salt \\'*\\' pkg.remove <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.remove pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    try:\n        pkg_params = __salt__['pkg_resource.parse_targets'](name, pkgs)[0]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = []\n    pkg_params = salt.utils.pkg.match_wildcard(old, pkg_params)\n    for target in pkg_params:\n        if target not in old:\n            continue\n        version_to_remove = pkg_params[target]\n        if target in old and (not version_to_remove):\n            targets.append(target)\n        elif target in old and version_to_remove in old[target].split(','):\n            arch = ''\n            pkgname = target\n            try:\n                (namepart, archpart) = pkgname.rsplit('.', 1)\n            except ValueError:\n                pass\n            else:\n                if archpart in salt.utils.pkg.rpm.ARCHES and (archpart != __grains__['osarch'] or kwargs.get('split_arch', True)):\n                    arch = '.' + archpart\n                    pkgname = namepart\n            targets.append('{}-{}{}'.format(pkgname, version_to_remove.split(':', 1)[-1], arch))\n    if not targets:\n        return {}\n    out = _call_yum(['-y', 'remove'] + targets)\n    if out['retcode'] != 0 and out['stderr']:\n        errors = [out['stderr']]\n    else:\n        errors = []\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Error occurred removing package(s)', info={'errors': errors, 'changes': ret})\n    return ret",
            "def remove(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    Remove packages\\n\\n    name\\n        The name of the package to be removed\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n    split_arch : True\\n        If set to False it prevents package name normalization by removing arch.\\n\\n        .. versionadded:: 3006.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.remove <package name>\\n        salt \\'*\\' pkg.remove <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.remove pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    try:\n        pkg_params = __salt__['pkg_resource.parse_targets'](name, pkgs)[0]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = []\n    pkg_params = salt.utils.pkg.match_wildcard(old, pkg_params)\n    for target in pkg_params:\n        if target not in old:\n            continue\n        version_to_remove = pkg_params[target]\n        if target in old and (not version_to_remove):\n            targets.append(target)\n        elif target in old and version_to_remove in old[target].split(','):\n            arch = ''\n            pkgname = target\n            try:\n                (namepart, archpart) = pkgname.rsplit('.', 1)\n            except ValueError:\n                pass\n            else:\n                if archpart in salt.utils.pkg.rpm.ARCHES and (archpart != __grains__['osarch'] or kwargs.get('split_arch', True)):\n                    arch = '.' + archpart\n                    pkgname = namepart\n            targets.append('{}-{}{}'.format(pkgname, version_to_remove.split(':', 1)[-1], arch))\n    if not targets:\n        return {}\n    out = _call_yum(['-y', 'remove'] + targets)\n    if out['retcode'] != 0 and out['stderr']:\n        errors = [out['stderr']]\n    else:\n        errors = []\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Error occurred removing package(s)', info={'errors': errors, 'changes': ret})\n    return ret",
            "def remove(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    Remove packages\\n\\n    name\\n        The name of the package to be removed\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n    split_arch : True\\n        If set to False it prevents package name normalization by removing arch.\\n\\n        .. versionadded:: 3006.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.remove <package name>\\n        salt \\'*\\' pkg.remove <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.remove pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    try:\n        pkg_params = __salt__['pkg_resource.parse_targets'](name, pkgs)[0]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = []\n    pkg_params = salt.utils.pkg.match_wildcard(old, pkg_params)\n    for target in pkg_params:\n        if target not in old:\n            continue\n        version_to_remove = pkg_params[target]\n        if target in old and (not version_to_remove):\n            targets.append(target)\n        elif target in old and version_to_remove in old[target].split(','):\n            arch = ''\n            pkgname = target\n            try:\n                (namepart, archpart) = pkgname.rsplit('.', 1)\n            except ValueError:\n                pass\n            else:\n                if archpart in salt.utils.pkg.rpm.ARCHES and (archpart != __grains__['osarch'] or kwargs.get('split_arch', True)):\n                    arch = '.' + archpart\n                    pkgname = namepart\n            targets.append('{}-{}{}'.format(pkgname, version_to_remove.split(':', 1)[-1], arch))\n    if not targets:\n        return {}\n    out = _call_yum(['-y', 'remove'] + targets)\n    if out['retcode'] != 0 and out['stderr']:\n        errors = [out['stderr']]\n    else:\n        errors = []\n    __context__.pop('pkg.list_pkgs', None)\n    new = list_pkgs()\n    ret = salt.utils.data.compare_dicts(old, new)\n    if errors:\n        raise CommandExecutionError('Error occurred removing package(s)', info={'errors': errors, 'changes': ret})\n    return ret"
        ]
    },
    {
        "func_name": "purge",
        "original": "def purge(name=None, pkgs=None, **kwargs):\n    \"\"\"\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\n        isolate commands which modify installed packages from the\n        ``salt-minion`` daemon's control group. This is done to keep systemd\n        from killing any yum/dnf commands spawned by Salt when the\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\n        ``False`` (no quotes).\n\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\n\n    Package purges are not supported by yum, this function is identical to\n    :mod:`pkg.remove <salt.modules.yumpkg.remove>`.\n\n    name\n        The name of the package to be purged\n\n\n    Multiple Package Options:\n\n    pkgs\n        A list of packages to delete. Must be passed as a python list. The\n        ``name`` parameter will be ignored if this option is passed.\n\n    .. versionadded:: 0.16.0\n\n\n    Returns a dict containing the changes.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.purge <package name>\n        salt '*' pkg.purge <package1>,<package2>,<package3>\n        salt '*' pkg.purge pkgs='[\"foo\", \"bar\"]'\n    \"\"\"\n    return remove(name=name, pkgs=pkgs)",
        "mutated": [
            "def purge(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n    '\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    Package purges are not supported by yum, this function is identical to\\n    :mod:`pkg.remove <salt.modules.yumpkg.remove>`.\\n\\n    name\\n        The name of the package to be purged\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.purge <package name>\\n        salt \\'*\\' pkg.purge <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.purge pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    return remove(name=name, pkgs=pkgs)",
            "def purge(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    Package purges are not supported by yum, this function is identical to\\n    :mod:`pkg.remove <salt.modules.yumpkg.remove>`.\\n\\n    name\\n        The name of the package to be purged\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.purge <package name>\\n        salt \\'*\\' pkg.purge <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.purge pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    return remove(name=name, pkgs=pkgs)",
            "def purge(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    Package purges are not supported by yum, this function is identical to\\n    :mod:`pkg.remove <salt.modules.yumpkg.remove>`.\\n\\n    name\\n        The name of the package to be purged\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.purge <package name>\\n        salt \\'*\\' pkg.purge <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.purge pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    return remove(name=name, pkgs=pkgs)",
            "def purge(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    Package purges are not supported by yum, this function is identical to\\n    :mod:`pkg.remove <salt.modules.yumpkg.remove>`.\\n\\n    name\\n        The name of the package to be purged\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.purge <package name>\\n        salt \\'*\\' pkg.purge <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.purge pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    return remove(name=name, pkgs=pkgs)",
            "def purge(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0\\n        On minions running systemd>=205, `systemd-run(1)`_ is now used to\\n        isolate commands which modify installed packages from the\\n        ``salt-minion`` daemon\\'s control group. This is done to keep systemd\\n        from killing any yum/dnf commands spawned by Salt when the\\n        ``salt-minion`` service is restarted. (see ``KillMode`` in the\\n        `systemd.kill(5)`_ manpage for more information). If desired, usage of\\n        `systemd-run(1)`_ can be suppressed by setting a :mod:`config option\\n        <salt.modules.config.get>` called ``systemd.scope``, with a value of\\n        ``False`` (no quotes).\\n\\n    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html\\n    .. _`systemd.kill(5)`: https://www.freedesktop.org/software/systemd/man/systemd.kill.html\\n\\n    Package purges are not supported by yum, this function is identical to\\n    :mod:`pkg.remove <salt.modules.yumpkg.remove>`.\\n\\n    name\\n        The name of the package to be purged\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.purge <package name>\\n        salt \\'*\\' pkg.purge <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.purge pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    return remove(name=name, pkgs=pkgs)"
        ]
    },
    {
        "func_name": "hold",
        "original": "def hold(name=None, pkgs=None, sources=None, normalize=True, **kwargs):\n    \"\"\"\n    .. versionadded:: 2014.7.0\n\n    Version-lock packages\n\n    .. note::\n        Requires the appropriate ``versionlock`` plugin package to be installed:\n\n        - On RHEL 5: ``yum-versionlock``\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\n\n\n    name\n        The name of the package to be held.\n\n    Multiple Package Options:\n\n    pkgs\n        A list of packages to hold. Must be passed as a python list. The\n        ``name`` parameter will be ignored if this option is passed.\n\n    Returns a dict containing the changes.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.hold <package name>\n        salt '*' pkg.hold pkgs='[\"foo\", \"bar\"]'\n    \"\"\"\n    _check_versionlock()\n    if not name and (not pkgs) and (not sources):\n        raise SaltInvocationError('One of name, pkgs, or sources must be specified.')\n    if pkgs and sources:\n        raise SaltInvocationError('Only one of pkgs or sources can be specified.')\n    targets = []\n    if pkgs:\n        targets.extend(pkgs)\n    elif sources:\n        for source in sources:\n            targets.append(next(iter(source.keys())))\n    else:\n        targets.append(name)\n    current_locks = list_holds(full=False)\n    ret = {}\n    for target in targets:\n        if isinstance(target, dict):\n            target = next(iter(target.keys()))\n        ret[target] = {'name': target, 'changes': {}, 'result': False, 'comment': ''}\n        if target not in current_locks:\n            if 'test' in __opts__ and __opts__['test']:\n                ret[target].update(result=None)\n                ret[target]['comment'] = f'Package {target} is set to be held.'\n            else:\n                out = _call_yum(['versionlock', target])\n                if out['retcode'] == 0:\n                    ret[target].update(result=True)\n                    ret[target]['comment'] = 'Package {} is now being held.'.format(target)\n                    ret[target]['changes']['new'] = 'hold'\n                    ret[target]['changes']['old'] = ''\n                else:\n                    ret[target]['comment'] = 'Package {} was unable to be held.'.format(target)\n        else:\n            ret[target].update(result=True)\n            ret[target]['comment'] = 'Package {} is already set to be held.'.format(target)\n    return ret",
        "mutated": [
            "def hold(name=None, pkgs=None, sources=None, normalize=True, **kwargs):\n    if False:\n        i = 10\n    '\\n    .. versionadded:: 2014.7.0\\n\\n    Version-lock packages\\n\\n    .. note::\\n        Requires the appropriate ``versionlock`` plugin package to be installed:\\n\\n        - On RHEL 5: ``yum-versionlock``\\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\\n\\n\\n    name\\n        The name of the package to be held.\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to hold. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.hold <package name>\\n        salt \\'*\\' pkg.hold pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    _check_versionlock()\n    if not name and (not pkgs) and (not sources):\n        raise SaltInvocationError('One of name, pkgs, or sources must be specified.')\n    if pkgs and sources:\n        raise SaltInvocationError('Only one of pkgs or sources can be specified.')\n    targets = []\n    if pkgs:\n        targets.extend(pkgs)\n    elif sources:\n        for source in sources:\n            targets.append(next(iter(source.keys())))\n    else:\n        targets.append(name)\n    current_locks = list_holds(full=False)\n    ret = {}\n    for target in targets:\n        if isinstance(target, dict):\n            target = next(iter(target.keys()))\n        ret[target] = {'name': target, 'changes': {}, 'result': False, 'comment': ''}\n        if target not in current_locks:\n            if 'test' in __opts__ and __opts__['test']:\n                ret[target].update(result=None)\n                ret[target]['comment'] = f'Package {target} is set to be held.'\n            else:\n                out = _call_yum(['versionlock', target])\n                if out['retcode'] == 0:\n                    ret[target].update(result=True)\n                    ret[target]['comment'] = 'Package {} is now being held.'.format(target)\n                    ret[target]['changes']['new'] = 'hold'\n                    ret[target]['changes']['old'] = ''\n                else:\n                    ret[target]['comment'] = 'Package {} was unable to be held.'.format(target)\n        else:\n            ret[target].update(result=True)\n            ret[target]['comment'] = 'Package {} is already set to be held.'.format(target)\n    return ret",
            "def hold(name=None, pkgs=None, sources=None, normalize=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    .. versionadded:: 2014.7.0\\n\\n    Version-lock packages\\n\\n    .. note::\\n        Requires the appropriate ``versionlock`` plugin package to be installed:\\n\\n        - On RHEL 5: ``yum-versionlock``\\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\\n\\n\\n    name\\n        The name of the package to be held.\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to hold. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.hold <package name>\\n        salt \\'*\\' pkg.hold pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    _check_versionlock()\n    if not name and (not pkgs) and (not sources):\n        raise SaltInvocationError('One of name, pkgs, or sources must be specified.')\n    if pkgs and sources:\n        raise SaltInvocationError('Only one of pkgs or sources can be specified.')\n    targets = []\n    if pkgs:\n        targets.extend(pkgs)\n    elif sources:\n        for source in sources:\n            targets.append(next(iter(source.keys())))\n    else:\n        targets.append(name)\n    current_locks = list_holds(full=False)\n    ret = {}\n    for target in targets:\n        if isinstance(target, dict):\n            target = next(iter(target.keys()))\n        ret[target] = {'name': target, 'changes': {}, 'result': False, 'comment': ''}\n        if target not in current_locks:\n            if 'test' in __opts__ and __opts__['test']:\n                ret[target].update(result=None)\n                ret[target]['comment'] = f'Package {target} is set to be held.'\n            else:\n                out = _call_yum(['versionlock', target])\n                if out['retcode'] == 0:\n                    ret[target].update(result=True)\n                    ret[target]['comment'] = 'Package {} is now being held.'.format(target)\n                    ret[target]['changes']['new'] = 'hold'\n                    ret[target]['changes']['old'] = ''\n                else:\n                    ret[target]['comment'] = 'Package {} was unable to be held.'.format(target)\n        else:\n            ret[target].update(result=True)\n            ret[target]['comment'] = 'Package {} is already set to be held.'.format(target)\n    return ret",
            "def hold(name=None, pkgs=None, sources=None, normalize=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    .. versionadded:: 2014.7.0\\n\\n    Version-lock packages\\n\\n    .. note::\\n        Requires the appropriate ``versionlock`` plugin package to be installed:\\n\\n        - On RHEL 5: ``yum-versionlock``\\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\\n\\n\\n    name\\n        The name of the package to be held.\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to hold. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.hold <package name>\\n        salt \\'*\\' pkg.hold pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    _check_versionlock()\n    if not name and (not pkgs) and (not sources):\n        raise SaltInvocationError('One of name, pkgs, or sources must be specified.')\n    if pkgs and sources:\n        raise SaltInvocationError('Only one of pkgs or sources can be specified.')\n    targets = []\n    if pkgs:\n        targets.extend(pkgs)\n    elif sources:\n        for source in sources:\n            targets.append(next(iter(source.keys())))\n    else:\n        targets.append(name)\n    current_locks = list_holds(full=False)\n    ret = {}\n    for target in targets:\n        if isinstance(target, dict):\n            target = next(iter(target.keys()))\n        ret[target] = {'name': target, 'changes': {}, 'result': False, 'comment': ''}\n        if target not in current_locks:\n            if 'test' in __opts__ and __opts__['test']:\n                ret[target].update(result=None)\n                ret[target]['comment'] = f'Package {target} is set to be held.'\n            else:\n                out = _call_yum(['versionlock', target])\n                if out['retcode'] == 0:\n                    ret[target].update(result=True)\n                    ret[target]['comment'] = 'Package {} is now being held.'.format(target)\n                    ret[target]['changes']['new'] = 'hold'\n                    ret[target]['changes']['old'] = ''\n                else:\n                    ret[target]['comment'] = 'Package {} was unable to be held.'.format(target)\n        else:\n            ret[target].update(result=True)\n            ret[target]['comment'] = 'Package {} is already set to be held.'.format(target)\n    return ret",
            "def hold(name=None, pkgs=None, sources=None, normalize=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    .. versionadded:: 2014.7.0\\n\\n    Version-lock packages\\n\\n    .. note::\\n        Requires the appropriate ``versionlock`` plugin package to be installed:\\n\\n        - On RHEL 5: ``yum-versionlock``\\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\\n\\n\\n    name\\n        The name of the package to be held.\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to hold. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.hold <package name>\\n        salt \\'*\\' pkg.hold pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    _check_versionlock()\n    if not name and (not pkgs) and (not sources):\n        raise SaltInvocationError('One of name, pkgs, or sources must be specified.')\n    if pkgs and sources:\n        raise SaltInvocationError('Only one of pkgs or sources can be specified.')\n    targets = []\n    if pkgs:\n        targets.extend(pkgs)\n    elif sources:\n        for source in sources:\n            targets.append(next(iter(source.keys())))\n    else:\n        targets.append(name)\n    current_locks = list_holds(full=False)\n    ret = {}\n    for target in targets:\n        if isinstance(target, dict):\n            target = next(iter(target.keys()))\n        ret[target] = {'name': target, 'changes': {}, 'result': False, 'comment': ''}\n        if target not in current_locks:\n            if 'test' in __opts__ and __opts__['test']:\n                ret[target].update(result=None)\n                ret[target]['comment'] = f'Package {target} is set to be held.'\n            else:\n                out = _call_yum(['versionlock', target])\n                if out['retcode'] == 0:\n                    ret[target].update(result=True)\n                    ret[target]['comment'] = 'Package {} is now being held.'.format(target)\n                    ret[target]['changes']['new'] = 'hold'\n                    ret[target]['changes']['old'] = ''\n                else:\n                    ret[target]['comment'] = 'Package {} was unable to be held.'.format(target)\n        else:\n            ret[target].update(result=True)\n            ret[target]['comment'] = 'Package {} is already set to be held.'.format(target)\n    return ret",
            "def hold(name=None, pkgs=None, sources=None, normalize=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    .. versionadded:: 2014.7.0\\n\\n    Version-lock packages\\n\\n    .. note::\\n        Requires the appropriate ``versionlock`` plugin package to be installed:\\n\\n        - On RHEL 5: ``yum-versionlock``\\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\\n\\n\\n    name\\n        The name of the package to be held.\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to hold. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.hold <package name>\\n        salt \\'*\\' pkg.hold pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    _check_versionlock()\n    if not name and (not pkgs) and (not sources):\n        raise SaltInvocationError('One of name, pkgs, or sources must be specified.')\n    if pkgs and sources:\n        raise SaltInvocationError('Only one of pkgs or sources can be specified.')\n    targets = []\n    if pkgs:\n        targets.extend(pkgs)\n    elif sources:\n        for source in sources:\n            targets.append(next(iter(source.keys())))\n    else:\n        targets.append(name)\n    current_locks = list_holds(full=False)\n    ret = {}\n    for target in targets:\n        if isinstance(target, dict):\n            target = next(iter(target.keys()))\n        ret[target] = {'name': target, 'changes': {}, 'result': False, 'comment': ''}\n        if target not in current_locks:\n            if 'test' in __opts__ and __opts__['test']:\n                ret[target].update(result=None)\n                ret[target]['comment'] = f'Package {target} is set to be held.'\n            else:\n                out = _call_yum(['versionlock', target])\n                if out['retcode'] == 0:\n                    ret[target].update(result=True)\n                    ret[target]['comment'] = 'Package {} is now being held.'.format(target)\n                    ret[target]['changes']['new'] = 'hold'\n                    ret[target]['changes']['old'] = ''\n                else:\n                    ret[target]['comment'] = 'Package {} was unable to be held.'.format(target)\n        else:\n            ret[target].update(result=True)\n            ret[target]['comment'] = 'Package {} is already set to be held.'.format(target)\n    return ret"
        ]
    },
    {
        "func_name": "unhold",
        "original": "def unhold(name=None, pkgs=None, sources=None, **kwargs):\n    \"\"\"\n    .. versionadded:: 2014.7.0\n\n    Remove version locks\n\n    .. note::\n        Requires the appropriate ``versionlock`` plugin package to be installed:\n\n        - On RHEL 5: ``yum-versionlock``\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\n\n\n    name\n        The name of the package to be unheld\n\n    Multiple Package Options:\n\n    pkgs\n        A list of packages to unhold. Must be passed as a python list. The\n        ``name`` parameter will be ignored if this option is passed.\n\n    Returns a dict containing the changes.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.unhold <package name>\n        salt '*' pkg.unhold pkgs='[\"foo\", \"bar\"]'\n    \"\"\"\n    _check_versionlock()\n    if not name and (not pkgs) and (not sources):\n        raise SaltInvocationError('One of name, pkgs, or sources must be specified.')\n    if pkgs and sources:\n        raise SaltInvocationError('Only one of pkgs or sources can be specified.')\n    targets = []\n    if pkgs:\n        targets.extend(pkgs)\n    elif sources:\n        for source in sources:\n            targets.append(next(iter(source)))\n    else:\n        targets.append(name)\n    current_locks = list_holds(full=_yum() == 'yum')\n    ret = {}\n    for target in targets:\n        if isinstance(target, dict):\n            target = next(iter(target.keys()))\n        ret[target] = {'name': target, 'changes': {}, 'result': False, 'comment': ''}\n        if _yum() in ('dnf', 'dnf5'):\n            search_locks = [x for x in current_locks if x == target]\n        else:\n            search_locks = [x for x in current_locks if fnmatch.fnmatch(x, f'*{target}*') and target == _get_hold(x, full=False)]\n        if search_locks:\n            if __opts__['test']:\n                ret[target].update(result=None)\n                ret[target]['comment'] = 'Package {} is set to be unheld.'.format(target)\n            else:\n                out = _call_yum(['versionlock', 'delete'] + search_locks)\n                if out['retcode'] == 0:\n                    ret[target].update(result=True)\n                    ret[target]['comment'] = 'Package {} is no longer held.'.format(target)\n                    ret[target]['changes']['new'] = ''\n                    ret[target]['changes']['old'] = 'hold'\n                else:\n                    ret[target]['comment'] = f'Package {target} was unable to be unheld.'\n        else:\n            ret[target].update(result=True)\n            ret[target]['comment'] = f'Package {target} is not being held.'\n    return ret",
        "mutated": [
            "def unhold(name=None, pkgs=None, sources=None, **kwargs):\n    if False:\n        i = 10\n    '\\n    .. versionadded:: 2014.7.0\\n\\n    Remove version locks\\n\\n    .. note::\\n        Requires the appropriate ``versionlock`` plugin package to be installed:\\n\\n        - On RHEL 5: ``yum-versionlock``\\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\\n\\n\\n    name\\n        The name of the package to be unheld\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to unhold. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.unhold <package name>\\n        salt \\'*\\' pkg.unhold pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    _check_versionlock()\n    if not name and (not pkgs) and (not sources):\n        raise SaltInvocationError('One of name, pkgs, or sources must be specified.')\n    if pkgs and sources:\n        raise SaltInvocationError('Only one of pkgs or sources can be specified.')\n    targets = []\n    if pkgs:\n        targets.extend(pkgs)\n    elif sources:\n        for source in sources:\n            targets.append(next(iter(source)))\n    else:\n        targets.append(name)\n    current_locks = list_holds(full=_yum() == 'yum')\n    ret = {}\n    for target in targets:\n        if isinstance(target, dict):\n            target = next(iter(target.keys()))\n        ret[target] = {'name': target, 'changes': {}, 'result': False, 'comment': ''}\n        if _yum() in ('dnf', 'dnf5'):\n            search_locks = [x for x in current_locks if x == target]\n        else:\n            search_locks = [x for x in current_locks if fnmatch.fnmatch(x, f'*{target}*') and target == _get_hold(x, full=False)]\n        if search_locks:\n            if __opts__['test']:\n                ret[target].update(result=None)\n                ret[target]['comment'] = 'Package {} is set to be unheld.'.format(target)\n            else:\n                out = _call_yum(['versionlock', 'delete'] + search_locks)\n                if out['retcode'] == 0:\n                    ret[target].update(result=True)\n                    ret[target]['comment'] = 'Package {} is no longer held.'.format(target)\n                    ret[target]['changes']['new'] = ''\n                    ret[target]['changes']['old'] = 'hold'\n                else:\n                    ret[target]['comment'] = f'Package {target} was unable to be unheld.'\n        else:\n            ret[target].update(result=True)\n            ret[target]['comment'] = f'Package {target} is not being held.'\n    return ret",
            "def unhold(name=None, pkgs=None, sources=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    .. versionadded:: 2014.7.0\\n\\n    Remove version locks\\n\\n    .. note::\\n        Requires the appropriate ``versionlock`` plugin package to be installed:\\n\\n        - On RHEL 5: ``yum-versionlock``\\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\\n\\n\\n    name\\n        The name of the package to be unheld\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to unhold. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.unhold <package name>\\n        salt \\'*\\' pkg.unhold pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    _check_versionlock()\n    if not name and (not pkgs) and (not sources):\n        raise SaltInvocationError('One of name, pkgs, or sources must be specified.')\n    if pkgs and sources:\n        raise SaltInvocationError('Only one of pkgs or sources can be specified.')\n    targets = []\n    if pkgs:\n        targets.extend(pkgs)\n    elif sources:\n        for source in sources:\n            targets.append(next(iter(source)))\n    else:\n        targets.append(name)\n    current_locks = list_holds(full=_yum() == 'yum')\n    ret = {}\n    for target in targets:\n        if isinstance(target, dict):\n            target = next(iter(target.keys()))\n        ret[target] = {'name': target, 'changes': {}, 'result': False, 'comment': ''}\n        if _yum() in ('dnf', 'dnf5'):\n            search_locks = [x for x in current_locks if x == target]\n        else:\n            search_locks = [x for x in current_locks if fnmatch.fnmatch(x, f'*{target}*') and target == _get_hold(x, full=False)]\n        if search_locks:\n            if __opts__['test']:\n                ret[target].update(result=None)\n                ret[target]['comment'] = 'Package {} is set to be unheld.'.format(target)\n            else:\n                out = _call_yum(['versionlock', 'delete'] + search_locks)\n                if out['retcode'] == 0:\n                    ret[target].update(result=True)\n                    ret[target]['comment'] = 'Package {} is no longer held.'.format(target)\n                    ret[target]['changes']['new'] = ''\n                    ret[target]['changes']['old'] = 'hold'\n                else:\n                    ret[target]['comment'] = f'Package {target} was unable to be unheld.'\n        else:\n            ret[target].update(result=True)\n            ret[target]['comment'] = f'Package {target} is not being held.'\n    return ret",
            "def unhold(name=None, pkgs=None, sources=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    .. versionadded:: 2014.7.0\\n\\n    Remove version locks\\n\\n    .. note::\\n        Requires the appropriate ``versionlock`` plugin package to be installed:\\n\\n        - On RHEL 5: ``yum-versionlock``\\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\\n\\n\\n    name\\n        The name of the package to be unheld\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to unhold. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.unhold <package name>\\n        salt \\'*\\' pkg.unhold pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    _check_versionlock()\n    if not name and (not pkgs) and (not sources):\n        raise SaltInvocationError('One of name, pkgs, or sources must be specified.')\n    if pkgs and sources:\n        raise SaltInvocationError('Only one of pkgs or sources can be specified.')\n    targets = []\n    if pkgs:\n        targets.extend(pkgs)\n    elif sources:\n        for source in sources:\n            targets.append(next(iter(source)))\n    else:\n        targets.append(name)\n    current_locks = list_holds(full=_yum() == 'yum')\n    ret = {}\n    for target in targets:\n        if isinstance(target, dict):\n            target = next(iter(target.keys()))\n        ret[target] = {'name': target, 'changes': {}, 'result': False, 'comment': ''}\n        if _yum() in ('dnf', 'dnf5'):\n            search_locks = [x for x in current_locks if x == target]\n        else:\n            search_locks = [x for x in current_locks if fnmatch.fnmatch(x, f'*{target}*') and target == _get_hold(x, full=False)]\n        if search_locks:\n            if __opts__['test']:\n                ret[target].update(result=None)\n                ret[target]['comment'] = 'Package {} is set to be unheld.'.format(target)\n            else:\n                out = _call_yum(['versionlock', 'delete'] + search_locks)\n                if out['retcode'] == 0:\n                    ret[target].update(result=True)\n                    ret[target]['comment'] = 'Package {} is no longer held.'.format(target)\n                    ret[target]['changes']['new'] = ''\n                    ret[target]['changes']['old'] = 'hold'\n                else:\n                    ret[target]['comment'] = f'Package {target} was unable to be unheld.'\n        else:\n            ret[target].update(result=True)\n            ret[target]['comment'] = f'Package {target} is not being held.'\n    return ret",
            "def unhold(name=None, pkgs=None, sources=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    .. versionadded:: 2014.7.0\\n\\n    Remove version locks\\n\\n    .. note::\\n        Requires the appropriate ``versionlock`` plugin package to be installed:\\n\\n        - On RHEL 5: ``yum-versionlock``\\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\\n\\n\\n    name\\n        The name of the package to be unheld\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to unhold. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.unhold <package name>\\n        salt \\'*\\' pkg.unhold pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    _check_versionlock()\n    if not name and (not pkgs) and (not sources):\n        raise SaltInvocationError('One of name, pkgs, or sources must be specified.')\n    if pkgs and sources:\n        raise SaltInvocationError('Only one of pkgs or sources can be specified.')\n    targets = []\n    if pkgs:\n        targets.extend(pkgs)\n    elif sources:\n        for source in sources:\n            targets.append(next(iter(source)))\n    else:\n        targets.append(name)\n    current_locks = list_holds(full=_yum() == 'yum')\n    ret = {}\n    for target in targets:\n        if isinstance(target, dict):\n            target = next(iter(target.keys()))\n        ret[target] = {'name': target, 'changes': {}, 'result': False, 'comment': ''}\n        if _yum() in ('dnf', 'dnf5'):\n            search_locks = [x for x in current_locks if x == target]\n        else:\n            search_locks = [x for x in current_locks if fnmatch.fnmatch(x, f'*{target}*') and target == _get_hold(x, full=False)]\n        if search_locks:\n            if __opts__['test']:\n                ret[target].update(result=None)\n                ret[target]['comment'] = 'Package {} is set to be unheld.'.format(target)\n            else:\n                out = _call_yum(['versionlock', 'delete'] + search_locks)\n                if out['retcode'] == 0:\n                    ret[target].update(result=True)\n                    ret[target]['comment'] = 'Package {} is no longer held.'.format(target)\n                    ret[target]['changes']['new'] = ''\n                    ret[target]['changes']['old'] = 'hold'\n                else:\n                    ret[target]['comment'] = f'Package {target} was unable to be unheld.'\n        else:\n            ret[target].update(result=True)\n            ret[target]['comment'] = f'Package {target} is not being held.'\n    return ret",
            "def unhold(name=None, pkgs=None, sources=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    .. versionadded:: 2014.7.0\\n\\n    Remove version locks\\n\\n    .. note::\\n        Requires the appropriate ``versionlock`` plugin package to be installed:\\n\\n        - On RHEL 5: ``yum-versionlock``\\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\\n\\n\\n    name\\n        The name of the package to be unheld\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to unhold. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.unhold <package name>\\n        salt \\'*\\' pkg.unhold pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    _check_versionlock()\n    if not name and (not pkgs) and (not sources):\n        raise SaltInvocationError('One of name, pkgs, or sources must be specified.')\n    if pkgs and sources:\n        raise SaltInvocationError('Only one of pkgs or sources can be specified.')\n    targets = []\n    if pkgs:\n        targets.extend(pkgs)\n    elif sources:\n        for source in sources:\n            targets.append(next(iter(source)))\n    else:\n        targets.append(name)\n    current_locks = list_holds(full=_yum() == 'yum')\n    ret = {}\n    for target in targets:\n        if isinstance(target, dict):\n            target = next(iter(target.keys()))\n        ret[target] = {'name': target, 'changes': {}, 'result': False, 'comment': ''}\n        if _yum() in ('dnf', 'dnf5'):\n            search_locks = [x for x in current_locks if x == target]\n        else:\n            search_locks = [x for x in current_locks if fnmatch.fnmatch(x, f'*{target}*') and target == _get_hold(x, full=False)]\n        if search_locks:\n            if __opts__['test']:\n                ret[target].update(result=None)\n                ret[target]['comment'] = 'Package {} is set to be unheld.'.format(target)\n            else:\n                out = _call_yum(['versionlock', 'delete'] + search_locks)\n                if out['retcode'] == 0:\n                    ret[target].update(result=True)\n                    ret[target]['comment'] = 'Package {} is no longer held.'.format(target)\n                    ret[target]['changes']['new'] = ''\n                    ret[target]['changes']['old'] = 'hold'\n                else:\n                    ret[target]['comment'] = f'Package {target} was unable to be unheld.'\n        else:\n            ret[target].update(result=True)\n            ret[target]['comment'] = f'Package {target} is not being held.'\n    return ret"
        ]
    },
    {
        "func_name": "list_holds",
        "original": "def list_holds(pattern=__HOLD_PATTERN, full=True):\n    \"\"\"\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0\n        Function renamed from ``pkg.get_locked_pkgs`` to ``pkg.list_holds``.\n\n    List information on locked packages\n\n    .. note::\n        Requires the appropriate ``versionlock`` plugin package to be installed:\n\n        - On RHEL 5: ``yum-versionlock``\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\n\n    pattern : \\\\w+(?:[.-][^-]+)*\n        Regular expression used to match the package name\n\n    full : True\n        Show the full hold definition including version and epoch. Set to\n        ``False`` to return just the name of the package(s) being held.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.list_holds\n        salt '*' pkg.list_holds full=False\n    \"\"\"\n    _check_versionlock()\n    out = __salt__['cmd.run']([_yum(), 'versionlock', 'list'], python_shell=False)\n    ret = []\n    for line in salt.utils.itertools.split(out, '\\n'):\n        match = _get_hold(line, pattern=pattern, full=full)\n        if match is not None:\n            ret.append(match)\n    return ret",
        "mutated": [
            "def list_holds(pattern=__HOLD_PATTERN, full=True):\n    if False:\n        i = 10\n    \"\\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0\\n        Function renamed from ``pkg.get_locked_pkgs`` to ``pkg.list_holds``.\\n\\n    List information on locked packages\\n\\n    .. note::\\n        Requires the appropriate ``versionlock`` plugin package to be installed:\\n\\n        - On RHEL 5: ``yum-versionlock``\\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\\n\\n    pattern : \\\\w+(?:[.-][^-]+)*\\n        Regular expression used to match the package name\\n\\n    full : True\\n        Show the full hold definition including version and epoch. Set to\\n        ``False`` to return just the name of the package(s) being held.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_holds\\n        salt '*' pkg.list_holds full=False\\n    \"\n    _check_versionlock()\n    out = __salt__['cmd.run']([_yum(), 'versionlock', 'list'], python_shell=False)\n    ret = []\n    for line in salt.utils.itertools.split(out, '\\n'):\n        match = _get_hold(line, pattern=pattern, full=full)\n        if match is not None:\n            ret.append(match)\n    return ret",
            "def list_holds(pattern=__HOLD_PATTERN, full=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0\\n        Function renamed from ``pkg.get_locked_pkgs`` to ``pkg.list_holds``.\\n\\n    List information on locked packages\\n\\n    .. note::\\n        Requires the appropriate ``versionlock`` plugin package to be installed:\\n\\n        - On RHEL 5: ``yum-versionlock``\\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\\n\\n    pattern : \\\\w+(?:[.-][^-]+)*\\n        Regular expression used to match the package name\\n\\n    full : True\\n        Show the full hold definition including version and epoch. Set to\\n        ``False`` to return just the name of the package(s) being held.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_holds\\n        salt '*' pkg.list_holds full=False\\n    \"\n    _check_versionlock()\n    out = __salt__['cmd.run']([_yum(), 'versionlock', 'list'], python_shell=False)\n    ret = []\n    for line in salt.utils.itertools.split(out, '\\n'):\n        match = _get_hold(line, pattern=pattern, full=full)\n        if match is not None:\n            ret.append(match)\n    return ret",
            "def list_holds(pattern=__HOLD_PATTERN, full=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0\\n        Function renamed from ``pkg.get_locked_pkgs`` to ``pkg.list_holds``.\\n\\n    List information on locked packages\\n\\n    .. note::\\n        Requires the appropriate ``versionlock`` plugin package to be installed:\\n\\n        - On RHEL 5: ``yum-versionlock``\\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\\n\\n    pattern : \\\\w+(?:[.-][^-]+)*\\n        Regular expression used to match the package name\\n\\n    full : True\\n        Show the full hold definition including version and epoch. Set to\\n        ``False`` to return just the name of the package(s) being held.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_holds\\n        salt '*' pkg.list_holds full=False\\n    \"\n    _check_versionlock()\n    out = __salt__['cmd.run']([_yum(), 'versionlock', 'list'], python_shell=False)\n    ret = []\n    for line in salt.utils.itertools.split(out, '\\n'):\n        match = _get_hold(line, pattern=pattern, full=full)\n        if match is not None:\n            ret.append(match)\n    return ret",
            "def list_holds(pattern=__HOLD_PATTERN, full=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0\\n        Function renamed from ``pkg.get_locked_pkgs`` to ``pkg.list_holds``.\\n\\n    List information on locked packages\\n\\n    .. note::\\n        Requires the appropriate ``versionlock`` plugin package to be installed:\\n\\n        - On RHEL 5: ``yum-versionlock``\\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\\n\\n    pattern : \\\\w+(?:[.-][^-]+)*\\n        Regular expression used to match the package name\\n\\n    full : True\\n        Show the full hold definition including version and epoch. Set to\\n        ``False`` to return just the name of the package(s) being held.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_holds\\n        salt '*' pkg.list_holds full=False\\n    \"\n    _check_versionlock()\n    out = __salt__['cmd.run']([_yum(), 'versionlock', 'list'], python_shell=False)\n    ret = []\n    for line in salt.utils.itertools.split(out, '\\n'):\n        match = _get_hold(line, pattern=pattern, full=full)\n        if match is not None:\n            ret.append(match)\n    return ret",
            "def list_holds(pattern=__HOLD_PATTERN, full=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0\\n        Function renamed from ``pkg.get_locked_pkgs`` to ``pkg.list_holds``.\\n\\n    List information on locked packages\\n\\n    .. note::\\n        Requires the appropriate ``versionlock`` plugin package to be installed:\\n\\n        - On RHEL 5: ``yum-versionlock``\\n        - On RHEL 6 & 7: ``yum-plugin-versionlock``\\n        - On Fedora: ``python-dnf-plugins-extras-versionlock``\\n\\n    pattern : \\\\w+(?:[.-][^-]+)*\\n        Regular expression used to match the package name\\n\\n    full : True\\n        Show the full hold definition including version and epoch. Set to\\n        ``False`` to return just the name of the package(s) being held.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_holds\\n        salt '*' pkg.list_holds full=False\\n    \"\n    _check_versionlock()\n    out = __salt__['cmd.run']([_yum(), 'versionlock', 'list'], python_shell=False)\n    ret = []\n    for line in salt.utils.itertools.split(out, '\\n'):\n        match = _get_hold(line, pattern=pattern, full=full)\n        if match is not None:\n            ret.append(match)\n    return ret"
        ]
    },
    {
        "func_name": "verify",
        "original": "def verify(*names, **kwargs):\n    \"\"\"\n    .. versionadded:: 2014.1.0\n\n    Runs an rpm -Va on a system, and returns the results in a dict\n\n    Pass options to modify rpm verify behavior using the ``verify_options``\n    keyword argument\n\n    Files with an attribute of config, doc, ghost, license or readme in the\n    package header can be ignored using the ``ignore_types`` keyword argument\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.verify\n        salt '*' pkg.verify httpd\n        salt '*' pkg.verify 'httpd postfix'\n        salt '*' pkg.verify 'httpd postfix' ignore_types=['config','doc']\n        salt '*' pkg.verify 'httpd postfix' verify_options=['nodeps','nosize']\n    \"\"\"\n    return __salt__['lowpkg.verify'](*names, **kwargs)",
        "mutated": [
            "def verify(*names, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    Runs an rpm -Va on a system, and returns the results in a dict\\n\\n    Pass options to modify rpm verify behavior using the ``verify_options``\\n    keyword argument\\n\\n    Files with an attribute of config, doc, ghost, license or readme in the\\n    package header can be ignored using the ``ignore_types`` keyword argument\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.verify\\n        salt '*' pkg.verify httpd\\n        salt '*' pkg.verify 'httpd postfix'\\n        salt '*' pkg.verify 'httpd postfix' ignore_types=['config','doc']\\n        salt '*' pkg.verify 'httpd postfix' verify_options=['nodeps','nosize']\\n    \"\n    return __salt__['lowpkg.verify'](*names, **kwargs)",
            "def verify(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    Runs an rpm -Va on a system, and returns the results in a dict\\n\\n    Pass options to modify rpm verify behavior using the ``verify_options``\\n    keyword argument\\n\\n    Files with an attribute of config, doc, ghost, license or readme in the\\n    package header can be ignored using the ``ignore_types`` keyword argument\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.verify\\n        salt '*' pkg.verify httpd\\n        salt '*' pkg.verify 'httpd postfix'\\n        salt '*' pkg.verify 'httpd postfix' ignore_types=['config','doc']\\n        salt '*' pkg.verify 'httpd postfix' verify_options=['nodeps','nosize']\\n    \"\n    return __salt__['lowpkg.verify'](*names, **kwargs)",
            "def verify(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    Runs an rpm -Va on a system, and returns the results in a dict\\n\\n    Pass options to modify rpm verify behavior using the ``verify_options``\\n    keyword argument\\n\\n    Files with an attribute of config, doc, ghost, license or readme in the\\n    package header can be ignored using the ``ignore_types`` keyword argument\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.verify\\n        salt '*' pkg.verify httpd\\n        salt '*' pkg.verify 'httpd postfix'\\n        salt '*' pkg.verify 'httpd postfix' ignore_types=['config','doc']\\n        salt '*' pkg.verify 'httpd postfix' verify_options=['nodeps','nosize']\\n    \"\n    return __salt__['lowpkg.verify'](*names, **kwargs)",
            "def verify(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    Runs an rpm -Va on a system, and returns the results in a dict\\n\\n    Pass options to modify rpm verify behavior using the ``verify_options``\\n    keyword argument\\n\\n    Files with an attribute of config, doc, ghost, license or readme in the\\n    package header can be ignored using the ``ignore_types`` keyword argument\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.verify\\n        salt '*' pkg.verify httpd\\n        salt '*' pkg.verify 'httpd postfix'\\n        salt '*' pkg.verify 'httpd postfix' ignore_types=['config','doc']\\n        salt '*' pkg.verify 'httpd postfix' verify_options=['nodeps','nosize']\\n    \"\n    return __salt__['lowpkg.verify'](*names, **kwargs)",
            "def verify(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    Runs an rpm -Va on a system, and returns the results in a dict\\n\\n    Pass options to modify rpm verify behavior using the ``verify_options``\\n    keyword argument\\n\\n    Files with an attribute of config, doc, ghost, license or readme in the\\n    package header can be ignored using the ``ignore_types`` keyword argument\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.verify\\n        salt '*' pkg.verify httpd\\n        salt '*' pkg.verify 'httpd postfix'\\n        salt '*' pkg.verify 'httpd postfix' ignore_types=['config','doc']\\n        salt '*' pkg.verify 'httpd postfix' verify_options=['nodeps','nosize']\\n    \"\n    return __salt__['lowpkg.verify'](*names, **kwargs)"
        ]
    },
    {
        "func_name": "group_list",
        "original": "def group_list():\n    \"\"\"\n    .. versionadded:: 2014.1.0\n\n    Lists all groups known by yum on this system\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.group_list\n    \"\"\"\n    ret = {'installed': [], 'available': [], 'installed environments': [], 'available environments': [], 'available languages': {}}\n    section_map = {'installed groups:': 'installed', 'available groups:': 'available', 'installed environment groups:': 'installed environments', 'available environment groups:': 'available environments', 'available language groups:': 'available languages'}\n    out = __salt__['cmd.run_stdout']([_yum(), 'grouplist', 'hidden'], output_loglevel='trace', python_shell=False)\n    key = None\n    for line in salt.utils.itertools.split(out, '\\n'):\n        line_lc = line.lower()\n        if line_lc == 'done':\n            break\n        section_lookup = section_map.get(line_lc)\n        if section_lookup is not None and section_lookup != key:\n            key = section_lookup\n            continue\n        if key is None:\n            continue\n        line = line.strip()\n        if key != 'available languages':\n            ret[key].append(line)\n        else:\n            match = re.match('(.+) \\\\[(.+)\\\\]', line)\n            if match:\n                (name, lang) = match.groups()\n                ret[key][line] = {'name': name, 'language': lang}\n    return ret",
        "mutated": [
            "def group_list():\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    Lists all groups known by yum on this system\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.group_list\\n    \"\n    ret = {'installed': [], 'available': [], 'installed environments': [], 'available environments': [], 'available languages': {}}\n    section_map = {'installed groups:': 'installed', 'available groups:': 'available', 'installed environment groups:': 'installed environments', 'available environment groups:': 'available environments', 'available language groups:': 'available languages'}\n    out = __salt__['cmd.run_stdout']([_yum(), 'grouplist', 'hidden'], output_loglevel='trace', python_shell=False)\n    key = None\n    for line in salt.utils.itertools.split(out, '\\n'):\n        line_lc = line.lower()\n        if line_lc == 'done':\n            break\n        section_lookup = section_map.get(line_lc)\n        if section_lookup is not None and section_lookup != key:\n            key = section_lookup\n            continue\n        if key is None:\n            continue\n        line = line.strip()\n        if key != 'available languages':\n            ret[key].append(line)\n        else:\n            match = re.match('(.+) \\\\[(.+)\\\\]', line)\n            if match:\n                (name, lang) = match.groups()\n                ret[key][line] = {'name': name, 'language': lang}\n    return ret",
            "def group_list():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    Lists all groups known by yum on this system\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.group_list\\n    \"\n    ret = {'installed': [], 'available': [], 'installed environments': [], 'available environments': [], 'available languages': {}}\n    section_map = {'installed groups:': 'installed', 'available groups:': 'available', 'installed environment groups:': 'installed environments', 'available environment groups:': 'available environments', 'available language groups:': 'available languages'}\n    out = __salt__['cmd.run_stdout']([_yum(), 'grouplist', 'hidden'], output_loglevel='trace', python_shell=False)\n    key = None\n    for line in salt.utils.itertools.split(out, '\\n'):\n        line_lc = line.lower()\n        if line_lc == 'done':\n            break\n        section_lookup = section_map.get(line_lc)\n        if section_lookup is not None and section_lookup != key:\n            key = section_lookup\n            continue\n        if key is None:\n            continue\n        line = line.strip()\n        if key != 'available languages':\n            ret[key].append(line)\n        else:\n            match = re.match('(.+) \\\\[(.+)\\\\]', line)\n            if match:\n                (name, lang) = match.groups()\n                ret[key][line] = {'name': name, 'language': lang}\n    return ret",
            "def group_list():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    Lists all groups known by yum on this system\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.group_list\\n    \"\n    ret = {'installed': [], 'available': [], 'installed environments': [], 'available environments': [], 'available languages': {}}\n    section_map = {'installed groups:': 'installed', 'available groups:': 'available', 'installed environment groups:': 'installed environments', 'available environment groups:': 'available environments', 'available language groups:': 'available languages'}\n    out = __salt__['cmd.run_stdout']([_yum(), 'grouplist', 'hidden'], output_loglevel='trace', python_shell=False)\n    key = None\n    for line in salt.utils.itertools.split(out, '\\n'):\n        line_lc = line.lower()\n        if line_lc == 'done':\n            break\n        section_lookup = section_map.get(line_lc)\n        if section_lookup is not None and section_lookup != key:\n            key = section_lookup\n            continue\n        if key is None:\n            continue\n        line = line.strip()\n        if key != 'available languages':\n            ret[key].append(line)\n        else:\n            match = re.match('(.+) \\\\[(.+)\\\\]', line)\n            if match:\n                (name, lang) = match.groups()\n                ret[key][line] = {'name': name, 'language': lang}\n    return ret",
            "def group_list():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    Lists all groups known by yum on this system\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.group_list\\n    \"\n    ret = {'installed': [], 'available': [], 'installed environments': [], 'available environments': [], 'available languages': {}}\n    section_map = {'installed groups:': 'installed', 'available groups:': 'available', 'installed environment groups:': 'installed environments', 'available environment groups:': 'available environments', 'available language groups:': 'available languages'}\n    out = __salt__['cmd.run_stdout']([_yum(), 'grouplist', 'hidden'], output_loglevel='trace', python_shell=False)\n    key = None\n    for line in salt.utils.itertools.split(out, '\\n'):\n        line_lc = line.lower()\n        if line_lc == 'done':\n            break\n        section_lookup = section_map.get(line_lc)\n        if section_lookup is not None and section_lookup != key:\n            key = section_lookup\n            continue\n        if key is None:\n            continue\n        line = line.strip()\n        if key != 'available languages':\n            ret[key].append(line)\n        else:\n            match = re.match('(.+) \\\\[(.+)\\\\]', line)\n            if match:\n                (name, lang) = match.groups()\n                ret[key][line] = {'name': name, 'language': lang}\n    return ret",
            "def group_list():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    Lists all groups known by yum on this system\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.group_list\\n    \"\n    ret = {'installed': [], 'available': [], 'installed environments': [], 'available environments': [], 'available languages': {}}\n    section_map = {'installed groups:': 'installed', 'available groups:': 'available', 'installed environment groups:': 'installed environments', 'available environment groups:': 'available environments', 'available language groups:': 'available languages'}\n    out = __salt__['cmd.run_stdout']([_yum(), 'grouplist', 'hidden'], output_loglevel='trace', python_shell=False)\n    key = None\n    for line in salt.utils.itertools.split(out, '\\n'):\n        line_lc = line.lower()\n        if line_lc == 'done':\n            break\n        section_lookup = section_map.get(line_lc)\n        if section_lookup is not None and section_lookup != key:\n            key = section_lookup\n            continue\n        if key is None:\n            continue\n        line = line.strip()\n        if key != 'available languages':\n            ret[key].append(line)\n        else:\n            match = re.match('(.+) \\\\[(.+)\\\\]', line)\n            if match:\n                (name, lang) = match.groups()\n                ret[key][line] = {'name': name, 'language': lang}\n    return ret"
        ]
    },
    {
        "func_name": "group_info",
        "original": "def group_info(name, expand=False, ignore_groups=None, **kwargs):\n    \"\"\"\n    .. versionadded:: 2014.1.0\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0,3001\n        The return data has changed. A new key ``type`` has been added to\n        distinguish environment groups from package groups. Also, keys for the\n        group name and group ID have been added. The ``mandatory packages``,\n        ``optional packages``, and ``default packages`` keys have been renamed\n        to ``mandatory``, ``optional``, and ``default`` for accuracy, as\n        environment groups include other groups, and not packages. Finally,\n        this function now properly identifies conditional packages.\n    .. versionchanged:: 3006.2\n        Support for ``fromrepo``, ``enablerepo``, and ``disablerepo`` (as used\n        in :py:func:`pkg.install <salt.modules.yumpkg.install>`) has been\n        added.\n\n    Lists packages belonging to a certain group\n\n    name\n        Name of the group to query\n\n    expand : False\n        If the specified group is an environment group, then the group will be\n        expanded and the return data will include package names instead of\n        group names.\n\n        .. versionadded:: 2016.3.0\n\n    ignore_groups : None\n        This parameter can be used to pass a list of groups to ignore when\n        expanding subgroups. It is used during recursion in order to prevent\n        expanding the same group multiple times.\n\n        .. versionadded:: 3001\n\n    fromrepo\n        Restrict ``yum groupinfo`` to the specified repo(s).\n        (e.g., ``yum --disablerepo='*' --enablerepo='somerepo'``)\n\n        .. versionadded:: 3006.2\n\n    enablerepo (ignored if ``fromrepo`` is specified)\n        Specify a disabled package repository (or repositories) to enable.\n        (e.g., ``yum --enablerepo='somerepo'``)\n\n        .. versionadded:: 3006.2\n\n    disablerepo (ignored if ``fromrepo`` is specified)\n        Specify an enabled package repository (or repositories) to disable.\n        (e.g., ``yum --disablerepo='somerepo'``)\n\n        .. versionadded:: 3006.2\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.group_info 'Perl Support'\n        salt '*' pkg.group_info 'Perl Support' fromrepo=base,updates\n        salt '*' pkg.group_info 'Perl Support' enablerepo=somerepo\n    \"\"\"\n    pkgtypes = ('mandatory', 'optional', 'default', 'conditional')\n    ret = {}\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = set()\n    options = _get_options(**{key: val for (key, val) in kwargs.items() if key in ('fromrepo', 'enablerepo', 'disablerepo')})\n    cmd = [_yum(), '--quiet'] + options + ['groupinfo', name]\n    out = __salt__['cmd.run_stdout'](cmd, output_loglevel='trace', python_shell=False)\n    g_info = {}\n    for line in salt.utils.itertools.split(out, '\\n'):\n        try:\n            (key, value) = (x.strip() for x in line.split(':'))\n            g_info[key.lower()] = value\n        except ValueError:\n            continue\n    if 'environment group' in g_info:\n        ret['type'] = 'environment group'\n    elif 'group' in g_info:\n        ret['type'] = 'package group'\n    ret['group'] = g_info.get('environment group') or g_info.get('group')\n    ret['id'] = g_info.get('environment-id') or g_info.get('group-id')\n    if not ret['group'] and (not ret['id']):\n        raise CommandExecutionError(f\"Group '{name}' not found\")\n    ret['description'] = g_info.get('description', '')\n    completed_groups = ignore_groups or []\n    pkgtypes_capturegroup = '(' + '|'.join(pkgtypes) + ')'\n    for pkgtype in pkgtypes:\n        target_found = False\n        for line in salt.utils.itertools.split(out, '\\n'):\n            line = line.strip().lstrip(string.punctuation)\n            match = re.match(pkgtypes_capturegroup + ' (?:groups|packages):\\\\s*$', line.lower())\n            if match:\n                if target_found:\n                    break\n                else:\n                    if match.group(1) == pkgtype:\n                        target_found = True\n                    continue\n            if target_found:\n                if expand and ret['type'] == 'environment group':\n                    if not line or line in completed_groups:\n                        continue\n                    log.trace('Adding group \"%s\" to completed list: %s', line, completed_groups)\n                    completed_groups.append(line)\n                    expanded = group_info('@' + line, expand=True, ignore_groups=completed_groups)\n                    for p_type in pkgtypes:\n                        ret[p_type].update(set(expanded[p_type]))\n                else:\n                    ret[pkgtype].add(line)\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = sorted(ret[pkgtype])\n    return ret",
        "mutated": [
            "def group_info(name, expand=False, ignore_groups=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2014.1.0\\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0,3001\\n        The return data has changed. A new key ``type`` has been added to\\n        distinguish environment groups from package groups. Also, keys for the\\n        group name and group ID have been added. The ``mandatory packages``,\\n        ``optional packages``, and ``default packages`` keys have been renamed\\n        to ``mandatory``, ``optional``, and ``default`` for accuracy, as\\n        environment groups include other groups, and not packages. Finally,\\n        this function now properly identifies conditional packages.\\n    .. versionchanged:: 3006.2\\n        Support for ``fromrepo``, ``enablerepo``, and ``disablerepo`` (as used\\n        in :py:func:`pkg.install <salt.modules.yumpkg.install>`) has been\\n        added.\\n\\n    Lists packages belonging to a certain group\\n\\n    name\\n        Name of the group to query\\n\\n    expand : False\\n        If the specified group is an environment group, then the group will be\\n        expanded and the return data will include package names instead of\\n        group names.\\n\\n        .. versionadded:: 2016.3.0\\n\\n    ignore_groups : None\\n        This parameter can be used to pass a list of groups to ignore when\\n        expanding subgroups. It is used during recursion in order to prevent\\n        expanding the same group multiple times.\\n\\n        .. versionadded:: 3001\\n\\n    fromrepo\\n        Restrict ``yum groupinfo`` to the specified repo(s).\\n        (e.g., ``yum --disablerepo='*' --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.group_info 'Perl Support'\\n        salt '*' pkg.group_info 'Perl Support' fromrepo=base,updates\\n        salt '*' pkg.group_info 'Perl Support' enablerepo=somerepo\\n    \"\n    pkgtypes = ('mandatory', 'optional', 'default', 'conditional')\n    ret = {}\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = set()\n    options = _get_options(**{key: val for (key, val) in kwargs.items() if key in ('fromrepo', 'enablerepo', 'disablerepo')})\n    cmd = [_yum(), '--quiet'] + options + ['groupinfo', name]\n    out = __salt__['cmd.run_stdout'](cmd, output_loglevel='trace', python_shell=False)\n    g_info = {}\n    for line in salt.utils.itertools.split(out, '\\n'):\n        try:\n            (key, value) = (x.strip() for x in line.split(':'))\n            g_info[key.lower()] = value\n        except ValueError:\n            continue\n    if 'environment group' in g_info:\n        ret['type'] = 'environment group'\n    elif 'group' in g_info:\n        ret['type'] = 'package group'\n    ret['group'] = g_info.get('environment group') or g_info.get('group')\n    ret['id'] = g_info.get('environment-id') or g_info.get('group-id')\n    if not ret['group'] and (not ret['id']):\n        raise CommandExecutionError(f\"Group '{name}' not found\")\n    ret['description'] = g_info.get('description', '')\n    completed_groups = ignore_groups or []\n    pkgtypes_capturegroup = '(' + '|'.join(pkgtypes) + ')'\n    for pkgtype in pkgtypes:\n        target_found = False\n        for line in salt.utils.itertools.split(out, '\\n'):\n            line = line.strip().lstrip(string.punctuation)\n            match = re.match(pkgtypes_capturegroup + ' (?:groups|packages):\\\\s*$', line.lower())\n            if match:\n                if target_found:\n                    break\n                else:\n                    if match.group(1) == pkgtype:\n                        target_found = True\n                    continue\n            if target_found:\n                if expand and ret['type'] == 'environment group':\n                    if not line or line in completed_groups:\n                        continue\n                    log.trace('Adding group \"%s\" to completed list: %s', line, completed_groups)\n                    completed_groups.append(line)\n                    expanded = group_info('@' + line, expand=True, ignore_groups=completed_groups)\n                    for p_type in pkgtypes:\n                        ret[p_type].update(set(expanded[p_type]))\n                else:\n                    ret[pkgtype].add(line)\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = sorted(ret[pkgtype])\n    return ret",
            "def group_info(name, expand=False, ignore_groups=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2014.1.0\\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0,3001\\n        The return data has changed. A new key ``type`` has been added to\\n        distinguish environment groups from package groups. Also, keys for the\\n        group name and group ID have been added. The ``mandatory packages``,\\n        ``optional packages``, and ``default packages`` keys have been renamed\\n        to ``mandatory``, ``optional``, and ``default`` for accuracy, as\\n        environment groups include other groups, and not packages. Finally,\\n        this function now properly identifies conditional packages.\\n    .. versionchanged:: 3006.2\\n        Support for ``fromrepo``, ``enablerepo``, and ``disablerepo`` (as used\\n        in :py:func:`pkg.install <salt.modules.yumpkg.install>`) has been\\n        added.\\n\\n    Lists packages belonging to a certain group\\n\\n    name\\n        Name of the group to query\\n\\n    expand : False\\n        If the specified group is an environment group, then the group will be\\n        expanded and the return data will include package names instead of\\n        group names.\\n\\n        .. versionadded:: 2016.3.0\\n\\n    ignore_groups : None\\n        This parameter can be used to pass a list of groups to ignore when\\n        expanding subgroups. It is used during recursion in order to prevent\\n        expanding the same group multiple times.\\n\\n        .. versionadded:: 3001\\n\\n    fromrepo\\n        Restrict ``yum groupinfo`` to the specified repo(s).\\n        (e.g., ``yum --disablerepo='*' --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.group_info 'Perl Support'\\n        salt '*' pkg.group_info 'Perl Support' fromrepo=base,updates\\n        salt '*' pkg.group_info 'Perl Support' enablerepo=somerepo\\n    \"\n    pkgtypes = ('mandatory', 'optional', 'default', 'conditional')\n    ret = {}\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = set()\n    options = _get_options(**{key: val for (key, val) in kwargs.items() if key in ('fromrepo', 'enablerepo', 'disablerepo')})\n    cmd = [_yum(), '--quiet'] + options + ['groupinfo', name]\n    out = __salt__['cmd.run_stdout'](cmd, output_loglevel='trace', python_shell=False)\n    g_info = {}\n    for line in salt.utils.itertools.split(out, '\\n'):\n        try:\n            (key, value) = (x.strip() for x in line.split(':'))\n            g_info[key.lower()] = value\n        except ValueError:\n            continue\n    if 'environment group' in g_info:\n        ret['type'] = 'environment group'\n    elif 'group' in g_info:\n        ret['type'] = 'package group'\n    ret['group'] = g_info.get('environment group') or g_info.get('group')\n    ret['id'] = g_info.get('environment-id') or g_info.get('group-id')\n    if not ret['group'] and (not ret['id']):\n        raise CommandExecutionError(f\"Group '{name}' not found\")\n    ret['description'] = g_info.get('description', '')\n    completed_groups = ignore_groups or []\n    pkgtypes_capturegroup = '(' + '|'.join(pkgtypes) + ')'\n    for pkgtype in pkgtypes:\n        target_found = False\n        for line in salt.utils.itertools.split(out, '\\n'):\n            line = line.strip().lstrip(string.punctuation)\n            match = re.match(pkgtypes_capturegroup + ' (?:groups|packages):\\\\s*$', line.lower())\n            if match:\n                if target_found:\n                    break\n                else:\n                    if match.group(1) == pkgtype:\n                        target_found = True\n                    continue\n            if target_found:\n                if expand and ret['type'] == 'environment group':\n                    if not line or line in completed_groups:\n                        continue\n                    log.trace('Adding group \"%s\" to completed list: %s', line, completed_groups)\n                    completed_groups.append(line)\n                    expanded = group_info('@' + line, expand=True, ignore_groups=completed_groups)\n                    for p_type in pkgtypes:\n                        ret[p_type].update(set(expanded[p_type]))\n                else:\n                    ret[pkgtype].add(line)\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = sorted(ret[pkgtype])\n    return ret",
            "def group_info(name, expand=False, ignore_groups=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2014.1.0\\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0,3001\\n        The return data has changed. A new key ``type`` has been added to\\n        distinguish environment groups from package groups. Also, keys for the\\n        group name and group ID have been added. The ``mandatory packages``,\\n        ``optional packages``, and ``default packages`` keys have been renamed\\n        to ``mandatory``, ``optional``, and ``default`` for accuracy, as\\n        environment groups include other groups, and not packages. Finally,\\n        this function now properly identifies conditional packages.\\n    .. versionchanged:: 3006.2\\n        Support for ``fromrepo``, ``enablerepo``, and ``disablerepo`` (as used\\n        in :py:func:`pkg.install <salt.modules.yumpkg.install>`) has been\\n        added.\\n\\n    Lists packages belonging to a certain group\\n\\n    name\\n        Name of the group to query\\n\\n    expand : False\\n        If the specified group is an environment group, then the group will be\\n        expanded and the return data will include package names instead of\\n        group names.\\n\\n        .. versionadded:: 2016.3.0\\n\\n    ignore_groups : None\\n        This parameter can be used to pass a list of groups to ignore when\\n        expanding subgroups. It is used during recursion in order to prevent\\n        expanding the same group multiple times.\\n\\n        .. versionadded:: 3001\\n\\n    fromrepo\\n        Restrict ``yum groupinfo`` to the specified repo(s).\\n        (e.g., ``yum --disablerepo='*' --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.group_info 'Perl Support'\\n        salt '*' pkg.group_info 'Perl Support' fromrepo=base,updates\\n        salt '*' pkg.group_info 'Perl Support' enablerepo=somerepo\\n    \"\n    pkgtypes = ('mandatory', 'optional', 'default', 'conditional')\n    ret = {}\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = set()\n    options = _get_options(**{key: val for (key, val) in kwargs.items() if key in ('fromrepo', 'enablerepo', 'disablerepo')})\n    cmd = [_yum(), '--quiet'] + options + ['groupinfo', name]\n    out = __salt__['cmd.run_stdout'](cmd, output_loglevel='trace', python_shell=False)\n    g_info = {}\n    for line in salt.utils.itertools.split(out, '\\n'):\n        try:\n            (key, value) = (x.strip() for x in line.split(':'))\n            g_info[key.lower()] = value\n        except ValueError:\n            continue\n    if 'environment group' in g_info:\n        ret['type'] = 'environment group'\n    elif 'group' in g_info:\n        ret['type'] = 'package group'\n    ret['group'] = g_info.get('environment group') or g_info.get('group')\n    ret['id'] = g_info.get('environment-id') or g_info.get('group-id')\n    if not ret['group'] and (not ret['id']):\n        raise CommandExecutionError(f\"Group '{name}' not found\")\n    ret['description'] = g_info.get('description', '')\n    completed_groups = ignore_groups or []\n    pkgtypes_capturegroup = '(' + '|'.join(pkgtypes) + ')'\n    for pkgtype in pkgtypes:\n        target_found = False\n        for line in salt.utils.itertools.split(out, '\\n'):\n            line = line.strip().lstrip(string.punctuation)\n            match = re.match(pkgtypes_capturegroup + ' (?:groups|packages):\\\\s*$', line.lower())\n            if match:\n                if target_found:\n                    break\n                else:\n                    if match.group(1) == pkgtype:\n                        target_found = True\n                    continue\n            if target_found:\n                if expand and ret['type'] == 'environment group':\n                    if not line or line in completed_groups:\n                        continue\n                    log.trace('Adding group \"%s\" to completed list: %s', line, completed_groups)\n                    completed_groups.append(line)\n                    expanded = group_info('@' + line, expand=True, ignore_groups=completed_groups)\n                    for p_type in pkgtypes:\n                        ret[p_type].update(set(expanded[p_type]))\n                else:\n                    ret[pkgtype].add(line)\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = sorted(ret[pkgtype])\n    return ret",
            "def group_info(name, expand=False, ignore_groups=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2014.1.0\\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0,3001\\n        The return data has changed. A new key ``type`` has been added to\\n        distinguish environment groups from package groups. Also, keys for the\\n        group name and group ID have been added. The ``mandatory packages``,\\n        ``optional packages``, and ``default packages`` keys have been renamed\\n        to ``mandatory``, ``optional``, and ``default`` for accuracy, as\\n        environment groups include other groups, and not packages. Finally,\\n        this function now properly identifies conditional packages.\\n    .. versionchanged:: 3006.2\\n        Support for ``fromrepo``, ``enablerepo``, and ``disablerepo`` (as used\\n        in :py:func:`pkg.install <salt.modules.yumpkg.install>`) has been\\n        added.\\n\\n    Lists packages belonging to a certain group\\n\\n    name\\n        Name of the group to query\\n\\n    expand : False\\n        If the specified group is an environment group, then the group will be\\n        expanded and the return data will include package names instead of\\n        group names.\\n\\n        .. versionadded:: 2016.3.0\\n\\n    ignore_groups : None\\n        This parameter can be used to pass a list of groups to ignore when\\n        expanding subgroups. It is used during recursion in order to prevent\\n        expanding the same group multiple times.\\n\\n        .. versionadded:: 3001\\n\\n    fromrepo\\n        Restrict ``yum groupinfo`` to the specified repo(s).\\n        (e.g., ``yum --disablerepo='*' --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.group_info 'Perl Support'\\n        salt '*' pkg.group_info 'Perl Support' fromrepo=base,updates\\n        salt '*' pkg.group_info 'Perl Support' enablerepo=somerepo\\n    \"\n    pkgtypes = ('mandatory', 'optional', 'default', 'conditional')\n    ret = {}\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = set()\n    options = _get_options(**{key: val for (key, val) in kwargs.items() if key in ('fromrepo', 'enablerepo', 'disablerepo')})\n    cmd = [_yum(), '--quiet'] + options + ['groupinfo', name]\n    out = __salt__['cmd.run_stdout'](cmd, output_loglevel='trace', python_shell=False)\n    g_info = {}\n    for line in salt.utils.itertools.split(out, '\\n'):\n        try:\n            (key, value) = (x.strip() for x in line.split(':'))\n            g_info[key.lower()] = value\n        except ValueError:\n            continue\n    if 'environment group' in g_info:\n        ret['type'] = 'environment group'\n    elif 'group' in g_info:\n        ret['type'] = 'package group'\n    ret['group'] = g_info.get('environment group') or g_info.get('group')\n    ret['id'] = g_info.get('environment-id') or g_info.get('group-id')\n    if not ret['group'] and (not ret['id']):\n        raise CommandExecutionError(f\"Group '{name}' not found\")\n    ret['description'] = g_info.get('description', '')\n    completed_groups = ignore_groups or []\n    pkgtypes_capturegroup = '(' + '|'.join(pkgtypes) + ')'\n    for pkgtype in pkgtypes:\n        target_found = False\n        for line in salt.utils.itertools.split(out, '\\n'):\n            line = line.strip().lstrip(string.punctuation)\n            match = re.match(pkgtypes_capturegroup + ' (?:groups|packages):\\\\s*$', line.lower())\n            if match:\n                if target_found:\n                    break\n                else:\n                    if match.group(1) == pkgtype:\n                        target_found = True\n                    continue\n            if target_found:\n                if expand and ret['type'] == 'environment group':\n                    if not line or line in completed_groups:\n                        continue\n                    log.trace('Adding group \"%s\" to completed list: %s', line, completed_groups)\n                    completed_groups.append(line)\n                    expanded = group_info('@' + line, expand=True, ignore_groups=completed_groups)\n                    for p_type in pkgtypes:\n                        ret[p_type].update(set(expanded[p_type]))\n                else:\n                    ret[pkgtype].add(line)\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = sorted(ret[pkgtype])\n    return ret",
            "def group_info(name, expand=False, ignore_groups=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2014.1.0\\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0,3001\\n        The return data has changed. A new key ``type`` has been added to\\n        distinguish environment groups from package groups. Also, keys for the\\n        group name and group ID have been added. The ``mandatory packages``,\\n        ``optional packages``, and ``default packages`` keys have been renamed\\n        to ``mandatory``, ``optional``, and ``default`` for accuracy, as\\n        environment groups include other groups, and not packages. Finally,\\n        this function now properly identifies conditional packages.\\n    .. versionchanged:: 3006.2\\n        Support for ``fromrepo``, ``enablerepo``, and ``disablerepo`` (as used\\n        in :py:func:`pkg.install <salt.modules.yumpkg.install>`) has been\\n        added.\\n\\n    Lists packages belonging to a certain group\\n\\n    name\\n        Name of the group to query\\n\\n    expand : False\\n        If the specified group is an environment group, then the group will be\\n        expanded and the return data will include package names instead of\\n        group names.\\n\\n        .. versionadded:: 2016.3.0\\n\\n    ignore_groups : None\\n        This parameter can be used to pass a list of groups to ignore when\\n        expanding subgroups. It is used during recursion in order to prevent\\n        expanding the same group multiple times.\\n\\n        .. versionadded:: 3001\\n\\n    fromrepo\\n        Restrict ``yum groupinfo`` to the specified repo(s).\\n        (e.g., ``yum --disablerepo='*' --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.group_info 'Perl Support'\\n        salt '*' pkg.group_info 'Perl Support' fromrepo=base,updates\\n        salt '*' pkg.group_info 'Perl Support' enablerepo=somerepo\\n    \"\n    pkgtypes = ('mandatory', 'optional', 'default', 'conditional')\n    ret = {}\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = set()\n    options = _get_options(**{key: val for (key, val) in kwargs.items() if key in ('fromrepo', 'enablerepo', 'disablerepo')})\n    cmd = [_yum(), '--quiet'] + options + ['groupinfo', name]\n    out = __salt__['cmd.run_stdout'](cmd, output_loglevel='trace', python_shell=False)\n    g_info = {}\n    for line in salt.utils.itertools.split(out, '\\n'):\n        try:\n            (key, value) = (x.strip() for x in line.split(':'))\n            g_info[key.lower()] = value\n        except ValueError:\n            continue\n    if 'environment group' in g_info:\n        ret['type'] = 'environment group'\n    elif 'group' in g_info:\n        ret['type'] = 'package group'\n    ret['group'] = g_info.get('environment group') or g_info.get('group')\n    ret['id'] = g_info.get('environment-id') or g_info.get('group-id')\n    if not ret['group'] and (not ret['id']):\n        raise CommandExecutionError(f\"Group '{name}' not found\")\n    ret['description'] = g_info.get('description', '')\n    completed_groups = ignore_groups or []\n    pkgtypes_capturegroup = '(' + '|'.join(pkgtypes) + ')'\n    for pkgtype in pkgtypes:\n        target_found = False\n        for line in salt.utils.itertools.split(out, '\\n'):\n            line = line.strip().lstrip(string.punctuation)\n            match = re.match(pkgtypes_capturegroup + ' (?:groups|packages):\\\\s*$', line.lower())\n            if match:\n                if target_found:\n                    break\n                else:\n                    if match.group(1) == pkgtype:\n                        target_found = True\n                    continue\n            if target_found:\n                if expand and ret['type'] == 'environment group':\n                    if not line or line in completed_groups:\n                        continue\n                    log.trace('Adding group \"%s\" to completed list: %s', line, completed_groups)\n                    completed_groups.append(line)\n                    expanded = group_info('@' + line, expand=True, ignore_groups=completed_groups)\n                    for p_type in pkgtypes:\n                        ret[p_type].update(set(expanded[p_type]))\n                else:\n                    ret[pkgtype].add(line)\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = sorted(ret[pkgtype])\n    return ret"
        ]
    },
    {
        "func_name": "group_diff",
        "original": "def group_diff(name, **kwargs):\n    \"\"\"\n    .. versionadded:: 2014.1.0\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0\n        Environment groups are now supported. The key names have been renamed,\n        similar to the changes made in :py:func:`pkg.group_info\n        <salt.modules.yumpkg.group_info>`.\n    .. versionchanged:: 3006.2\n        Support for ``fromrepo``, ``enablerepo``, and ``disablerepo`` (as used\n        in :py:func:`pkg.install <salt.modules.yumpkg.install>`) has been\n        added.\n\n    Lists which of a group's packages are installed and which are not\n    installed\n\n    name\n        The name of the group to check\n\n    fromrepo\n        Restrict ``yum groupinfo`` to the specified repo(s).\n        (e.g., ``yum --disablerepo='*' --enablerepo='somerepo'``)\n\n        .. versionadded:: 3006.2\n\n    enablerepo (ignored if ``fromrepo`` is specified)\n        Specify a disabled package repository (or repositories) to enable.\n        (e.g., ``yum --enablerepo='somerepo'``)\n\n        .. versionadded:: 3006.2\n\n    disablerepo (ignored if ``fromrepo`` is specified)\n        Specify an enabled package repository (or repositories) to disable.\n        (e.g., ``yum --disablerepo='somerepo'``)\n\n        .. versionadded:: 3006.2\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.group_diff 'Perl Support'\n        salt '*' pkg.group_diff 'Perl Support' fromrepo=base,updates\n        salt '*' pkg.group_diff 'Perl Support' enablerepo=somerepo\n    \"\"\"\n    pkgtypes = ('mandatory', 'optional', 'default', 'conditional')\n    ret = {}\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = {'installed': [], 'not installed': []}\n    pkgs = list_pkgs()\n    group_pkgs = group_info(name, expand=True, **kwargs)\n    for pkgtype in pkgtypes:\n        for member in group_pkgs.get(pkgtype, []):\n            if member in pkgs:\n                ret[pkgtype]['installed'].append(member)\n            else:\n                ret[pkgtype]['not installed'].append(member)\n    return ret",
        "mutated": [
            "def group_diff(name, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2014.1.0\\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0\\n        Environment groups are now supported. The key names have been renamed,\\n        similar to the changes made in :py:func:`pkg.group_info\\n        <salt.modules.yumpkg.group_info>`.\\n    .. versionchanged:: 3006.2\\n        Support for ``fromrepo``, ``enablerepo``, and ``disablerepo`` (as used\\n        in :py:func:`pkg.install <salt.modules.yumpkg.install>`) has been\\n        added.\\n\\n    Lists which of a group's packages are installed and which are not\\n    installed\\n\\n    name\\n        The name of the group to check\\n\\n    fromrepo\\n        Restrict ``yum groupinfo`` to the specified repo(s).\\n        (e.g., ``yum --disablerepo='*' --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.group_diff 'Perl Support'\\n        salt '*' pkg.group_diff 'Perl Support' fromrepo=base,updates\\n        salt '*' pkg.group_diff 'Perl Support' enablerepo=somerepo\\n    \"\n    pkgtypes = ('mandatory', 'optional', 'default', 'conditional')\n    ret = {}\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = {'installed': [], 'not installed': []}\n    pkgs = list_pkgs()\n    group_pkgs = group_info(name, expand=True, **kwargs)\n    for pkgtype in pkgtypes:\n        for member in group_pkgs.get(pkgtype, []):\n            if member in pkgs:\n                ret[pkgtype]['installed'].append(member)\n            else:\n                ret[pkgtype]['not installed'].append(member)\n    return ret",
            "def group_diff(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2014.1.0\\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0\\n        Environment groups are now supported. The key names have been renamed,\\n        similar to the changes made in :py:func:`pkg.group_info\\n        <salt.modules.yumpkg.group_info>`.\\n    .. versionchanged:: 3006.2\\n        Support for ``fromrepo``, ``enablerepo``, and ``disablerepo`` (as used\\n        in :py:func:`pkg.install <salt.modules.yumpkg.install>`) has been\\n        added.\\n\\n    Lists which of a group's packages are installed and which are not\\n    installed\\n\\n    name\\n        The name of the group to check\\n\\n    fromrepo\\n        Restrict ``yum groupinfo`` to the specified repo(s).\\n        (e.g., ``yum --disablerepo='*' --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.group_diff 'Perl Support'\\n        salt '*' pkg.group_diff 'Perl Support' fromrepo=base,updates\\n        salt '*' pkg.group_diff 'Perl Support' enablerepo=somerepo\\n    \"\n    pkgtypes = ('mandatory', 'optional', 'default', 'conditional')\n    ret = {}\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = {'installed': [], 'not installed': []}\n    pkgs = list_pkgs()\n    group_pkgs = group_info(name, expand=True, **kwargs)\n    for pkgtype in pkgtypes:\n        for member in group_pkgs.get(pkgtype, []):\n            if member in pkgs:\n                ret[pkgtype]['installed'].append(member)\n            else:\n                ret[pkgtype]['not installed'].append(member)\n    return ret",
            "def group_diff(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2014.1.0\\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0\\n        Environment groups are now supported. The key names have been renamed,\\n        similar to the changes made in :py:func:`pkg.group_info\\n        <salt.modules.yumpkg.group_info>`.\\n    .. versionchanged:: 3006.2\\n        Support for ``fromrepo``, ``enablerepo``, and ``disablerepo`` (as used\\n        in :py:func:`pkg.install <salt.modules.yumpkg.install>`) has been\\n        added.\\n\\n    Lists which of a group's packages are installed and which are not\\n    installed\\n\\n    name\\n        The name of the group to check\\n\\n    fromrepo\\n        Restrict ``yum groupinfo`` to the specified repo(s).\\n        (e.g., ``yum --disablerepo='*' --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.group_diff 'Perl Support'\\n        salt '*' pkg.group_diff 'Perl Support' fromrepo=base,updates\\n        salt '*' pkg.group_diff 'Perl Support' enablerepo=somerepo\\n    \"\n    pkgtypes = ('mandatory', 'optional', 'default', 'conditional')\n    ret = {}\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = {'installed': [], 'not installed': []}\n    pkgs = list_pkgs()\n    group_pkgs = group_info(name, expand=True, **kwargs)\n    for pkgtype in pkgtypes:\n        for member in group_pkgs.get(pkgtype, []):\n            if member in pkgs:\n                ret[pkgtype]['installed'].append(member)\n            else:\n                ret[pkgtype]['not installed'].append(member)\n    return ret",
            "def group_diff(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2014.1.0\\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0\\n        Environment groups are now supported. The key names have been renamed,\\n        similar to the changes made in :py:func:`pkg.group_info\\n        <salt.modules.yumpkg.group_info>`.\\n    .. versionchanged:: 3006.2\\n        Support for ``fromrepo``, ``enablerepo``, and ``disablerepo`` (as used\\n        in :py:func:`pkg.install <salt.modules.yumpkg.install>`) has been\\n        added.\\n\\n    Lists which of a group's packages are installed and which are not\\n    installed\\n\\n    name\\n        The name of the group to check\\n\\n    fromrepo\\n        Restrict ``yum groupinfo`` to the specified repo(s).\\n        (e.g., ``yum --disablerepo='*' --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.group_diff 'Perl Support'\\n        salt '*' pkg.group_diff 'Perl Support' fromrepo=base,updates\\n        salt '*' pkg.group_diff 'Perl Support' enablerepo=somerepo\\n    \"\n    pkgtypes = ('mandatory', 'optional', 'default', 'conditional')\n    ret = {}\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = {'installed': [], 'not installed': []}\n    pkgs = list_pkgs()\n    group_pkgs = group_info(name, expand=True, **kwargs)\n    for pkgtype in pkgtypes:\n        for member in group_pkgs.get(pkgtype, []):\n            if member in pkgs:\n                ret[pkgtype]['installed'].append(member)\n            else:\n                ret[pkgtype]['not installed'].append(member)\n    return ret",
            "def group_diff(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2014.1.0\\n    .. versionchanged:: 2015.5.10,2015.8.4,2016.3.0\\n        Environment groups are now supported. The key names have been renamed,\\n        similar to the changes made in :py:func:`pkg.group_info\\n        <salt.modules.yumpkg.group_info>`.\\n    .. versionchanged:: 3006.2\\n        Support for ``fromrepo``, ``enablerepo``, and ``disablerepo`` (as used\\n        in :py:func:`pkg.install <salt.modules.yumpkg.install>`) has been\\n        added.\\n\\n    Lists which of a group's packages are installed and which are not\\n    installed\\n\\n    name\\n        The name of the group to check\\n\\n    fromrepo\\n        Restrict ``yum groupinfo`` to the specified repo(s).\\n        (e.g., ``yum --disablerepo='*' --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    enablerepo (ignored if ``fromrepo`` is specified)\\n        Specify a disabled package repository (or repositories) to enable.\\n        (e.g., ``yum --enablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    disablerepo (ignored if ``fromrepo`` is specified)\\n        Specify an enabled package repository (or repositories) to disable.\\n        (e.g., ``yum --disablerepo='somerepo'``)\\n\\n        .. versionadded:: 3006.2\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.group_diff 'Perl Support'\\n        salt '*' pkg.group_diff 'Perl Support' fromrepo=base,updates\\n        salt '*' pkg.group_diff 'Perl Support' enablerepo=somerepo\\n    \"\n    pkgtypes = ('mandatory', 'optional', 'default', 'conditional')\n    ret = {}\n    for pkgtype in pkgtypes:\n        ret[pkgtype] = {'installed': [], 'not installed': []}\n    pkgs = list_pkgs()\n    group_pkgs = group_info(name, expand=True, **kwargs)\n    for pkgtype in pkgtypes:\n        for member in group_pkgs.get(pkgtype, []):\n            if member in pkgs:\n                ret[pkgtype]['installed'].append(member)\n            else:\n                ret[pkgtype]['not installed'].append(member)\n    return ret"
        ]
    },
    {
        "func_name": "group_install",
        "original": "def group_install(name, skip=(), include=(), **kwargs):\n    \"\"\"\n    .. versionadded:: 2014.1.0\n\n    Install the passed package group(s). This is basically a wrapper around\n    :py:func:`pkg.install <salt.modules.yumpkg.install>`, which performs\n    package group resolution for the user. This function is currently\n    considered experimental, and should be expected to undergo changes.\n\n    name\n        Package group to install. To install more than one group, either use a\n        comma-separated list or pass the value as a python list.\n\n        CLI Examples:\n\n        .. code-block:: bash\n\n            salt '*' pkg.group_install 'Group 1'\n            salt '*' pkg.group_install 'Group 1,Group 2'\n            salt '*' pkg.group_install '[\"Group 1\", \"Group 2\"]'\n\n    skip\n        Packages that would normally be installed by the package group\n        (\"default\" packages), which should not be installed. Can be passed\n        either as a comma-separated list or a python list.\n\n        CLI Examples:\n\n        .. code-block:: bash\n\n            salt '*' pkg.group_install 'My Group' skip='foo,bar'\n            salt '*' pkg.group_install 'My Group' skip='[\"foo\", \"bar\"]'\n\n    include\n        Packages which are included in a group, which would not normally be\n        installed by a ``yum groupinstall`` (\"optional\" packages). Note that\n        this will not enforce group membership; if you include packages which\n        are not members of the specified groups, they will still be installed.\n        Can be passed either as a comma-separated list or a python list.\n\n        CLI Examples:\n\n        .. code-block:: bash\n\n            salt '*' pkg.group_install 'My Group' include='foo,bar'\n            salt '*' pkg.group_install 'My Group' include='[\"foo\", \"bar\"]'\n\n    .. note::\n        Because this is essentially a wrapper around pkg.install, any argument\n        which can be passed to pkg.install may also be included here, and it\n        will be passed along wholesale.\n    \"\"\"\n    groups = name.split(',') if isinstance(name, str) else name\n    if not groups:\n        raise SaltInvocationError('no groups specified')\n    elif not isinstance(groups, list):\n        raise SaltInvocationError(\"'groups' must be a list\")\n    if isinstance(skip, str):\n        skip = skip.split(',')\n    if not isinstance(skip, (list, tuple)):\n        raise SaltInvocationError(\"'skip' must be a list\")\n    if isinstance(include, str):\n        include = include.split(',')\n    if not isinstance(include, (list, tuple)):\n        raise SaltInvocationError(\"'include' must be a list\")\n    targets = []\n    for group in groups:\n        group_detail = group_info(group)\n        targets.extend(group_detail.get('mandatory', []))\n        targets.extend([pkg for pkg in group_detail.get('default', []) if pkg not in skip])\n    if include:\n        targets.extend(include)\n    pkgs = [x for x in targets if x not in list_pkgs()]\n    if not pkgs:\n        return {}\n    return install(pkgs=pkgs, **kwargs)",
        "mutated": [
            "def group_install(name, skip=(), include=(), **kwargs):\n    if False:\n        i = 10\n    '\\n    .. versionadded:: 2014.1.0\\n\\n    Install the passed package group(s). This is basically a wrapper around\\n    :py:func:`pkg.install <salt.modules.yumpkg.install>`, which performs\\n    package group resolution for the user. This function is currently\\n    considered experimental, and should be expected to undergo changes.\\n\\n    name\\n        Package group to install. To install more than one group, either use a\\n        comma-separated list or pass the value as a python list.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.group_install \\'Group 1\\'\\n            salt \\'*\\' pkg.group_install \\'Group 1,Group 2\\'\\n            salt \\'*\\' pkg.group_install \\'[\"Group 1\", \"Group 2\"]\\'\\n\\n    skip\\n        Packages that would normally be installed by the package group\\n        (\"default\" packages), which should not be installed. Can be passed\\n        either as a comma-separated list or a python list.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.group_install \\'My Group\\' skip=\\'foo,bar\\'\\n            salt \\'*\\' pkg.group_install \\'My Group\\' skip=\\'[\"foo\", \"bar\"]\\'\\n\\n    include\\n        Packages which are included in a group, which would not normally be\\n        installed by a ``yum groupinstall`` (\"optional\" packages). Note that\\n        this will not enforce group membership; if you include packages which\\n        are not members of the specified groups, they will still be installed.\\n        Can be passed either as a comma-separated list or a python list.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.group_install \\'My Group\\' include=\\'foo,bar\\'\\n            salt \\'*\\' pkg.group_install \\'My Group\\' include=\\'[\"foo\", \"bar\"]\\'\\n\\n    .. note::\\n        Because this is essentially a wrapper around pkg.install, any argument\\n        which can be passed to pkg.install may also be included here, and it\\n        will be passed along wholesale.\\n    '\n    groups = name.split(',') if isinstance(name, str) else name\n    if not groups:\n        raise SaltInvocationError('no groups specified')\n    elif not isinstance(groups, list):\n        raise SaltInvocationError(\"'groups' must be a list\")\n    if isinstance(skip, str):\n        skip = skip.split(',')\n    if not isinstance(skip, (list, tuple)):\n        raise SaltInvocationError(\"'skip' must be a list\")\n    if isinstance(include, str):\n        include = include.split(',')\n    if not isinstance(include, (list, tuple)):\n        raise SaltInvocationError(\"'include' must be a list\")\n    targets = []\n    for group in groups:\n        group_detail = group_info(group)\n        targets.extend(group_detail.get('mandatory', []))\n        targets.extend([pkg for pkg in group_detail.get('default', []) if pkg not in skip])\n    if include:\n        targets.extend(include)\n    pkgs = [x for x in targets if x not in list_pkgs()]\n    if not pkgs:\n        return {}\n    return install(pkgs=pkgs, **kwargs)",
            "def group_install(name, skip=(), include=(), **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    .. versionadded:: 2014.1.0\\n\\n    Install the passed package group(s). This is basically a wrapper around\\n    :py:func:`pkg.install <salt.modules.yumpkg.install>`, which performs\\n    package group resolution for the user. This function is currently\\n    considered experimental, and should be expected to undergo changes.\\n\\n    name\\n        Package group to install. To install more than one group, either use a\\n        comma-separated list or pass the value as a python list.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.group_install \\'Group 1\\'\\n            salt \\'*\\' pkg.group_install \\'Group 1,Group 2\\'\\n            salt \\'*\\' pkg.group_install \\'[\"Group 1\", \"Group 2\"]\\'\\n\\n    skip\\n        Packages that would normally be installed by the package group\\n        (\"default\" packages), which should not be installed. Can be passed\\n        either as a comma-separated list or a python list.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.group_install \\'My Group\\' skip=\\'foo,bar\\'\\n            salt \\'*\\' pkg.group_install \\'My Group\\' skip=\\'[\"foo\", \"bar\"]\\'\\n\\n    include\\n        Packages which are included in a group, which would not normally be\\n        installed by a ``yum groupinstall`` (\"optional\" packages). Note that\\n        this will not enforce group membership; if you include packages which\\n        are not members of the specified groups, they will still be installed.\\n        Can be passed either as a comma-separated list or a python list.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.group_install \\'My Group\\' include=\\'foo,bar\\'\\n            salt \\'*\\' pkg.group_install \\'My Group\\' include=\\'[\"foo\", \"bar\"]\\'\\n\\n    .. note::\\n        Because this is essentially a wrapper around pkg.install, any argument\\n        which can be passed to pkg.install may also be included here, and it\\n        will be passed along wholesale.\\n    '\n    groups = name.split(',') if isinstance(name, str) else name\n    if not groups:\n        raise SaltInvocationError('no groups specified')\n    elif not isinstance(groups, list):\n        raise SaltInvocationError(\"'groups' must be a list\")\n    if isinstance(skip, str):\n        skip = skip.split(',')\n    if not isinstance(skip, (list, tuple)):\n        raise SaltInvocationError(\"'skip' must be a list\")\n    if isinstance(include, str):\n        include = include.split(',')\n    if not isinstance(include, (list, tuple)):\n        raise SaltInvocationError(\"'include' must be a list\")\n    targets = []\n    for group in groups:\n        group_detail = group_info(group)\n        targets.extend(group_detail.get('mandatory', []))\n        targets.extend([pkg for pkg in group_detail.get('default', []) if pkg not in skip])\n    if include:\n        targets.extend(include)\n    pkgs = [x for x in targets if x not in list_pkgs()]\n    if not pkgs:\n        return {}\n    return install(pkgs=pkgs, **kwargs)",
            "def group_install(name, skip=(), include=(), **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    .. versionadded:: 2014.1.0\\n\\n    Install the passed package group(s). This is basically a wrapper around\\n    :py:func:`pkg.install <salt.modules.yumpkg.install>`, which performs\\n    package group resolution for the user. This function is currently\\n    considered experimental, and should be expected to undergo changes.\\n\\n    name\\n        Package group to install. To install more than one group, either use a\\n        comma-separated list or pass the value as a python list.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.group_install \\'Group 1\\'\\n            salt \\'*\\' pkg.group_install \\'Group 1,Group 2\\'\\n            salt \\'*\\' pkg.group_install \\'[\"Group 1\", \"Group 2\"]\\'\\n\\n    skip\\n        Packages that would normally be installed by the package group\\n        (\"default\" packages), which should not be installed. Can be passed\\n        either as a comma-separated list or a python list.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.group_install \\'My Group\\' skip=\\'foo,bar\\'\\n            salt \\'*\\' pkg.group_install \\'My Group\\' skip=\\'[\"foo\", \"bar\"]\\'\\n\\n    include\\n        Packages which are included in a group, which would not normally be\\n        installed by a ``yum groupinstall`` (\"optional\" packages). Note that\\n        this will not enforce group membership; if you include packages which\\n        are not members of the specified groups, they will still be installed.\\n        Can be passed either as a comma-separated list or a python list.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.group_install \\'My Group\\' include=\\'foo,bar\\'\\n            salt \\'*\\' pkg.group_install \\'My Group\\' include=\\'[\"foo\", \"bar\"]\\'\\n\\n    .. note::\\n        Because this is essentially a wrapper around pkg.install, any argument\\n        which can be passed to pkg.install may also be included here, and it\\n        will be passed along wholesale.\\n    '\n    groups = name.split(',') if isinstance(name, str) else name\n    if not groups:\n        raise SaltInvocationError('no groups specified')\n    elif not isinstance(groups, list):\n        raise SaltInvocationError(\"'groups' must be a list\")\n    if isinstance(skip, str):\n        skip = skip.split(',')\n    if not isinstance(skip, (list, tuple)):\n        raise SaltInvocationError(\"'skip' must be a list\")\n    if isinstance(include, str):\n        include = include.split(',')\n    if not isinstance(include, (list, tuple)):\n        raise SaltInvocationError(\"'include' must be a list\")\n    targets = []\n    for group in groups:\n        group_detail = group_info(group)\n        targets.extend(group_detail.get('mandatory', []))\n        targets.extend([pkg for pkg in group_detail.get('default', []) if pkg not in skip])\n    if include:\n        targets.extend(include)\n    pkgs = [x for x in targets if x not in list_pkgs()]\n    if not pkgs:\n        return {}\n    return install(pkgs=pkgs, **kwargs)",
            "def group_install(name, skip=(), include=(), **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    .. versionadded:: 2014.1.0\\n\\n    Install the passed package group(s). This is basically a wrapper around\\n    :py:func:`pkg.install <salt.modules.yumpkg.install>`, which performs\\n    package group resolution for the user. This function is currently\\n    considered experimental, and should be expected to undergo changes.\\n\\n    name\\n        Package group to install. To install more than one group, either use a\\n        comma-separated list or pass the value as a python list.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.group_install \\'Group 1\\'\\n            salt \\'*\\' pkg.group_install \\'Group 1,Group 2\\'\\n            salt \\'*\\' pkg.group_install \\'[\"Group 1\", \"Group 2\"]\\'\\n\\n    skip\\n        Packages that would normally be installed by the package group\\n        (\"default\" packages), which should not be installed. Can be passed\\n        either as a comma-separated list or a python list.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.group_install \\'My Group\\' skip=\\'foo,bar\\'\\n            salt \\'*\\' pkg.group_install \\'My Group\\' skip=\\'[\"foo\", \"bar\"]\\'\\n\\n    include\\n        Packages which are included in a group, which would not normally be\\n        installed by a ``yum groupinstall`` (\"optional\" packages). Note that\\n        this will not enforce group membership; if you include packages which\\n        are not members of the specified groups, they will still be installed.\\n        Can be passed either as a comma-separated list or a python list.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.group_install \\'My Group\\' include=\\'foo,bar\\'\\n            salt \\'*\\' pkg.group_install \\'My Group\\' include=\\'[\"foo\", \"bar\"]\\'\\n\\n    .. note::\\n        Because this is essentially a wrapper around pkg.install, any argument\\n        which can be passed to pkg.install may also be included here, and it\\n        will be passed along wholesale.\\n    '\n    groups = name.split(',') if isinstance(name, str) else name\n    if not groups:\n        raise SaltInvocationError('no groups specified')\n    elif not isinstance(groups, list):\n        raise SaltInvocationError(\"'groups' must be a list\")\n    if isinstance(skip, str):\n        skip = skip.split(',')\n    if not isinstance(skip, (list, tuple)):\n        raise SaltInvocationError(\"'skip' must be a list\")\n    if isinstance(include, str):\n        include = include.split(',')\n    if not isinstance(include, (list, tuple)):\n        raise SaltInvocationError(\"'include' must be a list\")\n    targets = []\n    for group in groups:\n        group_detail = group_info(group)\n        targets.extend(group_detail.get('mandatory', []))\n        targets.extend([pkg for pkg in group_detail.get('default', []) if pkg not in skip])\n    if include:\n        targets.extend(include)\n    pkgs = [x for x in targets if x not in list_pkgs()]\n    if not pkgs:\n        return {}\n    return install(pkgs=pkgs, **kwargs)",
            "def group_install(name, skip=(), include=(), **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    .. versionadded:: 2014.1.0\\n\\n    Install the passed package group(s). This is basically a wrapper around\\n    :py:func:`pkg.install <salt.modules.yumpkg.install>`, which performs\\n    package group resolution for the user. This function is currently\\n    considered experimental, and should be expected to undergo changes.\\n\\n    name\\n        Package group to install. To install more than one group, either use a\\n        comma-separated list or pass the value as a python list.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.group_install \\'Group 1\\'\\n            salt \\'*\\' pkg.group_install \\'Group 1,Group 2\\'\\n            salt \\'*\\' pkg.group_install \\'[\"Group 1\", \"Group 2\"]\\'\\n\\n    skip\\n        Packages that would normally be installed by the package group\\n        (\"default\" packages), which should not be installed. Can be passed\\n        either as a comma-separated list or a python list.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.group_install \\'My Group\\' skip=\\'foo,bar\\'\\n            salt \\'*\\' pkg.group_install \\'My Group\\' skip=\\'[\"foo\", \"bar\"]\\'\\n\\n    include\\n        Packages which are included in a group, which would not normally be\\n        installed by a ``yum groupinstall`` (\"optional\" packages). Note that\\n        this will not enforce group membership; if you include packages which\\n        are not members of the specified groups, they will still be installed.\\n        Can be passed either as a comma-separated list or a python list.\\n\\n        CLI Examples:\\n\\n        .. code-block:: bash\\n\\n            salt \\'*\\' pkg.group_install \\'My Group\\' include=\\'foo,bar\\'\\n            salt \\'*\\' pkg.group_install \\'My Group\\' include=\\'[\"foo\", \"bar\"]\\'\\n\\n    .. note::\\n        Because this is essentially a wrapper around pkg.install, any argument\\n        which can be passed to pkg.install may also be included here, and it\\n        will be passed along wholesale.\\n    '\n    groups = name.split(',') if isinstance(name, str) else name\n    if not groups:\n        raise SaltInvocationError('no groups specified')\n    elif not isinstance(groups, list):\n        raise SaltInvocationError(\"'groups' must be a list\")\n    if isinstance(skip, str):\n        skip = skip.split(',')\n    if not isinstance(skip, (list, tuple)):\n        raise SaltInvocationError(\"'skip' must be a list\")\n    if isinstance(include, str):\n        include = include.split(',')\n    if not isinstance(include, (list, tuple)):\n        raise SaltInvocationError(\"'include' must be a list\")\n    targets = []\n    for group in groups:\n        group_detail = group_info(group)\n        targets.extend(group_detail.get('mandatory', []))\n        targets.extend([pkg for pkg in group_detail.get('default', []) if pkg not in skip])\n    if include:\n        targets.extend(include)\n    pkgs = [x for x in targets if x not in list_pkgs()]\n    if not pkgs:\n        return {}\n    return install(pkgs=pkgs, **kwargs)"
        ]
    },
    {
        "func_name": "list_repos",
        "original": "def list_repos(basedir=None, **kwargs):\n    \"\"\"\n    Lists all repos in <basedir> (default: all dirs in `reposdir` yum option).\n\n    Strict parsing of configuration files is the default, this can be disabled\n    using the  ``strict_config`` keyword argument set to False\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.list_repos\n        salt '*' pkg.list_repos basedir=/path/to/dir\n        salt '*' pkg.list_repos basedir=/path/to/dir,/path/to/another/dir strict_config=False\n    \"\"\"\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = {}\n    log.debug('Searching for repos in %s', basedirs)\n    for bdir in basedirs:\n        if not os.path.exists(bdir):\n            continue\n        for repofile in os.listdir(bdir):\n            repopath = f'{bdir}/{repofile}'\n            if not repofile.endswith('.repo'):\n                continue\n            filerepos = _parse_repo_file(repopath, strict_parser)[1]\n            for reponame in filerepos:\n                repo = filerepos[reponame]\n                repo['file'] = repopath\n                repos[reponame] = repo\n    return repos",
        "mutated": [
            "def list_repos(basedir=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Lists all repos in <basedir> (default: all dirs in `reposdir` yum option).\\n\\n    Strict parsing of configuration files is the default, this can be disabled\\n    using the  ``strict_config`` keyword argument set to False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_repos\\n        salt '*' pkg.list_repos basedir=/path/to/dir\\n        salt '*' pkg.list_repos basedir=/path/to/dir,/path/to/another/dir strict_config=False\\n    \"\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = {}\n    log.debug('Searching for repos in %s', basedirs)\n    for bdir in basedirs:\n        if not os.path.exists(bdir):\n            continue\n        for repofile in os.listdir(bdir):\n            repopath = f'{bdir}/{repofile}'\n            if not repofile.endswith('.repo'):\n                continue\n            filerepos = _parse_repo_file(repopath, strict_parser)[1]\n            for reponame in filerepos:\n                repo = filerepos[reponame]\n                repo['file'] = repopath\n                repos[reponame] = repo\n    return repos",
            "def list_repos(basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Lists all repos in <basedir> (default: all dirs in `reposdir` yum option).\\n\\n    Strict parsing of configuration files is the default, this can be disabled\\n    using the  ``strict_config`` keyword argument set to False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_repos\\n        salt '*' pkg.list_repos basedir=/path/to/dir\\n        salt '*' pkg.list_repos basedir=/path/to/dir,/path/to/another/dir strict_config=False\\n    \"\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = {}\n    log.debug('Searching for repos in %s', basedirs)\n    for bdir in basedirs:\n        if not os.path.exists(bdir):\n            continue\n        for repofile in os.listdir(bdir):\n            repopath = f'{bdir}/{repofile}'\n            if not repofile.endswith('.repo'):\n                continue\n            filerepos = _parse_repo_file(repopath, strict_parser)[1]\n            for reponame in filerepos:\n                repo = filerepos[reponame]\n                repo['file'] = repopath\n                repos[reponame] = repo\n    return repos",
            "def list_repos(basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Lists all repos in <basedir> (default: all dirs in `reposdir` yum option).\\n\\n    Strict parsing of configuration files is the default, this can be disabled\\n    using the  ``strict_config`` keyword argument set to False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_repos\\n        salt '*' pkg.list_repos basedir=/path/to/dir\\n        salt '*' pkg.list_repos basedir=/path/to/dir,/path/to/another/dir strict_config=False\\n    \"\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = {}\n    log.debug('Searching for repos in %s', basedirs)\n    for bdir in basedirs:\n        if not os.path.exists(bdir):\n            continue\n        for repofile in os.listdir(bdir):\n            repopath = f'{bdir}/{repofile}'\n            if not repofile.endswith('.repo'):\n                continue\n            filerepos = _parse_repo_file(repopath, strict_parser)[1]\n            for reponame in filerepos:\n                repo = filerepos[reponame]\n                repo['file'] = repopath\n                repos[reponame] = repo\n    return repos",
            "def list_repos(basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Lists all repos in <basedir> (default: all dirs in `reposdir` yum option).\\n\\n    Strict parsing of configuration files is the default, this can be disabled\\n    using the  ``strict_config`` keyword argument set to False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_repos\\n        salt '*' pkg.list_repos basedir=/path/to/dir\\n        salt '*' pkg.list_repos basedir=/path/to/dir,/path/to/another/dir strict_config=False\\n    \"\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = {}\n    log.debug('Searching for repos in %s', basedirs)\n    for bdir in basedirs:\n        if not os.path.exists(bdir):\n            continue\n        for repofile in os.listdir(bdir):\n            repopath = f'{bdir}/{repofile}'\n            if not repofile.endswith('.repo'):\n                continue\n            filerepos = _parse_repo_file(repopath, strict_parser)[1]\n            for reponame in filerepos:\n                repo = filerepos[reponame]\n                repo['file'] = repopath\n                repos[reponame] = repo\n    return repos",
            "def list_repos(basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Lists all repos in <basedir> (default: all dirs in `reposdir` yum option).\\n\\n    Strict parsing of configuration files is the default, this can be disabled\\n    using the  ``strict_config`` keyword argument set to False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_repos\\n        salt '*' pkg.list_repos basedir=/path/to/dir\\n        salt '*' pkg.list_repos basedir=/path/to/dir,/path/to/another/dir strict_config=False\\n    \"\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = {}\n    log.debug('Searching for repos in %s', basedirs)\n    for bdir in basedirs:\n        if not os.path.exists(bdir):\n            continue\n        for repofile in os.listdir(bdir):\n            repopath = f'{bdir}/{repofile}'\n            if not repofile.endswith('.repo'):\n                continue\n            filerepos = _parse_repo_file(repopath, strict_parser)[1]\n            for reponame in filerepos:\n                repo = filerepos[reponame]\n                repo['file'] = repopath\n                repos[reponame] = repo\n    return repos"
        ]
    },
    {
        "func_name": "get_repo",
        "original": "def get_repo(repo, basedir=None, **kwargs):\n    \"\"\"\n    Display a repo from <basedir> (default basedir: all dirs in ``reposdir``\n    yum option).\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' pkg.get_repo myrepo\n        salt '*' pkg.get_repo myrepo basedir=/path/to/dir\n        salt '*' pkg.get_repo myrepo basedir=/path/to/dir,/path/to/another/dir\n    \"\"\"\n    repos = list_repos(basedir, **kwargs)\n    if repo.startswith('copr:'):\n        repo = _get_copr_repo(repo)\n    repofile = ''\n    for list_repo in repos:\n        if list_repo == repo:\n            repofile = repos[list_repo]['file']\n    if repofile:\n        strict_parser = kwargs.get('strict_config', True)\n        filerepos = _parse_repo_file(repofile, strict_parser)[1]\n        return filerepos[repo]\n    return {}",
        "mutated": [
            "def get_repo(repo, basedir=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Display a repo from <basedir> (default basedir: all dirs in ``reposdir``\\n    yum option).\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.get_repo myrepo\\n        salt '*' pkg.get_repo myrepo basedir=/path/to/dir\\n        salt '*' pkg.get_repo myrepo basedir=/path/to/dir,/path/to/another/dir\\n    \"\n    repos = list_repos(basedir, **kwargs)\n    if repo.startswith('copr:'):\n        repo = _get_copr_repo(repo)\n    repofile = ''\n    for list_repo in repos:\n        if list_repo == repo:\n            repofile = repos[list_repo]['file']\n    if repofile:\n        strict_parser = kwargs.get('strict_config', True)\n        filerepos = _parse_repo_file(repofile, strict_parser)[1]\n        return filerepos[repo]\n    return {}",
            "def get_repo(repo, basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Display a repo from <basedir> (default basedir: all dirs in ``reposdir``\\n    yum option).\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.get_repo myrepo\\n        salt '*' pkg.get_repo myrepo basedir=/path/to/dir\\n        salt '*' pkg.get_repo myrepo basedir=/path/to/dir,/path/to/another/dir\\n    \"\n    repos = list_repos(basedir, **kwargs)\n    if repo.startswith('copr:'):\n        repo = _get_copr_repo(repo)\n    repofile = ''\n    for list_repo in repos:\n        if list_repo == repo:\n            repofile = repos[list_repo]['file']\n    if repofile:\n        strict_parser = kwargs.get('strict_config', True)\n        filerepos = _parse_repo_file(repofile, strict_parser)[1]\n        return filerepos[repo]\n    return {}",
            "def get_repo(repo, basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Display a repo from <basedir> (default basedir: all dirs in ``reposdir``\\n    yum option).\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.get_repo myrepo\\n        salt '*' pkg.get_repo myrepo basedir=/path/to/dir\\n        salt '*' pkg.get_repo myrepo basedir=/path/to/dir,/path/to/another/dir\\n    \"\n    repos = list_repos(basedir, **kwargs)\n    if repo.startswith('copr:'):\n        repo = _get_copr_repo(repo)\n    repofile = ''\n    for list_repo in repos:\n        if list_repo == repo:\n            repofile = repos[list_repo]['file']\n    if repofile:\n        strict_parser = kwargs.get('strict_config', True)\n        filerepos = _parse_repo_file(repofile, strict_parser)[1]\n        return filerepos[repo]\n    return {}",
            "def get_repo(repo, basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Display a repo from <basedir> (default basedir: all dirs in ``reposdir``\\n    yum option).\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.get_repo myrepo\\n        salt '*' pkg.get_repo myrepo basedir=/path/to/dir\\n        salt '*' pkg.get_repo myrepo basedir=/path/to/dir,/path/to/another/dir\\n    \"\n    repos = list_repos(basedir, **kwargs)\n    if repo.startswith('copr:'):\n        repo = _get_copr_repo(repo)\n    repofile = ''\n    for list_repo in repos:\n        if list_repo == repo:\n            repofile = repos[list_repo]['file']\n    if repofile:\n        strict_parser = kwargs.get('strict_config', True)\n        filerepos = _parse_repo_file(repofile, strict_parser)[1]\n        return filerepos[repo]\n    return {}",
            "def get_repo(repo, basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Display a repo from <basedir> (default basedir: all dirs in ``reposdir``\\n    yum option).\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.get_repo myrepo\\n        salt '*' pkg.get_repo myrepo basedir=/path/to/dir\\n        salt '*' pkg.get_repo myrepo basedir=/path/to/dir,/path/to/another/dir\\n    \"\n    repos = list_repos(basedir, **kwargs)\n    if repo.startswith('copr:'):\n        repo = _get_copr_repo(repo)\n    repofile = ''\n    for list_repo in repos:\n        if list_repo == repo:\n            repofile = repos[list_repo]['file']\n    if repofile:\n        strict_parser = kwargs.get('strict_config', True)\n        filerepos = _parse_repo_file(repofile, strict_parser)[1]\n        return filerepos[repo]\n    return {}"
        ]
    },
    {
        "func_name": "del_repo",
        "original": "def del_repo(repo, basedir=None, **kwargs):\n    \"\"\"\n    Delete a repo from <basedir> (default basedir: all dirs in `reposdir` yum\n    option).\n\n    If the .repo file in which the repo exists does not contain any other repo\n    configuration, the file itself will be deleted.\n\n    Strict parsing of configuration files is the default, this can be disabled\n    using the  ``strict_config`` keyword argument set to False\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' pkg.del_repo myrepo\n        salt '*' pkg.del_repo myrepo basedir=/path/to/dir strict_config=False\n        salt '*' pkg.del_repo myrepo basedir=/path/to/dir,/path/to/another/dir\n    \"\"\"\n    if repo.startswith('copr:'):\n        repo = _get_copr_repo(repo)\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = list_repos(basedirs, **kwargs)\n    if repo not in repos:\n        return f'Error: the {repo} repo does not exist in {basedirs}'\n    repofile = ''\n    for arepo in repos:\n        if arepo == repo:\n            repofile = repos[arepo]['file']\n    onlyrepo = True\n    for arepo in repos:\n        if arepo == repo:\n            continue\n        if repos[arepo]['file'] == repofile:\n            onlyrepo = False\n    if onlyrepo:\n        os.remove(repofile)\n        return f'File {repofile} containing repo {repo} has been removed'\n    (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n    content = header\n    for stanza in filerepos.keys():\n        if stanza == repo:\n            continue\n        comments = ''\n        if 'comments' in filerepos[stanza].keys():\n            comments = salt.utils.pkg.rpm.combine_comments(filerepos[stanza]['comments'])\n            del filerepos[stanza]['comments']\n        content += f'\\n[{stanza}]'\n        for line in filerepos[stanza]:\n            value = filerepos[stanza][line]\n            if isinstance(value, str) and '\\n' in value:\n                value = '\\n '.join(value.split('\\n'))\n            content += f'\\n{line}={value}'\n        content += f'\\n{comments}\\n'\n    with salt.utils.files.fopen(repofile, 'w') as fileout:\n        fileout.write(salt.utils.stringutils.to_str(content))\n    return f'Repo {repo} has been removed from {repofile}'",
        "mutated": [
            "def del_repo(repo, basedir=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Delete a repo from <basedir> (default basedir: all dirs in `reposdir` yum\\n    option).\\n\\n    If the .repo file in which the repo exists does not contain any other repo\\n    configuration, the file itself will be deleted.\\n\\n    Strict parsing of configuration files is the default, this can be disabled\\n    using the  ``strict_config`` keyword argument set to False\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.del_repo myrepo\\n        salt '*' pkg.del_repo myrepo basedir=/path/to/dir strict_config=False\\n        salt '*' pkg.del_repo myrepo basedir=/path/to/dir,/path/to/another/dir\\n    \"\n    if repo.startswith('copr:'):\n        repo = _get_copr_repo(repo)\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = list_repos(basedirs, **kwargs)\n    if repo not in repos:\n        return f'Error: the {repo} repo does not exist in {basedirs}'\n    repofile = ''\n    for arepo in repos:\n        if arepo == repo:\n            repofile = repos[arepo]['file']\n    onlyrepo = True\n    for arepo in repos:\n        if arepo == repo:\n            continue\n        if repos[arepo]['file'] == repofile:\n            onlyrepo = False\n    if onlyrepo:\n        os.remove(repofile)\n        return f'File {repofile} containing repo {repo} has been removed'\n    (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n    content = header\n    for stanza in filerepos.keys():\n        if stanza == repo:\n            continue\n        comments = ''\n        if 'comments' in filerepos[stanza].keys():\n            comments = salt.utils.pkg.rpm.combine_comments(filerepos[stanza]['comments'])\n            del filerepos[stanza]['comments']\n        content += f'\\n[{stanza}]'\n        for line in filerepos[stanza]:\n            value = filerepos[stanza][line]\n            if isinstance(value, str) and '\\n' in value:\n                value = '\\n '.join(value.split('\\n'))\n            content += f'\\n{line}={value}'\n        content += f'\\n{comments}\\n'\n    with salt.utils.files.fopen(repofile, 'w') as fileout:\n        fileout.write(salt.utils.stringutils.to_str(content))\n    return f'Repo {repo} has been removed from {repofile}'",
            "def del_repo(repo, basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Delete a repo from <basedir> (default basedir: all dirs in `reposdir` yum\\n    option).\\n\\n    If the .repo file in which the repo exists does not contain any other repo\\n    configuration, the file itself will be deleted.\\n\\n    Strict parsing of configuration files is the default, this can be disabled\\n    using the  ``strict_config`` keyword argument set to False\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.del_repo myrepo\\n        salt '*' pkg.del_repo myrepo basedir=/path/to/dir strict_config=False\\n        salt '*' pkg.del_repo myrepo basedir=/path/to/dir,/path/to/another/dir\\n    \"\n    if repo.startswith('copr:'):\n        repo = _get_copr_repo(repo)\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = list_repos(basedirs, **kwargs)\n    if repo not in repos:\n        return f'Error: the {repo} repo does not exist in {basedirs}'\n    repofile = ''\n    for arepo in repos:\n        if arepo == repo:\n            repofile = repos[arepo]['file']\n    onlyrepo = True\n    for arepo in repos:\n        if arepo == repo:\n            continue\n        if repos[arepo]['file'] == repofile:\n            onlyrepo = False\n    if onlyrepo:\n        os.remove(repofile)\n        return f'File {repofile} containing repo {repo} has been removed'\n    (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n    content = header\n    for stanza in filerepos.keys():\n        if stanza == repo:\n            continue\n        comments = ''\n        if 'comments' in filerepos[stanza].keys():\n            comments = salt.utils.pkg.rpm.combine_comments(filerepos[stanza]['comments'])\n            del filerepos[stanza]['comments']\n        content += f'\\n[{stanza}]'\n        for line in filerepos[stanza]:\n            value = filerepos[stanza][line]\n            if isinstance(value, str) and '\\n' in value:\n                value = '\\n '.join(value.split('\\n'))\n            content += f'\\n{line}={value}'\n        content += f'\\n{comments}\\n'\n    with salt.utils.files.fopen(repofile, 'w') as fileout:\n        fileout.write(salt.utils.stringutils.to_str(content))\n    return f'Repo {repo} has been removed from {repofile}'",
            "def del_repo(repo, basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Delete a repo from <basedir> (default basedir: all dirs in `reposdir` yum\\n    option).\\n\\n    If the .repo file in which the repo exists does not contain any other repo\\n    configuration, the file itself will be deleted.\\n\\n    Strict parsing of configuration files is the default, this can be disabled\\n    using the  ``strict_config`` keyword argument set to False\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.del_repo myrepo\\n        salt '*' pkg.del_repo myrepo basedir=/path/to/dir strict_config=False\\n        salt '*' pkg.del_repo myrepo basedir=/path/to/dir,/path/to/another/dir\\n    \"\n    if repo.startswith('copr:'):\n        repo = _get_copr_repo(repo)\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = list_repos(basedirs, **kwargs)\n    if repo not in repos:\n        return f'Error: the {repo} repo does not exist in {basedirs}'\n    repofile = ''\n    for arepo in repos:\n        if arepo == repo:\n            repofile = repos[arepo]['file']\n    onlyrepo = True\n    for arepo in repos:\n        if arepo == repo:\n            continue\n        if repos[arepo]['file'] == repofile:\n            onlyrepo = False\n    if onlyrepo:\n        os.remove(repofile)\n        return f'File {repofile} containing repo {repo} has been removed'\n    (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n    content = header\n    for stanza in filerepos.keys():\n        if stanza == repo:\n            continue\n        comments = ''\n        if 'comments' in filerepos[stanza].keys():\n            comments = salt.utils.pkg.rpm.combine_comments(filerepos[stanza]['comments'])\n            del filerepos[stanza]['comments']\n        content += f'\\n[{stanza}]'\n        for line in filerepos[stanza]:\n            value = filerepos[stanza][line]\n            if isinstance(value, str) and '\\n' in value:\n                value = '\\n '.join(value.split('\\n'))\n            content += f'\\n{line}={value}'\n        content += f'\\n{comments}\\n'\n    with salt.utils.files.fopen(repofile, 'w') as fileout:\n        fileout.write(salt.utils.stringutils.to_str(content))\n    return f'Repo {repo} has been removed from {repofile}'",
            "def del_repo(repo, basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Delete a repo from <basedir> (default basedir: all dirs in `reposdir` yum\\n    option).\\n\\n    If the .repo file in which the repo exists does not contain any other repo\\n    configuration, the file itself will be deleted.\\n\\n    Strict parsing of configuration files is the default, this can be disabled\\n    using the  ``strict_config`` keyword argument set to False\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.del_repo myrepo\\n        salt '*' pkg.del_repo myrepo basedir=/path/to/dir strict_config=False\\n        salt '*' pkg.del_repo myrepo basedir=/path/to/dir,/path/to/another/dir\\n    \"\n    if repo.startswith('copr:'):\n        repo = _get_copr_repo(repo)\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = list_repos(basedirs, **kwargs)\n    if repo not in repos:\n        return f'Error: the {repo} repo does not exist in {basedirs}'\n    repofile = ''\n    for arepo in repos:\n        if arepo == repo:\n            repofile = repos[arepo]['file']\n    onlyrepo = True\n    for arepo in repos:\n        if arepo == repo:\n            continue\n        if repos[arepo]['file'] == repofile:\n            onlyrepo = False\n    if onlyrepo:\n        os.remove(repofile)\n        return f'File {repofile} containing repo {repo} has been removed'\n    (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n    content = header\n    for stanza in filerepos.keys():\n        if stanza == repo:\n            continue\n        comments = ''\n        if 'comments' in filerepos[stanza].keys():\n            comments = salt.utils.pkg.rpm.combine_comments(filerepos[stanza]['comments'])\n            del filerepos[stanza]['comments']\n        content += f'\\n[{stanza}]'\n        for line in filerepos[stanza]:\n            value = filerepos[stanza][line]\n            if isinstance(value, str) and '\\n' in value:\n                value = '\\n '.join(value.split('\\n'))\n            content += f'\\n{line}={value}'\n        content += f'\\n{comments}\\n'\n    with salt.utils.files.fopen(repofile, 'w') as fileout:\n        fileout.write(salt.utils.stringutils.to_str(content))\n    return f'Repo {repo} has been removed from {repofile}'",
            "def del_repo(repo, basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Delete a repo from <basedir> (default basedir: all dirs in `reposdir` yum\\n    option).\\n\\n    If the .repo file in which the repo exists does not contain any other repo\\n    configuration, the file itself will be deleted.\\n\\n    Strict parsing of configuration files is the default, this can be disabled\\n    using the  ``strict_config`` keyword argument set to False\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.del_repo myrepo\\n        salt '*' pkg.del_repo myrepo basedir=/path/to/dir strict_config=False\\n        salt '*' pkg.del_repo myrepo basedir=/path/to/dir,/path/to/another/dir\\n    \"\n    if repo.startswith('copr:'):\n        repo = _get_copr_repo(repo)\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = list_repos(basedirs, **kwargs)\n    if repo not in repos:\n        return f'Error: the {repo} repo does not exist in {basedirs}'\n    repofile = ''\n    for arepo in repos:\n        if arepo == repo:\n            repofile = repos[arepo]['file']\n    onlyrepo = True\n    for arepo in repos:\n        if arepo == repo:\n            continue\n        if repos[arepo]['file'] == repofile:\n            onlyrepo = False\n    if onlyrepo:\n        os.remove(repofile)\n        return f'File {repofile} containing repo {repo} has been removed'\n    (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n    content = header\n    for stanza in filerepos.keys():\n        if stanza == repo:\n            continue\n        comments = ''\n        if 'comments' in filerepos[stanza].keys():\n            comments = salt.utils.pkg.rpm.combine_comments(filerepos[stanza]['comments'])\n            del filerepos[stanza]['comments']\n        content += f'\\n[{stanza}]'\n        for line in filerepos[stanza]:\n            value = filerepos[stanza][line]\n            if isinstance(value, str) and '\\n' in value:\n                value = '\\n '.join(value.split('\\n'))\n            content += f'\\n{line}={value}'\n        content += f'\\n{comments}\\n'\n    with salt.utils.files.fopen(repofile, 'w') as fileout:\n        fileout.write(salt.utils.stringutils.to_str(content))\n    return f'Repo {repo} has been removed from {repofile}'"
        ]
    },
    {
        "func_name": "mod_repo",
        "original": "def mod_repo(repo, basedir=None, **kwargs):\n    \"\"\"\n    Modify one or more values for a repo. If the repo does not exist, it will\n    be created, so long as the following values are specified:\n\n    repo\n        name by which the yum refers to the repo\n    name\n        a human-readable name for the repo\n    baseurl\n        the URL for yum to reference\n    mirrorlist\n        the URL for yum to reference\n\n    Key/Value pairs may also be removed from a repo's configuration by setting\n    a key to a blank value. Bear in mind that a name cannot be deleted, and a\n    baseurl can only be deleted if a mirrorlist is specified (or vice versa).\n\n    Strict parsing of configuration files is the default, this can be disabled\n    using the  ``strict_config`` keyword argument set to False\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' pkg.mod_repo reponame enabled=1 gpgcheck=1\n        salt '*' pkg.mod_repo reponame basedir=/path/to/dir enabled=1 strict_config=False\n        salt '*' pkg.mod_repo reponame baseurl= mirrorlist=http://host.com/\n    \"\"\"\n    repo_opts = {x: kwargs[x] for x in kwargs if not x.startswith('__') and x not in ('saltenv',)}\n    if all((x in repo_opts for x in ('mirrorlist', 'baseurl'))):\n        raise SaltInvocationError(\"Only one of 'mirrorlist' and 'baseurl' can be specified\")\n    use_copr = False\n    if repo.startswith('copr:'):\n        copr_name = repo.split(':', 1)[1]\n        repo = _get_copr_repo(repo)\n        use_copr = True\n    todelete = []\n    for key in list(repo_opts):\n        if repo_opts[key] != 0 and (not repo_opts[key]):\n            del repo_opts[key]\n            todelete.append(key)\n    if 'mirrorlist' in repo_opts:\n        todelete.append('baseurl')\n    elif 'baseurl' in repo_opts:\n        todelete.append('mirrorlist')\n    if 'name' in todelete:\n        raise SaltInvocationError('The repo name cannot be deleted')\n    repos = {}\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = list_repos(basedirs, **kwargs)\n    repofile = ''\n    header = ''\n    filerepos = {}\n    if repo not in repos:\n        newdir = None\n        for d in basedirs:\n            if os.path.exists(d):\n                newdir = d\n                break\n        if not newdir:\n            raise SaltInvocationError('The repo does not exist and needs to be created, but none of the following basedir directories exist: {}'.format(basedirs))\n        repofile = f'{newdir}/{repo}.repo'\n        if use_copr:\n            copr_plugin_name = ''\n            if _yum() in ('dnf', 'dnf5'):\n                copr_plugin_name = 'dnf-plugins-core'\n            else:\n                copr_plugin_name = 'yum-plugin-copr'\n            if not __salt__['pkg_resource.version'](copr_plugin_name):\n                raise SaltInvocationError(f'{copr_plugin_name} must be installed to use COPR')\n            out = _call_yum(['copr', 'enable', copr_name, '-y'])\n            if out['retcode']:\n                raise CommandExecutionError(\"Unable to add COPR '{}'. '{}' exited with status {!s}: '{}' \".format(copr_name, _yum(), out['retcode'], out['stderr']))\n            repos = list_repos(basedirs, **kwargs)\n            repofile = repos[repo]['file']\n            (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n        else:\n            repofile = f'{newdir}/{repo}.repo'\n            if 'name' not in repo_opts:\n                raise SaltInvocationError('The repo does not exist and needs to be created, but a name was not given')\n            if 'baseurl' not in repo_opts and 'mirrorlist' not in repo_opts:\n                raise SaltInvocationError('The repo does not exist and needs to be created, but either a baseurl or a mirrorlist needs to be given')\n            filerepos[repo] = {}\n    else:\n        repofile = repos[repo]['file']\n        (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n    if 'baseurl' in todelete:\n        if 'mirrorlist' not in repo_opts and 'mirrorlist' not in filerepos[repo]:\n            raise SaltInvocationError('Cannot delete baseurl without specifying mirrorlist')\n    if 'mirrorlist' in todelete:\n        if 'baseurl' not in repo_opts and 'baseurl' not in filerepos[repo]:\n            raise SaltInvocationError('Cannot delete mirrorlist without specifying baseurl')\n    for key in todelete:\n        if key in filerepos[repo].copy().keys():\n            del filerepos[repo][key]\n    _bool_to_str = lambda x: '1' if x else '0'\n    filerepos[repo].update(repo_opts)\n    content = header\n    for stanza in filerepos.keys():\n        comments = salt.utils.pkg.rpm.combine_comments(filerepos[stanza].pop('comments', []))\n        content += f'[{stanza}]\\n'\n        for line in filerepos[stanza].keys():\n            value = filerepos[stanza][line]\n            if isinstance(value, str) and '\\n' in value:\n                value = '\\n '.join(value.split('\\n'))\n            content += '{}={}\\n'.format(line, value if not isinstance(value, bool) else _bool_to_str(value))\n        content += comments + '\\n'\n    with salt.utils.files.fopen(repofile, 'w') as fileout:\n        fileout.write(salt.utils.stringutils.to_str(content))\n    return {repofile: filerepos}",
        "mutated": [
            "def mod_repo(repo, basedir=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Modify one or more values for a repo. If the repo does not exist, it will\\n    be created, so long as the following values are specified:\\n\\n    repo\\n        name by which the yum refers to the repo\\n    name\\n        a human-readable name for the repo\\n    baseurl\\n        the URL for yum to reference\\n    mirrorlist\\n        the URL for yum to reference\\n\\n    Key/Value pairs may also be removed from a repo's configuration by setting\\n    a key to a blank value. Bear in mind that a name cannot be deleted, and a\\n    baseurl can only be deleted if a mirrorlist is specified (or vice versa).\\n\\n    Strict parsing of configuration files is the default, this can be disabled\\n    using the  ``strict_config`` keyword argument set to False\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.mod_repo reponame enabled=1 gpgcheck=1\\n        salt '*' pkg.mod_repo reponame basedir=/path/to/dir enabled=1 strict_config=False\\n        salt '*' pkg.mod_repo reponame baseurl= mirrorlist=http://host.com/\\n    \"\n    repo_opts = {x: kwargs[x] for x in kwargs if not x.startswith('__') and x not in ('saltenv',)}\n    if all((x in repo_opts for x in ('mirrorlist', 'baseurl'))):\n        raise SaltInvocationError(\"Only one of 'mirrorlist' and 'baseurl' can be specified\")\n    use_copr = False\n    if repo.startswith('copr:'):\n        copr_name = repo.split(':', 1)[1]\n        repo = _get_copr_repo(repo)\n        use_copr = True\n    todelete = []\n    for key in list(repo_opts):\n        if repo_opts[key] != 0 and (not repo_opts[key]):\n            del repo_opts[key]\n            todelete.append(key)\n    if 'mirrorlist' in repo_opts:\n        todelete.append('baseurl')\n    elif 'baseurl' in repo_opts:\n        todelete.append('mirrorlist')\n    if 'name' in todelete:\n        raise SaltInvocationError('The repo name cannot be deleted')\n    repos = {}\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = list_repos(basedirs, **kwargs)\n    repofile = ''\n    header = ''\n    filerepos = {}\n    if repo not in repos:\n        newdir = None\n        for d in basedirs:\n            if os.path.exists(d):\n                newdir = d\n                break\n        if not newdir:\n            raise SaltInvocationError('The repo does not exist and needs to be created, but none of the following basedir directories exist: {}'.format(basedirs))\n        repofile = f'{newdir}/{repo}.repo'\n        if use_copr:\n            copr_plugin_name = ''\n            if _yum() in ('dnf', 'dnf5'):\n                copr_plugin_name = 'dnf-plugins-core'\n            else:\n                copr_plugin_name = 'yum-plugin-copr'\n            if not __salt__['pkg_resource.version'](copr_plugin_name):\n                raise SaltInvocationError(f'{copr_plugin_name} must be installed to use COPR')\n            out = _call_yum(['copr', 'enable', copr_name, '-y'])\n            if out['retcode']:\n                raise CommandExecutionError(\"Unable to add COPR '{}'. '{}' exited with status {!s}: '{}' \".format(copr_name, _yum(), out['retcode'], out['stderr']))\n            repos = list_repos(basedirs, **kwargs)\n            repofile = repos[repo]['file']\n            (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n        else:\n            repofile = f'{newdir}/{repo}.repo'\n            if 'name' not in repo_opts:\n                raise SaltInvocationError('The repo does not exist and needs to be created, but a name was not given')\n            if 'baseurl' not in repo_opts and 'mirrorlist' not in repo_opts:\n                raise SaltInvocationError('The repo does not exist and needs to be created, but either a baseurl or a mirrorlist needs to be given')\n            filerepos[repo] = {}\n    else:\n        repofile = repos[repo]['file']\n        (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n    if 'baseurl' in todelete:\n        if 'mirrorlist' not in repo_opts and 'mirrorlist' not in filerepos[repo]:\n            raise SaltInvocationError('Cannot delete baseurl without specifying mirrorlist')\n    if 'mirrorlist' in todelete:\n        if 'baseurl' not in repo_opts and 'baseurl' not in filerepos[repo]:\n            raise SaltInvocationError('Cannot delete mirrorlist without specifying baseurl')\n    for key in todelete:\n        if key in filerepos[repo].copy().keys():\n            del filerepos[repo][key]\n    _bool_to_str = lambda x: '1' if x else '0'\n    filerepos[repo].update(repo_opts)\n    content = header\n    for stanza in filerepos.keys():\n        comments = salt.utils.pkg.rpm.combine_comments(filerepos[stanza].pop('comments', []))\n        content += f'[{stanza}]\\n'\n        for line in filerepos[stanza].keys():\n            value = filerepos[stanza][line]\n            if isinstance(value, str) and '\\n' in value:\n                value = '\\n '.join(value.split('\\n'))\n            content += '{}={}\\n'.format(line, value if not isinstance(value, bool) else _bool_to_str(value))\n        content += comments + '\\n'\n    with salt.utils.files.fopen(repofile, 'w') as fileout:\n        fileout.write(salt.utils.stringutils.to_str(content))\n    return {repofile: filerepos}",
            "def mod_repo(repo, basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Modify one or more values for a repo. If the repo does not exist, it will\\n    be created, so long as the following values are specified:\\n\\n    repo\\n        name by which the yum refers to the repo\\n    name\\n        a human-readable name for the repo\\n    baseurl\\n        the URL for yum to reference\\n    mirrorlist\\n        the URL for yum to reference\\n\\n    Key/Value pairs may also be removed from a repo's configuration by setting\\n    a key to a blank value. Bear in mind that a name cannot be deleted, and a\\n    baseurl can only be deleted if a mirrorlist is specified (or vice versa).\\n\\n    Strict parsing of configuration files is the default, this can be disabled\\n    using the  ``strict_config`` keyword argument set to False\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.mod_repo reponame enabled=1 gpgcheck=1\\n        salt '*' pkg.mod_repo reponame basedir=/path/to/dir enabled=1 strict_config=False\\n        salt '*' pkg.mod_repo reponame baseurl= mirrorlist=http://host.com/\\n    \"\n    repo_opts = {x: kwargs[x] for x in kwargs if not x.startswith('__') and x not in ('saltenv',)}\n    if all((x in repo_opts for x in ('mirrorlist', 'baseurl'))):\n        raise SaltInvocationError(\"Only one of 'mirrorlist' and 'baseurl' can be specified\")\n    use_copr = False\n    if repo.startswith('copr:'):\n        copr_name = repo.split(':', 1)[1]\n        repo = _get_copr_repo(repo)\n        use_copr = True\n    todelete = []\n    for key in list(repo_opts):\n        if repo_opts[key] != 0 and (not repo_opts[key]):\n            del repo_opts[key]\n            todelete.append(key)\n    if 'mirrorlist' in repo_opts:\n        todelete.append('baseurl')\n    elif 'baseurl' in repo_opts:\n        todelete.append('mirrorlist')\n    if 'name' in todelete:\n        raise SaltInvocationError('The repo name cannot be deleted')\n    repos = {}\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = list_repos(basedirs, **kwargs)\n    repofile = ''\n    header = ''\n    filerepos = {}\n    if repo not in repos:\n        newdir = None\n        for d in basedirs:\n            if os.path.exists(d):\n                newdir = d\n                break\n        if not newdir:\n            raise SaltInvocationError('The repo does not exist and needs to be created, but none of the following basedir directories exist: {}'.format(basedirs))\n        repofile = f'{newdir}/{repo}.repo'\n        if use_copr:\n            copr_plugin_name = ''\n            if _yum() in ('dnf', 'dnf5'):\n                copr_plugin_name = 'dnf-plugins-core'\n            else:\n                copr_plugin_name = 'yum-plugin-copr'\n            if not __salt__['pkg_resource.version'](copr_plugin_name):\n                raise SaltInvocationError(f'{copr_plugin_name} must be installed to use COPR')\n            out = _call_yum(['copr', 'enable', copr_name, '-y'])\n            if out['retcode']:\n                raise CommandExecutionError(\"Unable to add COPR '{}'. '{}' exited with status {!s}: '{}' \".format(copr_name, _yum(), out['retcode'], out['stderr']))\n            repos = list_repos(basedirs, **kwargs)\n            repofile = repos[repo]['file']\n            (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n        else:\n            repofile = f'{newdir}/{repo}.repo'\n            if 'name' not in repo_opts:\n                raise SaltInvocationError('The repo does not exist and needs to be created, but a name was not given')\n            if 'baseurl' not in repo_opts and 'mirrorlist' not in repo_opts:\n                raise SaltInvocationError('The repo does not exist and needs to be created, but either a baseurl or a mirrorlist needs to be given')\n            filerepos[repo] = {}\n    else:\n        repofile = repos[repo]['file']\n        (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n    if 'baseurl' in todelete:\n        if 'mirrorlist' not in repo_opts and 'mirrorlist' not in filerepos[repo]:\n            raise SaltInvocationError('Cannot delete baseurl without specifying mirrorlist')\n    if 'mirrorlist' in todelete:\n        if 'baseurl' not in repo_opts and 'baseurl' not in filerepos[repo]:\n            raise SaltInvocationError('Cannot delete mirrorlist without specifying baseurl')\n    for key in todelete:\n        if key in filerepos[repo].copy().keys():\n            del filerepos[repo][key]\n    _bool_to_str = lambda x: '1' if x else '0'\n    filerepos[repo].update(repo_opts)\n    content = header\n    for stanza in filerepos.keys():\n        comments = salt.utils.pkg.rpm.combine_comments(filerepos[stanza].pop('comments', []))\n        content += f'[{stanza}]\\n'\n        for line in filerepos[stanza].keys():\n            value = filerepos[stanza][line]\n            if isinstance(value, str) and '\\n' in value:\n                value = '\\n '.join(value.split('\\n'))\n            content += '{}={}\\n'.format(line, value if not isinstance(value, bool) else _bool_to_str(value))\n        content += comments + '\\n'\n    with salt.utils.files.fopen(repofile, 'w') as fileout:\n        fileout.write(salt.utils.stringutils.to_str(content))\n    return {repofile: filerepos}",
            "def mod_repo(repo, basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Modify one or more values for a repo. If the repo does not exist, it will\\n    be created, so long as the following values are specified:\\n\\n    repo\\n        name by which the yum refers to the repo\\n    name\\n        a human-readable name for the repo\\n    baseurl\\n        the URL for yum to reference\\n    mirrorlist\\n        the URL for yum to reference\\n\\n    Key/Value pairs may also be removed from a repo's configuration by setting\\n    a key to a blank value. Bear in mind that a name cannot be deleted, and a\\n    baseurl can only be deleted if a mirrorlist is specified (or vice versa).\\n\\n    Strict parsing of configuration files is the default, this can be disabled\\n    using the  ``strict_config`` keyword argument set to False\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.mod_repo reponame enabled=1 gpgcheck=1\\n        salt '*' pkg.mod_repo reponame basedir=/path/to/dir enabled=1 strict_config=False\\n        salt '*' pkg.mod_repo reponame baseurl= mirrorlist=http://host.com/\\n    \"\n    repo_opts = {x: kwargs[x] for x in kwargs if not x.startswith('__') and x not in ('saltenv',)}\n    if all((x in repo_opts for x in ('mirrorlist', 'baseurl'))):\n        raise SaltInvocationError(\"Only one of 'mirrorlist' and 'baseurl' can be specified\")\n    use_copr = False\n    if repo.startswith('copr:'):\n        copr_name = repo.split(':', 1)[1]\n        repo = _get_copr_repo(repo)\n        use_copr = True\n    todelete = []\n    for key in list(repo_opts):\n        if repo_opts[key] != 0 and (not repo_opts[key]):\n            del repo_opts[key]\n            todelete.append(key)\n    if 'mirrorlist' in repo_opts:\n        todelete.append('baseurl')\n    elif 'baseurl' in repo_opts:\n        todelete.append('mirrorlist')\n    if 'name' in todelete:\n        raise SaltInvocationError('The repo name cannot be deleted')\n    repos = {}\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = list_repos(basedirs, **kwargs)\n    repofile = ''\n    header = ''\n    filerepos = {}\n    if repo not in repos:\n        newdir = None\n        for d in basedirs:\n            if os.path.exists(d):\n                newdir = d\n                break\n        if not newdir:\n            raise SaltInvocationError('The repo does not exist and needs to be created, but none of the following basedir directories exist: {}'.format(basedirs))\n        repofile = f'{newdir}/{repo}.repo'\n        if use_copr:\n            copr_plugin_name = ''\n            if _yum() in ('dnf', 'dnf5'):\n                copr_plugin_name = 'dnf-plugins-core'\n            else:\n                copr_plugin_name = 'yum-plugin-copr'\n            if not __salt__['pkg_resource.version'](copr_plugin_name):\n                raise SaltInvocationError(f'{copr_plugin_name} must be installed to use COPR')\n            out = _call_yum(['copr', 'enable', copr_name, '-y'])\n            if out['retcode']:\n                raise CommandExecutionError(\"Unable to add COPR '{}'. '{}' exited with status {!s}: '{}' \".format(copr_name, _yum(), out['retcode'], out['stderr']))\n            repos = list_repos(basedirs, **kwargs)\n            repofile = repos[repo]['file']\n            (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n        else:\n            repofile = f'{newdir}/{repo}.repo'\n            if 'name' not in repo_opts:\n                raise SaltInvocationError('The repo does not exist and needs to be created, but a name was not given')\n            if 'baseurl' not in repo_opts and 'mirrorlist' not in repo_opts:\n                raise SaltInvocationError('The repo does not exist and needs to be created, but either a baseurl or a mirrorlist needs to be given')\n            filerepos[repo] = {}\n    else:\n        repofile = repos[repo]['file']\n        (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n    if 'baseurl' in todelete:\n        if 'mirrorlist' not in repo_opts and 'mirrorlist' not in filerepos[repo]:\n            raise SaltInvocationError('Cannot delete baseurl without specifying mirrorlist')\n    if 'mirrorlist' in todelete:\n        if 'baseurl' not in repo_opts and 'baseurl' not in filerepos[repo]:\n            raise SaltInvocationError('Cannot delete mirrorlist without specifying baseurl')\n    for key in todelete:\n        if key in filerepos[repo].copy().keys():\n            del filerepos[repo][key]\n    _bool_to_str = lambda x: '1' if x else '0'\n    filerepos[repo].update(repo_opts)\n    content = header\n    for stanza in filerepos.keys():\n        comments = salt.utils.pkg.rpm.combine_comments(filerepos[stanza].pop('comments', []))\n        content += f'[{stanza}]\\n'\n        for line in filerepos[stanza].keys():\n            value = filerepos[stanza][line]\n            if isinstance(value, str) and '\\n' in value:\n                value = '\\n '.join(value.split('\\n'))\n            content += '{}={}\\n'.format(line, value if not isinstance(value, bool) else _bool_to_str(value))\n        content += comments + '\\n'\n    with salt.utils.files.fopen(repofile, 'w') as fileout:\n        fileout.write(salt.utils.stringutils.to_str(content))\n    return {repofile: filerepos}",
            "def mod_repo(repo, basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Modify one or more values for a repo. If the repo does not exist, it will\\n    be created, so long as the following values are specified:\\n\\n    repo\\n        name by which the yum refers to the repo\\n    name\\n        a human-readable name for the repo\\n    baseurl\\n        the URL for yum to reference\\n    mirrorlist\\n        the URL for yum to reference\\n\\n    Key/Value pairs may also be removed from a repo's configuration by setting\\n    a key to a blank value. Bear in mind that a name cannot be deleted, and a\\n    baseurl can only be deleted if a mirrorlist is specified (or vice versa).\\n\\n    Strict parsing of configuration files is the default, this can be disabled\\n    using the  ``strict_config`` keyword argument set to False\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.mod_repo reponame enabled=1 gpgcheck=1\\n        salt '*' pkg.mod_repo reponame basedir=/path/to/dir enabled=1 strict_config=False\\n        salt '*' pkg.mod_repo reponame baseurl= mirrorlist=http://host.com/\\n    \"\n    repo_opts = {x: kwargs[x] for x in kwargs if not x.startswith('__') and x not in ('saltenv',)}\n    if all((x in repo_opts for x in ('mirrorlist', 'baseurl'))):\n        raise SaltInvocationError(\"Only one of 'mirrorlist' and 'baseurl' can be specified\")\n    use_copr = False\n    if repo.startswith('copr:'):\n        copr_name = repo.split(':', 1)[1]\n        repo = _get_copr_repo(repo)\n        use_copr = True\n    todelete = []\n    for key in list(repo_opts):\n        if repo_opts[key] != 0 and (not repo_opts[key]):\n            del repo_opts[key]\n            todelete.append(key)\n    if 'mirrorlist' in repo_opts:\n        todelete.append('baseurl')\n    elif 'baseurl' in repo_opts:\n        todelete.append('mirrorlist')\n    if 'name' in todelete:\n        raise SaltInvocationError('The repo name cannot be deleted')\n    repos = {}\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = list_repos(basedirs, **kwargs)\n    repofile = ''\n    header = ''\n    filerepos = {}\n    if repo not in repos:\n        newdir = None\n        for d in basedirs:\n            if os.path.exists(d):\n                newdir = d\n                break\n        if not newdir:\n            raise SaltInvocationError('The repo does not exist and needs to be created, but none of the following basedir directories exist: {}'.format(basedirs))\n        repofile = f'{newdir}/{repo}.repo'\n        if use_copr:\n            copr_plugin_name = ''\n            if _yum() in ('dnf', 'dnf5'):\n                copr_plugin_name = 'dnf-plugins-core'\n            else:\n                copr_plugin_name = 'yum-plugin-copr'\n            if not __salt__['pkg_resource.version'](copr_plugin_name):\n                raise SaltInvocationError(f'{copr_plugin_name} must be installed to use COPR')\n            out = _call_yum(['copr', 'enable', copr_name, '-y'])\n            if out['retcode']:\n                raise CommandExecutionError(\"Unable to add COPR '{}'. '{}' exited with status {!s}: '{}' \".format(copr_name, _yum(), out['retcode'], out['stderr']))\n            repos = list_repos(basedirs, **kwargs)\n            repofile = repos[repo]['file']\n            (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n        else:\n            repofile = f'{newdir}/{repo}.repo'\n            if 'name' not in repo_opts:\n                raise SaltInvocationError('The repo does not exist and needs to be created, but a name was not given')\n            if 'baseurl' not in repo_opts and 'mirrorlist' not in repo_opts:\n                raise SaltInvocationError('The repo does not exist and needs to be created, but either a baseurl or a mirrorlist needs to be given')\n            filerepos[repo] = {}\n    else:\n        repofile = repos[repo]['file']\n        (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n    if 'baseurl' in todelete:\n        if 'mirrorlist' not in repo_opts and 'mirrorlist' not in filerepos[repo]:\n            raise SaltInvocationError('Cannot delete baseurl without specifying mirrorlist')\n    if 'mirrorlist' in todelete:\n        if 'baseurl' not in repo_opts and 'baseurl' not in filerepos[repo]:\n            raise SaltInvocationError('Cannot delete mirrorlist without specifying baseurl')\n    for key in todelete:\n        if key in filerepos[repo].copy().keys():\n            del filerepos[repo][key]\n    _bool_to_str = lambda x: '1' if x else '0'\n    filerepos[repo].update(repo_opts)\n    content = header\n    for stanza in filerepos.keys():\n        comments = salt.utils.pkg.rpm.combine_comments(filerepos[stanza].pop('comments', []))\n        content += f'[{stanza}]\\n'\n        for line in filerepos[stanza].keys():\n            value = filerepos[stanza][line]\n            if isinstance(value, str) and '\\n' in value:\n                value = '\\n '.join(value.split('\\n'))\n            content += '{}={}\\n'.format(line, value if not isinstance(value, bool) else _bool_to_str(value))\n        content += comments + '\\n'\n    with salt.utils.files.fopen(repofile, 'w') as fileout:\n        fileout.write(salt.utils.stringutils.to_str(content))\n    return {repofile: filerepos}",
            "def mod_repo(repo, basedir=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Modify one or more values for a repo. If the repo does not exist, it will\\n    be created, so long as the following values are specified:\\n\\n    repo\\n        name by which the yum refers to the repo\\n    name\\n        a human-readable name for the repo\\n    baseurl\\n        the URL for yum to reference\\n    mirrorlist\\n        the URL for yum to reference\\n\\n    Key/Value pairs may also be removed from a repo's configuration by setting\\n    a key to a blank value. Bear in mind that a name cannot be deleted, and a\\n    baseurl can only be deleted if a mirrorlist is specified (or vice versa).\\n\\n    Strict parsing of configuration files is the default, this can be disabled\\n    using the  ``strict_config`` keyword argument set to False\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.mod_repo reponame enabled=1 gpgcheck=1\\n        salt '*' pkg.mod_repo reponame basedir=/path/to/dir enabled=1 strict_config=False\\n        salt '*' pkg.mod_repo reponame baseurl= mirrorlist=http://host.com/\\n    \"\n    repo_opts = {x: kwargs[x] for x in kwargs if not x.startswith('__') and x not in ('saltenv',)}\n    if all((x in repo_opts for x in ('mirrorlist', 'baseurl'))):\n        raise SaltInvocationError(\"Only one of 'mirrorlist' and 'baseurl' can be specified\")\n    use_copr = False\n    if repo.startswith('copr:'):\n        copr_name = repo.split(':', 1)[1]\n        repo = _get_copr_repo(repo)\n        use_copr = True\n    todelete = []\n    for key in list(repo_opts):\n        if repo_opts[key] != 0 and (not repo_opts[key]):\n            del repo_opts[key]\n            todelete.append(key)\n    if 'mirrorlist' in repo_opts:\n        todelete.append('baseurl')\n    elif 'baseurl' in repo_opts:\n        todelete.append('mirrorlist')\n    if 'name' in todelete:\n        raise SaltInvocationError('The repo name cannot be deleted')\n    repos = {}\n    strict_parser = kwargs.get('strict_config', True)\n    basedirs = _normalize_basedir(basedir, strict_parser)\n    repos = list_repos(basedirs, **kwargs)\n    repofile = ''\n    header = ''\n    filerepos = {}\n    if repo not in repos:\n        newdir = None\n        for d in basedirs:\n            if os.path.exists(d):\n                newdir = d\n                break\n        if not newdir:\n            raise SaltInvocationError('The repo does not exist and needs to be created, but none of the following basedir directories exist: {}'.format(basedirs))\n        repofile = f'{newdir}/{repo}.repo'\n        if use_copr:\n            copr_plugin_name = ''\n            if _yum() in ('dnf', 'dnf5'):\n                copr_plugin_name = 'dnf-plugins-core'\n            else:\n                copr_plugin_name = 'yum-plugin-copr'\n            if not __salt__['pkg_resource.version'](copr_plugin_name):\n                raise SaltInvocationError(f'{copr_plugin_name} must be installed to use COPR')\n            out = _call_yum(['copr', 'enable', copr_name, '-y'])\n            if out['retcode']:\n                raise CommandExecutionError(\"Unable to add COPR '{}'. '{}' exited with status {!s}: '{}' \".format(copr_name, _yum(), out['retcode'], out['stderr']))\n            repos = list_repos(basedirs, **kwargs)\n            repofile = repos[repo]['file']\n            (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n        else:\n            repofile = f'{newdir}/{repo}.repo'\n            if 'name' not in repo_opts:\n                raise SaltInvocationError('The repo does not exist and needs to be created, but a name was not given')\n            if 'baseurl' not in repo_opts and 'mirrorlist' not in repo_opts:\n                raise SaltInvocationError('The repo does not exist and needs to be created, but either a baseurl or a mirrorlist needs to be given')\n            filerepos[repo] = {}\n    else:\n        repofile = repos[repo]['file']\n        (header, filerepos) = _parse_repo_file(repofile, strict_parser)\n    if 'baseurl' in todelete:\n        if 'mirrorlist' not in repo_opts and 'mirrorlist' not in filerepos[repo]:\n            raise SaltInvocationError('Cannot delete baseurl without specifying mirrorlist')\n    if 'mirrorlist' in todelete:\n        if 'baseurl' not in repo_opts and 'baseurl' not in filerepos[repo]:\n            raise SaltInvocationError('Cannot delete mirrorlist without specifying baseurl')\n    for key in todelete:\n        if key in filerepos[repo].copy().keys():\n            del filerepos[repo][key]\n    _bool_to_str = lambda x: '1' if x else '0'\n    filerepos[repo].update(repo_opts)\n    content = header\n    for stanza in filerepos.keys():\n        comments = salt.utils.pkg.rpm.combine_comments(filerepos[stanza].pop('comments', []))\n        content += f'[{stanza}]\\n'\n        for line in filerepos[stanza].keys():\n            value = filerepos[stanza][line]\n            if isinstance(value, str) and '\\n' in value:\n                value = '\\n '.join(value.split('\\n'))\n            content += '{}={}\\n'.format(line, value if not isinstance(value, bool) else _bool_to_str(value))\n        content += comments + '\\n'\n    with salt.utils.files.fopen(repofile, 'w') as fileout:\n        fileout.write(salt.utils.stringutils.to_str(content))\n    return {repofile: filerepos}"
        ]
    },
    {
        "func_name": "_parse_repo_file",
        "original": "def _parse_repo_file(filename, strict_config=True):\n    \"\"\"\n    Turn a single repo file into a dict\n    \"\"\"\n    parsed = configparser.ConfigParser(strict=strict_config)\n    config = {}\n    try:\n        parsed.read(filename)\n    except configparser.MissingSectionHeaderError as err:\n        log.error('Failed to parse file %s, error: %s', filename, err.message)\n        return ('', {})\n    for section in parsed._sections:\n        section_dict = dict(parsed._sections[section])\n        section_dict.pop('__name__', None)\n        config[section] = section_dict\n    headers = ''\n    section = None\n    with salt.utils.files.fopen(filename, 'r') as repofile:\n        for line in repofile:\n            line = salt.utils.stringutils.to_unicode(line)\n            line = line.strip()\n            if line.startswith('#'):\n                if section is None:\n                    headers += line + '\\n'\n                else:\n                    try:\n                        comments = config[section].setdefault('comments', [])\n                        comments.append(line[1:].lstrip())\n                    except KeyError:\n                        log.debug('Found comment in %s which does not appear to belong to any repo section: %s', filename, line)\n            elif line.startswith('[') and line.endswith(']'):\n                section = line[1:-1]\n    return (headers, salt.utils.data.decode(config))",
        "mutated": [
            "def _parse_repo_file(filename, strict_config=True):\n    if False:\n        i = 10\n    '\\n    Turn a single repo file into a dict\\n    '\n    parsed = configparser.ConfigParser(strict=strict_config)\n    config = {}\n    try:\n        parsed.read(filename)\n    except configparser.MissingSectionHeaderError as err:\n        log.error('Failed to parse file %s, error: %s', filename, err.message)\n        return ('', {})\n    for section in parsed._sections:\n        section_dict = dict(parsed._sections[section])\n        section_dict.pop('__name__', None)\n        config[section] = section_dict\n    headers = ''\n    section = None\n    with salt.utils.files.fopen(filename, 'r') as repofile:\n        for line in repofile:\n            line = salt.utils.stringutils.to_unicode(line)\n            line = line.strip()\n            if line.startswith('#'):\n                if section is None:\n                    headers += line + '\\n'\n                else:\n                    try:\n                        comments = config[section].setdefault('comments', [])\n                        comments.append(line[1:].lstrip())\n                    except KeyError:\n                        log.debug('Found comment in %s which does not appear to belong to any repo section: %s', filename, line)\n            elif line.startswith('[') and line.endswith(']'):\n                section = line[1:-1]\n    return (headers, salt.utils.data.decode(config))",
            "def _parse_repo_file(filename, strict_config=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Turn a single repo file into a dict\\n    '\n    parsed = configparser.ConfigParser(strict=strict_config)\n    config = {}\n    try:\n        parsed.read(filename)\n    except configparser.MissingSectionHeaderError as err:\n        log.error('Failed to parse file %s, error: %s', filename, err.message)\n        return ('', {})\n    for section in parsed._sections:\n        section_dict = dict(parsed._sections[section])\n        section_dict.pop('__name__', None)\n        config[section] = section_dict\n    headers = ''\n    section = None\n    with salt.utils.files.fopen(filename, 'r') as repofile:\n        for line in repofile:\n            line = salt.utils.stringutils.to_unicode(line)\n            line = line.strip()\n            if line.startswith('#'):\n                if section is None:\n                    headers += line + '\\n'\n                else:\n                    try:\n                        comments = config[section].setdefault('comments', [])\n                        comments.append(line[1:].lstrip())\n                    except KeyError:\n                        log.debug('Found comment in %s which does not appear to belong to any repo section: %s', filename, line)\n            elif line.startswith('[') and line.endswith(']'):\n                section = line[1:-1]\n    return (headers, salt.utils.data.decode(config))",
            "def _parse_repo_file(filename, strict_config=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Turn a single repo file into a dict\\n    '\n    parsed = configparser.ConfigParser(strict=strict_config)\n    config = {}\n    try:\n        parsed.read(filename)\n    except configparser.MissingSectionHeaderError as err:\n        log.error('Failed to parse file %s, error: %s', filename, err.message)\n        return ('', {})\n    for section in parsed._sections:\n        section_dict = dict(parsed._sections[section])\n        section_dict.pop('__name__', None)\n        config[section] = section_dict\n    headers = ''\n    section = None\n    with salt.utils.files.fopen(filename, 'r') as repofile:\n        for line in repofile:\n            line = salt.utils.stringutils.to_unicode(line)\n            line = line.strip()\n            if line.startswith('#'):\n                if section is None:\n                    headers += line + '\\n'\n                else:\n                    try:\n                        comments = config[section].setdefault('comments', [])\n                        comments.append(line[1:].lstrip())\n                    except KeyError:\n                        log.debug('Found comment in %s which does not appear to belong to any repo section: %s', filename, line)\n            elif line.startswith('[') and line.endswith(']'):\n                section = line[1:-1]\n    return (headers, salt.utils.data.decode(config))",
            "def _parse_repo_file(filename, strict_config=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Turn a single repo file into a dict\\n    '\n    parsed = configparser.ConfigParser(strict=strict_config)\n    config = {}\n    try:\n        parsed.read(filename)\n    except configparser.MissingSectionHeaderError as err:\n        log.error('Failed to parse file %s, error: %s', filename, err.message)\n        return ('', {})\n    for section in parsed._sections:\n        section_dict = dict(parsed._sections[section])\n        section_dict.pop('__name__', None)\n        config[section] = section_dict\n    headers = ''\n    section = None\n    with salt.utils.files.fopen(filename, 'r') as repofile:\n        for line in repofile:\n            line = salt.utils.stringutils.to_unicode(line)\n            line = line.strip()\n            if line.startswith('#'):\n                if section is None:\n                    headers += line + '\\n'\n                else:\n                    try:\n                        comments = config[section].setdefault('comments', [])\n                        comments.append(line[1:].lstrip())\n                    except KeyError:\n                        log.debug('Found comment in %s which does not appear to belong to any repo section: %s', filename, line)\n            elif line.startswith('[') and line.endswith(']'):\n                section = line[1:-1]\n    return (headers, salt.utils.data.decode(config))",
            "def _parse_repo_file(filename, strict_config=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Turn a single repo file into a dict\\n    '\n    parsed = configparser.ConfigParser(strict=strict_config)\n    config = {}\n    try:\n        parsed.read(filename)\n    except configparser.MissingSectionHeaderError as err:\n        log.error('Failed to parse file %s, error: %s', filename, err.message)\n        return ('', {})\n    for section in parsed._sections:\n        section_dict = dict(parsed._sections[section])\n        section_dict.pop('__name__', None)\n        config[section] = section_dict\n    headers = ''\n    section = None\n    with salt.utils.files.fopen(filename, 'r') as repofile:\n        for line in repofile:\n            line = salt.utils.stringutils.to_unicode(line)\n            line = line.strip()\n            if line.startswith('#'):\n                if section is None:\n                    headers += line + '\\n'\n                else:\n                    try:\n                        comments = config[section].setdefault('comments', [])\n                        comments.append(line[1:].lstrip())\n                    except KeyError:\n                        log.debug('Found comment in %s which does not appear to belong to any repo section: %s', filename, line)\n            elif line.startswith('[') and line.endswith(']'):\n                section = line[1:-1]\n    return (headers, salt.utils.data.decode(config))"
        ]
    },
    {
        "func_name": "file_list",
        "original": "def file_list(*packages, **kwargs):\n    \"\"\"\n    .. versionadded:: 2014.1.0\n\n    List the files that belong to a package. Not specifying any packages will\n    return a list of *every* file on the system's rpm database (not generally\n    recommended).\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' pkg.file_list httpd\n        salt '*' pkg.file_list httpd postfix\n        salt '*' pkg.file_list\n    \"\"\"\n    return __salt__['lowpkg.file_list'](*packages)",
        "mutated": [
            "def file_list(*packages, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    List the files that belong to a package. Not specifying any packages will\\n    return a list of *every* file on the system's rpm database (not generally\\n    recommended).\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.file_list httpd\\n        salt '*' pkg.file_list httpd postfix\\n        salt '*' pkg.file_list\\n    \"\n    return __salt__['lowpkg.file_list'](*packages)",
            "def file_list(*packages, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    List the files that belong to a package. Not specifying any packages will\\n    return a list of *every* file on the system's rpm database (not generally\\n    recommended).\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.file_list httpd\\n        salt '*' pkg.file_list httpd postfix\\n        salt '*' pkg.file_list\\n    \"\n    return __salt__['lowpkg.file_list'](*packages)",
            "def file_list(*packages, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    List the files that belong to a package. Not specifying any packages will\\n    return a list of *every* file on the system's rpm database (not generally\\n    recommended).\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.file_list httpd\\n        salt '*' pkg.file_list httpd postfix\\n        salt '*' pkg.file_list\\n    \"\n    return __salt__['lowpkg.file_list'](*packages)",
            "def file_list(*packages, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    List the files that belong to a package. Not specifying any packages will\\n    return a list of *every* file on the system's rpm database (not generally\\n    recommended).\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.file_list httpd\\n        salt '*' pkg.file_list httpd postfix\\n        salt '*' pkg.file_list\\n    \"\n    return __salt__['lowpkg.file_list'](*packages)",
            "def file_list(*packages, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    List the files that belong to a package. Not specifying any packages will\\n    return a list of *every* file on the system's rpm database (not generally\\n    recommended).\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.file_list httpd\\n        salt '*' pkg.file_list httpd postfix\\n        salt '*' pkg.file_list\\n    \"\n    return __salt__['lowpkg.file_list'](*packages)"
        ]
    },
    {
        "func_name": "file_dict",
        "original": "def file_dict(*packages, **kwargs):\n    \"\"\"\n    .. versionadded:: 2014.1.0\n\n    List the files that belong to a package, grouped by package. Not\n    specifying any packages will return a list of *every* file on the system's\n    rpm database (not generally recommended).\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' pkg.file_list httpd\n        salt '*' pkg.file_list httpd postfix\n        salt '*' pkg.file_list\n    \"\"\"\n    return __salt__['lowpkg.file_dict'](*packages)",
        "mutated": [
            "def file_dict(*packages, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    List the files that belong to a package, grouped by package. Not\\n    specifying any packages will return a list of *every* file on the system's\\n    rpm database (not generally recommended).\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.file_list httpd\\n        salt '*' pkg.file_list httpd postfix\\n        salt '*' pkg.file_list\\n    \"\n    return __salt__['lowpkg.file_dict'](*packages)",
            "def file_dict(*packages, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    List the files that belong to a package, grouped by package. Not\\n    specifying any packages will return a list of *every* file on the system's\\n    rpm database (not generally recommended).\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.file_list httpd\\n        salt '*' pkg.file_list httpd postfix\\n        salt '*' pkg.file_list\\n    \"\n    return __salt__['lowpkg.file_dict'](*packages)",
            "def file_dict(*packages, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    List the files that belong to a package, grouped by package. Not\\n    specifying any packages will return a list of *every* file on the system's\\n    rpm database (not generally recommended).\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.file_list httpd\\n        salt '*' pkg.file_list httpd postfix\\n        salt '*' pkg.file_list\\n    \"\n    return __salt__['lowpkg.file_dict'](*packages)",
            "def file_dict(*packages, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    List the files that belong to a package, grouped by package. Not\\n    specifying any packages will return a list of *every* file on the system's\\n    rpm database (not generally recommended).\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.file_list httpd\\n        salt '*' pkg.file_list httpd postfix\\n        salt '*' pkg.file_list\\n    \"\n    return __salt__['lowpkg.file_dict'](*packages)",
            "def file_dict(*packages, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2014.1.0\\n\\n    List the files that belong to a package, grouped by package. Not\\n    specifying any packages will return a list of *every* file on the system's\\n    rpm database (not generally recommended).\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.file_list httpd\\n        salt '*' pkg.file_list httpd postfix\\n        salt '*' pkg.file_list\\n    \"\n    return __salt__['lowpkg.file_dict'](*packages)"
        ]
    },
    {
        "func_name": "owner",
        "original": "def owner(*paths, **kwargs):\n    \"\"\"\n    .. versionadded:: 2014.7.0\n\n    Return the name of the package that owns the file. Multiple file paths can\n    be passed. Like :mod:`pkg.version <salt.modules.yumpkg.version>`, if a\n    single path is passed, a string will be returned, and if multiple paths are\n    passed, a dictionary of file/package name pairs will be returned.\n\n    If the file is not owned by a package, or is not present on the minion,\n    then an empty string will be returned for that path.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' pkg.owner /usr/bin/apachectl\n        salt '*' pkg.owner /usr/bin/apachectl /etc/httpd/conf/httpd.conf\n    \"\"\"\n    if not paths:\n        return ''\n    ret = {}\n    cmd_prefix = ['rpm', '-qf', '--queryformat', '%{name}']\n    for path in paths:\n        ret[path] = __salt__['cmd.run_stdout'](cmd_prefix + [path], output_loglevel='trace', python_shell=False)\n        if 'not owned' in ret[path].lower():\n            ret[path] = ''\n    if len(ret) == 1:\n        return next(iter(ret.values()))\n    return ret",
        "mutated": [
            "def owner(*paths, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2014.7.0\\n\\n    Return the name of the package that owns the file. Multiple file paths can\\n    be passed. Like :mod:`pkg.version <salt.modules.yumpkg.version>`, if a\\n    single path is passed, a string will be returned, and if multiple paths are\\n    passed, a dictionary of file/package name pairs will be returned.\\n\\n    If the file is not owned by a package, or is not present on the minion,\\n    then an empty string will be returned for that path.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.owner /usr/bin/apachectl\\n        salt '*' pkg.owner /usr/bin/apachectl /etc/httpd/conf/httpd.conf\\n    \"\n    if not paths:\n        return ''\n    ret = {}\n    cmd_prefix = ['rpm', '-qf', '--queryformat', '%{name}']\n    for path in paths:\n        ret[path] = __salt__['cmd.run_stdout'](cmd_prefix + [path], output_loglevel='trace', python_shell=False)\n        if 'not owned' in ret[path].lower():\n            ret[path] = ''\n    if len(ret) == 1:\n        return next(iter(ret.values()))\n    return ret",
            "def owner(*paths, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2014.7.0\\n\\n    Return the name of the package that owns the file. Multiple file paths can\\n    be passed. Like :mod:`pkg.version <salt.modules.yumpkg.version>`, if a\\n    single path is passed, a string will be returned, and if multiple paths are\\n    passed, a dictionary of file/package name pairs will be returned.\\n\\n    If the file is not owned by a package, or is not present on the minion,\\n    then an empty string will be returned for that path.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.owner /usr/bin/apachectl\\n        salt '*' pkg.owner /usr/bin/apachectl /etc/httpd/conf/httpd.conf\\n    \"\n    if not paths:\n        return ''\n    ret = {}\n    cmd_prefix = ['rpm', '-qf', '--queryformat', '%{name}']\n    for path in paths:\n        ret[path] = __salt__['cmd.run_stdout'](cmd_prefix + [path], output_loglevel='trace', python_shell=False)\n        if 'not owned' in ret[path].lower():\n            ret[path] = ''\n    if len(ret) == 1:\n        return next(iter(ret.values()))\n    return ret",
            "def owner(*paths, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2014.7.0\\n\\n    Return the name of the package that owns the file. Multiple file paths can\\n    be passed. Like :mod:`pkg.version <salt.modules.yumpkg.version>`, if a\\n    single path is passed, a string will be returned, and if multiple paths are\\n    passed, a dictionary of file/package name pairs will be returned.\\n\\n    If the file is not owned by a package, or is not present on the minion,\\n    then an empty string will be returned for that path.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.owner /usr/bin/apachectl\\n        salt '*' pkg.owner /usr/bin/apachectl /etc/httpd/conf/httpd.conf\\n    \"\n    if not paths:\n        return ''\n    ret = {}\n    cmd_prefix = ['rpm', '-qf', '--queryformat', '%{name}']\n    for path in paths:\n        ret[path] = __salt__['cmd.run_stdout'](cmd_prefix + [path], output_loglevel='trace', python_shell=False)\n        if 'not owned' in ret[path].lower():\n            ret[path] = ''\n    if len(ret) == 1:\n        return next(iter(ret.values()))\n    return ret",
            "def owner(*paths, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2014.7.0\\n\\n    Return the name of the package that owns the file. Multiple file paths can\\n    be passed. Like :mod:`pkg.version <salt.modules.yumpkg.version>`, if a\\n    single path is passed, a string will be returned, and if multiple paths are\\n    passed, a dictionary of file/package name pairs will be returned.\\n\\n    If the file is not owned by a package, or is not present on the minion,\\n    then an empty string will be returned for that path.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.owner /usr/bin/apachectl\\n        salt '*' pkg.owner /usr/bin/apachectl /etc/httpd/conf/httpd.conf\\n    \"\n    if not paths:\n        return ''\n    ret = {}\n    cmd_prefix = ['rpm', '-qf', '--queryformat', '%{name}']\n    for path in paths:\n        ret[path] = __salt__['cmd.run_stdout'](cmd_prefix + [path], output_loglevel='trace', python_shell=False)\n        if 'not owned' in ret[path].lower():\n            ret[path] = ''\n    if len(ret) == 1:\n        return next(iter(ret.values()))\n    return ret",
            "def owner(*paths, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2014.7.0\\n\\n    Return the name of the package that owns the file. Multiple file paths can\\n    be passed. Like :mod:`pkg.version <salt.modules.yumpkg.version>`, if a\\n    single path is passed, a string will be returned, and if multiple paths are\\n    passed, a dictionary of file/package name pairs will be returned.\\n\\n    If the file is not owned by a package, or is not present on the minion,\\n    then an empty string will be returned for that path.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.owner /usr/bin/apachectl\\n        salt '*' pkg.owner /usr/bin/apachectl /etc/httpd/conf/httpd.conf\\n    \"\n    if not paths:\n        return ''\n    ret = {}\n    cmd_prefix = ['rpm', '-qf', '--queryformat', '%{name}']\n    for path in paths:\n        ret[path] = __salt__['cmd.run_stdout'](cmd_prefix + [path], output_loglevel='trace', python_shell=False)\n        if 'not owned' in ret[path].lower():\n            ret[path] = ''\n    if len(ret) == 1:\n        return next(iter(ret.values()))\n    return ret"
        ]
    },
    {
        "func_name": "modified",
        "original": "def modified(*packages, **flags):\n    \"\"\"\n    List the modified files that belong to a package. Not specifying any packages\n    will return a list of _all_ modified files on the system's RPM database.\n\n    .. versionadded:: 2015.5.0\n\n    Filtering by flags (True or False):\n\n    size\n        Include only files where size changed.\n\n    mode\n        Include only files which file's mode has been changed.\n\n    checksum\n        Include only files which MD5 checksum has been changed.\n\n    device\n        Include only files which major and minor numbers has been changed.\n\n    symlink\n        Include only files which are symbolic link contents.\n\n    owner\n        Include only files where owner has been changed.\n\n    group\n        Include only files where group has been changed.\n\n    time\n        Include only files where modification time of the file has been\n        changed.\n\n    capabilities\n        Include only files where capabilities differ or not. Note: supported\n        only on newer RPM versions.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' pkg.modified\n        salt '*' pkg.modified httpd\n        salt '*' pkg.modified httpd postfix\n        salt '*' pkg.modified httpd owner=True group=False\n    \"\"\"\n    return __salt__['lowpkg.modified'](*packages, **flags)",
        "mutated": [
            "def modified(*packages, **flags):\n    if False:\n        i = 10\n    \"\\n    List the modified files that belong to a package. Not specifying any packages\\n    will return a list of _all_ modified files on the system's RPM database.\\n\\n    .. versionadded:: 2015.5.0\\n\\n    Filtering by flags (True or False):\\n\\n    size\\n        Include only files where size changed.\\n\\n    mode\\n        Include only files which file's mode has been changed.\\n\\n    checksum\\n        Include only files which MD5 checksum has been changed.\\n\\n    device\\n        Include only files which major and minor numbers has been changed.\\n\\n    symlink\\n        Include only files which are symbolic link contents.\\n\\n    owner\\n        Include only files where owner has been changed.\\n\\n    group\\n        Include only files where group has been changed.\\n\\n    time\\n        Include only files where modification time of the file has been\\n        changed.\\n\\n    capabilities\\n        Include only files where capabilities differ or not. Note: supported\\n        only on newer RPM versions.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.modified\\n        salt '*' pkg.modified httpd\\n        salt '*' pkg.modified httpd postfix\\n        salt '*' pkg.modified httpd owner=True group=False\\n    \"\n    return __salt__['lowpkg.modified'](*packages, **flags)",
            "def modified(*packages, **flags):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    List the modified files that belong to a package. Not specifying any packages\\n    will return a list of _all_ modified files on the system's RPM database.\\n\\n    .. versionadded:: 2015.5.0\\n\\n    Filtering by flags (True or False):\\n\\n    size\\n        Include only files where size changed.\\n\\n    mode\\n        Include only files which file's mode has been changed.\\n\\n    checksum\\n        Include only files which MD5 checksum has been changed.\\n\\n    device\\n        Include only files which major and minor numbers has been changed.\\n\\n    symlink\\n        Include only files which are symbolic link contents.\\n\\n    owner\\n        Include only files where owner has been changed.\\n\\n    group\\n        Include only files where group has been changed.\\n\\n    time\\n        Include only files where modification time of the file has been\\n        changed.\\n\\n    capabilities\\n        Include only files where capabilities differ or not. Note: supported\\n        only on newer RPM versions.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.modified\\n        salt '*' pkg.modified httpd\\n        salt '*' pkg.modified httpd postfix\\n        salt '*' pkg.modified httpd owner=True group=False\\n    \"\n    return __salt__['lowpkg.modified'](*packages, **flags)",
            "def modified(*packages, **flags):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    List the modified files that belong to a package. Not specifying any packages\\n    will return a list of _all_ modified files on the system's RPM database.\\n\\n    .. versionadded:: 2015.5.0\\n\\n    Filtering by flags (True or False):\\n\\n    size\\n        Include only files where size changed.\\n\\n    mode\\n        Include only files which file's mode has been changed.\\n\\n    checksum\\n        Include only files which MD5 checksum has been changed.\\n\\n    device\\n        Include only files which major and minor numbers has been changed.\\n\\n    symlink\\n        Include only files which are symbolic link contents.\\n\\n    owner\\n        Include only files where owner has been changed.\\n\\n    group\\n        Include only files where group has been changed.\\n\\n    time\\n        Include only files where modification time of the file has been\\n        changed.\\n\\n    capabilities\\n        Include only files where capabilities differ or not. Note: supported\\n        only on newer RPM versions.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.modified\\n        salt '*' pkg.modified httpd\\n        salt '*' pkg.modified httpd postfix\\n        salt '*' pkg.modified httpd owner=True group=False\\n    \"\n    return __salt__['lowpkg.modified'](*packages, **flags)",
            "def modified(*packages, **flags):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    List the modified files that belong to a package. Not specifying any packages\\n    will return a list of _all_ modified files on the system's RPM database.\\n\\n    .. versionadded:: 2015.5.0\\n\\n    Filtering by flags (True or False):\\n\\n    size\\n        Include only files where size changed.\\n\\n    mode\\n        Include only files which file's mode has been changed.\\n\\n    checksum\\n        Include only files which MD5 checksum has been changed.\\n\\n    device\\n        Include only files which major and minor numbers has been changed.\\n\\n    symlink\\n        Include only files which are symbolic link contents.\\n\\n    owner\\n        Include only files where owner has been changed.\\n\\n    group\\n        Include only files where group has been changed.\\n\\n    time\\n        Include only files where modification time of the file has been\\n        changed.\\n\\n    capabilities\\n        Include only files where capabilities differ or not. Note: supported\\n        only on newer RPM versions.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.modified\\n        salt '*' pkg.modified httpd\\n        salt '*' pkg.modified httpd postfix\\n        salt '*' pkg.modified httpd owner=True group=False\\n    \"\n    return __salt__['lowpkg.modified'](*packages, **flags)",
            "def modified(*packages, **flags):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    List the modified files that belong to a package. Not specifying any packages\\n    will return a list of _all_ modified files on the system's RPM database.\\n\\n    .. versionadded:: 2015.5.0\\n\\n    Filtering by flags (True or False):\\n\\n    size\\n        Include only files where size changed.\\n\\n    mode\\n        Include only files which file's mode has been changed.\\n\\n    checksum\\n        Include only files which MD5 checksum has been changed.\\n\\n    device\\n        Include only files which major and minor numbers has been changed.\\n\\n    symlink\\n        Include only files which are symbolic link contents.\\n\\n    owner\\n        Include only files where owner has been changed.\\n\\n    group\\n        Include only files where group has been changed.\\n\\n    time\\n        Include only files where modification time of the file has been\\n        changed.\\n\\n    capabilities\\n        Include only files where capabilities differ or not. Note: supported\\n        only on newer RPM versions.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.modified\\n        salt '*' pkg.modified httpd\\n        salt '*' pkg.modified httpd postfix\\n        salt '*' pkg.modified httpd owner=True group=False\\n    \"\n    return __salt__['lowpkg.modified'](*packages, **flags)"
        ]
    },
    {
        "func_name": "download",
        "original": "@salt.utils.decorators.path.which('yumdownloader')\ndef download(*packages, **kwargs):\n    \"\"\"\n    .. versionadded:: 2015.5.0\n\n    Download packages to the local disk. Requires ``yumdownloader`` from\n    ``yum-utils`` package.\n\n    .. note::\n\n        ``yum-utils`` will already be installed on the minion if the package\n        was installed from the Fedora / EPEL repositories.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.download httpd\n        salt '*' pkg.download httpd postfix\n    \"\"\"\n    if not packages:\n        raise SaltInvocationError('No packages were specified')\n    CACHE_DIR = '/var/cache/yum/packages'\n    if not os.path.exists(CACHE_DIR):\n        os.makedirs(CACHE_DIR)\n    cached_pkgs = os.listdir(CACHE_DIR)\n    to_purge = []\n    for pkg in packages:\n        to_purge.extend([os.path.join(CACHE_DIR, x) for x in cached_pkgs if x.startswith(f'{pkg}-')])\n    for purge_target in set(to_purge):\n        log.debug('Removing cached package %s', purge_target)\n        try:\n            os.unlink(purge_target)\n        except OSError as exc:\n            log.error('Unable to remove %s: %s', purge_target, exc)\n    cmd = ['yumdownloader', '-q', f'--destdir={CACHE_DIR}']\n    cmd.extend(packages)\n    __salt__['cmd.run'](cmd, output_loglevel='trace', python_shell=False)\n    ret = {}\n    for dld_result in os.listdir(CACHE_DIR):\n        if not dld_result.endswith('.rpm'):\n            continue\n        pkg_name = None\n        pkg_file = None\n        for query_pkg in packages:\n            if dld_result.startswith(f'{query_pkg}-'):\n                pkg_name = query_pkg\n                pkg_file = dld_result\n                break\n        if pkg_file is not None:\n            ret[pkg_name] = os.path.join(CACHE_DIR, pkg_file)\n    if not ret:\n        raise CommandExecutionError('Unable to download any of the following packages: {}'.format(', '.join(packages)))\n    failed = [x for x in packages if x not in ret]\n    if failed:\n        ret['_error'] = 'The following package(s) failed to download: {}'.format(', '.join(failed))\n    return ret",
        "mutated": [
            "@salt.utils.decorators.path.which('yumdownloader')\ndef download(*packages, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2015.5.0\\n\\n    Download packages to the local disk. Requires ``yumdownloader`` from\\n    ``yum-utils`` package.\\n\\n    .. note::\\n\\n        ``yum-utils`` will already be installed on the minion if the package\\n        was installed from the Fedora / EPEL repositories.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.download httpd\\n        salt '*' pkg.download httpd postfix\\n    \"\n    if not packages:\n        raise SaltInvocationError('No packages were specified')\n    CACHE_DIR = '/var/cache/yum/packages'\n    if not os.path.exists(CACHE_DIR):\n        os.makedirs(CACHE_DIR)\n    cached_pkgs = os.listdir(CACHE_DIR)\n    to_purge = []\n    for pkg in packages:\n        to_purge.extend([os.path.join(CACHE_DIR, x) for x in cached_pkgs if x.startswith(f'{pkg}-')])\n    for purge_target in set(to_purge):\n        log.debug('Removing cached package %s', purge_target)\n        try:\n            os.unlink(purge_target)\n        except OSError as exc:\n            log.error('Unable to remove %s: %s', purge_target, exc)\n    cmd = ['yumdownloader', '-q', f'--destdir={CACHE_DIR}']\n    cmd.extend(packages)\n    __salt__['cmd.run'](cmd, output_loglevel='trace', python_shell=False)\n    ret = {}\n    for dld_result in os.listdir(CACHE_DIR):\n        if not dld_result.endswith('.rpm'):\n            continue\n        pkg_name = None\n        pkg_file = None\n        for query_pkg in packages:\n            if dld_result.startswith(f'{query_pkg}-'):\n                pkg_name = query_pkg\n                pkg_file = dld_result\n                break\n        if pkg_file is not None:\n            ret[pkg_name] = os.path.join(CACHE_DIR, pkg_file)\n    if not ret:\n        raise CommandExecutionError('Unable to download any of the following packages: {}'.format(', '.join(packages)))\n    failed = [x for x in packages if x not in ret]\n    if failed:\n        ret['_error'] = 'The following package(s) failed to download: {}'.format(', '.join(failed))\n    return ret",
            "@salt.utils.decorators.path.which('yumdownloader')\ndef download(*packages, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2015.5.0\\n\\n    Download packages to the local disk. Requires ``yumdownloader`` from\\n    ``yum-utils`` package.\\n\\n    .. note::\\n\\n        ``yum-utils`` will already be installed on the minion if the package\\n        was installed from the Fedora / EPEL repositories.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.download httpd\\n        salt '*' pkg.download httpd postfix\\n    \"\n    if not packages:\n        raise SaltInvocationError('No packages were specified')\n    CACHE_DIR = '/var/cache/yum/packages'\n    if not os.path.exists(CACHE_DIR):\n        os.makedirs(CACHE_DIR)\n    cached_pkgs = os.listdir(CACHE_DIR)\n    to_purge = []\n    for pkg in packages:\n        to_purge.extend([os.path.join(CACHE_DIR, x) for x in cached_pkgs if x.startswith(f'{pkg}-')])\n    for purge_target in set(to_purge):\n        log.debug('Removing cached package %s', purge_target)\n        try:\n            os.unlink(purge_target)\n        except OSError as exc:\n            log.error('Unable to remove %s: %s', purge_target, exc)\n    cmd = ['yumdownloader', '-q', f'--destdir={CACHE_DIR}']\n    cmd.extend(packages)\n    __salt__['cmd.run'](cmd, output_loglevel='trace', python_shell=False)\n    ret = {}\n    for dld_result in os.listdir(CACHE_DIR):\n        if not dld_result.endswith('.rpm'):\n            continue\n        pkg_name = None\n        pkg_file = None\n        for query_pkg in packages:\n            if dld_result.startswith(f'{query_pkg}-'):\n                pkg_name = query_pkg\n                pkg_file = dld_result\n                break\n        if pkg_file is not None:\n            ret[pkg_name] = os.path.join(CACHE_DIR, pkg_file)\n    if not ret:\n        raise CommandExecutionError('Unable to download any of the following packages: {}'.format(', '.join(packages)))\n    failed = [x for x in packages if x not in ret]\n    if failed:\n        ret['_error'] = 'The following package(s) failed to download: {}'.format(', '.join(failed))\n    return ret",
            "@salt.utils.decorators.path.which('yumdownloader')\ndef download(*packages, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2015.5.0\\n\\n    Download packages to the local disk. Requires ``yumdownloader`` from\\n    ``yum-utils`` package.\\n\\n    .. note::\\n\\n        ``yum-utils`` will already be installed on the minion if the package\\n        was installed from the Fedora / EPEL repositories.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.download httpd\\n        salt '*' pkg.download httpd postfix\\n    \"\n    if not packages:\n        raise SaltInvocationError('No packages were specified')\n    CACHE_DIR = '/var/cache/yum/packages'\n    if not os.path.exists(CACHE_DIR):\n        os.makedirs(CACHE_DIR)\n    cached_pkgs = os.listdir(CACHE_DIR)\n    to_purge = []\n    for pkg in packages:\n        to_purge.extend([os.path.join(CACHE_DIR, x) for x in cached_pkgs if x.startswith(f'{pkg}-')])\n    for purge_target in set(to_purge):\n        log.debug('Removing cached package %s', purge_target)\n        try:\n            os.unlink(purge_target)\n        except OSError as exc:\n            log.error('Unable to remove %s: %s', purge_target, exc)\n    cmd = ['yumdownloader', '-q', f'--destdir={CACHE_DIR}']\n    cmd.extend(packages)\n    __salt__['cmd.run'](cmd, output_loglevel='trace', python_shell=False)\n    ret = {}\n    for dld_result in os.listdir(CACHE_DIR):\n        if not dld_result.endswith('.rpm'):\n            continue\n        pkg_name = None\n        pkg_file = None\n        for query_pkg in packages:\n            if dld_result.startswith(f'{query_pkg}-'):\n                pkg_name = query_pkg\n                pkg_file = dld_result\n                break\n        if pkg_file is not None:\n            ret[pkg_name] = os.path.join(CACHE_DIR, pkg_file)\n    if not ret:\n        raise CommandExecutionError('Unable to download any of the following packages: {}'.format(', '.join(packages)))\n    failed = [x for x in packages if x not in ret]\n    if failed:\n        ret['_error'] = 'The following package(s) failed to download: {}'.format(', '.join(failed))\n    return ret",
            "@salt.utils.decorators.path.which('yumdownloader')\ndef download(*packages, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2015.5.0\\n\\n    Download packages to the local disk. Requires ``yumdownloader`` from\\n    ``yum-utils`` package.\\n\\n    .. note::\\n\\n        ``yum-utils`` will already be installed on the minion if the package\\n        was installed from the Fedora / EPEL repositories.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.download httpd\\n        salt '*' pkg.download httpd postfix\\n    \"\n    if not packages:\n        raise SaltInvocationError('No packages were specified')\n    CACHE_DIR = '/var/cache/yum/packages'\n    if not os.path.exists(CACHE_DIR):\n        os.makedirs(CACHE_DIR)\n    cached_pkgs = os.listdir(CACHE_DIR)\n    to_purge = []\n    for pkg in packages:\n        to_purge.extend([os.path.join(CACHE_DIR, x) for x in cached_pkgs if x.startswith(f'{pkg}-')])\n    for purge_target in set(to_purge):\n        log.debug('Removing cached package %s', purge_target)\n        try:\n            os.unlink(purge_target)\n        except OSError as exc:\n            log.error('Unable to remove %s: %s', purge_target, exc)\n    cmd = ['yumdownloader', '-q', f'--destdir={CACHE_DIR}']\n    cmd.extend(packages)\n    __salt__['cmd.run'](cmd, output_loglevel='trace', python_shell=False)\n    ret = {}\n    for dld_result in os.listdir(CACHE_DIR):\n        if not dld_result.endswith('.rpm'):\n            continue\n        pkg_name = None\n        pkg_file = None\n        for query_pkg in packages:\n            if dld_result.startswith(f'{query_pkg}-'):\n                pkg_name = query_pkg\n                pkg_file = dld_result\n                break\n        if pkg_file is not None:\n            ret[pkg_name] = os.path.join(CACHE_DIR, pkg_file)\n    if not ret:\n        raise CommandExecutionError('Unable to download any of the following packages: {}'.format(', '.join(packages)))\n    failed = [x for x in packages if x not in ret]\n    if failed:\n        ret['_error'] = 'The following package(s) failed to download: {}'.format(', '.join(failed))\n    return ret",
            "@salt.utils.decorators.path.which('yumdownloader')\ndef download(*packages, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2015.5.0\\n\\n    Download packages to the local disk. Requires ``yumdownloader`` from\\n    ``yum-utils`` package.\\n\\n    .. note::\\n\\n        ``yum-utils`` will already be installed on the minion if the package\\n        was installed from the Fedora / EPEL repositories.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.download httpd\\n        salt '*' pkg.download httpd postfix\\n    \"\n    if not packages:\n        raise SaltInvocationError('No packages were specified')\n    CACHE_DIR = '/var/cache/yum/packages'\n    if not os.path.exists(CACHE_DIR):\n        os.makedirs(CACHE_DIR)\n    cached_pkgs = os.listdir(CACHE_DIR)\n    to_purge = []\n    for pkg in packages:\n        to_purge.extend([os.path.join(CACHE_DIR, x) for x in cached_pkgs if x.startswith(f'{pkg}-')])\n    for purge_target in set(to_purge):\n        log.debug('Removing cached package %s', purge_target)\n        try:\n            os.unlink(purge_target)\n        except OSError as exc:\n            log.error('Unable to remove %s: %s', purge_target, exc)\n    cmd = ['yumdownloader', '-q', f'--destdir={CACHE_DIR}']\n    cmd.extend(packages)\n    __salt__['cmd.run'](cmd, output_loglevel='trace', python_shell=False)\n    ret = {}\n    for dld_result in os.listdir(CACHE_DIR):\n        if not dld_result.endswith('.rpm'):\n            continue\n        pkg_name = None\n        pkg_file = None\n        for query_pkg in packages:\n            if dld_result.startswith(f'{query_pkg}-'):\n                pkg_name = query_pkg\n                pkg_file = dld_result\n                break\n        if pkg_file is not None:\n            ret[pkg_name] = os.path.join(CACHE_DIR, pkg_file)\n    if not ret:\n        raise CommandExecutionError('Unable to download any of the following packages: {}'.format(', '.join(packages)))\n    failed = [x for x in packages if x not in ret]\n    if failed:\n        ret['_error'] = 'The following package(s) failed to download: {}'.format(', '.join(failed))\n    return ret"
        ]
    },
    {
        "func_name": "diff",
        "original": "def diff(*paths, **kwargs):\n    \"\"\"\n    Return a formatted diff between current files and original in a package.\n    NOTE: this function includes all files (configuration and not), but does\n    not work on binary content.\n\n    :param path: Full path to the installed file\n    :return: Difference string or raises and exception if examined file is binary.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.diff /etc/apache2/httpd.conf /etc/sudoers\n    \"\"\"\n    ret = {}\n    pkg_to_paths = {}\n    for pth in paths:\n        pth_pkg = __salt__['lowpkg.owner'](pth)\n        if not pth_pkg:\n            ret[pth] = os.path.exists(pth) and 'Not managed' or 'N/A'\n        else:\n            if pkg_to_paths.get(pth_pkg) is None:\n                pkg_to_paths[pth_pkg] = []\n            pkg_to_paths[pth_pkg].append(pth)\n    if pkg_to_paths:\n        local_pkgs = __salt__['pkg.download'](*pkg_to_paths.keys())\n        for (pkg, files) in pkg_to_paths.items():\n            for path in files:\n                ret[path] = __salt__['lowpkg.diff'](local_pkgs[pkg]['path'], path) or 'Unchanged'\n    return ret",
        "mutated": [
            "def diff(*paths, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Return a formatted diff between current files and original in a package.\\n    NOTE: this function includes all files (configuration and not), but does\\n    not work on binary content.\\n\\n    :param path: Full path to the installed file\\n    :return: Difference string or raises and exception if examined file is binary.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.diff /etc/apache2/httpd.conf /etc/sudoers\\n    \"\n    ret = {}\n    pkg_to_paths = {}\n    for pth in paths:\n        pth_pkg = __salt__['lowpkg.owner'](pth)\n        if not pth_pkg:\n            ret[pth] = os.path.exists(pth) and 'Not managed' or 'N/A'\n        else:\n            if pkg_to_paths.get(pth_pkg) is None:\n                pkg_to_paths[pth_pkg] = []\n            pkg_to_paths[pth_pkg].append(pth)\n    if pkg_to_paths:\n        local_pkgs = __salt__['pkg.download'](*pkg_to_paths.keys())\n        for (pkg, files) in pkg_to_paths.items():\n            for path in files:\n                ret[path] = __salt__['lowpkg.diff'](local_pkgs[pkg]['path'], path) or 'Unchanged'\n    return ret",
            "def diff(*paths, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Return a formatted diff between current files and original in a package.\\n    NOTE: this function includes all files (configuration and not), but does\\n    not work on binary content.\\n\\n    :param path: Full path to the installed file\\n    :return: Difference string or raises and exception if examined file is binary.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.diff /etc/apache2/httpd.conf /etc/sudoers\\n    \"\n    ret = {}\n    pkg_to_paths = {}\n    for pth in paths:\n        pth_pkg = __salt__['lowpkg.owner'](pth)\n        if not pth_pkg:\n            ret[pth] = os.path.exists(pth) and 'Not managed' or 'N/A'\n        else:\n            if pkg_to_paths.get(pth_pkg) is None:\n                pkg_to_paths[pth_pkg] = []\n            pkg_to_paths[pth_pkg].append(pth)\n    if pkg_to_paths:\n        local_pkgs = __salt__['pkg.download'](*pkg_to_paths.keys())\n        for (pkg, files) in pkg_to_paths.items():\n            for path in files:\n                ret[path] = __salt__['lowpkg.diff'](local_pkgs[pkg]['path'], path) or 'Unchanged'\n    return ret",
            "def diff(*paths, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Return a formatted diff between current files and original in a package.\\n    NOTE: this function includes all files (configuration and not), but does\\n    not work on binary content.\\n\\n    :param path: Full path to the installed file\\n    :return: Difference string or raises and exception if examined file is binary.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.diff /etc/apache2/httpd.conf /etc/sudoers\\n    \"\n    ret = {}\n    pkg_to_paths = {}\n    for pth in paths:\n        pth_pkg = __salt__['lowpkg.owner'](pth)\n        if not pth_pkg:\n            ret[pth] = os.path.exists(pth) and 'Not managed' or 'N/A'\n        else:\n            if pkg_to_paths.get(pth_pkg) is None:\n                pkg_to_paths[pth_pkg] = []\n            pkg_to_paths[pth_pkg].append(pth)\n    if pkg_to_paths:\n        local_pkgs = __salt__['pkg.download'](*pkg_to_paths.keys())\n        for (pkg, files) in pkg_to_paths.items():\n            for path in files:\n                ret[path] = __salt__['lowpkg.diff'](local_pkgs[pkg]['path'], path) or 'Unchanged'\n    return ret",
            "def diff(*paths, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Return a formatted diff between current files and original in a package.\\n    NOTE: this function includes all files (configuration and not), but does\\n    not work on binary content.\\n\\n    :param path: Full path to the installed file\\n    :return: Difference string or raises and exception if examined file is binary.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.diff /etc/apache2/httpd.conf /etc/sudoers\\n    \"\n    ret = {}\n    pkg_to_paths = {}\n    for pth in paths:\n        pth_pkg = __salt__['lowpkg.owner'](pth)\n        if not pth_pkg:\n            ret[pth] = os.path.exists(pth) and 'Not managed' or 'N/A'\n        else:\n            if pkg_to_paths.get(pth_pkg) is None:\n                pkg_to_paths[pth_pkg] = []\n            pkg_to_paths[pth_pkg].append(pth)\n    if pkg_to_paths:\n        local_pkgs = __salt__['pkg.download'](*pkg_to_paths.keys())\n        for (pkg, files) in pkg_to_paths.items():\n            for path in files:\n                ret[path] = __salt__['lowpkg.diff'](local_pkgs[pkg]['path'], path) or 'Unchanged'\n    return ret",
            "def diff(*paths, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Return a formatted diff between current files and original in a package.\\n    NOTE: this function includes all files (configuration and not), but does\\n    not work on binary content.\\n\\n    :param path: Full path to the installed file\\n    :return: Difference string or raises and exception if examined file is binary.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.diff /etc/apache2/httpd.conf /etc/sudoers\\n    \"\n    ret = {}\n    pkg_to_paths = {}\n    for pth in paths:\n        pth_pkg = __salt__['lowpkg.owner'](pth)\n        if not pth_pkg:\n            ret[pth] = os.path.exists(pth) and 'Not managed' or 'N/A'\n        else:\n            if pkg_to_paths.get(pth_pkg) is None:\n                pkg_to_paths[pth_pkg] = []\n            pkg_to_paths[pth_pkg].append(pth)\n    if pkg_to_paths:\n        local_pkgs = __salt__['pkg.download'](*pkg_to_paths.keys())\n        for (pkg, files) in pkg_to_paths.items():\n            for path in files:\n                ret[path] = __salt__['lowpkg.diff'](local_pkgs[pkg]['path'], path) or 'Unchanged'\n    return ret"
        ]
    },
    {
        "func_name": "_get_patches",
        "original": "def _get_patches(installed_only=False):\n    \"\"\"\n    List all known patches in repos.\n    \"\"\"\n    patches = {}\n    cmd = [_yum(), '--quiet', 'updateinfo', 'list', 'all']\n    ret = __salt__['cmd.run_stdout'](cmd, python_shell=False)\n    parsing_errors = False\n    for line in salt.utils.itertools.split(ret, os.linesep):\n        try:\n            (inst, advisory_id, sev, pkg) = re.match('([i|\\\\s]) ([^\\\\s]+) +([^\\\\s]+) +([^\\\\s]+)', line).groups()\n        except Exception:\n            parsing_errors = True\n            continue\n        if advisory_id not in patches:\n            patches[advisory_id] = {'installed': True if inst == 'i' else False, 'summary': [pkg]}\n        else:\n            patches[advisory_id]['summary'].append(pkg)\n            if inst != 'i':\n                patches[advisory_id]['installed'] = False\n    if parsing_errors:\n        log.warning(\"Skipped some unexpected output while running '%s' to list patches. Please check output\", ' '.join(cmd))\n    if installed_only:\n        patches = {k: v for (k, v) in patches.items() if v['installed']}\n    return patches",
        "mutated": [
            "def _get_patches(installed_only=False):\n    if False:\n        i = 10\n    '\\n    List all known patches in repos.\\n    '\n    patches = {}\n    cmd = [_yum(), '--quiet', 'updateinfo', 'list', 'all']\n    ret = __salt__['cmd.run_stdout'](cmd, python_shell=False)\n    parsing_errors = False\n    for line in salt.utils.itertools.split(ret, os.linesep):\n        try:\n            (inst, advisory_id, sev, pkg) = re.match('([i|\\\\s]) ([^\\\\s]+) +([^\\\\s]+) +([^\\\\s]+)', line).groups()\n        except Exception:\n            parsing_errors = True\n            continue\n        if advisory_id not in patches:\n            patches[advisory_id] = {'installed': True if inst == 'i' else False, 'summary': [pkg]}\n        else:\n            patches[advisory_id]['summary'].append(pkg)\n            if inst != 'i':\n                patches[advisory_id]['installed'] = False\n    if parsing_errors:\n        log.warning(\"Skipped some unexpected output while running '%s' to list patches. Please check output\", ' '.join(cmd))\n    if installed_only:\n        patches = {k: v for (k, v) in patches.items() if v['installed']}\n    return patches",
            "def _get_patches(installed_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    List all known patches in repos.\\n    '\n    patches = {}\n    cmd = [_yum(), '--quiet', 'updateinfo', 'list', 'all']\n    ret = __salt__['cmd.run_stdout'](cmd, python_shell=False)\n    parsing_errors = False\n    for line in salt.utils.itertools.split(ret, os.linesep):\n        try:\n            (inst, advisory_id, sev, pkg) = re.match('([i|\\\\s]) ([^\\\\s]+) +([^\\\\s]+) +([^\\\\s]+)', line).groups()\n        except Exception:\n            parsing_errors = True\n            continue\n        if advisory_id not in patches:\n            patches[advisory_id] = {'installed': True if inst == 'i' else False, 'summary': [pkg]}\n        else:\n            patches[advisory_id]['summary'].append(pkg)\n            if inst != 'i':\n                patches[advisory_id]['installed'] = False\n    if parsing_errors:\n        log.warning(\"Skipped some unexpected output while running '%s' to list patches. Please check output\", ' '.join(cmd))\n    if installed_only:\n        patches = {k: v for (k, v) in patches.items() if v['installed']}\n    return patches",
            "def _get_patches(installed_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    List all known patches in repos.\\n    '\n    patches = {}\n    cmd = [_yum(), '--quiet', 'updateinfo', 'list', 'all']\n    ret = __salt__['cmd.run_stdout'](cmd, python_shell=False)\n    parsing_errors = False\n    for line in salt.utils.itertools.split(ret, os.linesep):\n        try:\n            (inst, advisory_id, sev, pkg) = re.match('([i|\\\\s]) ([^\\\\s]+) +([^\\\\s]+) +([^\\\\s]+)', line).groups()\n        except Exception:\n            parsing_errors = True\n            continue\n        if advisory_id not in patches:\n            patches[advisory_id] = {'installed': True if inst == 'i' else False, 'summary': [pkg]}\n        else:\n            patches[advisory_id]['summary'].append(pkg)\n            if inst != 'i':\n                patches[advisory_id]['installed'] = False\n    if parsing_errors:\n        log.warning(\"Skipped some unexpected output while running '%s' to list patches. Please check output\", ' '.join(cmd))\n    if installed_only:\n        patches = {k: v for (k, v) in patches.items() if v['installed']}\n    return patches",
            "def _get_patches(installed_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    List all known patches in repos.\\n    '\n    patches = {}\n    cmd = [_yum(), '--quiet', 'updateinfo', 'list', 'all']\n    ret = __salt__['cmd.run_stdout'](cmd, python_shell=False)\n    parsing_errors = False\n    for line in salt.utils.itertools.split(ret, os.linesep):\n        try:\n            (inst, advisory_id, sev, pkg) = re.match('([i|\\\\s]) ([^\\\\s]+) +([^\\\\s]+) +([^\\\\s]+)', line).groups()\n        except Exception:\n            parsing_errors = True\n            continue\n        if advisory_id not in patches:\n            patches[advisory_id] = {'installed': True if inst == 'i' else False, 'summary': [pkg]}\n        else:\n            patches[advisory_id]['summary'].append(pkg)\n            if inst != 'i':\n                patches[advisory_id]['installed'] = False\n    if parsing_errors:\n        log.warning(\"Skipped some unexpected output while running '%s' to list patches. Please check output\", ' '.join(cmd))\n    if installed_only:\n        patches = {k: v for (k, v) in patches.items() if v['installed']}\n    return patches",
            "def _get_patches(installed_only=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    List all known patches in repos.\\n    '\n    patches = {}\n    cmd = [_yum(), '--quiet', 'updateinfo', 'list', 'all']\n    ret = __salt__['cmd.run_stdout'](cmd, python_shell=False)\n    parsing_errors = False\n    for line in salt.utils.itertools.split(ret, os.linesep):\n        try:\n            (inst, advisory_id, sev, pkg) = re.match('([i|\\\\s]) ([^\\\\s]+) +([^\\\\s]+) +([^\\\\s]+)', line).groups()\n        except Exception:\n            parsing_errors = True\n            continue\n        if advisory_id not in patches:\n            patches[advisory_id] = {'installed': True if inst == 'i' else False, 'summary': [pkg]}\n        else:\n            patches[advisory_id]['summary'].append(pkg)\n            if inst != 'i':\n                patches[advisory_id]['installed'] = False\n    if parsing_errors:\n        log.warning(\"Skipped some unexpected output while running '%s' to list patches. Please check output\", ' '.join(cmd))\n    if installed_only:\n        patches = {k: v for (k, v) in patches.items() if v['installed']}\n    return patches"
        ]
    },
    {
        "func_name": "list_patches",
        "original": "def list_patches(refresh=False, **kwargs):\n    \"\"\"\n    .. versionadded:: 2017.7.0\n\n    List all known advisory patches from available repos.\n\n    refresh\n        force a refresh if set to True.\n        If set to False (default) it depends on yum if a refresh is\n        executed.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' pkg.list_patches\n    \"\"\"\n    if refresh:\n        refresh_db()\n    return _get_patches()",
        "mutated": [
            "def list_patches(refresh=False, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    List all known advisory patches from available repos.\\n\\n    refresh\\n        force a refresh if set to True.\\n        If set to False (default) it depends on yum if a refresh is\\n        executed.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_patches\\n    \"\n    if refresh:\n        refresh_db()\n    return _get_patches()",
            "def list_patches(refresh=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    List all known advisory patches from available repos.\\n\\n    refresh\\n        force a refresh if set to True.\\n        If set to False (default) it depends on yum if a refresh is\\n        executed.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_patches\\n    \"\n    if refresh:\n        refresh_db()\n    return _get_patches()",
            "def list_patches(refresh=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    List all known advisory patches from available repos.\\n\\n    refresh\\n        force a refresh if set to True.\\n        If set to False (default) it depends on yum if a refresh is\\n        executed.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_patches\\n    \"\n    if refresh:\n        refresh_db()\n    return _get_patches()",
            "def list_patches(refresh=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    List all known advisory patches from available repos.\\n\\n    refresh\\n        force a refresh if set to True.\\n        If set to False (default) it depends on yum if a refresh is\\n        executed.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_patches\\n    \"\n    if refresh:\n        refresh_db()\n    return _get_patches()",
            "def list_patches(refresh=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    List all known advisory patches from available repos.\\n\\n    refresh\\n        force a refresh if set to True.\\n        If set to False (default) it depends on yum if a refresh is\\n        executed.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_patches\\n    \"\n    if refresh:\n        refresh_db()\n    return _get_patches()"
        ]
    },
    {
        "func_name": "list_installed_patches",
        "original": "def list_installed_patches(**kwargs):\n    \"\"\"\n    .. versionadded:: 2017.7.0\n\n    List installed advisory patches on the system.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' pkg.list_installed_patches\n    \"\"\"\n    return _get_patches(installed_only=True)",
        "mutated": [
            "def list_installed_patches(**kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    List installed advisory patches on the system.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_installed_patches\\n    \"\n    return _get_patches(installed_only=True)",
            "def list_installed_patches(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    List installed advisory patches on the system.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_installed_patches\\n    \"\n    return _get_patches(installed_only=True)",
            "def list_installed_patches(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    List installed advisory patches on the system.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_installed_patches\\n    \"\n    return _get_patches(installed_only=True)",
            "def list_installed_patches(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    List installed advisory patches on the system.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_installed_patches\\n    \"\n    return _get_patches(installed_only=True)",
            "def list_installed_patches(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    List installed advisory patches on the system.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_installed_patches\\n    \"\n    return _get_patches(installed_only=True)"
        ]
    },
    {
        "func_name": "services_need_restart",
        "original": "def services_need_restart(**kwargs):\n    \"\"\"\n    .. versionadded:: 3003\n\n    List services that use files which have been changed by the\n    package manager. It might be needed to restart them.\n\n    Requires systemd.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' pkg.services_need_restart\n    \"\"\"\n    if _yum() != 'dnf':\n        raise CommandExecutionError('dnf is required to list outdated services.')\n    if not salt.utils.systemd.booted(__context__):\n        raise CommandExecutionError('systemd is required to list outdated services.')\n    cmd = ['dnf', '--quiet', 'needs-restarting']\n    dnf_output = __salt__['cmd.run_stdout'](cmd, python_shell=False)\n    if not dnf_output:\n        return []\n    services = set()\n    for line in dnf_output.split('\\n'):\n        (pid, has_delim, _) = line.partition(':')\n        if has_delim:\n            service = salt.utils.systemd.pid_to_service(pid.strip())\n            if service:\n                services.add(service)\n    return list(services)",
        "mutated": [
            "def services_need_restart(**kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 3003\\n\\n    List services that use files which have been changed by the\\n    package manager. It might be needed to restart them.\\n\\n    Requires systemd.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.services_need_restart\\n    \"\n    if _yum() != 'dnf':\n        raise CommandExecutionError('dnf is required to list outdated services.')\n    if not salt.utils.systemd.booted(__context__):\n        raise CommandExecutionError('systemd is required to list outdated services.')\n    cmd = ['dnf', '--quiet', 'needs-restarting']\n    dnf_output = __salt__['cmd.run_stdout'](cmd, python_shell=False)\n    if not dnf_output:\n        return []\n    services = set()\n    for line in dnf_output.split('\\n'):\n        (pid, has_delim, _) = line.partition(':')\n        if has_delim:\n            service = salt.utils.systemd.pid_to_service(pid.strip())\n            if service:\n                services.add(service)\n    return list(services)",
            "def services_need_restart(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 3003\\n\\n    List services that use files which have been changed by the\\n    package manager. It might be needed to restart them.\\n\\n    Requires systemd.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.services_need_restart\\n    \"\n    if _yum() != 'dnf':\n        raise CommandExecutionError('dnf is required to list outdated services.')\n    if not salt.utils.systemd.booted(__context__):\n        raise CommandExecutionError('systemd is required to list outdated services.')\n    cmd = ['dnf', '--quiet', 'needs-restarting']\n    dnf_output = __salt__['cmd.run_stdout'](cmd, python_shell=False)\n    if not dnf_output:\n        return []\n    services = set()\n    for line in dnf_output.split('\\n'):\n        (pid, has_delim, _) = line.partition(':')\n        if has_delim:\n            service = salt.utils.systemd.pid_to_service(pid.strip())\n            if service:\n                services.add(service)\n    return list(services)",
            "def services_need_restart(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 3003\\n\\n    List services that use files which have been changed by the\\n    package manager. It might be needed to restart them.\\n\\n    Requires systemd.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.services_need_restart\\n    \"\n    if _yum() != 'dnf':\n        raise CommandExecutionError('dnf is required to list outdated services.')\n    if not salt.utils.systemd.booted(__context__):\n        raise CommandExecutionError('systemd is required to list outdated services.')\n    cmd = ['dnf', '--quiet', 'needs-restarting']\n    dnf_output = __salt__['cmd.run_stdout'](cmd, python_shell=False)\n    if not dnf_output:\n        return []\n    services = set()\n    for line in dnf_output.split('\\n'):\n        (pid, has_delim, _) = line.partition(':')\n        if has_delim:\n            service = salt.utils.systemd.pid_to_service(pid.strip())\n            if service:\n                services.add(service)\n    return list(services)",
            "def services_need_restart(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 3003\\n\\n    List services that use files which have been changed by the\\n    package manager. It might be needed to restart them.\\n\\n    Requires systemd.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.services_need_restart\\n    \"\n    if _yum() != 'dnf':\n        raise CommandExecutionError('dnf is required to list outdated services.')\n    if not salt.utils.systemd.booted(__context__):\n        raise CommandExecutionError('systemd is required to list outdated services.')\n    cmd = ['dnf', '--quiet', 'needs-restarting']\n    dnf_output = __salt__['cmd.run_stdout'](cmd, python_shell=False)\n    if not dnf_output:\n        return []\n    services = set()\n    for line in dnf_output.split('\\n'):\n        (pid, has_delim, _) = line.partition(':')\n        if has_delim:\n            service = salt.utils.systemd.pid_to_service(pid.strip())\n            if service:\n                services.add(service)\n    return list(services)",
            "def services_need_restart(**kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 3003\\n\\n    List services that use files which have been changed by the\\n    package manager. It might be needed to restart them.\\n\\n    Requires systemd.\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.services_need_restart\\n    \"\n    if _yum() != 'dnf':\n        raise CommandExecutionError('dnf is required to list outdated services.')\n    if not salt.utils.systemd.booted(__context__):\n        raise CommandExecutionError('systemd is required to list outdated services.')\n    cmd = ['dnf', '--quiet', 'needs-restarting']\n    dnf_output = __salt__['cmd.run_stdout'](cmd, python_shell=False)\n    if not dnf_output:\n        return []\n    services = set()\n    for line in dnf_output.split('\\n'):\n        (pid, has_delim, _) = line.partition(':')\n        if has_delim:\n            service = salt.utils.systemd.pid_to_service(pid.strip())\n            if service:\n                services.add(service)\n    return list(services)"
        ]
    }
]