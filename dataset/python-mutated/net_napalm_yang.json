[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\n    This module in particular requires also napalm-yang.\n    \"\"\"\n    if not HAS_NAPALM_YANG:\n        return (False, 'Unable to load napalm_yang execution module: please install napalm-yang!')\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    This module in particular requires also napalm-yang.\\n    '\n    if not HAS_NAPALM_YANG:\n        return (False, 'Unable to load napalm_yang execution module: please install napalm-yang!')\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    This module in particular requires also napalm-yang.\\n    '\n    if not HAS_NAPALM_YANG:\n        return (False, 'Unable to load napalm_yang execution module: please install napalm-yang!')\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    This module in particular requires also napalm-yang.\\n    '\n    if not HAS_NAPALM_YANG:\n        return (False, 'Unable to load napalm_yang execution module: please install napalm-yang!')\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    This module in particular requires also napalm-yang.\\n    '\n    if not HAS_NAPALM_YANG:\n        return (False, 'Unable to load napalm_yang execution module: please install napalm-yang!')\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    This module in particular requires also napalm-yang.\\n    '\n    if not HAS_NAPALM_YANG:\n        return (False, 'Unable to load napalm_yang execution module: please install napalm-yang!')\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)"
        ]
    },
    {
        "func_name": "managed",
        "original": "def managed(name, data, **kwargs):\n    \"\"\"\n    Manage the device configuration given the input data structured\n    according to the YANG models.\n\n    data\n        YANG structured data.\n\n    models\n         A list of models to be used when generating the config.\n\n    profiles: ``None``\n        Use certain profiles to generate the config.\n        If not specified, will use the platform default profile(s).\n\n    compliance_report: ``False``\n        Return the compliance report in the comment.\n\n        .. versionadded:: 2017.7.3\n\n    test: ``False``\n        Dry run? If set as ``True``, will apply the config, discard\n        and return the changes. Default: ``False`` and will commit\n        the changes on the device.\n\n    commit: ``True``\n        Commit? Default: ``True``.\n\n    debug: ``False``\n        Debug mode. Will insert a new key under the output dictionary,\n        as ``loaded_config`` containing the raw configuration loaded on the device.\n\n    replace: ``False``\n        Should replace the config with the new generate one?\n\n    State SLS example:\n\n    .. code-block:: jinja\n\n        {%- set expected_config =  pillar.get('openconfig_interfaces_cfg') -%}\n        interfaces_config:\n          napalm_yang.managed:\n            - data: {{ expected_config | json }}\n            - models:\n              - models.openconfig_interfaces\n            - debug: true\n\n    Pillar example:\n\n    .. code-block:: yaml\n\n        openconfig_interfaces_cfg:\n          _kwargs:\n            filter: true\n          interfaces:\n            interface:\n              Et1:\n                config:\n                  mtu: 9000\n              Et2:\n                config:\n                  description: \"description example\"\n    \"\"\"\n    models = kwargs.get('models', None)\n    if isinstance(models, tuple) and isinstance(models[0], list):\n        models = models[0]\n    ret = salt.utils.napalm.default_ret(name)\n    test = kwargs.get('test', False) or __opts__.get('test', False)\n    debug = kwargs.get('debug', False) or __opts__.get('debug', False)\n    commit = kwargs.get('commit', True) or __opts__.get('commit', True)\n    replace = kwargs.get('replace', False) or __opts__.get('replace', False)\n    return_compliance_report = kwargs.get('compliance_report', False) or __opts__.get('compliance_report', False)\n    profiles = kwargs.get('profiles', [])\n    temp_file = __salt__['temp.file']()\n    log.debug('Creating temp file: %s', temp_file)\n    if 'to_dict' not in data:\n        data = {'to_dict': data}\n    data = [data]\n    with salt.utils.files.fopen(temp_file, 'w') as file_handle:\n        salt.utils.yaml.safe_dump(salt.utils.json.loads(salt.utils.json.dumps(data)), file_handle, encoding='utf-8')\n    device_config = __salt__['napalm_yang.parse'](*models, config=True, profiles=profiles)\n    log.debug('Parsed the config from the device:')\n    log.debug(device_config)\n    compliance_report = __salt__['napalm_yang.compliance_report'](device_config, *models, filepath=temp_file)\n    log.debug('Compliance report:')\n    log.debug(compliance_report)\n    complies = compliance_report.get('complies', False)\n    if complies:\n        ret.update({'result': True, 'comment': 'Already configured as required.'})\n        log.debug('All good here.')\n        return ret\n    log.debug('Does not comply, trying to generate and load config')\n    data = data[0]['to_dict']\n    if '_kwargs' in data:\n        data.pop('_kwargs')\n    loaded_changes = __salt__['napalm_yang.load_config'](data, *models, profiles=profiles, test=test, debug=debug, commit=commit, replace=replace)\n    log.debug('Loaded config result:')\n    log.debug(loaded_changes)\n    __salt__['file.remove'](temp_file)\n    loaded_changes['compliance_report'] = compliance_report\n    return salt.utils.napalm.loaded_ret(ret, loaded_changes, test, debug, opts=__opts__, compliance_report=return_compliance_report)",
        "mutated": [
            "def managed(name, data, **kwargs):\n    if False:\n        i = 10\n    '\\n    Manage the device configuration given the input data structured\\n    according to the YANG models.\\n\\n    data\\n        YANG structured data.\\n\\n    models\\n         A list of models to be used when generating the config.\\n\\n    profiles: ``None``\\n        Use certain profiles to generate the config.\\n        If not specified, will use the platform default profile(s).\\n\\n    compliance_report: ``False``\\n        Return the compliance report in the comment.\\n\\n        .. versionadded:: 2017.7.3\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard\\n        and return the changes. Default: ``False`` and will commit\\n        the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``False``\\n        Should replace the config with the new generate one?\\n\\n    State SLS example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set expected_config =  pillar.get(\\'openconfig_interfaces_cfg\\') -%}\\n        interfaces_config:\\n          napalm_yang.managed:\\n            - data: {{ expected_config | json }}\\n            - models:\\n              - models.openconfig_interfaces\\n            - debug: true\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        openconfig_interfaces_cfg:\\n          _kwargs:\\n            filter: true\\n          interfaces:\\n            interface:\\n              Et1:\\n                config:\\n                  mtu: 9000\\n              Et2:\\n                config:\\n                  description: \"description example\"\\n    '\n    models = kwargs.get('models', None)\n    if isinstance(models, tuple) and isinstance(models[0], list):\n        models = models[0]\n    ret = salt.utils.napalm.default_ret(name)\n    test = kwargs.get('test', False) or __opts__.get('test', False)\n    debug = kwargs.get('debug', False) or __opts__.get('debug', False)\n    commit = kwargs.get('commit', True) or __opts__.get('commit', True)\n    replace = kwargs.get('replace', False) or __opts__.get('replace', False)\n    return_compliance_report = kwargs.get('compliance_report', False) or __opts__.get('compliance_report', False)\n    profiles = kwargs.get('profiles', [])\n    temp_file = __salt__['temp.file']()\n    log.debug('Creating temp file: %s', temp_file)\n    if 'to_dict' not in data:\n        data = {'to_dict': data}\n    data = [data]\n    with salt.utils.files.fopen(temp_file, 'w') as file_handle:\n        salt.utils.yaml.safe_dump(salt.utils.json.loads(salt.utils.json.dumps(data)), file_handle, encoding='utf-8')\n    device_config = __salt__['napalm_yang.parse'](*models, config=True, profiles=profiles)\n    log.debug('Parsed the config from the device:')\n    log.debug(device_config)\n    compliance_report = __salt__['napalm_yang.compliance_report'](device_config, *models, filepath=temp_file)\n    log.debug('Compliance report:')\n    log.debug(compliance_report)\n    complies = compliance_report.get('complies', False)\n    if complies:\n        ret.update({'result': True, 'comment': 'Already configured as required.'})\n        log.debug('All good here.')\n        return ret\n    log.debug('Does not comply, trying to generate and load config')\n    data = data[0]['to_dict']\n    if '_kwargs' in data:\n        data.pop('_kwargs')\n    loaded_changes = __salt__['napalm_yang.load_config'](data, *models, profiles=profiles, test=test, debug=debug, commit=commit, replace=replace)\n    log.debug('Loaded config result:')\n    log.debug(loaded_changes)\n    __salt__['file.remove'](temp_file)\n    loaded_changes['compliance_report'] = compliance_report\n    return salt.utils.napalm.loaded_ret(ret, loaded_changes, test, debug, opts=__opts__, compliance_report=return_compliance_report)",
            "def managed(name, data, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Manage the device configuration given the input data structured\\n    according to the YANG models.\\n\\n    data\\n        YANG structured data.\\n\\n    models\\n         A list of models to be used when generating the config.\\n\\n    profiles: ``None``\\n        Use certain profiles to generate the config.\\n        If not specified, will use the platform default profile(s).\\n\\n    compliance_report: ``False``\\n        Return the compliance report in the comment.\\n\\n        .. versionadded:: 2017.7.3\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard\\n        and return the changes. Default: ``False`` and will commit\\n        the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``False``\\n        Should replace the config with the new generate one?\\n\\n    State SLS example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set expected_config =  pillar.get(\\'openconfig_interfaces_cfg\\') -%}\\n        interfaces_config:\\n          napalm_yang.managed:\\n            - data: {{ expected_config | json }}\\n            - models:\\n              - models.openconfig_interfaces\\n            - debug: true\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        openconfig_interfaces_cfg:\\n          _kwargs:\\n            filter: true\\n          interfaces:\\n            interface:\\n              Et1:\\n                config:\\n                  mtu: 9000\\n              Et2:\\n                config:\\n                  description: \"description example\"\\n    '\n    models = kwargs.get('models', None)\n    if isinstance(models, tuple) and isinstance(models[0], list):\n        models = models[0]\n    ret = salt.utils.napalm.default_ret(name)\n    test = kwargs.get('test', False) or __opts__.get('test', False)\n    debug = kwargs.get('debug', False) or __opts__.get('debug', False)\n    commit = kwargs.get('commit', True) or __opts__.get('commit', True)\n    replace = kwargs.get('replace', False) or __opts__.get('replace', False)\n    return_compliance_report = kwargs.get('compliance_report', False) or __opts__.get('compliance_report', False)\n    profiles = kwargs.get('profiles', [])\n    temp_file = __salt__['temp.file']()\n    log.debug('Creating temp file: %s', temp_file)\n    if 'to_dict' not in data:\n        data = {'to_dict': data}\n    data = [data]\n    with salt.utils.files.fopen(temp_file, 'w') as file_handle:\n        salt.utils.yaml.safe_dump(salt.utils.json.loads(salt.utils.json.dumps(data)), file_handle, encoding='utf-8')\n    device_config = __salt__['napalm_yang.parse'](*models, config=True, profiles=profiles)\n    log.debug('Parsed the config from the device:')\n    log.debug(device_config)\n    compliance_report = __salt__['napalm_yang.compliance_report'](device_config, *models, filepath=temp_file)\n    log.debug('Compliance report:')\n    log.debug(compliance_report)\n    complies = compliance_report.get('complies', False)\n    if complies:\n        ret.update({'result': True, 'comment': 'Already configured as required.'})\n        log.debug('All good here.')\n        return ret\n    log.debug('Does not comply, trying to generate and load config')\n    data = data[0]['to_dict']\n    if '_kwargs' in data:\n        data.pop('_kwargs')\n    loaded_changes = __salt__['napalm_yang.load_config'](data, *models, profiles=profiles, test=test, debug=debug, commit=commit, replace=replace)\n    log.debug('Loaded config result:')\n    log.debug(loaded_changes)\n    __salt__['file.remove'](temp_file)\n    loaded_changes['compliance_report'] = compliance_report\n    return salt.utils.napalm.loaded_ret(ret, loaded_changes, test, debug, opts=__opts__, compliance_report=return_compliance_report)",
            "def managed(name, data, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Manage the device configuration given the input data structured\\n    according to the YANG models.\\n\\n    data\\n        YANG structured data.\\n\\n    models\\n         A list of models to be used when generating the config.\\n\\n    profiles: ``None``\\n        Use certain profiles to generate the config.\\n        If not specified, will use the platform default profile(s).\\n\\n    compliance_report: ``False``\\n        Return the compliance report in the comment.\\n\\n        .. versionadded:: 2017.7.3\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard\\n        and return the changes. Default: ``False`` and will commit\\n        the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``False``\\n        Should replace the config with the new generate one?\\n\\n    State SLS example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set expected_config =  pillar.get(\\'openconfig_interfaces_cfg\\') -%}\\n        interfaces_config:\\n          napalm_yang.managed:\\n            - data: {{ expected_config | json }}\\n            - models:\\n              - models.openconfig_interfaces\\n            - debug: true\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        openconfig_interfaces_cfg:\\n          _kwargs:\\n            filter: true\\n          interfaces:\\n            interface:\\n              Et1:\\n                config:\\n                  mtu: 9000\\n              Et2:\\n                config:\\n                  description: \"description example\"\\n    '\n    models = kwargs.get('models', None)\n    if isinstance(models, tuple) and isinstance(models[0], list):\n        models = models[0]\n    ret = salt.utils.napalm.default_ret(name)\n    test = kwargs.get('test', False) or __opts__.get('test', False)\n    debug = kwargs.get('debug', False) or __opts__.get('debug', False)\n    commit = kwargs.get('commit', True) or __opts__.get('commit', True)\n    replace = kwargs.get('replace', False) or __opts__.get('replace', False)\n    return_compliance_report = kwargs.get('compliance_report', False) or __opts__.get('compliance_report', False)\n    profiles = kwargs.get('profiles', [])\n    temp_file = __salt__['temp.file']()\n    log.debug('Creating temp file: %s', temp_file)\n    if 'to_dict' not in data:\n        data = {'to_dict': data}\n    data = [data]\n    with salt.utils.files.fopen(temp_file, 'w') as file_handle:\n        salt.utils.yaml.safe_dump(salt.utils.json.loads(salt.utils.json.dumps(data)), file_handle, encoding='utf-8')\n    device_config = __salt__['napalm_yang.parse'](*models, config=True, profiles=profiles)\n    log.debug('Parsed the config from the device:')\n    log.debug(device_config)\n    compliance_report = __salt__['napalm_yang.compliance_report'](device_config, *models, filepath=temp_file)\n    log.debug('Compliance report:')\n    log.debug(compliance_report)\n    complies = compliance_report.get('complies', False)\n    if complies:\n        ret.update({'result': True, 'comment': 'Already configured as required.'})\n        log.debug('All good here.')\n        return ret\n    log.debug('Does not comply, trying to generate and load config')\n    data = data[0]['to_dict']\n    if '_kwargs' in data:\n        data.pop('_kwargs')\n    loaded_changes = __salt__['napalm_yang.load_config'](data, *models, profiles=profiles, test=test, debug=debug, commit=commit, replace=replace)\n    log.debug('Loaded config result:')\n    log.debug(loaded_changes)\n    __salt__['file.remove'](temp_file)\n    loaded_changes['compliance_report'] = compliance_report\n    return salt.utils.napalm.loaded_ret(ret, loaded_changes, test, debug, opts=__opts__, compliance_report=return_compliance_report)",
            "def managed(name, data, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Manage the device configuration given the input data structured\\n    according to the YANG models.\\n\\n    data\\n        YANG structured data.\\n\\n    models\\n         A list of models to be used when generating the config.\\n\\n    profiles: ``None``\\n        Use certain profiles to generate the config.\\n        If not specified, will use the platform default profile(s).\\n\\n    compliance_report: ``False``\\n        Return the compliance report in the comment.\\n\\n        .. versionadded:: 2017.7.3\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard\\n        and return the changes. Default: ``False`` and will commit\\n        the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``False``\\n        Should replace the config with the new generate one?\\n\\n    State SLS example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set expected_config =  pillar.get(\\'openconfig_interfaces_cfg\\') -%}\\n        interfaces_config:\\n          napalm_yang.managed:\\n            - data: {{ expected_config | json }}\\n            - models:\\n              - models.openconfig_interfaces\\n            - debug: true\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        openconfig_interfaces_cfg:\\n          _kwargs:\\n            filter: true\\n          interfaces:\\n            interface:\\n              Et1:\\n                config:\\n                  mtu: 9000\\n              Et2:\\n                config:\\n                  description: \"description example\"\\n    '\n    models = kwargs.get('models', None)\n    if isinstance(models, tuple) and isinstance(models[0], list):\n        models = models[0]\n    ret = salt.utils.napalm.default_ret(name)\n    test = kwargs.get('test', False) or __opts__.get('test', False)\n    debug = kwargs.get('debug', False) or __opts__.get('debug', False)\n    commit = kwargs.get('commit', True) or __opts__.get('commit', True)\n    replace = kwargs.get('replace', False) or __opts__.get('replace', False)\n    return_compliance_report = kwargs.get('compliance_report', False) or __opts__.get('compliance_report', False)\n    profiles = kwargs.get('profiles', [])\n    temp_file = __salt__['temp.file']()\n    log.debug('Creating temp file: %s', temp_file)\n    if 'to_dict' not in data:\n        data = {'to_dict': data}\n    data = [data]\n    with salt.utils.files.fopen(temp_file, 'w') as file_handle:\n        salt.utils.yaml.safe_dump(salt.utils.json.loads(salt.utils.json.dumps(data)), file_handle, encoding='utf-8')\n    device_config = __salt__['napalm_yang.parse'](*models, config=True, profiles=profiles)\n    log.debug('Parsed the config from the device:')\n    log.debug(device_config)\n    compliance_report = __salt__['napalm_yang.compliance_report'](device_config, *models, filepath=temp_file)\n    log.debug('Compliance report:')\n    log.debug(compliance_report)\n    complies = compliance_report.get('complies', False)\n    if complies:\n        ret.update({'result': True, 'comment': 'Already configured as required.'})\n        log.debug('All good here.')\n        return ret\n    log.debug('Does not comply, trying to generate and load config')\n    data = data[0]['to_dict']\n    if '_kwargs' in data:\n        data.pop('_kwargs')\n    loaded_changes = __salt__['napalm_yang.load_config'](data, *models, profiles=profiles, test=test, debug=debug, commit=commit, replace=replace)\n    log.debug('Loaded config result:')\n    log.debug(loaded_changes)\n    __salt__['file.remove'](temp_file)\n    loaded_changes['compliance_report'] = compliance_report\n    return salt.utils.napalm.loaded_ret(ret, loaded_changes, test, debug, opts=__opts__, compliance_report=return_compliance_report)",
            "def managed(name, data, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Manage the device configuration given the input data structured\\n    according to the YANG models.\\n\\n    data\\n        YANG structured data.\\n\\n    models\\n         A list of models to be used when generating the config.\\n\\n    profiles: ``None``\\n        Use certain profiles to generate the config.\\n        If not specified, will use the platform default profile(s).\\n\\n    compliance_report: ``False``\\n        Return the compliance report in the comment.\\n\\n        .. versionadded:: 2017.7.3\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard\\n        and return the changes. Default: ``False`` and will commit\\n        the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``False``\\n        Should replace the config with the new generate one?\\n\\n    State SLS example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set expected_config =  pillar.get(\\'openconfig_interfaces_cfg\\') -%}\\n        interfaces_config:\\n          napalm_yang.managed:\\n            - data: {{ expected_config | json }}\\n            - models:\\n              - models.openconfig_interfaces\\n            - debug: true\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        openconfig_interfaces_cfg:\\n          _kwargs:\\n            filter: true\\n          interfaces:\\n            interface:\\n              Et1:\\n                config:\\n                  mtu: 9000\\n              Et2:\\n                config:\\n                  description: \"description example\"\\n    '\n    models = kwargs.get('models', None)\n    if isinstance(models, tuple) and isinstance(models[0], list):\n        models = models[0]\n    ret = salt.utils.napalm.default_ret(name)\n    test = kwargs.get('test', False) or __opts__.get('test', False)\n    debug = kwargs.get('debug', False) or __opts__.get('debug', False)\n    commit = kwargs.get('commit', True) or __opts__.get('commit', True)\n    replace = kwargs.get('replace', False) or __opts__.get('replace', False)\n    return_compliance_report = kwargs.get('compliance_report', False) or __opts__.get('compliance_report', False)\n    profiles = kwargs.get('profiles', [])\n    temp_file = __salt__['temp.file']()\n    log.debug('Creating temp file: %s', temp_file)\n    if 'to_dict' not in data:\n        data = {'to_dict': data}\n    data = [data]\n    with salt.utils.files.fopen(temp_file, 'w') as file_handle:\n        salt.utils.yaml.safe_dump(salt.utils.json.loads(salt.utils.json.dumps(data)), file_handle, encoding='utf-8')\n    device_config = __salt__['napalm_yang.parse'](*models, config=True, profiles=profiles)\n    log.debug('Parsed the config from the device:')\n    log.debug(device_config)\n    compliance_report = __salt__['napalm_yang.compliance_report'](device_config, *models, filepath=temp_file)\n    log.debug('Compliance report:')\n    log.debug(compliance_report)\n    complies = compliance_report.get('complies', False)\n    if complies:\n        ret.update({'result': True, 'comment': 'Already configured as required.'})\n        log.debug('All good here.')\n        return ret\n    log.debug('Does not comply, trying to generate and load config')\n    data = data[0]['to_dict']\n    if '_kwargs' in data:\n        data.pop('_kwargs')\n    loaded_changes = __salt__['napalm_yang.load_config'](data, *models, profiles=profiles, test=test, debug=debug, commit=commit, replace=replace)\n    log.debug('Loaded config result:')\n    log.debug(loaded_changes)\n    __salt__['file.remove'](temp_file)\n    loaded_changes['compliance_report'] = compliance_report\n    return salt.utils.napalm.loaded_ret(ret, loaded_changes, test, debug, opts=__opts__, compliance_report=return_compliance_report)"
        ]
    },
    {
        "func_name": "configured",
        "original": "def configured(name, data, **kwargs):\n    \"\"\"\n    Configure the network device, given the input data strucuted\n    according to the YANG models.\n\n    .. note::\n        The main difference between this function and ``managed``\n        is that the later generates and loads the configuration\n        only when there are differences between the existing\n        configuration on the device and the expected\n        configuration. Depending on the platform and hardware\n        capabilities, one could be more optimal than the other.\n        Additionally, the output of the ``managed`` is different,\n        in such a way that the ``pchange`` field in the output\n        contains structured data, rather than text.\n\n    data\n        YANG structured data.\n\n    models\n         A list of models to be used when generating the config.\n\n    profiles: ``None``\n        Use certain profiles to generate the config.\n        If not specified, will use the platform default profile(s).\n\n    test: ``False``\n        Dry run? If set as ``True``, will apply the config, discard\n        and return the changes. Default: ``False`` and will commit\n        the changes on the device.\n\n    commit: ``True``\n        Commit? Default: ``True``.\n\n    debug: ``False``\n        Debug mode. Will insert a new key under the output dictionary,\n        as ``loaded_config`` containing the raw configuration loaded on the device.\n\n    replace: ``False``\n        Should replace the config with the new generate one?\n\n    State SLS example:\n\n    .. code-block:: jinja\n\n        {%- set expected_config =  pillar.get('openconfig_interfaces_cfg') -%}\n        interfaces_config:\n          napalm_yang.configured:\n            - data: {{ expected_config | json }}\n            - models:\n              - models.openconfig_interfaces\n            - debug: true\n\n    Pillar example:\n\n    .. code-block:: yaml\n\n        openconfig_interfaces_cfg:\n          _kwargs:\n            filter: true\n          interfaces:\n            interface:\n              Et1:\n                config:\n                  mtu: 9000\n              Et2:\n                config:\n                  description: \"description example\"\n    \"\"\"\n    models = kwargs.get('models', None)\n    if isinstance(models, tuple) and isinstance(models[0], list):\n        models = models[0]\n    ret = salt.utils.napalm.default_ret(name)\n    test = kwargs.get('test', False) or __opts__.get('test', False)\n    debug = kwargs.get('debug', False) or __opts__.get('debug', False)\n    commit = kwargs.get('commit', True) or __opts__.get('commit', True)\n    replace = kwargs.get('replace', False) or __opts__.get('replace', False)\n    profiles = kwargs.get('profiles', [])\n    if '_kwargs' in data:\n        data.pop('_kwargs')\n    loaded_changes = __salt__['napalm_yang.load_config'](data, *models, profiles=profiles, test=test, debug=debug, commit=commit, replace=replace)\n    return salt.utils.napalm.loaded_ret(ret, loaded_changes, test, debug)",
        "mutated": [
            "def configured(name, data, **kwargs):\n    if False:\n        i = 10\n    '\\n    Configure the network device, given the input data strucuted\\n    according to the YANG models.\\n\\n    .. note::\\n        The main difference between this function and ``managed``\\n        is that the later generates and loads the configuration\\n        only when there are differences between the existing\\n        configuration on the device and the expected\\n        configuration. Depending on the platform and hardware\\n        capabilities, one could be more optimal than the other.\\n        Additionally, the output of the ``managed`` is different,\\n        in such a way that the ``pchange`` field in the output\\n        contains structured data, rather than text.\\n\\n    data\\n        YANG structured data.\\n\\n    models\\n         A list of models to be used when generating the config.\\n\\n    profiles: ``None``\\n        Use certain profiles to generate the config.\\n        If not specified, will use the platform default profile(s).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard\\n        and return the changes. Default: ``False`` and will commit\\n        the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``False``\\n        Should replace the config with the new generate one?\\n\\n    State SLS example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set expected_config =  pillar.get(\\'openconfig_interfaces_cfg\\') -%}\\n        interfaces_config:\\n          napalm_yang.configured:\\n            - data: {{ expected_config | json }}\\n            - models:\\n              - models.openconfig_interfaces\\n            - debug: true\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        openconfig_interfaces_cfg:\\n          _kwargs:\\n            filter: true\\n          interfaces:\\n            interface:\\n              Et1:\\n                config:\\n                  mtu: 9000\\n              Et2:\\n                config:\\n                  description: \"description example\"\\n    '\n    models = kwargs.get('models', None)\n    if isinstance(models, tuple) and isinstance(models[0], list):\n        models = models[0]\n    ret = salt.utils.napalm.default_ret(name)\n    test = kwargs.get('test', False) or __opts__.get('test', False)\n    debug = kwargs.get('debug', False) or __opts__.get('debug', False)\n    commit = kwargs.get('commit', True) or __opts__.get('commit', True)\n    replace = kwargs.get('replace', False) or __opts__.get('replace', False)\n    profiles = kwargs.get('profiles', [])\n    if '_kwargs' in data:\n        data.pop('_kwargs')\n    loaded_changes = __salt__['napalm_yang.load_config'](data, *models, profiles=profiles, test=test, debug=debug, commit=commit, replace=replace)\n    return salt.utils.napalm.loaded_ret(ret, loaded_changes, test, debug)",
            "def configured(name, data, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Configure the network device, given the input data strucuted\\n    according to the YANG models.\\n\\n    .. note::\\n        The main difference between this function and ``managed``\\n        is that the later generates and loads the configuration\\n        only when there are differences between the existing\\n        configuration on the device and the expected\\n        configuration. Depending on the platform and hardware\\n        capabilities, one could be more optimal than the other.\\n        Additionally, the output of the ``managed`` is different,\\n        in such a way that the ``pchange`` field in the output\\n        contains structured data, rather than text.\\n\\n    data\\n        YANG structured data.\\n\\n    models\\n         A list of models to be used when generating the config.\\n\\n    profiles: ``None``\\n        Use certain profiles to generate the config.\\n        If not specified, will use the platform default profile(s).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard\\n        and return the changes. Default: ``False`` and will commit\\n        the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``False``\\n        Should replace the config with the new generate one?\\n\\n    State SLS example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set expected_config =  pillar.get(\\'openconfig_interfaces_cfg\\') -%}\\n        interfaces_config:\\n          napalm_yang.configured:\\n            - data: {{ expected_config | json }}\\n            - models:\\n              - models.openconfig_interfaces\\n            - debug: true\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        openconfig_interfaces_cfg:\\n          _kwargs:\\n            filter: true\\n          interfaces:\\n            interface:\\n              Et1:\\n                config:\\n                  mtu: 9000\\n              Et2:\\n                config:\\n                  description: \"description example\"\\n    '\n    models = kwargs.get('models', None)\n    if isinstance(models, tuple) and isinstance(models[0], list):\n        models = models[0]\n    ret = salt.utils.napalm.default_ret(name)\n    test = kwargs.get('test', False) or __opts__.get('test', False)\n    debug = kwargs.get('debug', False) or __opts__.get('debug', False)\n    commit = kwargs.get('commit', True) or __opts__.get('commit', True)\n    replace = kwargs.get('replace', False) or __opts__.get('replace', False)\n    profiles = kwargs.get('profiles', [])\n    if '_kwargs' in data:\n        data.pop('_kwargs')\n    loaded_changes = __salt__['napalm_yang.load_config'](data, *models, profiles=profiles, test=test, debug=debug, commit=commit, replace=replace)\n    return salt.utils.napalm.loaded_ret(ret, loaded_changes, test, debug)",
            "def configured(name, data, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Configure the network device, given the input data strucuted\\n    according to the YANG models.\\n\\n    .. note::\\n        The main difference between this function and ``managed``\\n        is that the later generates and loads the configuration\\n        only when there are differences between the existing\\n        configuration on the device and the expected\\n        configuration. Depending on the platform and hardware\\n        capabilities, one could be more optimal than the other.\\n        Additionally, the output of the ``managed`` is different,\\n        in such a way that the ``pchange`` field in the output\\n        contains structured data, rather than text.\\n\\n    data\\n        YANG structured data.\\n\\n    models\\n         A list of models to be used when generating the config.\\n\\n    profiles: ``None``\\n        Use certain profiles to generate the config.\\n        If not specified, will use the platform default profile(s).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard\\n        and return the changes. Default: ``False`` and will commit\\n        the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``False``\\n        Should replace the config with the new generate one?\\n\\n    State SLS example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set expected_config =  pillar.get(\\'openconfig_interfaces_cfg\\') -%}\\n        interfaces_config:\\n          napalm_yang.configured:\\n            - data: {{ expected_config | json }}\\n            - models:\\n              - models.openconfig_interfaces\\n            - debug: true\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        openconfig_interfaces_cfg:\\n          _kwargs:\\n            filter: true\\n          interfaces:\\n            interface:\\n              Et1:\\n                config:\\n                  mtu: 9000\\n              Et2:\\n                config:\\n                  description: \"description example\"\\n    '\n    models = kwargs.get('models', None)\n    if isinstance(models, tuple) and isinstance(models[0], list):\n        models = models[0]\n    ret = salt.utils.napalm.default_ret(name)\n    test = kwargs.get('test', False) or __opts__.get('test', False)\n    debug = kwargs.get('debug', False) or __opts__.get('debug', False)\n    commit = kwargs.get('commit', True) or __opts__.get('commit', True)\n    replace = kwargs.get('replace', False) or __opts__.get('replace', False)\n    profiles = kwargs.get('profiles', [])\n    if '_kwargs' in data:\n        data.pop('_kwargs')\n    loaded_changes = __salt__['napalm_yang.load_config'](data, *models, profiles=profiles, test=test, debug=debug, commit=commit, replace=replace)\n    return salt.utils.napalm.loaded_ret(ret, loaded_changes, test, debug)",
            "def configured(name, data, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Configure the network device, given the input data strucuted\\n    according to the YANG models.\\n\\n    .. note::\\n        The main difference between this function and ``managed``\\n        is that the later generates and loads the configuration\\n        only when there are differences between the existing\\n        configuration on the device and the expected\\n        configuration. Depending on the platform and hardware\\n        capabilities, one could be more optimal than the other.\\n        Additionally, the output of the ``managed`` is different,\\n        in such a way that the ``pchange`` field in the output\\n        contains structured data, rather than text.\\n\\n    data\\n        YANG structured data.\\n\\n    models\\n         A list of models to be used when generating the config.\\n\\n    profiles: ``None``\\n        Use certain profiles to generate the config.\\n        If not specified, will use the platform default profile(s).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard\\n        and return the changes. Default: ``False`` and will commit\\n        the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``False``\\n        Should replace the config with the new generate one?\\n\\n    State SLS example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set expected_config =  pillar.get(\\'openconfig_interfaces_cfg\\') -%}\\n        interfaces_config:\\n          napalm_yang.configured:\\n            - data: {{ expected_config | json }}\\n            - models:\\n              - models.openconfig_interfaces\\n            - debug: true\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        openconfig_interfaces_cfg:\\n          _kwargs:\\n            filter: true\\n          interfaces:\\n            interface:\\n              Et1:\\n                config:\\n                  mtu: 9000\\n              Et2:\\n                config:\\n                  description: \"description example\"\\n    '\n    models = kwargs.get('models', None)\n    if isinstance(models, tuple) and isinstance(models[0], list):\n        models = models[0]\n    ret = salt.utils.napalm.default_ret(name)\n    test = kwargs.get('test', False) or __opts__.get('test', False)\n    debug = kwargs.get('debug', False) or __opts__.get('debug', False)\n    commit = kwargs.get('commit', True) or __opts__.get('commit', True)\n    replace = kwargs.get('replace', False) or __opts__.get('replace', False)\n    profiles = kwargs.get('profiles', [])\n    if '_kwargs' in data:\n        data.pop('_kwargs')\n    loaded_changes = __salt__['napalm_yang.load_config'](data, *models, profiles=profiles, test=test, debug=debug, commit=commit, replace=replace)\n    return salt.utils.napalm.loaded_ret(ret, loaded_changes, test, debug)",
            "def configured(name, data, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Configure the network device, given the input data strucuted\\n    according to the YANG models.\\n\\n    .. note::\\n        The main difference between this function and ``managed``\\n        is that the later generates and loads the configuration\\n        only when there are differences between the existing\\n        configuration on the device and the expected\\n        configuration. Depending on the platform and hardware\\n        capabilities, one could be more optimal than the other.\\n        Additionally, the output of the ``managed`` is different,\\n        in such a way that the ``pchange`` field in the output\\n        contains structured data, rather than text.\\n\\n    data\\n        YANG structured data.\\n\\n    models\\n         A list of models to be used when generating the config.\\n\\n    profiles: ``None``\\n        Use certain profiles to generate the config.\\n        If not specified, will use the platform default profile(s).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard\\n        and return the changes. Default: ``False`` and will commit\\n        the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``False``\\n        Should replace the config with the new generate one?\\n\\n    State SLS example:\\n\\n    .. code-block:: jinja\\n\\n        {%- set expected_config =  pillar.get(\\'openconfig_interfaces_cfg\\') -%}\\n        interfaces_config:\\n          napalm_yang.configured:\\n            - data: {{ expected_config | json }}\\n            - models:\\n              - models.openconfig_interfaces\\n            - debug: true\\n\\n    Pillar example:\\n\\n    .. code-block:: yaml\\n\\n        openconfig_interfaces_cfg:\\n          _kwargs:\\n            filter: true\\n          interfaces:\\n            interface:\\n              Et1:\\n                config:\\n                  mtu: 9000\\n              Et2:\\n                config:\\n                  description: \"description example\"\\n    '\n    models = kwargs.get('models', None)\n    if isinstance(models, tuple) and isinstance(models[0], list):\n        models = models[0]\n    ret = salt.utils.napalm.default_ret(name)\n    test = kwargs.get('test', False) or __opts__.get('test', False)\n    debug = kwargs.get('debug', False) or __opts__.get('debug', False)\n    commit = kwargs.get('commit', True) or __opts__.get('commit', True)\n    replace = kwargs.get('replace', False) or __opts__.get('replace', False)\n    profiles = kwargs.get('profiles', [])\n    if '_kwargs' in data:\n        data.pop('_kwargs')\n    loaded_changes = __salt__['napalm_yang.load_config'](data, *models, profiles=profiles, test=test, debug=debug, commit=commit, replace=replace)\n    return salt.utils.napalm.loaded_ret(ret, loaded_changes, test, debug)"
        ]
    }
]