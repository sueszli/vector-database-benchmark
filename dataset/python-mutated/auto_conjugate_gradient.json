[
    {
        "func_name": "__call__",
        "original": "@abc.abstractmethod\ndef __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    raise NotImplementedError",
        "mutated": [
            "@abc.abstractmethod\ndef __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if False:\n        i = 10\n    raise NotImplementedError",
            "@abc.abstractmethod\ndef __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    raise NotImplementedError",
            "@abc.abstractmethod\ndef __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    raise NotImplementedError",
            "@abc.abstractmethod\ndef __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    raise NotImplementedError",
            "@abc.abstractmethod\ndef __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    raise NotImplementedError"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, from_logits, reduction='sum'):\n    self.ce_loss = tf.keras.losses.CategoricalCrossentropy(from_logits=from_logits, reduction=tf.keras.losses.Reduction.NONE)\n    self.reduction = reduction",
        "mutated": [
            "def __init__(self, from_logits, reduction='sum'):\n    if False:\n        i = 10\n    self.ce_loss = tf.keras.losses.CategoricalCrossentropy(from_logits=from_logits, reduction=tf.keras.losses.Reduction.NONE)\n    self.reduction = reduction",
            "def __init__(self, from_logits, reduction='sum'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.ce_loss = tf.keras.losses.CategoricalCrossentropy(from_logits=from_logits, reduction=tf.keras.losses.Reduction.NONE)\n    self.reduction = reduction",
            "def __init__(self, from_logits, reduction='sum'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.ce_loss = tf.keras.losses.CategoricalCrossentropy(from_logits=from_logits, reduction=tf.keras.losses.Reduction.NONE)\n    self.reduction = reduction",
            "def __init__(self, from_logits, reduction='sum'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.ce_loss = tf.keras.losses.CategoricalCrossentropy(from_logits=from_logits, reduction=tf.keras.losses.Reduction.NONE)\n    self.reduction = reduction",
            "def __init__(self, from_logits, reduction='sum'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.ce_loss = tf.keras.losses.CategoricalCrossentropy(from_logits=from_logits, reduction=tf.keras.losses.Reduction.NONE)\n    self.reduction = reduction"
        ]
    },
    {
        "func_name": "__call__",
        "original": "def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if self.reduction == 'mean':\n        return tf.reduce_mean(self.ce_loss(y_true, y_pred))\n    if self.reduction == 'sum':\n        return tf.reduce_sum(self.ce_loss(y_true, y_pred))\n    if self.reduction == 'none':\n        return self.ce_loss(y_true, y_pred)\n    raise NotImplementedError()",
        "mutated": [
            "def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if False:\n        i = 10\n    if self.reduction == 'mean':\n        return tf.reduce_mean(self.ce_loss(y_true, y_pred))\n    if self.reduction == 'sum':\n        return tf.reduce_sum(self.ce_loss(y_true, y_pred))\n    if self.reduction == 'none':\n        return self.ce_loss(y_true, y_pred)\n    raise NotImplementedError()",
            "def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.reduction == 'mean':\n        return tf.reduce_mean(self.ce_loss(y_true, y_pred))\n    if self.reduction == 'sum':\n        return tf.reduce_sum(self.ce_loss(y_true, y_pred))\n    if self.reduction == 'none':\n        return self.ce_loss(y_true, y_pred)\n    raise NotImplementedError()",
            "def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.reduction == 'mean':\n        return tf.reduce_mean(self.ce_loss(y_true, y_pred))\n    if self.reduction == 'sum':\n        return tf.reduce_sum(self.ce_loss(y_true, y_pred))\n    if self.reduction == 'none':\n        return self.ce_loss(y_true, y_pred)\n    raise NotImplementedError()",
            "def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.reduction == 'mean':\n        return tf.reduce_mean(self.ce_loss(y_true, y_pred))\n    if self.reduction == 'sum':\n        return tf.reduce_sum(self.ce_loss(y_true, y_pred))\n    if self.reduction == 'none':\n        return self.ce_loss(y_true, y_pred)\n    raise NotImplementedError()",
            "def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.reduction == 'mean':\n        return tf.reduce_mean(self.ce_loss(y_true, y_pred))\n    if self.reduction == 'sum':\n        return tf.reduce_sum(self.ce_loss(y_true, y_pred))\n    if self.reduction == 'none':\n        return self.ce_loss(y_true, y_pred)\n    raise NotImplementedError()"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.reduction = 'sum'",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.reduction = 'sum'",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.reduction = 'sum'",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.reduction = 'sum'",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.reduction = 'sum'",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.reduction = 'sum'"
        ]
    },
    {
        "func_name": "__call__",
        "original": "def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    i_y_true = tf.cast(tf.math.argmax(tf.cast(y_true, tf.int32), axis=1), tf.int32)\n    i_y_pred_arg = tf.argsort(y_pred, axis=1)\n    i_z_i_list = []\n    for i in range(y_true.shape[0]):\n        if i_y_pred_arg[i, -1] != i_y_true[i]:\n            i_z_i_list.append(i_y_pred_arg[i, -1])\n        else:\n            i_z_i_list.append(i_y_pred_arg[i, -2])\n    i_z_i = tf.stack(i_z_i_list)\n    z_1 = tf.gather(y_pred, i_y_pred_arg[:, -1], axis=1, batch_dims=0)\n    z_3 = tf.gather(y_pred, i_y_pred_arg[:, -3], axis=1, batch_dims=0)\n    z_i = tf.gather(y_pred, i_z_i, axis=1, batch_dims=0)\n    z_y = tf.gather(y_pred, i_y_true, axis=1, batch_dims=0)\n    z_1 = tf.linalg.diag_part(z_1)\n    z_3 = tf.linalg.diag_part(z_3)\n    z_i = tf.linalg.diag_part(z_i)\n    z_y = tf.linalg.diag_part(z_y)\n    dlr = -(z_y - z_i) / (z_1 - z_3)\n    if self.reduction == 'mean':\n        return tf.reduce_mean(dlr)\n    if self.reduction == 'sum':\n        return tf.reduce_sum(dlr)\n    if self.reduction == 'none':\n        return dlr\n    raise NotImplementedError()",
        "mutated": [
            "def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if False:\n        i = 10\n    i_y_true = tf.cast(tf.math.argmax(tf.cast(y_true, tf.int32), axis=1), tf.int32)\n    i_y_pred_arg = tf.argsort(y_pred, axis=1)\n    i_z_i_list = []\n    for i in range(y_true.shape[0]):\n        if i_y_pred_arg[i, -1] != i_y_true[i]:\n            i_z_i_list.append(i_y_pred_arg[i, -1])\n        else:\n            i_z_i_list.append(i_y_pred_arg[i, -2])\n    i_z_i = tf.stack(i_z_i_list)\n    z_1 = tf.gather(y_pred, i_y_pred_arg[:, -1], axis=1, batch_dims=0)\n    z_3 = tf.gather(y_pred, i_y_pred_arg[:, -3], axis=1, batch_dims=0)\n    z_i = tf.gather(y_pred, i_z_i, axis=1, batch_dims=0)\n    z_y = tf.gather(y_pred, i_y_true, axis=1, batch_dims=0)\n    z_1 = tf.linalg.diag_part(z_1)\n    z_3 = tf.linalg.diag_part(z_3)\n    z_i = tf.linalg.diag_part(z_i)\n    z_y = tf.linalg.diag_part(z_y)\n    dlr = -(z_y - z_i) / (z_1 - z_3)\n    if self.reduction == 'mean':\n        return tf.reduce_mean(dlr)\n    if self.reduction == 'sum':\n        return tf.reduce_sum(dlr)\n    if self.reduction == 'none':\n        return dlr\n    raise NotImplementedError()",
            "def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    i_y_true = tf.cast(tf.math.argmax(tf.cast(y_true, tf.int32), axis=1), tf.int32)\n    i_y_pred_arg = tf.argsort(y_pred, axis=1)\n    i_z_i_list = []\n    for i in range(y_true.shape[0]):\n        if i_y_pred_arg[i, -1] != i_y_true[i]:\n            i_z_i_list.append(i_y_pred_arg[i, -1])\n        else:\n            i_z_i_list.append(i_y_pred_arg[i, -2])\n    i_z_i = tf.stack(i_z_i_list)\n    z_1 = tf.gather(y_pred, i_y_pred_arg[:, -1], axis=1, batch_dims=0)\n    z_3 = tf.gather(y_pred, i_y_pred_arg[:, -3], axis=1, batch_dims=0)\n    z_i = tf.gather(y_pred, i_z_i, axis=1, batch_dims=0)\n    z_y = tf.gather(y_pred, i_y_true, axis=1, batch_dims=0)\n    z_1 = tf.linalg.diag_part(z_1)\n    z_3 = tf.linalg.diag_part(z_3)\n    z_i = tf.linalg.diag_part(z_i)\n    z_y = tf.linalg.diag_part(z_y)\n    dlr = -(z_y - z_i) / (z_1 - z_3)\n    if self.reduction == 'mean':\n        return tf.reduce_mean(dlr)\n    if self.reduction == 'sum':\n        return tf.reduce_sum(dlr)\n    if self.reduction == 'none':\n        return dlr\n    raise NotImplementedError()",
            "def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    i_y_true = tf.cast(tf.math.argmax(tf.cast(y_true, tf.int32), axis=1), tf.int32)\n    i_y_pred_arg = tf.argsort(y_pred, axis=1)\n    i_z_i_list = []\n    for i in range(y_true.shape[0]):\n        if i_y_pred_arg[i, -1] != i_y_true[i]:\n            i_z_i_list.append(i_y_pred_arg[i, -1])\n        else:\n            i_z_i_list.append(i_y_pred_arg[i, -2])\n    i_z_i = tf.stack(i_z_i_list)\n    z_1 = tf.gather(y_pred, i_y_pred_arg[:, -1], axis=1, batch_dims=0)\n    z_3 = tf.gather(y_pred, i_y_pred_arg[:, -3], axis=1, batch_dims=0)\n    z_i = tf.gather(y_pred, i_z_i, axis=1, batch_dims=0)\n    z_y = tf.gather(y_pred, i_y_true, axis=1, batch_dims=0)\n    z_1 = tf.linalg.diag_part(z_1)\n    z_3 = tf.linalg.diag_part(z_3)\n    z_i = tf.linalg.diag_part(z_i)\n    z_y = tf.linalg.diag_part(z_y)\n    dlr = -(z_y - z_i) / (z_1 - z_3)\n    if self.reduction == 'mean':\n        return tf.reduce_mean(dlr)\n    if self.reduction == 'sum':\n        return tf.reduce_sum(dlr)\n    if self.reduction == 'none':\n        return dlr\n    raise NotImplementedError()",
            "def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    i_y_true = tf.cast(tf.math.argmax(tf.cast(y_true, tf.int32), axis=1), tf.int32)\n    i_y_pred_arg = tf.argsort(y_pred, axis=1)\n    i_z_i_list = []\n    for i in range(y_true.shape[0]):\n        if i_y_pred_arg[i, -1] != i_y_true[i]:\n            i_z_i_list.append(i_y_pred_arg[i, -1])\n        else:\n            i_z_i_list.append(i_y_pred_arg[i, -2])\n    i_z_i = tf.stack(i_z_i_list)\n    z_1 = tf.gather(y_pred, i_y_pred_arg[:, -1], axis=1, batch_dims=0)\n    z_3 = tf.gather(y_pred, i_y_pred_arg[:, -3], axis=1, batch_dims=0)\n    z_i = tf.gather(y_pred, i_z_i, axis=1, batch_dims=0)\n    z_y = tf.gather(y_pred, i_y_true, axis=1, batch_dims=0)\n    z_1 = tf.linalg.diag_part(z_1)\n    z_3 = tf.linalg.diag_part(z_3)\n    z_i = tf.linalg.diag_part(z_i)\n    z_y = tf.linalg.diag_part(z_y)\n    dlr = -(z_y - z_i) / (z_1 - z_3)\n    if self.reduction == 'mean':\n        return tf.reduce_mean(dlr)\n    if self.reduction == 'sum':\n        return tf.reduce_sum(dlr)\n    if self.reduction == 'none':\n        return dlr\n    raise NotImplementedError()",
            "def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    i_y_true = tf.cast(tf.math.argmax(tf.cast(y_true, tf.int32), axis=1), tf.int32)\n    i_y_pred_arg = tf.argsort(y_pred, axis=1)\n    i_z_i_list = []\n    for i in range(y_true.shape[0]):\n        if i_y_pred_arg[i, -1] != i_y_true[i]:\n            i_z_i_list.append(i_y_pred_arg[i, -1])\n        else:\n            i_z_i_list.append(i_y_pred_arg[i, -2])\n    i_z_i = tf.stack(i_z_i_list)\n    z_1 = tf.gather(y_pred, i_y_pred_arg[:, -1], axis=1, batch_dims=0)\n    z_3 = tf.gather(y_pred, i_y_pred_arg[:, -3], axis=1, batch_dims=0)\n    z_i = tf.gather(y_pred, i_z_i, axis=1, batch_dims=0)\n    z_y = tf.gather(y_pred, i_y_true, axis=1, batch_dims=0)\n    z_1 = tf.linalg.diag_part(z_1)\n    z_3 = tf.linalg.diag_part(z_3)\n    z_i = tf.linalg.diag_part(z_i)\n    z_y = tf.linalg.diag_part(z_y)\n    dlr = -(z_y - z_i) / (z_1 - z_3)\n    if self.reduction == 'mean':\n        return tf.reduce_mean(dlr)\n    if self.reduction == 'sum':\n        return tf.reduce_sum(dlr)\n    if self.reduction == 'none':\n        return dlr\n    raise NotImplementedError()"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, reduction='sum'):\n    super().__init__()\n    self.ce_loss = torch.nn.CrossEntropyLoss(reduction='none')\n    self.reduction = reduction",
        "mutated": [
            "def __init__(self, reduction='sum'):\n    if False:\n        i = 10\n    super().__init__()\n    self.ce_loss = torch.nn.CrossEntropyLoss(reduction='none')\n    self.reduction = reduction",
            "def __init__(self, reduction='sum'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__()\n    self.ce_loss = torch.nn.CrossEntropyLoss(reduction='none')\n    self.reduction = reduction",
            "def __init__(self, reduction='sum'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__()\n    self.ce_loss = torch.nn.CrossEntropyLoss(reduction='none')\n    self.reduction = reduction",
            "def __init__(self, reduction='sum'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__()\n    self.ce_loss = torch.nn.CrossEntropyLoss(reduction='none')\n    self.reduction = reduction",
            "def __init__(self, reduction='sum'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__()\n    self.ce_loss = torch.nn.CrossEntropyLoss(reduction='none')\n    self.reduction = reduction"
        ]
    },
    {
        "func_name": "__call__",
        "original": "def __call__(self, y_true: torch.Tensor, y_pred: torch.Tensor, *args, **kwargs) -> torch.Tensor:\n    if self.reduction == 'mean':\n        return self.ce_loss(y_true, y_pred).mean()\n    if self.reduction == 'sum':\n        return self.ce_loss(y_true, y_pred).sum()\n    if self.reduction == 'none':\n        return self.ce_loss(y_true, y_pred)\n    raise NotImplementedError()",
        "mutated": [
            "def __call__(self, y_true: torch.Tensor, y_pred: torch.Tensor, *args, **kwargs) -> torch.Tensor:\n    if False:\n        i = 10\n    if self.reduction == 'mean':\n        return self.ce_loss(y_true, y_pred).mean()\n    if self.reduction == 'sum':\n        return self.ce_loss(y_true, y_pred).sum()\n    if self.reduction == 'none':\n        return self.ce_loss(y_true, y_pred)\n    raise NotImplementedError()",
            "def __call__(self, y_true: torch.Tensor, y_pred: torch.Tensor, *args, **kwargs) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.reduction == 'mean':\n        return self.ce_loss(y_true, y_pred).mean()\n    if self.reduction == 'sum':\n        return self.ce_loss(y_true, y_pred).sum()\n    if self.reduction == 'none':\n        return self.ce_loss(y_true, y_pred)\n    raise NotImplementedError()",
            "def __call__(self, y_true: torch.Tensor, y_pred: torch.Tensor, *args, **kwargs) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.reduction == 'mean':\n        return self.ce_loss(y_true, y_pred).mean()\n    if self.reduction == 'sum':\n        return self.ce_loss(y_true, y_pred).sum()\n    if self.reduction == 'none':\n        return self.ce_loss(y_true, y_pred)\n    raise NotImplementedError()",
            "def __call__(self, y_true: torch.Tensor, y_pred: torch.Tensor, *args, **kwargs) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.reduction == 'mean':\n        return self.ce_loss(y_true, y_pred).mean()\n    if self.reduction == 'sum':\n        return self.ce_loss(y_true, y_pred).sum()\n    if self.reduction == 'none':\n        return self.ce_loss(y_true, y_pred)\n    raise NotImplementedError()",
            "def __call__(self, y_true: torch.Tensor, y_pred: torch.Tensor, *args, **kwargs) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.reduction == 'mean':\n        return self.ce_loss(y_true, y_pred).mean()\n    if self.reduction == 'sum':\n        return self.ce_loss(y_true, y_pred).sum()\n    if self.reduction == 'none':\n        return self.ce_loss(y_true, y_pred)\n    raise NotImplementedError()"
        ]
    },
    {
        "func_name": "forward",
        "original": "def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n                            Forward method.\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\n                            :param target: Target labels of shape (nb_samples, nb_classes).\n                            :return: Difference Logits Ratio Loss.\n                            \"\"\"\n    return self.__call__(y_true=target, y_pred=input)",
        "mutated": [
            "def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n    '\\n                            Forward method.\\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\\n                            :param target: Target labels of shape (nb_samples, nb_classes).\\n                            :return: Difference Logits Ratio Loss.\\n                            '\n    return self.__call__(y_true=target, y_pred=input)",
            "def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n                            Forward method.\\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\\n                            :param target: Target labels of shape (nb_samples, nb_classes).\\n                            :return: Difference Logits Ratio Loss.\\n                            '\n    return self.__call__(y_true=target, y_pred=input)",
            "def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n                            Forward method.\\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\\n                            :param target: Target labels of shape (nb_samples, nb_classes).\\n                            :return: Difference Logits Ratio Loss.\\n                            '\n    return self.__call__(y_true=target, y_pred=input)",
            "def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n                            Forward method.\\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\\n                            :param target: Target labels of shape (nb_samples, nb_classes).\\n                            :return: Difference Logits Ratio Loss.\\n                            '\n    return self.__call__(y_true=target, y_pred=input)",
            "def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n                            Forward method.\\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\\n                            :param target: Target labels of shape (nb_samples, nb_classes).\\n                            :return: Difference Logits Ratio Loss.\\n                            '\n    return self.__call__(y_true=target, y_pred=input)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    super().__init__()\n    self.reduction = 'sum'",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    super().__init__()\n    self.reduction = 'sum'",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__()\n    self.reduction = 'sum'",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__()\n    self.reduction = 'sum'",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__()\n    self.reduction = 'sum'",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__()\n    self.reduction = 'sum'"
        ]
    },
    {
        "func_name": "__call__",
        "original": "def __call__(self, y_pred: torch.Tensor, y_true: torch.Tensor) -> torch.Tensor:\n    if isinstance(y_true, np.ndarray):\n        y_true = torch.from_numpy(y_true)\n    if isinstance(y_pred, np.ndarray):\n        y_pred = torch.from_numpy(y_pred)\n    y_true = y_true.float()\n    i_y_true = torch.argmax(y_true, dim=1)\n    i_y_pred_arg = torch.argsort(y_pred, dim=1)\n    i_z_i_list = []\n    for i in range(y_true.shape[0]):\n        if i_y_pred_arg[i, -1] != i_y_true[i]:\n            i_z_i_list.append(i_y_pred_arg[i, -1])\n        else:\n            i_z_i_list.append(i_y_pred_arg[i, -2])\n    i_z_i = torch.stack(i_z_i_list)\n    z_1 = y_pred[:, i_y_pred_arg[:, -1]]\n    z_3 = y_pred[:, i_y_pred_arg[:, -3]]\n    z_i = y_pred[:, i_z_i]\n    z_y = y_pred[:, i_y_true]\n    z_1 = torch.diagonal(z_1)\n    z_3 = torch.diagonal(z_3)\n    z_i = torch.diagonal(z_i)\n    z_y = torch.diagonal(z_y)\n    dlr = (-(z_y - z_i) / (z_1 - z_3)).float()\n    if self.reduction == 'mean':\n        return dlr.mean()\n    if self.reduction == 'sum':\n        return dlr.sum()\n    if self.reduction == 'none':\n        return dlr\n    raise NotImplementedError()",
        "mutated": [
            "def __call__(self, y_pred: torch.Tensor, y_true: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n    if isinstance(y_true, np.ndarray):\n        y_true = torch.from_numpy(y_true)\n    if isinstance(y_pred, np.ndarray):\n        y_pred = torch.from_numpy(y_pred)\n    y_true = y_true.float()\n    i_y_true = torch.argmax(y_true, dim=1)\n    i_y_pred_arg = torch.argsort(y_pred, dim=1)\n    i_z_i_list = []\n    for i in range(y_true.shape[0]):\n        if i_y_pred_arg[i, -1] != i_y_true[i]:\n            i_z_i_list.append(i_y_pred_arg[i, -1])\n        else:\n            i_z_i_list.append(i_y_pred_arg[i, -2])\n    i_z_i = torch.stack(i_z_i_list)\n    z_1 = y_pred[:, i_y_pred_arg[:, -1]]\n    z_3 = y_pred[:, i_y_pred_arg[:, -3]]\n    z_i = y_pred[:, i_z_i]\n    z_y = y_pred[:, i_y_true]\n    z_1 = torch.diagonal(z_1)\n    z_3 = torch.diagonal(z_3)\n    z_i = torch.diagonal(z_i)\n    z_y = torch.diagonal(z_y)\n    dlr = (-(z_y - z_i) / (z_1 - z_3)).float()\n    if self.reduction == 'mean':\n        return dlr.mean()\n    if self.reduction == 'sum':\n        return dlr.sum()\n    if self.reduction == 'none':\n        return dlr\n    raise NotImplementedError()",
            "def __call__(self, y_pred: torch.Tensor, y_true: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(y_true, np.ndarray):\n        y_true = torch.from_numpy(y_true)\n    if isinstance(y_pred, np.ndarray):\n        y_pred = torch.from_numpy(y_pred)\n    y_true = y_true.float()\n    i_y_true = torch.argmax(y_true, dim=1)\n    i_y_pred_arg = torch.argsort(y_pred, dim=1)\n    i_z_i_list = []\n    for i in range(y_true.shape[0]):\n        if i_y_pred_arg[i, -1] != i_y_true[i]:\n            i_z_i_list.append(i_y_pred_arg[i, -1])\n        else:\n            i_z_i_list.append(i_y_pred_arg[i, -2])\n    i_z_i = torch.stack(i_z_i_list)\n    z_1 = y_pred[:, i_y_pred_arg[:, -1]]\n    z_3 = y_pred[:, i_y_pred_arg[:, -3]]\n    z_i = y_pred[:, i_z_i]\n    z_y = y_pred[:, i_y_true]\n    z_1 = torch.diagonal(z_1)\n    z_3 = torch.diagonal(z_3)\n    z_i = torch.diagonal(z_i)\n    z_y = torch.diagonal(z_y)\n    dlr = (-(z_y - z_i) / (z_1 - z_3)).float()\n    if self.reduction == 'mean':\n        return dlr.mean()\n    if self.reduction == 'sum':\n        return dlr.sum()\n    if self.reduction == 'none':\n        return dlr\n    raise NotImplementedError()",
            "def __call__(self, y_pred: torch.Tensor, y_true: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(y_true, np.ndarray):\n        y_true = torch.from_numpy(y_true)\n    if isinstance(y_pred, np.ndarray):\n        y_pred = torch.from_numpy(y_pred)\n    y_true = y_true.float()\n    i_y_true = torch.argmax(y_true, dim=1)\n    i_y_pred_arg = torch.argsort(y_pred, dim=1)\n    i_z_i_list = []\n    for i in range(y_true.shape[0]):\n        if i_y_pred_arg[i, -1] != i_y_true[i]:\n            i_z_i_list.append(i_y_pred_arg[i, -1])\n        else:\n            i_z_i_list.append(i_y_pred_arg[i, -2])\n    i_z_i = torch.stack(i_z_i_list)\n    z_1 = y_pred[:, i_y_pred_arg[:, -1]]\n    z_3 = y_pred[:, i_y_pred_arg[:, -3]]\n    z_i = y_pred[:, i_z_i]\n    z_y = y_pred[:, i_y_true]\n    z_1 = torch.diagonal(z_1)\n    z_3 = torch.diagonal(z_3)\n    z_i = torch.diagonal(z_i)\n    z_y = torch.diagonal(z_y)\n    dlr = (-(z_y - z_i) / (z_1 - z_3)).float()\n    if self.reduction == 'mean':\n        return dlr.mean()\n    if self.reduction == 'sum':\n        return dlr.sum()\n    if self.reduction == 'none':\n        return dlr\n    raise NotImplementedError()",
            "def __call__(self, y_pred: torch.Tensor, y_true: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(y_true, np.ndarray):\n        y_true = torch.from_numpy(y_true)\n    if isinstance(y_pred, np.ndarray):\n        y_pred = torch.from_numpy(y_pred)\n    y_true = y_true.float()\n    i_y_true = torch.argmax(y_true, dim=1)\n    i_y_pred_arg = torch.argsort(y_pred, dim=1)\n    i_z_i_list = []\n    for i in range(y_true.shape[0]):\n        if i_y_pred_arg[i, -1] != i_y_true[i]:\n            i_z_i_list.append(i_y_pred_arg[i, -1])\n        else:\n            i_z_i_list.append(i_y_pred_arg[i, -2])\n    i_z_i = torch.stack(i_z_i_list)\n    z_1 = y_pred[:, i_y_pred_arg[:, -1]]\n    z_3 = y_pred[:, i_y_pred_arg[:, -3]]\n    z_i = y_pred[:, i_z_i]\n    z_y = y_pred[:, i_y_true]\n    z_1 = torch.diagonal(z_1)\n    z_3 = torch.diagonal(z_3)\n    z_i = torch.diagonal(z_i)\n    z_y = torch.diagonal(z_y)\n    dlr = (-(z_y - z_i) / (z_1 - z_3)).float()\n    if self.reduction == 'mean':\n        return dlr.mean()\n    if self.reduction == 'sum':\n        return dlr.sum()\n    if self.reduction == 'none':\n        return dlr\n    raise NotImplementedError()",
            "def __call__(self, y_pred: torch.Tensor, y_true: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(y_true, np.ndarray):\n        y_true = torch.from_numpy(y_true)\n    if isinstance(y_pred, np.ndarray):\n        y_pred = torch.from_numpy(y_pred)\n    y_true = y_true.float()\n    i_y_true = torch.argmax(y_true, dim=1)\n    i_y_pred_arg = torch.argsort(y_pred, dim=1)\n    i_z_i_list = []\n    for i in range(y_true.shape[0]):\n        if i_y_pred_arg[i, -1] != i_y_true[i]:\n            i_z_i_list.append(i_y_pred_arg[i, -1])\n        else:\n            i_z_i_list.append(i_y_pred_arg[i, -2])\n    i_z_i = torch.stack(i_z_i_list)\n    z_1 = y_pred[:, i_y_pred_arg[:, -1]]\n    z_3 = y_pred[:, i_y_pred_arg[:, -3]]\n    z_i = y_pred[:, i_z_i]\n    z_y = y_pred[:, i_y_true]\n    z_1 = torch.diagonal(z_1)\n    z_3 = torch.diagonal(z_3)\n    z_i = torch.diagonal(z_i)\n    z_y = torch.diagonal(z_y)\n    dlr = (-(z_y - z_i) / (z_1 - z_3)).float()\n    if self.reduction == 'mean':\n        return dlr.mean()\n    if self.reduction == 'sum':\n        return dlr.sum()\n    if self.reduction == 'none':\n        return dlr\n    raise NotImplementedError()"
        ]
    },
    {
        "func_name": "forward",
        "original": "def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n                            Forward method.\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\n                            :param target: Target labels of shape (nb_samples, nb_classes).\n                            :return: Difference Logits Ratio Loss.\n                            \"\"\"\n    return self.__call__(y_true=target, y_pred=input)",
        "mutated": [
            "def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n    '\\n                            Forward method.\\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\\n                            :param target: Target labels of shape (nb_samples, nb_classes).\\n                            :return: Difference Logits Ratio Loss.\\n                            '\n    return self.__call__(y_true=target, y_pred=input)",
            "def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n                            Forward method.\\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\\n                            :param target: Target labels of shape (nb_samples, nb_classes).\\n                            :return: Difference Logits Ratio Loss.\\n                            '\n    return self.__call__(y_true=target, y_pred=input)",
            "def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n                            Forward method.\\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\\n                            :param target: Target labels of shape (nb_samples, nb_classes).\\n                            :return: Difference Logits Ratio Loss.\\n                            '\n    return self.__call__(y_true=target, y_pred=input)",
            "def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n                            Forward method.\\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\\n                            :param target: Target labels of shape (nb_samples, nb_classes).\\n                            :return: Difference Logits Ratio Loss.\\n                            '\n    return self.__call__(y_true=target, y_pred=input)",
            "def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n                            Forward method.\\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\\n                            :param target: Target labels of shape (nb_samples, nb_classes).\\n                            :return: Difference Logits Ratio Loss.\\n                            '\n    return self.__call__(y_true=target, y_pred=input)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, estimator: 'CLASSIFIER_LOSS_GRADIENTS_TYPE', norm: Union[int, float, str]=np.inf, eps: float=0.3, eps_step: float=0.1, max_iter: int=100, targeted: bool=False, nb_random_init: int=5, batch_size: int=32, loss_type: Optional[str]=None, verbose: bool=True):\n    \"\"\"\n        Create a :class:`.AutoConjugateGradient` instance.\n\n        :param estimator: An trained estimator.\n        :param norm: The norm of the adversarial perturbation. Possible values: \"inf\", np.inf, 1 or 2.\n        :param eps: Maximum perturbation that the attacker can introduce.\n        :param eps_step: Attack step size (input variation) at each iteration.\n        :param max_iter: The maximum number of iterations.\n        :param targeted: Indicates whether the attack is targeted (True) or untargeted (False).\n        :param nb_random_init: Number of random initialisations within the epsilon ball. For num_random_init=0\n            starting at the original input.\n        :param batch_size: Size of the batch on which adversarial samples are generated.\n        :param loss_type: Defines the loss to attack. Available options: None (Use loss defined by estimator),\n            \"cross_entropy\", or \"difference_logits_ratio\"\n        :param verbose: Show progress bars.\n        \"\"\"\n    from art.estimators.classification import TensorFlowClassifier, TensorFlowV2Classifier, PyTorchClassifier\n    if isinstance(estimator, TensorFlowClassifier):\n        raise ValueError('This attack does not support TensorFlow  v1.')\n    if loss_type not in self._predefined_losses:\n        raise ValueError(f'The argument loss_type has an invalid value. The following options for `loss_type` are currently supported: {self._predefined_losses}')\n    if loss_type is None:\n        if hasattr(estimator, 'predict') and is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=np.float32))):\n            raise ValueError('AutoProjectedGradientDescent is expecting logits as estimator output, the provided estimator seems to predict probabilities.')\n        estimator_acg = estimator\n    elif isinstance(estimator, TensorFlowV2Classifier):\n        import tensorflow as tf\n\n        class TensorFlowV2Loss:\n            \"\"\"abstract class of loss function of tensorflow v2\"\"\"\n\n            @abc.abstractmethod\n            def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                raise NotImplementedError\n        if loss_type == 'cross_entropy':\n\n            class CrossEntropyLossV2(TensorFlowV2Loss):\n                \"\"\"Class defining cross entropy loss with reduction options.\"\"\"\n\n                def __init__(self, from_logits, reduction='sum'):\n                    self.ce_loss = tf.keras.losses.CategoricalCrossentropy(from_logits=from_logits, reduction=tf.keras.losses.Reduction.NONE)\n                    self.reduction = reduction\n\n                def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                    if self.reduction == 'mean':\n                        return tf.reduce_mean(self.ce_loss(y_true, y_pred))\n                    if self.reduction == 'sum':\n                        return tf.reduce_sum(self.ce_loss(y_true, y_pred))\n                    if self.reduction == 'none':\n                        return self.ce_loss(y_true, y_pred)\n                    raise NotImplementedError()\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape)))):\n                _loss_object_tf: TensorFlowV2Loss = CrossEntropyLossV2(from_logits=False)\n            else:\n                _loss_object_tf = CrossEntropyLossV2(from_logits=True)\n        elif loss_type == 'difference_logits_ratio':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape)))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='difference_logits_ratio' the estimator has to to predict logits.\")\n\n            class DifferenceLogitsRatioTensorFlowV2(TensorFlowV2Loss):\n                \"\"\"\n                        Callable class for Difference Logits Ratio loss in TensorFlow v2.\n                        \"\"\"\n\n                def __init__(self):\n                    self.reduction = 'sum'\n\n                def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                    i_y_true = tf.cast(tf.math.argmax(tf.cast(y_true, tf.int32), axis=1), tf.int32)\n                    i_y_pred_arg = tf.argsort(y_pred, axis=1)\n                    i_z_i_list = []\n                    for i in range(y_true.shape[0]):\n                        if i_y_pred_arg[i, -1] != i_y_true[i]:\n                            i_z_i_list.append(i_y_pred_arg[i, -1])\n                        else:\n                            i_z_i_list.append(i_y_pred_arg[i, -2])\n                    i_z_i = tf.stack(i_z_i_list)\n                    z_1 = tf.gather(y_pred, i_y_pred_arg[:, -1], axis=1, batch_dims=0)\n                    z_3 = tf.gather(y_pred, i_y_pred_arg[:, -3], axis=1, batch_dims=0)\n                    z_i = tf.gather(y_pred, i_z_i, axis=1, batch_dims=0)\n                    z_y = tf.gather(y_pred, i_y_true, axis=1, batch_dims=0)\n                    z_1 = tf.linalg.diag_part(z_1)\n                    z_3 = tf.linalg.diag_part(z_3)\n                    z_i = tf.linalg.diag_part(z_i)\n                    z_y = tf.linalg.diag_part(z_y)\n                    dlr = -(z_y - z_i) / (z_1 - z_3)\n                    if self.reduction == 'mean':\n                        return tf.reduce_mean(dlr)\n                    if self.reduction == 'sum':\n                        return tf.reduce_sum(dlr)\n                    if self.reduction == 'none':\n                        return dlr\n                    raise NotImplementedError()\n            _loss_object_tf = DifferenceLogitsRatioTensorFlowV2()\n        estimator_acg = TensorFlowV2Classifier(model=estimator.model, nb_classes=estimator.nb_classes, input_shape=estimator.input_shape, loss_object=_loss_object_tf, optimizer=estimator.optimizer, train_step=estimator.train_step, channels_first=estimator.channels_first, clip_values=estimator.clip_values, preprocessing_defences=estimator.preprocessing_defences, postprocessing_defences=estimator.postprocessing_defences, preprocessing=estimator.preprocessing)\n    elif isinstance(estimator, PyTorchClassifier):\n        import torch\n        if loss_type == 'cross_entropy':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=np.float32))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='cross_entropy' the estimator has to to predict logits.\")\n\n            class CrossEntropyLossTorch(torch.nn.modules.loss._Loss):\n                \"\"\"Class defining cross entropy loss with reduction options.\"\"\"\n\n                def __init__(self, reduction='sum'):\n                    super().__init__()\n                    self.ce_loss = torch.nn.CrossEntropyLoss(reduction='none')\n                    self.reduction = reduction\n\n                def __call__(self, y_true: torch.Tensor, y_pred: torch.Tensor, *args, **kwargs) -> torch.Tensor:\n                    if self.reduction == 'mean':\n                        return self.ce_loss(y_true, y_pred).mean()\n                    if self.reduction == 'sum':\n                        return self.ce_loss(y_true, y_pred).sum()\n                    if self.reduction == 'none':\n                        return self.ce_loss(y_true, y_pred)\n                    raise NotImplementedError()\n\n                def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n                    \"\"\"\n                            Forward method.\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\n                            :param target: Target labels of shape (nb_samples, nb_classes).\n                            :return: Difference Logits Ratio Loss.\n                            \"\"\"\n                    return self.__call__(y_true=target, y_pred=input)\n            _loss_object_pt: torch.nn.modules.loss._Loss = CrossEntropyLossTorch(reduction='mean')\n        elif loss_type == 'difference_logits_ratio':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=ART_NUMPY_DTYPE))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='difference_logits_ratio' the estimator has to to predict logits.\")\n\n            class DifferenceLogitsRatioPyTorch(torch.nn.modules.loss._Loss):\n                \"\"\"\n                        Callable class for Difference Logits Ratio loss in PyTorch.\n                        \"\"\"\n\n                def __init__(self):\n                    super().__init__()\n                    self.reduction = 'sum'\n\n                def __call__(self, y_pred: torch.Tensor, y_true: torch.Tensor) -> torch.Tensor:\n                    if isinstance(y_true, np.ndarray):\n                        y_true = torch.from_numpy(y_true)\n                    if isinstance(y_pred, np.ndarray):\n                        y_pred = torch.from_numpy(y_pred)\n                    y_true = y_true.float()\n                    i_y_true = torch.argmax(y_true, dim=1)\n                    i_y_pred_arg = torch.argsort(y_pred, dim=1)\n                    i_z_i_list = []\n                    for i in range(y_true.shape[0]):\n                        if i_y_pred_arg[i, -1] != i_y_true[i]:\n                            i_z_i_list.append(i_y_pred_arg[i, -1])\n                        else:\n                            i_z_i_list.append(i_y_pred_arg[i, -2])\n                    i_z_i = torch.stack(i_z_i_list)\n                    z_1 = y_pred[:, i_y_pred_arg[:, -1]]\n                    z_3 = y_pred[:, i_y_pred_arg[:, -3]]\n                    z_i = y_pred[:, i_z_i]\n                    z_y = y_pred[:, i_y_true]\n                    z_1 = torch.diagonal(z_1)\n                    z_3 = torch.diagonal(z_3)\n                    z_i = torch.diagonal(z_i)\n                    z_y = torch.diagonal(z_y)\n                    dlr = (-(z_y - z_i) / (z_1 - z_3)).float()\n                    if self.reduction == 'mean':\n                        return dlr.mean()\n                    if self.reduction == 'sum':\n                        return dlr.sum()\n                    if self.reduction == 'none':\n                        return dlr\n                    raise NotImplementedError()\n\n                def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n                    \"\"\"\n                            Forward method.\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\n                            :param target: Target labels of shape (nb_samples, nb_classes).\n                            :return: Difference Logits Ratio Loss.\n                            \"\"\"\n                    return self.__call__(y_true=target, y_pred=input)\n            _loss_object_pt = DifferenceLogitsRatioPyTorch()\n        else:\n            raise NotImplementedError()\n        estimator_acg = PyTorchClassifier(model=estimator.model, loss=_loss_object_pt, input_shape=estimator.input_shape, nb_classes=estimator.nb_classes, optimizer=None, channels_first=estimator.channels_first, clip_values=estimator.clip_values, preprocessing_defences=estimator.preprocessing_defences, postprocessing_defences=estimator.postprocessing_defences, preprocessing=estimator.preprocessing, device_type=str(estimator._device))\n    else:\n        raise ValueError(f'The loss type {loss_type} is not supported for the provided estimator.')\n    super().__init__(estimator=estimator_acg)\n    self.norm = norm\n    self.eps = eps\n    self.eps_step = eps_step\n    self.max_iter = max_iter\n    self.targeted = targeted\n    self.nb_random_init = nb_random_init\n    self.batch_size = batch_size\n    self.loss_type = loss_type\n    self.verbose = verbose\n    self._check_params()",
        "mutated": [
            "def __init__(self, estimator: 'CLASSIFIER_LOSS_GRADIENTS_TYPE', norm: Union[int, float, str]=np.inf, eps: float=0.3, eps_step: float=0.1, max_iter: int=100, targeted: bool=False, nb_random_init: int=5, batch_size: int=32, loss_type: Optional[str]=None, verbose: bool=True):\n    if False:\n        i = 10\n    '\\n        Create a :class:`.AutoConjugateGradient` instance.\\n\\n        :param estimator: An trained estimator.\\n        :param norm: The norm of the adversarial perturbation. Possible values: \"inf\", np.inf, 1 or 2.\\n        :param eps: Maximum perturbation that the attacker can introduce.\\n        :param eps_step: Attack step size (input variation) at each iteration.\\n        :param max_iter: The maximum number of iterations.\\n        :param targeted: Indicates whether the attack is targeted (True) or untargeted (False).\\n        :param nb_random_init: Number of random initialisations within the epsilon ball. For num_random_init=0\\n            starting at the original input.\\n        :param batch_size: Size of the batch on which adversarial samples are generated.\\n        :param loss_type: Defines the loss to attack. Available options: None (Use loss defined by estimator),\\n            \"cross_entropy\", or \"difference_logits_ratio\"\\n        :param verbose: Show progress bars.\\n        '\n    from art.estimators.classification import TensorFlowClassifier, TensorFlowV2Classifier, PyTorchClassifier\n    if isinstance(estimator, TensorFlowClassifier):\n        raise ValueError('This attack does not support TensorFlow  v1.')\n    if loss_type not in self._predefined_losses:\n        raise ValueError(f'The argument loss_type has an invalid value. The following options for `loss_type` are currently supported: {self._predefined_losses}')\n    if loss_type is None:\n        if hasattr(estimator, 'predict') and is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=np.float32))):\n            raise ValueError('AutoProjectedGradientDescent is expecting logits as estimator output, the provided estimator seems to predict probabilities.')\n        estimator_acg = estimator\n    elif isinstance(estimator, TensorFlowV2Classifier):\n        import tensorflow as tf\n\n        class TensorFlowV2Loss:\n            \"\"\"abstract class of loss function of tensorflow v2\"\"\"\n\n            @abc.abstractmethod\n            def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                raise NotImplementedError\n        if loss_type == 'cross_entropy':\n\n            class CrossEntropyLossV2(TensorFlowV2Loss):\n                \"\"\"Class defining cross entropy loss with reduction options.\"\"\"\n\n                def __init__(self, from_logits, reduction='sum'):\n                    self.ce_loss = tf.keras.losses.CategoricalCrossentropy(from_logits=from_logits, reduction=tf.keras.losses.Reduction.NONE)\n                    self.reduction = reduction\n\n                def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                    if self.reduction == 'mean':\n                        return tf.reduce_mean(self.ce_loss(y_true, y_pred))\n                    if self.reduction == 'sum':\n                        return tf.reduce_sum(self.ce_loss(y_true, y_pred))\n                    if self.reduction == 'none':\n                        return self.ce_loss(y_true, y_pred)\n                    raise NotImplementedError()\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape)))):\n                _loss_object_tf: TensorFlowV2Loss = CrossEntropyLossV2(from_logits=False)\n            else:\n                _loss_object_tf = CrossEntropyLossV2(from_logits=True)\n        elif loss_type == 'difference_logits_ratio':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape)))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='difference_logits_ratio' the estimator has to to predict logits.\")\n\n            class DifferenceLogitsRatioTensorFlowV2(TensorFlowV2Loss):\n                \"\"\"\n                        Callable class for Difference Logits Ratio loss in TensorFlow v2.\n                        \"\"\"\n\n                def __init__(self):\n                    self.reduction = 'sum'\n\n                def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                    i_y_true = tf.cast(tf.math.argmax(tf.cast(y_true, tf.int32), axis=1), tf.int32)\n                    i_y_pred_arg = tf.argsort(y_pred, axis=1)\n                    i_z_i_list = []\n                    for i in range(y_true.shape[0]):\n                        if i_y_pred_arg[i, -1] != i_y_true[i]:\n                            i_z_i_list.append(i_y_pred_arg[i, -1])\n                        else:\n                            i_z_i_list.append(i_y_pred_arg[i, -2])\n                    i_z_i = tf.stack(i_z_i_list)\n                    z_1 = tf.gather(y_pred, i_y_pred_arg[:, -1], axis=1, batch_dims=0)\n                    z_3 = tf.gather(y_pred, i_y_pred_arg[:, -3], axis=1, batch_dims=0)\n                    z_i = tf.gather(y_pred, i_z_i, axis=1, batch_dims=0)\n                    z_y = tf.gather(y_pred, i_y_true, axis=1, batch_dims=0)\n                    z_1 = tf.linalg.diag_part(z_1)\n                    z_3 = tf.linalg.diag_part(z_3)\n                    z_i = tf.linalg.diag_part(z_i)\n                    z_y = tf.linalg.diag_part(z_y)\n                    dlr = -(z_y - z_i) / (z_1 - z_3)\n                    if self.reduction == 'mean':\n                        return tf.reduce_mean(dlr)\n                    if self.reduction == 'sum':\n                        return tf.reduce_sum(dlr)\n                    if self.reduction == 'none':\n                        return dlr\n                    raise NotImplementedError()\n            _loss_object_tf = DifferenceLogitsRatioTensorFlowV2()\n        estimator_acg = TensorFlowV2Classifier(model=estimator.model, nb_classes=estimator.nb_classes, input_shape=estimator.input_shape, loss_object=_loss_object_tf, optimizer=estimator.optimizer, train_step=estimator.train_step, channels_first=estimator.channels_first, clip_values=estimator.clip_values, preprocessing_defences=estimator.preprocessing_defences, postprocessing_defences=estimator.postprocessing_defences, preprocessing=estimator.preprocessing)\n    elif isinstance(estimator, PyTorchClassifier):\n        import torch\n        if loss_type == 'cross_entropy':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=np.float32))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='cross_entropy' the estimator has to to predict logits.\")\n\n            class CrossEntropyLossTorch(torch.nn.modules.loss._Loss):\n                \"\"\"Class defining cross entropy loss with reduction options.\"\"\"\n\n                def __init__(self, reduction='sum'):\n                    super().__init__()\n                    self.ce_loss = torch.nn.CrossEntropyLoss(reduction='none')\n                    self.reduction = reduction\n\n                def __call__(self, y_true: torch.Tensor, y_pred: torch.Tensor, *args, **kwargs) -> torch.Tensor:\n                    if self.reduction == 'mean':\n                        return self.ce_loss(y_true, y_pred).mean()\n                    if self.reduction == 'sum':\n                        return self.ce_loss(y_true, y_pred).sum()\n                    if self.reduction == 'none':\n                        return self.ce_loss(y_true, y_pred)\n                    raise NotImplementedError()\n\n                def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n                    \"\"\"\n                            Forward method.\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\n                            :param target: Target labels of shape (nb_samples, nb_classes).\n                            :return: Difference Logits Ratio Loss.\n                            \"\"\"\n                    return self.__call__(y_true=target, y_pred=input)\n            _loss_object_pt: torch.nn.modules.loss._Loss = CrossEntropyLossTorch(reduction='mean')\n        elif loss_type == 'difference_logits_ratio':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=ART_NUMPY_DTYPE))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='difference_logits_ratio' the estimator has to to predict logits.\")\n\n            class DifferenceLogitsRatioPyTorch(torch.nn.modules.loss._Loss):\n                \"\"\"\n                        Callable class for Difference Logits Ratio loss in PyTorch.\n                        \"\"\"\n\n                def __init__(self):\n                    super().__init__()\n                    self.reduction = 'sum'\n\n                def __call__(self, y_pred: torch.Tensor, y_true: torch.Tensor) -> torch.Tensor:\n                    if isinstance(y_true, np.ndarray):\n                        y_true = torch.from_numpy(y_true)\n                    if isinstance(y_pred, np.ndarray):\n                        y_pred = torch.from_numpy(y_pred)\n                    y_true = y_true.float()\n                    i_y_true = torch.argmax(y_true, dim=1)\n                    i_y_pred_arg = torch.argsort(y_pred, dim=1)\n                    i_z_i_list = []\n                    for i in range(y_true.shape[0]):\n                        if i_y_pred_arg[i, -1] != i_y_true[i]:\n                            i_z_i_list.append(i_y_pred_arg[i, -1])\n                        else:\n                            i_z_i_list.append(i_y_pred_arg[i, -2])\n                    i_z_i = torch.stack(i_z_i_list)\n                    z_1 = y_pred[:, i_y_pred_arg[:, -1]]\n                    z_3 = y_pred[:, i_y_pred_arg[:, -3]]\n                    z_i = y_pred[:, i_z_i]\n                    z_y = y_pred[:, i_y_true]\n                    z_1 = torch.diagonal(z_1)\n                    z_3 = torch.diagonal(z_3)\n                    z_i = torch.diagonal(z_i)\n                    z_y = torch.diagonal(z_y)\n                    dlr = (-(z_y - z_i) / (z_1 - z_3)).float()\n                    if self.reduction == 'mean':\n                        return dlr.mean()\n                    if self.reduction == 'sum':\n                        return dlr.sum()\n                    if self.reduction == 'none':\n                        return dlr\n                    raise NotImplementedError()\n\n                def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n                    \"\"\"\n                            Forward method.\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\n                            :param target: Target labels of shape (nb_samples, nb_classes).\n                            :return: Difference Logits Ratio Loss.\n                            \"\"\"\n                    return self.__call__(y_true=target, y_pred=input)\n            _loss_object_pt = DifferenceLogitsRatioPyTorch()\n        else:\n            raise NotImplementedError()\n        estimator_acg = PyTorchClassifier(model=estimator.model, loss=_loss_object_pt, input_shape=estimator.input_shape, nb_classes=estimator.nb_classes, optimizer=None, channels_first=estimator.channels_first, clip_values=estimator.clip_values, preprocessing_defences=estimator.preprocessing_defences, postprocessing_defences=estimator.postprocessing_defences, preprocessing=estimator.preprocessing, device_type=str(estimator._device))\n    else:\n        raise ValueError(f'The loss type {loss_type} is not supported for the provided estimator.')\n    super().__init__(estimator=estimator_acg)\n    self.norm = norm\n    self.eps = eps\n    self.eps_step = eps_step\n    self.max_iter = max_iter\n    self.targeted = targeted\n    self.nb_random_init = nb_random_init\n    self.batch_size = batch_size\n    self.loss_type = loss_type\n    self.verbose = verbose\n    self._check_params()",
            "def __init__(self, estimator: 'CLASSIFIER_LOSS_GRADIENTS_TYPE', norm: Union[int, float, str]=np.inf, eps: float=0.3, eps_step: float=0.1, max_iter: int=100, targeted: bool=False, nb_random_init: int=5, batch_size: int=32, loss_type: Optional[str]=None, verbose: bool=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Create a :class:`.AutoConjugateGradient` instance.\\n\\n        :param estimator: An trained estimator.\\n        :param norm: The norm of the adversarial perturbation. Possible values: \"inf\", np.inf, 1 or 2.\\n        :param eps: Maximum perturbation that the attacker can introduce.\\n        :param eps_step: Attack step size (input variation) at each iteration.\\n        :param max_iter: The maximum number of iterations.\\n        :param targeted: Indicates whether the attack is targeted (True) or untargeted (False).\\n        :param nb_random_init: Number of random initialisations within the epsilon ball. For num_random_init=0\\n            starting at the original input.\\n        :param batch_size: Size of the batch on which adversarial samples are generated.\\n        :param loss_type: Defines the loss to attack. Available options: None (Use loss defined by estimator),\\n            \"cross_entropy\", or \"difference_logits_ratio\"\\n        :param verbose: Show progress bars.\\n        '\n    from art.estimators.classification import TensorFlowClassifier, TensorFlowV2Classifier, PyTorchClassifier\n    if isinstance(estimator, TensorFlowClassifier):\n        raise ValueError('This attack does not support TensorFlow  v1.')\n    if loss_type not in self._predefined_losses:\n        raise ValueError(f'The argument loss_type has an invalid value. The following options for `loss_type` are currently supported: {self._predefined_losses}')\n    if loss_type is None:\n        if hasattr(estimator, 'predict') and is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=np.float32))):\n            raise ValueError('AutoProjectedGradientDescent is expecting logits as estimator output, the provided estimator seems to predict probabilities.')\n        estimator_acg = estimator\n    elif isinstance(estimator, TensorFlowV2Classifier):\n        import tensorflow as tf\n\n        class TensorFlowV2Loss:\n            \"\"\"abstract class of loss function of tensorflow v2\"\"\"\n\n            @abc.abstractmethod\n            def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                raise NotImplementedError\n        if loss_type == 'cross_entropy':\n\n            class CrossEntropyLossV2(TensorFlowV2Loss):\n                \"\"\"Class defining cross entropy loss with reduction options.\"\"\"\n\n                def __init__(self, from_logits, reduction='sum'):\n                    self.ce_loss = tf.keras.losses.CategoricalCrossentropy(from_logits=from_logits, reduction=tf.keras.losses.Reduction.NONE)\n                    self.reduction = reduction\n\n                def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                    if self.reduction == 'mean':\n                        return tf.reduce_mean(self.ce_loss(y_true, y_pred))\n                    if self.reduction == 'sum':\n                        return tf.reduce_sum(self.ce_loss(y_true, y_pred))\n                    if self.reduction == 'none':\n                        return self.ce_loss(y_true, y_pred)\n                    raise NotImplementedError()\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape)))):\n                _loss_object_tf: TensorFlowV2Loss = CrossEntropyLossV2(from_logits=False)\n            else:\n                _loss_object_tf = CrossEntropyLossV2(from_logits=True)\n        elif loss_type == 'difference_logits_ratio':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape)))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='difference_logits_ratio' the estimator has to to predict logits.\")\n\n            class DifferenceLogitsRatioTensorFlowV2(TensorFlowV2Loss):\n                \"\"\"\n                        Callable class for Difference Logits Ratio loss in TensorFlow v2.\n                        \"\"\"\n\n                def __init__(self):\n                    self.reduction = 'sum'\n\n                def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                    i_y_true = tf.cast(tf.math.argmax(tf.cast(y_true, tf.int32), axis=1), tf.int32)\n                    i_y_pred_arg = tf.argsort(y_pred, axis=1)\n                    i_z_i_list = []\n                    for i in range(y_true.shape[0]):\n                        if i_y_pred_arg[i, -1] != i_y_true[i]:\n                            i_z_i_list.append(i_y_pred_arg[i, -1])\n                        else:\n                            i_z_i_list.append(i_y_pred_arg[i, -2])\n                    i_z_i = tf.stack(i_z_i_list)\n                    z_1 = tf.gather(y_pred, i_y_pred_arg[:, -1], axis=1, batch_dims=0)\n                    z_3 = tf.gather(y_pred, i_y_pred_arg[:, -3], axis=1, batch_dims=0)\n                    z_i = tf.gather(y_pred, i_z_i, axis=1, batch_dims=0)\n                    z_y = tf.gather(y_pred, i_y_true, axis=1, batch_dims=0)\n                    z_1 = tf.linalg.diag_part(z_1)\n                    z_3 = tf.linalg.diag_part(z_3)\n                    z_i = tf.linalg.diag_part(z_i)\n                    z_y = tf.linalg.diag_part(z_y)\n                    dlr = -(z_y - z_i) / (z_1 - z_3)\n                    if self.reduction == 'mean':\n                        return tf.reduce_mean(dlr)\n                    if self.reduction == 'sum':\n                        return tf.reduce_sum(dlr)\n                    if self.reduction == 'none':\n                        return dlr\n                    raise NotImplementedError()\n            _loss_object_tf = DifferenceLogitsRatioTensorFlowV2()\n        estimator_acg = TensorFlowV2Classifier(model=estimator.model, nb_classes=estimator.nb_classes, input_shape=estimator.input_shape, loss_object=_loss_object_tf, optimizer=estimator.optimizer, train_step=estimator.train_step, channels_first=estimator.channels_first, clip_values=estimator.clip_values, preprocessing_defences=estimator.preprocessing_defences, postprocessing_defences=estimator.postprocessing_defences, preprocessing=estimator.preprocessing)\n    elif isinstance(estimator, PyTorchClassifier):\n        import torch\n        if loss_type == 'cross_entropy':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=np.float32))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='cross_entropy' the estimator has to to predict logits.\")\n\n            class CrossEntropyLossTorch(torch.nn.modules.loss._Loss):\n                \"\"\"Class defining cross entropy loss with reduction options.\"\"\"\n\n                def __init__(self, reduction='sum'):\n                    super().__init__()\n                    self.ce_loss = torch.nn.CrossEntropyLoss(reduction='none')\n                    self.reduction = reduction\n\n                def __call__(self, y_true: torch.Tensor, y_pred: torch.Tensor, *args, **kwargs) -> torch.Tensor:\n                    if self.reduction == 'mean':\n                        return self.ce_loss(y_true, y_pred).mean()\n                    if self.reduction == 'sum':\n                        return self.ce_loss(y_true, y_pred).sum()\n                    if self.reduction == 'none':\n                        return self.ce_loss(y_true, y_pred)\n                    raise NotImplementedError()\n\n                def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n                    \"\"\"\n                            Forward method.\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\n                            :param target: Target labels of shape (nb_samples, nb_classes).\n                            :return: Difference Logits Ratio Loss.\n                            \"\"\"\n                    return self.__call__(y_true=target, y_pred=input)\n            _loss_object_pt: torch.nn.modules.loss._Loss = CrossEntropyLossTorch(reduction='mean')\n        elif loss_type == 'difference_logits_ratio':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=ART_NUMPY_DTYPE))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='difference_logits_ratio' the estimator has to to predict logits.\")\n\n            class DifferenceLogitsRatioPyTorch(torch.nn.modules.loss._Loss):\n                \"\"\"\n                        Callable class for Difference Logits Ratio loss in PyTorch.\n                        \"\"\"\n\n                def __init__(self):\n                    super().__init__()\n                    self.reduction = 'sum'\n\n                def __call__(self, y_pred: torch.Tensor, y_true: torch.Tensor) -> torch.Tensor:\n                    if isinstance(y_true, np.ndarray):\n                        y_true = torch.from_numpy(y_true)\n                    if isinstance(y_pred, np.ndarray):\n                        y_pred = torch.from_numpy(y_pred)\n                    y_true = y_true.float()\n                    i_y_true = torch.argmax(y_true, dim=1)\n                    i_y_pred_arg = torch.argsort(y_pred, dim=1)\n                    i_z_i_list = []\n                    for i in range(y_true.shape[0]):\n                        if i_y_pred_arg[i, -1] != i_y_true[i]:\n                            i_z_i_list.append(i_y_pred_arg[i, -1])\n                        else:\n                            i_z_i_list.append(i_y_pred_arg[i, -2])\n                    i_z_i = torch.stack(i_z_i_list)\n                    z_1 = y_pred[:, i_y_pred_arg[:, -1]]\n                    z_3 = y_pred[:, i_y_pred_arg[:, -3]]\n                    z_i = y_pred[:, i_z_i]\n                    z_y = y_pred[:, i_y_true]\n                    z_1 = torch.diagonal(z_1)\n                    z_3 = torch.diagonal(z_3)\n                    z_i = torch.diagonal(z_i)\n                    z_y = torch.diagonal(z_y)\n                    dlr = (-(z_y - z_i) / (z_1 - z_3)).float()\n                    if self.reduction == 'mean':\n                        return dlr.mean()\n                    if self.reduction == 'sum':\n                        return dlr.sum()\n                    if self.reduction == 'none':\n                        return dlr\n                    raise NotImplementedError()\n\n                def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n                    \"\"\"\n                            Forward method.\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\n                            :param target: Target labels of shape (nb_samples, nb_classes).\n                            :return: Difference Logits Ratio Loss.\n                            \"\"\"\n                    return self.__call__(y_true=target, y_pred=input)\n            _loss_object_pt = DifferenceLogitsRatioPyTorch()\n        else:\n            raise NotImplementedError()\n        estimator_acg = PyTorchClassifier(model=estimator.model, loss=_loss_object_pt, input_shape=estimator.input_shape, nb_classes=estimator.nb_classes, optimizer=None, channels_first=estimator.channels_first, clip_values=estimator.clip_values, preprocessing_defences=estimator.preprocessing_defences, postprocessing_defences=estimator.postprocessing_defences, preprocessing=estimator.preprocessing, device_type=str(estimator._device))\n    else:\n        raise ValueError(f'The loss type {loss_type} is not supported for the provided estimator.')\n    super().__init__(estimator=estimator_acg)\n    self.norm = norm\n    self.eps = eps\n    self.eps_step = eps_step\n    self.max_iter = max_iter\n    self.targeted = targeted\n    self.nb_random_init = nb_random_init\n    self.batch_size = batch_size\n    self.loss_type = loss_type\n    self.verbose = verbose\n    self._check_params()",
            "def __init__(self, estimator: 'CLASSIFIER_LOSS_GRADIENTS_TYPE', norm: Union[int, float, str]=np.inf, eps: float=0.3, eps_step: float=0.1, max_iter: int=100, targeted: bool=False, nb_random_init: int=5, batch_size: int=32, loss_type: Optional[str]=None, verbose: bool=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Create a :class:`.AutoConjugateGradient` instance.\\n\\n        :param estimator: An trained estimator.\\n        :param norm: The norm of the adversarial perturbation. Possible values: \"inf\", np.inf, 1 or 2.\\n        :param eps: Maximum perturbation that the attacker can introduce.\\n        :param eps_step: Attack step size (input variation) at each iteration.\\n        :param max_iter: The maximum number of iterations.\\n        :param targeted: Indicates whether the attack is targeted (True) or untargeted (False).\\n        :param nb_random_init: Number of random initialisations within the epsilon ball. For num_random_init=0\\n            starting at the original input.\\n        :param batch_size: Size of the batch on which adversarial samples are generated.\\n        :param loss_type: Defines the loss to attack. Available options: None (Use loss defined by estimator),\\n            \"cross_entropy\", or \"difference_logits_ratio\"\\n        :param verbose: Show progress bars.\\n        '\n    from art.estimators.classification import TensorFlowClassifier, TensorFlowV2Classifier, PyTorchClassifier\n    if isinstance(estimator, TensorFlowClassifier):\n        raise ValueError('This attack does not support TensorFlow  v1.')\n    if loss_type not in self._predefined_losses:\n        raise ValueError(f'The argument loss_type has an invalid value. The following options for `loss_type` are currently supported: {self._predefined_losses}')\n    if loss_type is None:\n        if hasattr(estimator, 'predict') and is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=np.float32))):\n            raise ValueError('AutoProjectedGradientDescent is expecting logits as estimator output, the provided estimator seems to predict probabilities.')\n        estimator_acg = estimator\n    elif isinstance(estimator, TensorFlowV2Classifier):\n        import tensorflow as tf\n\n        class TensorFlowV2Loss:\n            \"\"\"abstract class of loss function of tensorflow v2\"\"\"\n\n            @abc.abstractmethod\n            def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                raise NotImplementedError\n        if loss_type == 'cross_entropy':\n\n            class CrossEntropyLossV2(TensorFlowV2Loss):\n                \"\"\"Class defining cross entropy loss with reduction options.\"\"\"\n\n                def __init__(self, from_logits, reduction='sum'):\n                    self.ce_loss = tf.keras.losses.CategoricalCrossentropy(from_logits=from_logits, reduction=tf.keras.losses.Reduction.NONE)\n                    self.reduction = reduction\n\n                def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                    if self.reduction == 'mean':\n                        return tf.reduce_mean(self.ce_loss(y_true, y_pred))\n                    if self.reduction == 'sum':\n                        return tf.reduce_sum(self.ce_loss(y_true, y_pred))\n                    if self.reduction == 'none':\n                        return self.ce_loss(y_true, y_pred)\n                    raise NotImplementedError()\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape)))):\n                _loss_object_tf: TensorFlowV2Loss = CrossEntropyLossV2(from_logits=False)\n            else:\n                _loss_object_tf = CrossEntropyLossV2(from_logits=True)\n        elif loss_type == 'difference_logits_ratio':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape)))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='difference_logits_ratio' the estimator has to to predict logits.\")\n\n            class DifferenceLogitsRatioTensorFlowV2(TensorFlowV2Loss):\n                \"\"\"\n                        Callable class for Difference Logits Ratio loss in TensorFlow v2.\n                        \"\"\"\n\n                def __init__(self):\n                    self.reduction = 'sum'\n\n                def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                    i_y_true = tf.cast(tf.math.argmax(tf.cast(y_true, tf.int32), axis=1), tf.int32)\n                    i_y_pred_arg = tf.argsort(y_pred, axis=1)\n                    i_z_i_list = []\n                    for i in range(y_true.shape[0]):\n                        if i_y_pred_arg[i, -1] != i_y_true[i]:\n                            i_z_i_list.append(i_y_pred_arg[i, -1])\n                        else:\n                            i_z_i_list.append(i_y_pred_arg[i, -2])\n                    i_z_i = tf.stack(i_z_i_list)\n                    z_1 = tf.gather(y_pred, i_y_pred_arg[:, -1], axis=1, batch_dims=0)\n                    z_3 = tf.gather(y_pred, i_y_pred_arg[:, -3], axis=1, batch_dims=0)\n                    z_i = tf.gather(y_pred, i_z_i, axis=1, batch_dims=0)\n                    z_y = tf.gather(y_pred, i_y_true, axis=1, batch_dims=0)\n                    z_1 = tf.linalg.diag_part(z_1)\n                    z_3 = tf.linalg.diag_part(z_3)\n                    z_i = tf.linalg.diag_part(z_i)\n                    z_y = tf.linalg.diag_part(z_y)\n                    dlr = -(z_y - z_i) / (z_1 - z_3)\n                    if self.reduction == 'mean':\n                        return tf.reduce_mean(dlr)\n                    if self.reduction == 'sum':\n                        return tf.reduce_sum(dlr)\n                    if self.reduction == 'none':\n                        return dlr\n                    raise NotImplementedError()\n            _loss_object_tf = DifferenceLogitsRatioTensorFlowV2()\n        estimator_acg = TensorFlowV2Classifier(model=estimator.model, nb_classes=estimator.nb_classes, input_shape=estimator.input_shape, loss_object=_loss_object_tf, optimizer=estimator.optimizer, train_step=estimator.train_step, channels_first=estimator.channels_first, clip_values=estimator.clip_values, preprocessing_defences=estimator.preprocessing_defences, postprocessing_defences=estimator.postprocessing_defences, preprocessing=estimator.preprocessing)\n    elif isinstance(estimator, PyTorchClassifier):\n        import torch\n        if loss_type == 'cross_entropy':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=np.float32))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='cross_entropy' the estimator has to to predict logits.\")\n\n            class CrossEntropyLossTorch(torch.nn.modules.loss._Loss):\n                \"\"\"Class defining cross entropy loss with reduction options.\"\"\"\n\n                def __init__(self, reduction='sum'):\n                    super().__init__()\n                    self.ce_loss = torch.nn.CrossEntropyLoss(reduction='none')\n                    self.reduction = reduction\n\n                def __call__(self, y_true: torch.Tensor, y_pred: torch.Tensor, *args, **kwargs) -> torch.Tensor:\n                    if self.reduction == 'mean':\n                        return self.ce_loss(y_true, y_pred).mean()\n                    if self.reduction == 'sum':\n                        return self.ce_loss(y_true, y_pred).sum()\n                    if self.reduction == 'none':\n                        return self.ce_loss(y_true, y_pred)\n                    raise NotImplementedError()\n\n                def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n                    \"\"\"\n                            Forward method.\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\n                            :param target: Target labels of shape (nb_samples, nb_classes).\n                            :return: Difference Logits Ratio Loss.\n                            \"\"\"\n                    return self.__call__(y_true=target, y_pred=input)\n            _loss_object_pt: torch.nn.modules.loss._Loss = CrossEntropyLossTorch(reduction='mean')\n        elif loss_type == 'difference_logits_ratio':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=ART_NUMPY_DTYPE))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='difference_logits_ratio' the estimator has to to predict logits.\")\n\n            class DifferenceLogitsRatioPyTorch(torch.nn.modules.loss._Loss):\n                \"\"\"\n                        Callable class for Difference Logits Ratio loss in PyTorch.\n                        \"\"\"\n\n                def __init__(self):\n                    super().__init__()\n                    self.reduction = 'sum'\n\n                def __call__(self, y_pred: torch.Tensor, y_true: torch.Tensor) -> torch.Tensor:\n                    if isinstance(y_true, np.ndarray):\n                        y_true = torch.from_numpy(y_true)\n                    if isinstance(y_pred, np.ndarray):\n                        y_pred = torch.from_numpy(y_pred)\n                    y_true = y_true.float()\n                    i_y_true = torch.argmax(y_true, dim=1)\n                    i_y_pred_arg = torch.argsort(y_pred, dim=1)\n                    i_z_i_list = []\n                    for i in range(y_true.shape[0]):\n                        if i_y_pred_arg[i, -1] != i_y_true[i]:\n                            i_z_i_list.append(i_y_pred_arg[i, -1])\n                        else:\n                            i_z_i_list.append(i_y_pred_arg[i, -2])\n                    i_z_i = torch.stack(i_z_i_list)\n                    z_1 = y_pred[:, i_y_pred_arg[:, -1]]\n                    z_3 = y_pred[:, i_y_pred_arg[:, -3]]\n                    z_i = y_pred[:, i_z_i]\n                    z_y = y_pred[:, i_y_true]\n                    z_1 = torch.diagonal(z_1)\n                    z_3 = torch.diagonal(z_3)\n                    z_i = torch.diagonal(z_i)\n                    z_y = torch.diagonal(z_y)\n                    dlr = (-(z_y - z_i) / (z_1 - z_3)).float()\n                    if self.reduction == 'mean':\n                        return dlr.mean()\n                    if self.reduction == 'sum':\n                        return dlr.sum()\n                    if self.reduction == 'none':\n                        return dlr\n                    raise NotImplementedError()\n\n                def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n                    \"\"\"\n                            Forward method.\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\n                            :param target: Target labels of shape (nb_samples, nb_classes).\n                            :return: Difference Logits Ratio Loss.\n                            \"\"\"\n                    return self.__call__(y_true=target, y_pred=input)\n            _loss_object_pt = DifferenceLogitsRatioPyTorch()\n        else:\n            raise NotImplementedError()\n        estimator_acg = PyTorchClassifier(model=estimator.model, loss=_loss_object_pt, input_shape=estimator.input_shape, nb_classes=estimator.nb_classes, optimizer=None, channels_first=estimator.channels_first, clip_values=estimator.clip_values, preprocessing_defences=estimator.preprocessing_defences, postprocessing_defences=estimator.postprocessing_defences, preprocessing=estimator.preprocessing, device_type=str(estimator._device))\n    else:\n        raise ValueError(f'The loss type {loss_type} is not supported for the provided estimator.')\n    super().__init__(estimator=estimator_acg)\n    self.norm = norm\n    self.eps = eps\n    self.eps_step = eps_step\n    self.max_iter = max_iter\n    self.targeted = targeted\n    self.nb_random_init = nb_random_init\n    self.batch_size = batch_size\n    self.loss_type = loss_type\n    self.verbose = verbose\n    self._check_params()",
            "def __init__(self, estimator: 'CLASSIFIER_LOSS_GRADIENTS_TYPE', norm: Union[int, float, str]=np.inf, eps: float=0.3, eps_step: float=0.1, max_iter: int=100, targeted: bool=False, nb_random_init: int=5, batch_size: int=32, loss_type: Optional[str]=None, verbose: bool=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Create a :class:`.AutoConjugateGradient` instance.\\n\\n        :param estimator: An trained estimator.\\n        :param norm: The norm of the adversarial perturbation. Possible values: \"inf\", np.inf, 1 or 2.\\n        :param eps: Maximum perturbation that the attacker can introduce.\\n        :param eps_step: Attack step size (input variation) at each iteration.\\n        :param max_iter: The maximum number of iterations.\\n        :param targeted: Indicates whether the attack is targeted (True) or untargeted (False).\\n        :param nb_random_init: Number of random initialisations within the epsilon ball. For num_random_init=0\\n            starting at the original input.\\n        :param batch_size: Size of the batch on which adversarial samples are generated.\\n        :param loss_type: Defines the loss to attack. Available options: None (Use loss defined by estimator),\\n            \"cross_entropy\", or \"difference_logits_ratio\"\\n        :param verbose: Show progress bars.\\n        '\n    from art.estimators.classification import TensorFlowClassifier, TensorFlowV2Classifier, PyTorchClassifier\n    if isinstance(estimator, TensorFlowClassifier):\n        raise ValueError('This attack does not support TensorFlow  v1.')\n    if loss_type not in self._predefined_losses:\n        raise ValueError(f'The argument loss_type has an invalid value. The following options for `loss_type` are currently supported: {self._predefined_losses}')\n    if loss_type is None:\n        if hasattr(estimator, 'predict') and is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=np.float32))):\n            raise ValueError('AutoProjectedGradientDescent is expecting logits as estimator output, the provided estimator seems to predict probabilities.')\n        estimator_acg = estimator\n    elif isinstance(estimator, TensorFlowV2Classifier):\n        import tensorflow as tf\n\n        class TensorFlowV2Loss:\n            \"\"\"abstract class of loss function of tensorflow v2\"\"\"\n\n            @abc.abstractmethod\n            def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                raise NotImplementedError\n        if loss_type == 'cross_entropy':\n\n            class CrossEntropyLossV2(TensorFlowV2Loss):\n                \"\"\"Class defining cross entropy loss with reduction options.\"\"\"\n\n                def __init__(self, from_logits, reduction='sum'):\n                    self.ce_loss = tf.keras.losses.CategoricalCrossentropy(from_logits=from_logits, reduction=tf.keras.losses.Reduction.NONE)\n                    self.reduction = reduction\n\n                def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                    if self.reduction == 'mean':\n                        return tf.reduce_mean(self.ce_loss(y_true, y_pred))\n                    if self.reduction == 'sum':\n                        return tf.reduce_sum(self.ce_loss(y_true, y_pred))\n                    if self.reduction == 'none':\n                        return self.ce_loss(y_true, y_pred)\n                    raise NotImplementedError()\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape)))):\n                _loss_object_tf: TensorFlowV2Loss = CrossEntropyLossV2(from_logits=False)\n            else:\n                _loss_object_tf = CrossEntropyLossV2(from_logits=True)\n        elif loss_type == 'difference_logits_ratio':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape)))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='difference_logits_ratio' the estimator has to to predict logits.\")\n\n            class DifferenceLogitsRatioTensorFlowV2(TensorFlowV2Loss):\n                \"\"\"\n                        Callable class for Difference Logits Ratio loss in TensorFlow v2.\n                        \"\"\"\n\n                def __init__(self):\n                    self.reduction = 'sum'\n\n                def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                    i_y_true = tf.cast(tf.math.argmax(tf.cast(y_true, tf.int32), axis=1), tf.int32)\n                    i_y_pred_arg = tf.argsort(y_pred, axis=1)\n                    i_z_i_list = []\n                    for i in range(y_true.shape[0]):\n                        if i_y_pred_arg[i, -1] != i_y_true[i]:\n                            i_z_i_list.append(i_y_pred_arg[i, -1])\n                        else:\n                            i_z_i_list.append(i_y_pred_arg[i, -2])\n                    i_z_i = tf.stack(i_z_i_list)\n                    z_1 = tf.gather(y_pred, i_y_pred_arg[:, -1], axis=1, batch_dims=0)\n                    z_3 = tf.gather(y_pred, i_y_pred_arg[:, -3], axis=1, batch_dims=0)\n                    z_i = tf.gather(y_pred, i_z_i, axis=1, batch_dims=0)\n                    z_y = tf.gather(y_pred, i_y_true, axis=1, batch_dims=0)\n                    z_1 = tf.linalg.diag_part(z_1)\n                    z_3 = tf.linalg.diag_part(z_3)\n                    z_i = tf.linalg.diag_part(z_i)\n                    z_y = tf.linalg.diag_part(z_y)\n                    dlr = -(z_y - z_i) / (z_1 - z_3)\n                    if self.reduction == 'mean':\n                        return tf.reduce_mean(dlr)\n                    if self.reduction == 'sum':\n                        return tf.reduce_sum(dlr)\n                    if self.reduction == 'none':\n                        return dlr\n                    raise NotImplementedError()\n            _loss_object_tf = DifferenceLogitsRatioTensorFlowV2()\n        estimator_acg = TensorFlowV2Classifier(model=estimator.model, nb_classes=estimator.nb_classes, input_shape=estimator.input_shape, loss_object=_loss_object_tf, optimizer=estimator.optimizer, train_step=estimator.train_step, channels_first=estimator.channels_first, clip_values=estimator.clip_values, preprocessing_defences=estimator.preprocessing_defences, postprocessing_defences=estimator.postprocessing_defences, preprocessing=estimator.preprocessing)\n    elif isinstance(estimator, PyTorchClassifier):\n        import torch\n        if loss_type == 'cross_entropy':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=np.float32))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='cross_entropy' the estimator has to to predict logits.\")\n\n            class CrossEntropyLossTorch(torch.nn.modules.loss._Loss):\n                \"\"\"Class defining cross entropy loss with reduction options.\"\"\"\n\n                def __init__(self, reduction='sum'):\n                    super().__init__()\n                    self.ce_loss = torch.nn.CrossEntropyLoss(reduction='none')\n                    self.reduction = reduction\n\n                def __call__(self, y_true: torch.Tensor, y_pred: torch.Tensor, *args, **kwargs) -> torch.Tensor:\n                    if self.reduction == 'mean':\n                        return self.ce_loss(y_true, y_pred).mean()\n                    if self.reduction == 'sum':\n                        return self.ce_loss(y_true, y_pred).sum()\n                    if self.reduction == 'none':\n                        return self.ce_loss(y_true, y_pred)\n                    raise NotImplementedError()\n\n                def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n                    \"\"\"\n                            Forward method.\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\n                            :param target: Target labels of shape (nb_samples, nb_classes).\n                            :return: Difference Logits Ratio Loss.\n                            \"\"\"\n                    return self.__call__(y_true=target, y_pred=input)\n            _loss_object_pt: torch.nn.modules.loss._Loss = CrossEntropyLossTorch(reduction='mean')\n        elif loss_type == 'difference_logits_ratio':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=ART_NUMPY_DTYPE))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='difference_logits_ratio' the estimator has to to predict logits.\")\n\n            class DifferenceLogitsRatioPyTorch(torch.nn.modules.loss._Loss):\n                \"\"\"\n                        Callable class for Difference Logits Ratio loss in PyTorch.\n                        \"\"\"\n\n                def __init__(self):\n                    super().__init__()\n                    self.reduction = 'sum'\n\n                def __call__(self, y_pred: torch.Tensor, y_true: torch.Tensor) -> torch.Tensor:\n                    if isinstance(y_true, np.ndarray):\n                        y_true = torch.from_numpy(y_true)\n                    if isinstance(y_pred, np.ndarray):\n                        y_pred = torch.from_numpy(y_pred)\n                    y_true = y_true.float()\n                    i_y_true = torch.argmax(y_true, dim=1)\n                    i_y_pred_arg = torch.argsort(y_pred, dim=1)\n                    i_z_i_list = []\n                    for i in range(y_true.shape[0]):\n                        if i_y_pred_arg[i, -1] != i_y_true[i]:\n                            i_z_i_list.append(i_y_pred_arg[i, -1])\n                        else:\n                            i_z_i_list.append(i_y_pred_arg[i, -2])\n                    i_z_i = torch.stack(i_z_i_list)\n                    z_1 = y_pred[:, i_y_pred_arg[:, -1]]\n                    z_3 = y_pred[:, i_y_pred_arg[:, -3]]\n                    z_i = y_pred[:, i_z_i]\n                    z_y = y_pred[:, i_y_true]\n                    z_1 = torch.diagonal(z_1)\n                    z_3 = torch.diagonal(z_3)\n                    z_i = torch.diagonal(z_i)\n                    z_y = torch.diagonal(z_y)\n                    dlr = (-(z_y - z_i) / (z_1 - z_3)).float()\n                    if self.reduction == 'mean':\n                        return dlr.mean()\n                    if self.reduction == 'sum':\n                        return dlr.sum()\n                    if self.reduction == 'none':\n                        return dlr\n                    raise NotImplementedError()\n\n                def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n                    \"\"\"\n                            Forward method.\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\n                            :param target: Target labels of shape (nb_samples, nb_classes).\n                            :return: Difference Logits Ratio Loss.\n                            \"\"\"\n                    return self.__call__(y_true=target, y_pred=input)\n            _loss_object_pt = DifferenceLogitsRatioPyTorch()\n        else:\n            raise NotImplementedError()\n        estimator_acg = PyTorchClassifier(model=estimator.model, loss=_loss_object_pt, input_shape=estimator.input_shape, nb_classes=estimator.nb_classes, optimizer=None, channels_first=estimator.channels_first, clip_values=estimator.clip_values, preprocessing_defences=estimator.preprocessing_defences, postprocessing_defences=estimator.postprocessing_defences, preprocessing=estimator.preprocessing, device_type=str(estimator._device))\n    else:\n        raise ValueError(f'The loss type {loss_type} is not supported for the provided estimator.')\n    super().__init__(estimator=estimator_acg)\n    self.norm = norm\n    self.eps = eps\n    self.eps_step = eps_step\n    self.max_iter = max_iter\n    self.targeted = targeted\n    self.nb_random_init = nb_random_init\n    self.batch_size = batch_size\n    self.loss_type = loss_type\n    self.verbose = verbose\n    self._check_params()",
            "def __init__(self, estimator: 'CLASSIFIER_LOSS_GRADIENTS_TYPE', norm: Union[int, float, str]=np.inf, eps: float=0.3, eps_step: float=0.1, max_iter: int=100, targeted: bool=False, nb_random_init: int=5, batch_size: int=32, loss_type: Optional[str]=None, verbose: bool=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Create a :class:`.AutoConjugateGradient` instance.\\n\\n        :param estimator: An trained estimator.\\n        :param norm: The norm of the adversarial perturbation. Possible values: \"inf\", np.inf, 1 or 2.\\n        :param eps: Maximum perturbation that the attacker can introduce.\\n        :param eps_step: Attack step size (input variation) at each iteration.\\n        :param max_iter: The maximum number of iterations.\\n        :param targeted: Indicates whether the attack is targeted (True) or untargeted (False).\\n        :param nb_random_init: Number of random initialisations within the epsilon ball. For num_random_init=0\\n            starting at the original input.\\n        :param batch_size: Size of the batch on which adversarial samples are generated.\\n        :param loss_type: Defines the loss to attack. Available options: None (Use loss defined by estimator),\\n            \"cross_entropy\", or \"difference_logits_ratio\"\\n        :param verbose: Show progress bars.\\n        '\n    from art.estimators.classification import TensorFlowClassifier, TensorFlowV2Classifier, PyTorchClassifier\n    if isinstance(estimator, TensorFlowClassifier):\n        raise ValueError('This attack does not support TensorFlow  v1.')\n    if loss_type not in self._predefined_losses:\n        raise ValueError(f'The argument loss_type has an invalid value. The following options for `loss_type` are currently supported: {self._predefined_losses}')\n    if loss_type is None:\n        if hasattr(estimator, 'predict') and is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=np.float32))):\n            raise ValueError('AutoProjectedGradientDescent is expecting logits as estimator output, the provided estimator seems to predict probabilities.')\n        estimator_acg = estimator\n    elif isinstance(estimator, TensorFlowV2Classifier):\n        import tensorflow as tf\n\n        class TensorFlowV2Loss:\n            \"\"\"abstract class of loss function of tensorflow v2\"\"\"\n\n            @abc.abstractmethod\n            def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                raise NotImplementedError\n        if loss_type == 'cross_entropy':\n\n            class CrossEntropyLossV2(TensorFlowV2Loss):\n                \"\"\"Class defining cross entropy loss with reduction options.\"\"\"\n\n                def __init__(self, from_logits, reduction='sum'):\n                    self.ce_loss = tf.keras.losses.CategoricalCrossentropy(from_logits=from_logits, reduction=tf.keras.losses.Reduction.NONE)\n                    self.reduction = reduction\n\n                def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                    if self.reduction == 'mean':\n                        return tf.reduce_mean(self.ce_loss(y_true, y_pred))\n                    if self.reduction == 'sum':\n                        return tf.reduce_sum(self.ce_loss(y_true, y_pred))\n                    if self.reduction == 'none':\n                        return self.ce_loss(y_true, y_pred)\n                    raise NotImplementedError()\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape)))):\n                _loss_object_tf: TensorFlowV2Loss = CrossEntropyLossV2(from_logits=False)\n            else:\n                _loss_object_tf = CrossEntropyLossV2(from_logits=True)\n        elif loss_type == 'difference_logits_ratio':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape)))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='difference_logits_ratio' the estimator has to to predict logits.\")\n\n            class DifferenceLogitsRatioTensorFlowV2(TensorFlowV2Loss):\n                \"\"\"\n                        Callable class for Difference Logits Ratio loss in TensorFlow v2.\n                        \"\"\"\n\n                def __init__(self):\n                    self.reduction = 'sum'\n\n                def __call__(self, y_true: tf.Tensor, y_pred: tf.Tensor, *args, **kwargs) -> tf.Tensor:\n                    i_y_true = tf.cast(tf.math.argmax(tf.cast(y_true, tf.int32), axis=1), tf.int32)\n                    i_y_pred_arg = tf.argsort(y_pred, axis=1)\n                    i_z_i_list = []\n                    for i in range(y_true.shape[0]):\n                        if i_y_pred_arg[i, -1] != i_y_true[i]:\n                            i_z_i_list.append(i_y_pred_arg[i, -1])\n                        else:\n                            i_z_i_list.append(i_y_pred_arg[i, -2])\n                    i_z_i = tf.stack(i_z_i_list)\n                    z_1 = tf.gather(y_pred, i_y_pred_arg[:, -1], axis=1, batch_dims=0)\n                    z_3 = tf.gather(y_pred, i_y_pred_arg[:, -3], axis=1, batch_dims=0)\n                    z_i = tf.gather(y_pred, i_z_i, axis=1, batch_dims=0)\n                    z_y = tf.gather(y_pred, i_y_true, axis=1, batch_dims=0)\n                    z_1 = tf.linalg.diag_part(z_1)\n                    z_3 = tf.linalg.diag_part(z_3)\n                    z_i = tf.linalg.diag_part(z_i)\n                    z_y = tf.linalg.diag_part(z_y)\n                    dlr = -(z_y - z_i) / (z_1 - z_3)\n                    if self.reduction == 'mean':\n                        return tf.reduce_mean(dlr)\n                    if self.reduction == 'sum':\n                        return tf.reduce_sum(dlr)\n                    if self.reduction == 'none':\n                        return dlr\n                    raise NotImplementedError()\n            _loss_object_tf = DifferenceLogitsRatioTensorFlowV2()\n        estimator_acg = TensorFlowV2Classifier(model=estimator.model, nb_classes=estimator.nb_classes, input_shape=estimator.input_shape, loss_object=_loss_object_tf, optimizer=estimator.optimizer, train_step=estimator.train_step, channels_first=estimator.channels_first, clip_values=estimator.clip_values, preprocessing_defences=estimator.preprocessing_defences, postprocessing_defences=estimator.postprocessing_defences, preprocessing=estimator.preprocessing)\n    elif isinstance(estimator, PyTorchClassifier):\n        import torch\n        if loss_type == 'cross_entropy':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=np.float32))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='cross_entropy' the estimator has to to predict logits.\")\n\n            class CrossEntropyLossTorch(torch.nn.modules.loss._Loss):\n                \"\"\"Class defining cross entropy loss with reduction options.\"\"\"\n\n                def __init__(self, reduction='sum'):\n                    super().__init__()\n                    self.ce_loss = torch.nn.CrossEntropyLoss(reduction='none')\n                    self.reduction = reduction\n\n                def __call__(self, y_true: torch.Tensor, y_pred: torch.Tensor, *args, **kwargs) -> torch.Tensor:\n                    if self.reduction == 'mean':\n                        return self.ce_loss(y_true, y_pred).mean()\n                    if self.reduction == 'sum':\n                        return self.ce_loss(y_true, y_pred).sum()\n                    if self.reduction == 'none':\n                        return self.ce_loss(y_true, y_pred)\n                    raise NotImplementedError()\n\n                def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n                    \"\"\"\n                            Forward method.\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\n                            :param target: Target labels of shape (nb_samples, nb_classes).\n                            :return: Difference Logits Ratio Loss.\n                            \"\"\"\n                    return self.__call__(y_true=target, y_pred=input)\n            _loss_object_pt: torch.nn.modules.loss._Loss = CrossEntropyLossTorch(reduction='mean')\n        elif loss_type == 'difference_logits_ratio':\n            if is_probability(estimator.predict(x=np.ones(shape=(1, *estimator.input_shape), dtype=ART_NUMPY_DTYPE))):\n                raise ValueError(\"The provided estimator seems to predict probabilities. If loss_type='difference_logits_ratio' the estimator has to to predict logits.\")\n\n            class DifferenceLogitsRatioPyTorch(torch.nn.modules.loss._Loss):\n                \"\"\"\n                        Callable class for Difference Logits Ratio loss in PyTorch.\n                        \"\"\"\n\n                def __init__(self):\n                    super().__init__()\n                    self.reduction = 'sum'\n\n                def __call__(self, y_pred: torch.Tensor, y_true: torch.Tensor) -> torch.Tensor:\n                    if isinstance(y_true, np.ndarray):\n                        y_true = torch.from_numpy(y_true)\n                    if isinstance(y_pred, np.ndarray):\n                        y_pred = torch.from_numpy(y_pred)\n                    y_true = y_true.float()\n                    i_y_true = torch.argmax(y_true, dim=1)\n                    i_y_pred_arg = torch.argsort(y_pred, dim=1)\n                    i_z_i_list = []\n                    for i in range(y_true.shape[0]):\n                        if i_y_pred_arg[i, -1] != i_y_true[i]:\n                            i_z_i_list.append(i_y_pred_arg[i, -1])\n                        else:\n                            i_z_i_list.append(i_y_pred_arg[i, -2])\n                    i_z_i = torch.stack(i_z_i_list)\n                    z_1 = y_pred[:, i_y_pred_arg[:, -1]]\n                    z_3 = y_pred[:, i_y_pred_arg[:, -3]]\n                    z_i = y_pred[:, i_z_i]\n                    z_y = y_pred[:, i_y_true]\n                    z_1 = torch.diagonal(z_1)\n                    z_3 = torch.diagonal(z_3)\n                    z_i = torch.diagonal(z_i)\n                    z_y = torch.diagonal(z_y)\n                    dlr = (-(z_y - z_i) / (z_1 - z_3)).float()\n                    if self.reduction == 'mean':\n                        return dlr.mean()\n                    if self.reduction == 'sum':\n                        return dlr.sum()\n                    if self.reduction == 'none':\n                        return dlr\n                    raise NotImplementedError()\n\n                def forward(self, input: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n                    \"\"\"\n                            Forward method.\n                            :param input: Predicted labels of shape (nb_samples, nb_classes).\n                            :param target: Target labels of shape (nb_samples, nb_classes).\n                            :return: Difference Logits Ratio Loss.\n                            \"\"\"\n                    return self.__call__(y_true=target, y_pred=input)\n            _loss_object_pt = DifferenceLogitsRatioPyTorch()\n        else:\n            raise NotImplementedError()\n        estimator_acg = PyTorchClassifier(model=estimator.model, loss=_loss_object_pt, input_shape=estimator.input_shape, nb_classes=estimator.nb_classes, optimizer=None, channels_first=estimator.channels_first, clip_values=estimator.clip_values, preprocessing_defences=estimator.preprocessing_defences, postprocessing_defences=estimator.postprocessing_defences, preprocessing=estimator.preprocessing, device_type=str(estimator._device))\n    else:\n        raise ValueError(f'The loss type {loss_type} is not supported for the provided estimator.')\n    super().__init__(estimator=estimator_acg)\n    self.norm = norm\n    self.eps = eps\n    self.eps_step = eps_step\n    self.max_iter = max_iter\n    self.targeted = targeted\n    self.nb_random_init = nb_random_init\n    self.batch_size = batch_size\n    self.loss_type = loss_type\n    self.verbose = verbose\n    self._check_params()"
        ]
    },
    {
        "func_name": "generate",
        "original": "def generate(self, x: np.ndarray, y: Optional[np.ndarray]=None, **kwargs) -> np.ndarray:\n    \"\"\"\n        Generate adversarial samples and return them in an array.\n\n        :param x: An array with the original inputs.\n        :param y: Target values (class labels) one-hot-encoded of shape `(nb_samples, nb_classes)` or indices of shape\n                  (nb_samples,). Only provide this parameter if you'd like to use true labels when crafting adversarial\n                  samples. Otherwise, model predictions are used as labels to avoid the \"label leaking\" effect\n                  (explained in this paper: https://arxiv.org/abs/1611.01236). Default is `None`.\n        :param mask: An array with a mask broadcastable to input `x` defining where to apply adversarial perturbations.\n                     Shape needs to be broadcastable to the shape of x and can also be of the same shape as `x`. Any\n                     features for which the mask is zero will not be adversarially perturbed.\n        :type mask: `np.ndarray`\n        :return: An array holding the adversarial examples.\n        \"\"\"\n    mask = kwargs.get('mask')\n    if y is not None:\n        y = check_and_transform_label_format(y, nb_classes=self.estimator.nb_classes)\n    if y is None:\n        if self.targeted:\n            raise ValueError('Target labels `y` need to be provided for a targeted attack.')\n        y = get_labels_np_array(self.estimator.predict(x, batch_size=self.batch_size)).astype(int)\n    if self.estimator.nb_classes == 2 and y.shape[1] == 1:\n        raise ValueError('This attack has not yet been tested for binary classification with a single output classifier.')\n    x_adv = x.astype(ART_NUMPY_DTYPE)\n    for _ in trange(max(1, self.nb_random_init), desc='ACG - restart', disable=not self.verbose):\n        y_pred = self.estimator.predict(x_adv)\n        if self.targeted:\n            sample_is_robust = np.argmax(y_pred, axis=1) != np.argmax(y, axis=1)\n        elif not self.targeted:\n            sample_is_robust = np.argmax(y_pred, axis=1) == np.argmax(y, axis=1)\n        if np.sum(sample_is_robust) == 0:\n            break\n        x_robust = x_adv[sample_is_robust]\n        y_robust = y[sample_is_robust]\n        x_init = x[sample_is_robust]\n        n = x_robust.shape[0]\n        m = np.prod(x_robust.shape[1:]).item()\n        random_perturbation = random_sphere(n, m, self.eps, self.norm).reshape(x_robust.shape).astype(ART_NUMPY_DTYPE)\n        x_robust = x_robust + random_perturbation\n        if self.estimator.clip_values is not None:\n            (clip_min, clip_max) = self.estimator.clip_values\n            x_robust = np.clip(x_robust, clip_min, clip_max)\n        perturbation = projection(x_robust - x_init, self.eps, self.norm)\n        x_robust = x_init + perturbation\n        for batch_id in trange(int(np.ceil(x_robust.shape[0] / float(self.batch_size))), desc='ACG - batch', leave=False, disable=not self.verbose):\n            (batch_index_1, batch_index_2) = (batch_id * self.batch_size, (batch_id + 1) * self.batch_size)\n            x_k = x_robust[batch_index_1:batch_index_2].astype(ART_NUMPY_DTYPE)\n            x_init_batch = x_init[batch_index_1:batch_index_2].astype(ART_NUMPY_DTYPE)\n            y_batch = y_robust[batch_index_1:batch_index_2]\n            p_0 = 0\n            p_1 = 0.22\n            var_w = [p_0, p_1]\n            while True:\n                p_j_p_1 = var_w[-1] + max(var_w[-1] - var_w[-2] - 0.03, 0.06)\n                if p_j_p_1 > 1:\n                    break\n                var_w.append(p_j_p_1)\n            var_w = [math.ceil(p * self.max_iter) for p in var_w]\n            _batch_size = x_k.shape[0]\n            eta = np.full((_batch_size,) + (1,) * len(self.estimator.input_shape), self.eps_step).astype(ART_NUMPY_DTYPE)\n            self.count_condition_1 = np.zeros(shape=(_batch_size,))\n            gradk_1 = np.zeros_like(x_k)\n            cgradk_1 = np.zeros_like(x_k)\n            cgradk = np.zeros_like(x_k)\n            gradk_1_best = np.zeros_like(x_k)\n            cgradk_1_best = np.zeros_like(x_k)\n            gradk_1_tmp = np.zeros_like(x_k)\n            cgradk_1_tmp = np.zeros_like(x_k)\n            for k_iter in trange(self.max_iter, desc='ACG - iteration', leave=False, disable=not self.verbose):\n                tol = 1e-07\n                grad = self.estimator.loss_gradient(x_k, y_batch) * (1 - 2 * int(self.targeted))\n                if k_iter == 0:\n                    gradk_1 = grad.copy()\n                    cgradk_1 = grad.copy()\n                    cgradk = grad.copy()\n                else:\n                    beta = get_beta(grad, gradk_1, cgradk_1)\n                    cgradk = grad + beta * cgradk_1\n                if self.norm in [np.inf, 'inf']:\n                    grad = np.sign(cgradk)\n                elif self.norm == 1:\n                    ind = tuple(range(1, len(x_k.shape)))\n                    cgradk = cgradk / (np.sum(np.abs(cgradk), axis=ind, keepdims=True) + tol)\n                elif self.norm == 2:\n                    ind = tuple(range(1, len(x_k.shape)))\n                    cgradk = cgradk / (np.sqrt(np.sum(np.square(cgradk), axis=ind, keepdims=True)) + tol)\n                assert x_k.shape == cgradk.shape\n                perturbation = cgradk\n                if mask is not None:\n                    perturbation = perturbation * mask.astype(ART_NUMPY_DTYPE)\n                x_k_p_1 = x_k + eta * perturbation\n                if self.estimator.clip_values is not None:\n                    (clip_min, clip_max) = self.estimator.clip_values\n                    x_k_p_1 = np.clip(x_k_p_1, clip_min, clip_max)\n                if k_iter == 0:\n                    x_1 = x_k_p_1\n                    perturbation = projection(x_1 - x_init_batch, self.eps, self.norm)\n                    x_1 = x_init_batch + perturbation\n                    f_0 = self.estimator.compute_loss(x=x_k, y=y_batch, reduction='none')\n                    f_1 = self.estimator.compute_loss(x=x_1, y=y_batch, reduction='none')\n                    self.eta_w_j_m_1 = eta.copy()\n                    self.f_max_w_j_m_1 = f_0.copy()\n                    self.f_max = f_0.copy()\n                    self.x_max = x_k.copy()\n                    f1_ge_f0 = f_1 >= f_0\n                    f_1_tmp = f_1[f1_ge_f0].copy()\n                    self.f_max[f1_ge_f0] = f_1_tmp.copy()\n                    x_1_tmp = x_1[f1_ge_f0].copy()\n                    self.x_max[f1_ge_f0] = x_1_tmp.copy()\n                    self.count_condition_1[f1_ge_f0] += 1\n                    x_k = x_1\n                    gradk_1_best = gradk_1.copy()\n                    cgradk_1_best = cgradk_1.copy()\n                else:\n                    perturbation = projection(x_k_p_1 - x_init_batch, self.eps, self.norm)\n                    x_k_p_1 = x_init_batch + perturbation\n                    if self.estimator.clip_values is not None:\n                        (clip_min, clip_max) = self.estimator.clip_values\n                        x_k_p_1 = np.clip(x_k_p_1, clip_min, clip_max)\n                    perturbation = projection(x_k_p_1 - x_init_batch, self.eps, self.norm)\n                    x_k_p_1 = x_init_batch + perturbation\n                    f_k_p_1 = self.estimator.compute_loss(x=x_k_p_1, y=y_batch, reduction='none')\n                    if (f_k_p_1 == 0.0).all():\n                        x_k = x_k_p_1.copy()\n                        break\n                    if self.targeted:\n                        fk_ge_fm = f_k_p_1 < self.f_max\n                    else:\n                        fk_ge_fm = f_k_p_1 > self.f_max\n                    self.count_condition_1[fk_ge_fm] += 1\n                    x_k_p_1_tmp = x_k_p_1[fk_ge_fm].copy()\n                    self.x_max[fk_ge_fm] = x_k_p_1_tmp.copy()\n                    f_k_p_1_tmp = f_k_p_1[fk_ge_fm].copy()\n                    self.f_max[fk_ge_fm] = f_k_p_1_tmp.copy()\n                    gradk_1_tmp = gradk_1[fk_ge_fm].copy()\n                    gradk_1_best[fk_ge_fm] = gradk_1_tmp.copy()\n                    cgradk_1_tmp = cgradk_1[fk_ge_fm].copy()\n                    cgradk_1_best[fk_ge_fm] = cgradk_1_tmp.copy()\n                    x_k = x_k_p_1.copy()\n                    gradk_1 = grad.copy()\n                    cgradk_1 = cgradk.copy()\n                    if k_iter in var_w:\n                        rho = 0.75\n                        condition_1 = self.count_condition_1 < rho * (k_iter - var_w[var_w.index(k_iter) - 1])\n                        condition_2 = np.logical_and((self.eta_w_j_m_1 == eta).squeeze(), self.f_max_w_j_m_1 == self.f_max)\n                        condition = np.logical_or(condition_1, condition_2)\n                        eta[condition] /= 2\n                        x_max_tmp = self.x_max[condition].copy()\n                        x_k[condition] = x_max_tmp.copy()\n                        gradk_1_tmp = gradk_1_best[condition].copy()\n                        gradk_1[condition] = gradk_1_tmp.copy()\n                        cgradk_1_tmp = cgradk_1_best[condition].copy()\n                        cgradk_1[condition] = cgradk_1_tmp.copy()\n                        self.count_condition_1[:] = 0\n                        self.eta_w_j_m_1 = eta.copy()\n                        self.f_max_w_j_m_1 = self.f_max.copy()\n            y_pred_adv_k = self.estimator.predict(x_k)\n            if self.targeted:\n                sample_is_not_robust_k = np.invert(np.argmax(y_pred_adv_k, axis=1) != np.argmax(y_batch, axis=1))\n            elif not self.targeted:\n                sample_is_not_robust_k = np.invert(np.argmax(y_pred_adv_k, axis=1) == np.argmax(y_batch, axis=1))\n            x_robust[batch_index_1:batch_index_2][sample_is_not_robust_k] = x_k[sample_is_not_robust_k]\n        x_adv[sample_is_robust] = x_robust\n    return x_adv",
        "mutated": [
            "def generate(self, x: np.ndarray, y: Optional[np.ndarray]=None, **kwargs) -> np.ndarray:\n    if False:\n        i = 10\n    '\\n        Generate adversarial samples and return them in an array.\\n\\n        :param x: An array with the original inputs.\\n        :param y: Target values (class labels) one-hot-encoded of shape `(nb_samples, nb_classes)` or indices of shape\\n                  (nb_samples,). Only provide this parameter if you\\'d like to use true labels when crafting adversarial\\n                  samples. Otherwise, model predictions are used as labels to avoid the \"label leaking\" effect\\n                  (explained in this paper: https://arxiv.org/abs/1611.01236). Default is `None`.\\n        :param mask: An array with a mask broadcastable to input `x` defining where to apply adversarial perturbations.\\n                     Shape needs to be broadcastable to the shape of x and can also be of the same shape as `x`. Any\\n                     features for which the mask is zero will not be adversarially perturbed.\\n        :type mask: `np.ndarray`\\n        :return: An array holding the adversarial examples.\\n        '\n    mask = kwargs.get('mask')\n    if y is not None:\n        y = check_and_transform_label_format(y, nb_classes=self.estimator.nb_classes)\n    if y is None:\n        if self.targeted:\n            raise ValueError('Target labels `y` need to be provided for a targeted attack.')\n        y = get_labels_np_array(self.estimator.predict(x, batch_size=self.batch_size)).astype(int)\n    if self.estimator.nb_classes == 2 and y.shape[1] == 1:\n        raise ValueError('This attack has not yet been tested for binary classification with a single output classifier.')\n    x_adv = x.astype(ART_NUMPY_DTYPE)\n    for _ in trange(max(1, self.nb_random_init), desc='ACG - restart', disable=not self.verbose):\n        y_pred = self.estimator.predict(x_adv)\n        if self.targeted:\n            sample_is_robust = np.argmax(y_pred, axis=1) != np.argmax(y, axis=1)\n        elif not self.targeted:\n            sample_is_robust = np.argmax(y_pred, axis=1) == np.argmax(y, axis=1)\n        if np.sum(sample_is_robust) == 0:\n            break\n        x_robust = x_adv[sample_is_robust]\n        y_robust = y[sample_is_robust]\n        x_init = x[sample_is_robust]\n        n = x_robust.shape[0]\n        m = np.prod(x_robust.shape[1:]).item()\n        random_perturbation = random_sphere(n, m, self.eps, self.norm).reshape(x_robust.shape).astype(ART_NUMPY_DTYPE)\n        x_robust = x_robust + random_perturbation\n        if self.estimator.clip_values is not None:\n            (clip_min, clip_max) = self.estimator.clip_values\n            x_robust = np.clip(x_robust, clip_min, clip_max)\n        perturbation = projection(x_robust - x_init, self.eps, self.norm)\n        x_robust = x_init + perturbation\n        for batch_id in trange(int(np.ceil(x_robust.shape[0] / float(self.batch_size))), desc='ACG - batch', leave=False, disable=not self.verbose):\n            (batch_index_1, batch_index_2) = (batch_id * self.batch_size, (batch_id + 1) * self.batch_size)\n            x_k = x_robust[batch_index_1:batch_index_2].astype(ART_NUMPY_DTYPE)\n            x_init_batch = x_init[batch_index_1:batch_index_2].astype(ART_NUMPY_DTYPE)\n            y_batch = y_robust[batch_index_1:batch_index_2]\n            p_0 = 0\n            p_1 = 0.22\n            var_w = [p_0, p_1]\n            while True:\n                p_j_p_1 = var_w[-1] + max(var_w[-1] - var_w[-2] - 0.03, 0.06)\n                if p_j_p_1 > 1:\n                    break\n                var_w.append(p_j_p_1)\n            var_w = [math.ceil(p * self.max_iter) for p in var_w]\n            _batch_size = x_k.shape[0]\n            eta = np.full((_batch_size,) + (1,) * len(self.estimator.input_shape), self.eps_step).astype(ART_NUMPY_DTYPE)\n            self.count_condition_1 = np.zeros(shape=(_batch_size,))\n            gradk_1 = np.zeros_like(x_k)\n            cgradk_1 = np.zeros_like(x_k)\n            cgradk = np.zeros_like(x_k)\n            gradk_1_best = np.zeros_like(x_k)\n            cgradk_1_best = np.zeros_like(x_k)\n            gradk_1_tmp = np.zeros_like(x_k)\n            cgradk_1_tmp = np.zeros_like(x_k)\n            for k_iter in trange(self.max_iter, desc='ACG - iteration', leave=False, disable=not self.verbose):\n                tol = 1e-07\n                grad = self.estimator.loss_gradient(x_k, y_batch) * (1 - 2 * int(self.targeted))\n                if k_iter == 0:\n                    gradk_1 = grad.copy()\n                    cgradk_1 = grad.copy()\n                    cgradk = grad.copy()\n                else:\n                    beta = get_beta(grad, gradk_1, cgradk_1)\n                    cgradk = grad + beta * cgradk_1\n                if self.norm in [np.inf, 'inf']:\n                    grad = np.sign(cgradk)\n                elif self.norm == 1:\n                    ind = tuple(range(1, len(x_k.shape)))\n                    cgradk = cgradk / (np.sum(np.abs(cgradk), axis=ind, keepdims=True) + tol)\n                elif self.norm == 2:\n                    ind = tuple(range(1, len(x_k.shape)))\n                    cgradk = cgradk / (np.sqrt(np.sum(np.square(cgradk), axis=ind, keepdims=True)) + tol)\n                assert x_k.shape == cgradk.shape\n                perturbation = cgradk\n                if mask is not None:\n                    perturbation = perturbation * mask.astype(ART_NUMPY_DTYPE)\n                x_k_p_1 = x_k + eta * perturbation\n                if self.estimator.clip_values is not None:\n                    (clip_min, clip_max) = self.estimator.clip_values\n                    x_k_p_1 = np.clip(x_k_p_1, clip_min, clip_max)\n                if k_iter == 0:\n                    x_1 = x_k_p_1\n                    perturbation = projection(x_1 - x_init_batch, self.eps, self.norm)\n                    x_1 = x_init_batch + perturbation\n                    f_0 = self.estimator.compute_loss(x=x_k, y=y_batch, reduction='none')\n                    f_1 = self.estimator.compute_loss(x=x_1, y=y_batch, reduction='none')\n                    self.eta_w_j_m_1 = eta.copy()\n                    self.f_max_w_j_m_1 = f_0.copy()\n                    self.f_max = f_0.copy()\n                    self.x_max = x_k.copy()\n                    f1_ge_f0 = f_1 >= f_0\n                    f_1_tmp = f_1[f1_ge_f0].copy()\n                    self.f_max[f1_ge_f0] = f_1_tmp.copy()\n                    x_1_tmp = x_1[f1_ge_f0].copy()\n                    self.x_max[f1_ge_f0] = x_1_tmp.copy()\n                    self.count_condition_1[f1_ge_f0] += 1\n                    x_k = x_1\n                    gradk_1_best = gradk_1.copy()\n                    cgradk_1_best = cgradk_1.copy()\n                else:\n                    perturbation = projection(x_k_p_1 - x_init_batch, self.eps, self.norm)\n                    x_k_p_1 = x_init_batch + perturbation\n                    if self.estimator.clip_values is not None:\n                        (clip_min, clip_max) = self.estimator.clip_values\n                        x_k_p_1 = np.clip(x_k_p_1, clip_min, clip_max)\n                    perturbation = projection(x_k_p_1 - x_init_batch, self.eps, self.norm)\n                    x_k_p_1 = x_init_batch + perturbation\n                    f_k_p_1 = self.estimator.compute_loss(x=x_k_p_1, y=y_batch, reduction='none')\n                    if (f_k_p_1 == 0.0).all():\n                        x_k = x_k_p_1.copy()\n                        break\n                    if self.targeted:\n                        fk_ge_fm = f_k_p_1 < self.f_max\n                    else:\n                        fk_ge_fm = f_k_p_1 > self.f_max\n                    self.count_condition_1[fk_ge_fm] += 1\n                    x_k_p_1_tmp = x_k_p_1[fk_ge_fm].copy()\n                    self.x_max[fk_ge_fm] = x_k_p_1_tmp.copy()\n                    f_k_p_1_tmp = f_k_p_1[fk_ge_fm].copy()\n                    self.f_max[fk_ge_fm] = f_k_p_1_tmp.copy()\n                    gradk_1_tmp = gradk_1[fk_ge_fm].copy()\n                    gradk_1_best[fk_ge_fm] = gradk_1_tmp.copy()\n                    cgradk_1_tmp = cgradk_1[fk_ge_fm].copy()\n                    cgradk_1_best[fk_ge_fm] = cgradk_1_tmp.copy()\n                    x_k = x_k_p_1.copy()\n                    gradk_1 = grad.copy()\n                    cgradk_1 = cgradk.copy()\n                    if k_iter in var_w:\n                        rho = 0.75\n                        condition_1 = self.count_condition_1 < rho * (k_iter - var_w[var_w.index(k_iter) - 1])\n                        condition_2 = np.logical_and((self.eta_w_j_m_1 == eta).squeeze(), self.f_max_w_j_m_1 == self.f_max)\n                        condition = np.logical_or(condition_1, condition_2)\n                        eta[condition] /= 2\n                        x_max_tmp = self.x_max[condition].copy()\n                        x_k[condition] = x_max_tmp.copy()\n                        gradk_1_tmp = gradk_1_best[condition].copy()\n                        gradk_1[condition] = gradk_1_tmp.copy()\n                        cgradk_1_tmp = cgradk_1_best[condition].copy()\n                        cgradk_1[condition] = cgradk_1_tmp.copy()\n                        self.count_condition_1[:] = 0\n                        self.eta_w_j_m_1 = eta.copy()\n                        self.f_max_w_j_m_1 = self.f_max.copy()\n            y_pred_adv_k = self.estimator.predict(x_k)\n            if self.targeted:\n                sample_is_not_robust_k = np.invert(np.argmax(y_pred_adv_k, axis=1) != np.argmax(y_batch, axis=1))\n            elif not self.targeted:\n                sample_is_not_robust_k = np.invert(np.argmax(y_pred_adv_k, axis=1) == np.argmax(y_batch, axis=1))\n            x_robust[batch_index_1:batch_index_2][sample_is_not_robust_k] = x_k[sample_is_not_robust_k]\n        x_adv[sample_is_robust] = x_robust\n    return x_adv",
            "def generate(self, x: np.ndarray, y: Optional[np.ndarray]=None, **kwargs) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Generate adversarial samples and return them in an array.\\n\\n        :param x: An array with the original inputs.\\n        :param y: Target values (class labels) one-hot-encoded of shape `(nb_samples, nb_classes)` or indices of shape\\n                  (nb_samples,). Only provide this parameter if you\\'d like to use true labels when crafting adversarial\\n                  samples. Otherwise, model predictions are used as labels to avoid the \"label leaking\" effect\\n                  (explained in this paper: https://arxiv.org/abs/1611.01236). Default is `None`.\\n        :param mask: An array with a mask broadcastable to input `x` defining where to apply adversarial perturbations.\\n                     Shape needs to be broadcastable to the shape of x and can also be of the same shape as `x`. Any\\n                     features for which the mask is zero will not be adversarially perturbed.\\n        :type mask: `np.ndarray`\\n        :return: An array holding the adversarial examples.\\n        '\n    mask = kwargs.get('mask')\n    if y is not None:\n        y = check_and_transform_label_format(y, nb_classes=self.estimator.nb_classes)\n    if y is None:\n        if self.targeted:\n            raise ValueError('Target labels `y` need to be provided for a targeted attack.')\n        y = get_labels_np_array(self.estimator.predict(x, batch_size=self.batch_size)).astype(int)\n    if self.estimator.nb_classes == 2 and y.shape[1] == 1:\n        raise ValueError('This attack has not yet been tested for binary classification with a single output classifier.')\n    x_adv = x.astype(ART_NUMPY_DTYPE)\n    for _ in trange(max(1, self.nb_random_init), desc='ACG - restart', disable=not self.verbose):\n        y_pred = self.estimator.predict(x_adv)\n        if self.targeted:\n            sample_is_robust = np.argmax(y_pred, axis=1) != np.argmax(y, axis=1)\n        elif not self.targeted:\n            sample_is_robust = np.argmax(y_pred, axis=1) == np.argmax(y, axis=1)\n        if np.sum(sample_is_robust) == 0:\n            break\n        x_robust = x_adv[sample_is_robust]\n        y_robust = y[sample_is_robust]\n        x_init = x[sample_is_robust]\n        n = x_robust.shape[0]\n        m = np.prod(x_robust.shape[1:]).item()\n        random_perturbation = random_sphere(n, m, self.eps, self.norm).reshape(x_robust.shape).astype(ART_NUMPY_DTYPE)\n        x_robust = x_robust + random_perturbation\n        if self.estimator.clip_values is not None:\n            (clip_min, clip_max) = self.estimator.clip_values\n            x_robust = np.clip(x_robust, clip_min, clip_max)\n        perturbation = projection(x_robust - x_init, self.eps, self.norm)\n        x_robust = x_init + perturbation\n        for batch_id in trange(int(np.ceil(x_robust.shape[0] / float(self.batch_size))), desc='ACG - batch', leave=False, disable=not self.verbose):\n            (batch_index_1, batch_index_2) = (batch_id * self.batch_size, (batch_id + 1) * self.batch_size)\n            x_k = x_robust[batch_index_1:batch_index_2].astype(ART_NUMPY_DTYPE)\n            x_init_batch = x_init[batch_index_1:batch_index_2].astype(ART_NUMPY_DTYPE)\n            y_batch = y_robust[batch_index_1:batch_index_2]\n            p_0 = 0\n            p_1 = 0.22\n            var_w = [p_0, p_1]\n            while True:\n                p_j_p_1 = var_w[-1] + max(var_w[-1] - var_w[-2] - 0.03, 0.06)\n                if p_j_p_1 > 1:\n                    break\n                var_w.append(p_j_p_1)\n            var_w = [math.ceil(p * self.max_iter) for p in var_w]\n            _batch_size = x_k.shape[0]\n            eta = np.full((_batch_size,) + (1,) * len(self.estimator.input_shape), self.eps_step).astype(ART_NUMPY_DTYPE)\n            self.count_condition_1 = np.zeros(shape=(_batch_size,))\n            gradk_1 = np.zeros_like(x_k)\n            cgradk_1 = np.zeros_like(x_k)\n            cgradk = np.zeros_like(x_k)\n            gradk_1_best = np.zeros_like(x_k)\n            cgradk_1_best = np.zeros_like(x_k)\n            gradk_1_tmp = np.zeros_like(x_k)\n            cgradk_1_tmp = np.zeros_like(x_k)\n            for k_iter in trange(self.max_iter, desc='ACG - iteration', leave=False, disable=not self.verbose):\n                tol = 1e-07\n                grad = self.estimator.loss_gradient(x_k, y_batch) * (1 - 2 * int(self.targeted))\n                if k_iter == 0:\n                    gradk_1 = grad.copy()\n                    cgradk_1 = grad.copy()\n                    cgradk = grad.copy()\n                else:\n                    beta = get_beta(grad, gradk_1, cgradk_1)\n                    cgradk = grad + beta * cgradk_1\n                if self.norm in [np.inf, 'inf']:\n                    grad = np.sign(cgradk)\n                elif self.norm == 1:\n                    ind = tuple(range(1, len(x_k.shape)))\n                    cgradk = cgradk / (np.sum(np.abs(cgradk), axis=ind, keepdims=True) + tol)\n                elif self.norm == 2:\n                    ind = tuple(range(1, len(x_k.shape)))\n                    cgradk = cgradk / (np.sqrt(np.sum(np.square(cgradk), axis=ind, keepdims=True)) + tol)\n                assert x_k.shape == cgradk.shape\n                perturbation = cgradk\n                if mask is not None:\n                    perturbation = perturbation * mask.astype(ART_NUMPY_DTYPE)\n                x_k_p_1 = x_k + eta * perturbation\n                if self.estimator.clip_values is not None:\n                    (clip_min, clip_max) = self.estimator.clip_values\n                    x_k_p_1 = np.clip(x_k_p_1, clip_min, clip_max)\n                if k_iter == 0:\n                    x_1 = x_k_p_1\n                    perturbation = projection(x_1 - x_init_batch, self.eps, self.norm)\n                    x_1 = x_init_batch + perturbation\n                    f_0 = self.estimator.compute_loss(x=x_k, y=y_batch, reduction='none')\n                    f_1 = self.estimator.compute_loss(x=x_1, y=y_batch, reduction='none')\n                    self.eta_w_j_m_1 = eta.copy()\n                    self.f_max_w_j_m_1 = f_0.copy()\n                    self.f_max = f_0.copy()\n                    self.x_max = x_k.copy()\n                    f1_ge_f0 = f_1 >= f_0\n                    f_1_tmp = f_1[f1_ge_f0].copy()\n                    self.f_max[f1_ge_f0] = f_1_tmp.copy()\n                    x_1_tmp = x_1[f1_ge_f0].copy()\n                    self.x_max[f1_ge_f0] = x_1_tmp.copy()\n                    self.count_condition_1[f1_ge_f0] += 1\n                    x_k = x_1\n                    gradk_1_best = gradk_1.copy()\n                    cgradk_1_best = cgradk_1.copy()\n                else:\n                    perturbation = projection(x_k_p_1 - x_init_batch, self.eps, self.norm)\n                    x_k_p_1 = x_init_batch + perturbation\n                    if self.estimator.clip_values is not None:\n                        (clip_min, clip_max) = self.estimator.clip_values\n                        x_k_p_1 = np.clip(x_k_p_1, clip_min, clip_max)\n                    perturbation = projection(x_k_p_1 - x_init_batch, self.eps, self.norm)\n                    x_k_p_1 = x_init_batch + perturbation\n                    f_k_p_1 = self.estimator.compute_loss(x=x_k_p_1, y=y_batch, reduction='none')\n                    if (f_k_p_1 == 0.0).all():\n                        x_k = x_k_p_1.copy()\n                        break\n                    if self.targeted:\n                        fk_ge_fm = f_k_p_1 < self.f_max\n                    else:\n                        fk_ge_fm = f_k_p_1 > self.f_max\n                    self.count_condition_1[fk_ge_fm] += 1\n                    x_k_p_1_tmp = x_k_p_1[fk_ge_fm].copy()\n                    self.x_max[fk_ge_fm] = x_k_p_1_tmp.copy()\n                    f_k_p_1_tmp = f_k_p_1[fk_ge_fm].copy()\n                    self.f_max[fk_ge_fm] = f_k_p_1_tmp.copy()\n                    gradk_1_tmp = gradk_1[fk_ge_fm].copy()\n                    gradk_1_best[fk_ge_fm] = gradk_1_tmp.copy()\n                    cgradk_1_tmp = cgradk_1[fk_ge_fm].copy()\n                    cgradk_1_best[fk_ge_fm] = cgradk_1_tmp.copy()\n                    x_k = x_k_p_1.copy()\n                    gradk_1 = grad.copy()\n                    cgradk_1 = cgradk.copy()\n                    if k_iter in var_w:\n                        rho = 0.75\n                        condition_1 = self.count_condition_1 < rho * (k_iter - var_w[var_w.index(k_iter) - 1])\n                        condition_2 = np.logical_and((self.eta_w_j_m_1 == eta).squeeze(), self.f_max_w_j_m_1 == self.f_max)\n                        condition = np.logical_or(condition_1, condition_2)\n                        eta[condition] /= 2\n                        x_max_tmp = self.x_max[condition].copy()\n                        x_k[condition] = x_max_tmp.copy()\n                        gradk_1_tmp = gradk_1_best[condition].copy()\n                        gradk_1[condition] = gradk_1_tmp.copy()\n                        cgradk_1_tmp = cgradk_1_best[condition].copy()\n                        cgradk_1[condition] = cgradk_1_tmp.copy()\n                        self.count_condition_1[:] = 0\n                        self.eta_w_j_m_1 = eta.copy()\n                        self.f_max_w_j_m_1 = self.f_max.copy()\n            y_pred_adv_k = self.estimator.predict(x_k)\n            if self.targeted:\n                sample_is_not_robust_k = np.invert(np.argmax(y_pred_adv_k, axis=1) != np.argmax(y_batch, axis=1))\n            elif not self.targeted:\n                sample_is_not_robust_k = np.invert(np.argmax(y_pred_adv_k, axis=1) == np.argmax(y_batch, axis=1))\n            x_robust[batch_index_1:batch_index_2][sample_is_not_robust_k] = x_k[sample_is_not_robust_k]\n        x_adv[sample_is_robust] = x_robust\n    return x_adv",
            "def generate(self, x: np.ndarray, y: Optional[np.ndarray]=None, **kwargs) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Generate adversarial samples and return them in an array.\\n\\n        :param x: An array with the original inputs.\\n        :param y: Target values (class labels) one-hot-encoded of shape `(nb_samples, nb_classes)` or indices of shape\\n                  (nb_samples,). Only provide this parameter if you\\'d like to use true labels when crafting adversarial\\n                  samples. Otherwise, model predictions are used as labels to avoid the \"label leaking\" effect\\n                  (explained in this paper: https://arxiv.org/abs/1611.01236). Default is `None`.\\n        :param mask: An array with a mask broadcastable to input `x` defining where to apply adversarial perturbations.\\n                     Shape needs to be broadcastable to the shape of x and can also be of the same shape as `x`. Any\\n                     features for which the mask is zero will not be adversarially perturbed.\\n        :type mask: `np.ndarray`\\n        :return: An array holding the adversarial examples.\\n        '\n    mask = kwargs.get('mask')\n    if y is not None:\n        y = check_and_transform_label_format(y, nb_classes=self.estimator.nb_classes)\n    if y is None:\n        if self.targeted:\n            raise ValueError('Target labels `y` need to be provided for a targeted attack.')\n        y = get_labels_np_array(self.estimator.predict(x, batch_size=self.batch_size)).astype(int)\n    if self.estimator.nb_classes == 2 and y.shape[1] == 1:\n        raise ValueError('This attack has not yet been tested for binary classification with a single output classifier.')\n    x_adv = x.astype(ART_NUMPY_DTYPE)\n    for _ in trange(max(1, self.nb_random_init), desc='ACG - restart', disable=not self.verbose):\n        y_pred = self.estimator.predict(x_adv)\n        if self.targeted:\n            sample_is_robust = np.argmax(y_pred, axis=1) != np.argmax(y, axis=1)\n        elif not self.targeted:\n            sample_is_robust = np.argmax(y_pred, axis=1) == np.argmax(y, axis=1)\n        if np.sum(sample_is_robust) == 0:\n            break\n        x_robust = x_adv[sample_is_robust]\n        y_robust = y[sample_is_robust]\n        x_init = x[sample_is_robust]\n        n = x_robust.shape[0]\n        m = np.prod(x_robust.shape[1:]).item()\n        random_perturbation = random_sphere(n, m, self.eps, self.norm).reshape(x_robust.shape).astype(ART_NUMPY_DTYPE)\n        x_robust = x_robust + random_perturbation\n        if self.estimator.clip_values is not None:\n            (clip_min, clip_max) = self.estimator.clip_values\n            x_robust = np.clip(x_robust, clip_min, clip_max)\n        perturbation = projection(x_robust - x_init, self.eps, self.norm)\n        x_robust = x_init + perturbation\n        for batch_id in trange(int(np.ceil(x_robust.shape[0] / float(self.batch_size))), desc='ACG - batch', leave=False, disable=not self.verbose):\n            (batch_index_1, batch_index_2) = (batch_id * self.batch_size, (batch_id + 1) * self.batch_size)\n            x_k = x_robust[batch_index_1:batch_index_2].astype(ART_NUMPY_DTYPE)\n            x_init_batch = x_init[batch_index_1:batch_index_2].astype(ART_NUMPY_DTYPE)\n            y_batch = y_robust[batch_index_1:batch_index_2]\n            p_0 = 0\n            p_1 = 0.22\n            var_w = [p_0, p_1]\n            while True:\n                p_j_p_1 = var_w[-1] + max(var_w[-1] - var_w[-2] - 0.03, 0.06)\n                if p_j_p_1 > 1:\n                    break\n                var_w.append(p_j_p_1)\n            var_w = [math.ceil(p * self.max_iter) for p in var_w]\n            _batch_size = x_k.shape[0]\n            eta = np.full((_batch_size,) + (1,) * len(self.estimator.input_shape), self.eps_step).astype(ART_NUMPY_DTYPE)\n            self.count_condition_1 = np.zeros(shape=(_batch_size,))\n            gradk_1 = np.zeros_like(x_k)\n            cgradk_1 = np.zeros_like(x_k)\n            cgradk = np.zeros_like(x_k)\n            gradk_1_best = np.zeros_like(x_k)\n            cgradk_1_best = np.zeros_like(x_k)\n            gradk_1_tmp = np.zeros_like(x_k)\n            cgradk_1_tmp = np.zeros_like(x_k)\n            for k_iter in trange(self.max_iter, desc='ACG - iteration', leave=False, disable=not self.verbose):\n                tol = 1e-07\n                grad = self.estimator.loss_gradient(x_k, y_batch) * (1 - 2 * int(self.targeted))\n                if k_iter == 0:\n                    gradk_1 = grad.copy()\n                    cgradk_1 = grad.copy()\n                    cgradk = grad.copy()\n                else:\n                    beta = get_beta(grad, gradk_1, cgradk_1)\n                    cgradk = grad + beta * cgradk_1\n                if self.norm in [np.inf, 'inf']:\n                    grad = np.sign(cgradk)\n                elif self.norm == 1:\n                    ind = tuple(range(1, len(x_k.shape)))\n                    cgradk = cgradk / (np.sum(np.abs(cgradk), axis=ind, keepdims=True) + tol)\n                elif self.norm == 2:\n                    ind = tuple(range(1, len(x_k.shape)))\n                    cgradk = cgradk / (np.sqrt(np.sum(np.square(cgradk), axis=ind, keepdims=True)) + tol)\n                assert x_k.shape == cgradk.shape\n                perturbation = cgradk\n                if mask is not None:\n                    perturbation = perturbation * mask.astype(ART_NUMPY_DTYPE)\n                x_k_p_1 = x_k + eta * perturbation\n                if self.estimator.clip_values is not None:\n                    (clip_min, clip_max) = self.estimator.clip_values\n                    x_k_p_1 = np.clip(x_k_p_1, clip_min, clip_max)\n                if k_iter == 0:\n                    x_1 = x_k_p_1\n                    perturbation = projection(x_1 - x_init_batch, self.eps, self.norm)\n                    x_1 = x_init_batch + perturbation\n                    f_0 = self.estimator.compute_loss(x=x_k, y=y_batch, reduction='none')\n                    f_1 = self.estimator.compute_loss(x=x_1, y=y_batch, reduction='none')\n                    self.eta_w_j_m_1 = eta.copy()\n                    self.f_max_w_j_m_1 = f_0.copy()\n                    self.f_max = f_0.copy()\n                    self.x_max = x_k.copy()\n                    f1_ge_f0 = f_1 >= f_0\n                    f_1_tmp = f_1[f1_ge_f0].copy()\n                    self.f_max[f1_ge_f0] = f_1_tmp.copy()\n                    x_1_tmp = x_1[f1_ge_f0].copy()\n                    self.x_max[f1_ge_f0] = x_1_tmp.copy()\n                    self.count_condition_1[f1_ge_f0] += 1\n                    x_k = x_1\n                    gradk_1_best = gradk_1.copy()\n                    cgradk_1_best = cgradk_1.copy()\n                else:\n                    perturbation = projection(x_k_p_1 - x_init_batch, self.eps, self.norm)\n                    x_k_p_1 = x_init_batch + perturbation\n                    if self.estimator.clip_values is not None:\n                        (clip_min, clip_max) = self.estimator.clip_values\n                        x_k_p_1 = np.clip(x_k_p_1, clip_min, clip_max)\n                    perturbation = projection(x_k_p_1 - x_init_batch, self.eps, self.norm)\n                    x_k_p_1 = x_init_batch + perturbation\n                    f_k_p_1 = self.estimator.compute_loss(x=x_k_p_1, y=y_batch, reduction='none')\n                    if (f_k_p_1 == 0.0).all():\n                        x_k = x_k_p_1.copy()\n                        break\n                    if self.targeted:\n                        fk_ge_fm = f_k_p_1 < self.f_max\n                    else:\n                        fk_ge_fm = f_k_p_1 > self.f_max\n                    self.count_condition_1[fk_ge_fm] += 1\n                    x_k_p_1_tmp = x_k_p_1[fk_ge_fm].copy()\n                    self.x_max[fk_ge_fm] = x_k_p_1_tmp.copy()\n                    f_k_p_1_tmp = f_k_p_1[fk_ge_fm].copy()\n                    self.f_max[fk_ge_fm] = f_k_p_1_tmp.copy()\n                    gradk_1_tmp = gradk_1[fk_ge_fm].copy()\n                    gradk_1_best[fk_ge_fm] = gradk_1_tmp.copy()\n                    cgradk_1_tmp = cgradk_1[fk_ge_fm].copy()\n                    cgradk_1_best[fk_ge_fm] = cgradk_1_tmp.copy()\n                    x_k = x_k_p_1.copy()\n                    gradk_1 = grad.copy()\n                    cgradk_1 = cgradk.copy()\n                    if k_iter in var_w:\n                        rho = 0.75\n                        condition_1 = self.count_condition_1 < rho * (k_iter - var_w[var_w.index(k_iter) - 1])\n                        condition_2 = np.logical_and((self.eta_w_j_m_1 == eta).squeeze(), self.f_max_w_j_m_1 == self.f_max)\n                        condition = np.logical_or(condition_1, condition_2)\n                        eta[condition] /= 2\n                        x_max_tmp = self.x_max[condition].copy()\n                        x_k[condition] = x_max_tmp.copy()\n                        gradk_1_tmp = gradk_1_best[condition].copy()\n                        gradk_1[condition] = gradk_1_tmp.copy()\n                        cgradk_1_tmp = cgradk_1_best[condition].copy()\n                        cgradk_1[condition] = cgradk_1_tmp.copy()\n                        self.count_condition_1[:] = 0\n                        self.eta_w_j_m_1 = eta.copy()\n                        self.f_max_w_j_m_1 = self.f_max.copy()\n            y_pred_adv_k = self.estimator.predict(x_k)\n            if self.targeted:\n                sample_is_not_robust_k = np.invert(np.argmax(y_pred_adv_k, axis=1) != np.argmax(y_batch, axis=1))\n            elif not self.targeted:\n                sample_is_not_robust_k = np.invert(np.argmax(y_pred_adv_k, axis=1) == np.argmax(y_batch, axis=1))\n            x_robust[batch_index_1:batch_index_2][sample_is_not_robust_k] = x_k[sample_is_not_robust_k]\n        x_adv[sample_is_robust] = x_robust\n    return x_adv",
            "def generate(self, x: np.ndarray, y: Optional[np.ndarray]=None, **kwargs) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Generate adversarial samples and return them in an array.\\n\\n        :param x: An array with the original inputs.\\n        :param y: Target values (class labels) one-hot-encoded of shape `(nb_samples, nb_classes)` or indices of shape\\n                  (nb_samples,). Only provide this parameter if you\\'d like to use true labels when crafting adversarial\\n                  samples. Otherwise, model predictions are used as labels to avoid the \"label leaking\" effect\\n                  (explained in this paper: https://arxiv.org/abs/1611.01236). Default is `None`.\\n        :param mask: An array with a mask broadcastable to input `x` defining where to apply adversarial perturbations.\\n                     Shape needs to be broadcastable to the shape of x and can also be of the same shape as `x`. Any\\n                     features for which the mask is zero will not be adversarially perturbed.\\n        :type mask: `np.ndarray`\\n        :return: An array holding the adversarial examples.\\n        '\n    mask = kwargs.get('mask')\n    if y is not None:\n        y = check_and_transform_label_format(y, nb_classes=self.estimator.nb_classes)\n    if y is None:\n        if self.targeted:\n            raise ValueError('Target labels `y` need to be provided for a targeted attack.')\n        y = get_labels_np_array(self.estimator.predict(x, batch_size=self.batch_size)).astype(int)\n    if self.estimator.nb_classes == 2 and y.shape[1] == 1:\n        raise ValueError('This attack has not yet been tested for binary classification with a single output classifier.')\n    x_adv = x.astype(ART_NUMPY_DTYPE)\n    for _ in trange(max(1, self.nb_random_init), desc='ACG - restart', disable=not self.verbose):\n        y_pred = self.estimator.predict(x_adv)\n        if self.targeted:\n            sample_is_robust = np.argmax(y_pred, axis=1) != np.argmax(y, axis=1)\n        elif not self.targeted:\n            sample_is_robust = np.argmax(y_pred, axis=1) == np.argmax(y, axis=1)\n        if np.sum(sample_is_robust) == 0:\n            break\n        x_robust = x_adv[sample_is_robust]\n        y_robust = y[sample_is_robust]\n        x_init = x[sample_is_robust]\n        n = x_robust.shape[0]\n        m = np.prod(x_robust.shape[1:]).item()\n        random_perturbation = random_sphere(n, m, self.eps, self.norm).reshape(x_robust.shape).astype(ART_NUMPY_DTYPE)\n        x_robust = x_robust + random_perturbation\n        if self.estimator.clip_values is not None:\n            (clip_min, clip_max) = self.estimator.clip_values\n            x_robust = np.clip(x_robust, clip_min, clip_max)\n        perturbation = projection(x_robust - x_init, self.eps, self.norm)\n        x_robust = x_init + perturbation\n        for batch_id in trange(int(np.ceil(x_robust.shape[0] / float(self.batch_size))), desc='ACG - batch', leave=False, disable=not self.verbose):\n            (batch_index_1, batch_index_2) = (batch_id * self.batch_size, (batch_id + 1) * self.batch_size)\n            x_k = x_robust[batch_index_1:batch_index_2].astype(ART_NUMPY_DTYPE)\n            x_init_batch = x_init[batch_index_1:batch_index_2].astype(ART_NUMPY_DTYPE)\n            y_batch = y_robust[batch_index_1:batch_index_2]\n            p_0 = 0\n            p_1 = 0.22\n            var_w = [p_0, p_1]\n            while True:\n                p_j_p_1 = var_w[-1] + max(var_w[-1] - var_w[-2] - 0.03, 0.06)\n                if p_j_p_1 > 1:\n                    break\n                var_w.append(p_j_p_1)\n            var_w = [math.ceil(p * self.max_iter) for p in var_w]\n            _batch_size = x_k.shape[0]\n            eta = np.full((_batch_size,) + (1,) * len(self.estimator.input_shape), self.eps_step).astype(ART_NUMPY_DTYPE)\n            self.count_condition_1 = np.zeros(shape=(_batch_size,))\n            gradk_1 = np.zeros_like(x_k)\n            cgradk_1 = np.zeros_like(x_k)\n            cgradk = np.zeros_like(x_k)\n            gradk_1_best = np.zeros_like(x_k)\n            cgradk_1_best = np.zeros_like(x_k)\n            gradk_1_tmp = np.zeros_like(x_k)\n            cgradk_1_tmp = np.zeros_like(x_k)\n            for k_iter in trange(self.max_iter, desc='ACG - iteration', leave=False, disable=not self.verbose):\n                tol = 1e-07\n                grad = self.estimator.loss_gradient(x_k, y_batch) * (1 - 2 * int(self.targeted))\n                if k_iter == 0:\n                    gradk_1 = grad.copy()\n                    cgradk_1 = grad.copy()\n                    cgradk = grad.copy()\n                else:\n                    beta = get_beta(grad, gradk_1, cgradk_1)\n                    cgradk = grad + beta * cgradk_1\n                if self.norm in [np.inf, 'inf']:\n                    grad = np.sign(cgradk)\n                elif self.norm == 1:\n                    ind = tuple(range(1, len(x_k.shape)))\n                    cgradk = cgradk / (np.sum(np.abs(cgradk), axis=ind, keepdims=True) + tol)\n                elif self.norm == 2:\n                    ind = tuple(range(1, len(x_k.shape)))\n                    cgradk = cgradk / (np.sqrt(np.sum(np.square(cgradk), axis=ind, keepdims=True)) + tol)\n                assert x_k.shape == cgradk.shape\n                perturbation = cgradk\n                if mask is not None:\n                    perturbation = perturbation * mask.astype(ART_NUMPY_DTYPE)\n                x_k_p_1 = x_k + eta * perturbation\n                if self.estimator.clip_values is not None:\n                    (clip_min, clip_max) = self.estimator.clip_values\n                    x_k_p_1 = np.clip(x_k_p_1, clip_min, clip_max)\n                if k_iter == 0:\n                    x_1 = x_k_p_1\n                    perturbation = projection(x_1 - x_init_batch, self.eps, self.norm)\n                    x_1 = x_init_batch + perturbation\n                    f_0 = self.estimator.compute_loss(x=x_k, y=y_batch, reduction='none')\n                    f_1 = self.estimator.compute_loss(x=x_1, y=y_batch, reduction='none')\n                    self.eta_w_j_m_1 = eta.copy()\n                    self.f_max_w_j_m_1 = f_0.copy()\n                    self.f_max = f_0.copy()\n                    self.x_max = x_k.copy()\n                    f1_ge_f0 = f_1 >= f_0\n                    f_1_tmp = f_1[f1_ge_f0].copy()\n                    self.f_max[f1_ge_f0] = f_1_tmp.copy()\n                    x_1_tmp = x_1[f1_ge_f0].copy()\n                    self.x_max[f1_ge_f0] = x_1_tmp.copy()\n                    self.count_condition_1[f1_ge_f0] += 1\n                    x_k = x_1\n                    gradk_1_best = gradk_1.copy()\n                    cgradk_1_best = cgradk_1.copy()\n                else:\n                    perturbation = projection(x_k_p_1 - x_init_batch, self.eps, self.norm)\n                    x_k_p_1 = x_init_batch + perturbation\n                    if self.estimator.clip_values is not None:\n                        (clip_min, clip_max) = self.estimator.clip_values\n                        x_k_p_1 = np.clip(x_k_p_1, clip_min, clip_max)\n                    perturbation = projection(x_k_p_1 - x_init_batch, self.eps, self.norm)\n                    x_k_p_1 = x_init_batch + perturbation\n                    f_k_p_1 = self.estimator.compute_loss(x=x_k_p_1, y=y_batch, reduction='none')\n                    if (f_k_p_1 == 0.0).all():\n                        x_k = x_k_p_1.copy()\n                        break\n                    if self.targeted:\n                        fk_ge_fm = f_k_p_1 < self.f_max\n                    else:\n                        fk_ge_fm = f_k_p_1 > self.f_max\n                    self.count_condition_1[fk_ge_fm] += 1\n                    x_k_p_1_tmp = x_k_p_1[fk_ge_fm].copy()\n                    self.x_max[fk_ge_fm] = x_k_p_1_tmp.copy()\n                    f_k_p_1_tmp = f_k_p_1[fk_ge_fm].copy()\n                    self.f_max[fk_ge_fm] = f_k_p_1_tmp.copy()\n                    gradk_1_tmp = gradk_1[fk_ge_fm].copy()\n                    gradk_1_best[fk_ge_fm] = gradk_1_tmp.copy()\n                    cgradk_1_tmp = cgradk_1[fk_ge_fm].copy()\n                    cgradk_1_best[fk_ge_fm] = cgradk_1_tmp.copy()\n                    x_k = x_k_p_1.copy()\n                    gradk_1 = grad.copy()\n                    cgradk_1 = cgradk.copy()\n                    if k_iter in var_w:\n                        rho = 0.75\n                        condition_1 = self.count_condition_1 < rho * (k_iter - var_w[var_w.index(k_iter) - 1])\n                        condition_2 = np.logical_and((self.eta_w_j_m_1 == eta).squeeze(), self.f_max_w_j_m_1 == self.f_max)\n                        condition = np.logical_or(condition_1, condition_2)\n                        eta[condition] /= 2\n                        x_max_tmp = self.x_max[condition].copy()\n                        x_k[condition] = x_max_tmp.copy()\n                        gradk_1_tmp = gradk_1_best[condition].copy()\n                        gradk_1[condition] = gradk_1_tmp.copy()\n                        cgradk_1_tmp = cgradk_1_best[condition].copy()\n                        cgradk_1[condition] = cgradk_1_tmp.copy()\n                        self.count_condition_1[:] = 0\n                        self.eta_w_j_m_1 = eta.copy()\n                        self.f_max_w_j_m_1 = self.f_max.copy()\n            y_pred_adv_k = self.estimator.predict(x_k)\n            if self.targeted:\n                sample_is_not_robust_k = np.invert(np.argmax(y_pred_adv_k, axis=1) != np.argmax(y_batch, axis=1))\n            elif not self.targeted:\n                sample_is_not_robust_k = np.invert(np.argmax(y_pred_adv_k, axis=1) == np.argmax(y_batch, axis=1))\n            x_robust[batch_index_1:batch_index_2][sample_is_not_robust_k] = x_k[sample_is_not_robust_k]\n        x_adv[sample_is_robust] = x_robust\n    return x_adv",
            "def generate(self, x: np.ndarray, y: Optional[np.ndarray]=None, **kwargs) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Generate adversarial samples and return them in an array.\\n\\n        :param x: An array with the original inputs.\\n        :param y: Target values (class labels) one-hot-encoded of shape `(nb_samples, nb_classes)` or indices of shape\\n                  (nb_samples,). Only provide this parameter if you\\'d like to use true labels when crafting adversarial\\n                  samples. Otherwise, model predictions are used as labels to avoid the \"label leaking\" effect\\n                  (explained in this paper: https://arxiv.org/abs/1611.01236). Default is `None`.\\n        :param mask: An array with a mask broadcastable to input `x` defining where to apply adversarial perturbations.\\n                     Shape needs to be broadcastable to the shape of x and can also be of the same shape as `x`. Any\\n                     features for which the mask is zero will not be adversarially perturbed.\\n        :type mask: `np.ndarray`\\n        :return: An array holding the adversarial examples.\\n        '\n    mask = kwargs.get('mask')\n    if y is not None:\n        y = check_and_transform_label_format(y, nb_classes=self.estimator.nb_classes)\n    if y is None:\n        if self.targeted:\n            raise ValueError('Target labels `y` need to be provided for a targeted attack.')\n        y = get_labels_np_array(self.estimator.predict(x, batch_size=self.batch_size)).astype(int)\n    if self.estimator.nb_classes == 2 and y.shape[1] == 1:\n        raise ValueError('This attack has not yet been tested for binary classification with a single output classifier.')\n    x_adv = x.astype(ART_NUMPY_DTYPE)\n    for _ in trange(max(1, self.nb_random_init), desc='ACG - restart', disable=not self.verbose):\n        y_pred = self.estimator.predict(x_adv)\n        if self.targeted:\n            sample_is_robust = np.argmax(y_pred, axis=1) != np.argmax(y, axis=1)\n        elif not self.targeted:\n            sample_is_robust = np.argmax(y_pred, axis=1) == np.argmax(y, axis=1)\n        if np.sum(sample_is_robust) == 0:\n            break\n        x_robust = x_adv[sample_is_robust]\n        y_robust = y[sample_is_robust]\n        x_init = x[sample_is_robust]\n        n = x_robust.shape[0]\n        m = np.prod(x_robust.shape[1:]).item()\n        random_perturbation = random_sphere(n, m, self.eps, self.norm).reshape(x_robust.shape).astype(ART_NUMPY_DTYPE)\n        x_robust = x_robust + random_perturbation\n        if self.estimator.clip_values is not None:\n            (clip_min, clip_max) = self.estimator.clip_values\n            x_robust = np.clip(x_robust, clip_min, clip_max)\n        perturbation = projection(x_robust - x_init, self.eps, self.norm)\n        x_robust = x_init + perturbation\n        for batch_id in trange(int(np.ceil(x_robust.shape[0] / float(self.batch_size))), desc='ACG - batch', leave=False, disable=not self.verbose):\n            (batch_index_1, batch_index_2) = (batch_id * self.batch_size, (batch_id + 1) * self.batch_size)\n            x_k = x_robust[batch_index_1:batch_index_2].astype(ART_NUMPY_DTYPE)\n            x_init_batch = x_init[batch_index_1:batch_index_2].astype(ART_NUMPY_DTYPE)\n            y_batch = y_robust[batch_index_1:batch_index_2]\n            p_0 = 0\n            p_1 = 0.22\n            var_w = [p_0, p_1]\n            while True:\n                p_j_p_1 = var_w[-1] + max(var_w[-1] - var_w[-2] - 0.03, 0.06)\n                if p_j_p_1 > 1:\n                    break\n                var_w.append(p_j_p_1)\n            var_w = [math.ceil(p * self.max_iter) for p in var_w]\n            _batch_size = x_k.shape[0]\n            eta = np.full((_batch_size,) + (1,) * len(self.estimator.input_shape), self.eps_step).astype(ART_NUMPY_DTYPE)\n            self.count_condition_1 = np.zeros(shape=(_batch_size,))\n            gradk_1 = np.zeros_like(x_k)\n            cgradk_1 = np.zeros_like(x_k)\n            cgradk = np.zeros_like(x_k)\n            gradk_1_best = np.zeros_like(x_k)\n            cgradk_1_best = np.zeros_like(x_k)\n            gradk_1_tmp = np.zeros_like(x_k)\n            cgradk_1_tmp = np.zeros_like(x_k)\n            for k_iter in trange(self.max_iter, desc='ACG - iteration', leave=False, disable=not self.verbose):\n                tol = 1e-07\n                grad = self.estimator.loss_gradient(x_k, y_batch) * (1 - 2 * int(self.targeted))\n                if k_iter == 0:\n                    gradk_1 = grad.copy()\n                    cgradk_1 = grad.copy()\n                    cgradk = grad.copy()\n                else:\n                    beta = get_beta(grad, gradk_1, cgradk_1)\n                    cgradk = grad + beta * cgradk_1\n                if self.norm in [np.inf, 'inf']:\n                    grad = np.sign(cgradk)\n                elif self.norm == 1:\n                    ind = tuple(range(1, len(x_k.shape)))\n                    cgradk = cgradk / (np.sum(np.abs(cgradk), axis=ind, keepdims=True) + tol)\n                elif self.norm == 2:\n                    ind = tuple(range(1, len(x_k.shape)))\n                    cgradk = cgradk / (np.sqrt(np.sum(np.square(cgradk), axis=ind, keepdims=True)) + tol)\n                assert x_k.shape == cgradk.shape\n                perturbation = cgradk\n                if mask is not None:\n                    perturbation = perturbation * mask.astype(ART_NUMPY_DTYPE)\n                x_k_p_1 = x_k + eta * perturbation\n                if self.estimator.clip_values is not None:\n                    (clip_min, clip_max) = self.estimator.clip_values\n                    x_k_p_1 = np.clip(x_k_p_1, clip_min, clip_max)\n                if k_iter == 0:\n                    x_1 = x_k_p_1\n                    perturbation = projection(x_1 - x_init_batch, self.eps, self.norm)\n                    x_1 = x_init_batch + perturbation\n                    f_0 = self.estimator.compute_loss(x=x_k, y=y_batch, reduction='none')\n                    f_1 = self.estimator.compute_loss(x=x_1, y=y_batch, reduction='none')\n                    self.eta_w_j_m_1 = eta.copy()\n                    self.f_max_w_j_m_1 = f_0.copy()\n                    self.f_max = f_0.copy()\n                    self.x_max = x_k.copy()\n                    f1_ge_f0 = f_1 >= f_0\n                    f_1_tmp = f_1[f1_ge_f0].copy()\n                    self.f_max[f1_ge_f0] = f_1_tmp.copy()\n                    x_1_tmp = x_1[f1_ge_f0].copy()\n                    self.x_max[f1_ge_f0] = x_1_tmp.copy()\n                    self.count_condition_1[f1_ge_f0] += 1\n                    x_k = x_1\n                    gradk_1_best = gradk_1.copy()\n                    cgradk_1_best = cgradk_1.copy()\n                else:\n                    perturbation = projection(x_k_p_1 - x_init_batch, self.eps, self.norm)\n                    x_k_p_1 = x_init_batch + perturbation\n                    if self.estimator.clip_values is not None:\n                        (clip_min, clip_max) = self.estimator.clip_values\n                        x_k_p_1 = np.clip(x_k_p_1, clip_min, clip_max)\n                    perturbation = projection(x_k_p_1 - x_init_batch, self.eps, self.norm)\n                    x_k_p_1 = x_init_batch + perturbation\n                    f_k_p_1 = self.estimator.compute_loss(x=x_k_p_1, y=y_batch, reduction='none')\n                    if (f_k_p_1 == 0.0).all():\n                        x_k = x_k_p_1.copy()\n                        break\n                    if self.targeted:\n                        fk_ge_fm = f_k_p_1 < self.f_max\n                    else:\n                        fk_ge_fm = f_k_p_1 > self.f_max\n                    self.count_condition_1[fk_ge_fm] += 1\n                    x_k_p_1_tmp = x_k_p_1[fk_ge_fm].copy()\n                    self.x_max[fk_ge_fm] = x_k_p_1_tmp.copy()\n                    f_k_p_1_tmp = f_k_p_1[fk_ge_fm].copy()\n                    self.f_max[fk_ge_fm] = f_k_p_1_tmp.copy()\n                    gradk_1_tmp = gradk_1[fk_ge_fm].copy()\n                    gradk_1_best[fk_ge_fm] = gradk_1_tmp.copy()\n                    cgradk_1_tmp = cgradk_1[fk_ge_fm].copy()\n                    cgradk_1_best[fk_ge_fm] = cgradk_1_tmp.copy()\n                    x_k = x_k_p_1.copy()\n                    gradk_1 = grad.copy()\n                    cgradk_1 = cgradk.copy()\n                    if k_iter in var_w:\n                        rho = 0.75\n                        condition_1 = self.count_condition_1 < rho * (k_iter - var_w[var_w.index(k_iter) - 1])\n                        condition_2 = np.logical_and((self.eta_w_j_m_1 == eta).squeeze(), self.f_max_w_j_m_1 == self.f_max)\n                        condition = np.logical_or(condition_1, condition_2)\n                        eta[condition] /= 2\n                        x_max_tmp = self.x_max[condition].copy()\n                        x_k[condition] = x_max_tmp.copy()\n                        gradk_1_tmp = gradk_1_best[condition].copy()\n                        gradk_1[condition] = gradk_1_tmp.copy()\n                        cgradk_1_tmp = cgradk_1_best[condition].copy()\n                        cgradk_1[condition] = cgradk_1_tmp.copy()\n                        self.count_condition_1[:] = 0\n                        self.eta_w_j_m_1 = eta.copy()\n                        self.f_max_w_j_m_1 = self.f_max.copy()\n            y_pred_adv_k = self.estimator.predict(x_k)\n            if self.targeted:\n                sample_is_not_robust_k = np.invert(np.argmax(y_pred_adv_k, axis=1) != np.argmax(y_batch, axis=1))\n            elif not self.targeted:\n                sample_is_not_robust_k = np.invert(np.argmax(y_pred_adv_k, axis=1) == np.argmax(y_batch, axis=1))\n            x_robust[batch_index_1:batch_index_2][sample_is_not_robust_k] = x_k[sample_is_not_robust_k]\n        x_adv[sample_is_robust] = x_robust\n    return x_adv"
        ]
    },
    {
        "func_name": "_check_params",
        "original": "def _check_params(self) -> None:\n    if self.norm not in [1, 2, np.inf, 'inf']:\n        raise ValueError('The argument norm has to be either 1, 2, np.inf, or \"inf\".')\n    if not isinstance(self.eps, (int, float)) or self.eps <= 0.0:\n        raise ValueError('The argument eps has to be either of type int or float and larger than zero.')\n    if not isinstance(self.eps_step, (int, float)) or self.eps_step <= 0.0:\n        raise ValueError('The argument eps_step has to be either of type int or float and larger than zero.')\n    if not isinstance(self.max_iter, int) or self.max_iter <= 0:\n        raise ValueError('The argument max_iter has to be of type int and larger than zero.')\n    if not isinstance(self.targeted, bool):\n        raise ValueError('The argument targeted has to be of bool.')\n    if not isinstance(self.nb_random_init, int) or self.nb_random_init <= 0:\n        raise ValueError('The argument nb_random_init has to be of type int and larger than zero.')\n    if not isinstance(self.batch_size, int) or self.batch_size <= 0:\n        raise ValueError('The argument batch_size has to be of type int and larger than zero.')\n    if not isinstance(self.verbose, bool):\n        raise ValueError('The argument `verbose` has to be of type bool.')",
        "mutated": [
            "def _check_params(self) -> None:\n    if False:\n        i = 10\n    if self.norm not in [1, 2, np.inf, 'inf']:\n        raise ValueError('The argument norm has to be either 1, 2, np.inf, or \"inf\".')\n    if not isinstance(self.eps, (int, float)) or self.eps <= 0.0:\n        raise ValueError('The argument eps has to be either of type int or float and larger than zero.')\n    if not isinstance(self.eps_step, (int, float)) or self.eps_step <= 0.0:\n        raise ValueError('The argument eps_step has to be either of type int or float and larger than zero.')\n    if not isinstance(self.max_iter, int) or self.max_iter <= 0:\n        raise ValueError('The argument max_iter has to be of type int and larger than zero.')\n    if not isinstance(self.targeted, bool):\n        raise ValueError('The argument targeted has to be of bool.')\n    if not isinstance(self.nb_random_init, int) or self.nb_random_init <= 0:\n        raise ValueError('The argument nb_random_init has to be of type int and larger than zero.')\n    if not isinstance(self.batch_size, int) or self.batch_size <= 0:\n        raise ValueError('The argument batch_size has to be of type int and larger than zero.')\n    if not isinstance(self.verbose, bool):\n        raise ValueError('The argument `verbose` has to be of type bool.')",
            "def _check_params(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.norm not in [1, 2, np.inf, 'inf']:\n        raise ValueError('The argument norm has to be either 1, 2, np.inf, or \"inf\".')\n    if not isinstance(self.eps, (int, float)) or self.eps <= 0.0:\n        raise ValueError('The argument eps has to be either of type int or float and larger than zero.')\n    if not isinstance(self.eps_step, (int, float)) or self.eps_step <= 0.0:\n        raise ValueError('The argument eps_step has to be either of type int or float and larger than zero.')\n    if not isinstance(self.max_iter, int) or self.max_iter <= 0:\n        raise ValueError('The argument max_iter has to be of type int and larger than zero.')\n    if not isinstance(self.targeted, bool):\n        raise ValueError('The argument targeted has to be of bool.')\n    if not isinstance(self.nb_random_init, int) or self.nb_random_init <= 0:\n        raise ValueError('The argument nb_random_init has to be of type int and larger than zero.')\n    if not isinstance(self.batch_size, int) or self.batch_size <= 0:\n        raise ValueError('The argument batch_size has to be of type int and larger than zero.')\n    if not isinstance(self.verbose, bool):\n        raise ValueError('The argument `verbose` has to be of type bool.')",
            "def _check_params(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.norm not in [1, 2, np.inf, 'inf']:\n        raise ValueError('The argument norm has to be either 1, 2, np.inf, or \"inf\".')\n    if not isinstance(self.eps, (int, float)) or self.eps <= 0.0:\n        raise ValueError('The argument eps has to be either of type int or float and larger than zero.')\n    if not isinstance(self.eps_step, (int, float)) or self.eps_step <= 0.0:\n        raise ValueError('The argument eps_step has to be either of type int or float and larger than zero.')\n    if not isinstance(self.max_iter, int) or self.max_iter <= 0:\n        raise ValueError('The argument max_iter has to be of type int and larger than zero.')\n    if not isinstance(self.targeted, bool):\n        raise ValueError('The argument targeted has to be of bool.')\n    if not isinstance(self.nb_random_init, int) or self.nb_random_init <= 0:\n        raise ValueError('The argument nb_random_init has to be of type int and larger than zero.')\n    if not isinstance(self.batch_size, int) or self.batch_size <= 0:\n        raise ValueError('The argument batch_size has to be of type int and larger than zero.')\n    if not isinstance(self.verbose, bool):\n        raise ValueError('The argument `verbose` has to be of type bool.')",
            "def _check_params(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.norm not in [1, 2, np.inf, 'inf']:\n        raise ValueError('The argument norm has to be either 1, 2, np.inf, or \"inf\".')\n    if not isinstance(self.eps, (int, float)) or self.eps <= 0.0:\n        raise ValueError('The argument eps has to be either of type int or float and larger than zero.')\n    if not isinstance(self.eps_step, (int, float)) or self.eps_step <= 0.0:\n        raise ValueError('The argument eps_step has to be either of type int or float and larger than zero.')\n    if not isinstance(self.max_iter, int) or self.max_iter <= 0:\n        raise ValueError('The argument max_iter has to be of type int and larger than zero.')\n    if not isinstance(self.targeted, bool):\n        raise ValueError('The argument targeted has to be of bool.')\n    if not isinstance(self.nb_random_init, int) or self.nb_random_init <= 0:\n        raise ValueError('The argument nb_random_init has to be of type int and larger than zero.')\n    if not isinstance(self.batch_size, int) or self.batch_size <= 0:\n        raise ValueError('The argument batch_size has to be of type int and larger than zero.')\n    if not isinstance(self.verbose, bool):\n        raise ValueError('The argument `verbose` has to be of type bool.')",
            "def _check_params(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.norm not in [1, 2, np.inf, 'inf']:\n        raise ValueError('The argument norm has to be either 1, 2, np.inf, or \"inf\".')\n    if not isinstance(self.eps, (int, float)) or self.eps <= 0.0:\n        raise ValueError('The argument eps has to be either of type int or float and larger than zero.')\n    if not isinstance(self.eps_step, (int, float)) or self.eps_step <= 0.0:\n        raise ValueError('The argument eps_step has to be either of type int or float and larger than zero.')\n    if not isinstance(self.max_iter, int) or self.max_iter <= 0:\n        raise ValueError('The argument max_iter has to be of type int and larger than zero.')\n    if not isinstance(self.targeted, bool):\n        raise ValueError('The argument targeted has to be of bool.')\n    if not isinstance(self.nb_random_init, int) or self.nb_random_init <= 0:\n        raise ValueError('The argument nb_random_init has to be of type int and larger than zero.')\n    if not isinstance(self.batch_size, int) or self.batch_size <= 0:\n        raise ValueError('The argument batch_size has to be of type int and larger than zero.')\n    if not isinstance(self.verbose, bool):\n        raise ValueError('The argument `verbose` has to be of type bool.')"
        ]
    },
    {
        "func_name": "get_beta",
        "original": "def get_beta(gradk, gradk_1, cgradk_1):\n    \"\"\"compute the coefficient beta required to update CG direction\"\"\"\n    _batch_size = gradk.shape[0]\n    _cgradk_1 = cgradk_1.reshape(_batch_size, -1)\n    _gradk = -gradk.reshape(_batch_size, -1)\n    _gradk_1 = -gradk_1.reshape(_batch_size, -1)\n    delta_gradk = _gradk - _gradk_1\n    betak = -(_gradk * delta_gradk).sum(axis=1) / ((_cgradk_1 * delta_gradk).sum(axis=1) + np.finfo(ART_NUMPY_DTYPE).eps)\n    return betak.reshape((_batch_size,) + (1,) * (len(gradk.shape) - 1))",
        "mutated": [
            "def get_beta(gradk, gradk_1, cgradk_1):\n    if False:\n        i = 10\n    'compute the coefficient beta required to update CG direction'\n    _batch_size = gradk.shape[0]\n    _cgradk_1 = cgradk_1.reshape(_batch_size, -1)\n    _gradk = -gradk.reshape(_batch_size, -1)\n    _gradk_1 = -gradk_1.reshape(_batch_size, -1)\n    delta_gradk = _gradk - _gradk_1\n    betak = -(_gradk * delta_gradk).sum(axis=1) / ((_cgradk_1 * delta_gradk).sum(axis=1) + np.finfo(ART_NUMPY_DTYPE).eps)\n    return betak.reshape((_batch_size,) + (1,) * (len(gradk.shape) - 1))",
            "def get_beta(gradk, gradk_1, cgradk_1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'compute the coefficient beta required to update CG direction'\n    _batch_size = gradk.shape[0]\n    _cgradk_1 = cgradk_1.reshape(_batch_size, -1)\n    _gradk = -gradk.reshape(_batch_size, -1)\n    _gradk_1 = -gradk_1.reshape(_batch_size, -1)\n    delta_gradk = _gradk - _gradk_1\n    betak = -(_gradk * delta_gradk).sum(axis=1) / ((_cgradk_1 * delta_gradk).sum(axis=1) + np.finfo(ART_NUMPY_DTYPE).eps)\n    return betak.reshape((_batch_size,) + (1,) * (len(gradk.shape) - 1))",
            "def get_beta(gradk, gradk_1, cgradk_1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'compute the coefficient beta required to update CG direction'\n    _batch_size = gradk.shape[0]\n    _cgradk_1 = cgradk_1.reshape(_batch_size, -1)\n    _gradk = -gradk.reshape(_batch_size, -1)\n    _gradk_1 = -gradk_1.reshape(_batch_size, -1)\n    delta_gradk = _gradk - _gradk_1\n    betak = -(_gradk * delta_gradk).sum(axis=1) / ((_cgradk_1 * delta_gradk).sum(axis=1) + np.finfo(ART_NUMPY_DTYPE).eps)\n    return betak.reshape((_batch_size,) + (1,) * (len(gradk.shape) - 1))",
            "def get_beta(gradk, gradk_1, cgradk_1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'compute the coefficient beta required to update CG direction'\n    _batch_size = gradk.shape[0]\n    _cgradk_1 = cgradk_1.reshape(_batch_size, -1)\n    _gradk = -gradk.reshape(_batch_size, -1)\n    _gradk_1 = -gradk_1.reshape(_batch_size, -1)\n    delta_gradk = _gradk - _gradk_1\n    betak = -(_gradk * delta_gradk).sum(axis=1) / ((_cgradk_1 * delta_gradk).sum(axis=1) + np.finfo(ART_NUMPY_DTYPE).eps)\n    return betak.reshape((_batch_size,) + (1,) * (len(gradk.shape) - 1))",
            "def get_beta(gradk, gradk_1, cgradk_1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'compute the coefficient beta required to update CG direction'\n    _batch_size = gradk.shape[0]\n    _cgradk_1 = cgradk_1.reshape(_batch_size, -1)\n    _gradk = -gradk.reshape(_batch_size, -1)\n    _gradk_1 = -gradk_1.reshape(_batch_size, -1)\n    delta_gradk = _gradk - _gradk_1\n    betak = -(_gradk * delta_gradk).sum(axis=1) / ((_cgradk_1 * delta_gradk).sum(axis=1) + np.finfo(ART_NUMPY_DTYPE).eps)\n    return betak.reshape((_batch_size,) + (1,) * (len(gradk.shape) - 1))"
        ]
    }
]