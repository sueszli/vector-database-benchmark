[
    {
        "func_name": "_true_std_time_dep",
        "original": "def _true_std_time_dep(t, intervals, vol, k):\n    res = np.zeros_like(t, dtype=np.float64)\n    for (i, tt) in enumerate(t):\n        var = 0.0\n        for j in range(len(intervals) - 1):\n            if tt >= intervals[j] and tt < intervals[j + 1]:\n                var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[j]))\n                break\n            else:\n                var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * intervals[j + 1]) - np.exp(2 * k * intervals[j]))\n        else:\n            var = var + vol[-1] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[-1]))\n        res[i] = np.exp(-k * tt) * np.sqrt(var)\n    return res",
        "mutated": [
            "def _true_std_time_dep(t, intervals, vol, k):\n    if False:\n        i = 10\n    res = np.zeros_like(t, dtype=np.float64)\n    for (i, tt) in enumerate(t):\n        var = 0.0\n        for j in range(len(intervals) - 1):\n            if tt >= intervals[j] and tt < intervals[j + 1]:\n                var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[j]))\n                break\n            else:\n                var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * intervals[j + 1]) - np.exp(2 * k * intervals[j]))\n        else:\n            var = var + vol[-1] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[-1]))\n        res[i] = np.exp(-k * tt) * np.sqrt(var)\n    return res",
            "def _true_std_time_dep(t, intervals, vol, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    res = np.zeros_like(t, dtype=np.float64)\n    for (i, tt) in enumerate(t):\n        var = 0.0\n        for j in range(len(intervals) - 1):\n            if tt >= intervals[j] and tt < intervals[j + 1]:\n                var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[j]))\n                break\n            else:\n                var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * intervals[j + 1]) - np.exp(2 * k * intervals[j]))\n        else:\n            var = var + vol[-1] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[-1]))\n        res[i] = np.exp(-k * tt) * np.sqrt(var)\n    return res",
            "def _true_std_time_dep(t, intervals, vol, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    res = np.zeros_like(t, dtype=np.float64)\n    for (i, tt) in enumerate(t):\n        var = 0.0\n        for j in range(len(intervals) - 1):\n            if tt >= intervals[j] and tt < intervals[j + 1]:\n                var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[j]))\n                break\n            else:\n                var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * intervals[j + 1]) - np.exp(2 * k * intervals[j]))\n        else:\n            var = var + vol[-1] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[-1]))\n        res[i] = np.exp(-k * tt) * np.sqrt(var)\n    return res",
            "def _true_std_time_dep(t, intervals, vol, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    res = np.zeros_like(t, dtype=np.float64)\n    for (i, tt) in enumerate(t):\n        var = 0.0\n        for j in range(len(intervals) - 1):\n            if tt >= intervals[j] and tt < intervals[j + 1]:\n                var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[j]))\n                break\n            else:\n                var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * intervals[j + 1]) - np.exp(2 * k * intervals[j]))\n        else:\n            var = var + vol[-1] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[-1]))\n        res[i] = np.exp(-k * tt) * np.sqrt(var)\n    return res",
            "def _true_std_time_dep(t, intervals, vol, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    res = np.zeros_like(t, dtype=np.float64)\n    for (i, tt) in enumerate(t):\n        var = 0.0\n        for j in range(len(intervals) - 1):\n            if tt >= intervals[j] and tt < intervals[j + 1]:\n                var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[j]))\n                break\n            else:\n                var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * intervals[j + 1]) - np.exp(2 * k * intervals[j]))\n        else:\n            var = var + vol[-1] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[-1]))\n        res[i] = np.exp(-k * tt) * np.sqrt(var)\n    return res"
        ]
    },
    {
        "func_name": "_true_zcb_std",
        "original": "def _true_zcb_std(t, tau, v, k):\n    e_tau = np.exp(-k * tau)\n    et = np.exp(k * t)\n    val = v / k * (1.0 - e_tau * et) * np.sqrt((1.0 - 1.0 / et / et) / k / 2)\n    return val",
        "mutated": [
            "def _true_zcb_std(t, tau, v, k):\n    if False:\n        i = 10\n    e_tau = np.exp(-k * tau)\n    et = np.exp(k * t)\n    val = v / k * (1.0 - e_tau * et) * np.sqrt((1.0 - 1.0 / et / et) / k / 2)\n    return val",
            "def _true_zcb_std(t, tau, v, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    e_tau = np.exp(-k * tau)\n    et = np.exp(k * t)\n    val = v / k * (1.0 - e_tau * et) * np.sqrt((1.0 - 1.0 / et / et) / k / 2)\n    return val",
            "def _true_zcb_std(t, tau, v, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    e_tau = np.exp(-k * tau)\n    et = np.exp(k * t)\n    val = v / k * (1.0 - e_tau * et) * np.sqrt((1.0 - 1.0 / et / et) / k / 2)\n    return val",
            "def _true_zcb_std(t, tau, v, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    e_tau = np.exp(-k * tau)\n    et = np.exp(k * t)\n    val = v / k * (1.0 - e_tau * et) * np.sqrt((1.0 - 1.0 / et / et) / k / 2)\n    return val",
            "def _true_zcb_std(t, tau, v, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    e_tau = np.exp(-k * tau)\n    et = np.exp(k * t)\n    val = v / k * (1.0 - e_tau * et) * np.sqrt((1.0 - 1.0 / et / et) / k / 2)\n    return val"
        ]
    },
    {
        "func_name": "setUp",
        "original": "def setUp(self):\n    self.instant_forward_rate = lambda *args: [0.01]\n\n    def _true_std_time_dep(t, intervals, vol, k):\n        res = np.zeros_like(t, dtype=np.float64)\n        for (i, tt) in enumerate(t):\n            var = 0.0\n            for j in range(len(intervals) - 1):\n                if tt >= intervals[j] and tt < intervals[j + 1]:\n                    var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[j]))\n                    break\n                else:\n                    var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * intervals[j + 1]) - np.exp(2 * k * intervals[j]))\n            else:\n                var = var + vol[-1] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[-1]))\n            res[i] = np.exp(-k * tt) * np.sqrt(var)\n        return res\n    self.true_std_time_dep = _true_std_time_dep\n\n    def _true_zcb_std(t, tau, v, k):\n        e_tau = np.exp(-k * tau)\n        et = np.exp(k * t)\n        val = v / k * (1.0 - e_tau * et) * np.sqrt((1.0 - 1.0 / et / et) / k / 2)\n        return val\n    self.true_zcb_std = _true_zcb_std\n    super(GaussianHJMModelTest, self).setUp()",
        "mutated": [
            "def setUp(self):\n    if False:\n        i = 10\n    self.instant_forward_rate = lambda *args: [0.01]\n\n    def _true_std_time_dep(t, intervals, vol, k):\n        res = np.zeros_like(t, dtype=np.float64)\n        for (i, tt) in enumerate(t):\n            var = 0.0\n            for j in range(len(intervals) - 1):\n                if tt >= intervals[j] and tt < intervals[j + 1]:\n                    var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[j]))\n                    break\n                else:\n                    var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * intervals[j + 1]) - np.exp(2 * k * intervals[j]))\n            else:\n                var = var + vol[-1] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[-1]))\n            res[i] = np.exp(-k * tt) * np.sqrt(var)\n        return res\n    self.true_std_time_dep = _true_std_time_dep\n\n    def _true_zcb_std(t, tau, v, k):\n        e_tau = np.exp(-k * tau)\n        et = np.exp(k * t)\n        val = v / k * (1.0 - e_tau * et) * np.sqrt((1.0 - 1.0 / et / et) / k / 2)\n        return val\n    self.true_zcb_std = _true_zcb_std\n    super(GaussianHJMModelTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.instant_forward_rate = lambda *args: [0.01]\n\n    def _true_std_time_dep(t, intervals, vol, k):\n        res = np.zeros_like(t, dtype=np.float64)\n        for (i, tt) in enumerate(t):\n            var = 0.0\n            for j in range(len(intervals) - 1):\n                if tt >= intervals[j] and tt < intervals[j + 1]:\n                    var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[j]))\n                    break\n                else:\n                    var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * intervals[j + 1]) - np.exp(2 * k * intervals[j]))\n            else:\n                var = var + vol[-1] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[-1]))\n            res[i] = np.exp(-k * tt) * np.sqrt(var)\n        return res\n    self.true_std_time_dep = _true_std_time_dep\n\n    def _true_zcb_std(t, tau, v, k):\n        e_tau = np.exp(-k * tau)\n        et = np.exp(k * t)\n        val = v / k * (1.0 - e_tau * et) * np.sqrt((1.0 - 1.0 / et / et) / k / 2)\n        return val\n    self.true_zcb_std = _true_zcb_std\n    super(GaussianHJMModelTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.instant_forward_rate = lambda *args: [0.01]\n\n    def _true_std_time_dep(t, intervals, vol, k):\n        res = np.zeros_like(t, dtype=np.float64)\n        for (i, tt) in enumerate(t):\n            var = 0.0\n            for j in range(len(intervals) - 1):\n                if tt >= intervals[j] and tt < intervals[j + 1]:\n                    var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[j]))\n                    break\n                else:\n                    var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * intervals[j + 1]) - np.exp(2 * k * intervals[j]))\n            else:\n                var = var + vol[-1] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[-1]))\n            res[i] = np.exp(-k * tt) * np.sqrt(var)\n        return res\n    self.true_std_time_dep = _true_std_time_dep\n\n    def _true_zcb_std(t, tau, v, k):\n        e_tau = np.exp(-k * tau)\n        et = np.exp(k * t)\n        val = v / k * (1.0 - e_tau * et) * np.sqrt((1.0 - 1.0 / et / et) / k / 2)\n        return val\n    self.true_zcb_std = _true_zcb_std\n    super(GaussianHJMModelTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.instant_forward_rate = lambda *args: [0.01]\n\n    def _true_std_time_dep(t, intervals, vol, k):\n        res = np.zeros_like(t, dtype=np.float64)\n        for (i, tt) in enumerate(t):\n            var = 0.0\n            for j in range(len(intervals) - 1):\n                if tt >= intervals[j] and tt < intervals[j + 1]:\n                    var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[j]))\n                    break\n                else:\n                    var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * intervals[j + 1]) - np.exp(2 * k * intervals[j]))\n            else:\n                var = var + vol[-1] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[-1]))\n            res[i] = np.exp(-k * tt) * np.sqrt(var)\n        return res\n    self.true_std_time_dep = _true_std_time_dep\n\n    def _true_zcb_std(t, tau, v, k):\n        e_tau = np.exp(-k * tau)\n        et = np.exp(k * t)\n        val = v / k * (1.0 - e_tau * et) * np.sqrt((1.0 - 1.0 / et / et) / k / 2)\n        return val\n    self.true_zcb_std = _true_zcb_std\n    super(GaussianHJMModelTest, self).setUp()",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.instant_forward_rate = lambda *args: [0.01]\n\n    def _true_std_time_dep(t, intervals, vol, k):\n        res = np.zeros_like(t, dtype=np.float64)\n        for (i, tt) in enumerate(t):\n            var = 0.0\n            for j in range(len(intervals) - 1):\n                if tt >= intervals[j] and tt < intervals[j + 1]:\n                    var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[j]))\n                    break\n                else:\n                    var = var + vol[j] ** 2 / 2 / k * (np.exp(2 * k * intervals[j + 1]) - np.exp(2 * k * intervals[j]))\n            else:\n                var = var + vol[-1] ** 2 / 2 / k * (np.exp(2 * k * tt) - np.exp(2 * k * intervals[-1]))\n            res[i] = np.exp(-k * tt) * np.sqrt(var)\n        return res\n    self.true_std_time_dep = _true_std_time_dep\n\n    def _true_zcb_std(t, tau, v, k):\n        e_tau = np.exp(-k * tau)\n        et = np.exp(k * t)\n        val = v / k * (1.0 - e_tau * et) * np.sqrt((1.0 - 1.0 / et / et) / k / 2)\n        return val\n    self.true_zcb_std = _true_zcb_std\n    super(GaussianHJMModelTest, self).setUp()"
        ]
    },
    {
        "func_name": "test_correctness_rate_df_sims",
        "original": "@parameterized.named_parameters({'testcase_name': '1f_constant', 'dim': 1, 'mr': [0.03], 'vol': [0.01], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float32}, {'testcase_name': '1f_constant_num_time_steps', 'dim': 1, 'mr': [0.03], 'vol': [0.01], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': 21, 'dtype': tf.float64}, {'testcase_name': '1f_time_dep', 'dim': 1, 'mr': [0.03], 'vol': None, 'corr': None, 'vol_jumps': [[0.5, 1.0]], 'vol_values': [[0.01, 0.02, 0.01]], 'num_time_steps': None, 'dtype': None}, {'testcase_name': '2f_constant', 'dim': 2, 'mr': [0.03, 0.1], 'vol': [0.005, 0.012], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float64}, {'testcase_name': '2f_constant_with_corr', 'dim': 2, 'mr': [0.03, 0.1], 'vol': [0.005, 0.012], 'corr': [[1.0, 0.5], [0.5, 1.0]], 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float64}, {'testcase_name': '2f_time_dep', 'dim': 2, 'mr': [0.03, 0.1], 'vol': None, 'corr': None, 'vol_jumps': [[0.5, 1.0], [0.5, 1.0]], 'vol_values': [[0.005, 0.008, 0.005], [0.005, 0.008, 0.005]], 'num_time_steps': None, 'dtype': tf.float64})\ndef test_correctness_rate_df_sims(self, dim, mr, vol, corr, vol_jumps, vol_values, num_time_steps, dtype):\n    \"\"\"Tests short rate and discount factor simulations.\"\"\"\n    if vol is None:\n        vol = tff.math.piecewise.PiecewiseConstantFunc(vol_jumps, vol_values, dtype=dtype)\n    time_step = None if num_time_steps else 0.1\n    num_samples = 100000\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    times = np.array([0.1, 0.5, 1.0, 2.0])\n    (paths, df, _, _) = process.sample_paths(times, num_samples=num_samples, time_step=time_step, num_time_steps=num_time_steps, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], skip=1000000)\n    if dtype is not None:\n        with self.subTest('Dtype'):\n            self.assertEqual(paths.dtype, dtype)\n    paths = self.evaluate(paths)\n    df = self.evaluate(df)\n    with self.subTest('ShapePaths'):\n        self.assertAllEqual(paths.shape, [num_samples, 4])\n    with self.subTest('ShapeDiscountFactors'):\n        self.assertAllEqual(df.shape, [num_samples, 4])\n    discount_mean = np.mean(df, axis=0)\n    expected_mean = np.exp(-0.01 * times)\n    with self.subTest('DiscountMean'):\n        self.assertAllClose(discount_mean, expected_mean, rtol=0.001, atol=0.001)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': '1f_constant', 'dim': 1, 'mr': [0.03], 'vol': [0.01], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float32}, {'testcase_name': '1f_constant_num_time_steps', 'dim': 1, 'mr': [0.03], 'vol': [0.01], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': 21, 'dtype': tf.float64}, {'testcase_name': '1f_time_dep', 'dim': 1, 'mr': [0.03], 'vol': None, 'corr': None, 'vol_jumps': [[0.5, 1.0]], 'vol_values': [[0.01, 0.02, 0.01]], 'num_time_steps': None, 'dtype': None}, {'testcase_name': '2f_constant', 'dim': 2, 'mr': [0.03, 0.1], 'vol': [0.005, 0.012], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float64}, {'testcase_name': '2f_constant_with_corr', 'dim': 2, 'mr': [0.03, 0.1], 'vol': [0.005, 0.012], 'corr': [[1.0, 0.5], [0.5, 1.0]], 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float64}, {'testcase_name': '2f_time_dep', 'dim': 2, 'mr': [0.03, 0.1], 'vol': None, 'corr': None, 'vol_jumps': [[0.5, 1.0], [0.5, 1.0]], 'vol_values': [[0.005, 0.008, 0.005], [0.005, 0.008, 0.005]], 'num_time_steps': None, 'dtype': tf.float64})\ndef test_correctness_rate_df_sims(self, dim, mr, vol, corr, vol_jumps, vol_values, num_time_steps, dtype):\n    if False:\n        i = 10\n    'Tests short rate and discount factor simulations.'\n    if vol is None:\n        vol = tff.math.piecewise.PiecewiseConstantFunc(vol_jumps, vol_values, dtype=dtype)\n    time_step = None if num_time_steps else 0.1\n    num_samples = 100000\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    times = np.array([0.1, 0.5, 1.0, 2.0])\n    (paths, df, _, _) = process.sample_paths(times, num_samples=num_samples, time_step=time_step, num_time_steps=num_time_steps, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], skip=1000000)\n    if dtype is not None:\n        with self.subTest('Dtype'):\n            self.assertEqual(paths.dtype, dtype)\n    paths = self.evaluate(paths)\n    df = self.evaluate(df)\n    with self.subTest('ShapePaths'):\n        self.assertAllEqual(paths.shape, [num_samples, 4])\n    with self.subTest('ShapeDiscountFactors'):\n        self.assertAllEqual(df.shape, [num_samples, 4])\n    discount_mean = np.mean(df, axis=0)\n    expected_mean = np.exp(-0.01 * times)\n    with self.subTest('DiscountMean'):\n        self.assertAllClose(discount_mean, expected_mean, rtol=0.001, atol=0.001)",
            "@parameterized.named_parameters({'testcase_name': '1f_constant', 'dim': 1, 'mr': [0.03], 'vol': [0.01], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float32}, {'testcase_name': '1f_constant_num_time_steps', 'dim': 1, 'mr': [0.03], 'vol': [0.01], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': 21, 'dtype': tf.float64}, {'testcase_name': '1f_time_dep', 'dim': 1, 'mr': [0.03], 'vol': None, 'corr': None, 'vol_jumps': [[0.5, 1.0]], 'vol_values': [[0.01, 0.02, 0.01]], 'num_time_steps': None, 'dtype': None}, {'testcase_name': '2f_constant', 'dim': 2, 'mr': [0.03, 0.1], 'vol': [0.005, 0.012], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float64}, {'testcase_name': '2f_constant_with_corr', 'dim': 2, 'mr': [0.03, 0.1], 'vol': [0.005, 0.012], 'corr': [[1.0, 0.5], [0.5, 1.0]], 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float64}, {'testcase_name': '2f_time_dep', 'dim': 2, 'mr': [0.03, 0.1], 'vol': None, 'corr': None, 'vol_jumps': [[0.5, 1.0], [0.5, 1.0]], 'vol_values': [[0.005, 0.008, 0.005], [0.005, 0.008, 0.005]], 'num_time_steps': None, 'dtype': tf.float64})\ndef test_correctness_rate_df_sims(self, dim, mr, vol, corr, vol_jumps, vol_values, num_time_steps, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests short rate and discount factor simulations.'\n    if vol is None:\n        vol = tff.math.piecewise.PiecewiseConstantFunc(vol_jumps, vol_values, dtype=dtype)\n    time_step = None if num_time_steps else 0.1\n    num_samples = 100000\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    times = np.array([0.1, 0.5, 1.0, 2.0])\n    (paths, df, _, _) = process.sample_paths(times, num_samples=num_samples, time_step=time_step, num_time_steps=num_time_steps, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], skip=1000000)\n    if dtype is not None:\n        with self.subTest('Dtype'):\n            self.assertEqual(paths.dtype, dtype)\n    paths = self.evaluate(paths)\n    df = self.evaluate(df)\n    with self.subTest('ShapePaths'):\n        self.assertAllEqual(paths.shape, [num_samples, 4])\n    with self.subTest('ShapeDiscountFactors'):\n        self.assertAllEqual(df.shape, [num_samples, 4])\n    discount_mean = np.mean(df, axis=0)\n    expected_mean = np.exp(-0.01 * times)\n    with self.subTest('DiscountMean'):\n        self.assertAllClose(discount_mean, expected_mean, rtol=0.001, atol=0.001)",
            "@parameterized.named_parameters({'testcase_name': '1f_constant', 'dim': 1, 'mr': [0.03], 'vol': [0.01], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float32}, {'testcase_name': '1f_constant_num_time_steps', 'dim': 1, 'mr': [0.03], 'vol': [0.01], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': 21, 'dtype': tf.float64}, {'testcase_name': '1f_time_dep', 'dim': 1, 'mr': [0.03], 'vol': None, 'corr': None, 'vol_jumps': [[0.5, 1.0]], 'vol_values': [[0.01, 0.02, 0.01]], 'num_time_steps': None, 'dtype': None}, {'testcase_name': '2f_constant', 'dim': 2, 'mr': [0.03, 0.1], 'vol': [0.005, 0.012], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float64}, {'testcase_name': '2f_constant_with_corr', 'dim': 2, 'mr': [0.03, 0.1], 'vol': [0.005, 0.012], 'corr': [[1.0, 0.5], [0.5, 1.0]], 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float64}, {'testcase_name': '2f_time_dep', 'dim': 2, 'mr': [0.03, 0.1], 'vol': None, 'corr': None, 'vol_jumps': [[0.5, 1.0], [0.5, 1.0]], 'vol_values': [[0.005, 0.008, 0.005], [0.005, 0.008, 0.005]], 'num_time_steps': None, 'dtype': tf.float64})\ndef test_correctness_rate_df_sims(self, dim, mr, vol, corr, vol_jumps, vol_values, num_time_steps, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests short rate and discount factor simulations.'\n    if vol is None:\n        vol = tff.math.piecewise.PiecewiseConstantFunc(vol_jumps, vol_values, dtype=dtype)\n    time_step = None if num_time_steps else 0.1\n    num_samples = 100000\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    times = np.array([0.1, 0.5, 1.0, 2.0])\n    (paths, df, _, _) = process.sample_paths(times, num_samples=num_samples, time_step=time_step, num_time_steps=num_time_steps, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], skip=1000000)\n    if dtype is not None:\n        with self.subTest('Dtype'):\n            self.assertEqual(paths.dtype, dtype)\n    paths = self.evaluate(paths)\n    df = self.evaluate(df)\n    with self.subTest('ShapePaths'):\n        self.assertAllEqual(paths.shape, [num_samples, 4])\n    with self.subTest('ShapeDiscountFactors'):\n        self.assertAllEqual(df.shape, [num_samples, 4])\n    discount_mean = np.mean(df, axis=0)\n    expected_mean = np.exp(-0.01 * times)\n    with self.subTest('DiscountMean'):\n        self.assertAllClose(discount_mean, expected_mean, rtol=0.001, atol=0.001)",
            "@parameterized.named_parameters({'testcase_name': '1f_constant', 'dim': 1, 'mr': [0.03], 'vol': [0.01], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float32}, {'testcase_name': '1f_constant_num_time_steps', 'dim': 1, 'mr': [0.03], 'vol': [0.01], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': 21, 'dtype': tf.float64}, {'testcase_name': '1f_time_dep', 'dim': 1, 'mr': [0.03], 'vol': None, 'corr': None, 'vol_jumps': [[0.5, 1.0]], 'vol_values': [[0.01, 0.02, 0.01]], 'num_time_steps': None, 'dtype': None}, {'testcase_name': '2f_constant', 'dim': 2, 'mr': [0.03, 0.1], 'vol': [0.005, 0.012], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float64}, {'testcase_name': '2f_constant_with_corr', 'dim': 2, 'mr': [0.03, 0.1], 'vol': [0.005, 0.012], 'corr': [[1.0, 0.5], [0.5, 1.0]], 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float64}, {'testcase_name': '2f_time_dep', 'dim': 2, 'mr': [0.03, 0.1], 'vol': None, 'corr': None, 'vol_jumps': [[0.5, 1.0], [0.5, 1.0]], 'vol_values': [[0.005, 0.008, 0.005], [0.005, 0.008, 0.005]], 'num_time_steps': None, 'dtype': tf.float64})\ndef test_correctness_rate_df_sims(self, dim, mr, vol, corr, vol_jumps, vol_values, num_time_steps, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests short rate and discount factor simulations.'\n    if vol is None:\n        vol = tff.math.piecewise.PiecewiseConstantFunc(vol_jumps, vol_values, dtype=dtype)\n    time_step = None if num_time_steps else 0.1\n    num_samples = 100000\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    times = np.array([0.1, 0.5, 1.0, 2.0])\n    (paths, df, _, _) = process.sample_paths(times, num_samples=num_samples, time_step=time_step, num_time_steps=num_time_steps, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], skip=1000000)\n    if dtype is not None:\n        with self.subTest('Dtype'):\n            self.assertEqual(paths.dtype, dtype)\n    paths = self.evaluate(paths)\n    df = self.evaluate(df)\n    with self.subTest('ShapePaths'):\n        self.assertAllEqual(paths.shape, [num_samples, 4])\n    with self.subTest('ShapeDiscountFactors'):\n        self.assertAllEqual(df.shape, [num_samples, 4])\n    discount_mean = np.mean(df, axis=0)\n    expected_mean = np.exp(-0.01 * times)\n    with self.subTest('DiscountMean'):\n        self.assertAllClose(discount_mean, expected_mean, rtol=0.001, atol=0.001)",
            "@parameterized.named_parameters({'testcase_name': '1f_constant', 'dim': 1, 'mr': [0.03], 'vol': [0.01], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float32}, {'testcase_name': '1f_constant_num_time_steps', 'dim': 1, 'mr': [0.03], 'vol': [0.01], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': 21, 'dtype': tf.float64}, {'testcase_name': '1f_time_dep', 'dim': 1, 'mr': [0.03], 'vol': None, 'corr': None, 'vol_jumps': [[0.5, 1.0]], 'vol_values': [[0.01, 0.02, 0.01]], 'num_time_steps': None, 'dtype': None}, {'testcase_name': '2f_constant', 'dim': 2, 'mr': [0.03, 0.1], 'vol': [0.005, 0.012], 'corr': None, 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float64}, {'testcase_name': '2f_constant_with_corr', 'dim': 2, 'mr': [0.03, 0.1], 'vol': [0.005, 0.012], 'corr': [[1.0, 0.5], [0.5, 1.0]], 'vol_jumps': None, 'vol_values': None, 'num_time_steps': None, 'dtype': tf.float64}, {'testcase_name': '2f_time_dep', 'dim': 2, 'mr': [0.03, 0.1], 'vol': None, 'corr': None, 'vol_jumps': [[0.5, 1.0], [0.5, 1.0]], 'vol_values': [[0.005, 0.008, 0.005], [0.005, 0.008, 0.005]], 'num_time_steps': None, 'dtype': tf.float64})\ndef test_correctness_rate_df_sims(self, dim, mr, vol, corr, vol_jumps, vol_values, num_time_steps, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests short rate and discount factor simulations.'\n    if vol is None:\n        vol = tff.math.piecewise.PiecewiseConstantFunc(vol_jumps, vol_values, dtype=dtype)\n    time_step = None if num_time_steps else 0.1\n    num_samples = 100000\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    times = np.array([0.1, 0.5, 1.0, 2.0])\n    (paths, df, _, _) = process.sample_paths(times, num_samples=num_samples, time_step=time_step, num_time_steps=num_time_steps, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], skip=1000000)\n    if dtype is not None:\n        with self.subTest('Dtype'):\n            self.assertEqual(paths.dtype, dtype)\n    paths = self.evaluate(paths)\n    df = self.evaluate(df)\n    with self.subTest('ShapePaths'):\n        self.assertAllEqual(paths.shape, [num_samples, 4])\n    with self.subTest('ShapeDiscountFactors'):\n        self.assertAllEqual(df.shape, [num_samples, 4])\n    discount_mean = np.mean(df, axis=0)\n    expected_mean = np.exp(-0.01 * times)\n    with self.subTest('DiscountMean'):\n        self.assertAllClose(discount_mean, expected_mean, rtol=0.001, atol=0.001)"
        ]
    },
    {
        "func_name": "test_correctness_zcb_sims",
        "original": "@parameterized.named_parameters({'testcase_name': '1f_constant', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'factor': 1.0}, {'testcase_name': '2f_constant', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'factor': np.sqrt(2.0)}, {'testcase_name': '2f_constant_with_corr', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': [[1.0, 0.5], [0.5, 1.0]], 'factor': np.sqrt(3.0)})\ndef test_correctness_zcb_sims(self, dim, mr, vol, corr, factor):\n    \"\"\"Tests discount bond simulations.\"\"\"\n    dtype = np.float64\n    num_samples = 100000\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    times = np.array([0.1, 0.5, 1.0, 2.0])\n    curve_times = np.array([0.0, 0.5, 1.0, 2.0, 5.0])\n    (paths, _, _) = process.sample_discount_curve_paths(times, curve_times=curve_times, num_samples=num_samples, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], skip=1000000)\n    self.assertEqual(paths.dtype, dtype)\n    paths = self.evaluate(paths)\n    self.assertAllEqual(paths.shape, [num_samples, 5, 4])\n    sampled_std = tf.math.reduce_std(tf.math.log(paths), axis=0)\n    for tidx in range(4):\n        true_std = self.true_zcb_std(times[tidx], curve_times + times[tidx], 0.005, 0.03)\n        self.assertAllClose(sampled_std[:, tidx], factor * true_std, rtol=0.001, atol=0.001)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': '1f_constant', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'factor': 1.0}, {'testcase_name': '2f_constant', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'factor': np.sqrt(2.0)}, {'testcase_name': '2f_constant_with_corr', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': [[1.0, 0.5], [0.5, 1.0]], 'factor': np.sqrt(3.0)})\ndef test_correctness_zcb_sims(self, dim, mr, vol, corr, factor):\n    if False:\n        i = 10\n    'Tests discount bond simulations.'\n    dtype = np.float64\n    num_samples = 100000\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    times = np.array([0.1, 0.5, 1.0, 2.0])\n    curve_times = np.array([0.0, 0.5, 1.0, 2.0, 5.0])\n    (paths, _, _) = process.sample_discount_curve_paths(times, curve_times=curve_times, num_samples=num_samples, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], skip=1000000)\n    self.assertEqual(paths.dtype, dtype)\n    paths = self.evaluate(paths)\n    self.assertAllEqual(paths.shape, [num_samples, 5, 4])\n    sampled_std = tf.math.reduce_std(tf.math.log(paths), axis=0)\n    for tidx in range(4):\n        true_std = self.true_zcb_std(times[tidx], curve_times + times[tidx], 0.005, 0.03)\n        self.assertAllClose(sampled_std[:, tidx], factor * true_std, rtol=0.001, atol=0.001)",
            "@parameterized.named_parameters({'testcase_name': '1f_constant', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'factor': 1.0}, {'testcase_name': '2f_constant', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'factor': np.sqrt(2.0)}, {'testcase_name': '2f_constant_with_corr', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': [[1.0, 0.5], [0.5, 1.0]], 'factor': np.sqrt(3.0)})\ndef test_correctness_zcb_sims(self, dim, mr, vol, corr, factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests discount bond simulations.'\n    dtype = np.float64\n    num_samples = 100000\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    times = np.array([0.1, 0.5, 1.0, 2.0])\n    curve_times = np.array([0.0, 0.5, 1.0, 2.0, 5.0])\n    (paths, _, _) = process.sample_discount_curve_paths(times, curve_times=curve_times, num_samples=num_samples, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], skip=1000000)\n    self.assertEqual(paths.dtype, dtype)\n    paths = self.evaluate(paths)\n    self.assertAllEqual(paths.shape, [num_samples, 5, 4])\n    sampled_std = tf.math.reduce_std(tf.math.log(paths), axis=0)\n    for tidx in range(4):\n        true_std = self.true_zcb_std(times[tidx], curve_times + times[tidx], 0.005, 0.03)\n        self.assertAllClose(sampled_std[:, tidx], factor * true_std, rtol=0.001, atol=0.001)",
            "@parameterized.named_parameters({'testcase_name': '1f_constant', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'factor': 1.0}, {'testcase_name': '2f_constant', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'factor': np.sqrt(2.0)}, {'testcase_name': '2f_constant_with_corr', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': [[1.0, 0.5], [0.5, 1.0]], 'factor': np.sqrt(3.0)})\ndef test_correctness_zcb_sims(self, dim, mr, vol, corr, factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests discount bond simulations.'\n    dtype = np.float64\n    num_samples = 100000\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    times = np.array([0.1, 0.5, 1.0, 2.0])\n    curve_times = np.array([0.0, 0.5, 1.0, 2.0, 5.0])\n    (paths, _, _) = process.sample_discount_curve_paths(times, curve_times=curve_times, num_samples=num_samples, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], skip=1000000)\n    self.assertEqual(paths.dtype, dtype)\n    paths = self.evaluate(paths)\n    self.assertAllEqual(paths.shape, [num_samples, 5, 4])\n    sampled_std = tf.math.reduce_std(tf.math.log(paths), axis=0)\n    for tidx in range(4):\n        true_std = self.true_zcb_std(times[tidx], curve_times + times[tidx], 0.005, 0.03)\n        self.assertAllClose(sampled_std[:, tidx], factor * true_std, rtol=0.001, atol=0.001)",
            "@parameterized.named_parameters({'testcase_name': '1f_constant', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'factor': 1.0}, {'testcase_name': '2f_constant', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'factor': np.sqrt(2.0)}, {'testcase_name': '2f_constant_with_corr', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': [[1.0, 0.5], [0.5, 1.0]], 'factor': np.sqrt(3.0)})\ndef test_correctness_zcb_sims(self, dim, mr, vol, corr, factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests discount bond simulations.'\n    dtype = np.float64\n    num_samples = 100000\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    times = np.array([0.1, 0.5, 1.0, 2.0])\n    curve_times = np.array([0.0, 0.5, 1.0, 2.0, 5.0])\n    (paths, _, _) = process.sample_discount_curve_paths(times, curve_times=curve_times, num_samples=num_samples, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], skip=1000000)\n    self.assertEqual(paths.dtype, dtype)\n    paths = self.evaluate(paths)\n    self.assertAllEqual(paths.shape, [num_samples, 5, 4])\n    sampled_std = tf.math.reduce_std(tf.math.log(paths), axis=0)\n    for tidx in range(4):\n        true_std = self.true_zcb_std(times[tidx], curve_times + times[tidx], 0.005, 0.03)\n        self.assertAllClose(sampled_std[:, tidx], factor * true_std, rtol=0.001, atol=0.001)",
            "@parameterized.named_parameters({'testcase_name': '1f_constant', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'factor': 1.0}, {'testcase_name': '2f_constant', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'factor': np.sqrt(2.0)}, {'testcase_name': '2f_constant_with_corr', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': [[1.0, 0.5], [0.5, 1.0]], 'factor': np.sqrt(3.0)})\ndef test_correctness_zcb_sims(self, dim, mr, vol, corr, factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests discount bond simulations.'\n    dtype = np.float64\n    num_samples = 100000\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    times = np.array([0.1, 0.5, 1.0, 2.0])\n    curve_times = np.array([0.0, 0.5, 1.0, 2.0, 5.0])\n    (paths, _, _) = process.sample_discount_curve_paths(times, curve_times=curve_times, num_samples=num_samples, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], skip=1000000)\n    self.assertEqual(paths.dtype, dtype)\n    paths = self.evaluate(paths)\n    self.assertAllEqual(paths.shape, [num_samples, 5, 4])\n    sampled_std = tf.math.reduce_std(tf.math.log(paths), axis=0)\n    for tidx in range(4):\n        true_std = self.true_zcb_std(times[tidx], curve_times + times[tidx], 0.005, 0.03)\n        self.assertAllClose(sampled_std[:, tidx], factor * true_std, rtol=0.001, atol=0.001)"
        ]
    },
    {
        "func_name": "test_correctness_discount_bond_price",
        "original": "@parameterized.named_parameters({'testcase_name': '1f_single_time', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'times': [1.0], 'expected': [0.9803327113840525]}, {'testcase_name': '1f_many_times', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'times': [1.0, 2.0, 3.0], 'expected': [0.9803327113840525, 0.9803218405347454, 0.9803116028646381]}, {'testcase_name': '2f_single_time', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'times': [1.0], 'expected': [0.9707109604475661]}, {'testcase_name': '2f_many_times', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'times': [1.0, 2.0, 3.0], 'expected': [0.9707109604475661, 0.9706894322583266, 0.9706691582097785]})\ndef test_correctness_discount_bond_price(self, dim, mr, vol, corr, times, expected):\n    \"\"\"Tests discount bond price computation.\"\"\"\n    dtype = np.float64\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    x_t = 0.01 * np.ones(shape=(len(times), dim))\n    times = np.array(times)\n    bond_prices = self.evaluate(process.discount_bond_price(x_t, times, times + 1.0))\n    self.assertAllEqual(bond_prices.shape, times.shape)\n    self.assertAllClose(expected, bond_prices, 1e-08, 1e-08)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': '1f_single_time', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'times': [1.0], 'expected': [0.9803327113840525]}, {'testcase_name': '1f_many_times', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'times': [1.0, 2.0, 3.0], 'expected': [0.9803327113840525, 0.9803218405347454, 0.9803116028646381]}, {'testcase_name': '2f_single_time', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'times': [1.0], 'expected': [0.9707109604475661]}, {'testcase_name': '2f_many_times', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'times': [1.0, 2.0, 3.0], 'expected': [0.9707109604475661, 0.9706894322583266, 0.9706691582097785]})\ndef test_correctness_discount_bond_price(self, dim, mr, vol, corr, times, expected):\n    if False:\n        i = 10\n    'Tests discount bond price computation.'\n    dtype = np.float64\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    x_t = 0.01 * np.ones(shape=(len(times), dim))\n    times = np.array(times)\n    bond_prices = self.evaluate(process.discount_bond_price(x_t, times, times + 1.0))\n    self.assertAllEqual(bond_prices.shape, times.shape)\n    self.assertAllClose(expected, bond_prices, 1e-08, 1e-08)",
            "@parameterized.named_parameters({'testcase_name': '1f_single_time', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'times': [1.0], 'expected': [0.9803327113840525]}, {'testcase_name': '1f_many_times', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'times': [1.0, 2.0, 3.0], 'expected': [0.9803327113840525, 0.9803218405347454, 0.9803116028646381]}, {'testcase_name': '2f_single_time', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'times': [1.0], 'expected': [0.9707109604475661]}, {'testcase_name': '2f_many_times', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'times': [1.0, 2.0, 3.0], 'expected': [0.9707109604475661, 0.9706894322583266, 0.9706691582097785]})\ndef test_correctness_discount_bond_price(self, dim, mr, vol, corr, times, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests discount bond price computation.'\n    dtype = np.float64\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    x_t = 0.01 * np.ones(shape=(len(times), dim))\n    times = np.array(times)\n    bond_prices = self.evaluate(process.discount_bond_price(x_t, times, times + 1.0))\n    self.assertAllEqual(bond_prices.shape, times.shape)\n    self.assertAllClose(expected, bond_prices, 1e-08, 1e-08)",
            "@parameterized.named_parameters({'testcase_name': '1f_single_time', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'times': [1.0], 'expected': [0.9803327113840525]}, {'testcase_name': '1f_many_times', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'times': [1.0, 2.0, 3.0], 'expected': [0.9803327113840525, 0.9803218405347454, 0.9803116028646381]}, {'testcase_name': '2f_single_time', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'times': [1.0], 'expected': [0.9707109604475661]}, {'testcase_name': '2f_many_times', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'times': [1.0, 2.0, 3.0], 'expected': [0.9707109604475661, 0.9706894322583266, 0.9706691582097785]})\ndef test_correctness_discount_bond_price(self, dim, mr, vol, corr, times, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests discount bond price computation.'\n    dtype = np.float64\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    x_t = 0.01 * np.ones(shape=(len(times), dim))\n    times = np.array(times)\n    bond_prices = self.evaluate(process.discount_bond_price(x_t, times, times + 1.0))\n    self.assertAllEqual(bond_prices.shape, times.shape)\n    self.assertAllClose(expected, bond_prices, 1e-08, 1e-08)",
            "@parameterized.named_parameters({'testcase_name': '1f_single_time', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'times': [1.0], 'expected': [0.9803327113840525]}, {'testcase_name': '1f_many_times', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'times': [1.0, 2.0, 3.0], 'expected': [0.9803327113840525, 0.9803218405347454, 0.9803116028646381]}, {'testcase_name': '2f_single_time', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'times': [1.0], 'expected': [0.9707109604475661]}, {'testcase_name': '2f_many_times', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'times': [1.0, 2.0, 3.0], 'expected': [0.9707109604475661, 0.9706894322583266, 0.9706691582097785]})\ndef test_correctness_discount_bond_price(self, dim, mr, vol, corr, times, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests discount bond price computation.'\n    dtype = np.float64\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    x_t = 0.01 * np.ones(shape=(len(times), dim))\n    times = np.array(times)\n    bond_prices = self.evaluate(process.discount_bond_price(x_t, times, times + 1.0))\n    self.assertAllEqual(bond_prices.shape, times.shape)\n    self.assertAllClose(expected, bond_prices, 1e-08, 1e-08)",
            "@parameterized.named_parameters({'testcase_name': '1f_single_time', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'times': [1.0], 'expected': [0.9803327113840525]}, {'testcase_name': '1f_many_times', 'dim': 1, 'mr': [0.03], 'vol': [0.005], 'corr': None, 'times': [1.0, 2.0, 3.0], 'expected': [0.9803327113840525, 0.9803218405347454, 0.9803116028646381]}, {'testcase_name': '2f_single_time', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'times': [1.0], 'expected': [0.9707109604475661]}, {'testcase_name': '2f_many_times', 'dim': 2, 'mr': [0.03, 0.03], 'vol': [0.005, 0.005], 'corr': None, 'times': [1.0, 2.0, 3.0], 'expected': [0.9707109604475661, 0.9706894322583266, 0.9706691582097785]})\ndef test_correctness_discount_bond_price(self, dim, mr, vol, corr, times, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests discount bond price computation.'\n    dtype = np.float64\n    process = tff.models.hjm.GaussianHJM(dim=dim, mean_reversion=mr, volatility=vol, initial_discount_rate_fn=self.instant_forward_rate, corr_matrix=corr, dtype=dtype)\n    x_t = 0.01 * np.ones(shape=(len(times), dim))\n    times = np.array(times)\n    bond_prices = self.evaluate(process.discount_bond_price(x_t, times, times + 1.0))\n    self.assertAllEqual(bond_prices.shape, times.shape)\n    self.assertAllClose(expected, bond_prices, 1e-08, 1e-08)"
        ]
    }
]