[
    {
        "func_name": "Geom_bg",
        "original": "def Geom_bg(Model_name, File_bg):\n    Lon_bg = []\n    Lat_bg = []\n    geom_bg = np.genfromtxt(File_bg, dtype=['U100', 'f', 'f'], skip_header=1)\n    column_model = list(map(lambda i: str(geom_bg[i][0]), range(len(geom_bg))))\n    index_model = np.where(np.array(column_model) == Model_name)[0]\n    Lon_bg = map(lambda i: geom_bg[i][1], index_model)\n    Lat_bg = map(lambda i: geom_bg[i][2], index_model)\n    return (list(Lon_bg), list(Lat_bg))",
        "mutated": [
            "def Geom_bg(Model_name, File_bg):\n    if False:\n        i = 10\n    Lon_bg = []\n    Lat_bg = []\n    geom_bg = np.genfromtxt(File_bg, dtype=['U100', 'f', 'f'], skip_header=1)\n    column_model = list(map(lambda i: str(geom_bg[i][0]), range(len(geom_bg))))\n    index_model = np.where(np.array(column_model) == Model_name)[0]\n    Lon_bg = map(lambda i: geom_bg[i][1], index_model)\n    Lat_bg = map(lambda i: geom_bg[i][2], index_model)\n    return (list(Lon_bg), list(Lat_bg))",
            "def Geom_bg(Model_name, File_bg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Lon_bg = []\n    Lat_bg = []\n    geom_bg = np.genfromtxt(File_bg, dtype=['U100', 'f', 'f'], skip_header=1)\n    column_model = list(map(lambda i: str(geom_bg[i][0]), range(len(geom_bg))))\n    index_model = np.where(np.array(column_model) == Model_name)[0]\n    Lon_bg = map(lambda i: geom_bg[i][1], index_model)\n    Lat_bg = map(lambda i: geom_bg[i][2], index_model)\n    return (list(Lon_bg), list(Lat_bg))",
            "def Geom_bg(Model_name, File_bg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Lon_bg = []\n    Lat_bg = []\n    geom_bg = np.genfromtxt(File_bg, dtype=['U100', 'f', 'f'], skip_header=1)\n    column_model = list(map(lambda i: str(geom_bg[i][0]), range(len(geom_bg))))\n    index_model = np.where(np.array(column_model) == Model_name)[0]\n    Lon_bg = map(lambda i: geom_bg[i][1], index_model)\n    Lat_bg = map(lambda i: geom_bg[i][2], index_model)\n    return (list(Lon_bg), list(Lat_bg))",
            "def Geom_bg(Model_name, File_bg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Lon_bg = []\n    Lat_bg = []\n    geom_bg = np.genfromtxt(File_bg, dtype=['U100', 'f', 'f'], skip_header=1)\n    column_model = list(map(lambda i: str(geom_bg[i][0]), range(len(geom_bg))))\n    index_model = np.where(np.array(column_model) == Model_name)[0]\n    Lon_bg = map(lambda i: geom_bg[i][1], index_model)\n    Lat_bg = map(lambda i: geom_bg[i][2], index_model)\n    return (list(Lon_bg), list(Lat_bg))",
            "def Geom_bg(Model_name, File_bg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Lon_bg = []\n    Lat_bg = []\n    geom_bg = np.genfromtxt(File_bg, dtype=['U100', 'f', 'f'], skip_header=1)\n    column_model = list(map(lambda i: str(geom_bg[i][0]), range(len(geom_bg))))\n    index_model = np.where(np.array(column_model) == Model_name)[0]\n    Lon_bg = map(lambda i: geom_bg[i][1], index_model)\n    Lat_bg = map(lambda i: geom_bg[i][2], index_model)\n    return (list(Lon_bg), list(Lat_bg))"
        ]
    },
    {
        "func_name": "plt_catalog",
        "original": "def plt_catalog(do_catalog, Model_list, File_bg, catalog_file, Run_name, xmin, xmax, ymin, ymax, llcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat, completness_file, nb_inter, bining_in_mag, end_year_of_catalog, sub_area_file):\n    if do_catalog == True:\n        if not os.path.exists(str(Run_name) + '/analysis/figures/catalogue'):\n            os.makedirs(str(Run_name) + '/analysis/figures/catalogue')\n        catalog_cum_rate = []\n        index_model = 0\n        for model in Model_list:\n            file_catalog_rate_all = open(str(Run_name) + '/analysis/figures/catalogue/catalog_rates_all_' + model + '.txt', 'w')\n            for mag in bining_in_mag[:-1]:\n                file_catalog_rate_all.write(str(round(mag, 1)) + '\\t')\n            file_catalog_rate_all.write(str(round(bining_in_mag[-1], 1)) + '\\n')\n            (Lon_bg, Lat_bg) = Geom_bg(model, File_bg)\n            ColX = Lon_bg\n            ColY = Lat_bg\n            Poly = []\n            for (x1, y1) in zip(ColX, ColY):\n                Poly.append((x1, y1))\n            bbPath = mplPath.Path(Poly)\n            bbPath_sub_areas = []\n            if os.path.exists(sub_area_file):\n                read_sub_area_file = open(sub_area_file, 'rU')\n                lines_sub_area = read_sub_area_file.readlines()\n                sub_area_names = []\n                sub_area_coord = []\n                sub_area_lon = []\n                sub_area_lat = []\n                for line in lines_sub_area:\n                    model_sub_area = line.split('\\t')[0]\n                    if model == model_sub_area:\n                        sub_area_names.append(line.split('\\t')[1])\n                        sub_area_coord.append(line.split('\\t')[2:])\n                        sub_area_lon_i = []\n                        sub_area_lat_i = []\n                        for sub_area_coord_i in line.split('\\t')[2:]:\n                            if not '\\n' in sub_area_coord_i.split(','):\n                                if not '' in sub_area_coord_i.split(','):\n                                    sub_area_lon_i.append(float(sub_area_coord_i.split(',')[1]))\n                                    sub_area_lat_i.append(float(sub_area_coord_i.split(',')[0]))\n                        sub_area_lon.append(sub_area_lon_i)\n                        sub_area_lat.append(sub_area_lat_i)\n                        if not os.path.exists(str(Run_name) + '/analysis/figures/catalogue/sub_area'):\n                            os.makedirs(str(Run_name) + '/analysis/figures/catalogue/sub_area')\n                        Poly_sub = []\n                        for (x1, y1) in zip(sub_area_lon_i, sub_area_lat_i):\n                            Poly_sub.append((x1, y1))\n                        bbPath_sub_areas.append(mplPath.Path(Poly_sub))\n            cat_data = np.genfromtxt(catalog_file, dtype=['S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100'], skip_header=1)\n            cat_lon = list(map(lambda i: float(cat_data[i][5]), range(len(cat_data))))\n            cat_lat = list(map(lambda i: float(cat_data[i][4]), range(len(cat_data))))\n            cat_depth = list(map(lambda i: float(cat_data[i][6]), range(len(cat_data))))\n            cat_Mw = list(map(lambda i: float(cat_data[i][7]), range(len(cat_data))))\n            cat_sig_Mw = list(map(lambda i: float(cat_data[i][8]), range(len(cat_data))))\n            cat_Yr = list(map(lambda i: float(cat_data[i][0]), range(len(cat_data))))\n            indexes_in = []\n            for index_cat in range(len(cat_lon)):\n                if bbPath.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                    indexes_in.append(index_cat)\n            cat_lon = np.take(cat_lon, indexes_in)\n            cat_lat = np.take(cat_lat, indexes_in)\n            cat_depth = np.take(cat_depth, indexes_in)\n            cat_Mw = np.take(cat_Mw, indexes_in)\n            cat_sig_Mw = np.take(cat_sig_Mw, indexes_in)\n            cat_Yr = np.take(cat_Yr, indexes_in)\n            completness = []\n            weights_completness = []\n            read_comp_file = open(completness_file, 'rU')\n            lines_of_the_file = read_comp_file.readlines()\n            line_number = 0\n            for i in range(int(len(lines_of_the_file) / 2)):\n                if len(lines_of_the_file[line_number].split('\\t')) != 0:\n                    binning_comp_i = lines_of_the_file[line_number].split('\\t')\n                    if '\\r\\n' in binning_comp_i:\n                        binning_comp_i.remove('\\r\\n')\n                    if '\\n' in binning_comp_i:\n                        binning_comp_i.remove('\\n')\n                    binning_comp = []\n                    for magnitudes in binning_comp_i[1:]:\n                        mag = magnitudes.split(',')\n                        binning_comp.append(float(mag[0]))\n                        binning_comp.append(float(mag[1]))\n                    binning_comp.append(bining_in_mag[-1])\n                    comp_value_i = lines_of_the_file[line_number + 1].split('\\t')\n                    if '\\r\\n' in comp_value_i:\n                        comp_value_i.remove('\\r\\n')\n                    if '\\n' in comp_value_i:\n                        comp_value_i.remove('\\n')\n                    comp_value = []\n                    for value in comp_value_i[1:]:\n                        comp_value.append(float(value))\n                        comp_value.append(float(value))\n                    comp_value.append(comp_value[-1])\n                    completeness_interpolate = interp1d(binning_comp, comp_value)\n                    completness_i = []\n                    for mag in bining_in_mag:\n                        try:\n                            completness_i.append(completeness_interpolate(mag))\n                        except ValueError:\n                            print('!!!!!!!!!!!!\\n\\n\\nERROR in completeness file\\n your minimum magnitude might not be low enough\\n\\n\\n!!!!!!!!!!!!')\n                    line_number += 2\n                    completness.append(completness_i)\n                    weights_completness.append(float(comp_value_i[0]))\n            seismological_moment_rate = []\n            number_of_earthquakes_for_rate = []\n            number_of_earthquakes_for_rate_sub_area = []\n            for poly_sub_area_i in bbPath_sub_areas:\n                number_of_earthquakes_for_rate_sub_area.append([])\n            file_catalog_for_map = open(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', 'w')\n            earthquake_for_map = []\n            nb_time_picked = []\n            rate_cat_cum_density = []\n            rate_in_sub_area_cum = []\n            for poly_sub_area_i in bbPath_sub_areas:\n                rate_in_sub_area_cum.append([])\n            for i in range(nb_inter):\n                cat_model_bin = np.zeros(len(bining_in_mag))\n                rate_cat = np.zeros(len(bining_in_mag))\n                seismological_moment_rate_i = 0.0\n                test_if_eq_here = []\n                index_completness = np.random.choice(len(weights_completness), 1, p=weights_completness)[0]\n                completness_used = completness[index_completness]\n                cat_sub_area_bin = []\n                rate_sub_area = []\n                for poly_sub_area_i in bbPath_sub_areas:\n                    cat_sub_area_bin.append(np.zeros(len(bining_in_mag)))\n                    rate_sub_area.append(np.zeros(len(bining_in_mag)))\n                envents_magnitude = []\n                index_cat = 0\n                for Yr in cat_Yr:\n                    if cat_sig_Mw[index_cat] == 0:\n                        event_magnitude = cat_Mw[index_cat]\n                    elif cat_sig_Mw[index_cat] <= 3.0:\n                        event_magnitude = np.random.triangular(cat_Mw[index_cat] - cat_sig_Mw[index_cat] / 2.0, cat_Mw[index_cat], cat_Mw[index_cat] + cat_sig_Mw[index_cat] / 2.0)\n                        event_magnitude = np.random.normal(loc=cat_Mw[index_cat], scale=cat_sig_Mw[index_cat])\n                    envents_magnitude.append(event_magnitude)\n                    index_cat += 1\n                index_mag = 0\n                for (mag_i, completness_i) in zip(bining_in_mag, completness_used):\n                    index_cat = 0\n                    picked_completness = completness_i\n                    index_cat = 0\n                    for Yr in cat_Yr:\n                        if cat_depth[index_cat] < 30.0 or math.isnan(cat_depth[index_cat]):\n                            if Yr >= picked_completness and Yr <= end_year_of_catalog:\n                                event_magnitude = envents_magnitude[index_cat]\n                                if event_magnitude >= mag_i and event_magnitude < mag_i + 0.099:\n                                    if bbPath.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                                        if not str(Yr) + str(cat_lon[index_cat]) + str(cat_lat[index_cat]) + str(cat_sig_Mw[index_cat]) in test_if_eq_here:\n                                            test_if_eq_here.append(str(Yr) + str(cat_lon[index_cat]) + str(cat_lat[index_cat]))\n                                            cat_model_bin[index_mag] += 1\n                                            string_for_map = str(Yr) + '\\t' + str(cat_Mw[index_cat]) + '\\t' + str(cat_lon[index_cat]) + '\\t' + str(cat_lat[index_cat])\n                                            if not string_for_map in earthquake_for_map:\n                                                earthquake_for_map.append(string_for_map)\n                                                nb_time_picked.append(1)\n                                            else:\n                                                index_in_cat_for_map = np.where(np.array(earthquake_for_map) == string_for_map)[0][0]\n                                                nb_time_picked[index_in_cat_for_map] += 1\n                                            index_sub_area = 0\n                                            for poly_sub_area_i in bbPath_sub_areas:\n                                                if poly_sub_area_i.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                                                    cat_sub_area_bin[index_sub_area][index_mag] += 1\n                                                index_sub_area += 1\n                        index_cat += 1\n                    rate_cat[index_mag] = cat_model_bin[index_mag] / (end_year_of_catalog - picked_completness)\n                    M0 = 10.0 ** (1.5 * mag_i + 9.1)\n                    rate_M0 = M0 * rate_cat[index_mag]\n                    seismological_moment_rate_i += rate_M0\n                    index_sub_area = 0\n                    for poly_sub_area_i in bbPath_sub_areas:\n                        rate_sub_area[index_sub_area][index_mag] = cat_sub_area_bin[index_sub_area][index_mag] / (end_year_of_catalog - picked_completness)\n                        index_sub_area += 1\n                    index_mag += 1\n                seismological_moment_rate.append(seismological_moment_rate_i)\n                number_of_earthquakes_for_rate_i = []\n                for i in range(len(cat_model_bin)):\n                    number_of_earthquakes_for_rate_i.append(int(np.sum(np.array(cat_model_bin)[-(len(cat_model_bin) - i):])))\n                number_of_earthquakes_for_rate.append(number_of_earthquakes_for_rate_i)\n                index_sub_area = 0\n                for poly_sub_area_i in bbPath_sub_areas:\n                    number_of_earthquakes_for_rate_i = []\n                    for i in range(len(cat_model_bin)):\n                        number_of_earthquakes_for_rate_i.append(int(np.sum(np.array(cat_sub_area_bin[index_sub_area])[-(len(cat_sub_area_bin[index_sub_area]) - i):])))\n                    number_of_earthquakes_for_rate_sub_area[index_sub_area].append(number_of_earthquakes_for_rate_i)\n                    index_sub_area += 1\n                rate_cat_cum = []\n                for i in range(len(rate_cat)):\n                    rate_cat_cum.append(np.sum(np.array(rate_cat)[-(len(rate_cat) - i):]))\n                rate_cat_cum_density.append(rate_cat_cum)\n                index_sub_area = 0\n                for poly_sub_area_i in bbPath_sub_areas:\n                    rate_sub_area_i_cum = []\n                    for i in range(len(rate_sub_area[index_sub_area])):\n                        rate_sub_area_i_cum.append(np.sum(np.array(rate_sub_area[index_sub_area])[-(len(rate_sub_area[index_sub_area]) - i):]))\n                    rate_in_sub_area_cum[index_sub_area].append(rate_sub_area_i_cum)\n                    index_sub_area += 1\n                plt.scatter(bining_in_mag, rate_cat_cum, c='brown', marker='_', s=50, alpha=0.2)\n                for rate_i in rate_cat_cum[:-1]:\n                    file_catalog_rate_all.write(str(rate_i) + '\\t')\n                file_catalog_rate_all.write(str(rate_cat_cum[-1]) + '\\n')\n            file_catalog_rate_all.close()\n            axes = plt.gca()\n            axes.set_xlim([xmin, xmax])\n            axes.set_ylim([ymin, ymax])\n            mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate, axis=0)\n            nb_sample = 50\n            time_simu = 1000000\n            alphas = []\n            for index_mag in range(len(bining_in_mag)):\n                nb_eq = mean_nb_eq_in_cat[index_mag]\n                if nb_eq <= 10:\n                    time_obs = int(round(end_year_of_catalog - completness[0][index_mag]))\n                    rate = float(nb_eq) / float(time_obs)\n                    cat = []\n                    for i in range(time_simu):\n                        test = np.random.uniform(0.0, 1.0)\n                        if test <= rate:\n                            cat.append(1)\n                        else:\n                            cat.append(0)\n                    rates_simu = []\n                    for i in range(nb_sample):\n                        yrs_start = random.choice(range(time_simu - time_obs))\n                        cat_sampled = cat[yrs_start:yrs_start + time_obs]\n                        rates_simu.append(sum(cat_sampled) / float(time_obs))\n                    unc_rate = np.std(rate_cat_cum_density, axis=0)[index_mag] / np.square(mean_nb_eq_in_cat[index_mag])\n                    unc_rate = np.std(rates_simu)\n                    rate_plus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] + unc_rate\n                    rate_minus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] - unc_rate\n                    if rate_minus < 0.0:\n                        rate_minus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] / 100.0\n                    if np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag] > rate_plus:\n                        rate_plus = np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag]\n                    if np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag] < rate_minus:\n                        rate_minus = np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag]\n                else:\n                    rate_plus = np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag]\n                    rate_minus = np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag]\n                mag = bining_in_mag[index_mag]\n                mag_plus = mag + 0.05\n                mag_minus = mag - 0.05\n                verts = [(mag_minus, rate_minus), (mag_minus, rate_plus), (mag_plus, rate_plus), (mag_plus, rate_minus), (mag_minus, rate_minus)]\n                codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]\n                alpha = float(np.count_nonzero(rate_cat_cum_density, axis=0)[index_mag]) / float(nb_sample) * 0.2\n                alphas.append(alpha)\n                path_poly = Path(verts, codes)\n                patch = patches.PathPatch(path_poly, facecolor='k', lw=0.0, alpha=alpha)\n                axes.add_patch(patch)\n            rgba_colors = np.zeros((len(bining_in_mag), 4))\n            rgba_colors[:, 0] = 0.0\n            rgba_colors[:, 3] = alphas\n            plt.scatter(bining_in_mag, np.array(rate_cat_cum_density).mean(axis=0), c=rgba_colors, s=20, edgecolor='', marker='s')\n            plt.yscale('log')\n            plt.title('earthquake catalog')\n            plt.grid(alpha=0.3)\n            plt.savefig(str(Run_name) + '/analysis/figures/catalogue/catalogue_' + str(model) + '.png', dpi=180, transparent=True)\n            plt.close()\n            catalog_cum_rate.append(np.array(rate_cat_cum_density).mean(axis=0))\n            index_sub_area = 0\n            for poly_sub_area_i in bbPath_sub_areas:\n                axes = plt.gca()\n                axes.set_xlim([xmin, xmax])\n                axes.set_ylim([ymin, ymax])\n                mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate_sub_area[index_sub_area], axis=0)\n                alphas = []\n                for index_mag in range(len(bining_in_mag)):\n                    nb_eq = mean_nb_eq_in_cat[index_mag]\n                    if nb_eq <= 10:\n                        time_obs = int(round(end_year_of_catalog - completness[0][index_mag]))\n                        rate = float(nb_eq) / float(time_obs)\n                        cat = []\n                        for i in range(time_simu):\n                            test = np.random.uniform(0.0, 1.0)\n                            if test <= rate:\n                                cat.append(1)\n                            else:\n                                cat.append(0)\n                        rates_simu = []\n                        for i in range(nb_sample):\n                            yrs_start = random.choice(range(time_simu - time_obs))\n                            cat_sampled = cat[yrs_start:yrs_start + time_obs]\n                            rates_simu.append(sum(cat_sampled) / float(time_obs))\n                        unc_rate = np.std(rates_simu)\n                        rate_plus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] + unc_rate\n                        rate_minus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] - unc_rate\n                        if rate_minus < 0.0:\n                            rate_minus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] / 10.0\n                        if np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag] > rate_plus:\n                            rate_plus = np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag]\n                        if np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag] < rate_minus:\n                            rate_minus = np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag]\n                    else:\n                        rate_plus = np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag]\n                        rate_minus = np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag]\n                    mag = bining_in_mag[index_mag]\n                    mag_plus = mag + 0.05\n                    mag_minus = mag - 0.05\n                    verts = [(mag_minus, rate_minus), (mag_minus, rate_plus), (mag_plus, rate_plus), (mag_plus, rate_minus), (mag_minus, rate_minus)]\n                    codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]\n                    path_poly = Path(verts, codes)\n                    alpha = float(np.count_nonzero(rate_in_sub_area_cum[index_sub_area], axis=0)[index_mag]) / float(nb_sample) * 0.2\n                    alphas.append(alpha)\n                    patch = patches.PathPatch(path_poly, facecolor='k', lw=0.0, alpha=alpha)\n                    axes.add_patch(patch)\n                for i in range(nb_inter):\n                    plt.scatter(bining_in_mag, rate_in_sub_area_cum[index_sub_area][i], c='brown', marker='_', s=50, alpha=0.2)\n                rgba_colors = np.zeros((len(bining_in_mag), 4))\n                rgba_colors[:, 0] = 0.0\n                rgba_colors[:, 3] = alphas\n                plt.scatter(bining_in_mag, np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0), c=rgba_colors, s=20, edgecolor='', marker='s')\n                axes = plt.gca()\n                axes.set_xlim([xmin, xmax])\n                axes.set_ylim([ymin, ymax])\n                plt.grid()\n                plt.yscale('log')\n                plt.title('catalogue sub area ' + sub_area_names[index_sub_area])\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/sub_area/catalogue_sub_area_' + sub_area_names[index_sub_area] + ' Model ' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n                file_cat_sub_area = open(str(Run_name) + '/analysis/figures/catalogue/sub_area/mean_rate_cat_' + sub_area_names[index_sub_area] + ' Model ' + str(model) + '.txt', 'w')\n                for index_mag in range(len(bining_in_mag)):\n                    file_cat_sub_area.write(str(bining_in_mag[index_mag]) + '\\t' + str(np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag]) + '\\n')\n                file_cat_sub_area.close()\n                index_sub_area += 1\n            file_nb_eq_in_cat = open(str(Run_name) + '/analysis/figures/catalogue/nb_eq_in_cat_' + str(model) + '.txt', 'w')\n            file_nb_eq_in_cat.write('Number of earthquake for the rate in catalogue' + '\\n')\n            mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate, axis=0)\n            for i in range(len(bining_in_mag)):\n                file_nb_eq_in_cat.write(str(bining_in_mag[i]) + '\\t' + str(round(mean_nb_eq_in_cat[i], 0)) + '\\n')\n            file_nb_eq_in_cat.close()\n            plt.scatter(bining_in_mag, mean_nb_eq_in_cat)\n            plt.axhline(y=1)\n            plt.axhline(y=2)\n            plt.axhline(y=5)\n            plt.axhline(y=10)\n            plt.title('nb of earthquakes (m>M) in the catalogue')\n            plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'nb_of_EQ_in_catalogue.png', dpi=180, transparent=True)\n            plt.grid()\n            plt.close()\n            for (string, nb) in zip(earthquake_for_map, nb_time_picked):\n                file_catalog_for_map.write(string + '\\t' + str(nb) + '\\n')\n            file_catalog_for_map.close()\n            index_sub_area = 0\n            for poly_sub_area_i in bbPath_sub_areas:\n                plt.scatter(bining_in_mag, np.mean(number_of_earthquakes_for_rate_sub_area[index_sub_area], axis=0))\n                plt.axhline(y=1)\n                plt.axhline(y=2)\n                plt.axhline(y=5)\n                plt.axhline(y=10)\n                plt.title('nb of earthquakes (m>M) in the catalogue ' + sub_area_names[index_sub_area])\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/sub_area/' + 'nb_of_EQ_in_ ' + sub_area_names[index_sub_area] + '.png', dpi=180, transparent=True)\n                plt.grid()\n                plt.close()\n                index_sub_area += 1\n            if mean_nb_eq_in_cat[0] > 3:\n                catalog_for_map = np.genfromtxt(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', dtype=['f8', 'f8', 'f8', 'f8', 'f8'])\n                yr_cat_for_map = list(map(lambda i: round(float(catalog_for_map[i][0])), range(len(catalog_for_map))))\n                M_cat_for_map = list(map(lambda i: float(catalog_for_map[i][1]), range(len(catalog_for_map))))\n                lon_cat_for_map = list(map(lambda i: float(catalog_for_map[i][2]), range(len(catalog_for_map))))\n                lat_cat_for_map = list(map(lambda i: float(catalog_for_map[i][3]), range(len(catalog_for_map))))\n                nb_time_picked = list(map(lambda i: float(catalog_for_map[i][4]), range(len(catalog_for_map))))\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n                for (Yr, M, lon, lat, nb) in zip(yr_cat_for_map, M_cat_for_map, lon_cat_for_map, lat_cat_for_map, nb_time_picked):\n                    (x, y) = m(lon, lat)\n                    if M < 5.0:\n                        c = 'b'\n                        s = 3\n                    elif M < 6.0:\n                        c = 'g'\n                        s = 5\n                    elif M < 7.0:\n                        c = 'orange'\n                        s = 7\n                    else:\n                        c = 'r'\n                        s = 10\n                    if nb >= 2 * nb_inter / 3:\n                        alpha = 1.0\n                    if nb <= 2 * nb_inter / 3:\n                        alpha = 0.8\n                    if nb <= 1 * nb_inter / 2:\n                        alpha = 0.3\n                    if nb < 1 * nb_inter / 3:\n                        alpha = 0.1\n                    c = plt.cm.jet((M - min(M_cat_for_map)) / (max(M_cat_for_map) - min(M_cat_for_map)))\n                    m.plot(x, y, '.', markersize=s, markeredgewidth=0.0, linewidth=0.2, color=c, alpha=alpha)\n                    if M > max(M_cat_for_map) - 1.0:\n                        (x_text, y_text) = m(lon + 0.005, lat + 0.005)\n                        plt.text(x_text, y_text, str(int(Yr)) + ',' + str(int(nb)), fontsize=4)\n                m.drawcoastlines(linewidth=0.1)\n                plt.gca().set_title('Earthquake catalog - Complete period')\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'earthquake_map_' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n                catalog_for_map = np.genfromtxt(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', dtype=['f8', 'f8', 'f8', 'f8', 'f8'])\n                yr_cat_for_map = list(map(lambda i: round(float(catalog_for_map[i][0])), range(len(catalog_for_map))))\n                M_cat_for_map = list(map(lambda i: float(catalog_for_map[i][1]), range(len(catalog_for_map))))\n                lon_cat_for_map = list(map(lambda i: float(catalog_for_map[i][2]), range(len(catalog_for_map))))\n                lat_cat_for_map = list(map(lambda i: float(catalog_for_map[i][3]), range(len(catalog_for_map))))\n                nb_time_picked = list(map(lambda i: float(catalog_for_map[i][4]), range(len(catalog_for_map))))\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='l')\n                for (Yr, M, lon, lat, nb) in zip(yr_cat_for_map, M_cat_for_map, lon_cat_for_map, lat_cat_for_map, nb_time_picked):\n                    (x, y) = m(lon, lat)\n                    if M < 5.0:\n                        c = 'b'\n                        s = 3\n                    elif M < 6.0:\n                        c = 'g'\n                        s = 5\n                    elif M < 7.0:\n                        c = 'orange'\n                        s = 7\n                    else:\n                        c = 'r'\n                        s = 10\n                    if nb >= float(nb_inter) / 2.0:\n                        m.plot(x, y, '.', markersize=s, markeredgewidth=0.0, linewidth=0.0, color=c, alpha=0.6)\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'earthquake_map_just_EQ_' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n        index_model += 1\n        file_eq_rate_cat = open(str(Run_name) + '/analysis/figures/catalogue/cat_cumulative_eq_rate.txt', 'w')\n        file_eq_rate_cat.write('cumulative annual eq rate in the catalog' + '\\n')\n        for (model_i, rate_i) in zip(Model_list, catalog_cum_rate):\n            file_eq_rate_cat.write(model_i)\n            for r in rate_i:\n                file_eq_rate_cat.write('\\t' + str(r))\n            file_eq_rate_cat.write('\\n')\n        file_eq_rate_cat.close()\n    else:\n        file_eq_rate_cat = str(Run_name) + '/analysis/figures/catalogue/cat_cumulative_eq_rate.txt'\n        with open(file_eq_rate_cat) as f:\n            lines_cat = f.readlines()\n        Model_list = []\n        catalog_cum_rate = []\n        for line in lines_cat[1:]:\n            cat_rates_i = line.split('\\t')\n            catalog_cum_rate.append([float(i) for i in cat_rates_i[1:]])\n        seismological_moment_rate = []\n        for rates in catalog_cum_rate:\n            rates_inc = []\n            for i in range(len(rates) - 1):\n                rates_inc.append(rates[i] - rates[i + 1])\n            rates_inc.append(rates[-1])\n            seismological_moment_rate_i = 0\n            for (mag_i, rate_i) in zip(bining_in_mag, rates_inc):\n                M0 = 10.0 ** (1.5 * mag_i + 9.1)\n                rate_M0 = M0 * rate_i\n                seismological_moment_rate_i += rate_M0\n            seismological_moment_rate.append(seismological_moment_rate_i)\n    return (seismological_moment_rate, catalog_cum_rate)",
        "mutated": [
            "def plt_catalog(do_catalog, Model_list, File_bg, catalog_file, Run_name, xmin, xmax, ymin, ymax, llcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat, completness_file, nb_inter, bining_in_mag, end_year_of_catalog, sub_area_file):\n    if False:\n        i = 10\n    if do_catalog == True:\n        if not os.path.exists(str(Run_name) + '/analysis/figures/catalogue'):\n            os.makedirs(str(Run_name) + '/analysis/figures/catalogue')\n        catalog_cum_rate = []\n        index_model = 0\n        for model in Model_list:\n            file_catalog_rate_all = open(str(Run_name) + '/analysis/figures/catalogue/catalog_rates_all_' + model + '.txt', 'w')\n            for mag in bining_in_mag[:-1]:\n                file_catalog_rate_all.write(str(round(mag, 1)) + '\\t')\n            file_catalog_rate_all.write(str(round(bining_in_mag[-1], 1)) + '\\n')\n            (Lon_bg, Lat_bg) = Geom_bg(model, File_bg)\n            ColX = Lon_bg\n            ColY = Lat_bg\n            Poly = []\n            for (x1, y1) in zip(ColX, ColY):\n                Poly.append((x1, y1))\n            bbPath = mplPath.Path(Poly)\n            bbPath_sub_areas = []\n            if os.path.exists(sub_area_file):\n                read_sub_area_file = open(sub_area_file, 'rU')\n                lines_sub_area = read_sub_area_file.readlines()\n                sub_area_names = []\n                sub_area_coord = []\n                sub_area_lon = []\n                sub_area_lat = []\n                for line in lines_sub_area:\n                    model_sub_area = line.split('\\t')[0]\n                    if model == model_sub_area:\n                        sub_area_names.append(line.split('\\t')[1])\n                        sub_area_coord.append(line.split('\\t')[2:])\n                        sub_area_lon_i = []\n                        sub_area_lat_i = []\n                        for sub_area_coord_i in line.split('\\t')[2:]:\n                            if not '\\n' in sub_area_coord_i.split(','):\n                                if not '' in sub_area_coord_i.split(','):\n                                    sub_area_lon_i.append(float(sub_area_coord_i.split(',')[1]))\n                                    sub_area_lat_i.append(float(sub_area_coord_i.split(',')[0]))\n                        sub_area_lon.append(sub_area_lon_i)\n                        sub_area_lat.append(sub_area_lat_i)\n                        if not os.path.exists(str(Run_name) + '/analysis/figures/catalogue/sub_area'):\n                            os.makedirs(str(Run_name) + '/analysis/figures/catalogue/sub_area')\n                        Poly_sub = []\n                        for (x1, y1) in zip(sub_area_lon_i, sub_area_lat_i):\n                            Poly_sub.append((x1, y1))\n                        bbPath_sub_areas.append(mplPath.Path(Poly_sub))\n            cat_data = np.genfromtxt(catalog_file, dtype=['S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100'], skip_header=1)\n            cat_lon = list(map(lambda i: float(cat_data[i][5]), range(len(cat_data))))\n            cat_lat = list(map(lambda i: float(cat_data[i][4]), range(len(cat_data))))\n            cat_depth = list(map(lambda i: float(cat_data[i][6]), range(len(cat_data))))\n            cat_Mw = list(map(lambda i: float(cat_data[i][7]), range(len(cat_data))))\n            cat_sig_Mw = list(map(lambda i: float(cat_data[i][8]), range(len(cat_data))))\n            cat_Yr = list(map(lambda i: float(cat_data[i][0]), range(len(cat_data))))\n            indexes_in = []\n            for index_cat in range(len(cat_lon)):\n                if bbPath.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                    indexes_in.append(index_cat)\n            cat_lon = np.take(cat_lon, indexes_in)\n            cat_lat = np.take(cat_lat, indexes_in)\n            cat_depth = np.take(cat_depth, indexes_in)\n            cat_Mw = np.take(cat_Mw, indexes_in)\n            cat_sig_Mw = np.take(cat_sig_Mw, indexes_in)\n            cat_Yr = np.take(cat_Yr, indexes_in)\n            completness = []\n            weights_completness = []\n            read_comp_file = open(completness_file, 'rU')\n            lines_of_the_file = read_comp_file.readlines()\n            line_number = 0\n            for i in range(int(len(lines_of_the_file) / 2)):\n                if len(lines_of_the_file[line_number].split('\\t')) != 0:\n                    binning_comp_i = lines_of_the_file[line_number].split('\\t')\n                    if '\\r\\n' in binning_comp_i:\n                        binning_comp_i.remove('\\r\\n')\n                    if '\\n' in binning_comp_i:\n                        binning_comp_i.remove('\\n')\n                    binning_comp = []\n                    for magnitudes in binning_comp_i[1:]:\n                        mag = magnitudes.split(',')\n                        binning_comp.append(float(mag[0]))\n                        binning_comp.append(float(mag[1]))\n                    binning_comp.append(bining_in_mag[-1])\n                    comp_value_i = lines_of_the_file[line_number + 1].split('\\t')\n                    if '\\r\\n' in comp_value_i:\n                        comp_value_i.remove('\\r\\n')\n                    if '\\n' in comp_value_i:\n                        comp_value_i.remove('\\n')\n                    comp_value = []\n                    for value in comp_value_i[1:]:\n                        comp_value.append(float(value))\n                        comp_value.append(float(value))\n                    comp_value.append(comp_value[-1])\n                    completeness_interpolate = interp1d(binning_comp, comp_value)\n                    completness_i = []\n                    for mag in bining_in_mag:\n                        try:\n                            completness_i.append(completeness_interpolate(mag))\n                        except ValueError:\n                            print('!!!!!!!!!!!!\\n\\n\\nERROR in completeness file\\n your minimum magnitude might not be low enough\\n\\n\\n!!!!!!!!!!!!')\n                    line_number += 2\n                    completness.append(completness_i)\n                    weights_completness.append(float(comp_value_i[0]))\n            seismological_moment_rate = []\n            number_of_earthquakes_for_rate = []\n            number_of_earthquakes_for_rate_sub_area = []\n            for poly_sub_area_i in bbPath_sub_areas:\n                number_of_earthquakes_for_rate_sub_area.append([])\n            file_catalog_for_map = open(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', 'w')\n            earthquake_for_map = []\n            nb_time_picked = []\n            rate_cat_cum_density = []\n            rate_in_sub_area_cum = []\n            for poly_sub_area_i in bbPath_sub_areas:\n                rate_in_sub_area_cum.append([])\n            for i in range(nb_inter):\n                cat_model_bin = np.zeros(len(bining_in_mag))\n                rate_cat = np.zeros(len(bining_in_mag))\n                seismological_moment_rate_i = 0.0\n                test_if_eq_here = []\n                index_completness = np.random.choice(len(weights_completness), 1, p=weights_completness)[0]\n                completness_used = completness[index_completness]\n                cat_sub_area_bin = []\n                rate_sub_area = []\n                for poly_sub_area_i in bbPath_sub_areas:\n                    cat_sub_area_bin.append(np.zeros(len(bining_in_mag)))\n                    rate_sub_area.append(np.zeros(len(bining_in_mag)))\n                envents_magnitude = []\n                index_cat = 0\n                for Yr in cat_Yr:\n                    if cat_sig_Mw[index_cat] == 0:\n                        event_magnitude = cat_Mw[index_cat]\n                    elif cat_sig_Mw[index_cat] <= 3.0:\n                        event_magnitude = np.random.triangular(cat_Mw[index_cat] - cat_sig_Mw[index_cat] / 2.0, cat_Mw[index_cat], cat_Mw[index_cat] + cat_sig_Mw[index_cat] / 2.0)\n                        event_magnitude = np.random.normal(loc=cat_Mw[index_cat], scale=cat_sig_Mw[index_cat])\n                    envents_magnitude.append(event_magnitude)\n                    index_cat += 1\n                index_mag = 0\n                for (mag_i, completness_i) in zip(bining_in_mag, completness_used):\n                    index_cat = 0\n                    picked_completness = completness_i\n                    index_cat = 0\n                    for Yr in cat_Yr:\n                        if cat_depth[index_cat] < 30.0 or math.isnan(cat_depth[index_cat]):\n                            if Yr >= picked_completness and Yr <= end_year_of_catalog:\n                                event_magnitude = envents_magnitude[index_cat]\n                                if event_magnitude >= mag_i and event_magnitude < mag_i + 0.099:\n                                    if bbPath.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                                        if not str(Yr) + str(cat_lon[index_cat]) + str(cat_lat[index_cat]) + str(cat_sig_Mw[index_cat]) in test_if_eq_here:\n                                            test_if_eq_here.append(str(Yr) + str(cat_lon[index_cat]) + str(cat_lat[index_cat]))\n                                            cat_model_bin[index_mag] += 1\n                                            string_for_map = str(Yr) + '\\t' + str(cat_Mw[index_cat]) + '\\t' + str(cat_lon[index_cat]) + '\\t' + str(cat_lat[index_cat])\n                                            if not string_for_map in earthquake_for_map:\n                                                earthquake_for_map.append(string_for_map)\n                                                nb_time_picked.append(1)\n                                            else:\n                                                index_in_cat_for_map = np.where(np.array(earthquake_for_map) == string_for_map)[0][0]\n                                                nb_time_picked[index_in_cat_for_map] += 1\n                                            index_sub_area = 0\n                                            for poly_sub_area_i in bbPath_sub_areas:\n                                                if poly_sub_area_i.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                                                    cat_sub_area_bin[index_sub_area][index_mag] += 1\n                                                index_sub_area += 1\n                        index_cat += 1\n                    rate_cat[index_mag] = cat_model_bin[index_mag] / (end_year_of_catalog - picked_completness)\n                    M0 = 10.0 ** (1.5 * mag_i + 9.1)\n                    rate_M0 = M0 * rate_cat[index_mag]\n                    seismological_moment_rate_i += rate_M0\n                    index_sub_area = 0\n                    for poly_sub_area_i in bbPath_sub_areas:\n                        rate_sub_area[index_sub_area][index_mag] = cat_sub_area_bin[index_sub_area][index_mag] / (end_year_of_catalog - picked_completness)\n                        index_sub_area += 1\n                    index_mag += 1\n                seismological_moment_rate.append(seismological_moment_rate_i)\n                number_of_earthquakes_for_rate_i = []\n                for i in range(len(cat_model_bin)):\n                    number_of_earthquakes_for_rate_i.append(int(np.sum(np.array(cat_model_bin)[-(len(cat_model_bin) - i):])))\n                number_of_earthquakes_for_rate.append(number_of_earthquakes_for_rate_i)\n                index_sub_area = 0\n                for poly_sub_area_i in bbPath_sub_areas:\n                    number_of_earthquakes_for_rate_i = []\n                    for i in range(len(cat_model_bin)):\n                        number_of_earthquakes_for_rate_i.append(int(np.sum(np.array(cat_sub_area_bin[index_sub_area])[-(len(cat_sub_area_bin[index_sub_area]) - i):])))\n                    number_of_earthquakes_for_rate_sub_area[index_sub_area].append(number_of_earthquakes_for_rate_i)\n                    index_sub_area += 1\n                rate_cat_cum = []\n                for i in range(len(rate_cat)):\n                    rate_cat_cum.append(np.sum(np.array(rate_cat)[-(len(rate_cat) - i):]))\n                rate_cat_cum_density.append(rate_cat_cum)\n                index_sub_area = 0\n                for poly_sub_area_i in bbPath_sub_areas:\n                    rate_sub_area_i_cum = []\n                    for i in range(len(rate_sub_area[index_sub_area])):\n                        rate_sub_area_i_cum.append(np.sum(np.array(rate_sub_area[index_sub_area])[-(len(rate_sub_area[index_sub_area]) - i):]))\n                    rate_in_sub_area_cum[index_sub_area].append(rate_sub_area_i_cum)\n                    index_sub_area += 1\n                plt.scatter(bining_in_mag, rate_cat_cum, c='brown', marker='_', s=50, alpha=0.2)\n                for rate_i in rate_cat_cum[:-1]:\n                    file_catalog_rate_all.write(str(rate_i) + '\\t')\n                file_catalog_rate_all.write(str(rate_cat_cum[-1]) + '\\n')\n            file_catalog_rate_all.close()\n            axes = plt.gca()\n            axes.set_xlim([xmin, xmax])\n            axes.set_ylim([ymin, ymax])\n            mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate, axis=0)\n            nb_sample = 50\n            time_simu = 1000000\n            alphas = []\n            for index_mag in range(len(bining_in_mag)):\n                nb_eq = mean_nb_eq_in_cat[index_mag]\n                if nb_eq <= 10:\n                    time_obs = int(round(end_year_of_catalog - completness[0][index_mag]))\n                    rate = float(nb_eq) / float(time_obs)\n                    cat = []\n                    for i in range(time_simu):\n                        test = np.random.uniform(0.0, 1.0)\n                        if test <= rate:\n                            cat.append(1)\n                        else:\n                            cat.append(0)\n                    rates_simu = []\n                    for i in range(nb_sample):\n                        yrs_start = random.choice(range(time_simu - time_obs))\n                        cat_sampled = cat[yrs_start:yrs_start + time_obs]\n                        rates_simu.append(sum(cat_sampled) / float(time_obs))\n                    unc_rate = np.std(rate_cat_cum_density, axis=0)[index_mag] / np.square(mean_nb_eq_in_cat[index_mag])\n                    unc_rate = np.std(rates_simu)\n                    rate_plus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] + unc_rate\n                    rate_minus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] - unc_rate\n                    if rate_minus < 0.0:\n                        rate_minus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] / 100.0\n                    if np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag] > rate_plus:\n                        rate_plus = np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag]\n                    if np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag] < rate_minus:\n                        rate_minus = np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag]\n                else:\n                    rate_plus = np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag]\n                    rate_minus = np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag]\n                mag = bining_in_mag[index_mag]\n                mag_plus = mag + 0.05\n                mag_minus = mag - 0.05\n                verts = [(mag_minus, rate_minus), (mag_minus, rate_plus), (mag_plus, rate_plus), (mag_plus, rate_minus), (mag_minus, rate_minus)]\n                codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]\n                alpha = float(np.count_nonzero(rate_cat_cum_density, axis=0)[index_mag]) / float(nb_sample) * 0.2\n                alphas.append(alpha)\n                path_poly = Path(verts, codes)\n                patch = patches.PathPatch(path_poly, facecolor='k', lw=0.0, alpha=alpha)\n                axes.add_patch(patch)\n            rgba_colors = np.zeros((len(bining_in_mag), 4))\n            rgba_colors[:, 0] = 0.0\n            rgba_colors[:, 3] = alphas\n            plt.scatter(bining_in_mag, np.array(rate_cat_cum_density).mean(axis=0), c=rgba_colors, s=20, edgecolor='', marker='s')\n            plt.yscale('log')\n            plt.title('earthquake catalog')\n            plt.grid(alpha=0.3)\n            plt.savefig(str(Run_name) + '/analysis/figures/catalogue/catalogue_' + str(model) + '.png', dpi=180, transparent=True)\n            plt.close()\n            catalog_cum_rate.append(np.array(rate_cat_cum_density).mean(axis=0))\n            index_sub_area = 0\n            for poly_sub_area_i in bbPath_sub_areas:\n                axes = plt.gca()\n                axes.set_xlim([xmin, xmax])\n                axes.set_ylim([ymin, ymax])\n                mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate_sub_area[index_sub_area], axis=0)\n                alphas = []\n                for index_mag in range(len(bining_in_mag)):\n                    nb_eq = mean_nb_eq_in_cat[index_mag]\n                    if nb_eq <= 10:\n                        time_obs = int(round(end_year_of_catalog - completness[0][index_mag]))\n                        rate = float(nb_eq) / float(time_obs)\n                        cat = []\n                        for i in range(time_simu):\n                            test = np.random.uniform(0.0, 1.0)\n                            if test <= rate:\n                                cat.append(1)\n                            else:\n                                cat.append(0)\n                        rates_simu = []\n                        for i in range(nb_sample):\n                            yrs_start = random.choice(range(time_simu - time_obs))\n                            cat_sampled = cat[yrs_start:yrs_start + time_obs]\n                            rates_simu.append(sum(cat_sampled) / float(time_obs))\n                        unc_rate = np.std(rates_simu)\n                        rate_plus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] + unc_rate\n                        rate_minus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] - unc_rate\n                        if rate_minus < 0.0:\n                            rate_minus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] / 10.0\n                        if np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag] > rate_plus:\n                            rate_plus = np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag]\n                        if np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag] < rate_minus:\n                            rate_minus = np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag]\n                    else:\n                        rate_plus = np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag]\n                        rate_minus = np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag]\n                    mag = bining_in_mag[index_mag]\n                    mag_plus = mag + 0.05\n                    mag_minus = mag - 0.05\n                    verts = [(mag_minus, rate_minus), (mag_minus, rate_plus), (mag_plus, rate_plus), (mag_plus, rate_minus), (mag_minus, rate_minus)]\n                    codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]\n                    path_poly = Path(verts, codes)\n                    alpha = float(np.count_nonzero(rate_in_sub_area_cum[index_sub_area], axis=0)[index_mag]) / float(nb_sample) * 0.2\n                    alphas.append(alpha)\n                    patch = patches.PathPatch(path_poly, facecolor='k', lw=0.0, alpha=alpha)\n                    axes.add_patch(patch)\n                for i in range(nb_inter):\n                    plt.scatter(bining_in_mag, rate_in_sub_area_cum[index_sub_area][i], c='brown', marker='_', s=50, alpha=0.2)\n                rgba_colors = np.zeros((len(bining_in_mag), 4))\n                rgba_colors[:, 0] = 0.0\n                rgba_colors[:, 3] = alphas\n                plt.scatter(bining_in_mag, np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0), c=rgba_colors, s=20, edgecolor='', marker='s')\n                axes = plt.gca()\n                axes.set_xlim([xmin, xmax])\n                axes.set_ylim([ymin, ymax])\n                plt.grid()\n                plt.yscale('log')\n                plt.title('catalogue sub area ' + sub_area_names[index_sub_area])\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/sub_area/catalogue_sub_area_' + sub_area_names[index_sub_area] + ' Model ' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n                file_cat_sub_area = open(str(Run_name) + '/analysis/figures/catalogue/sub_area/mean_rate_cat_' + sub_area_names[index_sub_area] + ' Model ' + str(model) + '.txt', 'w')\n                for index_mag in range(len(bining_in_mag)):\n                    file_cat_sub_area.write(str(bining_in_mag[index_mag]) + '\\t' + str(np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag]) + '\\n')\n                file_cat_sub_area.close()\n                index_sub_area += 1\n            file_nb_eq_in_cat = open(str(Run_name) + '/analysis/figures/catalogue/nb_eq_in_cat_' + str(model) + '.txt', 'w')\n            file_nb_eq_in_cat.write('Number of earthquake for the rate in catalogue' + '\\n')\n            mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate, axis=0)\n            for i in range(len(bining_in_mag)):\n                file_nb_eq_in_cat.write(str(bining_in_mag[i]) + '\\t' + str(round(mean_nb_eq_in_cat[i], 0)) + '\\n')\n            file_nb_eq_in_cat.close()\n            plt.scatter(bining_in_mag, mean_nb_eq_in_cat)\n            plt.axhline(y=1)\n            plt.axhline(y=2)\n            plt.axhline(y=5)\n            plt.axhline(y=10)\n            plt.title('nb of earthquakes (m>M) in the catalogue')\n            plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'nb_of_EQ_in_catalogue.png', dpi=180, transparent=True)\n            plt.grid()\n            plt.close()\n            for (string, nb) in zip(earthquake_for_map, nb_time_picked):\n                file_catalog_for_map.write(string + '\\t' + str(nb) + '\\n')\n            file_catalog_for_map.close()\n            index_sub_area = 0\n            for poly_sub_area_i in bbPath_sub_areas:\n                plt.scatter(bining_in_mag, np.mean(number_of_earthquakes_for_rate_sub_area[index_sub_area], axis=0))\n                plt.axhline(y=1)\n                plt.axhline(y=2)\n                plt.axhline(y=5)\n                plt.axhline(y=10)\n                plt.title('nb of earthquakes (m>M) in the catalogue ' + sub_area_names[index_sub_area])\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/sub_area/' + 'nb_of_EQ_in_ ' + sub_area_names[index_sub_area] + '.png', dpi=180, transparent=True)\n                plt.grid()\n                plt.close()\n                index_sub_area += 1\n            if mean_nb_eq_in_cat[0] > 3:\n                catalog_for_map = np.genfromtxt(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', dtype=['f8', 'f8', 'f8', 'f8', 'f8'])\n                yr_cat_for_map = list(map(lambda i: round(float(catalog_for_map[i][0])), range(len(catalog_for_map))))\n                M_cat_for_map = list(map(lambda i: float(catalog_for_map[i][1]), range(len(catalog_for_map))))\n                lon_cat_for_map = list(map(lambda i: float(catalog_for_map[i][2]), range(len(catalog_for_map))))\n                lat_cat_for_map = list(map(lambda i: float(catalog_for_map[i][3]), range(len(catalog_for_map))))\n                nb_time_picked = list(map(lambda i: float(catalog_for_map[i][4]), range(len(catalog_for_map))))\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n                for (Yr, M, lon, lat, nb) in zip(yr_cat_for_map, M_cat_for_map, lon_cat_for_map, lat_cat_for_map, nb_time_picked):\n                    (x, y) = m(lon, lat)\n                    if M < 5.0:\n                        c = 'b'\n                        s = 3\n                    elif M < 6.0:\n                        c = 'g'\n                        s = 5\n                    elif M < 7.0:\n                        c = 'orange'\n                        s = 7\n                    else:\n                        c = 'r'\n                        s = 10\n                    if nb >= 2 * nb_inter / 3:\n                        alpha = 1.0\n                    if nb <= 2 * nb_inter / 3:\n                        alpha = 0.8\n                    if nb <= 1 * nb_inter / 2:\n                        alpha = 0.3\n                    if nb < 1 * nb_inter / 3:\n                        alpha = 0.1\n                    c = plt.cm.jet((M - min(M_cat_for_map)) / (max(M_cat_for_map) - min(M_cat_for_map)))\n                    m.plot(x, y, '.', markersize=s, markeredgewidth=0.0, linewidth=0.2, color=c, alpha=alpha)\n                    if M > max(M_cat_for_map) - 1.0:\n                        (x_text, y_text) = m(lon + 0.005, lat + 0.005)\n                        plt.text(x_text, y_text, str(int(Yr)) + ',' + str(int(nb)), fontsize=4)\n                m.drawcoastlines(linewidth=0.1)\n                plt.gca().set_title('Earthquake catalog - Complete period')\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'earthquake_map_' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n                catalog_for_map = np.genfromtxt(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', dtype=['f8', 'f8', 'f8', 'f8', 'f8'])\n                yr_cat_for_map = list(map(lambda i: round(float(catalog_for_map[i][0])), range(len(catalog_for_map))))\n                M_cat_for_map = list(map(lambda i: float(catalog_for_map[i][1]), range(len(catalog_for_map))))\n                lon_cat_for_map = list(map(lambda i: float(catalog_for_map[i][2]), range(len(catalog_for_map))))\n                lat_cat_for_map = list(map(lambda i: float(catalog_for_map[i][3]), range(len(catalog_for_map))))\n                nb_time_picked = list(map(lambda i: float(catalog_for_map[i][4]), range(len(catalog_for_map))))\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='l')\n                for (Yr, M, lon, lat, nb) in zip(yr_cat_for_map, M_cat_for_map, lon_cat_for_map, lat_cat_for_map, nb_time_picked):\n                    (x, y) = m(lon, lat)\n                    if M < 5.0:\n                        c = 'b'\n                        s = 3\n                    elif M < 6.0:\n                        c = 'g'\n                        s = 5\n                    elif M < 7.0:\n                        c = 'orange'\n                        s = 7\n                    else:\n                        c = 'r'\n                        s = 10\n                    if nb >= float(nb_inter) / 2.0:\n                        m.plot(x, y, '.', markersize=s, markeredgewidth=0.0, linewidth=0.0, color=c, alpha=0.6)\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'earthquake_map_just_EQ_' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n        index_model += 1\n        file_eq_rate_cat = open(str(Run_name) + '/analysis/figures/catalogue/cat_cumulative_eq_rate.txt', 'w')\n        file_eq_rate_cat.write('cumulative annual eq rate in the catalog' + '\\n')\n        for (model_i, rate_i) in zip(Model_list, catalog_cum_rate):\n            file_eq_rate_cat.write(model_i)\n            for r in rate_i:\n                file_eq_rate_cat.write('\\t' + str(r))\n            file_eq_rate_cat.write('\\n')\n        file_eq_rate_cat.close()\n    else:\n        file_eq_rate_cat = str(Run_name) + '/analysis/figures/catalogue/cat_cumulative_eq_rate.txt'\n        with open(file_eq_rate_cat) as f:\n            lines_cat = f.readlines()\n        Model_list = []\n        catalog_cum_rate = []\n        for line in lines_cat[1:]:\n            cat_rates_i = line.split('\\t')\n            catalog_cum_rate.append([float(i) for i in cat_rates_i[1:]])\n        seismological_moment_rate = []\n        for rates in catalog_cum_rate:\n            rates_inc = []\n            for i in range(len(rates) - 1):\n                rates_inc.append(rates[i] - rates[i + 1])\n            rates_inc.append(rates[-1])\n            seismological_moment_rate_i = 0\n            for (mag_i, rate_i) in zip(bining_in_mag, rates_inc):\n                M0 = 10.0 ** (1.5 * mag_i + 9.1)\n                rate_M0 = M0 * rate_i\n                seismological_moment_rate_i += rate_M0\n            seismological_moment_rate.append(seismological_moment_rate_i)\n    return (seismological_moment_rate, catalog_cum_rate)",
            "def plt_catalog(do_catalog, Model_list, File_bg, catalog_file, Run_name, xmin, xmax, ymin, ymax, llcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat, completness_file, nb_inter, bining_in_mag, end_year_of_catalog, sub_area_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if do_catalog == True:\n        if not os.path.exists(str(Run_name) + '/analysis/figures/catalogue'):\n            os.makedirs(str(Run_name) + '/analysis/figures/catalogue')\n        catalog_cum_rate = []\n        index_model = 0\n        for model in Model_list:\n            file_catalog_rate_all = open(str(Run_name) + '/analysis/figures/catalogue/catalog_rates_all_' + model + '.txt', 'w')\n            for mag in bining_in_mag[:-1]:\n                file_catalog_rate_all.write(str(round(mag, 1)) + '\\t')\n            file_catalog_rate_all.write(str(round(bining_in_mag[-1], 1)) + '\\n')\n            (Lon_bg, Lat_bg) = Geom_bg(model, File_bg)\n            ColX = Lon_bg\n            ColY = Lat_bg\n            Poly = []\n            for (x1, y1) in zip(ColX, ColY):\n                Poly.append((x1, y1))\n            bbPath = mplPath.Path(Poly)\n            bbPath_sub_areas = []\n            if os.path.exists(sub_area_file):\n                read_sub_area_file = open(sub_area_file, 'rU')\n                lines_sub_area = read_sub_area_file.readlines()\n                sub_area_names = []\n                sub_area_coord = []\n                sub_area_lon = []\n                sub_area_lat = []\n                for line in lines_sub_area:\n                    model_sub_area = line.split('\\t')[0]\n                    if model == model_sub_area:\n                        sub_area_names.append(line.split('\\t')[1])\n                        sub_area_coord.append(line.split('\\t')[2:])\n                        sub_area_lon_i = []\n                        sub_area_lat_i = []\n                        for sub_area_coord_i in line.split('\\t')[2:]:\n                            if not '\\n' in sub_area_coord_i.split(','):\n                                if not '' in sub_area_coord_i.split(','):\n                                    sub_area_lon_i.append(float(sub_area_coord_i.split(',')[1]))\n                                    sub_area_lat_i.append(float(sub_area_coord_i.split(',')[0]))\n                        sub_area_lon.append(sub_area_lon_i)\n                        sub_area_lat.append(sub_area_lat_i)\n                        if not os.path.exists(str(Run_name) + '/analysis/figures/catalogue/sub_area'):\n                            os.makedirs(str(Run_name) + '/analysis/figures/catalogue/sub_area')\n                        Poly_sub = []\n                        for (x1, y1) in zip(sub_area_lon_i, sub_area_lat_i):\n                            Poly_sub.append((x1, y1))\n                        bbPath_sub_areas.append(mplPath.Path(Poly_sub))\n            cat_data = np.genfromtxt(catalog_file, dtype=['S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100'], skip_header=1)\n            cat_lon = list(map(lambda i: float(cat_data[i][5]), range(len(cat_data))))\n            cat_lat = list(map(lambda i: float(cat_data[i][4]), range(len(cat_data))))\n            cat_depth = list(map(lambda i: float(cat_data[i][6]), range(len(cat_data))))\n            cat_Mw = list(map(lambda i: float(cat_data[i][7]), range(len(cat_data))))\n            cat_sig_Mw = list(map(lambda i: float(cat_data[i][8]), range(len(cat_data))))\n            cat_Yr = list(map(lambda i: float(cat_data[i][0]), range(len(cat_data))))\n            indexes_in = []\n            for index_cat in range(len(cat_lon)):\n                if bbPath.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                    indexes_in.append(index_cat)\n            cat_lon = np.take(cat_lon, indexes_in)\n            cat_lat = np.take(cat_lat, indexes_in)\n            cat_depth = np.take(cat_depth, indexes_in)\n            cat_Mw = np.take(cat_Mw, indexes_in)\n            cat_sig_Mw = np.take(cat_sig_Mw, indexes_in)\n            cat_Yr = np.take(cat_Yr, indexes_in)\n            completness = []\n            weights_completness = []\n            read_comp_file = open(completness_file, 'rU')\n            lines_of_the_file = read_comp_file.readlines()\n            line_number = 0\n            for i in range(int(len(lines_of_the_file) / 2)):\n                if len(lines_of_the_file[line_number].split('\\t')) != 0:\n                    binning_comp_i = lines_of_the_file[line_number].split('\\t')\n                    if '\\r\\n' in binning_comp_i:\n                        binning_comp_i.remove('\\r\\n')\n                    if '\\n' in binning_comp_i:\n                        binning_comp_i.remove('\\n')\n                    binning_comp = []\n                    for magnitudes in binning_comp_i[1:]:\n                        mag = magnitudes.split(',')\n                        binning_comp.append(float(mag[0]))\n                        binning_comp.append(float(mag[1]))\n                    binning_comp.append(bining_in_mag[-1])\n                    comp_value_i = lines_of_the_file[line_number + 1].split('\\t')\n                    if '\\r\\n' in comp_value_i:\n                        comp_value_i.remove('\\r\\n')\n                    if '\\n' in comp_value_i:\n                        comp_value_i.remove('\\n')\n                    comp_value = []\n                    for value in comp_value_i[1:]:\n                        comp_value.append(float(value))\n                        comp_value.append(float(value))\n                    comp_value.append(comp_value[-1])\n                    completeness_interpolate = interp1d(binning_comp, comp_value)\n                    completness_i = []\n                    for mag in bining_in_mag:\n                        try:\n                            completness_i.append(completeness_interpolate(mag))\n                        except ValueError:\n                            print('!!!!!!!!!!!!\\n\\n\\nERROR in completeness file\\n your minimum magnitude might not be low enough\\n\\n\\n!!!!!!!!!!!!')\n                    line_number += 2\n                    completness.append(completness_i)\n                    weights_completness.append(float(comp_value_i[0]))\n            seismological_moment_rate = []\n            number_of_earthquakes_for_rate = []\n            number_of_earthquakes_for_rate_sub_area = []\n            for poly_sub_area_i in bbPath_sub_areas:\n                number_of_earthquakes_for_rate_sub_area.append([])\n            file_catalog_for_map = open(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', 'w')\n            earthquake_for_map = []\n            nb_time_picked = []\n            rate_cat_cum_density = []\n            rate_in_sub_area_cum = []\n            for poly_sub_area_i in bbPath_sub_areas:\n                rate_in_sub_area_cum.append([])\n            for i in range(nb_inter):\n                cat_model_bin = np.zeros(len(bining_in_mag))\n                rate_cat = np.zeros(len(bining_in_mag))\n                seismological_moment_rate_i = 0.0\n                test_if_eq_here = []\n                index_completness = np.random.choice(len(weights_completness), 1, p=weights_completness)[0]\n                completness_used = completness[index_completness]\n                cat_sub_area_bin = []\n                rate_sub_area = []\n                for poly_sub_area_i in bbPath_sub_areas:\n                    cat_sub_area_bin.append(np.zeros(len(bining_in_mag)))\n                    rate_sub_area.append(np.zeros(len(bining_in_mag)))\n                envents_magnitude = []\n                index_cat = 0\n                for Yr in cat_Yr:\n                    if cat_sig_Mw[index_cat] == 0:\n                        event_magnitude = cat_Mw[index_cat]\n                    elif cat_sig_Mw[index_cat] <= 3.0:\n                        event_magnitude = np.random.triangular(cat_Mw[index_cat] - cat_sig_Mw[index_cat] / 2.0, cat_Mw[index_cat], cat_Mw[index_cat] + cat_sig_Mw[index_cat] / 2.0)\n                        event_magnitude = np.random.normal(loc=cat_Mw[index_cat], scale=cat_sig_Mw[index_cat])\n                    envents_magnitude.append(event_magnitude)\n                    index_cat += 1\n                index_mag = 0\n                for (mag_i, completness_i) in zip(bining_in_mag, completness_used):\n                    index_cat = 0\n                    picked_completness = completness_i\n                    index_cat = 0\n                    for Yr in cat_Yr:\n                        if cat_depth[index_cat] < 30.0 or math.isnan(cat_depth[index_cat]):\n                            if Yr >= picked_completness and Yr <= end_year_of_catalog:\n                                event_magnitude = envents_magnitude[index_cat]\n                                if event_magnitude >= mag_i and event_magnitude < mag_i + 0.099:\n                                    if bbPath.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                                        if not str(Yr) + str(cat_lon[index_cat]) + str(cat_lat[index_cat]) + str(cat_sig_Mw[index_cat]) in test_if_eq_here:\n                                            test_if_eq_here.append(str(Yr) + str(cat_lon[index_cat]) + str(cat_lat[index_cat]))\n                                            cat_model_bin[index_mag] += 1\n                                            string_for_map = str(Yr) + '\\t' + str(cat_Mw[index_cat]) + '\\t' + str(cat_lon[index_cat]) + '\\t' + str(cat_lat[index_cat])\n                                            if not string_for_map in earthquake_for_map:\n                                                earthquake_for_map.append(string_for_map)\n                                                nb_time_picked.append(1)\n                                            else:\n                                                index_in_cat_for_map = np.where(np.array(earthquake_for_map) == string_for_map)[0][0]\n                                                nb_time_picked[index_in_cat_for_map] += 1\n                                            index_sub_area = 0\n                                            for poly_sub_area_i in bbPath_sub_areas:\n                                                if poly_sub_area_i.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                                                    cat_sub_area_bin[index_sub_area][index_mag] += 1\n                                                index_sub_area += 1\n                        index_cat += 1\n                    rate_cat[index_mag] = cat_model_bin[index_mag] / (end_year_of_catalog - picked_completness)\n                    M0 = 10.0 ** (1.5 * mag_i + 9.1)\n                    rate_M0 = M0 * rate_cat[index_mag]\n                    seismological_moment_rate_i += rate_M0\n                    index_sub_area = 0\n                    for poly_sub_area_i in bbPath_sub_areas:\n                        rate_sub_area[index_sub_area][index_mag] = cat_sub_area_bin[index_sub_area][index_mag] / (end_year_of_catalog - picked_completness)\n                        index_sub_area += 1\n                    index_mag += 1\n                seismological_moment_rate.append(seismological_moment_rate_i)\n                number_of_earthquakes_for_rate_i = []\n                for i in range(len(cat_model_bin)):\n                    number_of_earthquakes_for_rate_i.append(int(np.sum(np.array(cat_model_bin)[-(len(cat_model_bin) - i):])))\n                number_of_earthquakes_for_rate.append(number_of_earthquakes_for_rate_i)\n                index_sub_area = 0\n                for poly_sub_area_i in bbPath_sub_areas:\n                    number_of_earthquakes_for_rate_i = []\n                    for i in range(len(cat_model_bin)):\n                        number_of_earthquakes_for_rate_i.append(int(np.sum(np.array(cat_sub_area_bin[index_sub_area])[-(len(cat_sub_area_bin[index_sub_area]) - i):])))\n                    number_of_earthquakes_for_rate_sub_area[index_sub_area].append(number_of_earthquakes_for_rate_i)\n                    index_sub_area += 1\n                rate_cat_cum = []\n                for i in range(len(rate_cat)):\n                    rate_cat_cum.append(np.sum(np.array(rate_cat)[-(len(rate_cat) - i):]))\n                rate_cat_cum_density.append(rate_cat_cum)\n                index_sub_area = 0\n                for poly_sub_area_i in bbPath_sub_areas:\n                    rate_sub_area_i_cum = []\n                    for i in range(len(rate_sub_area[index_sub_area])):\n                        rate_sub_area_i_cum.append(np.sum(np.array(rate_sub_area[index_sub_area])[-(len(rate_sub_area[index_sub_area]) - i):]))\n                    rate_in_sub_area_cum[index_sub_area].append(rate_sub_area_i_cum)\n                    index_sub_area += 1\n                plt.scatter(bining_in_mag, rate_cat_cum, c='brown', marker='_', s=50, alpha=0.2)\n                for rate_i in rate_cat_cum[:-1]:\n                    file_catalog_rate_all.write(str(rate_i) + '\\t')\n                file_catalog_rate_all.write(str(rate_cat_cum[-1]) + '\\n')\n            file_catalog_rate_all.close()\n            axes = plt.gca()\n            axes.set_xlim([xmin, xmax])\n            axes.set_ylim([ymin, ymax])\n            mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate, axis=0)\n            nb_sample = 50\n            time_simu = 1000000\n            alphas = []\n            for index_mag in range(len(bining_in_mag)):\n                nb_eq = mean_nb_eq_in_cat[index_mag]\n                if nb_eq <= 10:\n                    time_obs = int(round(end_year_of_catalog - completness[0][index_mag]))\n                    rate = float(nb_eq) / float(time_obs)\n                    cat = []\n                    for i in range(time_simu):\n                        test = np.random.uniform(0.0, 1.0)\n                        if test <= rate:\n                            cat.append(1)\n                        else:\n                            cat.append(0)\n                    rates_simu = []\n                    for i in range(nb_sample):\n                        yrs_start = random.choice(range(time_simu - time_obs))\n                        cat_sampled = cat[yrs_start:yrs_start + time_obs]\n                        rates_simu.append(sum(cat_sampled) / float(time_obs))\n                    unc_rate = np.std(rate_cat_cum_density, axis=0)[index_mag] / np.square(mean_nb_eq_in_cat[index_mag])\n                    unc_rate = np.std(rates_simu)\n                    rate_plus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] + unc_rate\n                    rate_minus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] - unc_rate\n                    if rate_minus < 0.0:\n                        rate_minus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] / 100.0\n                    if np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag] > rate_plus:\n                        rate_plus = np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag]\n                    if np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag] < rate_minus:\n                        rate_minus = np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag]\n                else:\n                    rate_plus = np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag]\n                    rate_minus = np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag]\n                mag = bining_in_mag[index_mag]\n                mag_plus = mag + 0.05\n                mag_minus = mag - 0.05\n                verts = [(mag_minus, rate_minus), (mag_minus, rate_plus), (mag_plus, rate_plus), (mag_plus, rate_minus), (mag_minus, rate_minus)]\n                codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]\n                alpha = float(np.count_nonzero(rate_cat_cum_density, axis=0)[index_mag]) / float(nb_sample) * 0.2\n                alphas.append(alpha)\n                path_poly = Path(verts, codes)\n                patch = patches.PathPatch(path_poly, facecolor='k', lw=0.0, alpha=alpha)\n                axes.add_patch(patch)\n            rgba_colors = np.zeros((len(bining_in_mag), 4))\n            rgba_colors[:, 0] = 0.0\n            rgba_colors[:, 3] = alphas\n            plt.scatter(bining_in_mag, np.array(rate_cat_cum_density).mean(axis=0), c=rgba_colors, s=20, edgecolor='', marker='s')\n            plt.yscale('log')\n            plt.title('earthquake catalog')\n            plt.grid(alpha=0.3)\n            plt.savefig(str(Run_name) + '/analysis/figures/catalogue/catalogue_' + str(model) + '.png', dpi=180, transparent=True)\n            plt.close()\n            catalog_cum_rate.append(np.array(rate_cat_cum_density).mean(axis=0))\n            index_sub_area = 0\n            for poly_sub_area_i in bbPath_sub_areas:\n                axes = plt.gca()\n                axes.set_xlim([xmin, xmax])\n                axes.set_ylim([ymin, ymax])\n                mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate_sub_area[index_sub_area], axis=0)\n                alphas = []\n                for index_mag in range(len(bining_in_mag)):\n                    nb_eq = mean_nb_eq_in_cat[index_mag]\n                    if nb_eq <= 10:\n                        time_obs = int(round(end_year_of_catalog - completness[0][index_mag]))\n                        rate = float(nb_eq) / float(time_obs)\n                        cat = []\n                        for i in range(time_simu):\n                            test = np.random.uniform(0.0, 1.0)\n                            if test <= rate:\n                                cat.append(1)\n                            else:\n                                cat.append(0)\n                        rates_simu = []\n                        for i in range(nb_sample):\n                            yrs_start = random.choice(range(time_simu - time_obs))\n                            cat_sampled = cat[yrs_start:yrs_start + time_obs]\n                            rates_simu.append(sum(cat_sampled) / float(time_obs))\n                        unc_rate = np.std(rates_simu)\n                        rate_plus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] + unc_rate\n                        rate_minus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] - unc_rate\n                        if rate_minus < 0.0:\n                            rate_minus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] / 10.0\n                        if np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag] > rate_plus:\n                            rate_plus = np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag]\n                        if np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag] < rate_minus:\n                            rate_minus = np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag]\n                    else:\n                        rate_plus = np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag]\n                        rate_minus = np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag]\n                    mag = bining_in_mag[index_mag]\n                    mag_plus = mag + 0.05\n                    mag_minus = mag - 0.05\n                    verts = [(mag_minus, rate_minus), (mag_minus, rate_plus), (mag_plus, rate_plus), (mag_plus, rate_minus), (mag_minus, rate_minus)]\n                    codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]\n                    path_poly = Path(verts, codes)\n                    alpha = float(np.count_nonzero(rate_in_sub_area_cum[index_sub_area], axis=0)[index_mag]) / float(nb_sample) * 0.2\n                    alphas.append(alpha)\n                    patch = patches.PathPatch(path_poly, facecolor='k', lw=0.0, alpha=alpha)\n                    axes.add_patch(patch)\n                for i in range(nb_inter):\n                    plt.scatter(bining_in_mag, rate_in_sub_area_cum[index_sub_area][i], c='brown', marker='_', s=50, alpha=0.2)\n                rgba_colors = np.zeros((len(bining_in_mag), 4))\n                rgba_colors[:, 0] = 0.0\n                rgba_colors[:, 3] = alphas\n                plt.scatter(bining_in_mag, np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0), c=rgba_colors, s=20, edgecolor='', marker='s')\n                axes = plt.gca()\n                axes.set_xlim([xmin, xmax])\n                axes.set_ylim([ymin, ymax])\n                plt.grid()\n                plt.yscale('log')\n                plt.title('catalogue sub area ' + sub_area_names[index_sub_area])\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/sub_area/catalogue_sub_area_' + sub_area_names[index_sub_area] + ' Model ' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n                file_cat_sub_area = open(str(Run_name) + '/analysis/figures/catalogue/sub_area/mean_rate_cat_' + sub_area_names[index_sub_area] + ' Model ' + str(model) + '.txt', 'w')\n                for index_mag in range(len(bining_in_mag)):\n                    file_cat_sub_area.write(str(bining_in_mag[index_mag]) + '\\t' + str(np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag]) + '\\n')\n                file_cat_sub_area.close()\n                index_sub_area += 1\n            file_nb_eq_in_cat = open(str(Run_name) + '/analysis/figures/catalogue/nb_eq_in_cat_' + str(model) + '.txt', 'w')\n            file_nb_eq_in_cat.write('Number of earthquake for the rate in catalogue' + '\\n')\n            mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate, axis=0)\n            for i in range(len(bining_in_mag)):\n                file_nb_eq_in_cat.write(str(bining_in_mag[i]) + '\\t' + str(round(mean_nb_eq_in_cat[i], 0)) + '\\n')\n            file_nb_eq_in_cat.close()\n            plt.scatter(bining_in_mag, mean_nb_eq_in_cat)\n            plt.axhline(y=1)\n            plt.axhline(y=2)\n            plt.axhline(y=5)\n            plt.axhline(y=10)\n            plt.title('nb of earthquakes (m>M) in the catalogue')\n            plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'nb_of_EQ_in_catalogue.png', dpi=180, transparent=True)\n            plt.grid()\n            plt.close()\n            for (string, nb) in zip(earthquake_for_map, nb_time_picked):\n                file_catalog_for_map.write(string + '\\t' + str(nb) + '\\n')\n            file_catalog_for_map.close()\n            index_sub_area = 0\n            for poly_sub_area_i in bbPath_sub_areas:\n                plt.scatter(bining_in_mag, np.mean(number_of_earthquakes_for_rate_sub_area[index_sub_area], axis=0))\n                plt.axhline(y=1)\n                plt.axhline(y=2)\n                plt.axhline(y=5)\n                plt.axhline(y=10)\n                plt.title('nb of earthquakes (m>M) in the catalogue ' + sub_area_names[index_sub_area])\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/sub_area/' + 'nb_of_EQ_in_ ' + sub_area_names[index_sub_area] + '.png', dpi=180, transparent=True)\n                plt.grid()\n                plt.close()\n                index_sub_area += 1\n            if mean_nb_eq_in_cat[0] > 3:\n                catalog_for_map = np.genfromtxt(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', dtype=['f8', 'f8', 'f8', 'f8', 'f8'])\n                yr_cat_for_map = list(map(lambda i: round(float(catalog_for_map[i][0])), range(len(catalog_for_map))))\n                M_cat_for_map = list(map(lambda i: float(catalog_for_map[i][1]), range(len(catalog_for_map))))\n                lon_cat_for_map = list(map(lambda i: float(catalog_for_map[i][2]), range(len(catalog_for_map))))\n                lat_cat_for_map = list(map(lambda i: float(catalog_for_map[i][3]), range(len(catalog_for_map))))\n                nb_time_picked = list(map(lambda i: float(catalog_for_map[i][4]), range(len(catalog_for_map))))\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n                for (Yr, M, lon, lat, nb) in zip(yr_cat_for_map, M_cat_for_map, lon_cat_for_map, lat_cat_for_map, nb_time_picked):\n                    (x, y) = m(lon, lat)\n                    if M < 5.0:\n                        c = 'b'\n                        s = 3\n                    elif M < 6.0:\n                        c = 'g'\n                        s = 5\n                    elif M < 7.0:\n                        c = 'orange'\n                        s = 7\n                    else:\n                        c = 'r'\n                        s = 10\n                    if nb >= 2 * nb_inter / 3:\n                        alpha = 1.0\n                    if nb <= 2 * nb_inter / 3:\n                        alpha = 0.8\n                    if nb <= 1 * nb_inter / 2:\n                        alpha = 0.3\n                    if nb < 1 * nb_inter / 3:\n                        alpha = 0.1\n                    c = plt.cm.jet((M - min(M_cat_for_map)) / (max(M_cat_for_map) - min(M_cat_for_map)))\n                    m.plot(x, y, '.', markersize=s, markeredgewidth=0.0, linewidth=0.2, color=c, alpha=alpha)\n                    if M > max(M_cat_for_map) - 1.0:\n                        (x_text, y_text) = m(lon + 0.005, lat + 0.005)\n                        plt.text(x_text, y_text, str(int(Yr)) + ',' + str(int(nb)), fontsize=4)\n                m.drawcoastlines(linewidth=0.1)\n                plt.gca().set_title('Earthquake catalog - Complete period')\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'earthquake_map_' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n                catalog_for_map = np.genfromtxt(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', dtype=['f8', 'f8', 'f8', 'f8', 'f8'])\n                yr_cat_for_map = list(map(lambda i: round(float(catalog_for_map[i][0])), range(len(catalog_for_map))))\n                M_cat_for_map = list(map(lambda i: float(catalog_for_map[i][1]), range(len(catalog_for_map))))\n                lon_cat_for_map = list(map(lambda i: float(catalog_for_map[i][2]), range(len(catalog_for_map))))\n                lat_cat_for_map = list(map(lambda i: float(catalog_for_map[i][3]), range(len(catalog_for_map))))\n                nb_time_picked = list(map(lambda i: float(catalog_for_map[i][4]), range(len(catalog_for_map))))\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='l')\n                for (Yr, M, lon, lat, nb) in zip(yr_cat_for_map, M_cat_for_map, lon_cat_for_map, lat_cat_for_map, nb_time_picked):\n                    (x, y) = m(lon, lat)\n                    if M < 5.0:\n                        c = 'b'\n                        s = 3\n                    elif M < 6.0:\n                        c = 'g'\n                        s = 5\n                    elif M < 7.0:\n                        c = 'orange'\n                        s = 7\n                    else:\n                        c = 'r'\n                        s = 10\n                    if nb >= float(nb_inter) / 2.0:\n                        m.plot(x, y, '.', markersize=s, markeredgewidth=0.0, linewidth=0.0, color=c, alpha=0.6)\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'earthquake_map_just_EQ_' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n        index_model += 1\n        file_eq_rate_cat = open(str(Run_name) + '/analysis/figures/catalogue/cat_cumulative_eq_rate.txt', 'w')\n        file_eq_rate_cat.write('cumulative annual eq rate in the catalog' + '\\n')\n        for (model_i, rate_i) in zip(Model_list, catalog_cum_rate):\n            file_eq_rate_cat.write(model_i)\n            for r in rate_i:\n                file_eq_rate_cat.write('\\t' + str(r))\n            file_eq_rate_cat.write('\\n')\n        file_eq_rate_cat.close()\n    else:\n        file_eq_rate_cat = str(Run_name) + '/analysis/figures/catalogue/cat_cumulative_eq_rate.txt'\n        with open(file_eq_rate_cat) as f:\n            lines_cat = f.readlines()\n        Model_list = []\n        catalog_cum_rate = []\n        for line in lines_cat[1:]:\n            cat_rates_i = line.split('\\t')\n            catalog_cum_rate.append([float(i) for i in cat_rates_i[1:]])\n        seismological_moment_rate = []\n        for rates in catalog_cum_rate:\n            rates_inc = []\n            for i in range(len(rates) - 1):\n                rates_inc.append(rates[i] - rates[i + 1])\n            rates_inc.append(rates[-1])\n            seismological_moment_rate_i = 0\n            for (mag_i, rate_i) in zip(bining_in_mag, rates_inc):\n                M0 = 10.0 ** (1.5 * mag_i + 9.1)\n                rate_M0 = M0 * rate_i\n                seismological_moment_rate_i += rate_M0\n            seismological_moment_rate.append(seismological_moment_rate_i)\n    return (seismological_moment_rate, catalog_cum_rate)",
            "def plt_catalog(do_catalog, Model_list, File_bg, catalog_file, Run_name, xmin, xmax, ymin, ymax, llcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat, completness_file, nb_inter, bining_in_mag, end_year_of_catalog, sub_area_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if do_catalog == True:\n        if not os.path.exists(str(Run_name) + '/analysis/figures/catalogue'):\n            os.makedirs(str(Run_name) + '/analysis/figures/catalogue')\n        catalog_cum_rate = []\n        index_model = 0\n        for model in Model_list:\n            file_catalog_rate_all = open(str(Run_name) + '/analysis/figures/catalogue/catalog_rates_all_' + model + '.txt', 'w')\n            for mag in bining_in_mag[:-1]:\n                file_catalog_rate_all.write(str(round(mag, 1)) + '\\t')\n            file_catalog_rate_all.write(str(round(bining_in_mag[-1], 1)) + '\\n')\n            (Lon_bg, Lat_bg) = Geom_bg(model, File_bg)\n            ColX = Lon_bg\n            ColY = Lat_bg\n            Poly = []\n            for (x1, y1) in zip(ColX, ColY):\n                Poly.append((x1, y1))\n            bbPath = mplPath.Path(Poly)\n            bbPath_sub_areas = []\n            if os.path.exists(sub_area_file):\n                read_sub_area_file = open(sub_area_file, 'rU')\n                lines_sub_area = read_sub_area_file.readlines()\n                sub_area_names = []\n                sub_area_coord = []\n                sub_area_lon = []\n                sub_area_lat = []\n                for line in lines_sub_area:\n                    model_sub_area = line.split('\\t')[0]\n                    if model == model_sub_area:\n                        sub_area_names.append(line.split('\\t')[1])\n                        sub_area_coord.append(line.split('\\t')[2:])\n                        sub_area_lon_i = []\n                        sub_area_lat_i = []\n                        for sub_area_coord_i in line.split('\\t')[2:]:\n                            if not '\\n' in sub_area_coord_i.split(','):\n                                if not '' in sub_area_coord_i.split(','):\n                                    sub_area_lon_i.append(float(sub_area_coord_i.split(',')[1]))\n                                    sub_area_lat_i.append(float(sub_area_coord_i.split(',')[0]))\n                        sub_area_lon.append(sub_area_lon_i)\n                        sub_area_lat.append(sub_area_lat_i)\n                        if not os.path.exists(str(Run_name) + '/analysis/figures/catalogue/sub_area'):\n                            os.makedirs(str(Run_name) + '/analysis/figures/catalogue/sub_area')\n                        Poly_sub = []\n                        for (x1, y1) in zip(sub_area_lon_i, sub_area_lat_i):\n                            Poly_sub.append((x1, y1))\n                        bbPath_sub_areas.append(mplPath.Path(Poly_sub))\n            cat_data = np.genfromtxt(catalog_file, dtype=['S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100'], skip_header=1)\n            cat_lon = list(map(lambda i: float(cat_data[i][5]), range(len(cat_data))))\n            cat_lat = list(map(lambda i: float(cat_data[i][4]), range(len(cat_data))))\n            cat_depth = list(map(lambda i: float(cat_data[i][6]), range(len(cat_data))))\n            cat_Mw = list(map(lambda i: float(cat_data[i][7]), range(len(cat_data))))\n            cat_sig_Mw = list(map(lambda i: float(cat_data[i][8]), range(len(cat_data))))\n            cat_Yr = list(map(lambda i: float(cat_data[i][0]), range(len(cat_data))))\n            indexes_in = []\n            for index_cat in range(len(cat_lon)):\n                if bbPath.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                    indexes_in.append(index_cat)\n            cat_lon = np.take(cat_lon, indexes_in)\n            cat_lat = np.take(cat_lat, indexes_in)\n            cat_depth = np.take(cat_depth, indexes_in)\n            cat_Mw = np.take(cat_Mw, indexes_in)\n            cat_sig_Mw = np.take(cat_sig_Mw, indexes_in)\n            cat_Yr = np.take(cat_Yr, indexes_in)\n            completness = []\n            weights_completness = []\n            read_comp_file = open(completness_file, 'rU')\n            lines_of_the_file = read_comp_file.readlines()\n            line_number = 0\n            for i in range(int(len(lines_of_the_file) / 2)):\n                if len(lines_of_the_file[line_number].split('\\t')) != 0:\n                    binning_comp_i = lines_of_the_file[line_number].split('\\t')\n                    if '\\r\\n' in binning_comp_i:\n                        binning_comp_i.remove('\\r\\n')\n                    if '\\n' in binning_comp_i:\n                        binning_comp_i.remove('\\n')\n                    binning_comp = []\n                    for magnitudes in binning_comp_i[1:]:\n                        mag = magnitudes.split(',')\n                        binning_comp.append(float(mag[0]))\n                        binning_comp.append(float(mag[1]))\n                    binning_comp.append(bining_in_mag[-1])\n                    comp_value_i = lines_of_the_file[line_number + 1].split('\\t')\n                    if '\\r\\n' in comp_value_i:\n                        comp_value_i.remove('\\r\\n')\n                    if '\\n' in comp_value_i:\n                        comp_value_i.remove('\\n')\n                    comp_value = []\n                    for value in comp_value_i[1:]:\n                        comp_value.append(float(value))\n                        comp_value.append(float(value))\n                    comp_value.append(comp_value[-1])\n                    completeness_interpolate = interp1d(binning_comp, comp_value)\n                    completness_i = []\n                    for mag in bining_in_mag:\n                        try:\n                            completness_i.append(completeness_interpolate(mag))\n                        except ValueError:\n                            print('!!!!!!!!!!!!\\n\\n\\nERROR in completeness file\\n your minimum magnitude might not be low enough\\n\\n\\n!!!!!!!!!!!!')\n                    line_number += 2\n                    completness.append(completness_i)\n                    weights_completness.append(float(comp_value_i[0]))\n            seismological_moment_rate = []\n            number_of_earthquakes_for_rate = []\n            number_of_earthquakes_for_rate_sub_area = []\n            for poly_sub_area_i in bbPath_sub_areas:\n                number_of_earthquakes_for_rate_sub_area.append([])\n            file_catalog_for_map = open(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', 'w')\n            earthquake_for_map = []\n            nb_time_picked = []\n            rate_cat_cum_density = []\n            rate_in_sub_area_cum = []\n            for poly_sub_area_i in bbPath_sub_areas:\n                rate_in_sub_area_cum.append([])\n            for i in range(nb_inter):\n                cat_model_bin = np.zeros(len(bining_in_mag))\n                rate_cat = np.zeros(len(bining_in_mag))\n                seismological_moment_rate_i = 0.0\n                test_if_eq_here = []\n                index_completness = np.random.choice(len(weights_completness), 1, p=weights_completness)[0]\n                completness_used = completness[index_completness]\n                cat_sub_area_bin = []\n                rate_sub_area = []\n                for poly_sub_area_i in bbPath_sub_areas:\n                    cat_sub_area_bin.append(np.zeros(len(bining_in_mag)))\n                    rate_sub_area.append(np.zeros(len(bining_in_mag)))\n                envents_magnitude = []\n                index_cat = 0\n                for Yr in cat_Yr:\n                    if cat_sig_Mw[index_cat] == 0:\n                        event_magnitude = cat_Mw[index_cat]\n                    elif cat_sig_Mw[index_cat] <= 3.0:\n                        event_magnitude = np.random.triangular(cat_Mw[index_cat] - cat_sig_Mw[index_cat] / 2.0, cat_Mw[index_cat], cat_Mw[index_cat] + cat_sig_Mw[index_cat] / 2.0)\n                        event_magnitude = np.random.normal(loc=cat_Mw[index_cat], scale=cat_sig_Mw[index_cat])\n                    envents_magnitude.append(event_magnitude)\n                    index_cat += 1\n                index_mag = 0\n                for (mag_i, completness_i) in zip(bining_in_mag, completness_used):\n                    index_cat = 0\n                    picked_completness = completness_i\n                    index_cat = 0\n                    for Yr in cat_Yr:\n                        if cat_depth[index_cat] < 30.0 or math.isnan(cat_depth[index_cat]):\n                            if Yr >= picked_completness and Yr <= end_year_of_catalog:\n                                event_magnitude = envents_magnitude[index_cat]\n                                if event_magnitude >= mag_i and event_magnitude < mag_i + 0.099:\n                                    if bbPath.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                                        if not str(Yr) + str(cat_lon[index_cat]) + str(cat_lat[index_cat]) + str(cat_sig_Mw[index_cat]) in test_if_eq_here:\n                                            test_if_eq_here.append(str(Yr) + str(cat_lon[index_cat]) + str(cat_lat[index_cat]))\n                                            cat_model_bin[index_mag] += 1\n                                            string_for_map = str(Yr) + '\\t' + str(cat_Mw[index_cat]) + '\\t' + str(cat_lon[index_cat]) + '\\t' + str(cat_lat[index_cat])\n                                            if not string_for_map in earthquake_for_map:\n                                                earthquake_for_map.append(string_for_map)\n                                                nb_time_picked.append(1)\n                                            else:\n                                                index_in_cat_for_map = np.where(np.array(earthquake_for_map) == string_for_map)[0][0]\n                                                nb_time_picked[index_in_cat_for_map] += 1\n                                            index_sub_area = 0\n                                            for poly_sub_area_i in bbPath_sub_areas:\n                                                if poly_sub_area_i.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                                                    cat_sub_area_bin[index_sub_area][index_mag] += 1\n                                                index_sub_area += 1\n                        index_cat += 1\n                    rate_cat[index_mag] = cat_model_bin[index_mag] / (end_year_of_catalog - picked_completness)\n                    M0 = 10.0 ** (1.5 * mag_i + 9.1)\n                    rate_M0 = M0 * rate_cat[index_mag]\n                    seismological_moment_rate_i += rate_M0\n                    index_sub_area = 0\n                    for poly_sub_area_i in bbPath_sub_areas:\n                        rate_sub_area[index_sub_area][index_mag] = cat_sub_area_bin[index_sub_area][index_mag] / (end_year_of_catalog - picked_completness)\n                        index_sub_area += 1\n                    index_mag += 1\n                seismological_moment_rate.append(seismological_moment_rate_i)\n                number_of_earthquakes_for_rate_i = []\n                for i in range(len(cat_model_bin)):\n                    number_of_earthquakes_for_rate_i.append(int(np.sum(np.array(cat_model_bin)[-(len(cat_model_bin) - i):])))\n                number_of_earthquakes_for_rate.append(number_of_earthquakes_for_rate_i)\n                index_sub_area = 0\n                for poly_sub_area_i in bbPath_sub_areas:\n                    number_of_earthquakes_for_rate_i = []\n                    for i in range(len(cat_model_bin)):\n                        number_of_earthquakes_for_rate_i.append(int(np.sum(np.array(cat_sub_area_bin[index_sub_area])[-(len(cat_sub_area_bin[index_sub_area]) - i):])))\n                    number_of_earthquakes_for_rate_sub_area[index_sub_area].append(number_of_earthquakes_for_rate_i)\n                    index_sub_area += 1\n                rate_cat_cum = []\n                for i in range(len(rate_cat)):\n                    rate_cat_cum.append(np.sum(np.array(rate_cat)[-(len(rate_cat) - i):]))\n                rate_cat_cum_density.append(rate_cat_cum)\n                index_sub_area = 0\n                for poly_sub_area_i in bbPath_sub_areas:\n                    rate_sub_area_i_cum = []\n                    for i in range(len(rate_sub_area[index_sub_area])):\n                        rate_sub_area_i_cum.append(np.sum(np.array(rate_sub_area[index_sub_area])[-(len(rate_sub_area[index_sub_area]) - i):]))\n                    rate_in_sub_area_cum[index_sub_area].append(rate_sub_area_i_cum)\n                    index_sub_area += 1\n                plt.scatter(bining_in_mag, rate_cat_cum, c='brown', marker='_', s=50, alpha=0.2)\n                for rate_i in rate_cat_cum[:-1]:\n                    file_catalog_rate_all.write(str(rate_i) + '\\t')\n                file_catalog_rate_all.write(str(rate_cat_cum[-1]) + '\\n')\n            file_catalog_rate_all.close()\n            axes = plt.gca()\n            axes.set_xlim([xmin, xmax])\n            axes.set_ylim([ymin, ymax])\n            mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate, axis=0)\n            nb_sample = 50\n            time_simu = 1000000\n            alphas = []\n            for index_mag in range(len(bining_in_mag)):\n                nb_eq = mean_nb_eq_in_cat[index_mag]\n                if nb_eq <= 10:\n                    time_obs = int(round(end_year_of_catalog - completness[0][index_mag]))\n                    rate = float(nb_eq) / float(time_obs)\n                    cat = []\n                    for i in range(time_simu):\n                        test = np.random.uniform(0.0, 1.0)\n                        if test <= rate:\n                            cat.append(1)\n                        else:\n                            cat.append(0)\n                    rates_simu = []\n                    for i in range(nb_sample):\n                        yrs_start = random.choice(range(time_simu - time_obs))\n                        cat_sampled = cat[yrs_start:yrs_start + time_obs]\n                        rates_simu.append(sum(cat_sampled) / float(time_obs))\n                    unc_rate = np.std(rate_cat_cum_density, axis=0)[index_mag] / np.square(mean_nb_eq_in_cat[index_mag])\n                    unc_rate = np.std(rates_simu)\n                    rate_plus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] + unc_rate\n                    rate_minus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] - unc_rate\n                    if rate_minus < 0.0:\n                        rate_minus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] / 100.0\n                    if np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag] > rate_plus:\n                        rate_plus = np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag]\n                    if np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag] < rate_minus:\n                        rate_minus = np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag]\n                else:\n                    rate_plus = np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag]\n                    rate_minus = np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag]\n                mag = bining_in_mag[index_mag]\n                mag_plus = mag + 0.05\n                mag_minus = mag - 0.05\n                verts = [(mag_minus, rate_minus), (mag_minus, rate_plus), (mag_plus, rate_plus), (mag_plus, rate_minus), (mag_minus, rate_minus)]\n                codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]\n                alpha = float(np.count_nonzero(rate_cat_cum_density, axis=0)[index_mag]) / float(nb_sample) * 0.2\n                alphas.append(alpha)\n                path_poly = Path(verts, codes)\n                patch = patches.PathPatch(path_poly, facecolor='k', lw=0.0, alpha=alpha)\n                axes.add_patch(patch)\n            rgba_colors = np.zeros((len(bining_in_mag), 4))\n            rgba_colors[:, 0] = 0.0\n            rgba_colors[:, 3] = alphas\n            plt.scatter(bining_in_mag, np.array(rate_cat_cum_density).mean(axis=0), c=rgba_colors, s=20, edgecolor='', marker='s')\n            plt.yscale('log')\n            plt.title('earthquake catalog')\n            plt.grid(alpha=0.3)\n            plt.savefig(str(Run_name) + '/analysis/figures/catalogue/catalogue_' + str(model) + '.png', dpi=180, transparent=True)\n            plt.close()\n            catalog_cum_rate.append(np.array(rate_cat_cum_density).mean(axis=0))\n            index_sub_area = 0\n            for poly_sub_area_i in bbPath_sub_areas:\n                axes = plt.gca()\n                axes.set_xlim([xmin, xmax])\n                axes.set_ylim([ymin, ymax])\n                mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate_sub_area[index_sub_area], axis=0)\n                alphas = []\n                for index_mag in range(len(bining_in_mag)):\n                    nb_eq = mean_nb_eq_in_cat[index_mag]\n                    if nb_eq <= 10:\n                        time_obs = int(round(end_year_of_catalog - completness[0][index_mag]))\n                        rate = float(nb_eq) / float(time_obs)\n                        cat = []\n                        for i in range(time_simu):\n                            test = np.random.uniform(0.0, 1.0)\n                            if test <= rate:\n                                cat.append(1)\n                            else:\n                                cat.append(0)\n                        rates_simu = []\n                        for i in range(nb_sample):\n                            yrs_start = random.choice(range(time_simu - time_obs))\n                            cat_sampled = cat[yrs_start:yrs_start + time_obs]\n                            rates_simu.append(sum(cat_sampled) / float(time_obs))\n                        unc_rate = np.std(rates_simu)\n                        rate_plus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] + unc_rate\n                        rate_minus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] - unc_rate\n                        if rate_minus < 0.0:\n                            rate_minus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] / 10.0\n                        if np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag] > rate_plus:\n                            rate_plus = np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag]\n                        if np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag] < rate_minus:\n                            rate_minus = np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag]\n                    else:\n                        rate_plus = np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag]\n                        rate_minus = np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag]\n                    mag = bining_in_mag[index_mag]\n                    mag_plus = mag + 0.05\n                    mag_minus = mag - 0.05\n                    verts = [(mag_minus, rate_minus), (mag_minus, rate_plus), (mag_plus, rate_plus), (mag_plus, rate_minus), (mag_minus, rate_minus)]\n                    codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]\n                    path_poly = Path(verts, codes)\n                    alpha = float(np.count_nonzero(rate_in_sub_area_cum[index_sub_area], axis=0)[index_mag]) / float(nb_sample) * 0.2\n                    alphas.append(alpha)\n                    patch = patches.PathPatch(path_poly, facecolor='k', lw=0.0, alpha=alpha)\n                    axes.add_patch(patch)\n                for i in range(nb_inter):\n                    plt.scatter(bining_in_mag, rate_in_sub_area_cum[index_sub_area][i], c='brown', marker='_', s=50, alpha=0.2)\n                rgba_colors = np.zeros((len(bining_in_mag), 4))\n                rgba_colors[:, 0] = 0.0\n                rgba_colors[:, 3] = alphas\n                plt.scatter(bining_in_mag, np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0), c=rgba_colors, s=20, edgecolor='', marker='s')\n                axes = plt.gca()\n                axes.set_xlim([xmin, xmax])\n                axes.set_ylim([ymin, ymax])\n                plt.grid()\n                plt.yscale('log')\n                plt.title('catalogue sub area ' + sub_area_names[index_sub_area])\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/sub_area/catalogue_sub_area_' + sub_area_names[index_sub_area] + ' Model ' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n                file_cat_sub_area = open(str(Run_name) + '/analysis/figures/catalogue/sub_area/mean_rate_cat_' + sub_area_names[index_sub_area] + ' Model ' + str(model) + '.txt', 'w')\n                for index_mag in range(len(bining_in_mag)):\n                    file_cat_sub_area.write(str(bining_in_mag[index_mag]) + '\\t' + str(np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag]) + '\\n')\n                file_cat_sub_area.close()\n                index_sub_area += 1\n            file_nb_eq_in_cat = open(str(Run_name) + '/analysis/figures/catalogue/nb_eq_in_cat_' + str(model) + '.txt', 'w')\n            file_nb_eq_in_cat.write('Number of earthquake for the rate in catalogue' + '\\n')\n            mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate, axis=0)\n            for i in range(len(bining_in_mag)):\n                file_nb_eq_in_cat.write(str(bining_in_mag[i]) + '\\t' + str(round(mean_nb_eq_in_cat[i], 0)) + '\\n')\n            file_nb_eq_in_cat.close()\n            plt.scatter(bining_in_mag, mean_nb_eq_in_cat)\n            plt.axhline(y=1)\n            plt.axhline(y=2)\n            plt.axhline(y=5)\n            plt.axhline(y=10)\n            plt.title('nb of earthquakes (m>M) in the catalogue')\n            plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'nb_of_EQ_in_catalogue.png', dpi=180, transparent=True)\n            plt.grid()\n            plt.close()\n            for (string, nb) in zip(earthquake_for_map, nb_time_picked):\n                file_catalog_for_map.write(string + '\\t' + str(nb) + '\\n')\n            file_catalog_for_map.close()\n            index_sub_area = 0\n            for poly_sub_area_i in bbPath_sub_areas:\n                plt.scatter(bining_in_mag, np.mean(number_of_earthquakes_for_rate_sub_area[index_sub_area], axis=0))\n                plt.axhline(y=1)\n                plt.axhline(y=2)\n                plt.axhline(y=5)\n                plt.axhline(y=10)\n                plt.title('nb of earthquakes (m>M) in the catalogue ' + sub_area_names[index_sub_area])\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/sub_area/' + 'nb_of_EQ_in_ ' + sub_area_names[index_sub_area] + '.png', dpi=180, transparent=True)\n                plt.grid()\n                plt.close()\n                index_sub_area += 1\n            if mean_nb_eq_in_cat[0] > 3:\n                catalog_for_map = np.genfromtxt(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', dtype=['f8', 'f8', 'f8', 'f8', 'f8'])\n                yr_cat_for_map = list(map(lambda i: round(float(catalog_for_map[i][0])), range(len(catalog_for_map))))\n                M_cat_for_map = list(map(lambda i: float(catalog_for_map[i][1]), range(len(catalog_for_map))))\n                lon_cat_for_map = list(map(lambda i: float(catalog_for_map[i][2]), range(len(catalog_for_map))))\n                lat_cat_for_map = list(map(lambda i: float(catalog_for_map[i][3]), range(len(catalog_for_map))))\n                nb_time_picked = list(map(lambda i: float(catalog_for_map[i][4]), range(len(catalog_for_map))))\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n                for (Yr, M, lon, lat, nb) in zip(yr_cat_for_map, M_cat_for_map, lon_cat_for_map, lat_cat_for_map, nb_time_picked):\n                    (x, y) = m(lon, lat)\n                    if M < 5.0:\n                        c = 'b'\n                        s = 3\n                    elif M < 6.0:\n                        c = 'g'\n                        s = 5\n                    elif M < 7.0:\n                        c = 'orange'\n                        s = 7\n                    else:\n                        c = 'r'\n                        s = 10\n                    if nb >= 2 * nb_inter / 3:\n                        alpha = 1.0\n                    if nb <= 2 * nb_inter / 3:\n                        alpha = 0.8\n                    if nb <= 1 * nb_inter / 2:\n                        alpha = 0.3\n                    if nb < 1 * nb_inter / 3:\n                        alpha = 0.1\n                    c = plt.cm.jet((M - min(M_cat_for_map)) / (max(M_cat_for_map) - min(M_cat_for_map)))\n                    m.plot(x, y, '.', markersize=s, markeredgewidth=0.0, linewidth=0.2, color=c, alpha=alpha)\n                    if M > max(M_cat_for_map) - 1.0:\n                        (x_text, y_text) = m(lon + 0.005, lat + 0.005)\n                        plt.text(x_text, y_text, str(int(Yr)) + ',' + str(int(nb)), fontsize=4)\n                m.drawcoastlines(linewidth=0.1)\n                plt.gca().set_title('Earthquake catalog - Complete period')\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'earthquake_map_' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n                catalog_for_map = np.genfromtxt(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', dtype=['f8', 'f8', 'f8', 'f8', 'f8'])\n                yr_cat_for_map = list(map(lambda i: round(float(catalog_for_map[i][0])), range(len(catalog_for_map))))\n                M_cat_for_map = list(map(lambda i: float(catalog_for_map[i][1]), range(len(catalog_for_map))))\n                lon_cat_for_map = list(map(lambda i: float(catalog_for_map[i][2]), range(len(catalog_for_map))))\n                lat_cat_for_map = list(map(lambda i: float(catalog_for_map[i][3]), range(len(catalog_for_map))))\n                nb_time_picked = list(map(lambda i: float(catalog_for_map[i][4]), range(len(catalog_for_map))))\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='l')\n                for (Yr, M, lon, lat, nb) in zip(yr_cat_for_map, M_cat_for_map, lon_cat_for_map, lat_cat_for_map, nb_time_picked):\n                    (x, y) = m(lon, lat)\n                    if M < 5.0:\n                        c = 'b'\n                        s = 3\n                    elif M < 6.0:\n                        c = 'g'\n                        s = 5\n                    elif M < 7.0:\n                        c = 'orange'\n                        s = 7\n                    else:\n                        c = 'r'\n                        s = 10\n                    if nb >= float(nb_inter) / 2.0:\n                        m.plot(x, y, '.', markersize=s, markeredgewidth=0.0, linewidth=0.0, color=c, alpha=0.6)\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'earthquake_map_just_EQ_' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n        index_model += 1\n        file_eq_rate_cat = open(str(Run_name) + '/analysis/figures/catalogue/cat_cumulative_eq_rate.txt', 'w')\n        file_eq_rate_cat.write('cumulative annual eq rate in the catalog' + '\\n')\n        for (model_i, rate_i) in zip(Model_list, catalog_cum_rate):\n            file_eq_rate_cat.write(model_i)\n            for r in rate_i:\n                file_eq_rate_cat.write('\\t' + str(r))\n            file_eq_rate_cat.write('\\n')\n        file_eq_rate_cat.close()\n    else:\n        file_eq_rate_cat = str(Run_name) + '/analysis/figures/catalogue/cat_cumulative_eq_rate.txt'\n        with open(file_eq_rate_cat) as f:\n            lines_cat = f.readlines()\n        Model_list = []\n        catalog_cum_rate = []\n        for line in lines_cat[1:]:\n            cat_rates_i = line.split('\\t')\n            catalog_cum_rate.append([float(i) for i in cat_rates_i[1:]])\n        seismological_moment_rate = []\n        for rates in catalog_cum_rate:\n            rates_inc = []\n            for i in range(len(rates) - 1):\n                rates_inc.append(rates[i] - rates[i + 1])\n            rates_inc.append(rates[-1])\n            seismological_moment_rate_i = 0\n            for (mag_i, rate_i) in zip(bining_in_mag, rates_inc):\n                M0 = 10.0 ** (1.5 * mag_i + 9.1)\n                rate_M0 = M0 * rate_i\n                seismological_moment_rate_i += rate_M0\n            seismological_moment_rate.append(seismological_moment_rate_i)\n    return (seismological_moment_rate, catalog_cum_rate)",
            "def plt_catalog(do_catalog, Model_list, File_bg, catalog_file, Run_name, xmin, xmax, ymin, ymax, llcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat, completness_file, nb_inter, bining_in_mag, end_year_of_catalog, sub_area_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if do_catalog == True:\n        if not os.path.exists(str(Run_name) + '/analysis/figures/catalogue'):\n            os.makedirs(str(Run_name) + '/analysis/figures/catalogue')\n        catalog_cum_rate = []\n        index_model = 0\n        for model in Model_list:\n            file_catalog_rate_all = open(str(Run_name) + '/analysis/figures/catalogue/catalog_rates_all_' + model + '.txt', 'w')\n            for mag in bining_in_mag[:-1]:\n                file_catalog_rate_all.write(str(round(mag, 1)) + '\\t')\n            file_catalog_rate_all.write(str(round(bining_in_mag[-1], 1)) + '\\n')\n            (Lon_bg, Lat_bg) = Geom_bg(model, File_bg)\n            ColX = Lon_bg\n            ColY = Lat_bg\n            Poly = []\n            for (x1, y1) in zip(ColX, ColY):\n                Poly.append((x1, y1))\n            bbPath = mplPath.Path(Poly)\n            bbPath_sub_areas = []\n            if os.path.exists(sub_area_file):\n                read_sub_area_file = open(sub_area_file, 'rU')\n                lines_sub_area = read_sub_area_file.readlines()\n                sub_area_names = []\n                sub_area_coord = []\n                sub_area_lon = []\n                sub_area_lat = []\n                for line in lines_sub_area:\n                    model_sub_area = line.split('\\t')[0]\n                    if model == model_sub_area:\n                        sub_area_names.append(line.split('\\t')[1])\n                        sub_area_coord.append(line.split('\\t')[2:])\n                        sub_area_lon_i = []\n                        sub_area_lat_i = []\n                        for sub_area_coord_i in line.split('\\t')[2:]:\n                            if not '\\n' in sub_area_coord_i.split(','):\n                                if not '' in sub_area_coord_i.split(','):\n                                    sub_area_lon_i.append(float(sub_area_coord_i.split(',')[1]))\n                                    sub_area_lat_i.append(float(sub_area_coord_i.split(',')[0]))\n                        sub_area_lon.append(sub_area_lon_i)\n                        sub_area_lat.append(sub_area_lat_i)\n                        if not os.path.exists(str(Run_name) + '/analysis/figures/catalogue/sub_area'):\n                            os.makedirs(str(Run_name) + '/analysis/figures/catalogue/sub_area')\n                        Poly_sub = []\n                        for (x1, y1) in zip(sub_area_lon_i, sub_area_lat_i):\n                            Poly_sub.append((x1, y1))\n                        bbPath_sub_areas.append(mplPath.Path(Poly_sub))\n            cat_data = np.genfromtxt(catalog_file, dtype=['S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100'], skip_header=1)\n            cat_lon = list(map(lambda i: float(cat_data[i][5]), range(len(cat_data))))\n            cat_lat = list(map(lambda i: float(cat_data[i][4]), range(len(cat_data))))\n            cat_depth = list(map(lambda i: float(cat_data[i][6]), range(len(cat_data))))\n            cat_Mw = list(map(lambda i: float(cat_data[i][7]), range(len(cat_data))))\n            cat_sig_Mw = list(map(lambda i: float(cat_data[i][8]), range(len(cat_data))))\n            cat_Yr = list(map(lambda i: float(cat_data[i][0]), range(len(cat_data))))\n            indexes_in = []\n            for index_cat in range(len(cat_lon)):\n                if bbPath.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                    indexes_in.append(index_cat)\n            cat_lon = np.take(cat_lon, indexes_in)\n            cat_lat = np.take(cat_lat, indexes_in)\n            cat_depth = np.take(cat_depth, indexes_in)\n            cat_Mw = np.take(cat_Mw, indexes_in)\n            cat_sig_Mw = np.take(cat_sig_Mw, indexes_in)\n            cat_Yr = np.take(cat_Yr, indexes_in)\n            completness = []\n            weights_completness = []\n            read_comp_file = open(completness_file, 'rU')\n            lines_of_the_file = read_comp_file.readlines()\n            line_number = 0\n            for i in range(int(len(lines_of_the_file) / 2)):\n                if len(lines_of_the_file[line_number].split('\\t')) != 0:\n                    binning_comp_i = lines_of_the_file[line_number].split('\\t')\n                    if '\\r\\n' in binning_comp_i:\n                        binning_comp_i.remove('\\r\\n')\n                    if '\\n' in binning_comp_i:\n                        binning_comp_i.remove('\\n')\n                    binning_comp = []\n                    for magnitudes in binning_comp_i[1:]:\n                        mag = magnitudes.split(',')\n                        binning_comp.append(float(mag[0]))\n                        binning_comp.append(float(mag[1]))\n                    binning_comp.append(bining_in_mag[-1])\n                    comp_value_i = lines_of_the_file[line_number + 1].split('\\t')\n                    if '\\r\\n' in comp_value_i:\n                        comp_value_i.remove('\\r\\n')\n                    if '\\n' in comp_value_i:\n                        comp_value_i.remove('\\n')\n                    comp_value = []\n                    for value in comp_value_i[1:]:\n                        comp_value.append(float(value))\n                        comp_value.append(float(value))\n                    comp_value.append(comp_value[-1])\n                    completeness_interpolate = interp1d(binning_comp, comp_value)\n                    completness_i = []\n                    for mag in bining_in_mag:\n                        try:\n                            completness_i.append(completeness_interpolate(mag))\n                        except ValueError:\n                            print('!!!!!!!!!!!!\\n\\n\\nERROR in completeness file\\n your minimum magnitude might not be low enough\\n\\n\\n!!!!!!!!!!!!')\n                    line_number += 2\n                    completness.append(completness_i)\n                    weights_completness.append(float(comp_value_i[0]))\n            seismological_moment_rate = []\n            number_of_earthquakes_for_rate = []\n            number_of_earthquakes_for_rate_sub_area = []\n            for poly_sub_area_i in bbPath_sub_areas:\n                number_of_earthquakes_for_rate_sub_area.append([])\n            file_catalog_for_map = open(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', 'w')\n            earthquake_for_map = []\n            nb_time_picked = []\n            rate_cat_cum_density = []\n            rate_in_sub_area_cum = []\n            for poly_sub_area_i in bbPath_sub_areas:\n                rate_in_sub_area_cum.append([])\n            for i in range(nb_inter):\n                cat_model_bin = np.zeros(len(bining_in_mag))\n                rate_cat = np.zeros(len(bining_in_mag))\n                seismological_moment_rate_i = 0.0\n                test_if_eq_here = []\n                index_completness = np.random.choice(len(weights_completness), 1, p=weights_completness)[0]\n                completness_used = completness[index_completness]\n                cat_sub_area_bin = []\n                rate_sub_area = []\n                for poly_sub_area_i in bbPath_sub_areas:\n                    cat_sub_area_bin.append(np.zeros(len(bining_in_mag)))\n                    rate_sub_area.append(np.zeros(len(bining_in_mag)))\n                envents_magnitude = []\n                index_cat = 0\n                for Yr in cat_Yr:\n                    if cat_sig_Mw[index_cat] == 0:\n                        event_magnitude = cat_Mw[index_cat]\n                    elif cat_sig_Mw[index_cat] <= 3.0:\n                        event_magnitude = np.random.triangular(cat_Mw[index_cat] - cat_sig_Mw[index_cat] / 2.0, cat_Mw[index_cat], cat_Mw[index_cat] + cat_sig_Mw[index_cat] / 2.0)\n                        event_magnitude = np.random.normal(loc=cat_Mw[index_cat], scale=cat_sig_Mw[index_cat])\n                    envents_magnitude.append(event_magnitude)\n                    index_cat += 1\n                index_mag = 0\n                for (mag_i, completness_i) in zip(bining_in_mag, completness_used):\n                    index_cat = 0\n                    picked_completness = completness_i\n                    index_cat = 0\n                    for Yr in cat_Yr:\n                        if cat_depth[index_cat] < 30.0 or math.isnan(cat_depth[index_cat]):\n                            if Yr >= picked_completness and Yr <= end_year_of_catalog:\n                                event_magnitude = envents_magnitude[index_cat]\n                                if event_magnitude >= mag_i and event_magnitude < mag_i + 0.099:\n                                    if bbPath.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                                        if not str(Yr) + str(cat_lon[index_cat]) + str(cat_lat[index_cat]) + str(cat_sig_Mw[index_cat]) in test_if_eq_here:\n                                            test_if_eq_here.append(str(Yr) + str(cat_lon[index_cat]) + str(cat_lat[index_cat]))\n                                            cat_model_bin[index_mag] += 1\n                                            string_for_map = str(Yr) + '\\t' + str(cat_Mw[index_cat]) + '\\t' + str(cat_lon[index_cat]) + '\\t' + str(cat_lat[index_cat])\n                                            if not string_for_map in earthquake_for_map:\n                                                earthquake_for_map.append(string_for_map)\n                                                nb_time_picked.append(1)\n                                            else:\n                                                index_in_cat_for_map = np.where(np.array(earthquake_for_map) == string_for_map)[0][0]\n                                                nb_time_picked[index_in_cat_for_map] += 1\n                                            index_sub_area = 0\n                                            for poly_sub_area_i in bbPath_sub_areas:\n                                                if poly_sub_area_i.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                                                    cat_sub_area_bin[index_sub_area][index_mag] += 1\n                                                index_sub_area += 1\n                        index_cat += 1\n                    rate_cat[index_mag] = cat_model_bin[index_mag] / (end_year_of_catalog - picked_completness)\n                    M0 = 10.0 ** (1.5 * mag_i + 9.1)\n                    rate_M0 = M0 * rate_cat[index_mag]\n                    seismological_moment_rate_i += rate_M0\n                    index_sub_area = 0\n                    for poly_sub_area_i in bbPath_sub_areas:\n                        rate_sub_area[index_sub_area][index_mag] = cat_sub_area_bin[index_sub_area][index_mag] / (end_year_of_catalog - picked_completness)\n                        index_sub_area += 1\n                    index_mag += 1\n                seismological_moment_rate.append(seismological_moment_rate_i)\n                number_of_earthquakes_for_rate_i = []\n                for i in range(len(cat_model_bin)):\n                    number_of_earthquakes_for_rate_i.append(int(np.sum(np.array(cat_model_bin)[-(len(cat_model_bin) - i):])))\n                number_of_earthquakes_for_rate.append(number_of_earthquakes_for_rate_i)\n                index_sub_area = 0\n                for poly_sub_area_i in bbPath_sub_areas:\n                    number_of_earthquakes_for_rate_i = []\n                    for i in range(len(cat_model_bin)):\n                        number_of_earthquakes_for_rate_i.append(int(np.sum(np.array(cat_sub_area_bin[index_sub_area])[-(len(cat_sub_area_bin[index_sub_area]) - i):])))\n                    number_of_earthquakes_for_rate_sub_area[index_sub_area].append(number_of_earthquakes_for_rate_i)\n                    index_sub_area += 1\n                rate_cat_cum = []\n                for i in range(len(rate_cat)):\n                    rate_cat_cum.append(np.sum(np.array(rate_cat)[-(len(rate_cat) - i):]))\n                rate_cat_cum_density.append(rate_cat_cum)\n                index_sub_area = 0\n                for poly_sub_area_i in bbPath_sub_areas:\n                    rate_sub_area_i_cum = []\n                    for i in range(len(rate_sub_area[index_sub_area])):\n                        rate_sub_area_i_cum.append(np.sum(np.array(rate_sub_area[index_sub_area])[-(len(rate_sub_area[index_sub_area]) - i):]))\n                    rate_in_sub_area_cum[index_sub_area].append(rate_sub_area_i_cum)\n                    index_sub_area += 1\n                plt.scatter(bining_in_mag, rate_cat_cum, c='brown', marker='_', s=50, alpha=0.2)\n                for rate_i in rate_cat_cum[:-1]:\n                    file_catalog_rate_all.write(str(rate_i) + '\\t')\n                file_catalog_rate_all.write(str(rate_cat_cum[-1]) + '\\n')\n            file_catalog_rate_all.close()\n            axes = plt.gca()\n            axes.set_xlim([xmin, xmax])\n            axes.set_ylim([ymin, ymax])\n            mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate, axis=0)\n            nb_sample = 50\n            time_simu = 1000000\n            alphas = []\n            for index_mag in range(len(bining_in_mag)):\n                nb_eq = mean_nb_eq_in_cat[index_mag]\n                if nb_eq <= 10:\n                    time_obs = int(round(end_year_of_catalog - completness[0][index_mag]))\n                    rate = float(nb_eq) / float(time_obs)\n                    cat = []\n                    for i in range(time_simu):\n                        test = np.random.uniform(0.0, 1.0)\n                        if test <= rate:\n                            cat.append(1)\n                        else:\n                            cat.append(0)\n                    rates_simu = []\n                    for i in range(nb_sample):\n                        yrs_start = random.choice(range(time_simu - time_obs))\n                        cat_sampled = cat[yrs_start:yrs_start + time_obs]\n                        rates_simu.append(sum(cat_sampled) / float(time_obs))\n                    unc_rate = np.std(rate_cat_cum_density, axis=0)[index_mag] / np.square(mean_nb_eq_in_cat[index_mag])\n                    unc_rate = np.std(rates_simu)\n                    rate_plus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] + unc_rate\n                    rate_minus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] - unc_rate\n                    if rate_minus < 0.0:\n                        rate_minus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] / 100.0\n                    if np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag] > rate_plus:\n                        rate_plus = np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag]\n                    if np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag] < rate_minus:\n                        rate_minus = np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag]\n                else:\n                    rate_plus = np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag]\n                    rate_minus = np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag]\n                mag = bining_in_mag[index_mag]\n                mag_plus = mag + 0.05\n                mag_minus = mag - 0.05\n                verts = [(mag_minus, rate_minus), (mag_minus, rate_plus), (mag_plus, rate_plus), (mag_plus, rate_minus), (mag_minus, rate_minus)]\n                codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]\n                alpha = float(np.count_nonzero(rate_cat_cum_density, axis=0)[index_mag]) / float(nb_sample) * 0.2\n                alphas.append(alpha)\n                path_poly = Path(verts, codes)\n                patch = patches.PathPatch(path_poly, facecolor='k', lw=0.0, alpha=alpha)\n                axes.add_patch(patch)\n            rgba_colors = np.zeros((len(bining_in_mag), 4))\n            rgba_colors[:, 0] = 0.0\n            rgba_colors[:, 3] = alphas\n            plt.scatter(bining_in_mag, np.array(rate_cat_cum_density).mean(axis=0), c=rgba_colors, s=20, edgecolor='', marker='s')\n            plt.yscale('log')\n            plt.title('earthquake catalog')\n            plt.grid(alpha=0.3)\n            plt.savefig(str(Run_name) + '/analysis/figures/catalogue/catalogue_' + str(model) + '.png', dpi=180, transparent=True)\n            plt.close()\n            catalog_cum_rate.append(np.array(rate_cat_cum_density).mean(axis=0))\n            index_sub_area = 0\n            for poly_sub_area_i in bbPath_sub_areas:\n                axes = plt.gca()\n                axes.set_xlim([xmin, xmax])\n                axes.set_ylim([ymin, ymax])\n                mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate_sub_area[index_sub_area], axis=0)\n                alphas = []\n                for index_mag in range(len(bining_in_mag)):\n                    nb_eq = mean_nb_eq_in_cat[index_mag]\n                    if nb_eq <= 10:\n                        time_obs = int(round(end_year_of_catalog - completness[0][index_mag]))\n                        rate = float(nb_eq) / float(time_obs)\n                        cat = []\n                        for i in range(time_simu):\n                            test = np.random.uniform(0.0, 1.0)\n                            if test <= rate:\n                                cat.append(1)\n                            else:\n                                cat.append(0)\n                        rates_simu = []\n                        for i in range(nb_sample):\n                            yrs_start = random.choice(range(time_simu - time_obs))\n                            cat_sampled = cat[yrs_start:yrs_start + time_obs]\n                            rates_simu.append(sum(cat_sampled) / float(time_obs))\n                        unc_rate = np.std(rates_simu)\n                        rate_plus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] + unc_rate\n                        rate_minus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] - unc_rate\n                        if rate_minus < 0.0:\n                            rate_minus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] / 10.0\n                        if np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag] > rate_plus:\n                            rate_plus = np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag]\n                        if np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag] < rate_minus:\n                            rate_minus = np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag]\n                    else:\n                        rate_plus = np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag]\n                        rate_minus = np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag]\n                    mag = bining_in_mag[index_mag]\n                    mag_plus = mag + 0.05\n                    mag_minus = mag - 0.05\n                    verts = [(mag_minus, rate_minus), (mag_minus, rate_plus), (mag_plus, rate_plus), (mag_plus, rate_minus), (mag_minus, rate_minus)]\n                    codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]\n                    path_poly = Path(verts, codes)\n                    alpha = float(np.count_nonzero(rate_in_sub_area_cum[index_sub_area], axis=0)[index_mag]) / float(nb_sample) * 0.2\n                    alphas.append(alpha)\n                    patch = patches.PathPatch(path_poly, facecolor='k', lw=0.0, alpha=alpha)\n                    axes.add_patch(patch)\n                for i in range(nb_inter):\n                    plt.scatter(bining_in_mag, rate_in_sub_area_cum[index_sub_area][i], c='brown', marker='_', s=50, alpha=0.2)\n                rgba_colors = np.zeros((len(bining_in_mag), 4))\n                rgba_colors[:, 0] = 0.0\n                rgba_colors[:, 3] = alphas\n                plt.scatter(bining_in_mag, np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0), c=rgba_colors, s=20, edgecolor='', marker='s')\n                axes = plt.gca()\n                axes.set_xlim([xmin, xmax])\n                axes.set_ylim([ymin, ymax])\n                plt.grid()\n                plt.yscale('log')\n                plt.title('catalogue sub area ' + sub_area_names[index_sub_area])\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/sub_area/catalogue_sub_area_' + sub_area_names[index_sub_area] + ' Model ' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n                file_cat_sub_area = open(str(Run_name) + '/analysis/figures/catalogue/sub_area/mean_rate_cat_' + sub_area_names[index_sub_area] + ' Model ' + str(model) + '.txt', 'w')\n                for index_mag in range(len(bining_in_mag)):\n                    file_cat_sub_area.write(str(bining_in_mag[index_mag]) + '\\t' + str(np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag]) + '\\n')\n                file_cat_sub_area.close()\n                index_sub_area += 1\n            file_nb_eq_in_cat = open(str(Run_name) + '/analysis/figures/catalogue/nb_eq_in_cat_' + str(model) + '.txt', 'w')\n            file_nb_eq_in_cat.write('Number of earthquake for the rate in catalogue' + '\\n')\n            mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate, axis=0)\n            for i in range(len(bining_in_mag)):\n                file_nb_eq_in_cat.write(str(bining_in_mag[i]) + '\\t' + str(round(mean_nb_eq_in_cat[i], 0)) + '\\n')\n            file_nb_eq_in_cat.close()\n            plt.scatter(bining_in_mag, mean_nb_eq_in_cat)\n            plt.axhline(y=1)\n            plt.axhline(y=2)\n            plt.axhline(y=5)\n            plt.axhline(y=10)\n            plt.title('nb of earthquakes (m>M) in the catalogue')\n            plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'nb_of_EQ_in_catalogue.png', dpi=180, transparent=True)\n            plt.grid()\n            plt.close()\n            for (string, nb) in zip(earthquake_for_map, nb_time_picked):\n                file_catalog_for_map.write(string + '\\t' + str(nb) + '\\n')\n            file_catalog_for_map.close()\n            index_sub_area = 0\n            for poly_sub_area_i in bbPath_sub_areas:\n                plt.scatter(bining_in_mag, np.mean(number_of_earthquakes_for_rate_sub_area[index_sub_area], axis=0))\n                plt.axhline(y=1)\n                plt.axhline(y=2)\n                plt.axhline(y=5)\n                plt.axhline(y=10)\n                plt.title('nb of earthquakes (m>M) in the catalogue ' + sub_area_names[index_sub_area])\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/sub_area/' + 'nb_of_EQ_in_ ' + sub_area_names[index_sub_area] + '.png', dpi=180, transparent=True)\n                plt.grid()\n                plt.close()\n                index_sub_area += 1\n            if mean_nb_eq_in_cat[0] > 3:\n                catalog_for_map = np.genfromtxt(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', dtype=['f8', 'f8', 'f8', 'f8', 'f8'])\n                yr_cat_for_map = list(map(lambda i: round(float(catalog_for_map[i][0])), range(len(catalog_for_map))))\n                M_cat_for_map = list(map(lambda i: float(catalog_for_map[i][1]), range(len(catalog_for_map))))\n                lon_cat_for_map = list(map(lambda i: float(catalog_for_map[i][2]), range(len(catalog_for_map))))\n                lat_cat_for_map = list(map(lambda i: float(catalog_for_map[i][3]), range(len(catalog_for_map))))\n                nb_time_picked = list(map(lambda i: float(catalog_for_map[i][4]), range(len(catalog_for_map))))\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n                for (Yr, M, lon, lat, nb) in zip(yr_cat_for_map, M_cat_for_map, lon_cat_for_map, lat_cat_for_map, nb_time_picked):\n                    (x, y) = m(lon, lat)\n                    if M < 5.0:\n                        c = 'b'\n                        s = 3\n                    elif M < 6.0:\n                        c = 'g'\n                        s = 5\n                    elif M < 7.0:\n                        c = 'orange'\n                        s = 7\n                    else:\n                        c = 'r'\n                        s = 10\n                    if nb >= 2 * nb_inter / 3:\n                        alpha = 1.0\n                    if nb <= 2 * nb_inter / 3:\n                        alpha = 0.8\n                    if nb <= 1 * nb_inter / 2:\n                        alpha = 0.3\n                    if nb < 1 * nb_inter / 3:\n                        alpha = 0.1\n                    c = plt.cm.jet((M - min(M_cat_for_map)) / (max(M_cat_for_map) - min(M_cat_for_map)))\n                    m.plot(x, y, '.', markersize=s, markeredgewidth=0.0, linewidth=0.2, color=c, alpha=alpha)\n                    if M > max(M_cat_for_map) - 1.0:\n                        (x_text, y_text) = m(lon + 0.005, lat + 0.005)\n                        plt.text(x_text, y_text, str(int(Yr)) + ',' + str(int(nb)), fontsize=4)\n                m.drawcoastlines(linewidth=0.1)\n                plt.gca().set_title('Earthquake catalog - Complete period')\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'earthquake_map_' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n                catalog_for_map = np.genfromtxt(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', dtype=['f8', 'f8', 'f8', 'f8', 'f8'])\n                yr_cat_for_map = list(map(lambda i: round(float(catalog_for_map[i][0])), range(len(catalog_for_map))))\n                M_cat_for_map = list(map(lambda i: float(catalog_for_map[i][1]), range(len(catalog_for_map))))\n                lon_cat_for_map = list(map(lambda i: float(catalog_for_map[i][2]), range(len(catalog_for_map))))\n                lat_cat_for_map = list(map(lambda i: float(catalog_for_map[i][3]), range(len(catalog_for_map))))\n                nb_time_picked = list(map(lambda i: float(catalog_for_map[i][4]), range(len(catalog_for_map))))\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='l')\n                for (Yr, M, lon, lat, nb) in zip(yr_cat_for_map, M_cat_for_map, lon_cat_for_map, lat_cat_for_map, nb_time_picked):\n                    (x, y) = m(lon, lat)\n                    if M < 5.0:\n                        c = 'b'\n                        s = 3\n                    elif M < 6.0:\n                        c = 'g'\n                        s = 5\n                    elif M < 7.0:\n                        c = 'orange'\n                        s = 7\n                    else:\n                        c = 'r'\n                        s = 10\n                    if nb >= float(nb_inter) / 2.0:\n                        m.plot(x, y, '.', markersize=s, markeredgewidth=0.0, linewidth=0.0, color=c, alpha=0.6)\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'earthquake_map_just_EQ_' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n        index_model += 1\n        file_eq_rate_cat = open(str(Run_name) + '/analysis/figures/catalogue/cat_cumulative_eq_rate.txt', 'w')\n        file_eq_rate_cat.write('cumulative annual eq rate in the catalog' + '\\n')\n        for (model_i, rate_i) in zip(Model_list, catalog_cum_rate):\n            file_eq_rate_cat.write(model_i)\n            for r in rate_i:\n                file_eq_rate_cat.write('\\t' + str(r))\n            file_eq_rate_cat.write('\\n')\n        file_eq_rate_cat.close()\n    else:\n        file_eq_rate_cat = str(Run_name) + '/analysis/figures/catalogue/cat_cumulative_eq_rate.txt'\n        with open(file_eq_rate_cat) as f:\n            lines_cat = f.readlines()\n        Model_list = []\n        catalog_cum_rate = []\n        for line in lines_cat[1:]:\n            cat_rates_i = line.split('\\t')\n            catalog_cum_rate.append([float(i) for i in cat_rates_i[1:]])\n        seismological_moment_rate = []\n        for rates in catalog_cum_rate:\n            rates_inc = []\n            for i in range(len(rates) - 1):\n                rates_inc.append(rates[i] - rates[i + 1])\n            rates_inc.append(rates[-1])\n            seismological_moment_rate_i = 0\n            for (mag_i, rate_i) in zip(bining_in_mag, rates_inc):\n                M0 = 10.0 ** (1.5 * mag_i + 9.1)\n                rate_M0 = M0 * rate_i\n                seismological_moment_rate_i += rate_M0\n            seismological_moment_rate.append(seismological_moment_rate_i)\n    return (seismological_moment_rate, catalog_cum_rate)",
            "def plt_catalog(do_catalog, Model_list, File_bg, catalog_file, Run_name, xmin, xmax, ymin, ymax, llcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat, completness_file, nb_inter, bining_in_mag, end_year_of_catalog, sub_area_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if do_catalog == True:\n        if not os.path.exists(str(Run_name) + '/analysis/figures/catalogue'):\n            os.makedirs(str(Run_name) + '/analysis/figures/catalogue')\n        catalog_cum_rate = []\n        index_model = 0\n        for model in Model_list:\n            file_catalog_rate_all = open(str(Run_name) + '/analysis/figures/catalogue/catalog_rates_all_' + model + '.txt', 'w')\n            for mag in bining_in_mag[:-1]:\n                file_catalog_rate_all.write(str(round(mag, 1)) + '\\t')\n            file_catalog_rate_all.write(str(round(bining_in_mag[-1], 1)) + '\\n')\n            (Lon_bg, Lat_bg) = Geom_bg(model, File_bg)\n            ColX = Lon_bg\n            ColY = Lat_bg\n            Poly = []\n            for (x1, y1) in zip(ColX, ColY):\n                Poly.append((x1, y1))\n            bbPath = mplPath.Path(Poly)\n            bbPath_sub_areas = []\n            if os.path.exists(sub_area_file):\n                read_sub_area_file = open(sub_area_file, 'rU')\n                lines_sub_area = read_sub_area_file.readlines()\n                sub_area_names = []\n                sub_area_coord = []\n                sub_area_lon = []\n                sub_area_lat = []\n                for line in lines_sub_area:\n                    model_sub_area = line.split('\\t')[0]\n                    if model == model_sub_area:\n                        sub_area_names.append(line.split('\\t')[1])\n                        sub_area_coord.append(line.split('\\t')[2:])\n                        sub_area_lon_i = []\n                        sub_area_lat_i = []\n                        for sub_area_coord_i in line.split('\\t')[2:]:\n                            if not '\\n' in sub_area_coord_i.split(','):\n                                if not '' in sub_area_coord_i.split(','):\n                                    sub_area_lon_i.append(float(sub_area_coord_i.split(',')[1]))\n                                    sub_area_lat_i.append(float(sub_area_coord_i.split(',')[0]))\n                        sub_area_lon.append(sub_area_lon_i)\n                        sub_area_lat.append(sub_area_lat_i)\n                        if not os.path.exists(str(Run_name) + '/analysis/figures/catalogue/sub_area'):\n                            os.makedirs(str(Run_name) + '/analysis/figures/catalogue/sub_area')\n                        Poly_sub = []\n                        for (x1, y1) in zip(sub_area_lon_i, sub_area_lat_i):\n                            Poly_sub.append((x1, y1))\n                        bbPath_sub_areas.append(mplPath.Path(Poly_sub))\n            cat_data = np.genfromtxt(catalog_file, dtype=['S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100', 'S100'], skip_header=1)\n            cat_lon = list(map(lambda i: float(cat_data[i][5]), range(len(cat_data))))\n            cat_lat = list(map(lambda i: float(cat_data[i][4]), range(len(cat_data))))\n            cat_depth = list(map(lambda i: float(cat_data[i][6]), range(len(cat_data))))\n            cat_Mw = list(map(lambda i: float(cat_data[i][7]), range(len(cat_data))))\n            cat_sig_Mw = list(map(lambda i: float(cat_data[i][8]), range(len(cat_data))))\n            cat_Yr = list(map(lambda i: float(cat_data[i][0]), range(len(cat_data))))\n            indexes_in = []\n            for index_cat in range(len(cat_lon)):\n                if bbPath.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                    indexes_in.append(index_cat)\n            cat_lon = np.take(cat_lon, indexes_in)\n            cat_lat = np.take(cat_lat, indexes_in)\n            cat_depth = np.take(cat_depth, indexes_in)\n            cat_Mw = np.take(cat_Mw, indexes_in)\n            cat_sig_Mw = np.take(cat_sig_Mw, indexes_in)\n            cat_Yr = np.take(cat_Yr, indexes_in)\n            completness = []\n            weights_completness = []\n            read_comp_file = open(completness_file, 'rU')\n            lines_of_the_file = read_comp_file.readlines()\n            line_number = 0\n            for i in range(int(len(lines_of_the_file) / 2)):\n                if len(lines_of_the_file[line_number].split('\\t')) != 0:\n                    binning_comp_i = lines_of_the_file[line_number].split('\\t')\n                    if '\\r\\n' in binning_comp_i:\n                        binning_comp_i.remove('\\r\\n')\n                    if '\\n' in binning_comp_i:\n                        binning_comp_i.remove('\\n')\n                    binning_comp = []\n                    for magnitudes in binning_comp_i[1:]:\n                        mag = magnitudes.split(',')\n                        binning_comp.append(float(mag[0]))\n                        binning_comp.append(float(mag[1]))\n                    binning_comp.append(bining_in_mag[-1])\n                    comp_value_i = lines_of_the_file[line_number + 1].split('\\t')\n                    if '\\r\\n' in comp_value_i:\n                        comp_value_i.remove('\\r\\n')\n                    if '\\n' in comp_value_i:\n                        comp_value_i.remove('\\n')\n                    comp_value = []\n                    for value in comp_value_i[1:]:\n                        comp_value.append(float(value))\n                        comp_value.append(float(value))\n                    comp_value.append(comp_value[-1])\n                    completeness_interpolate = interp1d(binning_comp, comp_value)\n                    completness_i = []\n                    for mag in bining_in_mag:\n                        try:\n                            completness_i.append(completeness_interpolate(mag))\n                        except ValueError:\n                            print('!!!!!!!!!!!!\\n\\n\\nERROR in completeness file\\n your minimum magnitude might not be low enough\\n\\n\\n!!!!!!!!!!!!')\n                    line_number += 2\n                    completness.append(completness_i)\n                    weights_completness.append(float(comp_value_i[0]))\n            seismological_moment_rate = []\n            number_of_earthquakes_for_rate = []\n            number_of_earthquakes_for_rate_sub_area = []\n            for poly_sub_area_i in bbPath_sub_areas:\n                number_of_earthquakes_for_rate_sub_area.append([])\n            file_catalog_for_map = open(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', 'w')\n            earthquake_for_map = []\n            nb_time_picked = []\n            rate_cat_cum_density = []\n            rate_in_sub_area_cum = []\n            for poly_sub_area_i in bbPath_sub_areas:\n                rate_in_sub_area_cum.append([])\n            for i in range(nb_inter):\n                cat_model_bin = np.zeros(len(bining_in_mag))\n                rate_cat = np.zeros(len(bining_in_mag))\n                seismological_moment_rate_i = 0.0\n                test_if_eq_here = []\n                index_completness = np.random.choice(len(weights_completness), 1, p=weights_completness)[0]\n                completness_used = completness[index_completness]\n                cat_sub_area_bin = []\n                rate_sub_area = []\n                for poly_sub_area_i in bbPath_sub_areas:\n                    cat_sub_area_bin.append(np.zeros(len(bining_in_mag)))\n                    rate_sub_area.append(np.zeros(len(bining_in_mag)))\n                envents_magnitude = []\n                index_cat = 0\n                for Yr in cat_Yr:\n                    if cat_sig_Mw[index_cat] == 0:\n                        event_magnitude = cat_Mw[index_cat]\n                    elif cat_sig_Mw[index_cat] <= 3.0:\n                        event_magnitude = np.random.triangular(cat_Mw[index_cat] - cat_sig_Mw[index_cat] / 2.0, cat_Mw[index_cat], cat_Mw[index_cat] + cat_sig_Mw[index_cat] / 2.0)\n                        event_magnitude = np.random.normal(loc=cat_Mw[index_cat], scale=cat_sig_Mw[index_cat])\n                    envents_magnitude.append(event_magnitude)\n                    index_cat += 1\n                index_mag = 0\n                for (mag_i, completness_i) in zip(bining_in_mag, completness_used):\n                    index_cat = 0\n                    picked_completness = completness_i\n                    index_cat = 0\n                    for Yr in cat_Yr:\n                        if cat_depth[index_cat] < 30.0 or math.isnan(cat_depth[index_cat]):\n                            if Yr >= picked_completness and Yr <= end_year_of_catalog:\n                                event_magnitude = envents_magnitude[index_cat]\n                                if event_magnitude >= mag_i and event_magnitude < mag_i + 0.099:\n                                    if bbPath.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                                        if not str(Yr) + str(cat_lon[index_cat]) + str(cat_lat[index_cat]) + str(cat_sig_Mw[index_cat]) in test_if_eq_here:\n                                            test_if_eq_here.append(str(Yr) + str(cat_lon[index_cat]) + str(cat_lat[index_cat]))\n                                            cat_model_bin[index_mag] += 1\n                                            string_for_map = str(Yr) + '\\t' + str(cat_Mw[index_cat]) + '\\t' + str(cat_lon[index_cat]) + '\\t' + str(cat_lat[index_cat])\n                                            if not string_for_map in earthquake_for_map:\n                                                earthquake_for_map.append(string_for_map)\n                                                nb_time_picked.append(1)\n                                            else:\n                                                index_in_cat_for_map = np.where(np.array(earthquake_for_map) == string_for_map)[0][0]\n                                                nb_time_picked[index_in_cat_for_map] += 1\n                                            index_sub_area = 0\n                                            for poly_sub_area_i in bbPath_sub_areas:\n                                                if poly_sub_area_i.contains_point((cat_lon[index_cat], cat_lat[index_cat])) == 1:\n                                                    cat_sub_area_bin[index_sub_area][index_mag] += 1\n                                                index_sub_area += 1\n                        index_cat += 1\n                    rate_cat[index_mag] = cat_model_bin[index_mag] / (end_year_of_catalog - picked_completness)\n                    M0 = 10.0 ** (1.5 * mag_i + 9.1)\n                    rate_M0 = M0 * rate_cat[index_mag]\n                    seismological_moment_rate_i += rate_M0\n                    index_sub_area = 0\n                    for poly_sub_area_i in bbPath_sub_areas:\n                        rate_sub_area[index_sub_area][index_mag] = cat_sub_area_bin[index_sub_area][index_mag] / (end_year_of_catalog - picked_completness)\n                        index_sub_area += 1\n                    index_mag += 1\n                seismological_moment_rate.append(seismological_moment_rate_i)\n                number_of_earthquakes_for_rate_i = []\n                for i in range(len(cat_model_bin)):\n                    number_of_earthquakes_for_rate_i.append(int(np.sum(np.array(cat_model_bin)[-(len(cat_model_bin) - i):])))\n                number_of_earthquakes_for_rate.append(number_of_earthquakes_for_rate_i)\n                index_sub_area = 0\n                for poly_sub_area_i in bbPath_sub_areas:\n                    number_of_earthquakes_for_rate_i = []\n                    for i in range(len(cat_model_bin)):\n                        number_of_earthquakes_for_rate_i.append(int(np.sum(np.array(cat_sub_area_bin[index_sub_area])[-(len(cat_sub_area_bin[index_sub_area]) - i):])))\n                    number_of_earthquakes_for_rate_sub_area[index_sub_area].append(number_of_earthquakes_for_rate_i)\n                    index_sub_area += 1\n                rate_cat_cum = []\n                for i in range(len(rate_cat)):\n                    rate_cat_cum.append(np.sum(np.array(rate_cat)[-(len(rate_cat) - i):]))\n                rate_cat_cum_density.append(rate_cat_cum)\n                index_sub_area = 0\n                for poly_sub_area_i in bbPath_sub_areas:\n                    rate_sub_area_i_cum = []\n                    for i in range(len(rate_sub_area[index_sub_area])):\n                        rate_sub_area_i_cum.append(np.sum(np.array(rate_sub_area[index_sub_area])[-(len(rate_sub_area[index_sub_area]) - i):]))\n                    rate_in_sub_area_cum[index_sub_area].append(rate_sub_area_i_cum)\n                    index_sub_area += 1\n                plt.scatter(bining_in_mag, rate_cat_cum, c='brown', marker='_', s=50, alpha=0.2)\n                for rate_i in rate_cat_cum[:-1]:\n                    file_catalog_rate_all.write(str(rate_i) + '\\t')\n                file_catalog_rate_all.write(str(rate_cat_cum[-1]) + '\\n')\n            file_catalog_rate_all.close()\n            axes = plt.gca()\n            axes.set_xlim([xmin, xmax])\n            axes.set_ylim([ymin, ymax])\n            mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate, axis=0)\n            nb_sample = 50\n            time_simu = 1000000\n            alphas = []\n            for index_mag in range(len(bining_in_mag)):\n                nb_eq = mean_nb_eq_in_cat[index_mag]\n                if nb_eq <= 10:\n                    time_obs = int(round(end_year_of_catalog - completness[0][index_mag]))\n                    rate = float(nb_eq) / float(time_obs)\n                    cat = []\n                    for i in range(time_simu):\n                        test = np.random.uniform(0.0, 1.0)\n                        if test <= rate:\n                            cat.append(1)\n                        else:\n                            cat.append(0)\n                    rates_simu = []\n                    for i in range(nb_sample):\n                        yrs_start = random.choice(range(time_simu - time_obs))\n                        cat_sampled = cat[yrs_start:yrs_start + time_obs]\n                        rates_simu.append(sum(cat_sampled) / float(time_obs))\n                    unc_rate = np.std(rate_cat_cum_density, axis=0)[index_mag] / np.square(mean_nb_eq_in_cat[index_mag])\n                    unc_rate = np.std(rates_simu)\n                    rate_plus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] + unc_rate\n                    rate_minus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] - unc_rate\n                    if rate_minus < 0.0:\n                        rate_minus = np.array(rate_cat_cum_density).mean(axis=0)[index_mag] / 100.0\n                    if np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag] > rate_plus:\n                        rate_plus = np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag]\n                    if np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag] < rate_minus:\n                        rate_minus = np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag]\n                else:\n                    rate_plus = np.percentile(rate_cat_cum_density, 84, axis=0)[index_mag]\n                    rate_minus = np.percentile(rate_cat_cum_density, 16, axis=0)[index_mag]\n                mag = bining_in_mag[index_mag]\n                mag_plus = mag + 0.05\n                mag_minus = mag - 0.05\n                verts = [(mag_minus, rate_minus), (mag_minus, rate_plus), (mag_plus, rate_plus), (mag_plus, rate_minus), (mag_minus, rate_minus)]\n                codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]\n                alpha = float(np.count_nonzero(rate_cat_cum_density, axis=0)[index_mag]) / float(nb_sample) * 0.2\n                alphas.append(alpha)\n                path_poly = Path(verts, codes)\n                patch = patches.PathPatch(path_poly, facecolor='k', lw=0.0, alpha=alpha)\n                axes.add_patch(patch)\n            rgba_colors = np.zeros((len(bining_in_mag), 4))\n            rgba_colors[:, 0] = 0.0\n            rgba_colors[:, 3] = alphas\n            plt.scatter(bining_in_mag, np.array(rate_cat_cum_density).mean(axis=0), c=rgba_colors, s=20, edgecolor='', marker='s')\n            plt.yscale('log')\n            plt.title('earthquake catalog')\n            plt.grid(alpha=0.3)\n            plt.savefig(str(Run_name) + '/analysis/figures/catalogue/catalogue_' + str(model) + '.png', dpi=180, transparent=True)\n            plt.close()\n            catalog_cum_rate.append(np.array(rate_cat_cum_density).mean(axis=0))\n            index_sub_area = 0\n            for poly_sub_area_i in bbPath_sub_areas:\n                axes = plt.gca()\n                axes.set_xlim([xmin, xmax])\n                axes.set_ylim([ymin, ymax])\n                mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate_sub_area[index_sub_area], axis=0)\n                alphas = []\n                for index_mag in range(len(bining_in_mag)):\n                    nb_eq = mean_nb_eq_in_cat[index_mag]\n                    if nb_eq <= 10:\n                        time_obs = int(round(end_year_of_catalog - completness[0][index_mag]))\n                        rate = float(nb_eq) / float(time_obs)\n                        cat = []\n                        for i in range(time_simu):\n                            test = np.random.uniform(0.0, 1.0)\n                            if test <= rate:\n                                cat.append(1)\n                            else:\n                                cat.append(0)\n                        rates_simu = []\n                        for i in range(nb_sample):\n                            yrs_start = random.choice(range(time_simu - time_obs))\n                            cat_sampled = cat[yrs_start:yrs_start + time_obs]\n                            rates_simu.append(sum(cat_sampled) / float(time_obs))\n                        unc_rate = np.std(rates_simu)\n                        rate_plus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] + unc_rate\n                        rate_minus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] - unc_rate\n                        if rate_minus < 0.0:\n                            rate_minus = np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag] / 10.0\n                        if np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag] > rate_plus:\n                            rate_plus = np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag]\n                        if np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag] < rate_minus:\n                            rate_minus = np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag]\n                    else:\n                        rate_plus = np.percentile(rate_in_sub_area_cum[index_sub_area], 84, axis=0)[index_mag]\n                        rate_minus = np.percentile(rate_in_sub_area_cum[index_sub_area], 16, axis=0)[index_mag]\n                    mag = bining_in_mag[index_mag]\n                    mag_plus = mag + 0.05\n                    mag_minus = mag - 0.05\n                    verts = [(mag_minus, rate_minus), (mag_minus, rate_plus), (mag_plus, rate_plus), (mag_plus, rate_minus), (mag_minus, rate_minus)]\n                    codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]\n                    path_poly = Path(verts, codes)\n                    alpha = float(np.count_nonzero(rate_in_sub_area_cum[index_sub_area], axis=0)[index_mag]) / float(nb_sample) * 0.2\n                    alphas.append(alpha)\n                    patch = patches.PathPatch(path_poly, facecolor='k', lw=0.0, alpha=alpha)\n                    axes.add_patch(patch)\n                for i in range(nb_inter):\n                    plt.scatter(bining_in_mag, rate_in_sub_area_cum[index_sub_area][i], c='brown', marker='_', s=50, alpha=0.2)\n                rgba_colors = np.zeros((len(bining_in_mag), 4))\n                rgba_colors[:, 0] = 0.0\n                rgba_colors[:, 3] = alphas\n                plt.scatter(bining_in_mag, np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0), c=rgba_colors, s=20, edgecolor='', marker='s')\n                axes = plt.gca()\n                axes.set_xlim([xmin, xmax])\n                axes.set_ylim([ymin, ymax])\n                plt.grid()\n                plt.yscale('log')\n                plt.title('catalogue sub area ' + sub_area_names[index_sub_area])\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/sub_area/catalogue_sub_area_' + sub_area_names[index_sub_area] + ' Model ' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n                file_cat_sub_area = open(str(Run_name) + '/analysis/figures/catalogue/sub_area/mean_rate_cat_' + sub_area_names[index_sub_area] + ' Model ' + str(model) + '.txt', 'w')\n                for index_mag in range(len(bining_in_mag)):\n                    file_cat_sub_area.write(str(bining_in_mag[index_mag]) + '\\t' + str(np.array(rate_in_sub_area_cum[index_sub_area]).mean(axis=0)[index_mag]) + '\\n')\n                file_cat_sub_area.close()\n                index_sub_area += 1\n            file_nb_eq_in_cat = open(str(Run_name) + '/analysis/figures/catalogue/nb_eq_in_cat_' + str(model) + '.txt', 'w')\n            file_nb_eq_in_cat.write('Number of earthquake for the rate in catalogue' + '\\n')\n            mean_nb_eq_in_cat = np.mean(number_of_earthquakes_for_rate, axis=0)\n            for i in range(len(bining_in_mag)):\n                file_nb_eq_in_cat.write(str(bining_in_mag[i]) + '\\t' + str(round(mean_nb_eq_in_cat[i], 0)) + '\\n')\n            file_nb_eq_in_cat.close()\n            plt.scatter(bining_in_mag, mean_nb_eq_in_cat)\n            plt.axhline(y=1)\n            plt.axhline(y=2)\n            plt.axhline(y=5)\n            plt.axhline(y=10)\n            plt.title('nb of earthquakes (m>M) in the catalogue')\n            plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'nb_of_EQ_in_catalogue.png', dpi=180, transparent=True)\n            plt.grid()\n            plt.close()\n            for (string, nb) in zip(earthquake_for_map, nb_time_picked):\n                file_catalog_for_map.write(string + '\\t' + str(nb) + '\\n')\n            file_catalog_for_map.close()\n            index_sub_area = 0\n            for poly_sub_area_i in bbPath_sub_areas:\n                plt.scatter(bining_in_mag, np.mean(number_of_earthquakes_for_rate_sub_area[index_sub_area], axis=0))\n                plt.axhline(y=1)\n                plt.axhline(y=2)\n                plt.axhline(y=5)\n                plt.axhline(y=10)\n                plt.title('nb of earthquakes (m>M) in the catalogue ' + sub_area_names[index_sub_area])\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/sub_area/' + 'nb_of_EQ_in_ ' + sub_area_names[index_sub_area] + '.png', dpi=180, transparent=True)\n                plt.grid()\n                plt.close()\n                index_sub_area += 1\n            if mean_nb_eq_in_cat[0] > 3:\n                catalog_for_map = np.genfromtxt(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', dtype=['f8', 'f8', 'f8', 'f8', 'f8'])\n                yr_cat_for_map = list(map(lambda i: round(float(catalog_for_map[i][0])), range(len(catalog_for_map))))\n                M_cat_for_map = list(map(lambda i: float(catalog_for_map[i][1]), range(len(catalog_for_map))))\n                lon_cat_for_map = list(map(lambda i: float(catalog_for_map[i][2]), range(len(catalog_for_map))))\n                lat_cat_for_map = list(map(lambda i: float(catalog_for_map[i][3]), range(len(catalog_for_map))))\n                nb_time_picked = list(map(lambda i: float(catalog_for_map[i][4]), range(len(catalog_for_map))))\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n                for (Yr, M, lon, lat, nb) in zip(yr_cat_for_map, M_cat_for_map, lon_cat_for_map, lat_cat_for_map, nb_time_picked):\n                    (x, y) = m(lon, lat)\n                    if M < 5.0:\n                        c = 'b'\n                        s = 3\n                    elif M < 6.0:\n                        c = 'g'\n                        s = 5\n                    elif M < 7.0:\n                        c = 'orange'\n                        s = 7\n                    else:\n                        c = 'r'\n                        s = 10\n                    if nb >= 2 * nb_inter / 3:\n                        alpha = 1.0\n                    if nb <= 2 * nb_inter / 3:\n                        alpha = 0.8\n                    if nb <= 1 * nb_inter / 2:\n                        alpha = 0.3\n                    if nb < 1 * nb_inter / 3:\n                        alpha = 0.1\n                    c = plt.cm.jet((M - min(M_cat_for_map)) / (max(M_cat_for_map) - min(M_cat_for_map)))\n                    m.plot(x, y, '.', markersize=s, markeredgewidth=0.0, linewidth=0.2, color=c, alpha=alpha)\n                    if M > max(M_cat_for_map) - 1.0:\n                        (x_text, y_text) = m(lon + 0.005, lat + 0.005)\n                        plt.text(x_text, y_text, str(int(Yr)) + ',' + str(int(nb)), fontsize=4)\n                m.drawcoastlines(linewidth=0.1)\n                plt.gca().set_title('Earthquake catalog - Complete period')\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'earthquake_map_' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n                catalog_for_map = np.genfromtxt(str(Run_name) + '/analysis/figures/catalogue/catalog_for_map_' + str(model) + '.txt', dtype=['f8', 'f8', 'f8', 'f8', 'f8'])\n                yr_cat_for_map = list(map(lambda i: round(float(catalog_for_map[i][0])), range(len(catalog_for_map))))\n                M_cat_for_map = list(map(lambda i: float(catalog_for_map[i][1]), range(len(catalog_for_map))))\n                lon_cat_for_map = list(map(lambda i: float(catalog_for_map[i][2]), range(len(catalog_for_map))))\n                lat_cat_for_map = list(map(lambda i: float(catalog_for_map[i][3]), range(len(catalog_for_map))))\n                nb_time_picked = list(map(lambda i: float(catalog_for_map[i][4]), range(len(catalog_for_map))))\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='l')\n                for (Yr, M, lon, lat, nb) in zip(yr_cat_for_map, M_cat_for_map, lon_cat_for_map, lat_cat_for_map, nb_time_picked):\n                    (x, y) = m(lon, lat)\n                    if M < 5.0:\n                        c = 'b'\n                        s = 3\n                    elif M < 6.0:\n                        c = 'g'\n                        s = 5\n                    elif M < 7.0:\n                        c = 'orange'\n                        s = 7\n                    else:\n                        c = 'r'\n                        s = 10\n                    if nb >= float(nb_inter) / 2.0:\n                        m.plot(x, y, '.', markersize=s, markeredgewidth=0.0, linewidth=0.0, color=c, alpha=0.6)\n                plt.savefig(str(Run_name) + '/analysis/figures/catalogue/' + 'earthquake_map_just_EQ_' + str(model) + '.png', dpi=180, transparent=True)\n                plt.close()\n        index_model += 1\n        file_eq_rate_cat = open(str(Run_name) + '/analysis/figures/catalogue/cat_cumulative_eq_rate.txt', 'w')\n        file_eq_rate_cat.write('cumulative annual eq rate in the catalog' + '\\n')\n        for (model_i, rate_i) in zip(Model_list, catalog_cum_rate):\n            file_eq_rate_cat.write(model_i)\n            for r in rate_i:\n                file_eq_rate_cat.write('\\t' + str(r))\n            file_eq_rate_cat.write('\\n')\n        file_eq_rate_cat.close()\n    else:\n        file_eq_rate_cat = str(Run_name) + '/analysis/figures/catalogue/cat_cumulative_eq_rate.txt'\n        with open(file_eq_rate_cat) as f:\n            lines_cat = f.readlines()\n        Model_list = []\n        catalog_cum_rate = []\n        for line in lines_cat[1:]:\n            cat_rates_i = line.split('\\t')\n            catalog_cum_rate.append([float(i) for i in cat_rates_i[1:]])\n        seismological_moment_rate = []\n        for rates in catalog_cum_rate:\n            rates_inc = []\n            for i in range(len(rates) - 1):\n                rates_inc.append(rates[i] - rates[i + 1])\n            rates_inc.append(rates[-1])\n            seismological_moment_rate_i = 0\n            for (mag_i, rate_i) in zip(bining_in_mag, rates_inc):\n                M0 = 10.0 ** (1.5 * mag_i + 9.1)\n                rate_M0 = M0 * rate_i\n                seismological_moment_rate_i += rate_M0\n            seismological_moment_rate.append(seismological_moment_rate_i)\n    return (seismological_moment_rate, catalog_cum_rate)"
        ]
    }
]