[
    {
        "func_name": "_get_network",
        "original": "def _get_network(name):\n    \"\"\"Gets a single encoder/decoder network model.\"\"\"\n    if name not in _NAME_TO_NETS:\n        raise ValueError('Network name [%s] not recognized.' % name)\n    return _NAME_TO_NETS[name].model",
        "mutated": [
            "def _get_network(name):\n    if False:\n        i = 10\n    'Gets a single encoder/decoder network model.'\n    if name not in _NAME_TO_NETS:\n        raise ValueError('Network name [%s] not recognized.' % name)\n    return _NAME_TO_NETS[name].model",
            "def _get_network(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Gets a single encoder/decoder network model.'\n    if name not in _NAME_TO_NETS:\n        raise ValueError('Network name [%s] not recognized.' % name)\n    return _NAME_TO_NETS[name].model",
            "def _get_network(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Gets a single encoder/decoder network model.'\n    if name not in _NAME_TO_NETS:\n        raise ValueError('Network name [%s] not recognized.' % name)\n    return _NAME_TO_NETS[name].model",
            "def _get_network(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Gets a single encoder/decoder network model.'\n    if name not in _NAME_TO_NETS:\n        raise ValueError('Network name [%s] not recognized.' % name)\n    return _NAME_TO_NETS[name].model",
            "def _get_network(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Gets a single encoder/decoder network model.'\n    if name not in _NAME_TO_NETS:\n        raise ValueError('Network name [%s] not recognized.' % name)\n    return _NAME_TO_NETS[name].model"
        ]
    },
    {
        "func_name": "model",
        "original": "def model(inputs):\n    \"\"\"Model function corresponding to a specific network architecture.\"\"\"\n    outputs = {}\n    encoder_fn = _get_network(params.encoder_name)\n    with tf.variable_scope('encoder', reuse=reuse):\n        enc_outputs = encoder_fn(inputs['images_1'], params, is_training)\n        outputs['ids_1'] = enc_outputs['ids']\n    decoder_fn = _get_network(params.decoder_name)\n    with tf.variable_scope('decoder', reuse=reuse):\n        outputs['voxels_1'] = decoder_fn(outputs['ids_1'], params, is_training)\n    if run_projection:\n        projector_fn = _get_network(params.projector_name)\n        with tf.variable_scope('projector', reuse=reuse):\n            outputs['projs_1'] = projector_fn(outputs['voxels_1'], inputs['matrix_1'], params, is_training)\n        with tf.variable_scope('oracle', reuse=reuse):\n            outputs['masks_1'] = projector_fn(inputs['voxels'], inputs['matrix_1'], params, False)\n        for k in range(1, params.step_size):\n            with tf.variable_scope('projector', reuse=True):\n                outputs['projs_%d' % (k + 1)] = projector_fn(outputs['voxels_1'], inputs['matrix_%d' % (k + 1)], params, is_training)\n            with tf.variable_scope('oracle', reuse=True):\n                outputs['masks_%d' % (k + 1)] = projector_fn(inputs['voxels'], inputs['matrix_%d' % (k + 1)], params, False)\n    return outputs",
        "mutated": [
            "def model(inputs):\n    if False:\n        i = 10\n    'Model function corresponding to a specific network architecture.'\n    outputs = {}\n    encoder_fn = _get_network(params.encoder_name)\n    with tf.variable_scope('encoder', reuse=reuse):\n        enc_outputs = encoder_fn(inputs['images_1'], params, is_training)\n        outputs['ids_1'] = enc_outputs['ids']\n    decoder_fn = _get_network(params.decoder_name)\n    with tf.variable_scope('decoder', reuse=reuse):\n        outputs['voxels_1'] = decoder_fn(outputs['ids_1'], params, is_training)\n    if run_projection:\n        projector_fn = _get_network(params.projector_name)\n        with tf.variable_scope('projector', reuse=reuse):\n            outputs['projs_1'] = projector_fn(outputs['voxels_1'], inputs['matrix_1'], params, is_training)\n        with tf.variable_scope('oracle', reuse=reuse):\n            outputs['masks_1'] = projector_fn(inputs['voxels'], inputs['matrix_1'], params, False)\n        for k in range(1, params.step_size):\n            with tf.variable_scope('projector', reuse=True):\n                outputs['projs_%d' % (k + 1)] = projector_fn(outputs['voxels_1'], inputs['matrix_%d' % (k + 1)], params, is_training)\n            with tf.variable_scope('oracle', reuse=True):\n                outputs['masks_%d' % (k + 1)] = projector_fn(inputs['voxels'], inputs['matrix_%d' % (k + 1)], params, False)\n    return outputs",
            "def model(inputs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Model function corresponding to a specific network architecture.'\n    outputs = {}\n    encoder_fn = _get_network(params.encoder_name)\n    with tf.variable_scope('encoder', reuse=reuse):\n        enc_outputs = encoder_fn(inputs['images_1'], params, is_training)\n        outputs['ids_1'] = enc_outputs['ids']\n    decoder_fn = _get_network(params.decoder_name)\n    with tf.variable_scope('decoder', reuse=reuse):\n        outputs['voxels_1'] = decoder_fn(outputs['ids_1'], params, is_training)\n    if run_projection:\n        projector_fn = _get_network(params.projector_name)\n        with tf.variable_scope('projector', reuse=reuse):\n            outputs['projs_1'] = projector_fn(outputs['voxels_1'], inputs['matrix_1'], params, is_training)\n        with tf.variable_scope('oracle', reuse=reuse):\n            outputs['masks_1'] = projector_fn(inputs['voxels'], inputs['matrix_1'], params, False)\n        for k in range(1, params.step_size):\n            with tf.variable_scope('projector', reuse=True):\n                outputs['projs_%d' % (k + 1)] = projector_fn(outputs['voxels_1'], inputs['matrix_%d' % (k + 1)], params, is_training)\n            with tf.variable_scope('oracle', reuse=True):\n                outputs['masks_%d' % (k + 1)] = projector_fn(inputs['voxels'], inputs['matrix_%d' % (k + 1)], params, False)\n    return outputs",
            "def model(inputs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Model function corresponding to a specific network architecture.'\n    outputs = {}\n    encoder_fn = _get_network(params.encoder_name)\n    with tf.variable_scope('encoder', reuse=reuse):\n        enc_outputs = encoder_fn(inputs['images_1'], params, is_training)\n        outputs['ids_1'] = enc_outputs['ids']\n    decoder_fn = _get_network(params.decoder_name)\n    with tf.variable_scope('decoder', reuse=reuse):\n        outputs['voxels_1'] = decoder_fn(outputs['ids_1'], params, is_training)\n    if run_projection:\n        projector_fn = _get_network(params.projector_name)\n        with tf.variable_scope('projector', reuse=reuse):\n            outputs['projs_1'] = projector_fn(outputs['voxels_1'], inputs['matrix_1'], params, is_training)\n        with tf.variable_scope('oracle', reuse=reuse):\n            outputs['masks_1'] = projector_fn(inputs['voxels'], inputs['matrix_1'], params, False)\n        for k in range(1, params.step_size):\n            with tf.variable_scope('projector', reuse=True):\n                outputs['projs_%d' % (k + 1)] = projector_fn(outputs['voxels_1'], inputs['matrix_%d' % (k + 1)], params, is_training)\n            with tf.variable_scope('oracle', reuse=True):\n                outputs['masks_%d' % (k + 1)] = projector_fn(inputs['voxels'], inputs['matrix_%d' % (k + 1)], params, False)\n    return outputs",
            "def model(inputs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Model function corresponding to a specific network architecture.'\n    outputs = {}\n    encoder_fn = _get_network(params.encoder_name)\n    with tf.variable_scope('encoder', reuse=reuse):\n        enc_outputs = encoder_fn(inputs['images_1'], params, is_training)\n        outputs['ids_1'] = enc_outputs['ids']\n    decoder_fn = _get_network(params.decoder_name)\n    with tf.variable_scope('decoder', reuse=reuse):\n        outputs['voxels_1'] = decoder_fn(outputs['ids_1'], params, is_training)\n    if run_projection:\n        projector_fn = _get_network(params.projector_name)\n        with tf.variable_scope('projector', reuse=reuse):\n            outputs['projs_1'] = projector_fn(outputs['voxels_1'], inputs['matrix_1'], params, is_training)\n        with tf.variable_scope('oracle', reuse=reuse):\n            outputs['masks_1'] = projector_fn(inputs['voxels'], inputs['matrix_1'], params, False)\n        for k in range(1, params.step_size):\n            with tf.variable_scope('projector', reuse=True):\n                outputs['projs_%d' % (k + 1)] = projector_fn(outputs['voxels_1'], inputs['matrix_%d' % (k + 1)], params, is_training)\n            with tf.variable_scope('oracle', reuse=True):\n                outputs['masks_%d' % (k + 1)] = projector_fn(inputs['voxels'], inputs['matrix_%d' % (k + 1)], params, False)\n    return outputs",
            "def model(inputs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Model function corresponding to a specific network architecture.'\n    outputs = {}\n    encoder_fn = _get_network(params.encoder_name)\n    with tf.variable_scope('encoder', reuse=reuse):\n        enc_outputs = encoder_fn(inputs['images_1'], params, is_training)\n        outputs['ids_1'] = enc_outputs['ids']\n    decoder_fn = _get_network(params.decoder_name)\n    with tf.variable_scope('decoder', reuse=reuse):\n        outputs['voxels_1'] = decoder_fn(outputs['ids_1'], params, is_training)\n    if run_projection:\n        projector_fn = _get_network(params.projector_name)\n        with tf.variable_scope('projector', reuse=reuse):\n            outputs['projs_1'] = projector_fn(outputs['voxels_1'], inputs['matrix_1'], params, is_training)\n        with tf.variable_scope('oracle', reuse=reuse):\n            outputs['masks_1'] = projector_fn(inputs['voxels'], inputs['matrix_1'], params, False)\n        for k in range(1, params.step_size):\n            with tf.variable_scope('projector', reuse=True):\n                outputs['projs_%d' % (k + 1)] = projector_fn(outputs['voxels_1'], inputs['matrix_%d' % (k + 1)], params, is_training)\n            with tf.variable_scope('oracle', reuse=True):\n                outputs['masks_%d' % (k + 1)] = projector_fn(inputs['voxels'], inputs['matrix_%d' % (k + 1)], params, False)\n    return outputs"
        ]
    },
    {
        "func_name": "get",
        "original": "def get(params, is_training=False, reuse=False, run_projection=True):\n    \"\"\"Factory function to get the training/pretraining im->vox model (NIPS16).\n\n  Args:\n    params: Different parameters used througout ptn, typically FLAGS (dict).\n    is_training: Set to True if while training (boolean).\n    reuse: Set as True if sharing variables with a model that has already\n      been built (boolean).\n    run_projection: Set as False if not interested in mask and projection\n      images. Useful in evaluation routine (boolean).\n  Returns:\n    Model function for network (inputs to outputs).\n  \"\"\"\n\n    def model(inputs):\n        \"\"\"Model function corresponding to a specific network architecture.\"\"\"\n        outputs = {}\n        encoder_fn = _get_network(params.encoder_name)\n        with tf.variable_scope('encoder', reuse=reuse):\n            enc_outputs = encoder_fn(inputs['images_1'], params, is_training)\n            outputs['ids_1'] = enc_outputs['ids']\n        decoder_fn = _get_network(params.decoder_name)\n        with tf.variable_scope('decoder', reuse=reuse):\n            outputs['voxels_1'] = decoder_fn(outputs['ids_1'], params, is_training)\n        if run_projection:\n            projector_fn = _get_network(params.projector_name)\n            with tf.variable_scope('projector', reuse=reuse):\n                outputs['projs_1'] = projector_fn(outputs['voxels_1'], inputs['matrix_1'], params, is_training)\n            with tf.variable_scope('oracle', reuse=reuse):\n                outputs['masks_1'] = projector_fn(inputs['voxels'], inputs['matrix_1'], params, False)\n            for k in range(1, params.step_size):\n                with tf.variable_scope('projector', reuse=True):\n                    outputs['projs_%d' % (k + 1)] = projector_fn(outputs['voxels_1'], inputs['matrix_%d' % (k + 1)], params, is_training)\n                with tf.variable_scope('oracle', reuse=True):\n                    outputs['masks_%d' % (k + 1)] = projector_fn(inputs['voxels'], inputs['matrix_%d' % (k + 1)], params, False)\n        return outputs\n    return model",
        "mutated": [
            "def get(params, is_training=False, reuse=False, run_projection=True):\n    if False:\n        i = 10\n    'Factory function to get the training/pretraining im->vox model (NIPS16).\\n\\n  Args:\\n    params: Different parameters used througout ptn, typically FLAGS (dict).\\n    is_training: Set to True if while training (boolean).\\n    reuse: Set as True if sharing variables with a model that has already\\n      been built (boolean).\\n    run_projection: Set as False if not interested in mask and projection\\n      images. Useful in evaluation routine (boolean).\\n  Returns:\\n    Model function for network (inputs to outputs).\\n  '\n\n    def model(inputs):\n        \"\"\"Model function corresponding to a specific network architecture.\"\"\"\n        outputs = {}\n        encoder_fn = _get_network(params.encoder_name)\n        with tf.variable_scope('encoder', reuse=reuse):\n            enc_outputs = encoder_fn(inputs['images_1'], params, is_training)\n            outputs['ids_1'] = enc_outputs['ids']\n        decoder_fn = _get_network(params.decoder_name)\n        with tf.variable_scope('decoder', reuse=reuse):\n            outputs['voxels_1'] = decoder_fn(outputs['ids_1'], params, is_training)\n        if run_projection:\n            projector_fn = _get_network(params.projector_name)\n            with tf.variable_scope('projector', reuse=reuse):\n                outputs['projs_1'] = projector_fn(outputs['voxels_1'], inputs['matrix_1'], params, is_training)\n            with tf.variable_scope('oracle', reuse=reuse):\n                outputs['masks_1'] = projector_fn(inputs['voxels'], inputs['matrix_1'], params, False)\n            for k in range(1, params.step_size):\n                with tf.variable_scope('projector', reuse=True):\n                    outputs['projs_%d' % (k + 1)] = projector_fn(outputs['voxels_1'], inputs['matrix_%d' % (k + 1)], params, is_training)\n                with tf.variable_scope('oracle', reuse=True):\n                    outputs['masks_%d' % (k + 1)] = projector_fn(inputs['voxels'], inputs['matrix_%d' % (k + 1)], params, False)\n        return outputs\n    return model",
            "def get(params, is_training=False, reuse=False, run_projection=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Factory function to get the training/pretraining im->vox model (NIPS16).\\n\\n  Args:\\n    params: Different parameters used througout ptn, typically FLAGS (dict).\\n    is_training: Set to True if while training (boolean).\\n    reuse: Set as True if sharing variables with a model that has already\\n      been built (boolean).\\n    run_projection: Set as False if not interested in mask and projection\\n      images. Useful in evaluation routine (boolean).\\n  Returns:\\n    Model function for network (inputs to outputs).\\n  '\n\n    def model(inputs):\n        \"\"\"Model function corresponding to a specific network architecture.\"\"\"\n        outputs = {}\n        encoder_fn = _get_network(params.encoder_name)\n        with tf.variable_scope('encoder', reuse=reuse):\n            enc_outputs = encoder_fn(inputs['images_1'], params, is_training)\n            outputs['ids_1'] = enc_outputs['ids']\n        decoder_fn = _get_network(params.decoder_name)\n        with tf.variable_scope('decoder', reuse=reuse):\n            outputs['voxels_1'] = decoder_fn(outputs['ids_1'], params, is_training)\n        if run_projection:\n            projector_fn = _get_network(params.projector_name)\n            with tf.variable_scope('projector', reuse=reuse):\n                outputs['projs_1'] = projector_fn(outputs['voxels_1'], inputs['matrix_1'], params, is_training)\n            with tf.variable_scope('oracle', reuse=reuse):\n                outputs['masks_1'] = projector_fn(inputs['voxels'], inputs['matrix_1'], params, False)\n            for k in range(1, params.step_size):\n                with tf.variable_scope('projector', reuse=True):\n                    outputs['projs_%d' % (k + 1)] = projector_fn(outputs['voxels_1'], inputs['matrix_%d' % (k + 1)], params, is_training)\n                with tf.variable_scope('oracle', reuse=True):\n                    outputs['masks_%d' % (k + 1)] = projector_fn(inputs['voxels'], inputs['matrix_%d' % (k + 1)], params, False)\n        return outputs\n    return model",
            "def get(params, is_training=False, reuse=False, run_projection=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Factory function to get the training/pretraining im->vox model (NIPS16).\\n\\n  Args:\\n    params: Different parameters used througout ptn, typically FLAGS (dict).\\n    is_training: Set to True if while training (boolean).\\n    reuse: Set as True if sharing variables with a model that has already\\n      been built (boolean).\\n    run_projection: Set as False if not interested in mask and projection\\n      images. Useful in evaluation routine (boolean).\\n  Returns:\\n    Model function for network (inputs to outputs).\\n  '\n\n    def model(inputs):\n        \"\"\"Model function corresponding to a specific network architecture.\"\"\"\n        outputs = {}\n        encoder_fn = _get_network(params.encoder_name)\n        with tf.variable_scope('encoder', reuse=reuse):\n            enc_outputs = encoder_fn(inputs['images_1'], params, is_training)\n            outputs['ids_1'] = enc_outputs['ids']\n        decoder_fn = _get_network(params.decoder_name)\n        with tf.variable_scope('decoder', reuse=reuse):\n            outputs['voxels_1'] = decoder_fn(outputs['ids_1'], params, is_training)\n        if run_projection:\n            projector_fn = _get_network(params.projector_name)\n            with tf.variable_scope('projector', reuse=reuse):\n                outputs['projs_1'] = projector_fn(outputs['voxels_1'], inputs['matrix_1'], params, is_training)\n            with tf.variable_scope('oracle', reuse=reuse):\n                outputs['masks_1'] = projector_fn(inputs['voxels'], inputs['matrix_1'], params, False)\n            for k in range(1, params.step_size):\n                with tf.variable_scope('projector', reuse=True):\n                    outputs['projs_%d' % (k + 1)] = projector_fn(outputs['voxels_1'], inputs['matrix_%d' % (k + 1)], params, is_training)\n                with tf.variable_scope('oracle', reuse=True):\n                    outputs['masks_%d' % (k + 1)] = projector_fn(inputs['voxels'], inputs['matrix_%d' % (k + 1)], params, False)\n        return outputs\n    return model",
            "def get(params, is_training=False, reuse=False, run_projection=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Factory function to get the training/pretraining im->vox model (NIPS16).\\n\\n  Args:\\n    params: Different parameters used througout ptn, typically FLAGS (dict).\\n    is_training: Set to True if while training (boolean).\\n    reuse: Set as True if sharing variables with a model that has already\\n      been built (boolean).\\n    run_projection: Set as False if not interested in mask and projection\\n      images. Useful in evaluation routine (boolean).\\n  Returns:\\n    Model function for network (inputs to outputs).\\n  '\n\n    def model(inputs):\n        \"\"\"Model function corresponding to a specific network architecture.\"\"\"\n        outputs = {}\n        encoder_fn = _get_network(params.encoder_name)\n        with tf.variable_scope('encoder', reuse=reuse):\n            enc_outputs = encoder_fn(inputs['images_1'], params, is_training)\n            outputs['ids_1'] = enc_outputs['ids']\n        decoder_fn = _get_network(params.decoder_name)\n        with tf.variable_scope('decoder', reuse=reuse):\n            outputs['voxels_1'] = decoder_fn(outputs['ids_1'], params, is_training)\n        if run_projection:\n            projector_fn = _get_network(params.projector_name)\n            with tf.variable_scope('projector', reuse=reuse):\n                outputs['projs_1'] = projector_fn(outputs['voxels_1'], inputs['matrix_1'], params, is_training)\n            with tf.variable_scope('oracle', reuse=reuse):\n                outputs['masks_1'] = projector_fn(inputs['voxels'], inputs['matrix_1'], params, False)\n            for k in range(1, params.step_size):\n                with tf.variable_scope('projector', reuse=True):\n                    outputs['projs_%d' % (k + 1)] = projector_fn(outputs['voxels_1'], inputs['matrix_%d' % (k + 1)], params, is_training)\n                with tf.variable_scope('oracle', reuse=True):\n                    outputs['masks_%d' % (k + 1)] = projector_fn(inputs['voxels'], inputs['matrix_%d' % (k + 1)], params, False)\n        return outputs\n    return model",
            "def get(params, is_training=False, reuse=False, run_projection=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Factory function to get the training/pretraining im->vox model (NIPS16).\\n\\n  Args:\\n    params: Different parameters used througout ptn, typically FLAGS (dict).\\n    is_training: Set to True if while training (boolean).\\n    reuse: Set as True if sharing variables with a model that has already\\n      been built (boolean).\\n    run_projection: Set as False if not interested in mask and projection\\n      images. Useful in evaluation routine (boolean).\\n  Returns:\\n    Model function for network (inputs to outputs).\\n  '\n\n    def model(inputs):\n        \"\"\"Model function corresponding to a specific network architecture.\"\"\"\n        outputs = {}\n        encoder_fn = _get_network(params.encoder_name)\n        with tf.variable_scope('encoder', reuse=reuse):\n            enc_outputs = encoder_fn(inputs['images_1'], params, is_training)\n            outputs['ids_1'] = enc_outputs['ids']\n        decoder_fn = _get_network(params.decoder_name)\n        with tf.variable_scope('decoder', reuse=reuse):\n            outputs['voxels_1'] = decoder_fn(outputs['ids_1'], params, is_training)\n        if run_projection:\n            projector_fn = _get_network(params.projector_name)\n            with tf.variable_scope('projector', reuse=reuse):\n                outputs['projs_1'] = projector_fn(outputs['voxels_1'], inputs['matrix_1'], params, is_training)\n            with tf.variable_scope('oracle', reuse=reuse):\n                outputs['masks_1'] = projector_fn(inputs['voxels'], inputs['matrix_1'], params, False)\n            for k in range(1, params.step_size):\n                with tf.variable_scope('projector', reuse=True):\n                    outputs['projs_%d' % (k + 1)] = projector_fn(outputs['voxels_1'], inputs['matrix_%d' % (k + 1)], params, is_training)\n                with tf.variable_scope('oracle', reuse=True):\n                    outputs['masks_%d' % (k + 1)] = projector_fn(inputs['voxels'], inputs['matrix_%d' % (k + 1)], params, False)\n        return outputs\n    return model"
        ]
    }
]