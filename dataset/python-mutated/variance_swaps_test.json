[
    {
        "func_name": "test_replicating_weights",
        "original": "@parameterized.named_parameters({'testcase_name': 'Puts', 'strikes': np.array([100.0, 90.0, 80.0, 70.0])}, {'testcase_name': 'Calls', 'strikes': np.array([100.0, 110.0, 120.0, 130.0])})\ndef test_replicating_weights(self, strikes):\n    \"\"\"Tests ability to match 'hand' calculated variance replicating weights.\"\"\"\n    reference_strikes = 100.0\n    delta_strike = 10.0\n    expiries = 1.0\n    payoff_values = 2 * ((strikes - reference_strikes) / reference_strikes - np.log(strikes / reference_strikes))\n    slope_values = np.diff(payoff_values / delta_strike)\n    expected_weights = []\n    for v in slope_values:\n        expected_weights.append(v - np.sum(expected_weights))\n    weights = self.evaluate(variance_swaps.replicating_weights(strikes, reference_strikes, expiries, dtype=tf.float64))\n    self.assertAllClose(weights, expected_weights, 1e-06)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'Puts', 'strikes': np.array([100.0, 90.0, 80.0, 70.0])}, {'testcase_name': 'Calls', 'strikes': np.array([100.0, 110.0, 120.0, 130.0])})\ndef test_replicating_weights(self, strikes):\n    if False:\n        i = 10\n    \"Tests ability to match 'hand' calculated variance replicating weights.\"\n    reference_strikes = 100.0\n    delta_strike = 10.0\n    expiries = 1.0\n    payoff_values = 2 * ((strikes - reference_strikes) / reference_strikes - np.log(strikes / reference_strikes))\n    slope_values = np.diff(payoff_values / delta_strike)\n    expected_weights = []\n    for v in slope_values:\n        expected_weights.append(v - np.sum(expected_weights))\n    weights = self.evaluate(variance_swaps.replicating_weights(strikes, reference_strikes, expiries, dtype=tf.float64))\n    self.assertAllClose(weights, expected_weights, 1e-06)",
            "@parameterized.named_parameters({'testcase_name': 'Puts', 'strikes': np.array([100.0, 90.0, 80.0, 70.0])}, {'testcase_name': 'Calls', 'strikes': np.array([100.0, 110.0, 120.0, 130.0])})\ndef test_replicating_weights(self, strikes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Tests ability to match 'hand' calculated variance replicating weights.\"\n    reference_strikes = 100.0\n    delta_strike = 10.0\n    expiries = 1.0\n    payoff_values = 2 * ((strikes - reference_strikes) / reference_strikes - np.log(strikes / reference_strikes))\n    slope_values = np.diff(payoff_values / delta_strike)\n    expected_weights = []\n    for v in slope_values:\n        expected_weights.append(v - np.sum(expected_weights))\n    weights = self.evaluate(variance_swaps.replicating_weights(strikes, reference_strikes, expiries, dtype=tf.float64))\n    self.assertAllClose(weights, expected_weights, 1e-06)",
            "@parameterized.named_parameters({'testcase_name': 'Puts', 'strikes': np.array([100.0, 90.0, 80.0, 70.0])}, {'testcase_name': 'Calls', 'strikes': np.array([100.0, 110.0, 120.0, 130.0])})\ndef test_replicating_weights(self, strikes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Tests ability to match 'hand' calculated variance replicating weights.\"\n    reference_strikes = 100.0\n    delta_strike = 10.0\n    expiries = 1.0\n    payoff_values = 2 * ((strikes - reference_strikes) / reference_strikes - np.log(strikes / reference_strikes))\n    slope_values = np.diff(payoff_values / delta_strike)\n    expected_weights = []\n    for v in slope_values:\n        expected_weights.append(v - np.sum(expected_weights))\n    weights = self.evaluate(variance_swaps.replicating_weights(strikes, reference_strikes, expiries, dtype=tf.float64))\n    self.assertAllClose(weights, expected_weights, 1e-06)",
            "@parameterized.named_parameters({'testcase_name': 'Puts', 'strikes': np.array([100.0, 90.0, 80.0, 70.0])}, {'testcase_name': 'Calls', 'strikes': np.array([100.0, 110.0, 120.0, 130.0])})\ndef test_replicating_weights(self, strikes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Tests ability to match 'hand' calculated variance replicating weights.\"\n    reference_strikes = 100.0\n    delta_strike = 10.0\n    expiries = 1.0\n    payoff_values = 2 * ((strikes - reference_strikes) / reference_strikes - np.log(strikes / reference_strikes))\n    slope_values = np.diff(payoff_values / delta_strike)\n    expected_weights = []\n    for v in slope_values:\n        expected_weights.append(v - np.sum(expected_weights))\n    weights = self.evaluate(variance_swaps.replicating_weights(strikes, reference_strikes, expiries, dtype=tf.float64))\n    self.assertAllClose(weights, expected_weights, 1e-06)",
            "@parameterized.named_parameters({'testcase_name': 'Puts', 'strikes': np.array([100.0, 90.0, 80.0, 70.0])}, {'testcase_name': 'Calls', 'strikes': np.array([100.0, 110.0, 120.0, 130.0])})\ndef test_replicating_weights(self, strikes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Tests ability to match 'hand' calculated variance replicating weights.\"\n    reference_strikes = 100.0\n    delta_strike = 10.0\n    expiries = 1.0\n    payoff_values = 2 * ((strikes - reference_strikes) / reference_strikes - np.log(strikes / reference_strikes))\n    slope_values = np.diff(payoff_values / delta_strike)\n    expected_weights = []\n    for v in slope_values:\n        expected_weights.append(v - np.sum(expected_weights))\n    weights = self.evaluate(variance_swaps.replicating_weights(strikes, reference_strikes, expiries, dtype=tf.float64))\n    self.assertAllClose(weights, expected_weights, 1e-06)"
        ]
    },
    {
        "func_name": "test_replicating_weights_supports_batching",
        "original": "def test_replicating_weights_supports_batching(self):\n    put_strikes = tf.constant([[100, 95, 90, 85]], dtype=np.float64)\n    batch_put_strikes = batch_put_strikes = tf.concat([put_strikes, put_strikes, 2 * (put_strikes - 100) + 100], axis=0)\n    batch_reference = tf.math.reduce_max(batch_put_strikes, axis=1)\n    batch_expiries = tf.constant([0.25, 0.5, 0.25], dtype=tf.float64)\n    expected_shape = np.array(batch_put_strikes.shape)\n    expected_shape[-1] = expected_shape[-1] - 1\n    batch_weights = self.evaluate(variance_swaps.replicating_weights(batch_put_strikes, batch_reference, batch_expiries))\n    self.assertAllEqual(batch_weights.shape, expected_shape)\n    for i in range(3):\n        row_weights = self.evaluate(variance_swaps.replicating_weights(batch_put_strikes[i, :], batch_reference[i], batch_expiries[i]))\n        self.assertAllEqual(row_weights, batch_weights[i, :])",
        "mutated": [
            "def test_replicating_weights_supports_batching(self):\n    if False:\n        i = 10\n    put_strikes = tf.constant([[100, 95, 90, 85]], dtype=np.float64)\n    batch_put_strikes = batch_put_strikes = tf.concat([put_strikes, put_strikes, 2 * (put_strikes - 100) + 100], axis=0)\n    batch_reference = tf.math.reduce_max(batch_put_strikes, axis=1)\n    batch_expiries = tf.constant([0.25, 0.5, 0.25], dtype=tf.float64)\n    expected_shape = np.array(batch_put_strikes.shape)\n    expected_shape[-1] = expected_shape[-1] - 1\n    batch_weights = self.evaluate(variance_swaps.replicating_weights(batch_put_strikes, batch_reference, batch_expiries))\n    self.assertAllEqual(batch_weights.shape, expected_shape)\n    for i in range(3):\n        row_weights = self.evaluate(variance_swaps.replicating_weights(batch_put_strikes[i, :], batch_reference[i], batch_expiries[i]))\n        self.assertAllEqual(row_weights, batch_weights[i, :])",
            "def test_replicating_weights_supports_batching(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    put_strikes = tf.constant([[100, 95, 90, 85]], dtype=np.float64)\n    batch_put_strikes = batch_put_strikes = tf.concat([put_strikes, put_strikes, 2 * (put_strikes - 100) + 100], axis=0)\n    batch_reference = tf.math.reduce_max(batch_put_strikes, axis=1)\n    batch_expiries = tf.constant([0.25, 0.5, 0.25], dtype=tf.float64)\n    expected_shape = np.array(batch_put_strikes.shape)\n    expected_shape[-1] = expected_shape[-1] - 1\n    batch_weights = self.evaluate(variance_swaps.replicating_weights(batch_put_strikes, batch_reference, batch_expiries))\n    self.assertAllEqual(batch_weights.shape, expected_shape)\n    for i in range(3):\n        row_weights = self.evaluate(variance_swaps.replicating_weights(batch_put_strikes[i, :], batch_reference[i], batch_expiries[i]))\n        self.assertAllEqual(row_weights, batch_weights[i, :])",
            "def test_replicating_weights_supports_batching(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    put_strikes = tf.constant([[100, 95, 90, 85]], dtype=np.float64)\n    batch_put_strikes = batch_put_strikes = tf.concat([put_strikes, put_strikes, 2 * (put_strikes - 100) + 100], axis=0)\n    batch_reference = tf.math.reduce_max(batch_put_strikes, axis=1)\n    batch_expiries = tf.constant([0.25, 0.5, 0.25], dtype=tf.float64)\n    expected_shape = np.array(batch_put_strikes.shape)\n    expected_shape[-1] = expected_shape[-1] - 1\n    batch_weights = self.evaluate(variance_swaps.replicating_weights(batch_put_strikes, batch_reference, batch_expiries))\n    self.assertAllEqual(batch_weights.shape, expected_shape)\n    for i in range(3):\n        row_weights = self.evaluate(variance_swaps.replicating_weights(batch_put_strikes[i, :], batch_reference[i], batch_expiries[i]))\n        self.assertAllEqual(row_weights, batch_weights[i, :])",
            "def test_replicating_weights_supports_batching(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    put_strikes = tf.constant([[100, 95, 90, 85]], dtype=np.float64)\n    batch_put_strikes = batch_put_strikes = tf.concat([put_strikes, put_strikes, 2 * (put_strikes - 100) + 100], axis=0)\n    batch_reference = tf.math.reduce_max(batch_put_strikes, axis=1)\n    batch_expiries = tf.constant([0.25, 0.5, 0.25], dtype=tf.float64)\n    expected_shape = np.array(batch_put_strikes.shape)\n    expected_shape[-1] = expected_shape[-1] - 1\n    batch_weights = self.evaluate(variance_swaps.replicating_weights(batch_put_strikes, batch_reference, batch_expiries))\n    self.assertAllEqual(batch_weights.shape, expected_shape)\n    for i in range(3):\n        row_weights = self.evaluate(variance_swaps.replicating_weights(batch_put_strikes[i, :], batch_reference[i], batch_expiries[i]))\n        self.assertAllEqual(row_weights, batch_weights[i, :])",
            "def test_replicating_weights_supports_batching(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    put_strikes = tf.constant([[100, 95, 90, 85]], dtype=np.float64)\n    batch_put_strikes = batch_put_strikes = tf.concat([put_strikes, put_strikes, 2 * (put_strikes - 100) + 100], axis=0)\n    batch_reference = tf.math.reduce_max(batch_put_strikes, axis=1)\n    batch_expiries = tf.constant([0.25, 0.5, 0.25], dtype=tf.float64)\n    expected_shape = np.array(batch_put_strikes.shape)\n    expected_shape[-1] = expected_shape[-1] - 1\n    batch_weights = self.evaluate(variance_swaps.replicating_weights(batch_put_strikes, batch_reference, batch_expiries))\n    self.assertAllEqual(batch_weights.shape, expected_shape)\n    for i in range(3):\n        row_weights = self.evaluate(variance_swaps.replicating_weights(batch_put_strikes[i, :], batch_reference[i], batch_expiries[i]))\n        self.assertAllEqual(row_weights, batch_weights[i, :])"
        ]
    },
    {
        "func_name": "test_replicating_weights_raises_validation_error",
        "original": "def test_replicating_weights_raises_validation_error(self):\n    strikes = np.array([1, 2, 3, 2, 1])\n    reference_strike = 3\n    expiry = 1\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        _ = self.evaluate(variance_swaps.replicating_weights(strikes, reference_strike, expiry, validate_args=True, dtype=tf.float64))",
        "mutated": [
            "def test_replicating_weights_raises_validation_error(self):\n    if False:\n        i = 10\n    strikes = np.array([1, 2, 3, 2, 1])\n    reference_strike = 3\n    expiry = 1\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        _ = self.evaluate(variance_swaps.replicating_weights(strikes, reference_strike, expiry, validate_args=True, dtype=tf.float64))",
            "def test_replicating_weights_raises_validation_error(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    strikes = np.array([1, 2, 3, 2, 1])\n    reference_strike = 3\n    expiry = 1\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        _ = self.evaluate(variance_swaps.replicating_weights(strikes, reference_strike, expiry, validate_args=True, dtype=tf.float64))",
            "def test_replicating_weights_raises_validation_error(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    strikes = np.array([1, 2, 3, 2, 1])\n    reference_strike = 3\n    expiry = 1\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        _ = self.evaluate(variance_swaps.replicating_weights(strikes, reference_strike, expiry, validate_args=True, dtype=tf.float64))",
            "def test_replicating_weights_raises_validation_error(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    strikes = np.array([1, 2, 3, 2, 1])\n    reference_strike = 3\n    expiry = 1\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        _ = self.evaluate(variance_swaps.replicating_weights(strikes, reference_strike, expiry, validate_args=True, dtype=tf.float64))",
            "def test_replicating_weights_raises_validation_error(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    strikes = np.array([1, 2, 3, 2, 1])\n    reference_strike = 3\n    expiry = 1\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        _ = self.evaluate(variance_swaps.replicating_weights(strikes, reference_strike, expiry, validate_args=True, dtype=tf.float64))"
        ]
    },
    {
        "func_name": "test_variance_swap_demeterfi_example",
        "original": "@parameterized.named_parameters({'testcase_name': 'Demeterfi_et_al', 'call_strikes': np.array([100.0, 105.0, 110.0, 115.0, 120.0, 125.0, 130.0, 135.0, 140.0]), 'call_weights': np.array([19.63, 36.83, 33.55, 30.69, 28.19, 25.98, 24.02, 22.27]), 'call_volatilities': np.array([0.2, 0.19, 0.18, 0.17, 0.16, 0.15, 0.14, 0.13, np.nan]), 'put_strikes': np.array([100.0, 95.0, 90.0, 85.0, 80.0, 75.0, 70.0, 65.0, 60.0, 55.0, 50.0, 45.0]), 'put_weights': np.array([20.98, 45.0, 50.15, 56.23, 63.49, 72.26, 82.98, 96.27, 113.05, 134.63, 163.04]), 'put_volatilities': np.array([0.2, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3, np.nan]), 'reference_strikes': 100.0, 'expiries': 0.25, 'discount_rates': 0.05, 'tolerance': 0.01, 'k_var': 0.20467 ** 2})\ndef test_variance_swap_demeterfi_example(self, call_strikes, call_weights, call_volatilities, put_strikes, put_weights, put_volatilities, reference_strikes, expiries, discount_rates, tolerance, k_var):\n    \"\"\"Tests ability to match 'hand' calculated variance replicating weights.\"\"\"\n    discount_factor = np.exp(discount_rates * expiries)\n    calculated_call_weights = self.evaluate(variance_swaps.replicating_weights(call_strikes, reference_strikes, expiries, dtype=tf.float64))\n    matched_call_weights = discount_factor * 100.0 ** 2 * calculated_call_weights\n    self.assertAllClose(matched_call_weights, call_weights, tolerance)\n    calculated_put_weights = self.evaluate(variance_swaps.replicating_weights(put_strikes, reference_strikes, expiries, dtype=tf.float64))\n    matched_put_weights = discount_factor * 100.0 ** 2 * calculated_put_weights\n    self.assertAllClose(matched_put_weights, put_weights, tolerance)\n    variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(put_strikes, put_volatilities, call_strikes, call_volatilities, expiries, discount_rates, reference_strikes, reference_strikes, dtype=tf.float64))\n    self.assertAllClose(variance_price, k_var, 0.01)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'Demeterfi_et_al', 'call_strikes': np.array([100.0, 105.0, 110.0, 115.0, 120.0, 125.0, 130.0, 135.0, 140.0]), 'call_weights': np.array([19.63, 36.83, 33.55, 30.69, 28.19, 25.98, 24.02, 22.27]), 'call_volatilities': np.array([0.2, 0.19, 0.18, 0.17, 0.16, 0.15, 0.14, 0.13, np.nan]), 'put_strikes': np.array([100.0, 95.0, 90.0, 85.0, 80.0, 75.0, 70.0, 65.0, 60.0, 55.0, 50.0, 45.0]), 'put_weights': np.array([20.98, 45.0, 50.15, 56.23, 63.49, 72.26, 82.98, 96.27, 113.05, 134.63, 163.04]), 'put_volatilities': np.array([0.2, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3, np.nan]), 'reference_strikes': 100.0, 'expiries': 0.25, 'discount_rates': 0.05, 'tolerance': 0.01, 'k_var': 0.20467 ** 2})\ndef test_variance_swap_demeterfi_example(self, call_strikes, call_weights, call_volatilities, put_strikes, put_weights, put_volatilities, reference_strikes, expiries, discount_rates, tolerance, k_var):\n    if False:\n        i = 10\n    \"Tests ability to match 'hand' calculated variance replicating weights.\"\n    discount_factor = np.exp(discount_rates * expiries)\n    calculated_call_weights = self.evaluate(variance_swaps.replicating_weights(call_strikes, reference_strikes, expiries, dtype=tf.float64))\n    matched_call_weights = discount_factor * 100.0 ** 2 * calculated_call_weights\n    self.assertAllClose(matched_call_weights, call_weights, tolerance)\n    calculated_put_weights = self.evaluate(variance_swaps.replicating_weights(put_strikes, reference_strikes, expiries, dtype=tf.float64))\n    matched_put_weights = discount_factor * 100.0 ** 2 * calculated_put_weights\n    self.assertAllClose(matched_put_weights, put_weights, tolerance)\n    variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(put_strikes, put_volatilities, call_strikes, call_volatilities, expiries, discount_rates, reference_strikes, reference_strikes, dtype=tf.float64))\n    self.assertAllClose(variance_price, k_var, 0.01)",
            "@parameterized.named_parameters({'testcase_name': 'Demeterfi_et_al', 'call_strikes': np.array([100.0, 105.0, 110.0, 115.0, 120.0, 125.0, 130.0, 135.0, 140.0]), 'call_weights': np.array([19.63, 36.83, 33.55, 30.69, 28.19, 25.98, 24.02, 22.27]), 'call_volatilities': np.array([0.2, 0.19, 0.18, 0.17, 0.16, 0.15, 0.14, 0.13, np.nan]), 'put_strikes': np.array([100.0, 95.0, 90.0, 85.0, 80.0, 75.0, 70.0, 65.0, 60.0, 55.0, 50.0, 45.0]), 'put_weights': np.array([20.98, 45.0, 50.15, 56.23, 63.49, 72.26, 82.98, 96.27, 113.05, 134.63, 163.04]), 'put_volatilities': np.array([0.2, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3, np.nan]), 'reference_strikes': 100.0, 'expiries': 0.25, 'discount_rates': 0.05, 'tolerance': 0.01, 'k_var': 0.20467 ** 2})\ndef test_variance_swap_demeterfi_example(self, call_strikes, call_weights, call_volatilities, put_strikes, put_weights, put_volatilities, reference_strikes, expiries, discount_rates, tolerance, k_var):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Tests ability to match 'hand' calculated variance replicating weights.\"\n    discount_factor = np.exp(discount_rates * expiries)\n    calculated_call_weights = self.evaluate(variance_swaps.replicating_weights(call_strikes, reference_strikes, expiries, dtype=tf.float64))\n    matched_call_weights = discount_factor * 100.0 ** 2 * calculated_call_weights\n    self.assertAllClose(matched_call_weights, call_weights, tolerance)\n    calculated_put_weights = self.evaluate(variance_swaps.replicating_weights(put_strikes, reference_strikes, expiries, dtype=tf.float64))\n    matched_put_weights = discount_factor * 100.0 ** 2 * calculated_put_weights\n    self.assertAllClose(matched_put_weights, put_weights, tolerance)\n    variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(put_strikes, put_volatilities, call_strikes, call_volatilities, expiries, discount_rates, reference_strikes, reference_strikes, dtype=tf.float64))\n    self.assertAllClose(variance_price, k_var, 0.01)",
            "@parameterized.named_parameters({'testcase_name': 'Demeterfi_et_al', 'call_strikes': np.array([100.0, 105.0, 110.0, 115.0, 120.0, 125.0, 130.0, 135.0, 140.0]), 'call_weights': np.array([19.63, 36.83, 33.55, 30.69, 28.19, 25.98, 24.02, 22.27]), 'call_volatilities': np.array([0.2, 0.19, 0.18, 0.17, 0.16, 0.15, 0.14, 0.13, np.nan]), 'put_strikes': np.array([100.0, 95.0, 90.0, 85.0, 80.0, 75.0, 70.0, 65.0, 60.0, 55.0, 50.0, 45.0]), 'put_weights': np.array([20.98, 45.0, 50.15, 56.23, 63.49, 72.26, 82.98, 96.27, 113.05, 134.63, 163.04]), 'put_volatilities': np.array([0.2, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3, np.nan]), 'reference_strikes': 100.0, 'expiries': 0.25, 'discount_rates': 0.05, 'tolerance': 0.01, 'k_var': 0.20467 ** 2})\ndef test_variance_swap_demeterfi_example(self, call_strikes, call_weights, call_volatilities, put_strikes, put_weights, put_volatilities, reference_strikes, expiries, discount_rates, tolerance, k_var):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Tests ability to match 'hand' calculated variance replicating weights.\"\n    discount_factor = np.exp(discount_rates * expiries)\n    calculated_call_weights = self.evaluate(variance_swaps.replicating_weights(call_strikes, reference_strikes, expiries, dtype=tf.float64))\n    matched_call_weights = discount_factor * 100.0 ** 2 * calculated_call_weights\n    self.assertAllClose(matched_call_weights, call_weights, tolerance)\n    calculated_put_weights = self.evaluate(variance_swaps.replicating_weights(put_strikes, reference_strikes, expiries, dtype=tf.float64))\n    matched_put_weights = discount_factor * 100.0 ** 2 * calculated_put_weights\n    self.assertAllClose(matched_put_weights, put_weights, tolerance)\n    variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(put_strikes, put_volatilities, call_strikes, call_volatilities, expiries, discount_rates, reference_strikes, reference_strikes, dtype=tf.float64))\n    self.assertAllClose(variance_price, k_var, 0.01)",
            "@parameterized.named_parameters({'testcase_name': 'Demeterfi_et_al', 'call_strikes': np.array([100.0, 105.0, 110.0, 115.0, 120.0, 125.0, 130.0, 135.0, 140.0]), 'call_weights': np.array([19.63, 36.83, 33.55, 30.69, 28.19, 25.98, 24.02, 22.27]), 'call_volatilities': np.array([0.2, 0.19, 0.18, 0.17, 0.16, 0.15, 0.14, 0.13, np.nan]), 'put_strikes': np.array([100.0, 95.0, 90.0, 85.0, 80.0, 75.0, 70.0, 65.0, 60.0, 55.0, 50.0, 45.0]), 'put_weights': np.array([20.98, 45.0, 50.15, 56.23, 63.49, 72.26, 82.98, 96.27, 113.05, 134.63, 163.04]), 'put_volatilities': np.array([0.2, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3, np.nan]), 'reference_strikes': 100.0, 'expiries': 0.25, 'discount_rates': 0.05, 'tolerance': 0.01, 'k_var': 0.20467 ** 2})\ndef test_variance_swap_demeterfi_example(self, call_strikes, call_weights, call_volatilities, put_strikes, put_weights, put_volatilities, reference_strikes, expiries, discount_rates, tolerance, k_var):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Tests ability to match 'hand' calculated variance replicating weights.\"\n    discount_factor = np.exp(discount_rates * expiries)\n    calculated_call_weights = self.evaluate(variance_swaps.replicating_weights(call_strikes, reference_strikes, expiries, dtype=tf.float64))\n    matched_call_weights = discount_factor * 100.0 ** 2 * calculated_call_weights\n    self.assertAllClose(matched_call_weights, call_weights, tolerance)\n    calculated_put_weights = self.evaluate(variance_swaps.replicating_weights(put_strikes, reference_strikes, expiries, dtype=tf.float64))\n    matched_put_weights = discount_factor * 100.0 ** 2 * calculated_put_weights\n    self.assertAllClose(matched_put_weights, put_weights, tolerance)\n    variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(put_strikes, put_volatilities, call_strikes, call_volatilities, expiries, discount_rates, reference_strikes, reference_strikes, dtype=tf.float64))\n    self.assertAllClose(variance_price, k_var, 0.01)",
            "@parameterized.named_parameters({'testcase_name': 'Demeterfi_et_al', 'call_strikes': np.array([100.0, 105.0, 110.0, 115.0, 120.0, 125.0, 130.0, 135.0, 140.0]), 'call_weights': np.array([19.63, 36.83, 33.55, 30.69, 28.19, 25.98, 24.02, 22.27]), 'call_volatilities': np.array([0.2, 0.19, 0.18, 0.17, 0.16, 0.15, 0.14, 0.13, np.nan]), 'put_strikes': np.array([100.0, 95.0, 90.0, 85.0, 80.0, 75.0, 70.0, 65.0, 60.0, 55.0, 50.0, 45.0]), 'put_weights': np.array([20.98, 45.0, 50.15, 56.23, 63.49, 72.26, 82.98, 96.27, 113.05, 134.63, 163.04]), 'put_volatilities': np.array([0.2, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3, np.nan]), 'reference_strikes': 100.0, 'expiries': 0.25, 'discount_rates': 0.05, 'tolerance': 0.01, 'k_var': 0.20467 ** 2})\ndef test_variance_swap_demeterfi_example(self, call_strikes, call_weights, call_volatilities, put_strikes, put_weights, put_volatilities, reference_strikes, expiries, discount_rates, tolerance, k_var):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Tests ability to match 'hand' calculated variance replicating weights.\"\n    discount_factor = np.exp(discount_rates * expiries)\n    calculated_call_weights = self.evaluate(variance_swaps.replicating_weights(call_strikes, reference_strikes, expiries, dtype=tf.float64))\n    matched_call_weights = discount_factor * 100.0 ** 2 * calculated_call_weights\n    self.assertAllClose(matched_call_weights, call_weights, tolerance)\n    calculated_put_weights = self.evaluate(variance_swaps.replicating_weights(put_strikes, reference_strikes, expiries, dtype=tf.float64))\n    matched_put_weights = discount_factor * 100.0 ** 2 * calculated_put_weights\n    self.assertAllClose(matched_put_weights, put_weights, tolerance)\n    variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(put_strikes, put_volatilities, call_strikes, call_volatilities, expiries, discount_rates, reference_strikes, reference_strikes, dtype=tf.float64))\n    self.assertAllClose(variance_price, k_var, 0.01)"
        ]
    },
    {
        "func_name": "test_variance_swap_fair_strike_supports_batching",
        "original": "@parameterized.named_parameters({'testcase_name': 'with_validation', 'validate_args': True}, {'testcase_name': 'without_validation', 'validate_args': False})\ndef test_variance_swap_fair_strike_supports_batching(self, validate_args):\n    dtype = tf.float64\n    batch_call_strikes = tf.repeat(tf.expand_dims(tf.range(100, 120, 5, dtype=dtype), 0), 3, axis=0)\n    batch_put_strikes = tf.repeat(tf.expand_dims(tf.range(100, 80, -5, dtype=dtype), 0), 3, axis=0)\n    batch_vols = 0.2 * tf.ones((3, 4), dtype=dtype)\n    batch_shape = (3,)\n    reference_strikes = 100.0 * tf.ones(batch_shape, dtype=dtype)\n    batch_expiries = tf.constant([0.25, 0.5, 1.0], dtype=dtype)\n    discount_rates = 0.05 * tf.ones(batch_shape, dtype=dtype)\n    batch_variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(batch_put_strikes, batch_vols, batch_call_strikes, batch_vols, batch_expiries, discount_rates, reference_strikes, reference_strikes, validate_args=validate_args, dtype=dtype))\n    self.assertEqual(batch_variance_price.shape, batch_shape)\n    for i in range(3):\n        row_variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(batch_put_strikes[i, :], batch_vols[i, :], batch_call_strikes[i, :], batch_vols[i, :], batch_expiries[i], discount_rates[i], reference_strikes[i], reference_strikes[i], dtype=tf.float64))\n        self.assertAllEqual(row_variance_price, batch_variance_price[i])",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'with_validation', 'validate_args': True}, {'testcase_name': 'without_validation', 'validate_args': False})\ndef test_variance_swap_fair_strike_supports_batching(self, validate_args):\n    if False:\n        i = 10\n    dtype = tf.float64\n    batch_call_strikes = tf.repeat(tf.expand_dims(tf.range(100, 120, 5, dtype=dtype), 0), 3, axis=0)\n    batch_put_strikes = tf.repeat(tf.expand_dims(tf.range(100, 80, -5, dtype=dtype), 0), 3, axis=0)\n    batch_vols = 0.2 * tf.ones((3, 4), dtype=dtype)\n    batch_shape = (3,)\n    reference_strikes = 100.0 * tf.ones(batch_shape, dtype=dtype)\n    batch_expiries = tf.constant([0.25, 0.5, 1.0], dtype=dtype)\n    discount_rates = 0.05 * tf.ones(batch_shape, dtype=dtype)\n    batch_variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(batch_put_strikes, batch_vols, batch_call_strikes, batch_vols, batch_expiries, discount_rates, reference_strikes, reference_strikes, validate_args=validate_args, dtype=dtype))\n    self.assertEqual(batch_variance_price.shape, batch_shape)\n    for i in range(3):\n        row_variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(batch_put_strikes[i, :], batch_vols[i, :], batch_call_strikes[i, :], batch_vols[i, :], batch_expiries[i], discount_rates[i], reference_strikes[i], reference_strikes[i], dtype=tf.float64))\n        self.assertAllEqual(row_variance_price, batch_variance_price[i])",
            "@parameterized.named_parameters({'testcase_name': 'with_validation', 'validate_args': True}, {'testcase_name': 'without_validation', 'validate_args': False})\ndef test_variance_swap_fair_strike_supports_batching(self, validate_args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dtype = tf.float64\n    batch_call_strikes = tf.repeat(tf.expand_dims(tf.range(100, 120, 5, dtype=dtype), 0), 3, axis=0)\n    batch_put_strikes = tf.repeat(tf.expand_dims(tf.range(100, 80, -5, dtype=dtype), 0), 3, axis=0)\n    batch_vols = 0.2 * tf.ones((3, 4), dtype=dtype)\n    batch_shape = (3,)\n    reference_strikes = 100.0 * tf.ones(batch_shape, dtype=dtype)\n    batch_expiries = tf.constant([0.25, 0.5, 1.0], dtype=dtype)\n    discount_rates = 0.05 * tf.ones(batch_shape, dtype=dtype)\n    batch_variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(batch_put_strikes, batch_vols, batch_call_strikes, batch_vols, batch_expiries, discount_rates, reference_strikes, reference_strikes, validate_args=validate_args, dtype=dtype))\n    self.assertEqual(batch_variance_price.shape, batch_shape)\n    for i in range(3):\n        row_variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(batch_put_strikes[i, :], batch_vols[i, :], batch_call_strikes[i, :], batch_vols[i, :], batch_expiries[i], discount_rates[i], reference_strikes[i], reference_strikes[i], dtype=tf.float64))\n        self.assertAllEqual(row_variance_price, batch_variance_price[i])",
            "@parameterized.named_parameters({'testcase_name': 'with_validation', 'validate_args': True}, {'testcase_name': 'without_validation', 'validate_args': False})\ndef test_variance_swap_fair_strike_supports_batching(self, validate_args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dtype = tf.float64\n    batch_call_strikes = tf.repeat(tf.expand_dims(tf.range(100, 120, 5, dtype=dtype), 0), 3, axis=0)\n    batch_put_strikes = tf.repeat(tf.expand_dims(tf.range(100, 80, -5, dtype=dtype), 0), 3, axis=0)\n    batch_vols = 0.2 * tf.ones((3, 4), dtype=dtype)\n    batch_shape = (3,)\n    reference_strikes = 100.0 * tf.ones(batch_shape, dtype=dtype)\n    batch_expiries = tf.constant([0.25, 0.5, 1.0], dtype=dtype)\n    discount_rates = 0.05 * tf.ones(batch_shape, dtype=dtype)\n    batch_variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(batch_put_strikes, batch_vols, batch_call_strikes, batch_vols, batch_expiries, discount_rates, reference_strikes, reference_strikes, validate_args=validate_args, dtype=dtype))\n    self.assertEqual(batch_variance_price.shape, batch_shape)\n    for i in range(3):\n        row_variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(batch_put_strikes[i, :], batch_vols[i, :], batch_call_strikes[i, :], batch_vols[i, :], batch_expiries[i], discount_rates[i], reference_strikes[i], reference_strikes[i], dtype=tf.float64))\n        self.assertAllEqual(row_variance_price, batch_variance_price[i])",
            "@parameterized.named_parameters({'testcase_name': 'with_validation', 'validate_args': True}, {'testcase_name': 'without_validation', 'validate_args': False})\ndef test_variance_swap_fair_strike_supports_batching(self, validate_args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dtype = tf.float64\n    batch_call_strikes = tf.repeat(tf.expand_dims(tf.range(100, 120, 5, dtype=dtype), 0), 3, axis=0)\n    batch_put_strikes = tf.repeat(tf.expand_dims(tf.range(100, 80, -5, dtype=dtype), 0), 3, axis=0)\n    batch_vols = 0.2 * tf.ones((3, 4), dtype=dtype)\n    batch_shape = (3,)\n    reference_strikes = 100.0 * tf.ones(batch_shape, dtype=dtype)\n    batch_expiries = tf.constant([0.25, 0.5, 1.0], dtype=dtype)\n    discount_rates = 0.05 * tf.ones(batch_shape, dtype=dtype)\n    batch_variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(batch_put_strikes, batch_vols, batch_call_strikes, batch_vols, batch_expiries, discount_rates, reference_strikes, reference_strikes, validate_args=validate_args, dtype=dtype))\n    self.assertEqual(batch_variance_price.shape, batch_shape)\n    for i in range(3):\n        row_variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(batch_put_strikes[i, :], batch_vols[i, :], batch_call_strikes[i, :], batch_vols[i, :], batch_expiries[i], discount_rates[i], reference_strikes[i], reference_strikes[i], dtype=tf.float64))\n        self.assertAllEqual(row_variance_price, batch_variance_price[i])",
            "@parameterized.named_parameters({'testcase_name': 'with_validation', 'validate_args': True}, {'testcase_name': 'without_validation', 'validate_args': False})\ndef test_variance_swap_fair_strike_supports_batching(self, validate_args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dtype = tf.float64\n    batch_call_strikes = tf.repeat(tf.expand_dims(tf.range(100, 120, 5, dtype=dtype), 0), 3, axis=0)\n    batch_put_strikes = tf.repeat(tf.expand_dims(tf.range(100, 80, -5, dtype=dtype), 0), 3, axis=0)\n    batch_vols = 0.2 * tf.ones((3, 4), dtype=dtype)\n    batch_shape = (3,)\n    reference_strikes = 100.0 * tf.ones(batch_shape, dtype=dtype)\n    batch_expiries = tf.constant([0.25, 0.5, 1.0], dtype=dtype)\n    discount_rates = 0.05 * tf.ones(batch_shape, dtype=dtype)\n    batch_variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(batch_put_strikes, batch_vols, batch_call_strikes, batch_vols, batch_expiries, discount_rates, reference_strikes, reference_strikes, validate_args=validate_args, dtype=dtype))\n    self.assertEqual(batch_variance_price.shape, batch_shape)\n    for i in range(3):\n        row_variance_price = self.evaluate(tff.black_scholes.variance_swap_fair_strike(batch_put_strikes[i, :], batch_vols[i, :], batch_call_strikes[i, :], batch_vols[i, :], batch_expiries[i], discount_rates[i], reference_strikes[i], reference_strikes[i], dtype=tf.float64))\n        self.assertAllEqual(row_variance_price, batch_variance_price[i])"
        ]
    },
    {
        "func_name": "test_variance_swap_fair_strike_raises_validation_error",
        "original": "def test_variance_swap_fair_strike_raises_validation_error(self):\n    dtype = tf.float64\n    strikes = tf.ones((3, 2), dtype=dtype)\n    vols = tf.ones((3, 4), dtype=dtype)\n    reference_strike = 1.0\n    discount_rate = 0.0\n    expiry = 1.0\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        _ = self.evaluate(tff.black_scholes.variance_swap_fair_strike(strikes, vols, strikes, vols, expiry, discount_rate, reference_strike, reference_strike, validate_args=True, dtype=dtype))",
        "mutated": [
            "def test_variance_swap_fair_strike_raises_validation_error(self):\n    if False:\n        i = 10\n    dtype = tf.float64\n    strikes = tf.ones((3, 2), dtype=dtype)\n    vols = tf.ones((3, 4), dtype=dtype)\n    reference_strike = 1.0\n    discount_rate = 0.0\n    expiry = 1.0\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        _ = self.evaluate(tff.black_scholes.variance_swap_fair_strike(strikes, vols, strikes, vols, expiry, discount_rate, reference_strike, reference_strike, validate_args=True, dtype=dtype))",
            "def test_variance_swap_fair_strike_raises_validation_error(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dtype = tf.float64\n    strikes = tf.ones((3, 2), dtype=dtype)\n    vols = tf.ones((3, 4), dtype=dtype)\n    reference_strike = 1.0\n    discount_rate = 0.0\n    expiry = 1.0\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        _ = self.evaluate(tff.black_scholes.variance_swap_fair_strike(strikes, vols, strikes, vols, expiry, discount_rate, reference_strike, reference_strike, validate_args=True, dtype=dtype))",
            "def test_variance_swap_fair_strike_raises_validation_error(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dtype = tf.float64\n    strikes = tf.ones((3, 2), dtype=dtype)\n    vols = tf.ones((3, 4), dtype=dtype)\n    reference_strike = 1.0\n    discount_rate = 0.0\n    expiry = 1.0\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        _ = self.evaluate(tff.black_scholes.variance_swap_fair_strike(strikes, vols, strikes, vols, expiry, discount_rate, reference_strike, reference_strike, validate_args=True, dtype=dtype))",
            "def test_variance_swap_fair_strike_raises_validation_error(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dtype = tf.float64\n    strikes = tf.ones((3, 2), dtype=dtype)\n    vols = tf.ones((3, 4), dtype=dtype)\n    reference_strike = 1.0\n    discount_rate = 0.0\n    expiry = 1.0\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        _ = self.evaluate(tff.black_scholes.variance_swap_fair_strike(strikes, vols, strikes, vols, expiry, discount_rate, reference_strike, reference_strike, validate_args=True, dtype=dtype))",
            "def test_variance_swap_fair_strike_raises_validation_error(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dtype = tf.float64\n    strikes = tf.ones((3, 2), dtype=dtype)\n    vols = tf.ones((3, 4), dtype=dtype)\n    reference_strike = 1.0\n    discount_rate = 0.0\n    expiry = 1.0\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        _ = self.evaluate(tff.black_scholes.variance_swap_fair_strike(strikes, vols, strikes, vols, expiry, discount_rate, reference_strike, reference_strike, validate_args=True, dtype=dtype))"
        ]
    }
]