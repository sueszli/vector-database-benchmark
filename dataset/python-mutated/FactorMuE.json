[
    {
        "func_name": "generate_data",
        "original": "def generate_data(small_test, include_stop, device):\n    \"\"\"Generate mini example dataset.\"\"\"\n    if small_test:\n        mult_dat = 1\n    else:\n        mult_dat = 10\n    seqs = ['BABBA'] * mult_dat + ['BAAB'] * mult_dat + ['BABBB'] * mult_dat\n    dataset = BiosequenceDataset(seqs, 'list', 'AB', include_stop=include_stop, device=device)\n    return dataset",
        "mutated": [
            "def generate_data(small_test, include_stop, device):\n    if False:\n        i = 10\n    'Generate mini example dataset.'\n    if small_test:\n        mult_dat = 1\n    else:\n        mult_dat = 10\n    seqs = ['BABBA'] * mult_dat + ['BAAB'] * mult_dat + ['BABBB'] * mult_dat\n    dataset = BiosequenceDataset(seqs, 'list', 'AB', include_stop=include_stop, device=device)\n    return dataset",
            "def generate_data(small_test, include_stop, device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generate mini example dataset.'\n    if small_test:\n        mult_dat = 1\n    else:\n        mult_dat = 10\n    seqs = ['BABBA'] * mult_dat + ['BAAB'] * mult_dat + ['BABBB'] * mult_dat\n    dataset = BiosequenceDataset(seqs, 'list', 'AB', include_stop=include_stop, device=device)\n    return dataset",
            "def generate_data(small_test, include_stop, device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generate mini example dataset.'\n    if small_test:\n        mult_dat = 1\n    else:\n        mult_dat = 10\n    seqs = ['BABBA'] * mult_dat + ['BAAB'] * mult_dat + ['BABBB'] * mult_dat\n    dataset = BiosequenceDataset(seqs, 'list', 'AB', include_stop=include_stop, device=device)\n    return dataset",
            "def generate_data(small_test, include_stop, device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generate mini example dataset.'\n    if small_test:\n        mult_dat = 1\n    else:\n        mult_dat = 10\n    seqs = ['BABBA'] * mult_dat + ['BAAB'] * mult_dat + ['BABBB'] * mult_dat\n    dataset = BiosequenceDataset(seqs, 'list', 'AB', include_stop=include_stop, device=device)\n    return dataset",
            "def generate_data(small_test, include_stop, device):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generate mini example dataset.'\n    if small_test:\n        mult_dat = 1\n    else:\n        mult_dat = 10\n    seqs = ['BABBA'] * mult_dat + ['BAAB'] * mult_dat + ['BABBB'] * mult_dat\n    dataset = BiosequenceDataset(seqs, 'list', 'AB', include_stop=include_stop, device=device)\n    return dataset"
        ]
    },
    {
        "func_name": "main",
        "original": "def main(args):\n    if args.cpu_data or not args.cuda:\n        device = torch.device('cpu')\n    else:\n        device = torch.device('cuda')\n    if args.test:\n        dataset = generate_data(args.small, args.include_stop, device)\n    else:\n        dataset = BiosequenceDataset(args.file, 'fasta', args.alphabet, include_stop=args.include_stop, device=device)\n    args.batch_size = min([dataset.data_size, args.batch_size])\n    if args.split > 0.0:\n        heldout_num = int(np.ceil(args.split * len(dataset)))\n        data_lengths = [len(dataset) - heldout_num, heldout_num]\n        pyro.set_rng_seed(args.rng_data_seed)\n        indices = torch.randperm(sum(data_lengths), device=device).tolist()\n        (dataset_train, dataset_test) = [torch.utils.data.Subset(dataset, indices[offset - length:offset]) for (offset, length) in zip(torch._utils._accumulate(data_lengths), data_lengths)]\n    else:\n        dataset_train = dataset\n        dataset_test = None\n    pyro.set_rng_seed(args.rng_seed)\n    model = FactorMuE(dataset.max_length, dataset.alphabet_length, args.z_dim, batch_size=args.batch_size, latent_seq_length=args.latent_seq_length, indel_factor_dependence=args.indel_factor, indel_prior_scale=args.indel_prior_scale, indel_prior_bias=args.indel_prior_bias, inverse_temp_prior=args.inverse_temp_prior, weights_prior_scale=args.weights_prior_scale, offset_prior_scale=args.offset_prior_scale, z_prior_distribution=args.z_prior, ARD_prior=args.ARD_prior, substitution_matrix=not args.no_substitution_matrix, substitution_prior_scale=args.substitution_prior_scale, latent_alphabet_length=args.latent_alphabet, cuda=args.cuda, pin_memory=args.pin_mem)\n    scheduler = MultiStepLR({'optimizer': Adam, 'optim_args': {'lr': args.learning_rate}, 'milestones': json.loads(args.milestones), 'gamma': args.learning_gamma})\n    n_epochs = args.n_epochs\n    losses = model.fit_svi(dataset_train, n_epochs, args.anneal, args.batch_size, scheduler, args.jit)\n    (train_lp, test_lp, train_perplex, test_perplex) = model.evaluate(dataset_train, dataset_test, args.jit)\n    print('train logp: {} perplex: {}'.format(train_lp, train_perplex))\n    print('test logp: {} perplex: {}'.format(test_lp, test_perplex))\n    (z_locs, z_scales) = model.embed(dataset)\n    time_stamp = datetime.datetime.now().strftime('%Y%m%d-%H%M%S')\n    if not args.no_plots:\n        plt.figure(figsize=(6, 6))\n        plt.plot(losses)\n        plt.xlabel('step')\n        plt.ylabel('loss')\n        if not args.no_save:\n            plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.loss_{}.pdf'.format(time_stamp)))\n        plt.figure(figsize=(6, 6))\n        plt.scatter(z_locs[:, 0], z_locs[:, 1])\n        plt.xlabel('$z_1$')\n        plt.ylabel('$z_2$')\n        if not args.no_save:\n            plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.latent_{}.pdf'.format(time_stamp)))\n        if not args.indel_factor:\n            plt.figure(figsize=(6, 6))\n            insert = pyro.param('insert_q_mn').detach()\n            insert_expect = torch.exp(insert - insert.logsumexp(-1, True))\n            plt.plot(insert_expect[:, :, 1].cpu().numpy())\n            plt.xlabel('position')\n            plt.ylabel('probability of insert')\n            plt.legend(['$r_0$', '$r_1$', '$r_2$'])\n            if not args.no_save:\n                plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.insert_prob_{}.pdf'.format(time_stamp)))\n            plt.figure(figsize=(6, 6))\n            delete = pyro.param('delete_q_mn').detach()\n            delete_expect = torch.exp(delete - delete.logsumexp(-1, True))\n            plt.plot(delete_expect[:, :, 1].cpu().numpy())\n            plt.xlabel('position')\n            plt.ylabel('probability of delete')\n            plt.legend(['$u_0$', '$u_1$', '$u_2$'])\n            if not args.no_save:\n                plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.delete_prob_{}.pdf'.format(time_stamp)))\n    if not args.no_save:\n        pyro.get_param_store().save(os.path.join(args.out_folder, 'FactorMuE_results.params_{}.out'.format(time_stamp)))\n        with open(os.path.join(args.out_folder, 'FactorMuE_results.evaluation_{}.txt'.format(time_stamp)), 'w') as ow:\n            ow.write('train_lp,test_lp,train_perplex,test_perplex\\n')\n            ow.write('{},{},{},{}\\n'.format(train_lp, test_lp, train_perplex, test_perplex))\n        np.savetxt(os.path.join(args.out_folder, 'FactorMuE_results.embed_loc_{}.txt'.format(time_stamp)), z_locs.cpu().numpy())\n        np.savetxt(os.path.join(args.out_folder, 'FactorMuE_results.embed_scale_{}.txt'.format(time_stamp)), z_scales.cpu().numpy())\n        with open(os.path.join(args.out_folder, 'FactorMuE_results.input_{}.txt'.format(time_stamp)), 'w') as ow:\n            ow.write('[args]\\n')\n            args.latent_seq_length = model.latent_seq_length\n            args.latent_alphabet = model.latent_alphabet_length\n            for elem in list(args.__dict__.keys()):\n                ow.write('{} = {}\\n'.format(elem, args.__getattribute__(elem)))\n            ow.write('alphabet_str = {}\\n'.format(''.join(dataset.alphabet)))\n            ow.write('max_length = {}\\n'.format(dataset.max_length))",
        "mutated": [
            "def main(args):\n    if False:\n        i = 10\n    if args.cpu_data or not args.cuda:\n        device = torch.device('cpu')\n    else:\n        device = torch.device('cuda')\n    if args.test:\n        dataset = generate_data(args.small, args.include_stop, device)\n    else:\n        dataset = BiosequenceDataset(args.file, 'fasta', args.alphabet, include_stop=args.include_stop, device=device)\n    args.batch_size = min([dataset.data_size, args.batch_size])\n    if args.split > 0.0:\n        heldout_num = int(np.ceil(args.split * len(dataset)))\n        data_lengths = [len(dataset) - heldout_num, heldout_num]\n        pyro.set_rng_seed(args.rng_data_seed)\n        indices = torch.randperm(sum(data_lengths), device=device).tolist()\n        (dataset_train, dataset_test) = [torch.utils.data.Subset(dataset, indices[offset - length:offset]) for (offset, length) in zip(torch._utils._accumulate(data_lengths), data_lengths)]\n    else:\n        dataset_train = dataset\n        dataset_test = None\n    pyro.set_rng_seed(args.rng_seed)\n    model = FactorMuE(dataset.max_length, dataset.alphabet_length, args.z_dim, batch_size=args.batch_size, latent_seq_length=args.latent_seq_length, indel_factor_dependence=args.indel_factor, indel_prior_scale=args.indel_prior_scale, indel_prior_bias=args.indel_prior_bias, inverse_temp_prior=args.inverse_temp_prior, weights_prior_scale=args.weights_prior_scale, offset_prior_scale=args.offset_prior_scale, z_prior_distribution=args.z_prior, ARD_prior=args.ARD_prior, substitution_matrix=not args.no_substitution_matrix, substitution_prior_scale=args.substitution_prior_scale, latent_alphabet_length=args.latent_alphabet, cuda=args.cuda, pin_memory=args.pin_mem)\n    scheduler = MultiStepLR({'optimizer': Adam, 'optim_args': {'lr': args.learning_rate}, 'milestones': json.loads(args.milestones), 'gamma': args.learning_gamma})\n    n_epochs = args.n_epochs\n    losses = model.fit_svi(dataset_train, n_epochs, args.anneal, args.batch_size, scheduler, args.jit)\n    (train_lp, test_lp, train_perplex, test_perplex) = model.evaluate(dataset_train, dataset_test, args.jit)\n    print('train logp: {} perplex: {}'.format(train_lp, train_perplex))\n    print('test logp: {} perplex: {}'.format(test_lp, test_perplex))\n    (z_locs, z_scales) = model.embed(dataset)\n    time_stamp = datetime.datetime.now().strftime('%Y%m%d-%H%M%S')\n    if not args.no_plots:\n        plt.figure(figsize=(6, 6))\n        plt.plot(losses)\n        plt.xlabel('step')\n        plt.ylabel('loss')\n        if not args.no_save:\n            plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.loss_{}.pdf'.format(time_stamp)))\n        plt.figure(figsize=(6, 6))\n        plt.scatter(z_locs[:, 0], z_locs[:, 1])\n        plt.xlabel('$z_1$')\n        plt.ylabel('$z_2$')\n        if not args.no_save:\n            plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.latent_{}.pdf'.format(time_stamp)))\n        if not args.indel_factor:\n            plt.figure(figsize=(6, 6))\n            insert = pyro.param('insert_q_mn').detach()\n            insert_expect = torch.exp(insert - insert.logsumexp(-1, True))\n            plt.plot(insert_expect[:, :, 1].cpu().numpy())\n            plt.xlabel('position')\n            plt.ylabel('probability of insert')\n            plt.legend(['$r_0$', '$r_1$', '$r_2$'])\n            if not args.no_save:\n                plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.insert_prob_{}.pdf'.format(time_stamp)))\n            plt.figure(figsize=(6, 6))\n            delete = pyro.param('delete_q_mn').detach()\n            delete_expect = torch.exp(delete - delete.logsumexp(-1, True))\n            plt.plot(delete_expect[:, :, 1].cpu().numpy())\n            plt.xlabel('position')\n            plt.ylabel('probability of delete')\n            plt.legend(['$u_0$', '$u_1$', '$u_2$'])\n            if not args.no_save:\n                plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.delete_prob_{}.pdf'.format(time_stamp)))\n    if not args.no_save:\n        pyro.get_param_store().save(os.path.join(args.out_folder, 'FactorMuE_results.params_{}.out'.format(time_stamp)))\n        with open(os.path.join(args.out_folder, 'FactorMuE_results.evaluation_{}.txt'.format(time_stamp)), 'w') as ow:\n            ow.write('train_lp,test_lp,train_perplex,test_perplex\\n')\n            ow.write('{},{},{},{}\\n'.format(train_lp, test_lp, train_perplex, test_perplex))\n        np.savetxt(os.path.join(args.out_folder, 'FactorMuE_results.embed_loc_{}.txt'.format(time_stamp)), z_locs.cpu().numpy())\n        np.savetxt(os.path.join(args.out_folder, 'FactorMuE_results.embed_scale_{}.txt'.format(time_stamp)), z_scales.cpu().numpy())\n        with open(os.path.join(args.out_folder, 'FactorMuE_results.input_{}.txt'.format(time_stamp)), 'w') as ow:\n            ow.write('[args]\\n')\n            args.latent_seq_length = model.latent_seq_length\n            args.latent_alphabet = model.latent_alphabet_length\n            for elem in list(args.__dict__.keys()):\n                ow.write('{} = {}\\n'.format(elem, args.__getattribute__(elem)))\n            ow.write('alphabet_str = {}\\n'.format(''.join(dataset.alphabet)))\n            ow.write('max_length = {}\\n'.format(dataset.max_length))",
            "def main(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if args.cpu_data or not args.cuda:\n        device = torch.device('cpu')\n    else:\n        device = torch.device('cuda')\n    if args.test:\n        dataset = generate_data(args.small, args.include_stop, device)\n    else:\n        dataset = BiosequenceDataset(args.file, 'fasta', args.alphabet, include_stop=args.include_stop, device=device)\n    args.batch_size = min([dataset.data_size, args.batch_size])\n    if args.split > 0.0:\n        heldout_num = int(np.ceil(args.split * len(dataset)))\n        data_lengths = [len(dataset) - heldout_num, heldout_num]\n        pyro.set_rng_seed(args.rng_data_seed)\n        indices = torch.randperm(sum(data_lengths), device=device).tolist()\n        (dataset_train, dataset_test) = [torch.utils.data.Subset(dataset, indices[offset - length:offset]) for (offset, length) in zip(torch._utils._accumulate(data_lengths), data_lengths)]\n    else:\n        dataset_train = dataset\n        dataset_test = None\n    pyro.set_rng_seed(args.rng_seed)\n    model = FactorMuE(dataset.max_length, dataset.alphabet_length, args.z_dim, batch_size=args.batch_size, latent_seq_length=args.latent_seq_length, indel_factor_dependence=args.indel_factor, indel_prior_scale=args.indel_prior_scale, indel_prior_bias=args.indel_prior_bias, inverse_temp_prior=args.inverse_temp_prior, weights_prior_scale=args.weights_prior_scale, offset_prior_scale=args.offset_prior_scale, z_prior_distribution=args.z_prior, ARD_prior=args.ARD_prior, substitution_matrix=not args.no_substitution_matrix, substitution_prior_scale=args.substitution_prior_scale, latent_alphabet_length=args.latent_alphabet, cuda=args.cuda, pin_memory=args.pin_mem)\n    scheduler = MultiStepLR({'optimizer': Adam, 'optim_args': {'lr': args.learning_rate}, 'milestones': json.loads(args.milestones), 'gamma': args.learning_gamma})\n    n_epochs = args.n_epochs\n    losses = model.fit_svi(dataset_train, n_epochs, args.anneal, args.batch_size, scheduler, args.jit)\n    (train_lp, test_lp, train_perplex, test_perplex) = model.evaluate(dataset_train, dataset_test, args.jit)\n    print('train logp: {} perplex: {}'.format(train_lp, train_perplex))\n    print('test logp: {} perplex: {}'.format(test_lp, test_perplex))\n    (z_locs, z_scales) = model.embed(dataset)\n    time_stamp = datetime.datetime.now().strftime('%Y%m%d-%H%M%S')\n    if not args.no_plots:\n        plt.figure(figsize=(6, 6))\n        plt.plot(losses)\n        plt.xlabel('step')\n        plt.ylabel('loss')\n        if not args.no_save:\n            plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.loss_{}.pdf'.format(time_stamp)))\n        plt.figure(figsize=(6, 6))\n        plt.scatter(z_locs[:, 0], z_locs[:, 1])\n        plt.xlabel('$z_1$')\n        plt.ylabel('$z_2$')\n        if not args.no_save:\n            plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.latent_{}.pdf'.format(time_stamp)))\n        if not args.indel_factor:\n            plt.figure(figsize=(6, 6))\n            insert = pyro.param('insert_q_mn').detach()\n            insert_expect = torch.exp(insert - insert.logsumexp(-1, True))\n            plt.plot(insert_expect[:, :, 1].cpu().numpy())\n            plt.xlabel('position')\n            plt.ylabel('probability of insert')\n            plt.legend(['$r_0$', '$r_1$', '$r_2$'])\n            if not args.no_save:\n                plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.insert_prob_{}.pdf'.format(time_stamp)))\n            plt.figure(figsize=(6, 6))\n            delete = pyro.param('delete_q_mn').detach()\n            delete_expect = torch.exp(delete - delete.logsumexp(-1, True))\n            plt.plot(delete_expect[:, :, 1].cpu().numpy())\n            plt.xlabel('position')\n            plt.ylabel('probability of delete')\n            plt.legend(['$u_0$', '$u_1$', '$u_2$'])\n            if not args.no_save:\n                plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.delete_prob_{}.pdf'.format(time_stamp)))\n    if not args.no_save:\n        pyro.get_param_store().save(os.path.join(args.out_folder, 'FactorMuE_results.params_{}.out'.format(time_stamp)))\n        with open(os.path.join(args.out_folder, 'FactorMuE_results.evaluation_{}.txt'.format(time_stamp)), 'w') as ow:\n            ow.write('train_lp,test_lp,train_perplex,test_perplex\\n')\n            ow.write('{},{},{},{}\\n'.format(train_lp, test_lp, train_perplex, test_perplex))\n        np.savetxt(os.path.join(args.out_folder, 'FactorMuE_results.embed_loc_{}.txt'.format(time_stamp)), z_locs.cpu().numpy())\n        np.savetxt(os.path.join(args.out_folder, 'FactorMuE_results.embed_scale_{}.txt'.format(time_stamp)), z_scales.cpu().numpy())\n        with open(os.path.join(args.out_folder, 'FactorMuE_results.input_{}.txt'.format(time_stamp)), 'w') as ow:\n            ow.write('[args]\\n')\n            args.latent_seq_length = model.latent_seq_length\n            args.latent_alphabet = model.latent_alphabet_length\n            for elem in list(args.__dict__.keys()):\n                ow.write('{} = {}\\n'.format(elem, args.__getattribute__(elem)))\n            ow.write('alphabet_str = {}\\n'.format(''.join(dataset.alphabet)))\n            ow.write('max_length = {}\\n'.format(dataset.max_length))",
            "def main(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if args.cpu_data or not args.cuda:\n        device = torch.device('cpu')\n    else:\n        device = torch.device('cuda')\n    if args.test:\n        dataset = generate_data(args.small, args.include_stop, device)\n    else:\n        dataset = BiosequenceDataset(args.file, 'fasta', args.alphabet, include_stop=args.include_stop, device=device)\n    args.batch_size = min([dataset.data_size, args.batch_size])\n    if args.split > 0.0:\n        heldout_num = int(np.ceil(args.split * len(dataset)))\n        data_lengths = [len(dataset) - heldout_num, heldout_num]\n        pyro.set_rng_seed(args.rng_data_seed)\n        indices = torch.randperm(sum(data_lengths), device=device).tolist()\n        (dataset_train, dataset_test) = [torch.utils.data.Subset(dataset, indices[offset - length:offset]) for (offset, length) in zip(torch._utils._accumulate(data_lengths), data_lengths)]\n    else:\n        dataset_train = dataset\n        dataset_test = None\n    pyro.set_rng_seed(args.rng_seed)\n    model = FactorMuE(dataset.max_length, dataset.alphabet_length, args.z_dim, batch_size=args.batch_size, latent_seq_length=args.latent_seq_length, indel_factor_dependence=args.indel_factor, indel_prior_scale=args.indel_prior_scale, indel_prior_bias=args.indel_prior_bias, inverse_temp_prior=args.inverse_temp_prior, weights_prior_scale=args.weights_prior_scale, offset_prior_scale=args.offset_prior_scale, z_prior_distribution=args.z_prior, ARD_prior=args.ARD_prior, substitution_matrix=not args.no_substitution_matrix, substitution_prior_scale=args.substitution_prior_scale, latent_alphabet_length=args.latent_alphabet, cuda=args.cuda, pin_memory=args.pin_mem)\n    scheduler = MultiStepLR({'optimizer': Adam, 'optim_args': {'lr': args.learning_rate}, 'milestones': json.loads(args.milestones), 'gamma': args.learning_gamma})\n    n_epochs = args.n_epochs\n    losses = model.fit_svi(dataset_train, n_epochs, args.anneal, args.batch_size, scheduler, args.jit)\n    (train_lp, test_lp, train_perplex, test_perplex) = model.evaluate(dataset_train, dataset_test, args.jit)\n    print('train logp: {} perplex: {}'.format(train_lp, train_perplex))\n    print('test logp: {} perplex: {}'.format(test_lp, test_perplex))\n    (z_locs, z_scales) = model.embed(dataset)\n    time_stamp = datetime.datetime.now().strftime('%Y%m%d-%H%M%S')\n    if not args.no_plots:\n        plt.figure(figsize=(6, 6))\n        plt.plot(losses)\n        plt.xlabel('step')\n        plt.ylabel('loss')\n        if not args.no_save:\n            plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.loss_{}.pdf'.format(time_stamp)))\n        plt.figure(figsize=(6, 6))\n        plt.scatter(z_locs[:, 0], z_locs[:, 1])\n        plt.xlabel('$z_1$')\n        plt.ylabel('$z_2$')\n        if not args.no_save:\n            plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.latent_{}.pdf'.format(time_stamp)))\n        if not args.indel_factor:\n            plt.figure(figsize=(6, 6))\n            insert = pyro.param('insert_q_mn').detach()\n            insert_expect = torch.exp(insert - insert.logsumexp(-1, True))\n            plt.plot(insert_expect[:, :, 1].cpu().numpy())\n            plt.xlabel('position')\n            plt.ylabel('probability of insert')\n            plt.legend(['$r_0$', '$r_1$', '$r_2$'])\n            if not args.no_save:\n                plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.insert_prob_{}.pdf'.format(time_stamp)))\n            plt.figure(figsize=(6, 6))\n            delete = pyro.param('delete_q_mn').detach()\n            delete_expect = torch.exp(delete - delete.logsumexp(-1, True))\n            plt.plot(delete_expect[:, :, 1].cpu().numpy())\n            plt.xlabel('position')\n            plt.ylabel('probability of delete')\n            plt.legend(['$u_0$', '$u_1$', '$u_2$'])\n            if not args.no_save:\n                plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.delete_prob_{}.pdf'.format(time_stamp)))\n    if not args.no_save:\n        pyro.get_param_store().save(os.path.join(args.out_folder, 'FactorMuE_results.params_{}.out'.format(time_stamp)))\n        with open(os.path.join(args.out_folder, 'FactorMuE_results.evaluation_{}.txt'.format(time_stamp)), 'w') as ow:\n            ow.write('train_lp,test_lp,train_perplex,test_perplex\\n')\n            ow.write('{},{},{},{}\\n'.format(train_lp, test_lp, train_perplex, test_perplex))\n        np.savetxt(os.path.join(args.out_folder, 'FactorMuE_results.embed_loc_{}.txt'.format(time_stamp)), z_locs.cpu().numpy())\n        np.savetxt(os.path.join(args.out_folder, 'FactorMuE_results.embed_scale_{}.txt'.format(time_stamp)), z_scales.cpu().numpy())\n        with open(os.path.join(args.out_folder, 'FactorMuE_results.input_{}.txt'.format(time_stamp)), 'w') as ow:\n            ow.write('[args]\\n')\n            args.latent_seq_length = model.latent_seq_length\n            args.latent_alphabet = model.latent_alphabet_length\n            for elem in list(args.__dict__.keys()):\n                ow.write('{} = {}\\n'.format(elem, args.__getattribute__(elem)))\n            ow.write('alphabet_str = {}\\n'.format(''.join(dataset.alphabet)))\n            ow.write('max_length = {}\\n'.format(dataset.max_length))",
            "def main(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if args.cpu_data or not args.cuda:\n        device = torch.device('cpu')\n    else:\n        device = torch.device('cuda')\n    if args.test:\n        dataset = generate_data(args.small, args.include_stop, device)\n    else:\n        dataset = BiosequenceDataset(args.file, 'fasta', args.alphabet, include_stop=args.include_stop, device=device)\n    args.batch_size = min([dataset.data_size, args.batch_size])\n    if args.split > 0.0:\n        heldout_num = int(np.ceil(args.split * len(dataset)))\n        data_lengths = [len(dataset) - heldout_num, heldout_num]\n        pyro.set_rng_seed(args.rng_data_seed)\n        indices = torch.randperm(sum(data_lengths), device=device).tolist()\n        (dataset_train, dataset_test) = [torch.utils.data.Subset(dataset, indices[offset - length:offset]) for (offset, length) in zip(torch._utils._accumulate(data_lengths), data_lengths)]\n    else:\n        dataset_train = dataset\n        dataset_test = None\n    pyro.set_rng_seed(args.rng_seed)\n    model = FactorMuE(dataset.max_length, dataset.alphabet_length, args.z_dim, batch_size=args.batch_size, latent_seq_length=args.latent_seq_length, indel_factor_dependence=args.indel_factor, indel_prior_scale=args.indel_prior_scale, indel_prior_bias=args.indel_prior_bias, inverse_temp_prior=args.inverse_temp_prior, weights_prior_scale=args.weights_prior_scale, offset_prior_scale=args.offset_prior_scale, z_prior_distribution=args.z_prior, ARD_prior=args.ARD_prior, substitution_matrix=not args.no_substitution_matrix, substitution_prior_scale=args.substitution_prior_scale, latent_alphabet_length=args.latent_alphabet, cuda=args.cuda, pin_memory=args.pin_mem)\n    scheduler = MultiStepLR({'optimizer': Adam, 'optim_args': {'lr': args.learning_rate}, 'milestones': json.loads(args.milestones), 'gamma': args.learning_gamma})\n    n_epochs = args.n_epochs\n    losses = model.fit_svi(dataset_train, n_epochs, args.anneal, args.batch_size, scheduler, args.jit)\n    (train_lp, test_lp, train_perplex, test_perplex) = model.evaluate(dataset_train, dataset_test, args.jit)\n    print('train logp: {} perplex: {}'.format(train_lp, train_perplex))\n    print('test logp: {} perplex: {}'.format(test_lp, test_perplex))\n    (z_locs, z_scales) = model.embed(dataset)\n    time_stamp = datetime.datetime.now().strftime('%Y%m%d-%H%M%S')\n    if not args.no_plots:\n        plt.figure(figsize=(6, 6))\n        plt.plot(losses)\n        plt.xlabel('step')\n        plt.ylabel('loss')\n        if not args.no_save:\n            plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.loss_{}.pdf'.format(time_stamp)))\n        plt.figure(figsize=(6, 6))\n        plt.scatter(z_locs[:, 0], z_locs[:, 1])\n        plt.xlabel('$z_1$')\n        plt.ylabel('$z_2$')\n        if not args.no_save:\n            plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.latent_{}.pdf'.format(time_stamp)))\n        if not args.indel_factor:\n            plt.figure(figsize=(6, 6))\n            insert = pyro.param('insert_q_mn').detach()\n            insert_expect = torch.exp(insert - insert.logsumexp(-1, True))\n            plt.plot(insert_expect[:, :, 1].cpu().numpy())\n            plt.xlabel('position')\n            plt.ylabel('probability of insert')\n            plt.legend(['$r_0$', '$r_1$', '$r_2$'])\n            if not args.no_save:\n                plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.insert_prob_{}.pdf'.format(time_stamp)))\n            plt.figure(figsize=(6, 6))\n            delete = pyro.param('delete_q_mn').detach()\n            delete_expect = torch.exp(delete - delete.logsumexp(-1, True))\n            plt.plot(delete_expect[:, :, 1].cpu().numpy())\n            plt.xlabel('position')\n            plt.ylabel('probability of delete')\n            plt.legend(['$u_0$', '$u_1$', '$u_2$'])\n            if not args.no_save:\n                plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.delete_prob_{}.pdf'.format(time_stamp)))\n    if not args.no_save:\n        pyro.get_param_store().save(os.path.join(args.out_folder, 'FactorMuE_results.params_{}.out'.format(time_stamp)))\n        with open(os.path.join(args.out_folder, 'FactorMuE_results.evaluation_{}.txt'.format(time_stamp)), 'w') as ow:\n            ow.write('train_lp,test_lp,train_perplex,test_perplex\\n')\n            ow.write('{},{},{},{}\\n'.format(train_lp, test_lp, train_perplex, test_perplex))\n        np.savetxt(os.path.join(args.out_folder, 'FactorMuE_results.embed_loc_{}.txt'.format(time_stamp)), z_locs.cpu().numpy())\n        np.savetxt(os.path.join(args.out_folder, 'FactorMuE_results.embed_scale_{}.txt'.format(time_stamp)), z_scales.cpu().numpy())\n        with open(os.path.join(args.out_folder, 'FactorMuE_results.input_{}.txt'.format(time_stamp)), 'w') as ow:\n            ow.write('[args]\\n')\n            args.latent_seq_length = model.latent_seq_length\n            args.latent_alphabet = model.latent_alphabet_length\n            for elem in list(args.__dict__.keys()):\n                ow.write('{} = {}\\n'.format(elem, args.__getattribute__(elem)))\n            ow.write('alphabet_str = {}\\n'.format(''.join(dataset.alphabet)))\n            ow.write('max_length = {}\\n'.format(dataset.max_length))",
            "def main(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if args.cpu_data or not args.cuda:\n        device = torch.device('cpu')\n    else:\n        device = torch.device('cuda')\n    if args.test:\n        dataset = generate_data(args.small, args.include_stop, device)\n    else:\n        dataset = BiosequenceDataset(args.file, 'fasta', args.alphabet, include_stop=args.include_stop, device=device)\n    args.batch_size = min([dataset.data_size, args.batch_size])\n    if args.split > 0.0:\n        heldout_num = int(np.ceil(args.split * len(dataset)))\n        data_lengths = [len(dataset) - heldout_num, heldout_num]\n        pyro.set_rng_seed(args.rng_data_seed)\n        indices = torch.randperm(sum(data_lengths), device=device).tolist()\n        (dataset_train, dataset_test) = [torch.utils.data.Subset(dataset, indices[offset - length:offset]) for (offset, length) in zip(torch._utils._accumulate(data_lengths), data_lengths)]\n    else:\n        dataset_train = dataset\n        dataset_test = None\n    pyro.set_rng_seed(args.rng_seed)\n    model = FactorMuE(dataset.max_length, dataset.alphabet_length, args.z_dim, batch_size=args.batch_size, latent_seq_length=args.latent_seq_length, indel_factor_dependence=args.indel_factor, indel_prior_scale=args.indel_prior_scale, indel_prior_bias=args.indel_prior_bias, inverse_temp_prior=args.inverse_temp_prior, weights_prior_scale=args.weights_prior_scale, offset_prior_scale=args.offset_prior_scale, z_prior_distribution=args.z_prior, ARD_prior=args.ARD_prior, substitution_matrix=not args.no_substitution_matrix, substitution_prior_scale=args.substitution_prior_scale, latent_alphabet_length=args.latent_alphabet, cuda=args.cuda, pin_memory=args.pin_mem)\n    scheduler = MultiStepLR({'optimizer': Adam, 'optim_args': {'lr': args.learning_rate}, 'milestones': json.loads(args.milestones), 'gamma': args.learning_gamma})\n    n_epochs = args.n_epochs\n    losses = model.fit_svi(dataset_train, n_epochs, args.anneal, args.batch_size, scheduler, args.jit)\n    (train_lp, test_lp, train_perplex, test_perplex) = model.evaluate(dataset_train, dataset_test, args.jit)\n    print('train logp: {} perplex: {}'.format(train_lp, train_perplex))\n    print('test logp: {} perplex: {}'.format(test_lp, test_perplex))\n    (z_locs, z_scales) = model.embed(dataset)\n    time_stamp = datetime.datetime.now().strftime('%Y%m%d-%H%M%S')\n    if not args.no_plots:\n        plt.figure(figsize=(6, 6))\n        plt.plot(losses)\n        plt.xlabel('step')\n        plt.ylabel('loss')\n        if not args.no_save:\n            plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.loss_{}.pdf'.format(time_stamp)))\n        plt.figure(figsize=(6, 6))\n        plt.scatter(z_locs[:, 0], z_locs[:, 1])\n        plt.xlabel('$z_1$')\n        plt.ylabel('$z_2$')\n        if not args.no_save:\n            plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.latent_{}.pdf'.format(time_stamp)))\n        if not args.indel_factor:\n            plt.figure(figsize=(6, 6))\n            insert = pyro.param('insert_q_mn').detach()\n            insert_expect = torch.exp(insert - insert.logsumexp(-1, True))\n            plt.plot(insert_expect[:, :, 1].cpu().numpy())\n            plt.xlabel('position')\n            plt.ylabel('probability of insert')\n            plt.legend(['$r_0$', '$r_1$', '$r_2$'])\n            if not args.no_save:\n                plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.insert_prob_{}.pdf'.format(time_stamp)))\n            plt.figure(figsize=(6, 6))\n            delete = pyro.param('delete_q_mn').detach()\n            delete_expect = torch.exp(delete - delete.logsumexp(-1, True))\n            plt.plot(delete_expect[:, :, 1].cpu().numpy())\n            plt.xlabel('position')\n            plt.ylabel('probability of delete')\n            plt.legend(['$u_0$', '$u_1$', '$u_2$'])\n            if not args.no_save:\n                plt.savefig(os.path.join(args.out_folder, 'FactorMuE_plot.delete_prob_{}.pdf'.format(time_stamp)))\n    if not args.no_save:\n        pyro.get_param_store().save(os.path.join(args.out_folder, 'FactorMuE_results.params_{}.out'.format(time_stamp)))\n        with open(os.path.join(args.out_folder, 'FactorMuE_results.evaluation_{}.txt'.format(time_stamp)), 'w') as ow:\n            ow.write('train_lp,test_lp,train_perplex,test_perplex\\n')\n            ow.write('{},{},{},{}\\n'.format(train_lp, test_lp, train_perplex, test_perplex))\n        np.savetxt(os.path.join(args.out_folder, 'FactorMuE_results.embed_loc_{}.txt'.format(time_stamp)), z_locs.cpu().numpy())\n        np.savetxt(os.path.join(args.out_folder, 'FactorMuE_results.embed_scale_{}.txt'.format(time_stamp)), z_scales.cpu().numpy())\n        with open(os.path.join(args.out_folder, 'FactorMuE_results.input_{}.txt'.format(time_stamp)), 'w') as ow:\n            ow.write('[args]\\n')\n            args.latent_seq_length = model.latent_seq_length\n            args.latent_alphabet = model.latent_alphabet_length\n            for elem in list(args.__dict__.keys()):\n                ow.write('{} = {}\\n'.format(elem, args.__getattribute__(elem)))\n            ow.write('alphabet_str = {}\\n'.format(''.join(dataset.alphabet)))\n            ow.write('max_length = {}\\n'.format(dataset.max_length))"
        ]
    }
]