[
    {
        "func_name": "gen",
        "original": "def gen(mode, simd, fsize):\n    funcname = 'convolution_{mode}_fh{fsize}_{simd}'.format(**vars())\n    filename = funcname + '.cpp'\n    if simd == 'fma':\n        MAX_H = 15 - fsize\n    elif simd == 'avx' or simd == 'sse':\n        MAX_H = 14 - fsize\n    else:\n        assert False\n    if simd == 'sse':\n        width = 4\n        mm_type = '__m128'\n        mm_load = '_mm_loadu_ps'\n        mm_store = '_mm_storeu_ps'\n        mm_mul = '_mm_mul_ps'\n        mm_add = '_mm_add_ps'\n        mm_set1 = '_mm_set1_ps'\n        mm_set0 = '_mm_setzero_ps'\n        mm_max = '_mm_max_ps'\n        mm_set1_sign = ''\n        header = ['xmmintrin.h']\n    elif simd == 'avx':\n        width = 8\n        mm_type = '__m256'\n        mm_load = '_mm256_loadu_ps'\n        mm_store = '_mm256_storeu_ps'\n        mm_mul = '_mm256_mul_ps'\n        mm_add = '_mm256_add_ps'\n        mm_set1 = '_mm256_broadcast_ss'\n        mm_set0 = '_mm256_setzero_ps'\n        mm_max = '_mm256_max_ps'\n        mm_set1_sign = '&'\n        header = ['immintrin.h', 'avxintrin.h']\n    elif simd == 'fma':\n        width = 8\n        mm_type = '__m256'\n        mm_load = '_mm256_loadu_ps'\n        mm_store = '_mm256_storeu_ps'\n        mm_set1 = '_mm256_broadcast_ss'\n        mm_set0 = '_mm256_setzero_ps'\n        mm_max = '_mm256_max_ps'\n        mm_set1_sign = '&'\n        header = ['immintrin.h', 'avxintrin.h', 'fmaintrin.h']\n    with open(filename, 'w') as f:\n        for H in range(1, MAX_H + 1):\n            f.write('#define SIMD_H{H} do {{ \\\\\\nconst size_t sh = dh; \\\\\\nconst float *src_d = src + sh*src_w; \\\\\\nfloat *dst_d = dst + dh*dst_w; \\\\\\nsize_t dw = dst_w_beg; \\\\\\nfor (; dw < dst_w_end; dw += {width}) {{ \\\\\\n    const size_t sw = dw; \\\\\\n    float *dst_dd = dst_d + dw; \\\\\\n    {mm_type} tmp0; \\\\\\n'.format(**vars()))\n            if simd != 'fma':\n                f.write('    {mm_type} tmp1; \\\\\\n'.format(**vars()))\n            for h in range(H):\n                f.write('    {mm_type} res{h}; \\\\\\n    res{h} = {mm_load}(dst_dd + {h}*dst_w); \\\\\\n'.format(**vars()))\n            f.write('    for (size_t fw = 0; fw < flt_w; ++fw) {{ \\\\\\n        const float *src_dd = src_d + sw + fw; \\\\\\n'.format(**vars()))\n            for fh in range(fsize):\n                if mode == 'xcorr':\n                    f.write('        {mm_type} vf{fh} = {mm_set1}({mm_set1_sign}filter[{fh}*flt_w+fw]); \\\\\\n'.format(**vars()))\n                elif mode == 'conv':\n                    f.write('        {mm_type} vf{fh} = {mm_set1}({mm_set1_sign}filter[{fh}*flt_w+flt_w-fw-1]); \\\\\\n'.format(**vars()))\n                else:\n                    assert False\n            for ih in range(H + fsize - 1):\n                f.write('        tmp0 = {mm_load}(src_dd + {ih}*src_w); \\\\\\n'.format(**vars()))\n                for fh in range(fsize):\n                    if mode == 'xcorr':\n                        oh = ih - fh\n                    elif mode == 'conv':\n                        oh = ih - (fsize - fh - 1)\n                    else:\n                        assert False\n                    if oh >= 0 and oh < H:\n                        if simd == 'fma':\n                            f.write('        res{oh} = _mm256_fmadd_ps(tmp0, vf{fh}, res{oh}); \\\\\\n'.format(**vars()))\n                        else:\n                            f.write('        tmp1 = {mm_mul}(tmp0, vf{fh}); \\\\\\n'.format(**vars()))\n                            f.write('        res{oh} = {mm_add}(res{oh}, tmp1); \\\\\\n'.format(**vars()))\n            f.write('    }} \\\\\\n'.format(**vars()))\n            for h in range(H):\n                f.write('    {mm_store}(dst_dd + {h}*dst_w, res{h}); \\\\\\n'.format(**vars()))\n            f.write('}} \\\\\\n}} while (0)\\n'.format(**vars()))\n            f.write('\\n')\n        for i in header:\n            f.write('#include <{}>\\n'.format(i))\n        f.write('#include <algorithm>\\n\\n#include \"../convolution_direct_special_cases.h\"\\n\\nnamespace megdnn {{\\nnamespace x86 {{\\nnamespace detail {{\\n\\nvoid {funcname}(const float *src, const float *filter, float *dst,\\n        const size_t src_h, const size_t src_w, const size_t dst_h, const size_t dst_w,\\n        const size_t flt_w)\\n{{\\n    (void)src_h;\\n    const size_t dst_h_beg = 0;\\n    const size_t dst_h_end = dst_h;\\n    const size_t dst_w_beg = 0;\\n    const size_t dst_w_end = dst_w;\\n'.format(**vars()))\n        f.write('\\n    size_t dh = dst_h_beg;\\n    for (; dh + {MAX_H} <= dst_h_end; dh += {MAX_H}) {{\\n        SIMD_H{MAX_H};\\n    }}\\n    switch (dst_h_end - dh) {{\\n'.format(**vars()))\n        for H in range(1, MAX_H):\n            f.write('        case {H}:\\n            SIMD_H{H};\\n            break;\\n'.format(**vars()))\n        f.write('    }}\\n}}\\n\\n}} // namespace detail\\n}} // namespace x86\\n}} // namespace megdnn\\n'.format(**vars()))\n        for H in range(1, MAX_H + 1):\n            f.write('#undef SIMD_H{H}\\n'.format(**vars()))",
        "mutated": [
            "def gen(mode, simd, fsize):\n    if False:\n        i = 10\n    funcname = 'convolution_{mode}_fh{fsize}_{simd}'.format(**vars())\n    filename = funcname + '.cpp'\n    if simd == 'fma':\n        MAX_H = 15 - fsize\n    elif simd == 'avx' or simd == 'sse':\n        MAX_H = 14 - fsize\n    else:\n        assert False\n    if simd == 'sse':\n        width = 4\n        mm_type = '__m128'\n        mm_load = '_mm_loadu_ps'\n        mm_store = '_mm_storeu_ps'\n        mm_mul = '_mm_mul_ps'\n        mm_add = '_mm_add_ps'\n        mm_set1 = '_mm_set1_ps'\n        mm_set0 = '_mm_setzero_ps'\n        mm_max = '_mm_max_ps'\n        mm_set1_sign = ''\n        header = ['xmmintrin.h']\n    elif simd == 'avx':\n        width = 8\n        mm_type = '__m256'\n        mm_load = '_mm256_loadu_ps'\n        mm_store = '_mm256_storeu_ps'\n        mm_mul = '_mm256_mul_ps'\n        mm_add = '_mm256_add_ps'\n        mm_set1 = '_mm256_broadcast_ss'\n        mm_set0 = '_mm256_setzero_ps'\n        mm_max = '_mm256_max_ps'\n        mm_set1_sign = '&'\n        header = ['immintrin.h', 'avxintrin.h']\n    elif simd == 'fma':\n        width = 8\n        mm_type = '__m256'\n        mm_load = '_mm256_loadu_ps'\n        mm_store = '_mm256_storeu_ps'\n        mm_set1 = '_mm256_broadcast_ss'\n        mm_set0 = '_mm256_setzero_ps'\n        mm_max = '_mm256_max_ps'\n        mm_set1_sign = '&'\n        header = ['immintrin.h', 'avxintrin.h', 'fmaintrin.h']\n    with open(filename, 'w') as f:\n        for H in range(1, MAX_H + 1):\n            f.write('#define SIMD_H{H} do {{ \\\\\\nconst size_t sh = dh; \\\\\\nconst float *src_d = src + sh*src_w; \\\\\\nfloat *dst_d = dst + dh*dst_w; \\\\\\nsize_t dw = dst_w_beg; \\\\\\nfor (; dw < dst_w_end; dw += {width}) {{ \\\\\\n    const size_t sw = dw; \\\\\\n    float *dst_dd = dst_d + dw; \\\\\\n    {mm_type} tmp0; \\\\\\n'.format(**vars()))\n            if simd != 'fma':\n                f.write('    {mm_type} tmp1; \\\\\\n'.format(**vars()))\n            for h in range(H):\n                f.write('    {mm_type} res{h}; \\\\\\n    res{h} = {mm_load}(dst_dd + {h}*dst_w); \\\\\\n'.format(**vars()))\n            f.write('    for (size_t fw = 0; fw < flt_w; ++fw) {{ \\\\\\n        const float *src_dd = src_d + sw + fw; \\\\\\n'.format(**vars()))\n            for fh in range(fsize):\n                if mode == 'xcorr':\n                    f.write('        {mm_type} vf{fh} = {mm_set1}({mm_set1_sign}filter[{fh}*flt_w+fw]); \\\\\\n'.format(**vars()))\n                elif mode == 'conv':\n                    f.write('        {mm_type} vf{fh} = {mm_set1}({mm_set1_sign}filter[{fh}*flt_w+flt_w-fw-1]); \\\\\\n'.format(**vars()))\n                else:\n                    assert False\n            for ih in range(H + fsize - 1):\n                f.write('        tmp0 = {mm_load}(src_dd + {ih}*src_w); \\\\\\n'.format(**vars()))\n                for fh in range(fsize):\n                    if mode == 'xcorr':\n                        oh = ih - fh\n                    elif mode == 'conv':\n                        oh = ih - (fsize - fh - 1)\n                    else:\n                        assert False\n                    if oh >= 0 and oh < H:\n                        if simd == 'fma':\n                            f.write('        res{oh} = _mm256_fmadd_ps(tmp0, vf{fh}, res{oh}); \\\\\\n'.format(**vars()))\n                        else:\n                            f.write('        tmp1 = {mm_mul}(tmp0, vf{fh}); \\\\\\n'.format(**vars()))\n                            f.write('        res{oh} = {mm_add}(res{oh}, tmp1); \\\\\\n'.format(**vars()))\n            f.write('    }} \\\\\\n'.format(**vars()))\n            for h in range(H):\n                f.write('    {mm_store}(dst_dd + {h}*dst_w, res{h}); \\\\\\n'.format(**vars()))\n            f.write('}} \\\\\\n}} while (0)\\n'.format(**vars()))\n            f.write('\\n')\n        for i in header:\n            f.write('#include <{}>\\n'.format(i))\n        f.write('#include <algorithm>\\n\\n#include \"../convolution_direct_special_cases.h\"\\n\\nnamespace megdnn {{\\nnamespace x86 {{\\nnamespace detail {{\\n\\nvoid {funcname}(const float *src, const float *filter, float *dst,\\n        const size_t src_h, const size_t src_w, const size_t dst_h, const size_t dst_w,\\n        const size_t flt_w)\\n{{\\n    (void)src_h;\\n    const size_t dst_h_beg = 0;\\n    const size_t dst_h_end = dst_h;\\n    const size_t dst_w_beg = 0;\\n    const size_t dst_w_end = dst_w;\\n'.format(**vars()))\n        f.write('\\n    size_t dh = dst_h_beg;\\n    for (; dh + {MAX_H} <= dst_h_end; dh += {MAX_H}) {{\\n        SIMD_H{MAX_H};\\n    }}\\n    switch (dst_h_end - dh) {{\\n'.format(**vars()))\n        for H in range(1, MAX_H):\n            f.write('        case {H}:\\n            SIMD_H{H};\\n            break;\\n'.format(**vars()))\n        f.write('    }}\\n}}\\n\\n}} // namespace detail\\n}} // namespace x86\\n}} // namespace megdnn\\n'.format(**vars()))\n        for H in range(1, MAX_H + 1):\n            f.write('#undef SIMD_H{H}\\n'.format(**vars()))",
            "def gen(mode, simd, fsize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    funcname = 'convolution_{mode}_fh{fsize}_{simd}'.format(**vars())\n    filename = funcname + '.cpp'\n    if simd == 'fma':\n        MAX_H = 15 - fsize\n    elif simd == 'avx' or simd == 'sse':\n        MAX_H = 14 - fsize\n    else:\n        assert False\n    if simd == 'sse':\n        width = 4\n        mm_type = '__m128'\n        mm_load = '_mm_loadu_ps'\n        mm_store = '_mm_storeu_ps'\n        mm_mul = '_mm_mul_ps'\n        mm_add = '_mm_add_ps'\n        mm_set1 = '_mm_set1_ps'\n        mm_set0 = '_mm_setzero_ps'\n        mm_max = '_mm_max_ps'\n        mm_set1_sign = ''\n        header = ['xmmintrin.h']\n    elif simd == 'avx':\n        width = 8\n        mm_type = '__m256'\n        mm_load = '_mm256_loadu_ps'\n        mm_store = '_mm256_storeu_ps'\n        mm_mul = '_mm256_mul_ps'\n        mm_add = '_mm256_add_ps'\n        mm_set1 = '_mm256_broadcast_ss'\n        mm_set0 = '_mm256_setzero_ps'\n        mm_max = '_mm256_max_ps'\n        mm_set1_sign = '&'\n        header = ['immintrin.h', 'avxintrin.h']\n    elif simd == 'fma':\n        width = 8\n        mm_type = '__m256'\n        mm_load = '_mm256_loadu_ps'\n        mm_store = '_mm256_storeu_ps'\n        mm_set1 = '_mm256_broadcast_ss'\n        mm_set0 = '_mm256_setzero_ps'\n        mm_max = '_mm256_max_ps'\n        mm_set1_sign = '&'\n        header = ['immintrin.h', 'avxintrin.h', 'fmaintrin.h']\n    with open(filename, 'w') as f:\n        for H in range(1, MAX_H + 1):\n            f.write('#define SIMD_H{H} do {{ \\\\\\nconst size_t sh = dh; \\\\\\nconst float *src_d = src + sh*src_w; \\\\\\nfloat *dst_d = dst + dh*dst_w; \\\\\\nsize_t dw = dst_w_beg; \\\\\\nfor (; dw < dst_w_end; dw += {width}) {{ \\\\\\n    const size_t sw = dw; \\\\\\n    float *dst_dd = dst_d + dw; \\\\\\n    {mm_type} tmp0; \\\\\\n'.format(**vars()))\n            if simd != 'fma':\n                f.write('    {mm_type} tmp1; \\\\\\n'.format(**vars()))\n            for h in range(H):\n                f.write('    {mm_type} res{h}; \\\\\\n    res{h} = {mm_load}(dst_dd + {h}*dst_w); \\\\\\n'.format(**vars()))\n            f.write('    for (size_t fw = 0; fw < flt_w; ++fw) {{ \\\\\\n        const float *src_dd = src_d + sw + fw; \\\\\\n'.format(**vars()))\n            for fh in range(fsize):\n                if mode == 'xcorr':\n                    f.write('        {mm_type} vf{fh} = {mm_set1}({mm_set1_sign}filter[{fh}*flt_w+fw]); \\\\\\n'.format(**vars()))\n                elif mode == 'conv':\n                    f.write('        {mm_type} vf{fh} = {mm_set1}({mm_set1_sign}filter[{fh}*flt_w+flt_w-fw-1]); \\\\\\n'.format(**vars()))\n                else:\n                    assert False\n            for ih in range(H + fsize - 1):\n                f.write('        tmp0 = {mm_load}(src_dd + {ih}*src_w); \\\\\\n'.format(**vars()))\n                for fh in range(fsize):\n                    if mode == 'xcorr':\n                        oh = ih - fh\n                    elif mode == 'conv':\n                        oh = ih - (fsize - fh - 1)\n                    else:\n                        assert False\n                    if oh >= 0 and oh < H:\n                        if simd == 'fma':\n                            f.write('        res{oh} = _mm256_fmadd_ps(tmp0, vf{fh}, res{oh}); \\\\\\n'.format(**vars()))\n                        else:\n                            f.write('        tmp1 = {mm_mul}(tmp0, vf{fh}); \\\\\\n'.format(**vars()))\n                            f.write('        res{oh} = {mm_add}(res{oh}, tmp1); \\\\\\n'.format(**vars()))\n            f.write('    }} \\\\\\n'.format(**vars()))\n            for h in range(H):\n                f.write('    {mm_store}(dst_dd + {h}*dst_w, res{h}); \\\\\\n'.format(**vars()))\n            f.write('}} \\\\\\n}} while (0)\\n'.format(**vars()))\n            f.write('\\n')\n        for i in header:\n            f.write('#include <{}>\\n'.format(i))\n        f.write('#include <algorithm>\\n\\n#include \"../convolution_direct_special_cases.h\"\\n\\nnamespace megdnn {{\\nnamespace x86 {{\\nnamespace detail {{\\n\\nvoid {funcname}(const float *src, const float *filter, float *dst,\\n        const size_t src_h, const size_t src_w, const size_t dst_h, const size_t dst_w,\\n        const size_t flt_w)\\n{{\\n    (void)src_h;\\n    const size_t dst_h_beg = 0;\\n    const size_t dst_h_end = dst_h;\\n    const size_t dst_w_beg = 0;\\n    const size_t dst_w_end = dst_w;\\n'.format(**vars()))\n        f.write('\\n    size_t dh = dst_h_beg;\\n    for (; dh + {MAX_H} <= dst_h_end; dh += {MAX_H}) {{\\n        SIMD_H{MAX_H};\\n    }}\\n    switch (dst_h_end - dh) {{\\n'.format(**vars()))\n        for H in range(1, MAX_H):\n            f.write('        case {H}:\\n            SIMD_H{H};\\n            break;\\n'.format(**vars()))\n        f.write('    }}\\n}}\\n\\n}} // namespace detail\\n}} // namespace x86\\n}} // namespace megdnn\\n'.format(**vars()))\n        for H in range(1, MAX_H + 1):\n            f.write('#undef SIMD_H{H}\\n'.format(**vars()))",
            "def gen(mode, simd, fsize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    funcname = 'convolution_{mode}_fh{fsize}_{simd}'.format(**vars())\n    filename = funcname + '.cpp'\n    if simd == 'fma':\n        MAX_H = 15 - fsize\n    elif simd == 'avx' or simd == 'sse':\n        MAX_H = 14 - fsize\n    else:\n        assert False\n    if simd == 'sse':\n        width = 4\n        mm_type = '__m128'\n        mm_load = '_mm_loadu_ps'\n        mm_store = '_mm_storeu_ps'\n        mm_mul = '_mm_mul_ps'\n        mm_add = '_mm_add_ps'\n        mm_set1 = '_mm_set1_ps'\n        mm_set0 = '_mm_setzero_ps'\n        mm_max = '_mm_max_ps'\n        mm_set1_sign = ''\n        header = ['xmmintrin.h']\n    elif simd == 'avx':\n        width = 8\n        mm_type = '__m256'\n        mm_load = '_mm256_loadu_ps'\n        mm_store = '_mm256_storeu_ps'\n        mm_mul = '_mm256_mul_ps'\n        mm_add = '_mm256_add_ps'\n        mm_set1 = '_mm256_broadcast_ss'\n        mm_set0 = '_mm256_setzero_ps'\n        mm_max = '_mm256_max_ps'\n        mm_set1_sign = '&'\n        header = ['immintrin.h', 'avxintrin.h']\n    elif simd == 'fma':\n        width = 8\n        mm_type = '__m256'\n        mm_load = '_mm256_loadu_ps'\n        mm_store = '_mm256_storeu_ps'\n        mm_set1 = '_mm256_broadcast_ss'\n        mm_set0 = '_mm256_setzero_ps'\n        mm_max = '_mm256_max_ps'\n        mm_set1_sign = '&'\n        header = ['immintrin.h', 'avxintrin.h', 'fmaintrin.h']\n    with open(filename, 'w') as f:\n        for H in range(1, MAX_H + 1):\n            f.write('#define SIMD_H{H} do {{ \\\\\\nconst size_t sh = dh; \\\\\\nconst float *src_d = src + sh*src_w; \\\\\\nfloat *dst_d = dst + dh*dst_w; \\\\\\nsize_t dw = dst_w_beg; \\\\\\nfor (; dw < dst_w_end; dw += {width}) {{ \\\\\\n    const size_t sw = dw; \\\\\\n    float *dst_dd = dst_d + dw; \\\\\\n    {mm_type} tmp0; \\\\\\n'.format(**vars()))\n            if simd != 'fma':\n                f.write('    {mm_type} tmp1; \\\\\\n'.format(**vars()))\n            for h in range(H):\n                f.write('    {mm_type} res{h}; \\\\\\n    res{h} = {mm_load}(dst_dd + {h}*dst_w); \\\\\\n'.format(**vars()))\n            f.write('    for (size_t fw = 0; fw < flt_w; ++fw) {{ \\\\\\n        const float *src_dd = src_d + sw + fw; \\\\\\n'.format(**vars()))\n            for fh in range(fsize):\n                if mode == 'xcorr':\n                    f.write('        {mm_type} vf{fh} = {mm_set1}({mm_set1_sign}filter[{fh}*flt_w+fw]); \\\\\\n'.format(**vars()))\n                elif mode == 'conv':\n                    f.write('        {mm_type} vf{fh} = {mm_set1}({mm_set1_sign}filter[{fh}*flt_w+flt_w-fw-1]); \\\\\\n'.format(**vars()))\n                else:\n                    assert False\n            for ih in range(H + fsize - 1):\n                f.write('        tmp0 = {mm_load}(src_dd + {ih}*src_w); \\\\\\n'.format(**vars()))\n                for fh in range(fsize):\n                    if mode == 'xcorr':\n                        oh = ih - fh\n                    elif mode == 'conv':\n                        oh = ih - (fsize - fh - 1)\n                    else:\n                        assert False\n                    if oh >= 0 and oh < H:\n                        if simd == 'fma':\n                            f.write('        res{oh} = _mm256_fmadd_ps(tmp0, vf{fh}, res{oh}); \\\\\\n'.format(**vars()))\n                        else:\n                            f.write('        tmp1 = {mm_mul}(tmp0, vf{fh}); \\\\\\n'.format(**vars()))\n                            f.write('        res{oh} = {mm_add}(res{oh}, tmp1); \\\\\\n'.format(**vars()))\n            f.write('    }} \\\\\\n'.format(**vars()))\n            for h in range(H):\n                f.write('    {mm_store}(dst_dd + {h}*dst_w, res{h}); \\\\\\n'.format(**vars()))\n            f.write('}} \\\\\\n}} while (0)\\n'.format(**vars()))\n            f.write('\\n')\n        for i in header:\n            f.write('#include <{}>\\n'.format(i))\n        f.write('#include <algorithm>\\n\\n#include \"../convolution_direct_special_cases.h\"\\n\\nnamespace megdnn {{\\nnamespace x86 {{\\nnamespace detail {{\\n\\nvoid {funcname}(const float *src, const float *filter, float *dst,\\n        const size_t src_h, const size_t src_w, const size_t dst_h, const size_t dst_w,\\n        const size_t flt_w)\\n{{\\n    (void)src_h;\\n    const size_t dst_h_beg = 0;\\n    const size_t dst_h_end = dst_h;\\n    const size_t dst_w_beg = 0;\\n    const size_t dst_w_end = dst_w;\\n'.format(**vars()))\n        f.write('\\n    size_t dh = dst_h_beg;\\n    for (; dh + {MAX_H} <= dst_h_end; dh += {MAX_H}) {{\\n        SIMD_H{MAX_H};\\n    }}\\n    switch (dst_h_end - dh) {{\\n'.format(**vars()))\n        for H in range(1, MAX_H):\n            f.write('        case {H}:\\n            SIMD_H{H};\\n            break;\\n'.format(**vars()))\n        f.write('    }}\\n}}\\n\\n}} // namespace detail\\n}} // namespace x86\\n}} // namespace megdnn\\n'.format(**vars()))\n        for H in range(1, MAX_H + 1):\n            f.write('#undef SIMD_H{H}\\n'.format(**vars()))",
            "def gen(mode, simd, fsize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    funcname = 'convolution_{mode}_fh{fsize}_{simd}'.format(**vars())\n    filename = funcname + '.cpp'\n    if simd == 'fma':\n        MAX_H = 15 - fsize\n    elif simd == 'avx' or simd == 'sse':\n        MAX_H = 14 - fsize\n    else:\n        assert False\n    if simd == 'sse':\n        width = 4\n        mm_type = '__m128'\n        mm_load = '_mm_loadu_ps'\n        mm_store = '_mm_storeu_ps'\n        mm_mul = '_mm_mul_ps'\n        mm_add = '_mm_add_ps'\n        mm_set1 = '_mm_set1_ps'\n        mm_set0 = '_mm_setzero_ps'\n        mm_max = '_mm_max_ps'\n        mm_set1_sign = ''\n        header = ['xmmintrin.h']\n    elif simd == 'avx':\n        width = 8\n        mm_type = '__m256'\n        mm_load = '_mm256_loadu_ps'\n        mm_store = '_mm256_storeu_ps'\n        mm_mul = '_mm256_mul_ps'\n        mm_add = '_mm256_add_ps'\n        mm_set1 = '_mm256_broadcast_ss'\n        mm_set0 = '_mm256_setzero_ps'\n        mm_max = '_mm256_max_ps'\n        mm_set1_sign = '&'\n        header = ['immintrin.h', 'avxintrin.h']\n    elif simd == 'fma':\n        width = 8\n        mm_type = '__m256'\n        mm_load = '_mm256_loadu_ps'\n        mm_store = '_mm256_storeu_ps'\n        mm_set1 = '_mm256_broadcast_ss'\n        mm_set0 = '_mm256_setzero_ps'\n        mm_max = '_mm256_max_ps'\n        mm_set1_sign = '&'\n        header = ['immintrin.h', 'avxintrin.h', 'fmaintrin.h']\n    with open(filename, 'w') as f:\n        for H in range(1, MAX_H + 1):\n            f.write('#define SIMD_H{H} do {{ \\\\\\nconst size_t sh = dh; \\\\\\nconst float *src_d = src + sh*src_w; \\\\\\nfloat *dst_d = dst + dh*dst_w; \\\\\\nsize_t dw = dst_w_beg; \\\\\\nfor (; dw < dst_w_end; dw += {width}) {{ \\\\\\n    const size_t sw = dw; \\\\\\n    float *dst_dd = dst_d + dw; \\\\\\n    {mm_type} tmp0; \\\\\\n'.format(**vars()))\n            if simd != 'fma':\n                f.write('    {mm_type} tmp1; \\\\\\n'.format(**vars()))\n            for h in range(H):\n                f.write('    {mm_type} res{h}; \\\\\\n    res{h} = {mm_load}(dst_dd + {h}*dst_w); \\\\\\n'.format(**vars()))\n            f.write('    for (size_t fw = 0; fw < flt_w; ++fw) {{ \\\\\\n        const float *src_dd = src_d + sw + fw; \\\\\\n'.format(**vars()))\n            for fh in range(fsize):\n                if mode == 'xcorr':\n                    f.write('        {mm_type} vf{fh} = {mm_set1}({mm_set1_sign}filter[{fh}*flt_w+fw]); \\\\\\n'.format(**vars()))\n                elif mode == 'conv':\n                    f.write('        {mm_type} vf{fh} = {mm_set1}({mm_set1_sign}filter[{fh}*flt_w+flt_w-fw-1]); \\\\\\n'.format(**vars()))\n                else:\n                    assert False\n            for ih in range(H + fsize - 1):\n                f.write('        tmp0 = {mm_load}(src_dd + {ih}*src_w); \\\\\\n'.format(**vars()))\n                for fh in range(fsize):\n                    if mode == 'xcorr':\n                        oh = ih - fh\n                    elif mode == 'conv':\n                        oh = ih - (fsize - fh - 1)\n                    else:\n                        assert False\n                    if oh >= 0 and oh < H:\n                        if simd == 'fma':\n                            f.write('        res{oh} = _mm256_fmadd_ps(tmp0, vf{fh}, res{oh}); \\\\\\n'.format(**vars()))\n                        else:\n                            f.write('        tmp1 = {mm_mul}(tmp0, vf{fh}); \\\\\\n'.format(**vars()))\n                            f.write('        res{oh} = {mm_add}(res{oh}, tmp1); \\\\\\n'.format(**vars()))\n            f.write('    }} \\\\\\n'.format(**vars()))\n            for h in range(H):\n                f.write('    {mm_store}(dst_dd + {h}*dst_w, res{h}); \\\\\\n'.format(**vars()))\n            f.write('}} \\\\\\n}} while (0)\\n'.format(**vars()))\n            f.write('\\n')\n        for i in header:\n            f.write('#include <{}>\\n'.format(i))\n        f.write('#include <algorithm>\\n\\n#include \"../convolution_direct_special_cases.h\"\\n\\nnamespace megdnn {{\\nnamespace x86 {{\\nnamespace detail {{\\n\\nvoid {funcname}(const float *src, const float *filter, float *dst,\\n        const size_t src_h, const size_t src_w, const size_t dst_h, const size_t dst_w,\\n        const size_t flt_w)\\n{{\\n    (void)src_h;\\n    const size_t dst_h_beg = 0;\\n    const size_t dst_h_end = dst_h;\\n    const size_t dst_w_beg = 0;\\n    const size_t dst_w_end = dst_w;\\n'.format(**vars()))\n        f.write('\\n    size_t dh = dst_h_beg;\\n    for (; dh + {MAX_H} <= dst_h_end; dh += {MAX_H}) {{\\n        SIMD_H{MAX_H};\\n    }}\\n    switch (dst_h_end - dh) {{\\n'.format(**vars()))\n        for H in range(1, MAX_H):\n            f.write('        case {H}:\\n            SIMD_H{H};\\n            break;\\n'.format(**vars()))\n        f.write('    }}\\n}}\\n\\n}} // namespace detail\\n}} // namespace x86\\n}} // namespace megdnn\\n'.format(**vars()))\n        for H in range(1, MAX_H + 1):\n            f.write('#undef SIMD_H{H}\\n'.format(**vars()))",
            "def gen(mode, simd, fsize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    funcname = 'convolution_{mode}_fh{fsize}_{simd}'.format(**vars())\n    filename = funcname + '.cpp'\n    if simd == 'fma':\n        MAX_H = 15 - fsize\n    elif simd == 'avx' or simd == 'sse':\n        MAX_H = 14 - fsize\n    else:\n        assert False\n    if simd == 'sse':\n        width = 4\n        mm_type = '__m128'\n        mm_load = '_mm_loadu_ps'\n        mm_store = '_mm_storeu_ps'\n        mm_mul = '_mm_mul_ps'\n        mm_add = '_mm_add_ps'\n        mm_set1 = '_mm_set1_ps'\n        mm_set0 = '_mm_setzero_ps'\n        mm_max = '_mm_max_ps'\n        mm_set1_sign = ''\n        header = ['xmmintrin.h']\n    elif simd == 'avx':\n        width = 8\n        mm_type = '__m256'\n        mm_load = '_mm256_loadu_ps'\n        mm_store = '_mm256_storeu_ps'\n        mm_mul = '_mm256_mul_ps'\n        mm_add = '_mm256_add_ps'\n        mm_set1 = '_mm256_broadcast_ss'\n        mm_set0 = '_mm256_setzero_ps'\n        mm_max = '_mm256_max_ps'\n        mm_set1_sign = '&'\n        header = ['immintrin.h', 'avxintrin.h']\n    elif simd == 'fma':\n        width = 8\n        mm_type = '__m256'\n        mm_load = '_mm256_loadu_ps'\n        mm_store = '_mm256_storeu_ps'\n        mm_set1 = '_mm256_broadcast_ss'\n        mm_set0 = '_mm256_setzero_ps'\n        mm_max = '_mm256_max_ps'\n        mm_set1_sign = '&'\n        header = ['immintrin.h', 'avxintrin.h', 'fmaintrin.h']\n    with open(filename, 'w') as f:\n        for H in range(1, MAX_H + 1):\n            f.write('#define SIMD_H{H} do {{ \\\\\\nconst size_t sh = dh; \\\\\\nconst float *src_d = src + sh*src_w; \\\\\\nfloat *dst_d = dst + dh*dst_w; \\\\\\nsize_t dw = dst_w_beg; \\\\\\nfor (; dw < dst_w_end; dw += {width}) {{ \\\\\\n    const size_t sw = dw; \\\\\\n    float *dst_dd = dst_d + dw; \\\\\\n    {mm_type} tmp0; \\\\\\n'.format(**vars()))\n            if simd != 'fma':\n                f.write('    {mm_type} tmp1; \\\\\\n'.format(**vars()))\n            for h in range(H):\n                f.write('    {mm_type} res{h}; \\\\\\n    res{h} = {mm_load}(dst_dd + {h}*dst_w); \\\\\\n'.format(**vars()))\n            f.write('    for (size_t fw = 0; fw < flt_w; ++fw) {{ \\\\\\n        const float *src_dd = src_d + sw + fw; \\\\\\n'.format(**vars()))\n            for fh in range(fsize):\n                if mode == 'xcorr':\n                    f.write('        {mm_type} vf{fh} = {mm_set1}({mm_set1_sign}filter[{fh}*flt_w+fw]); \\\\\\n'.format(**vars()))\n                elif mode == 'conv':\n                    f.write('        {mm_type} vf{fh} = {mm_set1}({mm_set1_sign}filter[{fh}*flt_w+flt_w-fw-1]); \\\\\\n'.format(**vars()))\n                else:\n                    assert False\n            for ih in range(H + fsize - 1):\n                f.write('        tmp0 = {mm_load}(src_dd + {ih}*src_w); \\\\\\n'.format(**vars()))\n                for fh in range(fsize):\n                    if mode == 'xcorr':\n                        oh = ih - fh\n                    elif mode == 'conv':\n                        oh = ih - (fsize - fh - 1)\n                    else:\n                        assert False\n                    if oh >= 0 and oh < H:\n                        if simd == 'fma':\n                            f.write('        res{oh} = _mm256_fmadd_ps(tmp0, vf{fh}, res{oh}); \\\\\\n'.format(**vars()))\n                        else:\n                            f.write('        tmp1 = {mm_mul}(tmp0, vf{fh}); \\\\\\n'.format(**vars()))\n                            f.write('        res{oh} = {mm_add}(res{oh}, tmp1); \\\\\\n'.format(**vars()))\n            f.write('    }} \\\\\\n'.format(**vars()))\n            for h in range(H):\n                f.write('    {mm_store}(dst_dd + {h}*dst_w, res{h}); \\\\\\n'.format(**vars()))\n            f.write('}} \\\\\\n}} while (0)\\n'.format(**vars()))\n            f.write('\\n')\n        for i in header:\n            f.write('#include <{}>\\n'.format(i))\n        f.write('#include <algorithm>\\n\\n#include \"../convolution_direct_special_cases.h\"\\n\\nnamespace megdnn {{\\nnamespace x86 {{\\nnamespace detail {{\\n\\nvoid {funcname}(const float *src, const float *filter, float *dst,\\n        const size_t src_h, const size_t src_w, const size_t dst_h, const size_t dst_w,\\n        const size_t flt_w)\\n{{\\n    (void)src_h;\\n    const size_t dst_h_beg = 0;\\n    const size_t dst_h_end = dst_h;\\n    const size_t dst_w_beg = 0;\\n    const size_t dst_w_end = dst_w;\\n'.format(**vars()))\n        f.write('\\n    size_t dh = dst_h_beg;\\n    for (; dh + {MAX_H} <= dst_h_end; dh += {MAX_H}) {{\\n        SIMD_H{MAX_H};\\n    }}\\n    switch (dst_h_end - dh) {{\\n'.format(**vars()))\n        for H in range(1, MAX_H):\n            f.write('        case {H}:\\n            SIMD_H{H};\\n            break;\\n'.format(**vars()))\n        f.write('    }}\\n}}\\n\\n}} // namespace detail\\n}} // namespace x86\\n}} // namespace megdnn\\n'.format(**vars()))\n        for H in range(1, MAX_H + 1):\n            f.write('#undef SIMD_H{H}\\n'.format(**vars()))"
        ]
    },
    {
        "func_name": "gen_header",
        "original": "def gen_header(modes, simds, fsizes):\n    with open('convolution_direct_special_cases.h', 'w') as f:\n        f.write('#pragma once\\n\\n#include <cstddef>\\n#include \"megdnn/arch.h\"\\n\\nnamespace megdnn {\\nnamespace x86 {\\nnamespace detail {\\n')\n        for (mode, simd, fsize) in itertools.product(modes, simds, fsizes):\n            funcname = 'convolution_{mode}_fh{fsize}_{simd}'.format(**vars())\n            f.write('\\nvoid {funcname}(const float *src, const float *filter, float *dst,\\n        const size_t src_h, const size_t src_w, const size_t dst_h, const size_t dst_w,\\n        const size_t flt_w) MEGDNN_ATTRIBUTE_TARGET(\"{simd}\");\\n'.format(**vars()))\n        f.write('} // namespace detail\\n} // namespace x86\\n} // namespace megdnn\\n')",
        "mutated": [
            "def gen_header(modes, simds, fsizes):\n    if False:\n        i = 10\n    with open('convolution_direct_special_cases.h', 'w') as f:\n        f.write('#pragma once\\n\\n#include <cstddef>\\n#include \"megdnn/arch.h\"\\n\\nnamespace megdnn {\\nnamespace x86 {\\nnamespace detail {\\n')\n        for (mode, simd, fsize) in itertools.product(modes, simds, fsizes):\n            funcname = 'convolution_{mode}_fh{fsize}_{simd}'.format(**vars())\n            f.write('\\nvoid {funcname}(const float *src, const float *filter, float *dst,\\n        const size_t src_h, const size_t src_w, const size_t dst_h, const size_t dst_w,\\n        const size_t flt_w) MEGDNN_ATTRIBUTE_TARGET(\"{simd}\");\\n'.format(**vars()))\n        f.write('} // namespace detail\\n} // namespace x86\\n} // namespace megdnn\\n')",
            "def gen_header(modes, simds, fsizes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with open('convolution_direct_special_cases.h', 'w') as f:\n        f.write('#pragma once\\n\\n#include <cstddef>\\n#include \"megdnn/arch.h\"\\n\\nnamespace megdnn {\\nnamespace x86 {\\nnamespace detail {\\n')\n        for (mode, simd, fsize) in itertools.product(modes, simds, fsizes):\n            funcname = 'convolution_{mode}_fh{fsize}_{simd}'.format(**vars())\n            f.write('\\nvoid {funcname}(const float *src, const float *filter, float *dst,\\n        const size_t src_h, const size_t src_w, const size_t dst_h, const size_t dst_w,\\n        const size_t flt_w) MEGDNN_ATTRIBUTE_TARGET(\"{simd}\");\\n'.format(**vars()))\n        f.write('} // namespace detail\\n} // namespace x86\\n} // namespace megdnn\\n')",
            "def gen_header(modes, simds, fsizes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with open('convolution_direct_special_cases.h', 'w') as f:\n        f.write('#pragma once\\n\\n#include <cstddef>\\n#include \"megdnn/arch.h\"\\n\\nnamespace megdnn {\\nnamespace x86 {\\nnamespace detail {\\n')\n        for (mode, simd, fsize) in itertools.product(modes, simds, fsizes):\n            funcname = 'convolution_{mode}_fh{fsize}_{simd}'.format(**vars())\n            f.write('\\nvoid {funcname}(const float *src, const float *filter, float *dst,\\n        const size_t src_h, const size_t src_w, const size_t dst_h, const size_t dst_w,\\n        const size_t flt_w) MEGDNN_ATTRIBUTE_TARGET(\"{simd}\");\\n'.format(**vars()))\n        f.write('} // namespace detail\\n} // namespace x86\\n} // namespace megdnn\\n')",
            "def gen_header(modes, simds, fsizes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with open('convolution_direct_special_cases.h', 'w') as f:\n        f.write('#pragma once\\n\\n#include <cstddef>\\n#include \"megdnn/arch.h\"\\n\\nnamespace megdnn {\\nnamespace x86 {\\nnamespace detail {\\n')\n        for (mode, simd, fsize) in itertools.product(modes, simds, fsizes):\n            funcname = 'convolution_{mode}_fh{fsize}_{simd}'.format(**vars())\n            f.write('\\nvoid {funcname}(const float *src, const float *filter, float *dst,\\n        const size_t src_h, const size_t src_w, const size_t dst_h, const size_t dst_w,\\n        const size_t flt_w) MEGDNN_ATTRIBUTE_TARGET(\"{simd}\");\\n'.format(**vars()))\n        f.write('} // namespace detail\\n} // namespace x86\\n} // namespace megdnn\\n')",
            "def gen_header(modes, simds, fsizes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with open('convolution_direct_special_cases.h', 'w') as f:\n        f.write('#pragma once\\n\\n#include <cstddef>\\n#include \"megdnn/arch.h\"\\n\\nnamespace megdnn {\\nnamespace x86 {\\nnamespace detail {\\n')\n        for (mode, simd, fsize) in itertools.product(modes, simds, fsizes):\n            funcname = 'convolution_{mode}_fh{fsize}_{simd}'.format(**vars())\n            f.write('\\nvoid {funcname}(const float *src, const float *filter, float *dst,\\n        const size_t src_h, const size_t src_w, const size_t dst_h, const size_t dst_w,\\n        const size_t flt_w) MEGDNN_ATTRIBUTE_TARGET(\"{simd}\");\\n'.format(**vars()))\n        f.write('} // namespace detail\\n} // namespace x86\\n} // namespace megdnn\\n')"
        ]
    }
]