"""SCADIO: write OpenSCAD program to create protein structure 3D model.

3D printing a protein structure is a non-trivial exercise due to the
overall complexity and the general requirement for supporting overhang regions
while printing.  This software is a path to generating a model for printing
(e.g. an STL file), and does not address the issues around converting the
model to a physical product.  OpenSCAD <http://www.openscad.org/> can create
a printable model from the script this software produces.  MeshMixer
<http://www.meshmixer.com/>, various slicer software, and the 3D printer
technology available to you provide options for addressing the problems around
physically rendering the model.

The model generated here consists of OpenSCAD primitives, e.g. spheres and
cylinders, representing individual atoms and bonds in an explicit model of a
protein structure.  The benefit is that individual atoms/bonds may be selected
for specific print customizations relevant to 3D printing (such as rotatable
bond mechanisms or hydrogen bond magnets).  Alternatively, use e.g. Chimera to
render a structure as ribbons or similar for printing as a single object.

I suggest generating your initial model using the OpenSCAD script provided
here, then modifying that script according to your needs.  Changing the
atomScale and bondRadius values can simplify the model by removing gaps and
the corresponding need for supports, or you may wish to modify the
hedronDispatch() routine to select residues or chain sections for printing
separately and subsequently joining with rotatable bonds.  During this
development phase you will likely have your version include only the data
matrices generated here, by using the `includeCode=False` option to
write_SCAD().  An example project using rotatable backbone and magnetic
hydrogen bonds is at <https://www.thingiverse.com/thing:3957471>.
"""
from Bio.File import as_handle
from Bio.PDB.PDBExceptions import PDBException
from Bio.PDB.internal_coords import IC_Residue, IC_Chain
from Bio.PDB.vectors import homog_scale_mtx
import numpy as np

def _scale_residue(res, scale, scaleMtx):
    if False:
        i = 10
        return i + 15
    if res.internal_coord:
        res.internal_coord.applyMtx(scaleMtx)
        if res.internal_coord.gly_Cbeta:
            res.internal_coord.scale = scale

def write_SCAD(entity, file, scale=None, pdbid=None, backboneOnly=False, includeCode=True, maxPeptideBond=None, start=None, fin=None, handle='protein'):
    if False:
        print('Hello World!')
    "Write hedron assembly to file as OpenSCAD matrices.\n\n    This routine calls both :meth:`.IC_Chain.internal_to_atom_coordinates` and\n    :meth:`.IC_Chain.atom_to_internal_coordinates` due to requirements for\n    scaling, explicit bonds around rings, and setting the coordinate space of\n    the output model.\n\n    Output data format is primarily:\n\n    - matrix for each hedron:\n        len1, angle2, len3, atom covalent bond class, flags to indicate\n        atom/bond represented in previous hedron (OpenSCAD very slow with\n        redundant overlapping elements), flags for bond features\n    - transform matrices to assemble each hedron into residue dihedra sets\n    - transform matrices for each residue to position in chain\n\n    OpenSCAD software is included in this Python file to process these\n    matrices into a model suitable for a 3D printing project.\n\n    :param entity: Biopython PDB :class:`.Structure` entity\n        structure data to export\n    :param file: Bipoython :func:`.as_handle` filename or open file pointer\n        file to write data to\n    :param float scale:\n        units (usually mm) per angstrom for STL output, written in output\n    :param str pdbid:\n        PDB idcode, written in output. Defaults to '0PDB' if not supplied\n        and no 'idcode' set in entity\n    :param bool backboneOnly: default False.\n        Do not output side chain data past Cbeta if True\n    :param bool includeCode: default True.\n        Include OpenSCAD software (inline below) so output file can be loaded\n        into OpenSCAD; if False, output data matrices only\n    :param float maxPeptideBond: Optional default None.\n        Override the cut-off in IC_Chain class (default 1.4) for detecting\n        chain breaks.  If your target has chain breaks, pass a large number\n        here to create a very long 'bond' spanning the break.\n    :param int start,fin: default None\n        Parameters for internal_to_atom_coords() to limit chain segment.\n    :param str handle: default 'protein'\n        name for top level of generated OpenSCAD matrix structure\n\n    See :meth:`.IC_Residue.set_flexible` to set flags for specific residues to\n    have rotatable bonds, and :meth:`.IC_Residue.set_hbond` to include cavities\n    for small magnets to work as hydrogen bonds.\n    See <https://www.thingiverse.com/thing:3957471> for implementation example.\n\n    The OpenSCAD code explicitly creates spheres and cylinders to\n    represent atoms and bonds in a 3D model.  Options are available\n    to support rotatable bonds and magnetic hydrogen bonds.\n\n    Matrices are written to link, enumerate and describe residues,\n    dihedra, hedra, and chains, mirroring contents of the relevant IC_*\n    data structures.\n\n    The OpenSCAD matrix of hedra has additional information as follows:\n\n    * the atom and bond state (single, double, resonance) are logged\n        so that covalent radii may be used for atom spheres in the 3D models\n\n    * bonds and atoms are tracked so that each is only created once\n\n    * bond options for rotation and magnet holders for hydrogen bonds\n        may be specified (see :meth:`.IC_Residue.set_flexible` and\n        :meth:`.IC_Residue.set_hbond` )\n\n    Note the application of :data:`Bio.PDB.internal_coords.IC_Chain.MaxPeptideBond`\n    :  missing residues may be linked (joining chain segments with arbitrarily\n    long bonds) by setting this to a large value.\n\n    Note this uses the serial assembly per residue, placing each residue at\n    the origin and supplying the coordinate space transform to OpenaSCAD\n\n    All ALTLOC (disordered) residues and atoms are written to the output\n    model.  (see :data:`Bio.PDB.internal_coords.IC_Residue.no_altloc`)\n    "
    if maxPeptideBond is not None:
        mpbStash = IC_Chain.MaxPeptideBond
        IC_Chain.MaxPeptideBond = float(maxPeptideBond)
    added_IC_Atoms = False
    if 'S' == entity.level or 'M' == entity.level:
        for chn in entity.get_chains():
            if not chn.internal_coord:
                chn.internal_coord = IC_Chain(chn)
                added_IC_Atoms = True
    elif 'C' == entity.level:
        if not entity.internal_coord:
            entity.internal_coord = IC_Chain(entity)
            added_IC_Atoms = True
    else:
        raise PDBException('level not S, M or C: ' + str(entity.level))
    if added_IC_Atoms:
        entity.atom_to_internal_coordinates()
    else:
        entity.internal_to_atom_coordinates(None)
    if scale is not None:
        scaleMtx = homog_scale_mtx(scale)
        if 'C' == entity.level:
            entity.internal_coord.atomArray = np.dot(entity.internal_coord.atomArray[:], scaleMtx)
            entity.internal_coord.hAtoms_needs_update[:] = True
            entity.internal_coord.scale = scale
        else:
            for chn in entity.get_chains():
                if hasattr(chn.internal_coord, 'atomArray'):
                    chn.internal_coord.atomArray = np.dot(chn.internal_coord.atomArray[:], scaleMtx)
                    chn.internal_coord.hAtoms_needs_update[:] = True
                    chn.internal_coord.scale = scale
    allBondsStash = IC_Residue._AllBonds
    IC_Residue._AllBonds = True
    if 'C' == entity.level:
        entity.internal_coord.ordered_aa_ic_list[0].hedra = {}
        delattr(entity.internal_coord, 'hAtoms_needs_update')
        delattr(entity.internal_coord, 'hedraLen')
    else:
        for chn in entity.get_chains():
            chn.internal_coord.ordered_aa_ic_list[0].hedra = {}
            delattr(chn.internal_coord, 'hAtoms_needs_update')
            delattr(chn.internal_coord, 'hedraLen')
    entity.atom_to_internal_coordinates()
    IC_Residue._AllBonds = allBondsStash
    entity.internal_to_atom_coordinates()
    with as_handle(file, 'w') as fp:
        if includeCode:
            fp.write(peptide_scad)
        if not pdbid and hasattr(entity, 'header'):
            pdbid = entity.header.get('idcode', None)
        if pdbid is None or '' == pdbid:
            pdbid = '0PDB'
        fp.write('protein = [ "' + pdbid + '", ' + str(scale) + ',  // ID, protein_scale\n')
        if 'S' == entity.level or 'M' == entity.level:
            for chn in entity.get_chains():
                fp.write(' [\n')
                chn.internal_coord._write_SCAD(fp, backboneOnly=backboneOnly, start=start, fin=fin)
                fp.write(' ]\n')
        elif 'C' == entity.level:
            fp.write(' [\n')
            entity.internal_coord._write_SCAD(fp, backboneOnly=backboneOnly, start=start, fin=fin)
            fp.write(' ]\n')
        elif 'R' == entity.level:
            raise NotImplementedError('writescad single residue not yet implemented.')
        fp.write('\n];\n')
    if maxPeptideBond is not None:
        IC_Chain.MaxPeptideBond = mpbStash
peptide_scad = '\n/*\n//\n// peptide.scad\n// Copyright (c) 2019 Robert T. Miller.  All rights reserved.\n// This file is part of the Biopython distribution and governed by your\n// choice of the "Biopython License Agreement" or the "BSD 3-Clause License".\n// Please see the LICENSE file that should have been included as part of this\n// package.\n//\n// This is the support file to build an OpenSCAD (http://www.openscad.org/) model\n// of a protein from internal coordinates.  The resulting model may be constructed\n// on a 3D printer.\n//\n// data matrices should be appended below to form a program ready to load into\n// the OpenSCAD application.\n//\n//  The protein_scale value used throughout is the second element of the\n//    protein[] array appended below.\n//    This is the value supplied when generating the data for build units per\n//    PDB angstrom.\n//    You may wish to modify it here to adjust the appearance of the model in\n//    terms of atom sphere or bond cylinder diameter, however the bond lengths\n//    are fixed with the supplied value when the data matrices are generated.\n//    Atom sphere and bond cylinder radii may be individually adjusted below as\n//    well.\n//\n//  $fn (fragment number) is an OpenSCAD parameter controlling the smoothness\n//    of the model surface.  Smaller values will render faster, but yield more\n//    \'blocky\' models.\n//\n//  This is intended to be a working example, you are encouraged to modify the\n//    OpenSCAD subroutines below to generate a model to your liking.  For more\n//    information, start with http://www.openscad.org/cheatsheet/index.html\n//\n//  Note especially the hedronDispatch() subroutine below: here you may select\n//    hedra based on residue, sequence position, and class (hedron atoms) for\n//    special handling.  Also see the per hedron render options in the hedra[]\n//    array.\n//\n//  If you modify this file, you may find it useful to generate the data\n//    matrices without this OpenSCAD code by calling write_SCAD() with the\n//    includeCode=False option, then use the OpenSCAD \'include <>\' facility at\n//    the end of your modified OpenSCAD program.\n*/\n\nrotate([-90,0,0])  // convenient for default location (no N-Ca-C start coordinates)\n    chain(protein);   // this is the main subroutine call to  build the structure\n\n// top-level OpenSCAD $fn for visible surfaces.  Rotatable bonds use $fn=8\n// inside, regardless of this setting.\n$fn = 0;  // 0 yields OpenSCAD default of 30.  $n=8 should print with minimal support\n\ntubes=false;     // style: render atoms and bonds as constant diameter cylinders, preferred for rotatable bonds / h-bonds\nsupport=false;   // enable print-in-place internal support for rotatable bonds\n// N.B. rotatable bonds must be parallel to build plate for internal support\n// structures to be generated correctly by slicer\n\n// output parameters\natomScale=1.0;  // 0.8 better for rotatable bonds\ndefaultAtomRadius = 0.77;  // used if tubes = true\n\nbondRadius = (tubes ? defaultAtomRadius * atomScale : 0.4);\njBondRadius = defaultAtomRadius * atomScale;  // radius for rotatable bonds\n\n// general printer, slicer, print settings\nlayerHeight=0.15;  // must match slicer setting for print-in-place support\nclearance=0.3;     // sliding clearance - can be smaller (0.2) if not doing print-in-place\npClearance=0.2;    // press-fit clearance (magnets for h-bonds)\nshim=0.05;         // extra to make OpenSCAD surfaces distinct in difference()\nnozzleDiameter=0.4;\n\n// need one magnet for each side of hydrogen bond, suggest 3mm x 5mm e.g. from eBay\n// use compass to identify poles if you care, North pointing (red) repels compass North pointing\nmagR=3/2;    // magnet radius\nmagL=5;      // magnet length\n\n// for $fn=8 which works nice on fdm printer\noRot = 22.5;              // 45/2, rotate to make fn=8 spheres and cylinders flat on build plate\napmFac = cos(180/8);      // apothem factor - multiply by radius for center to octagon side distance\noctSide = 2* tan(180/8);  // multiply by radius to get length of octagon side\n// for values of $fn:\nfnRot = ($fn ? 90-(180/$fn) : 90-(180/30));\n\nbondLenFac = 0.6;         // fraction of bond length to extend from atom for each arm of hedron in join\n\nhblen = 1.97;             // hydrogen bond length\n\nwall = 3*nozzleDiameter;\njoinerStep = 1;           // radius difference between rotatable bond axle and end knob inside bond cylinder\n\ncaTop = false;     // only make top of N_C-alpha_C hedron plus C-beta (see hedron() and hedron_dispatch() examples)\n\n/*\n//\n// Generate a sphere to represent an atom.\n// Colour and size determined for the atom covalent radius specified by the\n//   parameter \'a\' by lookup in the atomData table below, then scaled by the\n//   supplied parameter \'scal\'.\n//\n// scal : protein_scale\n// clr : additional radius if used to create clearance for rotatable bonds\n//\n*/\nmodule atom(a,scal,clr=0)\n{\n    ad = atomData[search([a],atomData)[0]];\n    color(ad[1]) {\n        rotate([0,0,fnRot]) sphere(r=((ad[2]*atomScale)*scal)+clr);\n    }\n}\n\n/*\n//\n// a hedron (below) may be \'reversed\' in terms of the order of its two bonds;\n// this function fixes the ordering\n//\n*/\nfunction hFlip(h,rev) =\n        //   yes reversed                                     :  not reversed\n        //    0    1     2     3     4     5     6      7     :     0     1     2     3    4     5      6      7\n        //  len1  len3  atom1 atom3  a1    a2   a1-a2  a2-a3      len1  len3  atom1 atom3   a1    a3  a1-a2  a2-a3\n    (rev ? [ h[2], h[0], h[5], h[3], h[8], h[6], h[10], h[9] ] : [ h[0], h[2], h[3], h[5], h[6], h[8],  h[9], h[10] ]);\n    // h[1] = angle2 for both cases\n\n\n/*\n//\n// generate the male or female interior cylinders of a rotating bond\n//\n*/\nmodule joinUnit(cOuterLen, cOuterRad, cInnerLen, cInnerRad, male=false) {\n    if (male) {\n        rotate([0,0,oRot]) {\n            cylinder(h=cInnerLen, r=cInnerRad, center=false, $fn=8);\n            cylinder(h=cOuterLen, r=cOuterRad, center=false, $fn=8);\n        }\n    } else {\n        rotate([0,0,fnRot]) {\n            cylinder(h=cInnerLen, r=cInnerRad, center=false, $fn=30);\n            cylinder(h=cOuterLen, r=cOuterRad, center=false, $fn=30);\n        }\n    }\n}\n\n/*\n//\n// create a rotatable bond\n//\n// supportSel : 0 for no support, 1 or 2 for support on top or bottom (needed\n// for reversed hedra)\n//\n*/\nmodule joiner(bondlen, scal, male=0, ver=0, supportSelect=0) {  // ver = differentiate joiner part lengths to guide assembly, but not used\n    lenfac = bondLenFac;\n    jClr = clearance+0.05;\n\n    cOuterRad = (jBondRadius * scal) - (2*wall + (male ? jClr/2 : -jClr/2));\n    cInnerRad = cOuterRad - joinerStep;  // m/f jClr already in cOuterRad;  - (male ? 0 : -0*jClr/2);\n\n    hArmLen = (bondlen * lenfac);\n    lenClr = 0.6*jClr;  // length clearance applied to male and female both, so effective clearance is 2x this value\n    cOuterLen = hArmLen * lenfac + (ver ? 0.5 : - 0.5) - (wall+ (male ? lenClr*2 : -lenClr*2  ));\n\n    joinerOffset = (hArmLen * (1 - lenfac)) + (male ? lenClr : -lenClr) - (ver ? 1 : 0);\n\n    i=supportSelect-1;\n    oside = cOuterRad*octSide;\n    wid = oside+2*wall+4*jClr+1;\n\n    if (male) {\n        rotate([0,180,0])\n        translate([0,0,-(bondlen-joinerOffset)]) {\n            difference() {\n                joinUnit(cOuterLen, cOuterRad, bondlen, cInnerRad, male=true);\n                if (supportSelect) {\n                    rotate([0,0,i*180]) {\n                        translate([0,(cOuterRad*apmFac)-0.5*layerHeight,cOuterLen/2]) {\n                                cube([oside+2*shim,layerHeight+shim,cOuterLen+2*shim],center=true);\n                        }\n                    }\n                }\n            }\n            if (supportSelect) {\n                rotate([0,0,i*180]) {\n                    translate([0,(cOuterRad*apmFac)-0.5*layerHeight,cOuterLen/2]) {\n                        for (j=[0:1]) {\n                            rotate([0,(j?60:-60),0])\n                                cube([wid,layerHeight,2*nozzleDiameter],center=true);\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        translate([0,0,joinerOffset]) {\n            joinUnit(cOuterLen, cOuterRad, bondlen, cInnerRad);\n            if (supportSelect) {  // extra gap top and bottom because filament sags\n                supHeight = max(5*layerHeight,2*(cOuterRad-cOuterRad*apmFac));  // double because center=true below\n                for(j=[0:1]) {\n                    rotate([0,0,j*180]) {\n                        translate([0,(cOuterRad*apmFac),cOuterLen/2]) {\n                            cube([oside+2*shim,supHeight+shim,cOuterLen+2*shim],center=true);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n/*\n//\n// create bond with different options (regular, skinny, h-bond atom, rotatable\n// male or female\n//\n//  parameters:\n//  bl : bond length\n//  br : bond radius\n//  scal : protein_scale\n//  key : option symbols defined below\n//  atm : atomic element symbol, used for color and radius by atom() routine above\n//  ver : make rotatable bonds slightly different based on value; currently unused\n//  supporSel : enable print-in-place support for rotatable bonds\n//\n*/\n\n// option symbols - these names generated in BioPython code so avoid changing without thought\nStdBond = 1;\nFemaleJoinBond = 2;\nMaleJoinBond = 3;\nSkinnyBond = 4;        // Calpha - Cbeta bond cylinder needs to be skinny for clearance with rotating bonds\nHBond = 5;             // make room inside atom/bond to insert magnet to appropriate depth\n\nmodule bond(bl, br, scal, key, atm, ver, supportSel=0) {\n\n    br = (key == FemaleJoinBond ? jBondRadius * scal : br)  * (key == SkinnyBond ? 0.65 : 1);   // bond radius smaller for skinnyBond\n    bl = (key == FemaleJoinBond ? bl * bondLenFac : bl);  // make female joiner shorter\n    if (key == MaleJoinBond) { // male join is direct solid, others need difference()\n        joiner(bl, scal, male = true, ver = ver, supportSelect=supportSel);\n    } else {  // regular bond / skinny / h-bond / female join\n        bhblen = bl +(hblen/2 * scal);\n        rotate([0,0,fnRot]) {\n            difference() {\n                union() {\n                    cylinder(h=bl,r=br,center=false);\n                    if (key == HBond) {  // make extension collar for h-bond magnet\n                        rotate([0,0,oRot-fnRot]) cylinder(h=bhblen-1,r=(magR + clearance +wall),center=false, $fn=8);\n                    }\n                }\n                atom(atm,scal,-clearance);  // remove overlap with atom to clear area for female join\n                if (key == HBond) {     // make space to insert magnet inside bond cylinder\n                    translate([0,0,(bhblen-magL)-pClearance])\n                        cylinder(h=magL+pClearance+shim, r=magR+pClearance, center=false, $fn=8);\n                }\n            }\n        }\n    }\n}\n\n/*\n//\n// Generate a \'hedron\', one plane of 3 points, consisting of 3 atoms joined by\n//   two bonds.\n//   Defined as bond length - bond angle - bond length\n//\n// In some cases the sequence of atoms in the h[] array is reversed (rev flag),\n// as detailed in the comments.\n//\n// other parameters:\n//\n// h = hedron array data according to rev flag:\n//   yes reversed                                     :  not reversed\n//    0    1     2     3     4     5     6      7     :     0     1     2     3    4     5      6      7\n//  len1  len3  atom1 atom3  a1    a2   a1-a2  a2-a3      len1  len3  atom1 atom3   a1    a3  a1-a2  a2-a3\n//\n// split: chop half of the hedron - to selectively print parts of a rotating\n//   bond to be glued together.  top or bottom half selected by global caTop\n//   (C-alpha top) variable, undef by default so bottom half.\n//\n// supporSel: enable support structure inside rotatable bond to print in place.\n//  Please note the bond needs to be exactly parallel to the buildplate and the\n//  layerHeight global variable above needs to be set correctly for the\n//  structure to be correctly created by your slicer software.\n//\n */\n\nmodule hedron(h,rev=0,scal,split=0, supportSel) {\n\n    newh = hFlip(h, rev);  // make a consistent hedron array regardless of rev flag\n\n    bondRad = bondRadius * scal;\n    difference() {\n        union(){\n            if (h[7]) {\n                // central atom at 0,0,0\n                atom(h[4],scal);\n            }\n\n            if (newh[5] && newh[7] != FemaleJoinBond) {  // not female join\n                // comments for non-reversed case\n                // atom 3 is len3 up on +z\n                translate([0,0,newh[1]])\n                    difference() {\n                        atom(newh[3],scal * (newh[7] == SkinnyBond ? 0.7 : 1));  // if skinny bond make atom (C-beta) same diameter as bond\n                        if (newh[7] == HBond) {  // make room for hbond magnet through atom - this branch not used for backbone N,O\n                            translate([0,0,scal*hblen/2-magL-pClearance])\n                                cylinder(h=magL+pClearance,r=magR+pClearance,$fn=8);\n                        }\n                    }\n            }\n\n            if (newh[7]) {\n                // atom 2 - atom 3 bond from origin up +z distance len3\n                bond(newh[1], bondRad, scal, newh[7], h[4], ver=1, supportSel=supportSel);\n            }\n            rotate([0, h[1], 0]) {                        // rotate following elements by angle2 about Y\n                if (newh[6]) {\n                    bond(newh[0], bondRad, scal, newh[6], h[4], ver=1, supportSel=supportSel);  // h[4] is center atom (atom 2)\n                }\n                if (newh[4] && newh[6] != FemaleJoinBond) {   // if draw atom 2 and atom1-atom2 not joiner\n                    translate([0,0,newh[0]]) {\n                        difference() {\n                            atom(newh[2],scal * (newh[6] == SkinnyBond ? 0.7 : 1));  // put atom1 sphere len1 away on Z\n                            if (newh[6] == HBond) {  // make room for hbond magnet through atom\n                                translate([0,0,scal*hblen/2-magL-pClearance])\n                                    cylinder(h=magL+pClearance,r=magR+pClearance,$fn=8);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (split) {\n            // top / bottom half cutter\n            thick = 2*bondRadius * scal;\n            Zdim = newh[0];\n            Xdim = newh[1];\n\n            cside = 7* defaultAtomRadius * atomScale * scal / 12 + (caTop ? pClearance : -pClearance);\n            difference() {\n                translate([-Xdim,((rev || caTop) ? 0 : -thick),-Zdim]) {\n                    cube([2*Xdim,thick,2*Zdim]);\n                }\n                if (!caTop) {\n                    rotate([0,(rev ? h[1] : 0),0])\n                    rotate([45,0,0])\n                    cube([cside, cside, cside],center=true);\n                }\n            }\n            if (caTop) {\n                //translate([tx+cside,0,tx+cside])\n                    rotate([0,(rev ? h[1] : 0),0])\n                        rotate([45,0,0])\n                        cube([cside, cside, cside], center=true);\n            }\n        }\n\n        if (newh[7] == FemaleJoinBond) {  // female join\n            joiner(newh[1], scal, male=false, ver=1, supportSelect=supportSel);\n        }\n\n        if (newh[6] == FemaleJoinBond) {  // female join\n            rotate([0, h[1], 0]) {                        // rotate following elements by angle2 about Y\n            joiner(newh[0], scal, male=false, ver=1, supportSelect=supportSel);\n            translate([0,0,newh[0]])\n                atom(newh[2],scal+0.5,clearance);  // clearance for atom against join outer cylinder\n            }\n        }\n\n        if (newh[7] == FemaleJoinBond || newh[6] == FemaleJoinBond) {  // female join both hedron arms\n            translate([0,0,newh[1]]) atom(newh[3],scal+0.5,clearance);  // clearance for atom against join outer cylinder\n        }\n    }\n}\n\n/*\n//\n// Hook to call custom routines for specific hedra.\n//\n// Residue is h[h_residue]\n// Sequence position is h[h_seqpos]\n//\n*/\nmodule hedronDispatch(h,rev=0,scal) {\n    // default action is just to pass to hedron()\n\n    hedron(h, rev, scal, 0, (support ? 1 : 0));\n\n    /*\n    // Some examples for special handling for specific hedra below:\n    // note use of h_seqpos, h_residue, h_class for selecting hedra\n\n    // bool flag caTop (for rotatable bond part) needs to be a global variable\n    // so hedron() above can see it.\n\ncaBase1 = false;   // only make bottom of N_C-alpha_C hedron\ncaBase2 = false;   // same as caBase1 but for case of reversed hedron (for testing, should be identical to caBase1 result)\namideOnly = false; // make only the first amide\n\n    if (caTop) {\n        // these examples select a specific sequence position (h[h_seqpos] == n)\n        if (h[h_seqpos] == 1) {\n            if (h[h_class] == "NCAC") {\n                hedron(h, rev, scal, 1);\n            } else if (h[h_class] == "CBCAC") {\n                color("yellow") {  // ca-cb\n                    hedron(h, rev, scal);\n                }\n            }\n        }\n    } else if (caBase1) {\n        if (h[h_seqpos] == 1 && (h[h_class] == "NCAC")) {\n            hedron(h, rev, scal, true, (support ? 1 : 0));\n        }\n    } else if (caBase2) {\n        if (h[h_seqpos] == 5 && (h[h_class] == "NCAC")) {\n            hedron(h, rev, scal, true, (support ? 1 : 0));\n        }\n    } else if (amideOnly) {\n        if (h[h_seqpos] == 1) {\n            if (h[h_class] == "CACN") {\n                color("darkgray") {\n                    hedron(h, rev, scal);\n                }\n            }  else if (h[h_class] == "CACO") {\n                color("red") {   // c=o\n                    hedron(h, rev, scal);\n                }\n            }  else if (h[h_class] == "CNCA") {\n                color("cyan") {  // h=n\n                    hedron(h, rev, scal);\n                }\n            }\n        } else if ((h[h_seqpos] == 2) && (h[h_class] == "HNCA")) {\n            color("cyan") {  // h=n\n                hedron(h, rev, scal);\n            }\n        }\n       // actions above select out only a single hedron\n    } else {\n        // actions below will process hedra all but handle selected ones differently\n\n        if (h[h_class] == "NCAC") {\n            if (h[h_seqpos] == 1) {\n                if (! CCap && NCap) {  // make split rotatable bond for terminal NH3\n                    hedron(h, rev, scal, true, (support ? 1 : 0));\n                }\n            } else if (h[h_seqpos] == 5) {  // make split rotatable bond for terminal COOH\n                hedron(h, rev, scal, true, (support ? 2 : 0));  // note supportSel = 2\n            } else {\n                hedron(h, rev, scal, 0, (support ? 2 : 0));\n            }\n        } else if (h[h_class] == "CBCAC") {\n            color("yellow") {                     // ca-cb -- color yellow in OpenSCAD renderer\n                if (h[h_seqpos] == 1 ) {         // don\'t make here for N-term\n                } else if (h[h_seqpos] == 5 ) {  // don\'t make here for C-term\n                } else {\n                    hedron(h, rev, scal);       // otherwise do make here\n                }\n            }\n        } else if (h[h_class] == "HNCA") {\n            color("cyan") { // color h-n in OenSCAD renderer\n                if (h[h_seqpos] == 1) {\n                    if (NCap) {                      // only make at N term if variable NCap is true\n                        hedron(h, rev, scal, 0, (support ? 1 : 0));\n                    }\n                } else {\n                    hedron(h, rev, scal, 0, (support ? 1 : 0));\n                }\n            }\n        } else if (h[h_residue] == "P") {\n            color("darkgray")   // highlight Prolines in OpenSCAD renderer\n                hedron(h, rev, scal);\n        } else {\n            echo("unrecognised hedron", h[h_class]);\n            color("pink")\n                hedron(h, rev, scal, 0, (support ? 1 : 0));\n        }\n    }\n    */\n}\n\n/*\n//\n// Generate a hedron rotated to specific angle d\n//\n*/\nmodule d2(d,hedra,scal)\n{\n    tz = (d[d_reversed] ? hedra[d[d_h2ndx]][2] : hedra[d[d_h2ndx]][0]);      // get h2 len1 depending on reversed\n    rotate(d[d_dangle1]) {                                                   // 4. rotate h2 to specified dihedral angle\n        translate([0,0,tz]) {                                               // 3. translate h2 h2:len1 up +z\n            rotate([180, 0, 0]) {                                          // 2. rotate h2r about X so h2:a3 in +z and h2:a1 in -z\n                hedronDispatch(hedra[d[d_h2ndx]],(!d[d_reversed]),scal);  // 1. reverse hedron 2 orientation = h2r\n            }\n        }\n    }\n}\n\n/*\n//\n// Generate two hedra at specified dihedral angle d\n//\n*/\nmodule dihedron(d,hedra,scal)\n{\n    if (d[d_h1new])\n        hedronDispatch(hedra[d[d_h1ndx]],d[d_reversed],scal);                // reverse h1 if dihedral reversed\n    if (d[d_h2new])\n        d2(d,hedra,scal);\n}\n\n/*\n//\n// Generate a residue consisting of the set of dihedra in the parameter \'r\',\n//   referring to hedra the table specified in the parameter \'hedra\'.\n//\n*/\nmodule residue(r,hedra, scal)\n{\n    for (d = r) {\n        multmatrix(d[d_dihedralTransform]) {\n            dihedron(d, hedra, scal);\n        }\n    }\n}\n\n/*\n//\n// Generate a chain of residues, each positioned by a supplied\n// rotation/translation matrix.\n//\n*/\nmodule chain(protein)\n{\n    chnD = protein[p_chainData];\n    c = chnD[c_residues];\n    dihedra = chnD[c_dihedra];\n    hedra = chnD[c_hedra];\n    for (r = c) {\n        multmatrix(r[r_resTransform]) {\n            residue(dihedra[r[r_resNdx]],hedra, protein[p_proteinScale]);\n        }\n    }\n}\n\n/*\n//\n// OpenSCAD array indices to reference protein data - tied to BioPython code\n//\n*/\n\n// protein base level\np_pdbid = 0;\np_proteinScale = 1;\np_chainData = 2;\n\n// chain level data\nc_chainID = 0;\nc_dihedra = 1;\nc_hedra = 2;\nc_residues = 3;\n\n// hedra definitions\nh_len1 = 0;\nh_angle2 = 1;\nh_len3 = 2;\nh_atom1class = 3;\nh_atom2class = 4;\nh_atom3class = 5;\nh_atom1state = 6;\nh_atom2state = 7;\nh_atom3state = 8;\nh_bond1state = 9;\nh_bond2state = 10;\nh_residue = 11;\nh_seqpos = 12;  // residue sequence position for first atom in hedra\nh_class = 13;\n\n// dihedra specifications for each residue in sequence, dihedral array\nd_dangle1 = 0;\nd_h1ndx = 1;\nd_h2ndx = 2;\nd_reversed = 3;\nd_h1new = 4;\nd_h2new = 5;\nd_dihedralTransform = 6;\n\n// residueSet: world transform for each residue in sequence array\nr_resNdx = 0;\nr_resID = 1;\nr_resTransform = 2;\n\n\n// use single default atom radius for all atoms if tubes = true, else use\n// covalent radii from literature\natomData = ( tubes ?\n            [   ["Csb","green" , defaultAtomRadius], ["Cres","green" , defaultAtomRadius], ["Cdb","green" , defaultAtomRadius],\n                ["Osb","red" , defaultAtomRadius], ["Ores","red" , defaultAtomRadius], ["Odb","red" , defaultAtomRadius],\n                ["Nsb","blue" , defaultAtomRadius], ["Nres","blue" , defaultAtomRadius], ["Ndb","blue" , defaultAtomRadius],\n                ["Hsb","gray" , defaultAtomRadius],\n                ["Ssb","yellow" , defaultAtomRadius] ]\n            :\n\n// covalent radii from Heyrovska, Raji : \'Atomic Structures of all the Twenty\n// Essential Amino Acids and a Tripeptide, with Bond Lengths as Sums of Atomic\n// Covalent Radii\'  https://arxiv.org/pdf/0804.2488.pdf\n\n            [   ["Csb","green" , 0.77], ["Cres","green" , 0.72], ["Cdb","green" , 0.67],\n                ["Osb","red" , 0.67], ["Ores","red" , 0.635], ["Odb","red" , 0.60],\n                ["Nsb","blue" , 0.70], ["Nres","blue" , 0.66], ["Ndb","blue" , 0.62],\n                ["Hsb","gray" , 0.37],\n                ["Ssb","yellow" , 1.04] ]\n    );\n\n\n// optionally include protein array data here [ write_SCAD(includeCode=False) ], e.g.:\n// include <1rtm.scad>;\n// or paste below\n\n'