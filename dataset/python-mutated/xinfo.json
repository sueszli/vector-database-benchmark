[
    {
        "func_name": "print_line",
        "original": "def print_line(name, addr, first, second, op, width=20) -> None:\n    print(f\"{name.rjust(width)} {M.get(addr)} = {(M.get(first) if not isinstance(first, str) else first.ljust(len(hex(addr).rstrip('L'))))} {op} {second:#x}\")",
        "mutated": [
            "def print_line(name, addr, first, second, op, width=20) -> None:\n    if False:\n        i = 10\n    print(f\"{name.rjust(width)} {M.get(addr)} = {(M.get(first) if not isinstance(first, str) else first.ljust(len(hex(addr).rstrip('L'))))} {op} {second:#x}\")",
            "def print_line(name, addr, first, second, op, width=20) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print(f\"{name.rjust(width)} {M.get(addr)} = {(M.get(first) if not isinstance(first, str) else first.ljust(len(hex(addr).rstrip('L'))))} {op} {second:#x}\")",
            "def print_line(name, addr, first, second, op, width=20) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print(f\"{name.rjust(width)} {M.get(addr)} = {(M.get(first) if not isinstance(first, str) else first.ljust(len(hex(addr).rstrip('L'))))} {op} {second:#x}\")",
            "def print_line(name, addr, first, second, op, width=20) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print(f\"{name.rjust(width)} {M.get(addr)} = {(M.get(first) if not isinstance(first, str) else first.ljust(len(hex(addr).rstrip('L'))))} {op} {second:#x}\")",
            "def print_line(name, addr, first, second, op, width=20) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print(f\"{name.rjust(width)} {M.get(addr)} = {(M.get(first) if not isinstance(first, str) else first.ljust(len(hex(addr).rstrip('L'))))} {op} {second:#x}\")"
        ]
    },
    {
        "func_name": "xinfo_stack",
        "original": "def xinfo_stack(page, addr) -> None:\n    sp = pwndbg.gdblib.regs.sp\n    frame = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n    frame_mapping = pwndbg.gdblib.vmmap.find(frame)\n    print_line('Stack Top', addr, page.vaddr, addr - page.vaddr, '+')\n    print_line('Stack End', addr, page.end, page.end - addr, '-')\n    print_line('Stack Pointer', addr, sp, addr - sp, '+')\n    if frame_mapping and page.vaddr == frame_mapping.vaddr:\n        print_line('Frame Pointer', addr, frame, frame - addr, '-')\n    canary_value = pwndbg.commands.canary.canary_value()[0]\n    if canary_value is not None:\n        all_canaries = list(pwndbg.search.search(pwndbg.gdblib.arch.pack(canary_value), mappings=pwndbg.gdblib.stack.stacks.values()))\n        follow_canaries = sorted(filter(lambda a: a > addr, all_canaries))\n        if follow_canaries is not None and len(follow_canaries) > 0:\n            nxt = follow_canaries[0]\n            print_line('Next Stack Canary', addr, nxt, nxt - addr, '-')",
        "mutated": [
            "def xinfo_stack(page, addr) -> None:\n    if False:\n        i = 10\n    sp = pwndbg.gdblib.regs.sp\n    frame = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n    frame_mapping = pwndbg.gdblib.vmmap.find(frame)\n    print_line('Stack Top', addr, page.vaddr, addr - page.vaddr, '+')\n    print_line('Stack End', addr, page.end, page.end - addr, '-')\n    print_line('Stack Pointer', addr, sp, addr - sp, '+')\n    if frame_mapping and page.vaddr == frame_mapping.vaddr:\n        print_line('Frame Pointer', addr, frame, frame - addr, '-')\n    canary_value = pwndbg.commands.canary.canary_value()[0]\n    if canary_value is not None:\n        all_canaries = list(pwndbg.search.search(pwndbg.gdblib.arch.pack(canary_value), mappings=pwndbg.gdblib.stack.stacks.values()))\n        follow_canaries = sorted(filter(lambda a: a > addr, all_canaries))\n        if follow_canaries is not None and len(follow_canaries) > 0:\n            nxt = follow_canaries[0]\n            print_line('Next Stack Canary', addr, nxt, nxt - addr, '-')",
            "def xinfo_stack(page, addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    sp = pwndbg.gdblib.regs.sp\n    frame = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n    frame_mapping = pwndbg.gdblib.vmmap.find(frame)\n    print_line('Stack Top', addr, page.vaddr, addr - page.vaddr, '+')\n    print_line('Stack End', addr, page.end, page.end - addr, '-')\n    print_line('Stack Pointer', addr, sp, addr - sp, '+')\n    if frame_mapping and page.vaddr == frame_mapping.vaddr:\n        print_line('Frame Pointer', addr, frame, frame - addr, '-')\n    canary_value = pwndbg.commands.canary.canary_value()[0]\n    if canary_value is not None:\n        all_canaries = list(pwndbg.search.search(pwndbg.gdblib.arch.pack(canary_value), mappings=pwndbg.gdblib.stack.stacks.values()))\n        follow_canaries = sorted(filter(lambda a: a > addr, all_canaries))\n        if follow_canaries is not None and len(follow_canaries) > 0:\n            nxt = follow_canaries[0]\n            print_line('Next Stack Canary', addr, nxt, nxt - addr, '-')",
            "def xinfo_stack(page, addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    sp = pwndbg.gdblib.regs.sp\n    frame = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n    frame_mapping = pwndbg.gdblib.vmmap.find(frame)\n    print_line('Stack Top', addr, page.vaddr, addr - page.vaddr, '+')\n    print_line('Stack End', addr, page.end, page.end - addr, '-')\n    print_line('Stack Pointer', addr, sp, addr - sp, '+')\n    if frame_mapping and page.vaddr == frame_mapping.vaddr:\n        print_line('Frame Pointer', addr, frame, frame - addr, '-')\n    canary_value = pwndbg.commands.canary.canary_value()[0]\n    if canary_value is not None:\n        all_canaries = list(pwndbg.search.search(pwndbg.gdblib.arch.pack(canary_value), mappings=pwndbg.gdblib.stack.stacks.values()))\n        follow_canaries = sorted(filter(lambda a: a > addr, all_canaries))\n        if follow_canaries is not None and len(follow_canaries) > 0:\n            nxt = follow_canaries[0]\n            print_line('Next Stack Canary', addr, nxt, nxt - addr, '-')",
            "def xinfo_stack(page, addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    sp = pwndbg.gdblib.regs.sp\n    frame = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n    frame_mapping = pwndbg.gdblib.vmmap.find(frame)\n    print_line('Stack Top', addr, page.vaddr, addr - page.vaddr, '+')\n    print_line('Stack End', addr, page.end, page.end - addr, '-')\n    print_line('Stack Pointer', addr, sp, addr - sp, '+')\n    if frame_mapping and page.vaddr == frame_mapping.vaddr:\n        print_line('Frame Pointer', addr, frame, frame - addr, '-')\n    canary_value = pwndbg.commands.canary.canary_value()[0]\n    if canary_value is not None:\n        all_canaries = list(pwndbg.search.search(pwndbg.gdblib.arch.pack(canary_value), mappings=pwndbg.gdblib.stack.stacks.values()))\n        follow_canaries = sorted(filter(lambda a: a > addr, all_canaries))\n        if follow_canaries is not None and len(follow_canaries) > 0:\n            nxt = follow_canaries[0]\n            print_line('Next Stack Canary', addr, nxt, nxt - addr, '-')",
            "def xinfo_stack(page, addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    sp = pwndbg.gdblib.regs.sp\n    frame = pwndbg.gdblib.regs[pwndbg.gdblib.regs.frame]\n    frame_mapping = pwndbg.gdblib.vmmap.find(frame)\n    print_line('Stack Top', addr, page.vaddr, addr - page.vaddr, '+')\n    print_line('Stack End', addr, page.end, page.end - addr, '-')\n    print_line('Stack Pointer', addr, sp, addr - sp, '+')\n    if frame_mapping and page.vaddr == frame_mapping.vaddr:\n        print_line('Frame Pointer', addr, frame, frame - addr, '-')\n    canary_value = pwndbg.commands.canary.canary_value()[0]\n    if canary_value is not None:\n        all_canaries = list(pwndbg.search.search(pwndbg.gdblib.arch.pack(canary_value), mappings=pwndbg.gdblib.stack.stacks.values()))\n        follow_canaries = sorted(filter(lambda a: a > addr, all_canaries))\n        if follow_canaries is not None and len(follow_canaries) > 0:\n            nxt = follow_canaries[0]\n            print_line('Next Stack Canary', addr, nxt, nxt - addr, '-')"
        ]
    },
    {
        "func_name": "xinfo_mmap_file",
        "original": "def xinfo_mmap_file(page, addr) -> None:\n    file_name = page.objfile\n    objpages = filter(lambda p: p.objfile == file_name, pwndbg.gdblib.vmmap.get())\n    first = sorted(objpages, key=lambda p: p.vaddr)[0]\n    rva = addr - first.vaddr\n    print_line('File (Base)', addr, first.vaddr, rva, '+')\n    containing_loads = [seg for seg in pwndbg.gdblib.elf.get_containing_segments(file_name, first.vaddr, addr) if seg['p_type'] == 'PT_LOAD']\n    for segment in containing_loads:\n        if segment['p_type'] == 'PT_LOAD' and addr < segment['x_vaddr_mem_end']:\n            offset = addr - segment['p_vaddr']\n            print_line('File (Segment)', addr, segment['p_vaddr'], offset, '+')\n            break\n    for segment in containing_loads:\n        if segment['p_type'] == 'PT_LOAD' and addr < segment['x_vaddr_file_end']:\n            file_offset = segment['p_offset'] + (addr - segment['p_vaddr'])\n            print_line('File (Disk)', addr, file_name, file_offset, '+')\n            break\n    else:\n        print(f\"{'File (Disk)'.rjust(20)} {M.get(addr)} = [not file backed]\")\n    containing_sections = pwndbg.gdblib.elf.get_containing_sections(file_name, first.vaddr, addr)\n    if len(containing_sections) > 0:\n        print('\\n Containing ELF sections:')\n        for sec in containing_sections:\n            print_line(sec['x_name'], addr, sec['sh_addr'], addr - sec['sh_addr'], '+')",
        "mutated": [
            "def xinfo_mmap_file(page, addr) -> None:\n    if False:\n        i = 10\n    file_name = page.objfile\n    objpages = filter(lambda p: p.objfile == file_name, pwndbg.gdblib.vmmap.get())\n    first = sorted(objpages, key=lambda p: p.vaddr)[0]\n    rva = addr - first.vaddr\n    print_line('File (Base)', addr, first.vaddr, rva, '+')\n    containing_loads = [seg for seg in pwndbg.gdblib.elf.get_containing_segments(file_name, first.vaddr, addr) if seg['p_type'] == 'PT_LOAD']\n    for segment in containing_loads:\n        if segment['p_type'] == 'PT_LOAD' and addr < segment['x_vaddr_mem_end']:\n            offset = addr - segment['p_vaddr']\n            print_line('File (Segment)', addr, segment['p_vaddr'], offset, '+')\n            break\n    for segment in containing_loads:\n        if segment['p_type'] == 'PT_LOAD' and addr < segment['x_vaddr_file_end']:\n            file_offset = segment['p_offset'] + (addr - segment['p_vaddr'])\n            print_line('File (Disk)', addr, file_name, file_offset, '+')\n            break\n    else:\n        print(f\"{'File (Disk)'.rjust(20)} {M.get(addr)} = [not file backed]\")\n    containing_sections = pwndbg.gdblib.elf.get_containing_sections(file_name, first.vaddr, addr)\n    if len(containing_sections) > 0:\n        print('\\n Containing ELF sections:')\n        for sec in containing_sections:\n            print_line(sec['x_name'], addr, sec['sh_addr'], addr - sec['sh_addr'], '+')",
            "def xinfo_mmap_file(page, addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    file_name = page.objfile\n    objpages = filter(lambda p: p.objfile == file_name, pwndbg.gdblib.vmmap.get())\n    first = sorted(objpages, key=lambda p: p.vaddr)[0]\n    rva = addr - first.vaddr\n    print_line('File (Base)', addr, first.vaddr, rva, '+')\n    containing_loads = [seg for seg in pwndbg.gdblib.elf.get_containing_segments(file_name, first.vaddr, addr) if seg['p_type'] == 'PT_LOAD']\n    for segment in containing_loads:\n        if segment['p_type'] == 'PT_LOAD' and addr < segment['x_vaddr_mem_end']:\n            offset = addr - segment['p_vaddr']\n            print_line('File (Segment)', addr, segment['p_vaddr'], offset, '+')\n            break\n    for segment in containing_loads:\n        if segment['p_type'] == 'PT_LOAD' and addr < segment['x_vaddr_file_end']:\n            file_offset = segment['p_offset'] + (addr - segment['p_vaddr'])\n            print_line('File (Disk)', addr, file_name, file_offset, '+')\n            break\n    else:\n        print(f\"{'File (Disk)'.rjust(20)} {M.get(addr)} = [not file backed]\")\n    containing_sections = pwndbg.gdblib.elf.get_containing_sections(file_name, first.vaddr, addr)\n    if len(containing_sections) > 0:\n        print('\\n Containing ELF sections:')\n        for sec in containing_sections:\n            print_line(sec['x_name'], addr, sec['sh_addr'], addr - sec['sh_addr'], '+')",
            "def xinfo_mmap_file(page, addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    file_name = page.objfile\n    objpages = filter(lambda p: p.objfile == file_name, pwndbg.gdblib.vmmap.get())\n    first = sorted(objpages, key=lambda p: p.vaddr)[0]\n    rva = addr - first.vaddr\n    print_line('File (Base)', addr, first.vaddr, rva, '+')\n    containing_loads = [seg for seg in pwndbg.gdblib.elf.get_containing_segments(file_name, first.vaddr, addr) if seg['p_type'] == 'PT_LOAD']\n    for segment in containing_loads:\n        if segment['p_type'] == 'PT_LOAD' and addr < segment['x_vaddr_mem_end']:\n            offset = addr - segment['p_vaddr']\n            print_line('File (Segment)', addr, segment['p_vaddr'], offset, '+')\n            break\n    for segment in containing_loads:\n        if segment['p_type'] == 'PT_LOAD' and addr < segment['x_vaddr_file_end']:\n            file_offset = segment['p_offset'] + (addr - segment['p_vaddr'])\n            print_line('File (Disk)', addr, file_name, file_offset, '+')\n            break\n    else:\n        print(f\"{'File (Disk)'.rjust(20)} {M.get(addr)} = [not file backed]\")\n    containing_sections = pwndbg.gdblib.elf.get_containing_sections(file_name, first.vaddr, addr)\n    if len(containing_sections) > 0:\n        print('\\n Containing ELF sections:')\n        for sec in containing_sections:\n            print_line(sec['x_name'], addr, sec['sh_addr'], addr - sec['sh_addr'], '+')",
            "def xinfo_mmap_file(page, addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    file_name = page.objfile\n    objpages = filter(lambda p: p.objfile == file_name, pwndbg.gdblib.vmmap.get())\n    first = sorted(objpages, key=lambda p: p.vaddr)[0]\n    rva = addr - first.vaddr\n    print_line('File (Base)', addr, first.vaddr, rva, '+')\n    containing_loads = [seg for seg in pwndbg.gdblib.elf.get_containing_segments(file_name, first.vaddr, addr) if seg['p_type'] == 'PT_LOAD']\n    for segment in containing_loads:\n        if segment['p_type'] == 'PT_LOAD' and addr < segment['x_vaddr_mem_end']:\n            offset = addr - segment['p_vaddr']\n            print_line('File (Segment)', addr, segment['p_vaddr'], offset, '+')\n            break\n    for segment in containing_loads:\n        if segment['p_type'] == 'PT_LOAD' and addr < segment['x_vaddr_file_end']:\n            file_offset = segment['p_offset'] + (addr - segment['p_vaddr'])\n            print_line('File (Disk)', addr, file_name, file_offset, '+')\n            break\n    else:\n        print(f\"{'File (Disk)'.rjust(20)} {M.get(addr)} = [not file backed]\")\n    containing_sections = pwndbg.gdblib.elf.get_containing_sections(file_name, first.vaddr, addr)\n    if len(containing_sections) > 0:\n        print('\\n Containing ELF sections:')\n        for sec in containing_sections:\n            print_line(sec['x_name'], addr, sec['sh_addr'], addr - sec['sh_addr'], '+')",
            "def xinfo_mmap_file(page, addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    file_name = page.objfile\n    objpages = filter(lambda p: p.objfile == file_name, pwndbg.gdblib.vmmap.get())\n    first = sorted(objpages, key=lambda p: p.vaddr)[0]\n    rva = addr - first.vaddr\n    print_line('File (Base)', addr, first.vaddr, rva, '+')\n    containing_loads = [seg for seg in pwndbg.gdblib.elf.get_containing_segments(file_name, first.vaddr, addr) if seg['p_type'] == 'PT_LOAD']\n    for segment in containing_loads:\n        if segment['p_type'] == 'PT_LOAD' and addr < segment['x_vaddr_mem_end']:\n            offset = addr - segment['p_vaddr']\n            print_line('File (Segment)', addr, segment['p_vaddr'], offset, '+')\n            break\n    for segment in containing_loads:\n        if segment['p_type'] == 'PT_LOAD' and addr < segment['x_vaddr_file_end']:\n            file_offset = segment['p_offset'] + (addr - segment['p_vaddr'])\n            print_line('File (Disk)', addr, file_name, file_offset, '+')\n            break\n    else:\n        print(f\"{'File (Disk)'.rjust(20)} {M.get(addr)} = [not file backed]\")\n    containing_sections = pwndbg.gdblib.elf.get_containing_sections(file_name, first.vaddr, addr)\n    if len(containing_sections) > 0:\n        print('\\n Containing ELF sections:')\n        for sec in containing_sections:\n            print_line(sec['x_name'], addr, sec['sh_addr'], addr - sec['sh_addr'], '+')"
        ]
    },
    {
        "func_name": "xinfo_default",
        "original": "def xinfo_default(page, addr) -> None:\n    print_line('Mapped Area', addr, page.vaddr, addr - page.vaddr, '+')",
        "mutated": [
            "def xinfo_default(page, addr) -> None:\n    if False:\n        i = 10\n    print_line('Mapped Area', addr, page.vaddr, addr - page.vaddr, '+')",
            "def xinfo_default(page, addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print_line('Mapped Area', addr, page.vaddr, addr - page.vaddr, '+')",
            "def xinfo_default(page, addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print_line('Mapped Area', addr, page.vaddr, addr - page.vaddr, '+')",
            "def xinfo_default(page, addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print_line('Mapped Area', addr, page.vaddr, addr - page.vaddr, '+')",
            "def xinfo_default(page, addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print_line('Mapped Area', addr, page.vaddr, addr - page.vaddr, '+')"
        ]
    },
    {
        "func_name": "xinfo",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.MEMORY)\n@pwndbg.commands.OnlyWhenRunning\ndef xinfo(address=None) -> None:\n    address = address.cast(pwndbg.gdblib.typeinfo.pvoid)\n    addr = int(address)\n    addr &= pwndbg.gdblib.arch.ptrmask\n    page = pwndbg.gdblib.vmmap.find(addr)\n    if page is None:\n        print(f'\\n  Virtual address {addr:#x} is not mapped.')\n        return\n    print(f'Extended information for virtual address {M.get(addr)}:')\n    print('\\n  Containing mapping:')\n    print(M.get(address, text=str(page)))\n    print('\\n  Offset information:')\n    if page.is_stack:\n        xinfo_stack(page, addr)\n    else:\n        xinfo_default(page, addr)\n    if page.is_memory_mapped_file:\n        xinfo_mmap_file(page, addr)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.MEMORY)\n@pwndbg.commands.OnlyWhenRunning\ndef xinfo(address=None) -> None:\n    if False:\n        i = 10\n    address = address.cast(pwndbg.gdblib.typeinfo.pvoid)\n    addr = int(address)\n    addr &= pwndbg.gdblib.arch.ptrmask\n    page = pwndbg.gdblib.vmmap.find(addr)\n    if page is None:\n        print(f'\\n  Virtual address {addr:#x} is not mapped.')\n        return\n    print(f'Extended information for virtual address {M.get(addr)}:')\n    print('\\n  Containing mapping:')\n    print(M.get(address, text=str(page)))\n    print('\\n  Offset information:')\n    if page.is_stack:\n        xinfo_stack(page, addr)\n    else:\n        xinfo_default(page, addr)\n    if page.is_memory_mapped_file:\n        xinfo_mmap_file(page, addr)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.MEMORY)\n@pwndbg.commands.OnlyWhenRunning\ndef xinfo(address=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    address = address.cast(pwndbg.gdblib.typeinfo.pvoid)\n    addr = int(address)\n    addr &= pwndbg.gdblib.arch.ptrmask\n    page = pwndbg.gdblib.vmmap.find(addr)\n    if page is None:\n        print(f'\\n  Virtual address {addr:#x} is not mapped.')\n        return\n    print(f'Extended information for virtual address {M.get(addr)}:')\n    print('\\n  Containing mapping:')\n    print(M.get(address, text=str(page)))\n    print('\\n  Offset information:')\n    if page.is_stack:\n        xinfo_stack(page, addr)\n    else:\n        xinfo_default(page, addr)\n    if page.is_memory_mapped_file:\n        xinfo_mmap_file(page, addr)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.MEMORY)\n@pwndbg.commands.OnlyWhenRunning\ndef xinfo(address=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    address = address.cast(pwndbg.gdblib.typeinfo.pvoid)\n    addr = int(address)\n    addr &= pwndbg.gdblib.arch.ptrmask\n    page = pwndbg.gdblib.vmmap.find(addr)\n    if page is None:\n        print(f'\\n  Virtual address {addr:#x} is not mapped.')\n        return\n    print(f'Extended information for virtual address {M.get(addr)}:')\n    print('\\n  Containing mapping:')\n    print(M.get(address, text=str(page)))\n    print('\\n  Offset information:')\n    if page.is_stack:\n        xinfo_stack(page, addr)\n    else:\n        xinfo_default(page, addr)\n    if page.is_memory_mapped_file:\n        xinfo_mmap_file(page, addr)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.MEMORY)\n@pwndbg.commands.OnlyWhenRunning\ndef xinfo(address=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    address = address.cast(pwndbg.gdblib.typeinfo.pvoid)\n    addr = int(address)\n    addr &= pwndbg.gdblib.arch.ptrmask\n    page = pwndbg.gdblib.vmmap.find(addr)\n    if page is None:\n        print(f'\\n  Virtual address {addr:#x} is not mapped.')\n        return\n    print(f'Extended information for virtual address {M.get(addr)}:')\n    print('\\n  Containing mapping:')\n    print(M.get(address, text=str(page)))\n    print('\\n  Offset information:')\n    if page.is_stack:\n        xinfo_stack(page, addr)\n    else:\n        xinfo_default(page, addr)\n    if page.is_memory_mapped_file:\n        xinfo_mmap_file(page, addr)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.MEMORY)\n@pwndbg.commands.OnlyWhenRunning\ndef xinfo(address=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    address = address.cast(pwndbg.gdblib.typeinfo.pvoid)\n    addr = int(address)\n    addr &= pwndbg.gdblib.arch.ptrmask\n    page = pwndbg.gdblib.vmmap.find(addr)\n    if page is None:\n        print(f'\\n  Virtual address {addr:#x} is not mapped.')\n        return\n    print(f'Extended information for virtual address {M.get(addr)}:')\n    print('\\n  Containing mapping:')\n    print(M.get(address, text=str(page)))\n    print('\\n  Offset information:')\n    if page.is_stack:\n        xinfo_stack(page, addr)\n    else:\n        xinfo_default(page, addr)\n    if page.is_memory_mapped_file:\n        xinfo_mmap_file(page, addr)"
        ]
    }
]