[
    {
        "func_name": "__init__",
        "original": "def __init__(self, N, sps, rolloff, ntaps, bw, noise, foffset, toffset, poffset, mode=0):\n    gr.top_block.__init__(self)\n    rrc_taps = filter.firdes.root_raised_cosine(sps, sps, 1.0, rolloff, ntaps)\n    gain = bw\n    nfilts = 32\n    rrc_taps_rx = filter.firdes.root_raised_cosine(nfilts, sps * nfilts, 1.0, rolloff, ntaps * nfilts)\n    data = 2.0 * numpy.random.randint(0, 2, N) - 1.0\n    data = numpy.exp(1j * poffset) * data\n    self.src = blocks.vector_source_c(data.tolist(), False)\n    self.rrc = filter.interp_fir_filter_ccf(sps, rrc_taps)\n    self.chn = channels.channel_model(noise, foffset, toffset)\n    self.off = filter.mmse_resampler_cc(0.2, 1.0)\n    if mode == 0:\n        self.clk = digital.pfb_clock_sync_ccf(sps, gain, rrc_taps_rx, nfilts, nfilts // 2, 1)\n        self.taps = self.clk.taps()\n        self.dtaps = self.clk.diff_taps()\n        self.delay = int(numpy.ceil(((len(rrc_taps) - 1) // 2 + (len(self.taps[0]) - 1) // 2) // float(sps))) + 1\n        self.vsnk_err = blocks.vector_sink_f()\n        self.vsnk_rat = blocks.vector_sink_f()\n        self.vsnk_phs = blocks.vector_sink_f()\n        self.connect((self.clk, 1), self.vsnk_err)\n        self.connect((self.clk, 2), self.vsnk_rat)\n        self.connect((self.clk, 3), self.vsnk_phs)\n    else:\n        mu = 0.5\n        gain_mu = bw\n        gain_omega = 0.25 * gain_mu * gain_mu\n        omega_rel_lim = 0.02\n        self.clk = digital.clock_recovery_mm_cc(sps, gain_omega, mu, gain_mu, omega_rel_lim)\n        self.vsnk_err = blocks.vector_sink_f()\n        self.connect((self.clk, 1), self.vsnk_err)\n    self.vsnk_src = blocks.vector_sink_c()\n    self.vsnk_clk = blocks.vector_sink_c()\n    self.connect(self.src, self.rrc, self.chn, self.off, self.clk, self.vsnk_clk)\n    self.connect(self.src, self.vsnk_src)",
        "mutated": [
            "def __init__(self, N, sps, rolloff, ntaps, bw, noise, foffset, toffset, poffset, mode=0):\n    if False:\n        i = 10\n    gr.top_block.__init__(self)\n    rrc_taps = filter.firdes.root_raised_cosine(sps, sps, 1.0, rolloff, ntaps)\n    gain = bw\n    nfilts = 32\n    rrc_taps_rx = filter.firdes.root_raised_cosine(nfilts, sps * nfilts, 1.0, rolloff, ntaps * nfilts)\n    data = 2.0 * numpy.random.randint(0, 2, N) - 1.0\n    data = numpy.exp(1j * poffset) * data\n    self.src = blocks.vector_source_c(data.tolist(), False)\n    self.rrc = filter.interp_fir_filter_ccf(sps, rrc_taps)\n    self.chn = channels.channel_model(noise, foffset, toffset)\n    self.off = filter.mmse_resampler_cc(0.2, 1.0)\n    if mode == 0:\n        self.clk = digital.pfb_clock_sync_ccf(sps, gain, rrc_taps_rx, nfilts, nfilts // 2, 1)\n        self.taps = self.clk.taps()\n        self.dtaps = self.clk.diff_taps()\n        self.delay = int(numpy.ceil(((len(rrc_taps) - 1) // 2 + (len(self.taps[0]) - 1) // 2) // float(sps))) + 1\n        self.vsnk_err = blocks.vector_sink_f()\n        self.vsnk_rat = blocks.vector_sink_f()\n        self.vsnk_phs = blocks.vector_sink_f()\n        self.connect((self.clk, 1), self.vsnk_err)\n        self.connect((self.clk, 2), self.vsnk_rat)\n        self.connect((self.clk, 3), self.vsnk_phs)\n    else:\n        mu = 0.5\n        gain_mu = bw\n        gain_omega = 0.25 * gain_mu * gain_mu\n        omega_rel_lim = 0.02\n        self.clk = digital.clock_recovery_mm_cc(sps, gain_omega, mu, gain_mu, omega_rel_lim)\n        self.vsnk_err = blocks.vector_sink_f()\n        self.connect((self.clk, 1), self.vsnk_err)\n    self.vsnk_src = blocks.vector_sink_c()\n    self.vsnk_clk = blocks.vector_sink_c()\n    self.connect(self.src, self.rrc, self.chn, self.off, self.clk, self.vsnk_clk)\n    self.connect(self.src, self.vsnk_src)",
            "def __init__(self, N, sps, rolloff, ntaps, bw, noise, foffset, toffset, poffset, mode=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    gr.top_block.__init__(self)\n    rrc_taps = filter.firdes.root_raised_cosine(sps, sps, 1.0, rolloff, ntaps)\n    gain = bw\n    nfilts = 32\n    rrc_taps_rx = filter.firdes.root_raised_cosine(nfilts, sps * nfilts, 1.0, rolloff, ntaps * nfilts)\n    data = 2.0 * numpy.random.randint(0, 2, N) - 1.0\n    data = numpy.exp(1j * poffset) * data\n    self.src = blocks.vector_source_c(data.tolist(), False)\n    self.rrc = filter.interp_fir_filter_ccf(sps, rrc_taps)\n    self.chn = channels.channel_model(noise, foffset, toffset)\n    self.off = filter.mmse_resampler_cc(0.2, 1.0)\n    if mode == 0:\n        self.clk = digital.pfb_clock_sync_ccf(sps, gain, rrc_taps_rx, nfilts, nfilts // 2, 1)\n        self.taps = self.clk.taps()\n        self.dtaps = self.clk.diff_taps()\n        self.delay = int(numpy.ceil(((len(rrc_taps) - 1) // 2 + (len(self.taps[0]) - 1) // 2) // float(sps))) + 1\n        self.vsnk_err = blocks.vector_sink_f()\n        self.vsnk_rat = blocks.vector_sink_f()\n        self.vsnk_phs = blocks.vector_sink_f()\n        self.connect((self.clk, 1), self.vsnk_err)\n        self.connect((self.clk, 2), self.vsnk_rat)\n        self.connect((self.clk, 3), self.vsnk_phs)\n    else:\n        mu = 0.5\n        gain_mu = bw\n        gain_omega = 0.25 * gain_mu * gain_mu\n        omega_rel_lim = 0.02\n        self.clk = digital.clock_recovery_mm_cc(sps, gain_omega, mu, gain_mu, omega_rel_lim)\n        self.vsnk_err = blocks.vector_sink_f()\n        self.connect((self.clk, 1), self.vsnk_err)\n    self.vsnk_src = blocks.vector_sink_c()\n    self.vsnk_clk = blocks.vector_sink_c()\n    self.connect(self.src, self.rrc, self.chn, self.off, self.clk, self.vsnk_clk)\n    self.connect(self.src, self.vsnk_src)",
            "def __init__(self, N, sps, rolloff, ntaps, bw, noise, foffset, toffset, poffset, mode=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    gr.top_block.__init__(self)\n    rrc_taps = filter.firdes.root_raised_cosine(sps, sps, 1.0, rolloff, ntaps)\n    gain = bw\n    nfilts = 32\n    rrc_taps_rx = filter.firdes.root_raised_cosine(nfilts, sps * nfilts, 1.0, rolloff, ntaps * nfilts)\n    data = 2.0 * numpy.random.randint(0, 2, N) - 1.0\n    data = numpy.exp(1j * poffset) * data\n    self.src = blocks.vector_source_c(data.tolist(), False)\n    self.rrc = filter.interp_fir_filter_ccf(sps, rrc_taps)\n    self.chn = channels.channel_model(noise, foffset, toffset)\n    self.off = filter.mmse_resampler_cc(0.2, 1.0)\n    if mode == 0:\n        self.clk = digital.pfb_clock_sync_ccf(sps, gain, rrc_taps_rx, nfilts, nfilts // 2, 1)\n        self.taps = self.clk.taps()\n        self.dtaps = self.clk.diff_taps()\n        self.delay = int(numpy.ceil(((len(rrc_taps) - 1) // 2 + (len(self.taps[0]) - 1) // 2) // float(sps))) + 1\n        self.vsnk_err = blocks.vector_sink_f()\n        self.vsnk_rat = blocks.vector_sink_f()\n        self.vsnk_phs = blocks.vector_sink_f()\n        self.connect((self.clk, 1), self.vsnk_err)\n        self.connect((self.clk, 2), self.vsnk_rat)\n        self.connect((self.clk, 3), self.vsnk_phs)\n    else:\n        mu = 0.5\n        gain_mu = bw\n        gain_omega = 0.25 * gain_mu * gain_mu\n        omega_rel_lim = 0.02\n        self.clk = digital.clock_recovery_mm_cc(sps, gain_omega, mu, gain_mu, omega_rel_lim)\n        self.vsnk_err = blocks.vector_sink_f()\n        self.connect((self.clk, 1), self.vsnk_err)\n    self.vsnk_src = blocks.vector_sink_c()\n    self.vsnk_clk = blocks.vector_sink_c()\n    self.connect(self.src, self.rrc, self.chn, self.off, self.clk, self.vsnk_clk)\n    self.connect(self.src, self.vsnk_src)",
            "def __init__(self, N, sps, rolloff, ntaps, bw, noise, foffset, toffset, poffset, mode=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    gr.top_block.__init__(self)\n    rrc_taps = filter.firdes.root_raised_cosine(sps, sps, 1.0, rolloff, ntaps)\n    gain = bw\n    nfilts = 32\n    rrc_taps_rx = filter.firdes.root_raised_cosine(nfilts, sps * nfilts, 1.0, rolloff, ntaps * nfilts)\n    data = 2.0 * numpy.random.randint(0, 2, N) - 1.0\n    data = numpy.exp(1j * poffset) * data\n    self.src = blocks.vector_source_c(data.tolist(), False)\n    self.rrc = filter.interp_fir_filter_ccf(sps, rrc_taps)\n    self.chn = channels.channel_model(noise, foffset, toffset)\n    self.off = filter.mmse_resampler_cc(0.2, 1.0)\n    if mode == 0:\n        self.clk = digital.pfb_clock_sync_ccf(sps, gain, rrc_taps_rx, nfilts, nfilts // 2, 1)\n        self.taps = self.clk.taps()\n        self.dtaps = self.clk.diff_taps()\n        self.delay = int(numpy.ceil(((len(rrc_taps) - 1) // 2 + (len(self.taps[0]) - 1) // 2) // float(sps))) + 1\n        self.vsnk_err = blocks.vector_sink_f()\n        self.vsnk_rat = blocks.vector_sink_f()\n        self.vsnk_phs = blocks.vector_sink_f()\n        self.connect((self.clk, 1), self.vsnk_err)\n        self.connect((self.clk, 2), self.vsnk_rat)\n        self.connect((self.clk, 3), self.vsnk_phs)\n    else:\n        mu = 0.5\n        gain_mu = bw\n        gain_omega = 0.25 * gain_mu * gain_mu\n        omega_rel_lim = 0.02\n        self.clk = digital.clock_recovery_mm_cc(sps, gain_omega, mu, gain_mu, omega_rel_lim)\n        self.vsnk_err = blocks.vector_sink_f()\n        self.connect((self.clk, 1), self.vsnk_err)\n    self.vsnk_src = blocks.vector_sink_c()\n    self.vsnk_clk = blocks.vector_sink_c()\n    self.connect(self.src, self.rrc, self.chn, self.off, self.clk, self.vsnk_clk)\n    self.connect(self.src, self.vsnk_src)",
            "def __init__(self, N, sps, rolloff, ntaps, bw, noise, foffset, toffset, poffset, mode=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    gr.top_block.__init__(self)\n    rrc_taps = filter.firdes.root_raised_cosine(sps, sps, 1.0, rolloff, ntaps)\n    gain = bw\n    nfilts = 32\n    rrc_taps_rx = filter.firdes.root_raised_cosine(nfilts, sps * nfilts, 1.0, rolloff, ntaps * nfilts)\n    data = 2.0 * numpy.random.randint(0, 2, N) - 1.0\n    data = numpy.exp(1j * poffset) * data\n    self.src = blocks.vector_source_c(data.tolist(), False)\n    self.rrc = filter.interp_fir_filter_ccf(sps, rrc_taps)\n    self.chn = channels.channel_model(noise, foffset, toffset)\n    self.off = filter.mmse_resampler_cc(0.2, 1.0)\n    if mode == 0:\n        self.clk = digital.pfb_clock_sync_ccf(sps, gain, rrc_taps_rx, nfilts, nfilts // 2, 1)\n        self.taps = self.clk.taps()\n        self.dtaps = self.clk.diff_taps()\n        self.delay = int(numpy.ceil(((len(rrc_taps) - 1) // 2 + (len(self.taps[0]) - 1) // 2) // float(sps))) + 1\n        self.vsnk_err = blocks.vector_sink_f()\n        self.vsnk_rat = blocks.vector_sink_f()\n        self.vsnk_phs = blocks.vector_sink_f()\n        self.connect((self.clk, 1), self.vsnk_err)\n        self.connect((self.clk, 2), self.vsnk_rat)\n        self.connect((self.clk, 3), self.vsnk_phs)\n    else:\n        mu = 0.5\n        gain_mu = bw\n        gain_omega = 0.25 * gain_mu * gain_mu\n        omega_rel_lim = 0.02\n        self.clk = digital.clock_recovery_mm_cc(sps, gain_omega, mu, gain_mu, omega_rel_lim)\n        self.vsnk_err = blocks.vector_sink_f()\n        self.connect((self.clk, 1), self.vsnk_err)\n    self.vsnk_src = blocks.vector_sink_c()\n    self.vsnk_clk = blocks.vector_sink_c()\n    self.connect(self.src, self.rrc, self.chn, self.off, self.clk, self.vsnk_clk)\n    self.connect(self.src, self.vsnk_src)"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    parser = ArgumentParser(conflict_handler='resolve')\n    parser.add_argument('-N', '--nsamples', type=int, default=2000, help='Set the number of samples to process [default=%(default)r]')\n    parser.add_argument('-S', '--sps', type=int, default=4, help='Set the samples per symbol [default=%(default)r]')\n    parser.add_argument('-r', '--rolloff', type=eng_float, default=0.35, help='Set the rolloff factor [default=%(default)r]')\n    parser.add_argument('-W', '--bandwidth', type=eng_float, default=2 * numpy.pi / 100.0, help='Set the loop bandwidth (PFB) or gain (M&M) [default=%(default)r]')\n    parser.add_argument('-n', '--ntaps', type=int, default=45, help='Set the number of taps in the filters [default=%(default)r]')\n    parser.add_argument('--noise', type=eng_float, default=0.0, help='Set the simulation noise voltage [default=%(default)r]')\n    parser.add_argument('-f', '--foffset', type=eng_float, default=0.0, help=\"Set the simulation's normalized frequency offset (in Hz) [default=%(default)r]\")\n    parser.add_argument('-t', '--toffset', type=eng_float, default=1.0, help=\"Set the simulation's timing offset [default=%(default)r]\")\n    parser.add_argument('-p', '--poffset', type=eng_float, default=0.0, help=\"Set the simulation's phase offset [default=%(default)r]\")\n    parser.add_argument('-M', '--mode', type=int, default=0, help='Set the recovery mode (0: polyphase, 1: M&M) [default=%(default)r]')\n    args = parser.parse_args()\n    args.nsamples = args.nsamples // args.sps\n    put = example_timing(args.nsamples, args.sps, args.rolloff, args.ntaps, args.bandwidth, args.noise, args.foffset, args.toffset, args.poffset, args.mode)\n    put.run()\n    if args.mode == 0:\n        data_src = numpy.array(put.vsnk_src.data()[20:])\n        data_clk = numpy.array(put.vsnk_clk.data()[20:])\n        data_err = numpy.array(put.vsnk_err.data()[20:])\n        data_rat = numpy.array(put.vsnk_rat.data()[20:])\n        data_phs = numpy.array(put.vsnk_phs.data()[20:])\n        f1 = pyplot.figure(1, figsize=(12, 10), facecolor='w')\n        s1 = f1.add_subplot(2, 2, 1)\n        s1.plot(data_src.real, data_src.imag, 'bo')\n        s1.plot(data_clk.real, data_clk.imag, 'ro')\n        s1.set_title('IQ')\n        s1.set_xlabel('Real part')\n        s1.set_ylabel('Imag part')\n        s1.set_xlim([-2, 2])\n        s1.set_ylim([-2, 2])\n        delay = put.delay\n        m = len(data_clk.real)\n        s2 = f1.add_subplot(2, 2, 2)\n        s2.plot(data_src.real, 'bs', markersize=10, label='Input')\n        s2.plot(data_clk.real[delay:], 'ro', label='Recovered')\n        s2.set_title('Symbols')\n        s2.set_xlabel('Samples')\n        s2.set_ylabel('Real Part of Signals')\n        s2.legend()\n        s3 = f1.add_subplot(2, 2, 3)\n        s3.plot(data_err, label='Error')\n        s3.plot(data_rat, 'r', label='Update rate')\n        s3.set_title('Clock Recovery Loop Error')\n        s3.set_xlabel('Samples')\n        s3.set_ylabel('Error')\n        s3.set_ylim([-0.5, 0.5])\n        s3.legend()\n        s4 = f1.add_subplot(2, 2, 4)\n        s4.plot(data_phs)\n        s4.set_title('Clock Recovery Loop Filter Phase')\n        s4.set_xlabel('Samples')\n        s4.set_ylabel('Filter Phase')\n        diff_taps = put.dtaps\n        ntaps = len(diff_taps[0])\n        nfilts = len(diff_taps)\n        t = numpy.arange(0, ntaps * nfilts)\n        f3 = pyplot.figure(3, figsize=(12, 10), facecolor='w')\n        s31 = f3.add_subplot(2, 1, 1)\n        s32 = f3.add_subplot(2, 1, 2)\n        s31.set_title('Differential Filters')\n        s32.set_title('FFT of Differential Filters')\n        for (i, d) in enumerate(diff_taps):\n            D = 20.0 * numpy.log10(1e-20 + abs(numpy.fft.fftshift(numpy.fft.fft(d, 10000))))\n            s31.plot(t[i::nfilts].real, d, '-o')\n            s32.plot(D)\n        s32.set_ylim([-120, 10])\n    else:\n        data_src = numpy.array(put.vsnk_src.data()[20:])\n        data_clk = numpy.array(put.vsnk_clk.data()[20:])\n        data_err = numpy.array(put.vsnk_err.data()[20:])\n        f1 = pyplot.figure(1, figsize=(12, 10), facecolor='w')\n        s1 = f1.add_subplot(2, 2, 1)\n        s1.plot(data_src.real, data_src.imag, 'o')\n        s1.plot(data_clk.real, data_clk.imag, 'ro')\n        s1.set_title('IQ')\n        s1.set_xlabel('Real part')\n        s1.set_ylabel('Imag part')\n        s1.set_xlim([-2, 2])\n        s1.set_ylim([-2, 2])\n        s2 = f1.add_subplot(2, 2, 2)\n        s2.plot(data_src.real, 'bs', markersize=10, label='Input')\n        s2.plot(data_clk.real, 'ro', label='Recovered')\n        s2.set_title('Symbols')\n        s2.set_xlabel('Samples')\n        s2.set_ylabel('Real Part of Signals')\n        s2.legend()\n        s3 = f1.add_subplot(2, 2, 3)\n        s3.plot(data_err)\n        s3.set_title('Clock Recovery Loop Error')\n        s3.set_xlabel('Samples')\n        s3.set_ylabel('Error')\n    pyplot.show()",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    parser = ArgumentParser(conflict_handler='resolve')\n    parser.add_argument('-N', '--nsamples', type=int, default=2000, help='Set the number of samples to process [default=%(default)r]')\n    parser.add_argument('-S', '--sps', type=int, default=4, help='Set the samples per symbol [default=%(default)r]')\n    parser.add_argument('-r', '--rolloff', type=eng_float, default=0.35, help='Set the rolloff factor [default=%(default)r]')\n    parser.add_argument('-W', '--bandwidth', type=eng_float, default=2 * numpy.pi / 100.0, help='Set the loop bandwidth (PFB) or gain (M&M) [default=%(default)r]')\n    parser.add_argument('-n', '--ntaps', type=int, default=45, help='Set the number of taps in the filters [default=%(default)r]')\n    parser.add_argument('--noise', type=eng_float, default=0.0, help='Set the simulation noise voltage [default=%(default)r]')\n    parser.add_argument('-f', '--foffset', type=eng_float, default=0.0, help=\"Set the simulation's normalized frequency offset (in Hz) [default=%(default)r]\")\n    parser.add_argument('-t', '--toffset', type=eng_float, default=1.0, help=\"Set the simulation's timing offset [default=%(default)r]\")\n    parser.add_argument('-p', '--poffset', type=eng_float, default=0.0, help=\"Set the simulation's phase offset [default=%(default)r]\")\n    parser.add_argument('-M', '--mode', type=int, default=0, help='Set the recovery mode (0: polyphase, 1: M&M) [default=%(default)r]')\n    args = parser.parse_args()\n    args.nsamples = args.nsamples // args.sps\n    put = example_timing(args.nsamples, args.sps, args.rolloff, args.ntaps, args.bandwidth, args.noise, args.foffset, args.toffset, args.poffset, args.mode)\n    put.run()\n    if args.mode == 0:\n        data_src = numpy.array(put.vsnk_src.data()[20:])\n        data_clk = numpy.array(put.vsnk_clk.data()[20:])\n        data_err = numpy.array(put.vsnk_err.data()[20:])\n        data_rat = numpy.array(put.vsnk_rat.data()[20:])\n        data_phs = numpy.array(put.vsnk_phs.data()[20:])\n        f1 = pyplot.figure(1, figsize=(12, 10), facecolor='w')\n        s1 = f1.add_subplot(2, 2, 1)\n        s1.plot(data_src.real, data_src.imag, 'bo')\n        s1.plot(data_clk.real, data_clk.imag, 'ro')\n        s1.set_title('IQ')\n        s1.set_xlabel('Real part')\n        s1.set_ylabel('Imag part')\n        s1.set_xlim([-2, 2])\n        s1.set_ylim([-2, 2])\n        delay = put.delay\n        m = len(data_clk.real)\n        s2 = f1.add_subplot(2, 2, 2)\n        s2.plot(data_src.real, 'bs', markersize=10, label='Input')\n        s2.plot(data_clk.real[delay:], 'ro', label='Recovered')\n        s2.set_title('Symbols')\n        s2.set_xlabel('Samples')\n        s2.set_ylabel('Real Part of Signals')\n        s2.legend()\n        s3 = f1.add_subplot(2, 2, 3)\n        s3.plot(data_err, label='Error')\n        s3.plot(data_rat, 'r', label='Update rate')\n        s3.set_title('Clock Recovery Loop Error')\n        s3.set_xlabel('Samples')\n        s3.set_ylabel('Error')\n        s3.set_ylim([-0.5, 0.5])\n        s3.legend()\n        s4 = f1.add_subplot(2, 2, 4)\n        s4.plot(data_phs)\n        s4.set_title('Clock Recovery Loop Filter Phase')\n        s4.set_xlabel('Samples')\n        s4.set_ylabel('Filter Phase')\n        diff_taps = put.dtaps\n        ntaps = len(diff_taps[0])\n        nfilts = len(diff_taps)\n        t = numpy.arange(0, ntaps * nfilts)\n        f3 = pyplot.figure(3, figsize=(12, 10), facecolor='w')\n        s31 = f3.add_subplot(2, 1, 1)\n        s32 = f3.add_subplot(2, 1, 2)\n        s31.set_title('Differential Filters')\n        s32.set_title('FFT of Differential Filters')\n        for (i, d) in enumerate(diff_taps):\n            D = 20.0 * numpy.log10(1e-20 + abs(numpy.fft.fftshift(numpy.fft.fft(d, 10000))))\n            s31.plot(t[i::nfilts].real, d, '-o')\n            s32.plot(D)\n        s32.set_ylim([-120, 10])\n    else:\n        data_src = numpy.array(put.vsnk_src.data()[20:])\n        data_clk = numpy.array(put.vsnk_clk.data()[20:])\n        data_err = numpy.array(put.vsnk_err.data()[20:])\n        f1 = pyplot.figure(1, figsize=(12, 10), facecolor='w')\n        s1 = f1.add_subplot(2, 2, 1)\n        s1.plot(data_src.real, data_src.imag, 'o')\n        s1.plot(data_clk.real, data_clk.imag, 'ro')\n        s1.set_title('IQ')\n        s1.set_xlabel('Real part')\n        s1.set_ylabel('Imag part')\n        s1.set_xlim([-2, 2])\n        s1.set_ylim([-2, 2])\n        s2 = f1.add_subplot(2, 2, 2)\n        s2.plot(data_src.real, 'bs', markersize=10, label='Input')\n        s2.plot(data_clk.real, 'ro', label='Recovered')\n        s2.set_title('Symbols')\n        s2.set_xlabel('Samples')\n        s2.set_ylabel('Real Part of Signals')\n        s2.legend()\n        s3 = f1.add_subplot(2, 2, 3)\n        s3.plot(data_err)\n        s3.set_title('Clock Recovery Loop Error')\n        s3.set_xlabel('Samples')\n        s3.set_ylabel('Error')\n    pyplot.show()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = ArgumentParser(conflict_handler='resolve')\n    parser.add_argument('-N', '--nsamples', type=int, default=2000, help='Set the number of samples to process [default=%(default)r]')\n    parser.add_argument('-S', '--sps', type=int, default=4, help='Set the samples per symbol [default=%(default)r]')\n    parser.add_argument('-r', '--rolloff', type=eng_float, default=0.35, help='Set the rolloff factor [default=%(default)r]')\n    parser.add_argument('-W', '--bandwidth', type=eng_float, default=2 * numpy.pi / 100.0, help='Set the loop bandwidth (PFB) or gain (M&M) [default=%(default)r]')\n    parser.add_argument('-n', '--ntaps', type=int, default=45, help='Set the number of taps in the filters [default=%(default)r]')\n    parser.add_argument('--noise', type=eng_float, default=0.0, help='Set the simulation noise voltage [default=%(default)r]')\n    parser.add_argument('-f', '--foffset', type=eng_float, default=0.0, help=\"Set the simulation's normalized frequency offset (in Hz) [default=%(default)r]\")\n    parser.add_argument('-t', '--toffset', type=eng_float, default=1.0, help=\"Set the simulation's timing offset [default=%(default)r]\")\n    parser.add_argument('-p', '--poffset', type=eng_float, default=0.0, help=\"Set the simulation's phase offset [default=%(default)r]\")\n    parser.add_argument('-M', '--mode', type=int, default=0, help='Set the recovery mode (0: polyphase, 1: M&M) [default=%(default)r]')\n    args = parser.parse_args()\n    args.nsamples = args.nsamples // args.sps\n    put = example_timing(args.nsamples, args.sps, args.rolloff, args.ntaps, args.bandwidth, args.noise, args.foffset, args.toffset, args.poffset, args.mode)\n    put.run()\n    if args.mode == 0:\n        data_src = numpy.array(put.vsnk_src.data()[20:])\n        data_clk = numpy.array(put.vsnk_clk.data()[20:])\n        data_err = numpy.array(put.vsnk_err.data()[20:])\n        data_rat = numpy.array(put.vsnk_rat.data()[20:])\n        data_phs = numpy.array(put.vsnk_phs.data()[20:])\n        f1 = pyplot.figure(1, figsize=(12, 10), facecolor='w')\n        s1 = f1.add_subplot(2, 2, 1)\n        s1.plot(data_src.real, data_src.imag, 'bo')\n        s1.plot(data_clk.real, data_clk.imag, 'ro')\n        s1.set_title('IQ')\n        s1.set_xlabel('Real part')\n        s1.set_ylabel('Imag part')\n        s1.set_xlim([-2, 2])\n        s1.set_ylim([-2, 2])\n        delay = put.delay\n        m = len(data_clk.real)\n        s2 = f1.add_subplot(2, 2, 2)\n        s2.plot(data_src.real, 'bs', markersize=10, label='Input')\n        s2.plot(data_clk.real[delay:], 'ro', label='Recovered')\n        s2.set_title('Symbols')\n        s2.set_xlabel('Samples')\n        s2.set_ylabel('Real Part of Signals')\n        s2.legend()\n        s3 = f1.add_subplot(2, 2, 3)\n        s3.plot(data_err, label='Error')\n        s3.plot(data_rat, 'r', label='Update rate')\n        s3.set_title('Clock Recovery Loop Error')\n        s3.set_xlabel('Samples')\n        s3.set_ylabel('Error')\n        s3.set_ylim([-0.5, 0.5])\n        s3.legend()\n        s4 = f1.add_subplot(2, 2, 4)\n        s4.plot(data_phs)\n        s4.set_title('Clock Recovery Loop Filter Phase')\n        s4.set_xlabel('Samples')\n        s4.set_ylabel('Filter Phase')\n        diff_taps = put.dtaps\n        ntaps = len(diff_taps[0])\n        nfilts = len(diff_taps)\n        t = numpy.arange(0, ntaps * nfilts)\n        f3 = pyplot.figure(3, figsize=(12, 10), facecolor='w')\n        s31 = f3.add_subplot(2, 1, 1)\n        s32 = f3.add_subplot(2, 1, 2)\n        s31.set_title('Differential Filters')\n        s32.set_title('FFT of Differential Filters')\n        for (i, d) in enumerate(diff_taps):\n            D = 20.0 * numpy.log10(1e-20 + abs(numpy.fft.fftshift(numpy.fft.fft(d, 10000))))\n            s31.plot(t[i::nfilts].real, d, '-o')\n            s32.plot(D)\n        s32.set_ylim([-120, 10])\n    else:\n        data_src = numpy.array(put.vsnk_src.data()[20:])\n        data_clk = numpy.array(put.vsnk_clk.data()[20:])\n        data_err = numpy.array(put.vsnk_err.data()[20:])\n        f1 = pyplot.figure(1, figsize=(12, 10), facecolor='w')\n        s1 = f1.add_subplot(2, 2, 1)\n        s1.plot(data_src.real, data_src.imag, 'o')\n        s1.plot(data_clk.real, data_clk.imag, 'ro')\n        s1.set_title('IQ')\n        s1.set_xlabel('Real part')\n        s1.set_ylabel('Imag part')\n        s1.set_xlim([-2, 2])\n        s1.set_ylim([-2, 2])\n        s2 = f1.add_subplot(2, 2, 2)\n        s2.plot(data_src.real, 'bs', markersize=10, label='Input')\n        s2.plot(data_clk.real, 'ro', label='Recovered')\n        s2.set_title('Symbols')\n        s2.set_xlabel('Samples')\n        s2.set_ylabel('Real Part of Signals')\n        s2.legend()\n        s3 = f1.add_subplot(2, 2, 3)\n        s3.plot(data_err)\n        s3.set_title('Clock Recovery Loop Error')\n        s3.set_xlabel('Samples')\n        s3.set_ylabel('Error')\n    pyplot.show()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = ArgumentParser(conflict_handler='resolve')\n    parser.add_argument('-N', '--nsamples', type=int, default=2000, help='Set the number of samples to process [default=%(default)r]')\n    parser.add_argument('-S', '--sps', type=int, default=4, help='Set the samples per symbol [default=%(default)r]')\n    parser.add_argument('-r', '--rolloff', type=eng_float, default=0.35, help='Set the rolloff factor [default=%(default)r]')\n    parser.add_argument('-W', '--bandwidth', type=eng_float, default=2 * numpy.pi / 100.0, help='Set the loop bandwidth (PFB) or gain (M&M) [default=%(default)r]')\n    parser.add_argument('-n', '--ntaps', type=int, default=45, help='Set the number of taps in the filters [default=%(default)r]')\n    parser.add_argument('--noise', type=eng_float, default=0.0, help='Set the simulation noise voltage [default=%(default)r]')\n    parser.add_argument('-f', '--foffset', type=eng_float, default=0.0, help=\"Set the simulation's normalized frequency offset (in Hz) [default=%(default)r]\")\n    parser.add_argument('-t', '--toffset', type=eng_float, default=1.0, help=\"Set the simulation's timing offset [default=%(default)r]\")\n    parser.add_argument('-p', '--poffset', type=eng_float, default=0.0, help=\"Set the simulation's phase offset [default=%(default)r]\")\n    parser.add_argument('-M', '--mode', type=int, default=0, help='Set the recovery mode (0: polyphase, 1: M&M) [default=%(default)r]')\n    args = parser.parse_args()\n    args.nsamples = args.nsamples // args.sps\n    put = example_timing(args.nsamples, args.sps, args.rolloff, args.ntaps, args.bandwidth, args.noise, args.foffset, args.toffset, args.poffset, args.mode)\n    put.run()\n    if args.mode == 0:\n        data_src = numpy.array(put.vsnk_src.data()[20:])\n        data_clk = numpy.array(put.vsnk_clk.data()[20:])\n        data_err = numpy.array(put.vsnk_err.data()[20:])\n        data_rat = numpy.array(put.vsnk_rat.data()[20:])\n        data_phs = numpy.array(put.vsnk_phs.data()[20:])\n        f1 = pyplot.figure(1, figsize=(12, 10), facecolor='w')\n        s1 = f1.add_subplot(2, 2, 1)\n        s1.plot(data_src.real, data_src.imag, 'bo')\n        s1.plot(data_clk.real, data_clk.imag, 'ro')\n        s1.set_title('IQ')\n        s1.set_xlabel('Real part')\n        s1.set_ylabel('Imag part')\n        s1.set_xlim([-2, 2])\n        s1.set_ylim([-2, 2])\n        delay = put.delay\n        m = len(data_clk.real)\n        s2 = f1.add_subplot(2, 2, 2)\n        s2.plot(data_src.real, 'bs', markersize=10, label='Input')\n        s2.plot(data_clk.real[delay:], 'ro', label='Recovered')\n        s2.set_title('Symbols')\n        s2.set_xlabel('Samples')\n        s2.set_ylabel('Real Part of Signals')\n        s2.legend()\n        s3 = f1.add_subplot(2, 2, 3)\n        s3.plot(data_err, label='Error')\n        s3.plot(data_rat, 'r', label='Update rate')\n        s3.set_title('Clock Recovery Loop Error')\n        s3.set_xlabel('Samples')\n        s3.set_ylabel('Error')\n        s3.set_ylim([-0.5, 0.5])\n        s3.legend()\n        s4 = f1.add_subplot(2, 2, 4)\n        s4.plot(data_phs)\n        s4.set_title('Clock Recovery Loop Filter Phase')\n        s4.set_xlabel('Samples')\n        s4.set_ylabel('Filter Phase')\n        diff_taps = put.dtaps\n        ntaps = len(diff_taps[0])\n        nfilts = len(diff_taps)\n        t = numpy.arange(0, ntaps * nfilts)\n        f3 = pyplot.figure(3, figsize=(12, 10), facecolor='w')\n        s31 = f3.add_subplot(2, 1, 1)\n        s32 = f3.add_subplot(2, 1, 2)\n        s31.set_title('Differential Filters')\n        s32.set_title('FFT of Differential Filters')\n        for (i, d) in enumerate(diff_taps):\n            D = 20.0 * numpy.log10(1e-20 + abs(numpy.fft.fftshift(numpy.fft.fft(d, 10000))))\n            s31.plot(t[i::nfilts].real, d, '-o')\n            s32.plot(D)\n        s32.set_ylim([-120, 10])\n    else:\n        data_src = numpy.array(put.vsnk_src.data()[20:])\n        data_clk = numpy.array(put.vsnk_clk.data()[20:])\n        data_err = numpy.array(put.vsnk_err.data()[20:])\n        f1 = pyplot.figure(1, figsize=(12, 10), facecolor='w')\n        s1 = f1.add_subplot(2, 2, 1)\n        s1.plot(data_src.real, data_src.imag, 'o')\n        s1.plot(data_clk.real, data_clk.imag, 'ro')\n        s1.set_title('IQ')\n        s1.set_xlabel('Real part')\n        s1.set_ylabel('Imag part')\n        s1.set_xlim([-2, 2])\n        s1.set_ylim([-2, 2])\n        s2 = f1.add_subplot(2, 2, 2)\n        s2.plot(data_src.real, 'bs', markersize=10, label='Input')\n        s2.plot(data_clk.real, 'ro', label='Recovered')\n        s2.set_title('Symbols')\n        s2.set_xlabel('Samples')\n        s2.set_ylabel('Real Part of Signals')\n        s2.legend()\n        s3 = f1.add_subplot(2, 2, 3)\n        s3.plot(data_err)\n        s3.set_title('Clock Recovery Loop Error')\n        s3.set_xlabel('Samples')\n        s3.set_ylabel('Error')\n    pyplot.show()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = ArgumentParser(conflict_handler='resolve')\n    parser.add_argument('-N', '--nsamples', type=int, default=2000, help='Set the number of samples to process [default=%(default)r]')\n    parser.add_argument('-S', '--sps', type=int, default=4, help='Set the samples per symbol [default=%(default)r]')\n    parser.add_argument('-r', '--rolloff', type=eng_float, default=0.35, help='Set the rolloff factor [default=%(default)r]')\n    parser.add_argument('-W', '--bandwidth', type=eng_float, default=2 * numpy.pi / 100.0, help='Set the loop bandwidth (PFB) or gain (M&M) [default=%(default)r]')\n    parser.add_argument('-n', '--ntaps', type=int, default=45, help='Set the number of taps in the filters [default=%(default)r]')\n    parser.add_argument('--noise', type=eng_float, default=0.0, help='Set the simulation noise voltage [default=%(default)r]')\n    parser.add_argument('-f', '--foffset', type=eng_float, default=0.0, help=\"Set the simulation's normalized frequency offset (in Hz) [default=%(default)r]\")\n    parser.add_argument('-t', '--toffset', type=eng_float, default=1.0, help=\"Set the simulation's timing offset [default=%(default)r]\")\n    parser.add_argument('-p', '--poffset', type=eng_float, default=0.0, help=\"Set the simulation's phase offset [default=%(default)r]\")\n    parser.add_argument('-M', '--mode', type=int, default=0, help='Set the recovery mode (0: polyphase, 1: M&M) [default=%(default)r]')\n    args = parser.parse_args()\n    args.nsamples = args.nsamples // args.sps\n    put = example_timing(args.nsamples, args.sps, args.rolloff, args.ntaps, args.bandwidth, args.noise, args.foffset, args.toffset, args.poffset, args.mode)\n    put.run()\n    if args.mode == 0:\n        data_src = numpy.array(put.vsnk_src.data()[20:])\n        data_clk = numpy.array(put.vsnk_clk.data()[20:])\n        data_err = numpy.array(put.vsnk_err.data()[20:])\n        data_rat = numpy.array(put.vsnk_rat.data()[20:])\n        data_phs = numpy.array(put.vsnk_phs.data()[20:])\n        f1 = pyplot.figure(1, figsize=(12, 10), facecolor='w')\n        s1 = f1.add_subplot(2, 2, 1)\n        s1.plot(data_src.real, data_src.imag, 'bo')\n        s1.plot(data_clk.real, data_clk.imag, 'ro')\n        s1.set_title('IQ')\n        s1.set_xlabel('Real part')\n        s1.set_ylabel('Imag part')\n        s1.set_xlim([-2, 2])\n        s1.set_ylim([-2, 2])\n        delay = put.delay\n        m = len(data_clk.real)\n        s2 = f1.add_subplot(2, 2, 2)\n        s2.plot(data_src.real, 'bs', markersize=10, label='Input')\n        s2.plot(data_clk.real[delay:], 'ro', label='Recovered')\n        s2.set_title('Symbols')\n        s2.set_xlabel('Samples')\n        s2.set_ylabel('Real Part of Signals')\n        s2.legend()\n        s3 = f1.add_subplot(2, 2, 3)\n        s3.plot(data_err, label='Error')\n        s3.plot(data_rat, 'r', label='Update rate')\n        s3.set_title('Clock Recovery Loop Error')\n        s3.set_xlabel('Samples')\n        s3.set_ylabel('Error')\n        s3.set_ylim([-0.5, 0.5])\n        s3.legend()\n        s4 = f1.add_subplot(2, 2, 4)\n        s4.plot(data_phs)\n        s4.set_title('Clock Recovery Loop Filter Phase')\n        s4.set_xlabel('Samples')\n        s4.set_ylabel('Filter Phase')\n        diff_taps = put.dtaps\n        ntaps = len(diff_taps[0])\n        nfilts = len(diff_taps)\n        t = numpy.arange(0, ntaps * nfilts)\n        f3 = pyplot.figure(3, figsize=(12, 10), facecolor='w')\n        s31 = f3.add_subplot(2, 1, 1)\n        s32 = f3.add_subplot(2, 1, 2)\n        s31.set_title('Differential Filters')\n        s32.set_title('FFT of Differential Filters')\n        for (i, d) in enumerate(diff_taps):\n            D = 20.0 * numpy.log10(1e-20 + abs(numpy.fft.fftshift(numpy.fft.fft(d, 10000))))\n            s31.plot(t[i::nfilts].real, d, '-o')\n            s32.plot(D)\n        s32.set_ylim([-120, 10])\n    else:\n        data_src = numpy.array(put.vsnk_src.data()[20:])\n        data_clk = numpy.array(put.vsnk_clk.data()[20:])\n        data_err = numpy.array(put.vsnk_err.data()[20:])\n        f1 = pyplot.figure(1, figsize=(12, 10), facecolor='w')\n        s1 = f1.add_subplot(2, 2, 1)\n        s1.plot(data_src.real, data_src.imag, 'o')\n        s1.plot(data_clk.real, data_clk.imag, 'ro')\n        s1.set_title('IQ')\n        s1.set_xlabel('Real part')\n        s1.set_ylabel('Imag part')\n        s1.set_xlim([-2, 2])\n        s1.set_ylim([-2, 2])\n        s2 = f1.add_subplot(2, 2, 2)\n        s2.plot(data_src.real, 'bs', markersize=10, label='Input')\n        s2.plot(data_clk.real, 'ro', label='Recovered')\n        s2.set_title('Symbols')\n        s2.set_xlabel('Samples')\n        s2.set_ylabel('Real Part of Signals')\n        s2.legend()\n        s3 = f1.add_subplot(2, 2, 3)\n        s3.plot(data_err)\n        s3.set_title('Clock Recovery Loop Error')\n        s3.set_xlabel('Samples')\n        s3.set_ylabel('Error')\n    pyplot.show()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = ArgumentParser(conflict_handler='resolve')\n    parser.add_argument('-N', '--nsamples', type=int, default=2000, help='Set the number of samples to process [default=%(default)r]')\n    parser.add_argument('-S', '--sps', type=int, default=4, help='Set the samples per symbol [default=%(default)r]')\n    parser.add_argument('-r', '--rolloff', type=eng_float, default=0.35, help='Set the rolloff factor [default=%(default)r]')\n    parser.add_argument('-W', '--bandwidth', type=eng_float, default=2 * numpy.pi / 100.0, help='Set the loop bandwidth (PFB) or gain (M&M) [default=%(default)r]')\n    parser.add_argument('-n', '--ntaps', type=int, default=45, help='Set the number of taps in the filters [default=%(default)r]')\n    parser.add_argument('--noise', type=eng_float, default=0.0, help='Set the simulation noise voltage [default=%(default)r]')\n    parser.add_argument('-f', '--foffset', type=eng_float, default=0.0, help=\"Set the simulation's normalized frequency offset (in Hz) [default=%(default)r]\")\n    parser.add_argument('-t', '--toffset', type=eng_float, default=1.0, help=\"Set the simulation's timing offset [default=%(default)r]\")\n    parser.add_argument('-p', '--poffset', type=eng_float, default=0.0, help=\"Set the simulation's phase offset [default=%(default)r]\")\n    parser.add_argument('-M', '--mode', type=int, default=0, help='Set the recovery mode (0: polyphase, 1: M&M) [default=%(default)r]')\n    args = parser.parse_args()\n    args.nsamples = args.nsamples // args.sps\n    put = example_timing(args.nsamples, args.sps, args.rolloff, args.ntaps, args.bandwidth, args.noise, args.foffset, args.toffset, args.poffset, args.mode)\n    put.run()\n    if args.mode == 0:\n        data_src = numpy.array(put.vsnk_src.data()[20:])\n        data_clk = numpy.array(put.vsnk_clk.data()[20:])\n        data_err = numpy.array(put.vsnk_err.data()[20:])\n        data_rat = numpy.array(put.vsnk_rat.data()[20:])\n        data_phs = numpy.array(put.vsnk_phs.data()[20:])\n        f1 = pyplot.figure(1, figsize=(12, 10), facecolor='w')\n        s1 = f1.add_subplot(2, 2, 1)\n        s1.plot(data_src.real, data_src.imag, 'bo')\n        s1.plot(data_clk.real, data_clk.imag, 'ro')\n        s1.set_title('IQ')\n        s1.set_xlabel('Real part')\n        s1.set_ylabel('Imag part')\n        s1.set_xlim([-2, 2])\n        s1.set_ylim([-2, 2])\n        delay = put.delay\n        m = len(data_clk.real)\n        s2 = f1.add_subplot(2, 2, 2)\n        s2.plot(data_src.real, 'bs', markersize=10, label='Input')\n        s2.plot(data_clk.real[delay:], 'ro', label='Recovered')\n        s2.set_title('Symbols')\n        s2.set_xlabel('Samples')\n        s2.set_ylabel('Real Part of Signals')\n        s2.legend()\n        s3 = f1.add_subplot(2, 2, 3)\n        s3.plot(data_err, label='Error')\n        s3.plot(data_rat, 'r', label='Update rate')\n        s3.set_title('Clock Recovery Loop Error')\n        s3.set_xlabel('Samples')\n        s3.set_ylabel('Error')\n        s3.set_ylim([-0.5, 0.5])\n        s3.legend()\n        s4 = f1.add_subplot(2, 2, 4)\n        s4.plot(data_phs)\n        s4.set_title('Clock Recovery Loop Filter Phase')\n        s4.set_xlabel('Samples')\n        s4.set_ylabel('Filter Phase')\n        diff_taps = put.dtaps\n        ntaps = len(diff_taps[0])\n        nfilts = len(diff_taps)\n        t = numpy.arange(0, ntaps * nfilts)\n        f3 = pyplot.figure(3, figsize=(12, 10), facecolor='w')\n        s31 = f3.add_subplot(2, 1, 1)\n        s32 = f3.add_subplot(2, 1, 2)\n        s31.set_title('Differential Filters')\n        s32.set_title('FFT of Differential Filters')\n        for (i, d) in enumerate(diff_taps):\n            D = 20.0 * numpy.log10(1e-20 + abs(numpy.fft.fftshift(numpy.fft.fft(d, 10000))))\n            s31.plot(t[i::nfilts].real, d, '-o')\n            s32.plot(D)\n        s32.set_ylim([-120, 10])\n    else:\n        data_src = numpy.array(put.vsnk_src.data()[20:])\n        data_clk = numpy.array(put.vsnk_clk.data()[20:])\n        data_err = numpy.array(put.vsnk_err.data()[20:])\n        f1 = pyplot.figure(1, figsize=(12, 10), facecolor='w')\n        s1 = f1.add_subplot(2, 2, 1)\n        s1.plot(data_src.real, data_src.imag, 'o')\n        s1.plot(data_clk.real, data_clk.imag, 'ro')\n        s1.set_title('IQ')\n        s1.set_xlabel('Real part')\n        s1.set_ylabel('Imag part')\n        s1.set_xlim([-2, 2])\n        s1.set_ylim([-2, 2])\n        s2 = f1.add_subplot(2, 2, 2)\n        s2.plot(data_src.real, 'bs', markersize=10, label='Input')\n        s2.plot(data_clk.real, 'ro', label='Recovered')\n        s2.set_title('Symbols')\n        s2.set_xlabel('Samples')\n        s2.set_ylabel('Real Part of Signals')\n        s2.legend()\n        s3 = f1.add_subplot(2, 2, 3)\n        s3.plot(data_err)\n        s3.set_title('Clock Recovery Loop Error')\n        s3.set_xlabel('Samples')\n        s3.set_ylabel('Error')\n    pyplot.show()"
        ]
    }
]