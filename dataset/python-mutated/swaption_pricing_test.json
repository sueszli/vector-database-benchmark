[
    {
        "func_name": "_fn",
        "original": "def _fn():\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=time_step, num_time_steps=num_time_steps, curve_times=curve_times, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    return price",
        "mutated": [
            "def _fn():\n    if False:\n        i = 10\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=time_step, num_time_steps=num_time_steps, curve_times=curve_times, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    return price",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=time_step, num_time_steps=num_time_steps, curve_times=curve_times, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    return price",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=time_step, num_time_steps=num_time_steps, curve_times=curve_times, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    return price",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=time_step, num_time_steps=num_time_steps, curve_times=curve_times, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    return price",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=time_step, num_time_steps=num_time_steps, curve_times=curve_times, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    return price"
        ]
    },
    {
        "func_name": "test_correctness_1d",
        "original": "@parameterized.named_parameters({'testcase_name': 'time_step', 'time_step': 0.1, 'num_time_steps': None, 'use_xla': False}, {'testcase_name': 'num_time_steps', 'time_step': None, 'num_time_steps': 11, 'use_xla': False}, {'testcase_name': 'num_time_steps_xla', 'time_step': None, 'num_time_steps': 11, 'use_xla': True})\ndef test_correctness_1d(self, time_step, num_time_steps, use_xla):\n    \"\"\"Tests model with constant parameters in 1 dimension.\"\"\"\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    if use_xla:\n        curve_times = np.array(fixed_leg_payment_times - expiries)\n    else:\n        curve_times = None\n\n    def _fn():\n        price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=time_step, num_time_steps=num_time_steps, curve_times=curve_times, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n        return price\n    if use_xla:\n        price = self.evaluate(tf.function(_fn, jit_compile=True)())\n    else:\n        price = self.evaluate(_fn())\n    self.assertAllClose(price, [0.7163243383624043], rtol=error_tol, atol=error_tol)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'time_step', 'time_step': 0.1, 'num_time_steps': None, 'use_xla': False}, {'testcase_name': 'num_time_steps', 'time_step': None, 'num_time_steps': 11, 'use_xla': False}, {'testcase_name': 'num_time_steps_xla', 'time_step': None, 'num_time_steps': 11, 'use_xla': True})\ndef test_correctness_1d(self, time_step, num_time_steps, use_xla):\n    if False:\n        i = 10\n    'Tests model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    if use_xla:\n        curve_times = np.array(fixed_leg_payment_times - expiries)\n    else:\n        curve_times = None\n\n    def _fn():\n        price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=time_step, num_time_steps=num_time_steps, curve_times=curve_times, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n        return price\n    if use_xla:\n        price = self.evaluate(tf.function(_fn, jit_compile=True)())\n    else:\n        price = self.evaluate(_fn())\n    self.assertAllClose(price, [0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'time_step', 'time_step': 0.1, 'num_time_steps': None, 'use_xla': False}, {'testcase_name': 'num_time_steps', 'time_step': None, 'num_time_steps': 11, 'use_xla': False}, {'testcase_name': 'num_time_steps_xla', 'time_step': None, 'num_time_steps': 11, 'use_xla': True})\ndef test_correctness_1d(self, time_step, num_time_steps, use_xla):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    if use_xla:\n        curve_times = np.array(fixed_leg_payment_times - expiries)\n    else:\n        curve_times = None\n\n    def _fn():\n        price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=time_step, num_time_steps=num_time_steps, curve_times=curve_times, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n        return price\n    if use_xla:\n        price = self.evaluate(tf.function(_fn, jit_compile=True)())\n    else:\n        price = self.evaluate(_fn())\n    self.assertAllClose(price, [0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'time_step', 'time_step': 0.1, 'num_time_steps': None, 'use_xla': False}, {'testcase_name': 'num_time_steps', 'time_step': None, 'num_time_steps': 11, 'use_xla': False}, {'testcase_name': 'num_time_steps_xla', 'time_step': None, 'num_time_steps': 11, 'use_xla': True})\ndef test_correctness_1d(self, time_step, num_time_steps, use_xla):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    if use_xla:\n        curve_times = np.array(fixed_leg_payment_times - expiries)\n    else:\n        curve_times = None\n\n    def _fn():\n        price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=time_step, num_time_steps=num_time_steps, curve_times=curve_times, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n        return price\n    if use_xla:\n        price = self.evaluate(tf.function(_fn, jit_compile=True)())\n    else:\n        price = self.evaluate(_fn())\n    self.assertAllClose(price, [0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'time_step', 'time_step': 0.1, 'num_time_steps': None, 'use_xla': False}, {'testcase_name': 'num_time_steps', 'time_step': None, 'num_time_steps': 11, 'use_xla': False}, {'testcase_name': 'num_time_steps_xla', 'time_step': None, 'num_time_steps': 11, 'use_xla': True})\ndef test_correctness_1d(self, time_step, num_time_steps, use_xla):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    if use_xla:\n        curve_times = np.array(fixed_leg_payment_times - expiries)\n    else:\n        curve_times = None\n\n    def _fn():\n        price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=time_step, num_time_steps=num_time_steps, curve_times=curve_times, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n        return price\n    if use_xla:\n        price = self.evaluate(tf.function(_fn, jit_compile=True)())\n    else:\n        price = self.evaluate(_fn())\n    self.assertAllClose(price, [0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'time_step', 'time_step': 0.1, 'num_time_steps': None, 'use_xla': False}, {'testcase_name': 'num_time_steps', 'time_step': None, 'num_time_steps': 11, 'use_xla': False}, {'testcase_name': 'num_time_steps_xla', 'time_step': None, 'num_time_steps': 11, 'use_xla': True})\ndef test_correctness_1d(self, time_step, num_time_steps, use_xla):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    if use_xla:\n        curve_times = np.array(fixed_leg_payment_times - expiries)\n    else:\n        curve_times = None\n\n    def _fn():\n        price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=time_step, num_time_steps=num_time_steps, curve_times=curve_times, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n        return price\n    if use_xla:\n        price = self.evaluate(tf.function(_fn, jit_compile=True)())\n    else:\n        price = self.evaluate(_fn())\n    self.assertAllClose(price, [0.7163243383624043], rtol=error_tol, atol=error_tol)"
        ]
    },
    {
        "func_name": "test_receiver_1d",
        "original": "def test_receiver_1d(self):\n    \"\"\"Test model with constant parameters in 1 dimension.\"\"\"\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, is_payer_swaption=False, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.813482544626056], rtol=error_tol, atol=error_tol)",
        "mutated": [
            "def test_receiver_1d(self):\n    if False:\n        i = 10\n    'Test model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, is_payer_swaption=False, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.813482544626056], rtol=error_tol, atol=error_tol)",
            "def test_receiver_1d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, is_payer_swaption=False, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.813482544626056], rtol=error_tol, atol=error_tol)",
            "def test_receiver_1d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, is_payer_swaption=False, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.813482544626056], rtol=error_tol, atol=error_tol)",
            "def test_receiver_1d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, is_payer_swaption=False, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.813482544626056], rtol=error_tol, atol=error_tol)",
            "def test_receiver_1d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test model with constant parameters in 1 dimension.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, is_payer_swaption=False, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.813482544626056], rtol=error_tol, atol=error_tol)"
        ]
    },
    {
        "func_name": "piecewise_1d_volatility_fn",
        "original": "def piecewise_1d_volatility_fn(t, r_t):\n    del r_t\n    vol = vol_piecewise_constant_fn([t])\n    return vol",
        "mutated": [
            "def piecewise_1d_volatility_fn(t, r_t):\n    if False:\n        i = 10\n    del r_t\n    vol = vol_piecewise_constant_fn([t])\n    return vol",
            "def piecewise_1d_volatility_fn(t, r_t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    del r_t\n    vol = vol_piecewise_constant_fn([t])\n    return vol",
            "def piecewise_1d_volatility_fn(t, r_t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    del r_t\n    vol = vol_piecewise_constant_fn([t])\n    return vol",
            "def piecewise_1d_volatility_fn(t, r_t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    del r_t\n    vol = vol_piecewise_constant_fn([t])\n    return vol",
            "def piecewise_1d_volatility_fn(t, r_t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    del r_t\n    vol = vol_piecewise_constant_fn([t])\n    return vol"
        ]
    },
    {
        "func_name": "test_time_dep_1d",
        "original": "def test_time_dep_1d(self):\n    \"\"\"Tests model with time-dependent parameters in 1 dimension.\"\"\"\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    vol_piecewise_constant_fn = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.01, 0.02], dtype=dtype)\n\n    def piecewise_1d_volatility_fn(t, r_t):\n        del r_t\n        vol = vol_piecewise_constant_fn([t])\n        return vol\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=piecewise_1d_volatility_fn, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.5593057004094042], rtol=error_tol, atol=error_tol)",
        "mutated": [
            "def test_time_dep_1d(self):\n    if False:\n        i = 10\n    'Tests model with time-dependent parameters in 1 dimension.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    vol_piecewise_constant_fn = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.01, 0.02], dtype=dtype)\n\n    def piecewise_1d_volatility_fn(t, r_t):\n        del r_t\n        vol = vol_piecewise_constant_fn([t])\n        return vol\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=piecewise_1d_volatility_fn, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.5593057004094042], rtol=error_tol, atol=error_tol)",
            "def test_time_dep_1d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests model with time-dependent parameters in 1 dimension.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    vol_piecewise_constant_fn = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.01, 0.02], dtype=dtype)\n\n    def piecewise_1d_volatility_fn(t, r_t):\n        del r_t\n        vol = vol_piecewise_constant_fn([t])\n        return vol\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=piecewise_1d_volatility_fn, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.5593057004094042], rtol=error_tol, atol=error_tol)",
            "def test_time_dep_1d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests model with time-dependent parameters in 1 dimension.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    vol_piecewise_constant_fn = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.01, 0.02], dtype=dtype)\n\n    def piecewise_1d_volatility_fn(t, r_t):\n        del r_t\n        vol = vol_piecewise_constant_fn([t])\n        return vol\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=piecewise_1d_volatility_fn, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.5593057004094042], rtol=error_tol, atol=error_tol)",
            "def test_time_dep_1d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests model with time-dependent parameters in 1 dimension.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    vol_piecewise_constant_fn = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.01, 0.02], dtype=dtype)\n\n    def piecewise_1d_volatility_fn(t, r_t):\n        del r_t\n        vol = vol_piecewise_constant_fn([t])\n        return vol\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=piecewise_1d_volatility_fn, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.5593057004094042], rtol=error_tol, atol=error_tol)",
            "def test_time_dep_1d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests model with time-dependent parameters in 1 dimension.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    vol_piecewise_constant_fn = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.01, 0.02], dtype=dtype)\n\n    def piecewise_1d_volatility_fn(t, r_t):\n        del r_t\n        vol = vol_piecewise_constant_fn([t])\n        return vol\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=piecewise_1d_volatility_fn, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.5593057004094042], rtol=error_tol, atol=error_tol)"
        ]
    },
    {
        "func_name": "zero_rate_fn",
        "original": "def zero_rate_fn(t):\n    ones = tf.expand_dims(tf.ones_like(t), axis=0)\n    return tf.transpose(tf.transpose(ones) * 0.01 * tf.ones(4, dtype=t.dtype))",
        "mutated": [
            "def zero_rate_fn(t):\n    if False:\n        i = 10\n    ones = tf.expand_dims(tf.ones_like(t), axis=0)\n    return tf.transpose(tf.transpose(ones) * 0.01 * tf.ones(4, dtype=t.dtype))",
            "def zero_rate_fn(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ones = tf.expand_dims(tf.ones_like(t), axis=0)\n    return tf.transpose(tf.transpose(ones) * 0.01 * tf.ones(4, dtype=t.dtype))",
            "def zero_rate_fn(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ones = tf.expand_dims(tf.ones_like(t), axis=0)\n    return tf.transpose(tf.transpose(ones) * 0.01 * tf.ones(4, dtype=t.dtype))",
            "def zero_rate_fn(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ones = tf.expand_dims(tf.ones_like(t), axis=0)\n    return tf.transpose(tf.transpose(ones) * 0.01 * tf.ones(4, dtype=t.dtype))",
            "def zero_rate_fn(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ones = tf.expand_dims(tf.ones_like(t), axis=0)\n    return tf.transpose(tf.transpose(ones) * 0.01 * tf.ones(4, dtype=t.dtype))"
        ]
    },
    {
        "func_name": "test_1d_batch_1d",
        "original": "@parameterized.named_parameters({'testcase_name': 'ModelHasNoBatch', 'model_batch_rank': 0, 'leading_dim_match': None}, {'testcase_name': 'ModelHas1D_Batch_LeadDimBroadcastable', 'model_batch_rank': 1, 'leading_dim_match': False}, {'testcase_name': 'ModelHas1D_Batch_LeadDimMatch', 'model_batch_rank': 1, 'leading_dim_match': True})\ndef test_1d_batch_1d(self, model_batch_rank, leading_dim_match):\n    \"\"\"Tests 1-d batch of swaptions with 1-factor models.\"\"\"\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0, 1.0])\n    fixed_leg_payment_times = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    if model_batch_rank == 1:\n        expiries = np.expand_dims(expiries, axis=0)\n        fixed_leg_payment_times = np.expand_dims(fixed_leg_payment_times, axis=0)\n        if leading_dim_match:\n            expiries = np.repeat(expiries, 4, axis=0)\n            fixed_leg_payment_times = np.repeat(fixed_leg_payment_times, 4, axis=0)\n\n        def zero_rate_fn(t):\n            ones = tf.expand_dims(tf.ones_like(t), axis=0)\n            return tf.transpose(tf.transpose(ones) * 0.01 * tf.ones(4, dtype=t.dtype))\n        mean_reversion = [[0.03], [0.03], [0.03], [0.03]]\n        volatility = [[0.02], [0.02], [0.02], [0.02]]\n        output_shape = [4, 2]\n    else:\n        zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n        output_shape = [2]\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, output_shape)\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.7163243383624043 * np.ones(output_shape), rtol=error_tol, atol=error_tol)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'ModelHasNoBatch', 'model_batch_rank': 0, 'leading_dim_match': None}, {'testcase_name': 'ModelHas1D_Batch_LeadDimBroadcastable', 'model_batch_rank': 1, 'leading_dim_match': False}, {'testcase_name': 'ModelHas1D_Batch_LeadDimMatch', 'model_batch_rank': 1, 'leading_dim_match': True})\ndef test_1d_batch_1d(self, model_batch_rank, leading_dim_match):\n    if False:\n        i = 10\n    'Tests 1-d batch of swaptions with 1-factor models.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0, 1.0])\n    fixed_leg_payment_times = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    if model_batch_rank == 1:\n        expiries = np.expand_dims(expiries, axis=0)\n        fixed_leg_payment_times = np.expand_dims(fixed_leg_payment_times, axis=0)\n        if leading_dim_match:\n            expiries = np.repeat(expiries, 4, axis=0)\n            fixed_leg_payment_times = np.repeat(fixed_leg_payment_times, 4, axis=0)\n\n        def zero_rate_fn(t):\n            ones = tf.expand_dims(tf.ones_like(t), axis=0)\n            return tf.transpose(tf.transpose(ones) * 0.01 * tf.ones(4, dtype=t.dtype))\n        mean_reversion = [[0.03], [0.03], [0.03], [0.03]]\n        volatility = [[0.02], [0.02], [0.02], [0.02]]\n        output_shape = [4, 2]\n    else:\n        zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n        output_shape = [2]\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, output_shape)\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.7163243383624043 * np.ones(output_shape), rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'ModelHasNoBatch', 'model_batch_rank': 0, 'leading_dim_match': None}, {'testcase_name': 'ModelHas1D_Batch_LeadDimBroadcastable', 'model_batch_rank': 1, 'leading_dim_match': False}, {'testcase_name': 'ModelHas1D_Batch_LeadDimMatch', 'model_batch_rank': 1, 'leading_dim_match': True})\ndef test_1d_batch_1d(self, model_batch_rank, leading_dim_match):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests 1-d batch of swaptions with 1-factor models.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0, 1.0])\n    fixed_leg_payment_times = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    if model_batch_rank == 1:\n        expiries = np.expand_dims(expiries, axis=0)\n        fixed_leg_payment_times = np.expand_dims(fixed_leg_payment_times, axis=0)\n        if leading_dim_match:\n            expiries = np.repeat(expiries, 4, axis=0)\n            fixed_leg_payment_times = np.repeat(fixed_leg_payment_times, 4, axis=0)\n\n        def zero_rate_fn(t):\n            ones = tf.expand_dims(tf.ones_like(t), axis=0)\n            return tf.transpose(tf.transpose(ones) * 0.01 * tf.ones(4, dtype=t.dtype))\n        mean_reversion = [[0.03], [0.03], [0.03], [0.03]]\n        volatility = [[0.02], [0.02], [0.02], [0.02]]\n        output_shape = [4, 2]\n    else:\n        zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n        output_shape = [2]\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, output_shape)\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.7163243383624043 * np.ones(output_shape), rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'ModelHasNoBatch', 'model_batch_rank': 0, 'leading_dim_match': None}, {'testcase_name': 'ModelHas1D_Batch_LeadDimBroadcastable', 'model_batch_rank': 1, 'leading_dim_match': False}, {'testcase_name': 'ModelHas1D_Batch_LeadDimMatch', 'model_batch_rank': 1, 'leading_dim_match': True})\ndef test_1d_batch_1d(self, model_batch_rank, leading_dim_match):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests 1-d batch of swaptions with 1-factor models.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0, 1.0])\n    fixed_leg_payment_times = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    if model_batch_rank == 1:\n        expiries = np.expand_dims(expiries, axis=0)\n        fixed_leg_payment_times = np.expand_dims(fixed_leg_payment_times, axis=0)\n        if leading_dim_match:\n            expiries = np.repeat(expiries, 4, axis=0)\n            fixed_leg_payment_times = np.repeat(fixed_leg_payment_times, 4, axis=0)\n\n        def zero_rate_fn(t):\n            ones = tf.expand_dims(tf.ones_like(t), axis=0)\n            return tf.transpose(tf.transpose(ones) * 0.01 * tf.ones(4, dtype=t.dtype))\n        mean_reversion = [[0.03], [0.03], [0.03], [0.03]]\n        volatility = [[0.02], [0.02], [0.02], [0.02]]\n        output_shape = [4, 2]\n    else:\n        zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n        output_shape = [2]\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, output_shape)\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.7163243383624043 * np.ones(output_shape), rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'ModelHasNoBatch', 'model_batch_rank': 0, 'leading_dim_match': None}, {'testcase_name': 'ModelHas1D_Batch_LeadDimBroadcastable', 'model_batch_rank': 1, 'leading_dim_match': False}, {'testcase_name': 'ModelHas1D_Batch_LeadDimMatch', 'model_batch_rank': 1, 'leading_dim_match': True})\ndef test_1d_batch_1d(self, model_batch_rank, leading_dim_match):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests 1-d batch of swaptions with 1-factor models.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0, 1.0])\n    fixed_leg_payment_times = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    if model_batch_rank == 1:\n        expiries = np.expand_dims(expiries, axis=0)\n        fixed_leg_payment_times = np.expand_dims(fixed_leg_payment_times, axis=0)\n        if leading_dim_match:\n            expiries = np.repeat(expiries, 4, axis=0)\n            fixed_leg_payment_times = np.repeat(fixed_leg_payment_times, 4, axis=0)\n\n        def zero_rate_fn(t):\n            ones = tf.expand_dims(tf.ones_like(t), axis=0)\n            return tf.transpose(tf.transpose(ones) * 0.01 * tf.ones(4, dtype=t.dtype))\n        mean_reversion = [[0.03], [0.03], [0.03], [0.03]]\n        volatility = [[0.02], [0.02], [0.02], [0.02]]\n        output_shape = [4, 2]\n    else:\n        zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n        output_shape = [2]\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, output_shape)\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.7163243383624043 * np.ones(output_shape), rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'ModelHasNoBatch', 'model_batch_rank': 0, 'leading_dim_match': None}, {'testcase_name': 'ModelHas1D_Batch_LeadDimBroadcastable', 'model_batch_rank': 1, 'leading_dim_match': False}, {'testcase_name': 'ModelHas1D_Batch_LeadDimMatch', 'model_batch_rank': 1, 'leading_dim_match': True})\ndef test_1d_batch_1d(self, model_batch_rank, leading_dim_match):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests 1-d batch of swaptions with 1-factor models.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0, 1.0])\n    fixed_leg_payment_times = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    if model_batch_rank == 1:\n        expiries = np.expand_dims(expiries, axis=0)\n        fixed_leg_payment_times = np.expand_dims(fixed_leg_payment_times, axis=0)\n        if leading_dim_match:\n            expiries = np.repeat(expiries, 4, axis=0)\n            fixed_leg_payment_times = np.repeat(fixed_leg_payment_times, 4, axis=0)\n\n        def zero_rate_fn(t):\n            ones = tf.expand_dims(tf.ones_like(t), axis=0)\n            return tf.transpose(tf.transpose(ones) * 0.01 * tf.ones(4, dtype=t.dtype))\n        mean_reversion = [[0.03], [0.03], [0.03], [0.03]]\n        volatility = [[0.02], [0.02], [0.02], [0.02]]\n        output_shape = [4, 2]\n    else:\n        zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n        output_shape = [2]\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, output_shape)\n    price = self.evaluate(price)\n    self.assertAllClose(price, 0.7163243383624043 * np.ones(output_shape), rtol=error_tol, atol=error_tol)"
        ]
    },
    {
        "func_name": "test_1d_batch_1d_notional",
        "original": "def test_1d_batch_1d_notional(self):\n    \"\"\"Tests 1-d batch with different notionals.\"\"\"\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0, 1.0])\n    fixed_leg_payment_times = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=[100.0, 200.0], num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 2 * 0.7163243383624043], rtol=error_tol, atol=error_tol)",
        "mutated": [
            "def test_1d_batch_1d_notional(self):\n    if False:\n        i = 10\n    'Tests 1-d batch with different notionals.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0, 1.0])\n    fixed_leg_payment_times = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=[100.0, 200.0], num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 2 * 0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "def test_1d_batch_1d_notional(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests 1-d batch with different notionals.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0, 1.0])\n    fixed_leg_payment_times = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=[100.0, 200.0], num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 2 * 0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "def test_1d_batch_1d_notional(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests 1-d batch with different notionals.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0, 1.0])\n    fixed_leg_payment_times = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=[100.0, 200.0], num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 2 * 0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "def test_1d_batch_1d_notional(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests 1-d batch with different notionals.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0, 1.0])\n    fixed_leg_payment_times = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=[100.0, 200.0], num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 2 * 0.7163243383624043], rtol=error_tol, atol=error_tol)",
            "def test_1d_batch_1d_notional(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests 1-d batch with different notionals.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0, 1.0])\n    fixed_leg_payment_times = np.array([[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=[100.0, 200.0], num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.7163243383624043, 2 * 0.7163243383624043], rtol=error_tol, atol=error_tol)"
        ]
    },
    {
        "func_name": "test_2d_batch_1d",
        "original": "def test_2d_batch_1d(self):\n    \"\"\"Tests 2-d batch.\"\"\"\n    dtype = tf.float64\n    error_tol = 0.01\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    expiries_2d = np.array([[1.0, 1.0], [1.0, 1.0]])\n    fixed_leg_payment_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    fixed_leg_daycount_fractions_2d = 0.25 * np.ones_like(fixed_leg_payment_times_2d)\n    fixed_leg_coupon_2d = 0.011 * np.ones_like(fixed_leg_payment_times_2d)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2, 2])\n    price = self.evaluate(price)\n    expected = [[0.7163243383624043, 0.7163243383624043], [0.7163243383624043, 0.7163243383624043]]\n    self.assertAllClose(price, expected, rtol=error_tol, atol=error_tol)",
        "mutated": [
            "def test_2d_batch_1d(self):\n    if False:\n        i = 10\n    'Tests 2-d batch.'\n    dtype = tf.float64\n    error_tol = 0.01\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    expiries_2d = np.array([[1.0, 1.0], [1.0, 1.0]])\n    fixed_leg_payment_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    fixed_leg_daycount_fractions_2d = 0.25 * np.ones_like(fixed_leg_payment_times_2d)\n    fixed_leg_coupon_2d = 0.011 * np.ones_like(fixed_leg_payment_times_2d)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2, 2])\n    price = self.evaluate(price)\n    expected = [[0.7163243383624043, 0.7163243383624043], [0.7163243383624043, 0.7163243383624043]]\n    self.assertAllClose(price, expected, rtol=error_tol, atol=error_tol)",
            "def test_2d_batch_1d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests 2-d batch.'\n    dtype = tf.float64\n    error_tol = 0.01\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    expiries_2d = np.array([[1.0, 1.0], [1.0, 1.0]])\n    fixed_leg_payment_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    fixed_leg_daycount_fractions_2d = 0.25 * np.ones_like(fixed_leg_payment_times_2d)\n    fixed_leg_coupon_2d = 0.011 * np.ones_like(fixed_leg_payment_times_2d)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2, 2])\n    price = self.evaluate(price)\n    expected = [[0.7163243383624043, 0.7163243383624043], [0.7163243383624043, 0.7163243383624043]]\n    self.assertAllClose(price, expected, rtol=error_tol, atol=error_tol)",
            "def test_2d_batch_1d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests 2-d batch.'\n    dtype = tf.float64\n    error_tol = 0.01\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    expiries_2d = np.array([[1.0, 1.0], [1.0, 1.0]])\n    fixed_leg_payment_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    fixed_leg_daycount_fractions_2d = 0.25 * np.ones_like(fixed_leg_payment_times_2d)\n    fixed_leg_coupon_2d = 0.011 * np.ones_like(fixed_leg_payment_times_2d)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2, 2])\n    price = self.evaluate(price)\n    expected = [[0.7163243383624043, 0.7163243383624043], [0.7163243383624043, 0.7163243383624043]]\n    self.assertAllClose(price, expected, rtol=error_tol, atol=error_tol)",
            "def test_2d_batch_1d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests 2-d batch.'\n    dtype = tf.float64\n    error_tol = 0.01\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    expiries_2d = np.array([[1.0, 1.0], [1.0, 1.0]])\n    fixed_leg_payment_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    fixed_leg_daycount_fractions_2d = 0.25 * np.ones_like(fixed_leg_payment_times_2d)\n    fixed_leg_coupon_2d = 0.011 * np.ones_like(fixed_leg_payment_times_2d)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2, 2])\n    price = self.evaluate(price)\n    expected = [[0.7163243383624043, 0.7163243383624043], [0.7163243383624043, 0.7163243383624043]]\n    self.assertAllClose(price, expected, rtol=error_tol, atol=error_tol)",
            "def test_2d_batch_1d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests 2-d batch.'\n    dtype = tf.float64\n    error_tol = 0.01\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    expiries_2d = np.array([[1.0, 1.0], [1.0, 1.0]])\n    fixed_leg_payment_times_2d = np.array([[[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]], [[1.25, 1.5, 1.75, 2.0], [1.25, 1.5, 1.75, 2.0]]])\n    fixed_leg_daycount_fractions_2d = 0.25 * np.ones_like(fixed_leg_payment_times_2d)\n    fixed_leg_coupon_2d = 0.011 * np.ones_like(fixed_leg_payment_times_2d)\n    mean_reversion = [0.03]\n    volatility = [0.02]\n    price = tff.models.hjm.swaption_price(expiries=expiries_2d, fixed_leg_payment_times=fixed_leg_payment_times_2d, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions_2d, fixed_leg_coupon=fixed_leg_coupon_2d, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=1, mean_reversion=mean_reversion, volatility=volatility, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2, 2])\n    price = self.evaluate(price)\n    expected = [[0.7163243383624043, 0.7163243383624043], [0.7163243383624043, 0.7163243383624043]]\n    self.assertAllClose(price, expected, rtol=error_tol, atol=error_tol)"
        ]
    },
    {
        "func_name": "test_correctness_2_factor",
        "original": "def test_correctness_2_factor(self):\n    \"\"\"Tests model with constant parameters in 2 dimensions.\"\"\"\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    mean_reversion = [0.03, 0.06]\n    volatility = [0.02, 0.01]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, num_samples=25000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.802226], rtol=error_tol, atol=error_tol)",
        "mutated": [
            "def test_correctness_2_factor(self):\n    if False:\n        i = 10\n    'Tests model with constant parameters in 2 dimensions.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    mean_reversion = [0.03, 0.06]\n    volatility = [0.02, 0.01]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, num_samples=25000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.802226], rtol=error_tol, atol=error_tol)",
            "def test_correctness_2_factor(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests model with constant parameters in 2 dimensions.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    mean_reversion = [0.03, 0.06]\n    volatility = [0.02, 0.01]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, num_samples=25000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.802226], rtol=error_tol, atol=error_tol)",
            "def test_correctness_2_factor(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests model with constant parameters in 2 dimensions.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    mean_reversion = [0.03, 0.06]\n    volatility = [0.02, 0.01]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, num_samples=25000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.802226], rtol=error_tol, atol=error_tol)",
            "def test_correctness_2_factor(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests model with constant parameters in 2 dimensions.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    mean_reversion = [0.03, 0.06]\n    volatility = [0.02, 0.01]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, num_samples=25000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.802226], rtol=error_tol, atol=error_tol)",
            "def test_correctness_2_factor(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests model with constant parameters in 2 dimensions.'\n    dtype = tf.float64\n    error_tol = 0.01\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    mean_reversion = [0.03, 0.06]\n    volatility = [0.02, 0.01]\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, num_samples=25000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [1])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [0.802226], rtol=error_tol, atol=error_tol)"
        ]
    },
    {
        "func_name": "test_correctness_2_factor_hull_white_consistency",
        "original": "@parameterized.named_parameters({'testcase_name': 'monte_carlo', 'valuation_method': tff.models.ValuationMethod.MONTE_CARLO, 'error_tol': 0.005}, {'testcase_name': 'pde', 'valuation_method': tff.models.ValuationMethod.FINITE_DIFFERENCE, 'error_tol': 0.002})\ndef test_correctness_2_factor_hull_white_consistency(self, valuation_method, error_tol):\n    \"\"\"Test that under certain conditions HJM matches analytic HW results.\n\n    Args:\n      valuation_method: The valuation method used.\n      error_tol: Test error tolerance.\n\n    For the two factor model, when both mean reversions are equivalent, then\n    the HJM model matches that of a HW one-factor model with the same mean\n    reversion, and effective volatility:\n    eff_vol = sqrt(vol1^2 + vol2^2 + 2 rho(vol1 * vol2)\n    where rho is the cross correlation between the two factors. In this\n    specific test, we assume rho = 0.0.\n    \"\"\"\n    dtype = tf.float64\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mu = 0.03\n    vol1 = 0.02\n    vol2 = 0.01\n    eff_vol = np.sqrt(vol1 ** 2 + vol2 ** 2)\n    hjm_price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=[mu, mu], volatility=[vol1, vol2], num_samples=25000, valuation_method=valuation_method, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    hjm_price = self.evaluate(hjm_price)\n    hw_price = tff.models.hull_white.swaption_price(expiries=expiries, floating_leg_start_times=[0], floating_leg_end_times=[0], floating_leg_daycount_fractions=[0], fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, mean_reversion=[mu], volatility=[eff_vol], use_analytic_pricing=True, dtype=dtype)\n    hw_price = self.evaluate(hw_price)\n    self.assertNear(hjm_price, hw_price, error_tol)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'monte_carlo', 'valuation_method': tff.models.ValuationMethod.MONTE_CARLO, 'error_tol': 0.005}, {'testcase_name': 'pde', 'valuation_method': tff.models.ValuationMethod.FINITE_DIFFERENCE, 'error_tol': 0.002})\ndef test_correctness_2_factor_hull_white_consistency(self, valuation_method, error_tol):\n    if False:\n        i = 10\n    'Test that under certain conditions HJM matches analytic HW results.\\n\\n    Args:\\n      valuation_method: The valuation method used.\\n      error_tol: Test error tolerance.\\n\\n    For the two factor model, when both mean reversions are equivalent, then\\n    the HJM model matches that of a HW one-factor model with the same mean\\n    reversion, and effective volatility:\\n    eff_vol = sqrt(vol1^2 + vol2^2 + 2 rho(vol1 * vol2)\\n    where rho is the cross correlation between the two factors. In this\\n    specific test, we assume rho = 0.0.\\n    '\n    dtype = tf.float64\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mu = 0.03\n    vol1 = 0.02\n    vol2 = 0.01\n    eff_vol = np.sqrt(vol1 ** 2 + vol2 ** 2)\n    hjm_price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=[mu, mu], volatility=[vol1, vol2], num_samples=25000, valuation_method=valuation_method, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    hjm_price = self.evaluate(hjm_price)\n    hw_price = tff.models.hull_white.swaption_price(expiries=expiries, floating_leg_start_times=[0], floating_leg_end_times=[0], floating_leg_daycount_fractions=[0], fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, mean_reversion=[mu], volatility=[eff_vol], use_analytic_pricing=True, dtype=dtype)\n    hw_price = self.evaluate(hw_price)\n    self.assertNear(hjm_price, hw_price, error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'monte_carlo', 'valuation_method': tff.models.ValuationMethod.MONTE_CARLO, 'error_tol': 0.005}, {'testcase_name': 'pde', 'valuation_method': tff.models.ValuationMethod.FINITE_DIFFERENCE, 'error_tol': 0.002})\ndef test_correctness_2_factor_hull_white_consistency(self, valuation_method, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test that under certain conditions HJM matches analytic HW results.\\n\\n    Args:\\n      valuation_method: The valuation method used.\\n      error_tol: Test error tolerance.\\n\\n    For the two factor model, when both mean reversions are equivalent, then\\n    the HJM model matches that of a HW one-factor model with the same mean\\n    reversion, and effective volatility:\\n    eff_vol = sqrt(vol1^2 + vol2^2 + 2 rho(vol1 * vol2)\\n    where rho is the cross correlation between the two factors. In this\\n    specific test, we assume rho = 0.0.\\n    '\n    dtype = tf.float64\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mu = 0.03\n    vol1 = 0.02\n    vol2 = 0.01\n    eff_vol = np.sqrt(vol1 ** 2 + vol2 ** 2)\n    hjm_price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=[mu, mu], volatility=[vol1, vol2], num_samples=25000, valuation_method=valuation_method, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    hjm_price = self.evaluate(hjm_price)\n    hw_price = tff.models.hull_white.swaption_price(expiries=expiries, floating_leg_start_times=[0], floating_leg_end_times=[0], floating_leg_daycount_fractions=[0], fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, mean_reversion=[mu], volatility=[eff_vol], use_analytic_pricing=True, dtype=dtype)\n    hw_price = self.evaluate(hw_price)\n    self.assertNear(hjm_price, hw_price, error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'monte_carlo', 'valuation_method': tff.models.ValuationMethod.MONTE_CARLO, 'error_tol': 0.005}, {'testcase_name': 'pde', 'valuation_method': tff.models.ValuationMethod.FINITE_DIFFERENCE, 'error_tol': 0.002})\ndef test_correctness_2_factor_hull_white_consistency(self, valuation_method, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test that under certain conditions HJM matches analytic HW results.\\n\\n    Args:\\n      valuation_method: The valuation method used.\\n      error_tol: Test error tolerance.\\n\\n    For the two factor model, when both mean reversions are equivalent, then\\n    the HJM model matches that of a HW one-factor model with the same mean\\n    reversion, and effective volatility:\\n    eff_vol = sqrt(vol1^2 + vol2^2 + 2 rho(vol1 * vol2)\\n    where rho is the cross correlation between the two factors. In this\\n    specific test, we assume rho = 0.0.\\n    '\n    dtype = tf.float64\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mu = 0.03\n    vol1 = 0.02\n    vol2 = 0.01\n    eff_vol = np.sqrt(vol1 ** 2 + vol2 ** 2)\n    hjm_price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=[mu, mu], volatility=[vol1, vol2], num_samples=25000, valuation_method=valuation_method, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    hjm_price = self.evaluate(hjm_price)\n    hw_price = tff.models.hull_white.swaption_price(expiries=expiries, floating_leg_start_times=[0], floating_leg_end_times=[0], floating_leg_daycount_fractions=[0], fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, mean_reversion=[mu], volatility=[eff_vol], use_analytic_pricing=True, dtype=dtype)\n    hw_price = self.evaluate(hw_price)\n    self.assertNear(hjm_price, hw_price, error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'monte_carlo', 'valuation_method': tff.models.ValuationMethod.MONTE_CARLO, 'error_tol': 0.005}, {'testcase_name': 'pde', 'valuation_method': tff.models.ValuationMethod.FINITE_DIFFERENCE, 'error_tol': 0.002})\ndef test_correctness_2_factor_hull_white_consistency(self, valuation_method, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test that under certain conditions HJM matches analytic HW results.\\n\\n    Args:\\n      valuation_method: The valuation method used.\\n      error_tol: Test error tolerance.\\n\\n    For the two factor model, when both mean reversions are equivalent, then\\n    the HJM model matches that of a HW one-factor model with the same mean\\n    reversion, and effective volatility:\\n    eff_vol = sqrt(vol1^2 + vol2^2 + 2 rho(vol1 * vol2)\\n    where rho is the cross correlation between the two factors. In this\\n    specific test, we assume rho = 0.0.\\n    '\n    dtype = tf.float64\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mu = 0.03\n    vol1 = 0.02\n    vol2 = 0.01\n    eff_vol = np.sqrt(vol1 ** 2 + vol2 ** 2)\n    hjm_price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=[mu, mu], volatility=[vol1, vol2], num_samples=25000, valuation_method=valuation_method, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    hjm_price = self.evaluate(hjm_price)\n    hw_price = tff.models.hull_white.swaption_price(expiries=expiries, floating_leg_start_times=[0], floating_leg_end_times=[0], floating_leg_daycount_fractions=[0], fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, mean_reversion=[mu], volatility=[eff_vol], use_analytic_pricing=True, dtype=dtype)\n    hw_price = self.evaluate(hw_price)\n    self.assertNear(hjm_price, hw_price, error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'monte_carlo', 'valuation_method': tff.models.ValuationMethod.MONTE_CARLO, 'error_tol': 0.005}, {'testcase_name': 'pde', 'valuation_method': tff.models.ValuationMethod.FINITE_DIFFERENCE, 'error_tol': 0.002})\ndef test_correctness_2_factor_hull_white_consistency(self, valuation_method, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test that under certain conditions HJM matches analytic HW results.\\n\\n    Args:\\n      valuation_method: The valuation method used.\\n      error_tol: Test error tolerance.\\n\\n    For the two factor model, when both mean reversions are equivalent, then\\n    the HJM model matches that of a HW one-factor model with the same mean\\n    reversion, and effective volatility:\\n    eff_vol = sqrt(vol1^2 + vol2^2 + 2 rho(vol1 * vol2)\\n    where rho is the cross correlation between the two factors. In this\\n    specific test, we assume rho = 0.0.\\n    '\n    dtype = tf.float64\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mu = 0.03\n    vol1 = 0.02\n    vol2 = 0.01\n    eff_vol = np.sqrt(vol1 ** 2 + vol2 ** 2)\n    hjm_price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=[mu, mu], volatility=[vol1, vol2], num_samples=25000, valuation_method=valuation_method, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    hjm_price = self.evaluate(hjm_price)\n    hw_price = tff.models.hull_white.swaption_price(expiries=expiries, floating_leg_start_times=[0], floating_leg_end_times=[0], floating_leg_daycount_fractions=[0], fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, mean_reversion=[mu], volatility=[eff_vol], use_analytic_pricing=True, dtype=dtype)\n    hw_price = self.evaluate(hw_price)\n    self.assertNear(hjm_price, hw_price, error_tol)"
        ]
    },
    {
        "func_name": "test_correctness_2_factor_hull_white_consistency_with_corr",
        "original": "@parameterized.named_parameters({'testcase_name': 'monte_carlo', 'valuation_method': tff.models.ValuationMethod.MONTE_CARLO, 'error_tol': 0.0012}, {'testcase_name': 'pde', 'valuation_method': tff.models.ValuationMethod.FINITE_DIFFERENCE, 'error_tol': 0.004})\ndef test_correctness_2_factor_hull_white_consistency_with_corr(self, valuation_method, error_tol):\n    \"\"\"Test that under certain conditions HJM matches analytic HW results.\"\"\"\n    dtype = tf.float64\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mu = 0.03\n    vol1 = 0.02\n    vol2 = 0.01\n    rho = -0.5\n    eff_vol = np.sqrt(vol1 ** 2 + vol2 ** 2 + 2 * rho * vol1 * vol2)\n    hjm_price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=[mu, mu], volatility=[vol1, vol2], corr_matrix=[[1, rho], [rho, 1]], valuation_method=valuation_method, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    hjm_price = self.evaluate(hjm_price)\n    hw_price = tff.models.hull_white.swaption_price(expiries=expiries, floating_leg_start_times=[0], floating_leg_end_times=[0], floating_leg_daycount_fractions=[0], fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, mean_reversion=[mu], volatility=[eff_vol], use_analytic_pricing=True, dtype=dtype)\n    hw_price = self.evaluate(hw_price)\n    self.assertNear(hjm_price, hw_price, error_tol)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'monte_carlo', 'valuation_method': tff.models.ValuationMethod.MONTE_CARLO, 'error_tol': 0.0012}, {'testcase_name': 'pde', 'valuation_method': tff.models.ValuationMethod.FINITE_DIFFERENCE, 'error_tol': 0.004})\ndef test_correctness_2_factor_hull_white_consistency_with_corr(self, valuation_method, error_tol):\n    if False:\n        i = 10\n    'Test that under certain conditions HJM matches analytic HW results.'\n    dtype = tf.float64\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mu = 0.03\n    vol1 = 0.02\n    vol2 = 0.01\n    rho = -0.5\n    eff_vol = np.sqrt(vol1 ** 2 + vol2 ** 2 + 2 * rho * vol1 * vol2)\n    hjm_price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=[mu, mu], volatility=[vol1, vol2], corr_matrix=[[1, rho], [rho, 1]], valuation_method=valuation_method, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    hjm_price = self.evaluate(hjm_price)\n    hw_price = tff.models.hull_white.swaption_price(expiries=expiries, floating_leg_start_times=[0], floating_leg_end_times=[0], floating_leg_daycount_fractions=[0], fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, mean_reversion=[mu], volatility=[eff_vol], use_analytic_pricing=True, dtype=dtype)\n    hw_price = self.evaluate(hw_price)\n    self.assertNear(hjm_price, hw_price, error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'monte_carlo', 'valuation_method': tff.models.ValuationMethod.MONTE_CARLO, 'error_tol': 0.0012}, {'testcase_name': 'pde', 'valuation_method': tff.models.ValuationMethod.FINITE_DIFFERENCE, 'error_tol': 0.004})\ndef test_correctness_2_factor_hull_white_consistency_with_corr(self, valuation_method, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test that under certain conditions HJM matches analytic HW results.'\n    dtype = tf.float64\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mu = 0.03\n    vol1 = 0.02\n    vol2 = 0.01\n    rho = -0.5\n    eff_vol = np.sqrt(vol1 ** 2 + vol2 ** 2 + 2 * rho * vol1 * vol2)\n    hjm_price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=[mu, mu], volatility=[vol1, vol2], corr_matrix=[[1, rho], [rho, 1]], valuation_method=valuation_method, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    hjm_price = self.evaluate(hjm_price)\n    hw_price = tff.models.hull_white.swaption_price(expiries=expiries, floating_leg_start_times=[0], floating_leg_end_times=[0], floating_leg_daycount_fractions=[0], fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, mean_reversion=[mu], volatility=[eff_vol], use_analytic_pricing=True, dtype=dtype)\n    hw_price = self.evaluate(hw_price)\n    self.assertNear(hjm_price, hw_price, error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'monte_carlo', 'valuation_method': tff.models.ValuationMethod.MONTE_CARLO, 'error_tol': 0.0012}, {'testcase_name': 'pde', 'valuation_method': tff.models.ValuationMethod.FINITE_DIFFERENCE, 'error_tol': 0.004})\ndef test_correctness_2_factor_hull_white_consistency_with_corr(self, valuation_method, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test that under certain conditions HJM matches analytic HW results.'\n    dtype = tf.float64\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mu = 0.03\n    vol1 = 0.02\n    vol2 = 0.01\n    rho = -0.5\n    eff_vol = np.sqrt(vol1 ** 2 + vol2 ** 2 + 2 * rho * vol1 * vol2)\n    hjm_price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=[mu, mu], volatility=[vol1, vol2], corr_matrix=[[1, rho], [rho, 1]], valuation_method=valuation_method, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    hjm_price = self.evaluate(hjm_price)\n    hw_price = tff.models.hull_white.swaption_price(expiries=expiries, floating_leg_start_times=[0], floating_leg_end_times=[0], floating_leg_daycount_fractions=[0], fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, mean_reversion=[mu], volatility=[eff_vol], use_analytic_pricing=True, dtype=dtype)\n    hw_price = self.evaluate(hw_price)\n    self.assertNear(hjm_price, hw_price, error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'monte_carlo', 'valuation_method': tff.models.ValuationMethod.MONTE_CARLO, 'error_tol': 0.0012}, {'testcase_name': 'pde', 'valuation_method': tff.models.ValuationMethod.FINITE_DIFFERENCE, 'error_tol': 0.004})\ndef test_correctness_2_factor_hull_white_consistency_with_corr(self, valuation_method, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test that under certain conditions HJM matches analytic HW results.'\n    dtype = tf.float64\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mu = 0.03\n    vol1 = 0.02\n    vol2 = 0.01\n    rho = -0.5\n    eff_vol = np.sqrt(vol1 ** 2 + vol2 ** 2 + 2 * rho * vol1 * vol2)\n    hjm_price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=[mu, mu], volatility=[vol1, vol2], corr_matrix=[[1, rho], [rho, 1]], valuation_method=valuation_method, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    hjm_price = self.evaluate(hjm_price)\n    hw_price = tff.models.hull_white.swaption_price(expiries=expiries, floating_leg_start_times=[0], floating_leg_end_times=[0], floating_leg_daycount_fractions=[0], fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, mean_reversion=[mu], volatility=[eff_vol], use_analytic_pricing=True, dtype=dtype)\n    hw_price = self.evaluate(hw_price)\n    self.assertNear(hjm_price, hw_price, error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'monte_carlo', 'valuation_method': tff.models.ValuationMethod.MONTE_CARLO, 'error_tol': 0.0012}, {'testcase_name': 'pde', 'valuation_method': tff.models.ValuationMethod.FINITE_DIFFERENCE, 'error_tol': 0.004})\ndef test_correctness_2_factor_hull_white_consistency_with_corr(self, valuation_method, error_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test that under certain conditions HJM matches analytic HW results.'\n    dtype = tf.float64\n    expiries = np.array([1.0])\n    fixed_leg_payment_times = np.array([1.25, 1.5, 1.75, 2.0])\n    fixed_leg_daycount_fractions = 0.25 * np.ones_like(fixed_leg_payment_times)\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mu = 0.03\n    vol1 = 0.02\n    vol2 = 0.01\n    rho = -0.5\n    eff_vol = np.sqrt(vol1 ** 2 + vol2 ** 2 + 2 * rho * vol1 * vol2)\n    hjm_price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=[mu, mu], volatility=[vol1, vol2], corr_matrix=[[1, rho], [rho, 1]], valuation_method=valuation_method, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, num_samples=50000, time_step=0.1, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 2], dtype=dtype)\n    hjm_price = self.evaluate(hjm_price)\n    hw_price = tff.models.hull_white.swaption_price(expiries=expiries, floating_leg_start_times=[0], floating_leg_end_times=[0], floating_leg_daycount_fractions=[0], fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, mean_reversion=[mu], volatility=[eff_vol], use_analytic_pricing=True, dtype=dtype)\n    hw_price = self.evaluate(hw_price)\n    self.assertNear(hjm_price, hw_price, error_tol)"
        ]
    },
    {
        "func_name": "_fn",
        "original": "def _fn():\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=time_step, num_time_steps_finite_difference=num_time_steps, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n    return price",
        "mutated": [
            "def _fn():\n    if False:\n        i = 10\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=time_step, num_time_steps_finite_difference=num_time_steps, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n    return price",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=time_step, num_time_steps_finite_difference=num_time_steps, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n    return price",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=time_step, num_time_steps_finite_difference=num_time_steps, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n    return price",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=time_step, num_time_steps_finite_difference=num_time_steps, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n    return price",
            "def _fn():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=time_step, num_time_steps_finite_difference=num_time_steps, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n    return price"
        ]
    },
    {
        "func_name": "test_correctness_2_factor_fd",
        "original": "@parameterized.named_parameters({'testcase_name': 'time_step', 'time_step': 0.05, 'num_time_steps': None, 'use_xla': False}, {'testcase_name': 'num_time_steps', 'time_step': None, 'num_time_steps': 21, 'use_xla': False})\ndef test_correctness_2_factor_fd(self, time_step, num_time_steps, use_xla):\n    \"\"\"Tests finite difference valuation for 2-factor model.\"\"\"\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726])\n    fixed_leg_payment_times = np.array([1.249315068, 1.498630137, 1.750684932, 2.002739726])\n    fixed_leg_daycount_fractions = np.array([0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15]\n    volatility = [0.01, 0.015]\n\n    def _fn():\n        price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=time_step, num_time_steps_finite_difference=num_time_steps, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n        return price\n    if use_xla:\n        price = self.evaluate(tf.function(_fn, jit_compile=True)())\n    else:\n        price = self.evaluate(_fn())\n    quantlib_price = 0.5900860719515227\n    self.assertAllClose(price, [quantlib_price], rtol=error_tol, atol=error_tol)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'time_step', 'time_step': 0.05, 'num_time_steps': None, 'use_xla': False}, {'testcase_name': 'num_time_steps', 'time_step': None, 'num_time_steps': 21, 'use_xla': False})\ndef test_correctness_2_factor_fd(self, time_step, num_time_steps, use_xla):\n    if False:\n        i = 10\n    'Tests finite difference valuation for 2-factor model.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726])\n    fixed_leg_payment_times = np.array([1.249315068, 1.498630137, 1.750684932, 2.002739726])\n    fixed_leg_daycount_fractions = np.array([0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15]\n    volatility = [0.01, 0.015]\n\n    def _fn():\n        price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=time_step, num_time_steps_finite_difference=num_time_steps, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n        return price\n    if use_xla:\n        price = self.evaluate(tf.function(_fn, jit_compile=True)())\n    else:\n        price = self.evaluate(_fn())\n    quantlib_price = 0.5900860719515227\n    self.assertAllClose(price, [quantlib_price], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'time_step', 'time_step': 0.05, 'num_time_steps': None, 'use_xla': False}, {'testcase_name': 'num_time_steps', 'time_step': None, 'num_time_steps': 21, 'use_xla': False})\ndef test_correctness_2_factor_fd(self, time_step, num_time_steps, use_xla):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests finite difference valuation for 2-factor model.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726])\n    fixed_leg_payment_times = np.array([1.249315068, 1.498630137, 1.750684932, 2.002739726])\n    fixed_leg_daycount_fractions = np.array([0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15]\n    volatility = [0.01, 0.015]\n\n    def _fn():\n        price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=time_step, num_time_steps_finite_difference=num_time_steps, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n        return price\n    if use_xla:\n        price = self.evaluate(tf.function(_fn, jit_compile=True)())\n    else:\n        price = self.evaluate(_fn())\n    quantlib_price = 0.5900860719515227\n    self.assertAllClose(price, [quantlib_price], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'time_step', 'time_step': 0.05, 'num_time_steps': None, 'use_xla': False}, {'testcase_name': 'num_time_steps', 'time_step': None, 'num_time_steps': 21, 'use_xla': False})\ndef test_correctness_2_factor_fd(self, time_step, num_time_steps, use_xla):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests finite difference valuation for 2-factor model.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726])\n    fixed_leg_payment_times = np.array([1.249315068, 1.498630137, 1.750684932, 2.002739726])\n    fixed_leg_daycount_fractions = np.array([0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15]\n    volatility = [0.01, 0.015]\n\n    def _fn():\n        price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=time_step, num_time_steps_finite_difference=num_time_steps, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n        return price\n    if use_xla:\n        price = self.evaluate(tf.function(_fn, jit_compile=True)())\n    else:\n        price = self.evaluate(_fn())\n    quantlib_price = 0.5900860719515227\n    self.assertAllClose(price, [quantlib_price], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'time_step', 'time_step': 0.05, 'num_time_steps': None, 'use_xla': False}, {'testcase_name': 'num_time_steps', 'time_step': None, 'num_time_steps': 21, 'use_xla': False})\ndef test_correctness_2_factor_fd(self, time_step, num_time_steps, use_xla):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests finite difference valuation for 2-factor model.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726])\n    fixed_leg_payment_times = np.array([1.249315068, 1.498630137, 1.750684932, 2.002739726])\n    fixed_leg_daycount_fractions = np.array([0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15]\n    volatility = [0.01, 0.015]\n\n    def _fn():\n        price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=time_step, num_time_steps_finite_difference=num_time_steps, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n        return price\n    if use_xla:\n        price = self.evaluate(tf.function(_fn, jit_compile=True)())\n    else:\n        price = self.evaluate(_fn())\n    quantlib_price = 0.5900860719515227\n    self.assertAllClose(price, [quantlib_price], rtol=error_tol, atol=error_tol)",
            "@parameterized.named_parameters({'testcase_name': 'time_step', 'time_step': 0.05, 'num_time_steps': None, 'use_xla': False}, {'testcase_name': 'num_time_steps', 'time_step': None, 'num_time_steps': 21, 'use_xla': False})\ndef test_correctness_2_factor_fd(self, time_step, num_time_steps, use_xla):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests finite difference valuation for 2-factor model.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726])\n    fixed_leg_payment_times = np.array([1.249315068, 1.498630137, 1.750684932, 2.002739726])\n    fixed_leg_daycount_fractions = np.array([0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15]\n    volatility = [0.01, 0.015]\n\n    def _fn():\n        price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=time_step, num_time_steps_finite_difference=num_time_steps, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n        return price\n    if use_xla:\n        price = self.evaluate(tf.function(_fn, jit_compile=True)())\n    else:\n        price = self.evaluate(_fn())\n    quantlib_price = 0.5900860719515227\n    self.assertAllClose(price, [quantlib_price], rtol=error_tol, atol=error_tol)"
        ]
    },
    {
        "func_name": "test_correctness_2_factor_batch_fd",
        "original": "def test_correctness_2_factor_batch_fd(self):\n    \"\"\"Tests finite difference valuation for a batch.\"\"\"\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726, 2.002739726])\n    fixed_leg_payment_times = np.array([[1.249315068, 1.498630137, 1.750684932, 2.002739726], [2.249315068, 2.498630137, 2.750684932, 3.002739726]])\n    fixed_leg_daycount_fractions = np.array([[0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945], [0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945]])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15]\n    volatility = [0.01, 0.015]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n    quantlib_price = [0.5900860719515227, 0.8029012153434956]\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [quantlib_price[0], quantlib_price[1]], rtol=error_tol, atol=error_tol)",
        "mutated": [
            "def test_correctness_2_factor_batch_fd(self):\n    if False:\n        i = 10\n    'Tests finite difference valuation for a batch.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726, 2.002739726])\n    fixed_leg_payment_times = np.array([[1.249315068, 1.498630137, 1.750684932, 2.002739726], [2.249315068, 2.498630137, 2.750684932, 3.002739726]])\n    fixed_leg_daycount_fractions = np.array([[0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945], [0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945]])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15]\n    volatility = [0.01, 0.015]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n    quantlib_price = [0.5900860719515227, 0.8029012153434956]\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [quantlib_price[0], quantlib_price[1]], rtol=error_tol, atol=error_tol)",
            "def test_correctness_2_factor_batch_fd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests finite difference valuation for a batch.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726, 2.002739726])\n    fixed_leg_payment_times = np.array([[1.249315068, 1.498630137, 1.750684932, 2.002739726], [2.249315068, 2.498630137, 2.750684932, 3.002739726]])\n    fixed_leg_daycount_fractions = np.array([[0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945], [0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945]])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15]\n    volatility = [0.01, 0.015]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n    quantlib_price = [0.5900860719515227, 0.8029012153434956]\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [quantlib_price[0], quantlib_price[1]], rtol=error_tol, atol=error_tol)",
            "def test_correctness_2_factor_batch_fd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests finite difference valuation for a batch.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726, 2.002739726])\n    fixed_leg_payment_times = np.array([[1.249315068, 1.498630137, 1.750684932, 2.002739726], [2.249315068, 2.498630137, 2.750684932, 3.002739726]])\n    fixed_leg_daycount_fractions = np.array([[0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945], [0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945]])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15]\n    volatility = [0.01, 0.015]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n    quantlib_price = [0.5900860719515227, 0.8029012153434956]\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [quantlib_price[0], quantlib_price[1]], rtol=error_tol, atol=error_tol)",
            "def test_correctness_2_factor_batch_fd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests finite difference valuation for a batch.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726, 2.002739726])\n    fixed_leg_payment_times = np.array([[1.249315068, 1.498630137, 1.750684932, 2.002739726], [2.249315068, 2.498630137, 2.750684932, 3.002739726]])\n    fixed_leg_daycount_fractions = np.array([[0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945], [0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945]])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15]\n    volatility = [0.01, 0.015]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n    quantlib_price = [0.5900860719515227, 0.8029012153434956]\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [quantlib_price[0], quantlib_price[1]], rtol=error_tol, atol=error_tol)",
            "def test_correctness_2_factor_batch_fd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests finite difference valuation for a batch.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726, 2.002739726])\n    fixed_leg_payment_times = np.array([[1.249315068, 1.498630137, 1.750684932, 2.002739726], [2.249315068, 2.498630137, 2.750684932, 3.002739726]])\n    fixed_leg_daycount_fractions = np.array([[0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945], [0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945]])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15]\n    volatility = [0.01, 0.015]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=2, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=0.05, num_grid_points_finite_difference=251, time_step=0.1, dtype=dtype)\n    quantlib_price = [0.5900860719515227, 0.8029012153434956]\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [quantlib_price[0], quantlib_price[1]], rtol=error_tol, atol=error_tol)"
        ]
    },
    {
        "func_name": "test_correctness_3_factor_batch_fd",
        "original": "def test_correctness_3_factor_batch_fd(self):\n    \"\"\"Tests finite difference valuation for a batch with 3 factor HJM.\"\"\"\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726, 1.002739726])\n    fixed_leg_payment_times = np.array([[1.249315068, 1.498630137, 1.750684932, 2.002739726], [1.249315068, 1.498630137, 1.750684932, 2.002739726]])\n    fixed_leg_daycount_fractions = np.array([[0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945], [0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945]])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15, 0.25]\n    volatility = [0.01, 0.015, 0.009]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=3, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=0.05, num_grid_points_finite_difference=51, time_step=0.1, dtype=dtype)\n    very_approximate_benchmark = 0.56020399\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [very_approximate_benchmark, very_approximate_benchmark], rtol=error_tol, atol=error_tol)",
        "mutated": [
            "def test_correctness_3_factor_batch_fd(self):\n    if False:\n        i = 10\n    'Tests finite difference valuation for a batch with 3 factor HJM.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726, 1.002739726])\n    fixed_leg_payment_times = np.array([[1.249315068, 1.498630137, 1.750684932, 2.002739726], [1.249315068, 1.498630137, 1.750684932, 2.002739726]])\n    fixed_leg_daycount_fractions = np.array([[0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945], [0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945]])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15, 0.25]\n    volatility = [0.01, 0.015, 0.009]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=3, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=0.05, num_grid_points_finite_difference=51, time_step=0.1, dtype=dtype)\n    very_approximate_benchmark = 0.56020399\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [very_approximate_benchmark, very_approximate_benchmark], rtol=error_tol, atol=error_tol)",
            "def test_correctness_3_factor_batch_fd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests finite difference valuation for a batch with 3 factor HJM.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726, 1.002739726])\n    fixed_leg_payment_times = np.array([[1.249315068, 1.498630137, 1.750684932, 2.002739726], [1.249315068, 1.498630137, 1.750684932, 2.002739726]])\n    fixed_leg_daycount_fractions = np.array([[0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945], [0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945]])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15, 0.25]\n    volatility = [0.01, 0.015, 0.009]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=3, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=0.05, num_grid_points_finite_difference=51, time_step=0.1, dtype=dtype)\n    very_approximate_benchmark = 0.56020399\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [very_approximate_benchmark, very_approximate_benchmark], rtol=error_tol, atol=error_tol)",
            "def test_correctness_3_factor_batch_fd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests finite difference valuation for a batch with 3 factor HJM.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726, 1.002739726])\n    fixed_leg_payment_times = np.array([[1.249315068, 1.498630137, 1.750684932, 2.002739726], [1.249315068, 1.498630137, 1.750684932, 2.002739726]])\n    fixed_leg_daycount_fractions = np.array([[0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945], [0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945]])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15, 0.25]\n    volatility = [0.01, 0.015, 0.009]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=3, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=0.05, num_grid_points_finite_difference=51, time_step=0.1, dtype=dtype)\n    very_approximate_benchmark = 0.56020399\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [very_approximate_benchmark, very_approximate_benchmark], rtol=error_tol, atol=error_tol)",
            "def test_correctness_3_factor_batch_fd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests finite difference valuation for a batch with 3 factor HJM.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726, 1.002739726])\n    fixed_leg_payment_times = np.array([[1.249315068, 1.498630137, 1.750684932, 2.002739726], [1.249315068, 1.498630137, 1.750684932, 2.002739726]])\n    fixed_leg_daycount_fractions = np.array([[0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945], [0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945]])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15, 0.25]\n    volatility = [0.01, 0.015, 0.009]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=3, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=0.05, num_grid_points_finite_difference=51, time_step=0.1, dtype=dtype)\n    very_approximate_benchmark = 0.56020399\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [very_approximate_benchmark, very_approximate_benchmark], rtol=error_tol, atol=error_tol)",
            "def test_correctness_3_factor_batch_fd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests finite difference valuation for a batch with 3 factor HJM.'\n    dtype = tf.float64\n    error_tol = 0.001\n    expiries = np.array([1.002739726, 1.002739726])\n    fixed_leg_payment_times = np.array([[1.249315068, 1.498630137, 1.750684932, 2.002739726], [1.249315068, 1.498630137, 1.750684932, 2.002739726]])\n    fixed_leg_daycount_fractions = np.array([[0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945], [0.2465753425, 0.2493150685, 0.2520547945, 0.2520547945]])\n    fixed_leg_coupon = 0.011 * np.ones_like(fixed_leg_payment_times)\n    zero_rate_fn = lambda x: 0.01 * tf.ones_like(x, dtype=dtype)\n    mean_reversion = [0.03, 0.15, 0.25]\n    volatility = [0.01, 0.015, 0.009]\n    price = tff.models.hjm.swaption_price(expiries=expiries, fixed_leg_payment_times=fixed_leg_payment_times, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, reference_rate_fn=zero_rate_fn, notional=100.0, num_hjm_factors=3, mean_reversion=mean_reversion, volatility=volatility, valuation_method=tff.models.ValuationMethod.FINITE_DIFFERENCE, time_step_finite_difference=0.05, num_grid_points_finite_difference=51, time_step=0.1, dtype=dtype)\n    very_approximate_benchmark = 0.56020399\n    self.assertEqual(price.dtype, dtype)\n    self.assertAllEqual(price.shape, [2])\n    price = self.evaluate(price)\n    self.assertAllClose(price, [very_approximate_benchmark, very_approximate_benchmark], rtol=error_tol, atol=error_tol)"
        ]
    }
]