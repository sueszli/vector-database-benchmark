"""Amazon Redshift Write Module (PRIVATE)."""
import logging
from typing import Dict, List, Literal, Optional, Union
import boto3
import awswrangler.pandas as pd
from awswrangler import _databases as _db_utils
from awswrangler import _utils, exceptions, s3
from awswrangler._config import apply_configs
from ._connect import _validate_connection
from ._utils import _create_table, _make_s3_auth_string, _upsert
redshift_connector = _utils.import_optional_dependency('redshift_connector')
_logger: logging.Logger = logging.getLogger(__name__)
_ToSqlModeLiteral = Literal['append', 'overwrite', 'upsert']
_ToSqlOverwriteModeLiteral = Literal['drop', 'cascade', 'truncate', 'delete']
_ToSqlDistStyleLiteral = Literal['AUTO', 'EVEN', 'ALL', 'KEY']
_ToSqlSortStyleLiteral = Literal['COMPOUND', 'INTERLEAVED']

def _copy(cursor: 'redshift_connector.Cursor', path: str, table: str, serialize_to_json: bool, iam_role: Optional[str]=None, aws_access_key_id: Optional[str]=None, aws_secret_access_key: Optional[str]=None, aws_session_token: Optional[str]=None, boto3_session: Optional[boto3.Session]=None, schema: Optional[str]=None, manifest: Optional[bool]=False, sql_copy_extra_params: Optional[List[str]]=None, column_names: Optional[List[str]]=None) -> None:
    if False:
        print('Hello World!')
    if schema is None:
        table_name: str = f'"{table}"'
    else:
        table_name = f'"{schema}"."{table}"'
    auth_str: str = _make_s3_auth_string(iam_role=iam_role, aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, aws_session_token=aws_session_token, boto3_session=boto3_session)
    ser_json_str: str = ' SERIALIZETOJSON' if serialize_to_json else ''
    column_names_str: str = f"({','.join(column_names)})" if column_names else ''
    sql = f"COPY {table_name} {column_names_str}\nFROM '{path}' {auth_str}\nFORMAT AS PARQUET{ser_json_str}"
    if manifest:
        sql += '\nMANIFEST'
    if sql_copy_extra_params:
        for param in sql_copy_extra_params:
            sql += f'\n{param}'
    cursor.execute(sql)

@_utils.check_optional_dependency(redshift_connector, 'redshift_connector')
@apply_configs
def to_sql(df: pd.DataFrame, con: 'redshift_connector.Connection', table: str, schema: str, mode: _ToSqlModeLiteral='append', overwrite_method: _ToSqlOverwriteModeLiteral='drop', index: bool=False, dtype: Optional[Dict[str, str]]=None, diststyle: _ToSqlDistStyleLiteral='AUTO', distkey: Optional[str]=None, sortstyle: _ToSqlSortStyleLiteral='COMPOUND', sortkey: Optional[List[str]]=None, primary_keys: Optional[List[str]]=None, varchar_lengths_default: int=256, varchar_lengths: Optional[Dict[str, int]]=None, use_column_names: bool=False, lock: bool=False, chunksize: int=200, commit_transaction: bool=True, precombine_key: Optional[str]=None) -> None:
    if False:
        for i in range(10):
            print('nop')
    'Write records stored in a DataFrame into Redshift.\n\n    Note\n    ----\n    For large DataFrames (1K+ rows) consider the function **wr.redshift.copy()**.\n\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        Pandas DataFrame https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html\n    con : redshift_connector.Connection\n        Use redshift_connector.connect() to use "\n        "credentials directly or wr.redshift.connect() to fetch it from the Glue Catalog.\n    table : str\n        Table name\n    schema : str\n        Schema name\n    mode : str\n        Append, overwrite or upsert.\n    overwrite_method : str\n        Drop, cascade, truncate, or delete. Only applicable in overwrite mode.\n\n        "drop" - ``DROP ... RESTRICT`` - drops the table. Fails if there are any views that depend on it.\n        "cascade" - ``DROP ... CASCADE`` - drops the table, and all views that depend on it.\n        "truncate" - ``TRUNCATE ...`` - truncates the table, but immediately commits current\n        transaction & starts a new one, hence the overwrite happens in two transactions and is not atomic.\n        "delete" - ``DELETE FROM ...`` - deletes all rows from the table. Slow relative to the other methods.\n    index : bool\n        True to store the DataFrame index as a column in the table,\n        otherwise False to ignore it.\n    dtype : Dict[str, str], optional\n        Dictionary of columns names and Redshift types to be casted.\n        Useful when you have columns with undetermined or mixed data types.\n        (e.g. {\'col name\': \'VARCHAR(10)\', \'col2 name\': \'FLOAT\'})\n        diststyle : str\n        Redshift distribution styles. Must be in ["AUTO", "EVEN", "ALL", "KEY"].\n        https://docs.aws.amazon.com/redshift/latest/dg/t_Distributing_data.html\n    distkey : str, optional\n        Specifies a column name or positional number for the distribution key.\n    sortstyle : str\n        Sorting can be "COMPOUND" or "INTERLEAVED".\n        https://docs.aws.amazon.com/redshift/latest/dg/t_Sorting_data.html\n    sortkey : List[str], optional\n        List of columns to be sorted.\n    primary_keys : List[str], optional\n        Primary keys.\n    varchar_lengths_default : int\n        The size that will be set for all VARCHAR columns not specified with varchar_lengths.\n    varchar_lengths : Dict[str, int], optional\n        Dict of VARCHAR length by columns. (e.g. {"col1": 10, "col5": 200}).\n    use_column_names: bool\n        If set to True, will use the column names of the DataFrame for generating the INSERT SQL Query.\n        E.g. If the DataFrame has two columns `col1` and `col3` and `use_column_names` is True, data will only be\n        inserted into the database columns `col1` and `col3`.\n    lock : bool\n        True to execute LOCK command inside the transaction to force serializable isolation.\n    chunksize : int\n        Number of rows which are inserted with each SQL query. Defaults to inserting 200 rows per query.\n    commit_transaction : bool\n        Whether to commit the transaction. True by default.\n    precombine_key : str, optional\n        When there is a primary_key match during upsert, this column will change the upsert method,\n        comparing the values of the specified column from source and target, and keeping the\n        larger of the two. Will only work when mode = upsert.\n\n    Returns\n    -------\n    None\n        None.\n\n    Examples\n    --------\n    Writing to Redshift using a Glue Catalog Connections\n\n    >>> import awswrangler as wr\n    >>> con = wr.redshift.connect("MY_GLUE_CONNECTION")\n    >>> wr.redshift.to_sql(\n    ...     df=df,\n    ...     table="my_table",\n    ...     schema="public",\n    ...     con=con\n    ... )\n    >>> con.close()\n\n    '
    if df.empty is True:
        raise exceptions.EmptyDataFrame('DataFrame cannot be empty.')
    _validate_connection(con=con)
    autocommit_temp: bool = con.autocommit
    con.autocommit = False
    try:
        with con.cursor() as cursor:
            (created_table, created_schema) = _create_table(df=df, path=None, con=con, cursor=cursor, table=table, schema=schema, mode=mode, overwrite_method=overwrite_method, index=index, dtype=dtype, diststyle=diststyle, sortstyle=sortstyle, distkey=distkey, sortkey=sortkey, primary_keys=primary_keys, varchar_lengths_default=varchar_lengths_default, varchar_lengths=varchar_lengths, lock=lock)
            if index:
                df.reset_index(level=df.index.names, inplace=True)
            column_names = [f'"{column}"' for column in df.columns]
            column_placeholders: str = ', '.join(['%s'] * len(column_names))
            schema_str = f'"{created_schema}".' if created_schema else ''
            insertion_columns = ''
            if use_column_names:
                insertion_columns = f"({', '.join(column_names)})"
            placeholder_parameter_pair_generator = _db_utils.generate_placeholder_parameter_pairs(df=df, column_placeholders=column_placeholders, chunksize=chunksize)
            for (placeholders, parameters) in placeholder_parameter_pair_generator:
                sql: str = f'INSERT INTO {schema_str}"{created_table}" {insertion_columns} VALUES {placeholders}'
                _logger.debug('Executing insert query:\n%s', sql)
                cursor.executemany(sql, (parameters,))
            if table != created_table:
                _upsert(cursor=cursor, schema=schema, table=table, temp_table=created_table, primary_keys=primary_keys, precombine_key=precombine_key, column_names=column_names)
            if commit_transaction:
                con.commit()
    except Exception as ex:
        con.rollback()
        _logger.error(ex)
        raise
    finally:
        con.autocommit = autocommit_temp

@_utils.check_optional_dependency(redshift_connector, 'redshift_connector')
def copy_from_files(path: str, con: 'redshift_connector.Connection', table: str, schema: str, iam_role: Optional[str]=None, aws_access_key_id: Optional[str]=None, aws_secret_access_key: Optional[str]=None, aws_session_token: Optional[str]=None, parquet_infer_sampling: float=1.0, mode: _ToSqlModeLiteral='append', overwrite_method: _ToSqlOverwriteModeLiteral='drop', diststyle: _ToSqlDistStyleLiteral='AUTO', distkey: Optional[str]=None, sortstyle: _ToSqlSortStyleLiteral='COMPOUND', sortkey: Optional[List[str]]=None, primary_keys: Optional[List[str]]=None, varchar_lengths_default: int=256, varchar_lengths: Optional[Dict[str, int]]=None, serialize_to_json: bool=False, path_suffix: Optional[str]=None, path_ignore_suffix: Union[str, List[str], None]=None, use_threads: Union[bool, int]=True, lock: bool=False, commit_transaction: bool=True, manifest: Optional[bool]=False, sql_copy_extra_params: Optional[List[str]]=None, boto3_session: Optional[boto3.Session]=None, s3_additional_kwargs: Optional[Dict[str, str]]=None, precombine_key: Optional[str]=None, column_names: Optional[List[str]]=None) -> None:
    if False:
        i = 10
        return i + 15
    'Load Parquet files from S3 to a Table on Amazon Redshift (Through COPY command).\n\n    https://docs.aws.amazon.com/redshift/latest/dg/r_COPY.html\n\n    Note\n    ----\n    If the table does not exist yet,\n    it will be automatically created for you\n    using the Parquet metadata to\n    infer the columns data types.\n\n    Note\n    ----\n    In case of `use_threads=True` the number of threads\n    that will be spawned will be gotten from os.cpu_count().\n\n    Parameters\n    ----------\n    path : str\n        S3 prefix (e.g. s3://bucket/prefix/)\n    con : redshift_connector.Connection\n        Use redshift_connector.connect() to use "\n        "credentials directly or wr.redshift.connect() to fetch it from the Glue Catalog.\n    table : str\n        Table name\n    schema : str\n        Schema name\n    iam_role : str, optional\n        AWS IAM role with the related permissions.\n    aws_access_key_id : str, optional\n        The access key for your AWS account.\n    aws_secret_access_key : str, optional\n        The secret key for your AWS account.\n    aws_session_token : str, optional\n        The session key for your AWS account. This is only needed when you are using temporary credentials.\n    parquet_infer_sampling : float\n        Random sample ratio of files that will have the metadata inspected.\n        Must be `0.0 < sampling <= 1.0`.\n        The higher, the more accurate.\n        The lower, the faster.\n    mode : str\n        Append, overwrite or upsert.\n    overwrite_method : str\n        Drop, cascade, truncate, or delete. Only applicable in overwrite mode.\n\n        "drop" - ``DROP ... RESTRICT`` - drops the table. Fails if there are any views that depend on it.\n        "cascade" - ``DROP ... CASCADE`` - drops the table, and all views that depend on it.\n        "truncate" - ``TRUNCATE ...`` - truncates the table, but immediately commits current\n        transaction & starts a new one, hence the overwrite happens in two transactions and is not atomic.\n        "delete" - ``DELETE FROM ...`` - deletes all rows from the table. Slow relative to the other methods.\n    diststyle : str\n        Redshift distribution styles. Must be in ["AUTO", "EVEN", "ALL", "KEY"].\n        https://docs.aws.amazon.com/redshift/latest/dg/t_Distributing_data.html\n    distkey : str, optional\n        Specifies a column name or positional number for the distribution key.\n    sortstyle : str\n        Sorting can be "COMPOUND" or "INTERLEAVED".\n        https://docs.aws.amazon.com/redshift/latest/dg/t_Sorting_data.html\n    sortkey : List[str], optional\n        List of columns to be sorted.\n    primary_keys : List[str], optional\n        Primary keys.\n    varchar_lengths_default : int\n        The size that will be set for all VARCHAR columns not specified with varchar_lengths.\n    varchar_lengths : Dict[str, int], optional\n        Dict of VARCHAR length by columns. (e.g. {"col1": 10, "col5": 200}).\n    serialize_to_json : bool\n        Should awswrangler add SERIALIZETOJSON parameter into the COPY command?\n        SERIALIZETOJSON is necessary to load nested data\n        https://docs.aws.amazon.com/redshift/latest/dg/ingest-super.html#copy_json\n    path_suffix : Union[str, List[str], None]\n        Suffix or List of suffixes to be scanned on s3 for the schema extraction\n        (e.g. [".gz.parquet", ".snappy.parquet"]).\n        Only has effect during the table creation.\n        If None, will try to read all files. (default)\n    path_ignore_suffix : Union[str, List[str], None]\n        Suffix or List of suffixes for S3 keys to be ignored during the schema extraction.\n        (e.g. [".csv", "_SUCCESS"]).\n        Only has effect during the table creation.\n        If None, will try to read all files. (default)\n    use_threads : bool, int\n        True to enable concurrent requests, False to disable multiple threads.\n        If enabled os.cpu_count() will be used as the max number of threads.\n        If integer is provided, specified number is used.\n    lock : bool\n        True to execute LOCK command inside the transaction to force serializable isolation.\n    commit_transaction : bool\n        Whether to commit the transaction. True by default.\n    manifest : bool\n        If set to true path argument accepts a S3 uri to a manifest file.\n    sql_copy_extra_params : Optional[List[str]]\n        Additional copy parameters to pass to the command. For example: ["STATUPDATE ON"]\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n    s3_additional_kwargs : Dict[str, str], optional\n        Forwarded to botocore requests.\n        e.g. s3_additional_kwargs={\'ServerSideEncryption\': \'aws:kms\', \'SSEKMSKeyId\': \'YOUR_KMS_KEY_ARN\'}\n    precombine_key : str, optional\n        When there is a primary_key match during upsert, this column will change the upsert method,\n        comparing the values of the specified column from source and target, and keeping the\n        larger of the two. Will only work when mode = upsert.\n    column_names: List[str], optional\n        List of column names to map source data fields to the target columns.\n\n    Returns\n    -------\n    None\n        None.\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> con = wr.redshift.connect("MY_GLUE_CONNECTION")\n    >>> wr.redshift.copy_from_files(\n    ...     path="s3://bucket/my_parquet_files/",\n    ...     con=con,\n    ...     table="my_table",\n    ...     schema="public",\n    ...     iam_role="arn:aws:iam::XXX:role/XXX"\n    ... )\n    >>> con.close()\n\n    '
    _logger.debug('Copying objects from S3 path: %s', path)
    autocommit_temp: bool = con.autocommit
    con.autocommit = False
    try:
        with con.cursor() as cursor:
            (created_table, created_schema) = _create_table(df=None, path=path, parquet_infer_sampling=parquet_infer_sampling, path_suffix=path_suffix, path_ignore_suffix=path_ignore_suffix, con=con, cursor=cursor, table=table, schema=schema, mode=mode, overwrite_method=overwrite_method, diststyle=diststyle, sortstyle=sortstyle, distkey=distkey, sortkey=sortkey, primary_keys=primary_keys, varchar_lengths_default=varchar_lengths_default, varchar_lengths=varchar_lengths, index=False, dtype=None, manifest=manifest, use_threads=use_threads, boto3_session=boto3_session, s3_additional_kwargs=s3_additional_kwargs, lock=lock)
            _copy(cursor=cursor, path=path, table=created_table, schema=created_schema, iam_role=iam_role, aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, aws_session_token=aws_session_token, boto3_session=boto3_session, serialize_to_json=serialize_to_json, sql_copy_extra_params=sql_copy_extra_params, manifest=manifest, column_names=column_names)
            if table != created_table:
                _upsert(cursor=cursor, schema=schema, table=table, temp_table=created_table, primary_keys=primary_keys, precombine_key=precombine_key, column_names=column_names)
            if commit_transaction:
                con.commit()
    except Exception as ex:
        con.rollback()
        _logger.error(ex)
        raise
    finally:
        con.autocommit = autocommit_temp

@_utils.validate_distributed_kwargs(unsupported_kwargs=['boto3_session', 's3_additional_kwargs'])
@_utils.check_optional_dependency(redshift_connector, 'redshift_connector')
def copy(df: pd.DataFrame, path: str, con: 'redshift_connector.Connection', table: str, schema: str, iam_role: Optional[str]=None, aws_access_key_id: Optional[str]=None, aws_secret_access_key: Optional[str]=None, aws_session_token: Optional[str]=None, index: bool=False, dtype: Optional[Dict[str, str]]=None, mode: _ToSqlModeLiteral='append', overwrite_method: _ToSqlOverwriteModeLiteral='drop', diststyle: _ToSqlDistStyleLiteral='AUTO', distkey: Optional[str]=None, sortstyle: _ToSqlSortStyleLiteral='COMPOUND', sortkey: Optional[List[str]]=None, primary_keys: Optional[List[str]]=None, varchar_lengths_default: int=256, varchar_lengths: Optional[Dict[str, int]]=None, serialize_to_json: bool=False, keep_files: bool=False, use_threads: Union[bool, int]=True, lock: bool=False, commit_transaction: bool=True, sql_copy_extra_params: Optional[List[str]]=None, boto3_session: Optional[boto3.Session]=None, s3_additional_kwargs: Optional[Dict[str, str]]=None, max_rows_by_file: Optional[int]=10000000, precombine_key: Optional[str]=None, use_column_names: bool=False) -> None:
    if False:
        for i in range(10):
            print('nop')
    'Load Pandas DataFrame as a Table on Amazon Redshift using parquet files on S3 as stage.\n\n    This is a **HIGH** latency and **HIGH** throughput alternative to `wr.redshift.to_sql()` to load large\n    DataFrames into Amazon Redshift through the ** SQL COPY command**.\n\n    This strategy has more overhead and requires more IAM privileges\n    than the regular `wr.redshift.to_sql()` function, so it is only recommended\n    to inserting +1K rows at once.\n\n    https://docs.aws.amazon.com/redshift/latest/dg/r_COPY.html\n\n    Note\n    ----\n    If the table does not exist yet,\n    it will be automatically created for you\n    using the Parquet metadata to\n    infer the columns data types.\n\n    Note\n    ----\n    In case of `use_threads=True` the number of threads\n    that will be spawned will be gotten from os.cpu_count().\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        Pandas DataFrame.\n    path : str\n        S3 path to write stage files (e.g. s3://bucket_name/any_name/).\n        Note: This path must be empty.\n    con : redshift_connector.Connection\n        Use redshift_connector.connect() to use "\n        "credentials directly or wr.redshift.connect() to fetch it from the Glue Catalog.\n    table : str\n        Table name\n    schema : str\n        Schema name\n    iam_role : str, optional\n        AWS IAM role with the related permissions.\n    aws_access_key_id : str, optional\n        The access key for your AWS account.\n    aws_secret_access_key : str, optional\n        The secret key for your AWS account.\n    aws_session_token : str, optional\n        The session key for your AWS account. This is only needed when you are using temporary credentials.\n    index : bool\n        True to store the DataFrame index in file, otherwise False to ignore it.\n    dtype : Dict[str, str], optional\n        Dictionary of columns names and Athena/Glue types to be casted.\n        Useful when you have columns with undetermined or mixed data types.\n        Only takes effect if dataset=True.\n        (e.g. {\'col name\': \'bigint\', \'col2 name\': \'int\'})\n    mode : str\n        Append, overwrite or upsert.\n    overwrite_method : str\n        Drop, cascade, truncate, or delete. Only applicable in overwrite mode.\n\n        "drop" - ``DROP ... RESTRICT`` - drops the table. Fails if there are any views that depend on it.\n        "cascade" - ``DROP ... CASCADE`` - drops the table, and all views that depend on it.\n        "truncate" - ``TRUNCATE ...`` - truncates the table, but immediately commits current\n        transaction & starts a new one, hence the overwrite happens in two transactions and is not atomic.\n        "delete" - ``DELETE FROM ...`` - deletes all rows from the table. Slow relative to the other methods.\n    diststyle : str\n        Redshift distribution styles. Must be in ["AUTO", "EVEN", "ALL", "KEY"].\n        https://docs.aws.amazon.com/redshift/latest/dg/t_Distributing_data.html\n    distkey : str, optional\n        Specifies a column name or positional number for the distribution key.\n    sortstyle : str\n        Sorting can be "COMPOUND" or "INTERLEAVED".\n        https://docs.aws.amazon.com/redshift/latest/dg/t_Sorting_data.html\n    sortkey : List[str], optional\n        List of columns to be sorted.\n    primary_keys : List[str], optional\n        Primary keys.\n    varchar_lengths_default : int\n        The size that will be set for all VARCHAR columns not specified with varchar_lengths.\n    varchar_lengths : Dict[str, int], optional\n        Dict of VARCHAR length by columns. (e.g. {"col1": 10, "col5": 200}).\n    keep_files : bool\n        Should keep stage files?\n    use_threads : bool, int\n        True to enable concurrent requests, False to disable multiple threads.\n        If enabled os.cpu_count() will be used as the max number of threads.\n        If integer is provided, specified number is used.\n    lock : bool\n        True to execute LOCK command inside the transaction to force serializable isolation.\n    commit_transaction : bool\n        Whether to commit the transaction. True by default.\n    sql_copy_extra_params : Optional[List[str]]\n        Additional copy parameters to pass to the command. For example: ["STATUPDATE ON"]\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n    s3_additional_kwargs : Dict[str, str], optional\n        Forwarded to botocore requests.\n        e.g. s3_additional_kwargs={\'ServerSideEncryption\': \'aws:kms\', \'SSEKMSKeyId\': \'YOUR_KMS_KEY_ARN\'}\n    max_rows_by_file : int\n        Max number of rows in each file.\n        (e.g. 33554432, 268435456)\n    precombine_key : str, optional\n        When there is a primary_key match during upsert, this column will change the upsert method,\n        comparing the values of the specified column from source and target, and keeping the\n        larger of the two. Will only work when mode = upsert.\n    use_column_names: bool\n        If set to True, will use the column names of the DataFrame for generating the INSERT SQL Query.\n        E.g. If the DataFrame has two columns `col1` and `col3` and `use_column_names` is True, data will only be\n        inserted into the database columns `col1` and `col3`.\n\n    Returns\n    -------\n    None\n        None.\n\n    Examples\n    --------\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> con = wr.redshift.connect("MY_GLUE_CONNECTION")\n    >>> wr.redshift.copy(\n    ...     df=pd.DataFrame({\'col\': [1, 2, 3]}),\n    ...     path="s3://bucket/my_parquet_files/",\n    ...     con=con,\n    ...     table="my_table",\n    ...     schema="public",\n    ...     iam_role="arn:aws:iam::XXX:role/XXX"\n    ... )\n    >>> con.close()\n\n    '
    path = path[:-1] if path.endswith('*') else path
    path = path if path.endswith('/') else f'{path}/'
    column_names = [f'"{column}"' for column in df.columns] if use_column_names else []
    if s3.list_objects(path=path, boto3_session=boto3_session, s3_additional_kwargs=s3_additional_kwargs):
        raise exceptions.InvalidArgument(f'The received S3 path ({path}) is not empty. Please, provide a different path or use wr.s3.delete_objects() to clean up the current one.')
    try:
        s3.to_parquet(df=df, path=path, index=index, dataset=True, mode='append', dtype=dtype, use_threads=use_threads, boto3_session=boto3_session, s3_additional_kwargs=s3_additional_kwargs, max_rows_by_file=max_rows_by_file)
        copy_from_files(path=path, con=con, table=table, schema=schema, iam_role=iam_role, aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, aws_session_token=aws_session_token, mode=mode, overwrite_method=overwrite_method, diststyle=diststyle, distkey=distkey, sortstyle=sortstyle, sortkey=sortkey, primary_keys=primary_keys, varchar_lengths_default=varchar_lengths_default, varchar_lengths=varchar_lengths, serialize_to_json=serialize_to_json, use_threads=use_threads, lock=lock, commit_transaction=commit_transaction, boto3_session=boto3_session, s3_additional_kwargs=s3_additional_kwargs, sql_copy_extra_params=sql_copy_extra_params, precombine_key=precombine_key, column_names=column_names)
    finally:
        if keep_files is False:
            _logger.debug('Deleting objects in S3 path: %s', path)
            s3.delete_objects(path=path, use_threads=use_threads, boto3_session=boto3_session, s3_additional_kwargs=s3_additional_kwargs)