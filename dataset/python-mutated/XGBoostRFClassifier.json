[
    {
        "func_name": "fit",
        "original": "def fit(self, data_dictionary: Dict, dk: FreqaiDataKitchen, **kwargs) -> Any:\n    \"\"\"\n        User sets up the training and test data to fit their desired model here\n        :param data_dictionary: the dictionary holding all data for train, test,\n            labels, weights\n        :param dk: The datakitchen object for the current coin/model\n        \"\"\"\n    X = data_dictionary['train_features'].to_numpy()\n    y = data_dictionary['train_labels'].to_numpy()[:, 0]\n    le = LabelEncoder()\n    if not is_integer_dtype(y):\n        y = pd.Series(le.fit_transform(y), dtype='int64')\n    if self.freqai_info.get('data_split_parameters', {}).get('test_size', 0.1) == 0:\n        eval_set = None\n    else:\n        test_features = data_dictionary['test_features'].to_numpy()\n        test_labels = data_dictionary['test_labels'].to_numpy()[:, 0]\n        if not is_integer_dtype(test_labels):\n            test_labels = pd.Series(le.transform(test_labels), dtype='int64')\n        eval_set = [(test_features, test_labels)]\n    train_weights = data_dictionary['train_weights']\n    init_model = self.get_init_model(dk.pair)\n    model = XGBRFClassifier(**self.model_training_parameters)\n    model.fit(X=X, y=y, eval_set=eval_set, sample_weight=train_weights, xgb_model=init_model)\n    return model",
        "mutated": [
            "def fit(self, data_dictionary: Dict, dk: FreqaiDataKitchen, **kwargs) -> Any:\n    if False:\n        i = 10\n    '\\n        User sets up the training and test data to fit their desired model here\\n        :param data_dictionary: the dictionary holding all data for train, test,\\n            labels, weights\\n        :param dk: The datakitchen object for the current coin/model\\n        '\n    X = data_dictionary['train_features'].to_numpy()\n    y = data_dictionary['train_labels'].to_numpy()[:, 0]\n    le = LabelEncoder()\n    if not is_integer_dtype(y):\n        y = pd.Series(le.fit_transform(y), dtype='int64')\n    if self.freqai_info.get('data_split_parameters', {}).get('test_size', 0.1) == 0:\n        eval_set = None\n    else:\n        test_features = data_dictionary['test_features'].to_numpy()\n        test_labels = data_dictionary['test_labels'].to_numpy()[:, 0]\n        if not is_integer_dtype(test_labels):\n            test_labels = pd.Series(le.transform(test_labels), dtype='int64')\n        eval_set = [(test_features, test_labels)]\n    train_weights = data_dictionary['train_weights']\n    init_model = self.get_init_model(dk.pair)\n    model = XGBRFClassifier(**self.model_training_parameters)\n    model.fit(X=X, y=y, eval_set=eval_set, sample_weight=train_weights, xgb_model=init_model)\n    return model",
            "def fit(self, data_dictionary: Dict, dk: FreqaiDataKitchen, **kwargs) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        User sets up the training and test data to fit their desired model here\\n        :param data_dictionary: the dictionary holding all data for train, test,\\n            labels, weights\\n        :param dk: The datakitchen object for the current coin/model\\n        '\n    X = data_dictionary['train_features'].to_numpy()\n    y = data_dictionary['train_labels'].to_numpy()[:, 0]\n    le = LabelEncoder()\n    if not is_integer_dtype(y):\n        y = pd.Series(le.fit_transform(y), dtype='int64')\n    if self.freqai_info.get('data_split_parameters', {}).get('test_size', 0.1) == 0:\n        eval_set = None\n    else:\n        test_features = data_dictionary['test_features'].to_numpy()\n        test_labels = data_dictionary['test_labels'].to_numpy()[:, 0]\n        if not is_integer_dtype(test_labels):\n            test_labels = pd.Series(le.transform(test_labels), dtype='int64')\n        eval_set = [(test_features, test_labels)]\n    train_weights = data_dictionary['train_weights']\n    init_model = self.get_init_model(dk.pair)\n    model = XGBRFClassifier(**self.model_training_parameters)\n    model.fit(X=X, y=y, eval_set=eval_set, sample_weight=train_weights, xgb_model=init_model)\n    return model",
            "def fit(self, data_dictionary: Dict, dk: FreqaiDataKitchen, **kwargs) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        User sets up the training and test data to fit their desired model here\\n        :param data_dictionary: the dictionary holding all data for train, test,\\n            labels, weights\\n        :param dk: The datakitchen object for the current coin/model\\n        '\n    X = data_dictionary['train_features'].to_numpy()\n    y = data_dictionary['train_labels'].to_numpy()[:, 0]\n    le = LabelEncoder()\n    if not is_integer_dtype(y):\n        y = pd.Series(le.fit_transform(y), dtype='int64')\n    if self.freqai_info.get('data_split_parameters', {}).get('test_size', 0.1) == 0:\n        eval_set = None\n    else:\n        test_features = data_dictionary['test_features'].to_numpy()\n        test_labels = data_dictionary['test_labels'].to_numpy()[:, 0]\n        if not is_integer_dtype(test_labels):\n            test_labels = pd.Series(le.transform(test_labels), dtype='int64')\n        eval_set = [(test_features, test_labels)]\n    train_weights = data_dictionary['train_weights']\n    init_model = self.get_init_model(dk.pair)\n    model = XGBRFClassifier(**self.model_training_parameters)\n    model.fit(X=X, y=y, eval_set=eval_set, sample_weight=train_weights, xgb_model=init_model)\n    return model",
            "def fit(self, data_dictionary: Dict, dk: FreqaiDataKitchen, **kwargs) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        User sets up the training and test data to fit their desired model here\\n        :param data_dictionary: the dictionary holding all data for train, test,\\n            labels, weights\\n        :param dk: The datakitchen object for the current coin/model\\n        '\n    X = data_dictionary['train_features'].to_numpy()\n    y = data_dictionary['train_labels'].to_numpy()[:, 0]\n    le = LabelEncoder()\n    if not is_integer_dtype(y):\n        y = pd.Series(le.fit_transform(y), dtype='int64')\n    if self.freqai_info.get('data_split_parameters', {}).get('test_size', 0.1) == 0:\n        eval_set = None\n    else:\n        test_features = data_dictionary['test_features'].to_numpy()\n        test_labels = data_dictionary['test_labels'].to_numpy()[:, 0]\n        if not is_integer_dtype(test_labels):\n            test_labels = pd.Series(le.transform(test_labels), dtype='int64')\n        eval_set = [(test_features, test_labels)]\n    train_weights = data_dictionary['train_weights']\n    init_model = self.get_init_model(dk.pair)\n    model = XGBRFClassifier(**self.model_training_parameters)\n    model.fit(X=X, y=y, eval_set=eval_set, sample_weight=train_weights, xgb_model=init_model)\n    return model",
            "def fit(self, data_dictionary: Dict, dk: FreqaiDataKitchen, **kwargs) -> Any:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        User sets up the training and test data to fit their desired model here\\n        :param data_dictionary: the dictionary holding all data for train, test,\\n            labels, weights\\n        :param dk: The datakitchen object for the current coin/model\\n        '\n    X = data_dictionary['train_features'].to_numpy()\n    y = data_dictionary['train_labels'].to_numpy()[:, 0]\n    le = LabelEncoder()\n    if not is_integer_dtype(y):\n        y = pd.Series(le.fit_transform(y), dtype='int64')\n    if self.freqai_info.get('data_split_parameters', {}).get('test_size', 0.1) == 0:\n        eval_set = None\n    else:\n        test_features = data_dictionary['test_features'].to_numpy()\n        test_labels = data_dictionary['test_labels'].to_numpy()[:, 0]\n        if not is_integer_dtype(test_labels):\n            test_labels = pd.Series(le.transform(test_labels), dtype='int64')\n        eval_set = [(test_features, test_labels)]\n    train_weights = data_dictionary['train_weights']\n    init_model = self.get_init_model(dk.pair)\n    model = XGBRFClassifier(**self.model_training_parameters)\n    model.fit(X=X, y=y, eval_set=eval_set, sample_weight=train_weights, xgb_model=init_model)\n    return model"
        ]
    },
    {
        "func_name": "predict",
        "original": "def predict(self, unfiltered_df: DataFrame, dk: FreqaiDataKitchen, **kwargs) -> Tuple[DataFrame, npt.NDArray[np.int_]]:\n    \"\"\"\n        Filter the prediction features data and predict with it.\n        :param  unfiltered_df: Full dataframe for the current backtest period.\n        :return:\n        :pred_df: dataframe containing the predictions\n        :do_predict: np.array of 1s and 0s to indicate places where freqai needed to remove\n        data (NaNs) or felt uncertain about data (PCA and DI index)\n        \"\"\"\n    (pred_df, dk.do_predict) = super().predict(unfiltered_df, dk, **kwargs)\n    le = LabelEncoder()\n    label = dk.label_list[0]\n    labels_before = list(dk.data['labels_std'].keys())\n    labels_after = le.fit_transform(labels_before).tolist()\n    pred_df[label] = le.inverse_transform(pred_df[label])\n    pred_df = pred_df.rename(columns={labels_after[i]: labels_before[i] for i in range(len(labels_before))})\n    return (pred_df, dk.do_predict)",
        "mutated": [
            "def predict(self, unfiltered_df: DataFrame, dk: FreqaiDataKitchen, **kwargs) -> Tuple[DataFrame, npt.NDArray[np.int_]]:\n    if False:\n        i = 10\n    '\\n        Filter the prediction features data and predict with it.\\n        :param  unfiltered_df: Full dataframe for the current backtest period.\\n        :return:\\n        :pred_df: dataframe containing the predictions\\n        :do_predict: np.array of 1s and 0s to indicate places where freqai needed to remove\\n        data (NaNs) or felt uncertain about data (PCA and DI index)\\n        '\n    (pred_df, dk.do_predict) = super().predict(unfiltered_df, dk, **kwargs)\n    le = LabelEncoder()\n    label = dk.label_list[0]\n    labels_before = list(dk.data['labels_std'].keys())\n    labels_after = le.fit_transform(labels_before).tolist()\n    pred_df[label] = le.inverse_transform(pred_df[label])\n    pred_df = pred_df.rename(columns={labels_after[i]: labels_before[i] for i in range(len(labels_before))})\n    return (pred_df, dk.do_predict)",
            "def predict(self, unfiltered_df: DataFrame, dk: FreqaiDataKitchen, **kwargs) -> Tuple[DataFrame, npt.NDArray[np.int_]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Filter the prediction features data and predict with it.\\n        :param  unfiltered_df: Full dataframe for the current backtest period.\\n        :return:\\n        :pred_df: dataframe containing the predictions\\n        :do_predict: np.array of 1s and 0s to indicate places where freqai needed to remove\\n        data (NaNs) or felt uncertain about data (PCA and DI index)\\n        '\n    (pred_df, dk.do_predict) = super().predict(unfiltered_df, dk, **kwargs)\n    le = LabelEncoder()\n    label = dk.label_list[0]\n    labels_before = list(dk.data['labels_std'].keys())\n    labels_after = le.fit_transform(labels_before).tolist()\n    pred_df[label] = le.inverse_transform(pred_df[label])\n    pred_df = pred_df.rename(columns={labels_after[i]: labels_before[i] for i in range(len(labels_before))})\n    return (pred_df, dk.do_predict)",
            "def predict(self, unfiltered_df: DataFrame, dk: FreqaiDataKitchen, **kwargs) -> Tuple[DataFrame, npt.NDArray[np.int_]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Filter the prediction features data and predict with it.\\n        :param  unfiltered_df: Full dataframe for the current backtest period.\\n        :return:\\n        :pred_df: dataframe containing the predictions\\n        :do_predict: np.array of 1s and 0s to indicate places where freqai needed to remove\\n        data (NaNs) or felt uncertain about data (PCA and DI index)\\n        '\n    (pred_df, dk.do_predict) = super().predict(unfiltered_df, dk, **kwargs)\n    le = LabelEncoder()\n    label = dk.label_list[0]\n    labels_before = list(dk.data['labels_std'].keys())\n    labels_after = le.fit_transform(labels_before).tolist()\n    pred_df[label] = le.inverse_transform(pred_df[label])\n    pred_df = pred_df.rename(columns={labels_after[i]: labels_before[i] for i in range(len(labels_before))})\n    return (pred_df, dk.do_predict)",
            "def predict(self, unfiltered_df: DataFrame, dk: FreqaiDataKitchen, **kwargs) -> Tuple[DataFrame, npt.NDArray[np.int_]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Filter the prediction features data and predict with it.\\n        :param  unfiltered_df: Full dataframe for the current backtest period.\\n        :return:\\n        :pred_df: dataframe containing the predictions\\n        :do_predict: np.array of 1s and 0s to indicate places where freqai needed to remove\\n        data (NaNs) or felt uncertain about data (PCA and DI index)\\n        '\n    (pred_df, dk.do_predict) = super().predict(unfiltered_df, dk, **kwargs)\n    le = LabelEncoder()\n    label = dk.label_list[0]\n    labels_before = list(dk.data['labels_std'].keys())\n    labels_after = le.fit_transform(labels_before).tolist()\n    pred_df[label] = le.inverse_transform(pred_df[label])\n    pred_df = pred_df.rename(columns={labels_after[i]: labels_before[i] for i in range(len(labels_before))})\n    return (pred_df, dk.do_predict)",
            "def predict(self, unfiltered_df: DataFrame, dk: FreqaiDataKitchen, **kwargs) -> Tuple[DataFrame, npt.NDArray[np.int_]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Filter the prediction features data and predict with it.\\n        :param  unfiltered_df: Full dataframe for the current backtest period.\\n        :return:\\n        :pred_df: dataframe containing the predictions\\n        :do_predict: np.array of 1s and 0s to indicate places where freqai needed to remove\\n        data (NaNs) or felt uncertain about data (PCA and DI index)\\n        '\n    (pred_df, dk.do_predict) = super().predict(unfiltered_df, dk, **kwargs)\n    le = LabelEncoder()\n    label = dk.label_list[0]\n    labels_before = list(dk.data['labels_std'].keys())\n    labels_after = le.fit_transform(labels_before).tolist()\n    pred_df[label] = le.inverse_transform(pred_df[label])\n    pred_df = pred_df.rename(columns={labels_after[i]: labels_before[i] for i in range(len(labels_before))})\n    return (pred_df, dk.do_predict)"
        ]
    }
]