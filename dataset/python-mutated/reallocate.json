[
    {
        "func_name": "__init__",
        "original": "def __init__(self, sort_id, word_id, value):\n    self.sort_id = sort_id\n    self.word_id = word_id\n    self.value = value",
        "mutated": [
            "def __init__(self, sort_id, word_id, value):\n    if False:\n        i = 10\n    self.sort_id = sort_id\n    self.word_id = word_id\n    self.value = value",
            "def __init__(self, sort_id, word_id, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.sort_id = sort_id\n    self.word_id = word_id\n    self.value = value",
            "def __init__(self, sort_id, word_id, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.sort_id = sort_id\n    self.word_id = word_id\n    self.value = value",
            "def __init__(self, sort_id, word_id, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.sort_id = sort_id\n    self.word_id = word_id\n    self.value = value",
            "def __init__(self, sort_id, word_id, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.sort_id = sort_id\n    self.word_id = word_id\n    self.value = value"
        ]
    },
    {
        "func_name": "__cmp__",
        "original": "def __cmp__(self, other):\n    return cmp(self.value, other.value)",
        "mutated": [
            "def __cmp__(self, other):\n    if False:\n        i = 10\n    return cmp(self.value, other.value)",
            "def __cmp__(self, other):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return cmp(self.value, other.value)",
            "def __cmp__(self, other):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return cmp(self.value, other.value)",
            "def __cmp__(self, other):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return cmp(self.value, other.value)",
            "def __cmp__(self, other):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return cmp(self.value, other.value)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, prob_row, prob_col, word_id):\n    self.prob_row = prob_row\n    self.prob_col = prob_col\n    self.word_id = word_id\n    self.row_id = 0\n    self.col_id = 0\n    self.row_loss_sum = 0\n    self.col_loss_sum = 0\n    for i in range(len(prob_row)):\n        self.row_loss_sum += prob_row[i][0]\n        self.col_loss_sum += prob_col[i][0]",
        "mutated": [
            "def __init__(self, prob_row, prob_col, word_id):\n    if False:\n        i = 10\n    self.prob_row = prob_row\n    self.prob_col = prob_col\n    self.word_id = word_id\n    self.row_id = 0\n    self.col_id = 0\n    self.row_loss_sum = 0\n    self.col_loss_sum = 0\n    for i in range(len(prob_row)):\n        self.row_loss_sum += prob_row[i][0]\n        self.col_loss_sum += prob_col[i][0]",
            "def __init__(self, prob_row, prob_col, word_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.prob_row = prob_row\n    self.prob_col = prob_col\n    self.word_id = word_id\n    self.row_id = 0\n    self.col_id = 0\n    self.row_loss_sum = 0\n    self.col_loss_sum = 0\n    for i in range(len(prob_row)):\n        self.row_loss_sum += prob_row[i][0]\n        self.col_loss_sum += prob_col[i][0]",
            "def __init__(self, prob_row, prob_col, word_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.prob_row = prob_row\n    self.prob_col = prob_col\n    self.word_id = word_id\n    self.row_id = 0\n    self.col_id = 0\n    self.row_loss_sum = 0\n    self.col_loss_sum = 0\n    for i in range(len(prob_row)):\n        self.row_loss_sum += prob_row[i][0]\n        self.col_loss_sum += prob_col[i][0]",
            "def __init__(self, prob_row, prob_col, word_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.prob_row = prob_row\n    self.prob_col = prob_col\n    self.word_id = word_id\n    self.row_id = 0\n    self.col_id = 0\n    self.row_loss_sum = 0\n    self.col_loss_sum = 0\n    for i in range(len(prob_row)):\n        self.row_loss_sum += prob_row[i][0]\n        self.col_loss_sum += prob_col[i][0]",
            "def __init__(self, prob_row, prob_col, word_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.prob_row = prob_row\n    self.prob_col = prob_col\n    self.word_id = word_id\n    self.row_id = 0\n    self.col_id = 0\n    self.row_loss_sum = 0\n    self.col_loss_sum = 0\n    for i in range(len(prob_row)):\n        self.row_loss_sum += prob_row[i][0]\n        self.col_loss_sum += prob_col[i][0]"
        ]
    },
    {
        "func_name": "next_row",
        "original": "def next_row(self):\n    sort_id = self.prob_row[self.row_id][1]\n    self.row_loss_sum -= self.prob_row[self.row_id][0]\n    self.row_id += 1\n    value = 0 if self.row_id == g_vocab_sqrt - 1 else 1.0 * self.row_loss_sum / (g_vocab_sqrt - self.row_id - 1)\n    return SortNode(sort_id, self.word_id, value)",
        "mutated": [
            "def next_row(self):\n    if False:\n        i = 10\n    sort_id = self.prob_row[self.row_id][1]\n    self.row_loss_sum -= self.prob_row[self.row_id][0]\n    self.row_id += 1\n    value = 0 if self.row_id == g_vocab_sqrt - 1 else 1.0 * self.row_loss_sum / (g_vocab_sqrt - self.row_id - 1)\n    return SortNode(sort_id, self.word_id, value)",
            "def next_row(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    sort_id = self.prob_row[self.row_id][1]\n    self.row_loss_sum -= self.prob_row[self.row_id][0]\n    self.row_id += 1\n    value = 0 if self.row_id == g_vocab_sqrt - 1 else 1.0 * self.row_loss_sum / (g_vocab_sqrt - self.row_id - 1)\n    return SortNode(sort_id, self.word_id, value)",
            "def next_row(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    sort_id = self.prob_row[self.row_id][1]\n    self.row_loss_sum -= self.prob_row[self.row_id][0]\n    self.row_id += 1\n    value = 0 if self.row_id == g_vocab_sqrt - 1 else 1.0 * self.row_loss_sum / (g_vocab_sqrt - self.row_id - 1)\n    return SortNode(sort_id, self.word_id, value)",
            "def next_row(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    sort_id = self.prob_row[self.row_id][1]\n    self.row_loss_sum -= self.prob_row[self.row_id][0]\n    self.row_id += 1\n    value = 0 if self.row_id == g_vocab_sqrt - 1 else 1.0 * self.row_loss_sum / (g_vocab_sqrt - self.row_id - 1)\n    return SortNode(sort_id, self.word_id, value)",
            "def next_row(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    sort_id = self.prob_row[self.row_id][1]\n    self.row_loss_sum -= self.prob_row[self.row_id][0]\n    self.row_id += 1\n    value = 0 if self.row_id == g_vocab_sqrt - 1 else 1.0 * self.row_loss_sum / (g_vocab_sqrt - self.row_id - 1)\n    return SortNode(sort_id, self.word_id, value)"
        ]
    },
    {
        "func_name": "next_col",
        "original": "def next_col(self):\n    sort_id = self.prob_col[self.col_id][1]\n    self.col_loss_sum -= self.prob_col[self.col_id][0]\n    self.col_id += 1\n    value = 0 if self.col_id == g_vocab_sqrt - 1 else 1.0 * self.col_loss_sum / (g_vocab_sqrt - self.col_id - 1)\n    return SortNode(sort_id, self.word_id, value)",
        "mutated": [
            "def next_col(self):\n    if False:\n        i = 10\n    sort_id = self.prob_col[self.col_id][1]\n    self.col_loss_sum -= self.prob_col[self.col_id][0]\n    self.col_id += 1\n    value = 0 if self.col_id == g_vocab_sqrt - 1 else 1.0 * self.col_loss_sum / (g_vocab_sqrt - self.col_id - 1)\n    return SortNode(sort_id, self.word_id, value)",
            "def next_col(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    sort_id = self.prob_col[self.col_id][1]\n    self.col_loss_sum -= self.prob_col[self.col_id][0]\n    self.col_id += 1\n    value = 0 if self.col_id == g_vocab_sqrt - 1 else 1.0 * self.col_loss_sum / (g_vocab_sqrt - self.col_id - 1)\n    return SortNode(sort_id, self.word_id, value)",
            "def next_col(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    sort_id = self.prob_col[self.col_id][1]\n    self.col_loss_sum -= self.prob_col[self.col_id][0]\n    self.col_id += 1\n    value = 0 if self.col_id == g_vocab_sqrt - 1 else 1.0 * self.col_loss_sum / (g_vocab_sqrt - self.col_id - 1)\n    return SortNode(sort_id, self.word_id, value)",
            "def next_col(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    sort_id = self.prob_col[self.col_id][1]\n    self.col_loss_sum -= self.prob_col[self.col_id][0]\n    self.col_id += 1\n    value = 0 if self.col_id == g_vocab_sqrt - 1 else 1.0 * self.col_loss_sum / (g_vocab_sqrt - self.col_id - 1)\n    return SortNode(sort_id, self.word_id, value)",
            "def next_col(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    sort_id = self.prob_col[self.col_id][1]\n    self.col_loss_sum -= self.prob_col[self.col_id][0]\n    self.col_id += 1\n    value = 0 if self.col_id == g_vocab_sqrt - 1 else 1.0 * self.col_loss_sum / (g_vocab_sqrt - self.col_id - 1)\n    return SortNode(sort_id, self.word_id, value)"
        ]
    },
    {
        "func_name": "get_word_location",
        "original": "def get_word_location(word_path):\n    vocab = []\n    with codecs.open(word_path, 'r', 'utf-8') as input_file:\n        for line in input_file:\n            line = line.strip()\n            vocab.append(line)\n    return vocab",
        "mutated": [
            "def get_word_location(word_path):\n    if False:\n        i = 10\n    vocab = []\n    with codecs.open(word_path, 'r', 'utf-8') as input_file:\n        for line in input_file:\n            line = line.strip()\n            vocab.append(line)\n    return vocab",
            "def get_word_location(word_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    vocab = []\n    with codecs.open(word_path, 'r', 'utf-8') as input_file:\n        for line in input_file:\n            line = line.strip()\n            vocab.append(line)\n    return vocab",
            "def get_word_location(word_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    vocab = []\n    with codecs.open(word_path, 'r', 'utf-8') as input_file:\n        for line in input_file:\n            line = line.strip()\n            vocab.append(line)\n    return vocab",
            "def get_word_location(word_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    vocab = []\n    with codecs.open(word_path, 'r', 'utf-8') as input_file:\n        for line in input_file:\n            line = line.strip()\n            vocab.append(line)\n    return vocab",
            "def get_word_location(word_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    vocab = []\n    with codecs.open(word_path, 'r', 'utf-8') as input_file:\n        for line in input_file:\n            line = line.strip()\n            vocab.append(line)\n    return vocab"
        ]
    },
    {
        "func_name": "save_allocate_word_location",
        "original": "def save_allocate_word_location(table, vocab, save_path):\n    string_path = save_path + '.string'\n    with codecs.open(save_path, 'w', 'utf-8') as output_file, codecs.open(string_path, 'w', 'utf-8') as output_string_file:\n        for i in range(g_vocab_sqrt):\n            for j in range(g_vocab_sqrt):\n                if table[i][j] == -1:\n                    output_string_file.write('<null> ')\n                else:\n                    output_string_file.write(vocab[table[i][j]] + ' ')\n                output_file.write('%d ' % table[i][j])\n            output_string_file.write('\\n')\n            output_file.write('\\n')",
        "mutated": [
            "def save_allocate_word_location(table, vocab, save_path):\n    if False:\n        i = 10\n    string_path = save_path + '.string'\n    with codecs.open(save_path, 'w', 'utf-8') as output_file, codecs.open(string_path, 'w', 'utf-8') as output_string_file:\n        for i in range(g_vocab_sqrt):\n            for j in range(g_vocab_sqrt):\n                if table[i][j] == -1:\n                    output_string_file.write('<null> ')\n                else:\n                    output_string_file.write(vocab[table[i][j]] + ' ')\n                output_file.write('%d ' % table[i][j])\n            output_string_file.write('\\n')\n            output_file.write('\\n')",
            "def save_allocate_word_location(table, vocab, save_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    string_path = save_path + '.string'\n    with codecs.open(save_path, 'w', 'utf-8') as output_file, codecs.open(string_path, 'w', 'utf-8') as output_string_file:\n        for i in range(g_vocab_sqrt):\n            for j in range(g_vocab_sqrt):\n                if table[i][j] == -1:\n                    output_string_file.write('<null> ')\n                else:\n                    output_string_file.write(vocab[table[i][j]] + ' ')\n                output_file.write('%d ' % table[i][j])\n            output_string_file.write('\\n')\n            output_file.write('\\n')",
            "def save_allocate_word_location(table, vocab, save_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    string_path = save_path + '.string'\n    with codecs.open(save_path, 'w', 'utf-8') as output_file, codecs.open(string_path, 'w', 'utf-8') as output_string_file:\n        for i in range(g_vocab_sqrt):\n            for j in range(g_vocab_sqrt):\n                if table[i][j] == -1:\n                    output_string_file.write('<null> ')\n                else:\n                    output_string_file.write(vocab[table[i][j]] + ' ')\n                output_file.write('%d ' % table[i][j])\n            output_string_file.write('\\n')\n            output_file.write('\\n')",
            "def save_allocate_word_location(table, vocab, save_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    string_path = save_path + '.string'\n    with codecs.open(save_path, 'w', 'utf-8') as output_file, codecs.open(string_path, 'w', 'utf-8') as output_string_file:\n        for i in range(g_vocab_sqrt):\n            for j in range(g_vocab_sqrt):\n                if table[i][j] == -1:\n                    output_string_file.write('<null> ')\n                else:\n                    output_string_file.write(vocab[table[i][j]] + ' ')\n                output_file.write('%d ' % table[i][j])\n            output_string_file.write('\\n')\n            output_file.write('\\n')",
            "def save_allocate_word_location(table, vocab, save_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    string_path = save_path + '.string'\n    with codecs.open(save_path, 'w', 'utf-8') as output_file, codecs.open(string_path, 'w', 'utf-8') as output_string_file:\n        for i in range(g_vocab_sqrt):\n            for j in range(g_vocab_sqrt):\n                if table[i][j] == -1:\n                    output_string_file.write('<null> ')\n                else:\n                    output_string_file.write(vocab[table[i][j]] + ' ')\n                output_file.write('%d ' % table[i][j])\n            output_string_file.write('\\n')\n            output_file.write('\\n')"
        ]
    },
    {
        "func_name": "reallocate_table",
        "original": "def reallocate_table(row, col, vocab_size, vocab_base, save_location_path, word_path):\n    \"\"\"\n     The allocate algorithm implement by python\n     Params:\n        content_row        : the loss vector of row\n        content_col        : the loss vector of col\n        vocabsize          : the size of vocabulary\n        vocabbase          : the sqrt of vocabuary size\n        save_location_path : the path of next word location, the reallocated table will be saved\n                               into this path\n        word_path          : the path of word table\n    \"\"\"\n    start = time.time()\n    global g_vocab_size\n    global g_vocab_sqrt\n    g_vocab_size = vocab_size\n    g_vocab_sqrt = vocab_base\n    prob_table = []\n    table = []\n    freq = vocab_size / 20\n    search_Queue = Q.PriorityQueue()\n    for i in range(vocab_size):\n        (current_row, current_col) = ([], [])\n        for j in range(vocab_base):\n            current_row.append((row[i][j], j))\n            current_col.append((col[i][j], j))\n        current_row.sort()\n        current_col.sort()\n        prob_table.append(InsertNode(current_row, current_col, i))\n        if i % freq == 0:\n            print('\\t\\t\\tFinish {:8d} / {:8d} Line'.format(i, vocab_size))\n    for i in range(vocab_base):\n        table.append([])\n    print('Ready ...')\n    print('Start to assign row for every word')\n    for i in range(vocab_size):\n        search_Queue.put(prob_table[i].next_row())\n    while not search_Queue.empty():\n        top_node = search_Queue.get()\n        word_id = top_node.word_id\n        row_id = top_node.sort_id\n        if len(table[row_id]) == g_vocab_sqrt:\n            search_Queue.put(prob_table[word_id].next_row())\n        else:\n            table[row_id].append(word_id)\n    print('Finish assign row')\n    print('Start to assign col for every word')\n    print('Finish assign col')\n    for i in range(g_vocab_sqrt):\n        for _ in range(len(table[i])):\n            col_node = prob_table[table[i][_]].next_col()\n            search_Queue.put(col_node)\n            table[i][_] = -1\n        for _ in range(len(table[i]), g_vocab_sqrt):\n            table[i].append(-1)\n        while not search_Queue.empty():\n            top_node = search_Queue.get()\n            word_id = top_node.word_id\n            col_id = top_node.sort_id\n            if table[i][col_id] == -1:\n                table[i][col_id] = word_id\n            else:\n                search_Queue.put(prob_table[word_id].next_col())\n    vocab = get_word_location(word_path)\n    save_allocate_word_location(table, vocab, save_location_path)\n    end = time.time()\n    print('Reallocate word location cost {} seconds'.format(end - start))",
        "mutated": [
            "def reallocate_table(row, col, vocab_size, vocab_base, save_location_path, word_path):\n    if False:\n        i = 10\n    '\\n     The allocate algorithm implement by python\\n     Params:\\n        content_row        : the loss vector of row\\n        content_col        : the loss vector of col\\n        vocabsize          : the size of vocabulary\\n        vocabbase          : the sqrt of vocabuary size\\n        save_location_path : the path of next word location, the reallocated table will be saved\\n                               into this path\\n        word_path          : the path of word table\\n    '\n    start = time.time()\n    global g_vocab_size\n    global g_vocab_sqrt\n    g_vocab_size = vocab_size\n    g_vocab_sqrt = vocab_base\n    prob_table = []\n    table = []\n    freq = vocab_size / 20\n    search_Queue = Q.PriorityQueue()\n    for i in range(vocab_size):\n        (current_row, current_col) = ([], [])\n        for j in range(vocab_base):\n            current_row.append((row[i][j], j))\n            current_col.append((col[i][j], j))\n        current_row.sort()\n        current_col.sort()\n        prob_table.append(InsertNode(current_row, current_col, i))\n        if i % freq == 0:\n            print('\\t\\t\\tFinish {:8d} / {:8d} Line'.format(i, vocab_size))\n    for i in range(vocab_base):\n        table.append([])\n    print('Ready ...')\n    print('Start to assign row for every word')\n    for i in range(vocab_size):\n        search_Queue.put(prob_table[i].next_row())\n    while not search_Queue.empty():\n        top_node = search_Queue.get()\n        word_id = top_node.word_id\n        row_id = top_node.sort_id\n        if len(table[row_id]) == g_vocab_sqrt:\n            search_Queue.put(prob_table[word_id].next_row())\n        else:\n            table[row_id].append(word_id)\n    print('Finish assign row')\n    print('Start to assign col for every word')\n    print('Finish assign col')\n    for i in range(g_vocab_sqrt):\n        for _ in range(len(table[i])):\n            col_node = prob_table[table[i][_]].next_col()\n            search_Queue.put(col_node)\n            table[i][_] = -1\n        for _ in range(len(table[i]), g_vocab_sqrt):\n            table[i].append(-1)\n        while not search_Queue.empty():\n            top_node = search_Queue.get()\n            word_id = top_node.word_id\n            col_id = top_node.sort_id\n            if table[i][col_id] == -1:\n                table[i][col_id] = word_id\n            else:\n                search_Queue.put(prob_table[word_id].next_col())\n    vocab = get_word_location(word_path)\n    save_allocate_word_location(table, vocab, save_location_path)\n    end = time.time()\n    print('Reallocate word location cost {} seconds'.format(end - start))",
            "def reallocate_table(row, col, vocab_size, vocab_base, save_location_path, word_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n     The allocate algorithm implement by python\\n     Params:\\n        content_row        : the loss vector of row\\n        content_col        : the loss vector of col\\n        vocabsize          : the size of vocabulary\\n        vocabbase          : the sqrt of vocabuary size\\n        save_location_path : the path of next word location, the reallocated table will be saved\\n                               into this path\\n        word_path          : the path of word table\\n    '\n    start = time.time()\n    global g_vocab_size\n    global g_vocab_sqrt\n    g_vocab_size = vocab_size\n    g_vocab_sqrt = vocab_base\n    prob_table = []\n    table = []\n    freq = vocab_size / 20\n    search_Queue = Q.PriorityQueue()\n    for i in range(vocab_size):\n        (current_row, current_col) = ([], [])\n        for j in range(vocab_base):\n            current_row.append((row[i][j], j))\n            current_col.append((col[i][j], j))\n        current_row.sort()\n        current_col.sort()\n        prob_table.append(InsertNode(current_row, current_col, i))\n        if i % freq == 0:\n            print('\\t\\t\\tFinish {:8d} / {:8d} Line'.format(i, vocab_size))\n    for i in range(vocab_base):\n        table.append([])\n    print('Ready ...')\n    print('Start to assign row for every word')\n    for i in range(vocab_size):\n        search_Queue.put(prob_table[i].next_row())\n    while not search_Queue.empty():\n        top_node = search_Queue.get()\n        word_id = top_node.word_id\n        row_id = top_node.sort_id\n        if len(table[row_id]) == g_vocab_sqrt:\n            search_Queue.put(prob_table[word_id].next_row())\n        else:\n            table[row_id].append(word_id)\n    print('Finish assign row')\n    print('Start to assign col for every word')\n    print('Finish assign col')\n    for i in range(g_vocab_sqrt):\n        for _ in range(len(table[i])):\n            col_node = prob_table[table[i][_]].next_col()\n            search_Queue.put(col_node)\n            table[i][_] = -1\n        for _ in range(len(table[i]), g_vocab_sqrt):\n            table[i].append(-1)\n        while not search_Queue.empty():\n            top_node = search_Queue.get()\n            word_id = top_node.word_id\n            col_id = top_node.sort_id\n            if table[i][col_id] == -1:\n                table[i][col_id] = word_id\n            else:\n                search_Queue.put(prob_table[word_id].next_col())\n    vocab = get_word_location(word_path)\n    save_allocate_word_location(table, vocab, save_location_path)\n    end = time.time()\n    print('Reallocate word location cost {} seconds'.format(end - start))",
            "def reallocate_table(row, col, vocab_size, vocab_base, save_location_path, word_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n     The allocate algorithm implement by python\\n     Params:\\n        content_row        : the loss vector of row\\n        content_col        : the loss vector of col\\n        vocabsize          : the size of vocabulary\\n        vocabbase          : the sqrt of vocabuary size\\n        save_location_path : the path of next word location, the reallocated table will be saved\\n                               into this path\\n        word_path          : the path of word table\\n    '\n    start = time.time()\n    global g_vocab_size\n    global g_vocab_sqrt\n    g_vocab_size = vocab_size\n    g_vocab_sqrt = vocab_base\n    prob_table = []\n    table = []\n    freq = vocab_size / 20\n    search_Queue = Q.PriorityQueue()\n    for i in range(vocab_size):\n        (current_row, current_col) = ([], [])\n        for j in range(vocab_base):\n            current_row.append((row[i][j], j))\n            current_col.append((col[i][j], j))\n        current_row.sort()\n        current_col.sort()\n        prob_table.append(InsertNode(current_row, current_col, i))\n        if i % freq == 0:\n            print('\\t\\t\\tFinish {:8d} / {:8d} Line'.format(i, vocab_size))\n    for i in range(vocab_base):\n        table.append([])\n    print('Ready ...')\n    print('Start to assign row for every word')\n    for i in range(vocab_size):\n        search_Queue.put(prob_table[i].next_row())\n    while not search_Queue.empty():\n        top_node = search_Queue.get()\n        word_id = top_node.word_id\n        row_id = top_node.sort_id\n        if len(table[row_id]) == g_vocab_sqrt:\n            search_Queue.put(prob_table[word_id].next_row())\n        else:\n            table[row_id].append(word_id)\n    print('Finish assign row')\n    print('Start to assign col for every word')\n    print('Finish assign col')\n    for i in range(g_vocab_sqrt):\n        for _ in range(len(table[i])):\n            col_node = prob_table[table[i][_]].next_col()\n            search_Queue.put(col_node)\n            table[i][_] = -1\n        for _ in range(len(table[i]), g_vocab_sqrt):\n            table[i].append(-1)\n        while not search_Queue.empty():\n            top_node = search_Queue.get()\n            word_id = top_node.word_id\n            col_id = top_node.sort_id\n            if table[i][col_id] == -1:\n                table[i][col_id] = word_id\n            else:\n                search_Queue.put(prob_table[word_id].next_col())\n    vocab = get_word_location(word_path)\n    save_allocate_word_location(table, vocab, save_location_path)\n    end = time.time()\n    print('Reallocate word location cost {} seconds'.format(end - start))",
            "def reallocate_table(row, col, vocab_size, vocab_base, save_location_path, word_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n     The allocate algorithm implement by python\\n     Params:\\n        content_row        : the loss vector of row\\n        content_col        : the loss vector of col\\n        vocabsize          : the size of vocabulary\\n        vocabbase          : the sqrt of vocabuary size\\n        save_location_path : the path of next word location, the reallocated table will be saved\\n                               into this path\\n        word_path          : the path of word table\\n    '\n    start = time.time()\n    global g_vocab_size\n    global g_vocab_sqrt\n    g_vocab_size = vocab_size\n    g_vocab_sqrt = vocab_base\n    prob_table = []\n    table = []\n    freq = vocab_size / 20\n    search_Queue = Q.PriorityQueue()\n    for i in range(vocab_size):\n        (current_row, current_col) = ([], [])\n        for j in range(vocab_base):\n            current_row.append((row[i][j], j))\n            current_col.append((col[i][j], j))\n        current_row.sort()\n        current_col.sort()\n        prob_table.append(InsertNode(current_row, current_col, i))\n        if i % freq == 0:\n            print('\\t\\t\\tFinish {:8d} / {:8d} Line'.format(i, vocab_size))\n    for i in range(vocab_base):\n        table.append([])\n    print('Ready ...')\n    print('Start to assign row for every word')\n    for i in range(vocab_size):\n        search_Queue.put(prob_table[i].next_row())\n    while not search_Queue.empty():\n        top_node = search_Queue.get()\n        word_id = top_node.word_id\n        row_id = top_node.sort_id\n        if len(table[row_id]) == g_vocab_sqrt:\n            search_Queue.put(prob_table[word_id].next_row())\n        else:\n            table[row_id].append(word_id)\n    print('Finish assign row')\n    print('Start to assign col for every word')\n    print('Finish assign col')\n    for i in range(g_vocab_sqrt):\n        for _ in range(len(table[i])):\n            col_node = prob_table[table[i][_]].next_col()\n            search_Queue.put(col_node)\n            table[i][_] = -1\n        for _ in range(len(table[i]), g_vocab_sqrt):\n            table[i].append(-1)\n        while not search_Queue.empty():\n            top_node = search_Queue.get()\n            word_id = top_node.word_id\n            col_id = top_node.sort_id\n            if table[i][col_id] == -1:\n                table[i][col_id] = word_id\n            else:\n                search_Queue.put(prob_table[word_id].next_col())\n    vocab = get_word_location(word_path)\n    save_allocate_word_location(table, vocab, save_location_path)\n    end = time.time()\n    print('Reallocate word location cost {} seconds'.format(end - start))",
            "def reallocate_table(row, col, vocab_size, vocab_base, save_location_path, word_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n     The allocate algorithm implement by python\\n     Params:\\n        content_row        : the loss vector of row\\n        content_col        : the loss vector of col\\n        vocabsize          : the size of vocabulary\\n        vocabbase          : the sqrt of vocabuary size\\n        save_location_path : the path of next word location, the reallocated table will be saved\\n                               into this path\\n        word_path          : the path of word table\\n    '\n    start = time.time()\n    global g_vocab_size\n    global g_vocab_sqrt\n    g_vocab_size = vocab_size\n    g_vocab_sqrt = vocab_base\n    prob_table = []\n    table = []\n    freq = vocab_size / 20\n    search_Queue = Q.PriorityQueue()\n    for i in range(vocab_size):\n        (current_row, current_col) = ([], [])\n        for j in range(vocab_base):\n            current_row.append((row[i][j], j))\n            current_col.append((col[i][j], j))\n        current_row.sort()\n        current_col.sort()\n        prob_table.append(InsertNode(current_row, current_col, i))\n        if i % freq == 0:\n            print('\\t\\t\\tFinish {:8d} / {:8d} Line'.format(i, vocab_size))\n    for i in range(vocab_base):\n        table.append([])\n    print('Ready ...')\n    print('Start to assign row for every word')\n    for i in range(vocab_size):\n        search_Queue.put(prob_table[i].next_row())\n    while not search_Queue.empty():\n        top_node = search_Queue.get()\n        word_id = top_node.word_id\n        row_id = top_node.sort_id\n        if len(table[row_id]) == g_vocab_sqrt:\n            search_Queue.put(prob_table[word_id].next_row())\n        else:\n            table[row_id].append(word_id)\n    print('Finish assign row')\n    print('Start to assign col for every word')\n    print('Finish assign col')\n    for i in range(g_vocab_sqrt):\n        for _ in range(len(table[i])):\n            col_node = prob_table[table[i][_]].next_col()\n            search_Queue.put(col_node)\n            table[i][_] = -1\n        for _ in range(len(table[i]), g_vocab_sqrt):\n            table[i].append(-1)\n        while not search_Queue.empty():\n            top_node = search_Queue.get()\n            word_id = top_node.word_id\n            col_id = top_node.sort_id\n            if table[i][col_id] == -1:\n                table[i][col_id] = word_id\n            else:\n                search_Queue.put(prob_table[word_id].next_col())\n    vocab = get_word_location(word_path)\n    save_allocate_word_location(table, vocab, save_location_path)\n    end = time.time()\n    print('Reallocate word location cost {} seconds'.format(end - start))"
        ]
    }
]