[
    {
        "func_name": "_apply_cu",
        "original": "def _apply_cu(circuit, theta, phi, lam, control, target, use_basis_gates=True):\n    if use_basis_gates:\n        circuit.p((lam + phi) / 2, [control])\n        circuit.p((lam - phi) / 2, [target])\n        circuit.cx(control, target)\n        circuit.u(-theta / 2, 0, -(phi + lam) / 2, [target])\n        circuit.cx(control, target)\n        circuit.u(theta / 2, phi, 0, [target])\n    else:\n        circuit.cu(theta, phi, lam, 0, control, target)",
        "mutated": [
            "def _apply_cu(circuit, theta, phi, lam, control, target, use_basis_gates=True):\n    if False:\n        i = 10\n    if use_basis_gates:\n        circuit.p((lam + phi) / 2, [control])\n        circuit.p((lam - phi) / 2, [target])\n        circuit.cx(control, target)\n        circuit.u(-theta / 2, 0, -(phi + lam) / 2, [target])\n        circuit.cx(control, target)\n        circuit.u(theta / 2, phi, 0, [target])\n    else:\n        circuit.cu(theta, phi, lam, 0, control, target)",
            "def _apply_cu(circuit, theta, phi, lam, control, target, use_basis_gates=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if use_basis_gates:\n        circuit.p((lam + phi) / 2, [control])\n        circuit.p((lam - phi) / 2, [target])\n        circuit.cx(control, target)\n        circuit.u(-theta / 2, 0, -(phi + lam) / 2, [target])\n        circuit.cx(control, target)\n        circuit.u(theta / 2, phi, 0, [target])\n    else:\n        circuit.cu(theta, phi, lam, 0, control, target)",
            "def _apply_cu(circuit, theta, phi, lam, control, target, use_basis_gates=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if use_basis_gates:\n        circuit.p((lam + phi) / 2, [control])\n        circuit.p((lam - phi) / 2, [target])\n        circuit.cx(control, target)\n        circuit.u(-theta / 2, 0, -(phi + lam) / 2, [target])\n        circuit.cx(control, target)\n        circuit.u(theta / 2, phi, 0, [target])\n    else:\n        circuit.cu(theta, phi, lam, 0, control, target)",
            "def _apply_cu(circuit, theta, phi, lam, control, target, use_basis_gates=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if use_basis_gates:\n        circuit.p((lam + phi) / 2, [control])\n        circuit.p((lam - phi) / 2, [target])\n        circuit.cx(control, target)\n        circuit.u(-theta / 2, 0, -(phi + lam) / 2, [target])\n        circuit.cx(control, target)\n        circuit.u(theta / 2, phi, 0, [target])\n    else:\n        circuit.cu(theta, phi, lam, 0, control, target)",
            "def _apply_cu(circuit, theta, phi, lam, control, target, use_basis_gates=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if use_basis_gates:\n        circuit.p((lam + phi) / 2, [control])\n        circuit.p((lam - phi) / 2, [target])\n        circuit.cx(control, target)\n        circuit.u(-theta / 2, 0, -(phi + lam) / 2, [target])\n        circuit.cx(control, target)\n        circuit.u(theta / 2, phi, 0, [target])\n    else:\n        circuit.cu(theta, phi, lam, 0, control, target)"
        ]
    },
    {
        "func_name": "_apply_mcu_graycode",
        "original": "def _apply_mcu_graycode(circuit, theta, phi, lam, ctls, tgt, use_basis_gates):\n    \"\"\"Apply multi-controlled u gate from ctls to tgt using graycode\n    pattern with single-step angles theta, phi, lam.\"\"\"\n    n = len(ctls)\n    gray_code = _generate_gray_code(n)\n    last_pattern = None\n    for pattern in gray_code:\n        if '1' not in pattern:\n            continue\n        if last_pattern is None:\n            last_pattern = pattern\n        lm_pos = list(pattern).index('1')\n        comp = [i != j for (i, j) in zip(pattern, last_pattern)]\n        if True in comp:\n            pos = comp.index(True)\n        else:\n            pos = None\n        if pos is not None:\n            if pos != lm_pos:\n                circuit.cx(ctls[pos], ctls[lm_pos])\n            else:\n                indices = [i for (i, x) in enumerate(pattern) if x == '1']\n                for idx in indices[1:]:\n                    circuit.cx(ctls[idx], ctls[lm_pos])\n        if pattern.count('1') % 2 == 0:\n            _apply_cu(circuit, -theta, -lam, -phi, ctls[lm_pos], tgt, use_basis_gates=use_basis_gates)\n        else:\n            _apply_cu(circuit, theta, phi, lam, ctls[lm_pos], tgt, use_basis_gates=use_basis_gates)\n        last_pattern = pattern",
        "mutated": [
            "def _apply_mcu_graycode(circuit, theta, phi, lam, ctls, tgt, use_basis_gates):\n    if False:\n        i = 10\n    'Apply multi-controlled u gate from ctls to tgt using graycode\\n    pattern with single-step angles theta, phi, lam.'\n    n = len(ctls)\n    gray_code = _generate_gray_code(n)\n    last_pattern = None\n    for pattern in gray_code:\n        if '1' not in pattern:\n            continue\n        if last_pattern is None:\n            last_pattern = pattern\n        lm_pos = list(pattern).index('1')\n        comp = [i != j for (i, j) in zip(pattern, last_pattern)]\n        if True in comp:\n            pos = comp.index(True)\n        else:\n            pos = None\n        if pos is not None:\n            if pos != lm_pos:\n                circuit.cx(ctls[pos], ctls[lm_pos])\n            else:\n                indices = [i for (i, x) in enumerate(pattern) if x == '1']\n                for idx in indices[1:]:\n                    circuit.cx(ctls[idx], ctls[lm_pos])\n        if pattern.count('1') % 2 == 0:\n            _apply_cu(circuit, -theta, -lam, -phi, ctls[lm_pos], tgt, use_basis_gates=use_basis_gates)\n        else:\n            _apply_cu(circuit, theta, phi, lam, ctls[lm_pos], tgt, use_basis_gates=use_basis_gates)\n        last_pattern = pattern",
            "def _apply_mcu_graycode(circuit, theta, phi, lam, ctls, tgt, use_basis_gates):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Apply multi-controlled u gate from ctls to tgt using graycode\\n    pattern with single-step angles theta, phi, lam.'\n    n = len(ctls)\n    gray_code = _generate_gray_code(n)\n    last_pattern = None\n    for pattern in gray_code:\n        if '1' not in pattern:\n            continue\n        if last_pattern is None:\n            last_pattern = pattern\n        lm_pos = list(pattern).index('1')\n        comp = [i != j for (i, j) in zip(pattern, last_pattern)]\n        if True in comp:\n            pos = comp.index(True)\n        else:\n            pos = None\n        if pos is not None:\n            if pos != lm_pos:\n                circuit.cx(ctls[pos], ctls[lm_pos])\n            else:\n                indices = [i for (i, x) in enumerate(pattern) if x == '1']\n                for idx in indices[1:]:\n                    circuit.cx(ctls[idx], ctls[lm_pos])\n        if pattern.count('1') % 2 == 0:\n            _apply_cu(circuit, -theta, -lam, -phi, ctls[lm_pos], tgt, use_basis_gates=use_basis_gates)\n        else:\n            _apply_cu(circuit, theta, phi, lam, ctls[lm_pos], tgt, use_basis_gates=use_basis_gates)\n        last_pattern = pattern",
            "def _apply_mcu_graycode(circuit, theta, phi, lam, ctls, tgt, use_basis_gates):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Apply multi-controlled u gate from ctls to tgt using graycode\\n    pattern with single-step angles theta, phi, lam.'\n    n = len(ctls)\n    gray_code = _generate_gray_code(n)\n    last_pattern = None\n    for pattern in gray_code:\n        if '1' not in pattern:\n            continue\n        if last_pattern is None:\n            last_pattern = pattern\n        lm_pos = list(pattern).index('1')\n        comp = [i != j for (i, j) in zip(pattern, last_pattern)]\n        if True in comp:\n            pos = comp.index(True)\n        else:\n            pos = None\n        if pos is not None:\n            if pos != lm_pos:\n                circuit.cx(ctls[pos], ctls[lm_pos])\n            else:\n                indices = [i for (i, x) in enumerate(pattern) if x == '1']\n                for idx in indices[1:]:\n                    circuit.cx(ctls[idx], ctls[lm_pos])\n        if pattern.count('1') % 2 == 0:\n            _apply_cu(circuit, -theta, -lam, -phi, ctls[lm_pos], tgt, use_basis_gates=use_basis_gates)\n        else:\n            _apply_cu(circuit, theta, phi, lam, ctls[lm_pos], tgt, use_basis_gates=use_basis_gates)\n        last_pattern = pattern",
            "def _apply_mcu_graycode(circuit, theta, phi, lam, ctls, tgt, use_basis_gates):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Apply multi-controlled u gate from ctls to tgt using graycode\\n    pattern with single-step angles theta, phi, lam.'\n    n = len(ctls)\n    gray_code = _generate_gray_code(n)\n    last_pattern = None\n    for pattern in gray_code:\n        if '1' not in pattern:\n            continue\n        if last_pattern is None:\n            last_pattern = pattern\n        lm_pos = list(pattern).index('1')\n        comp = [i != j for (i, j) in zip(pattern, last_pattern)]\n        if True in comp:\n            pos = comp.index(True)\n        else:\n            pos = None\n        if pos is not None:\n            if pos != lm_pos:\n                circuit.cx(ctls[pos], ctls[lm_pos])\n            else:\n                indices = [i for (i, x) in enumerate(pattern) if x == '1']\n                for idx in indices[1:]:\n                    circuit.cx(ctls[idx], ctls[lm_pos])\n        if pattern.count('1') % 2 == 0:\n            _apply_cu(circuit, -theta, -lam, -phi, ctls[lm_pos], tgt, use_basis_gates=use_basis_gates)\n        else:\n            _apply_cu(circuit, theta, phi, lam, ctls[lm_pos], tgt, use_basis_gates=use_basis_gates)\n        last_pattern = pattern",
            "def _apply_mcu_graycode(circuit, theta, phi, lam, ctls, tgt, use_basis_gates):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Apply multi-controlled u gate from ctls to tgt using graycode\\n    pattern with single-step angles theta, phi, lam.'\n    n = len(ctls)\n    gray_code = _generate_gray_code(n)\n    last_pattern = None\n    for pattern in gray_code:\n        if '1' not in pattern:\n            continue\n        if last_pattern is None:\n            last_pattern = pattern\n        lm_pos = list(pattern).index('1')\n        comp = [i != j for (i, j) in zip(pattern, last_pattern)]\n        if True in comp:\n            pos = comp.index(True)\n        else:\n            pos = None\n        if pos is not None:\n            if pos != lm_pos:\n                circuit.cx(ctls[pos], ctls[lm_pos])\n            else:\n                indices = [i for (i, x) in enumerate(pattern) if x == '1']\n                for idx in indices[1:]:\n                    circuit.cx(ctls[idx], ctls[lm_pos])\n        if pattern.count('1') % 2 == 0:\n            _apply_cu(circuit, -theta, -lam, -phi, ctls[lm_pos], tgt, use_basis_gates=use_basis_gates)\n        else:\n            _apply_cu(circuit, theta, phi, lam, ctls[lm_pos], tgt, use_basis_gates=use_basis_gates)\n        last_pattern = pattern"
        ]
    },
    {
        "func_name": "_mcsu2_real_diagonal",
        "original": "def _mcsu2_real_diagonal(unitary: np.ndarray, num_controls: int, ctrl_state: Optional[str]=None, use_basis_gates: bool=False) -> QuantumCircuit:\n    \"\"\"\n    Return a multi-controlled SU(2) gate [1]_ with a real main diagonal or secondary diagonal.\n\n    Args:\n        unitary: SU(2) unitary matrix with one real diagonal.\n        num_controls: The number of control qubits.\n        ctrl_state: The state on which the SU(2) operation is controlled. Defaults to all\n            control qubits being in state 1.\n        use_basis_gates: If ``True``, use ``[p, u, cx]`` gates to implement the decomposition.\n\n    Returns:\n        A :class:`.QuantumCircuit` implementing the multi-controlled SU(2) gate.\n\n    Raises:\n        QiskitError: If the input matrix is invalid.\n\n    References:\n\n        .. [1]: R. Vale et al. Decomposition of Multi-controlled Special Unitary Single-Qubit Gates\n            `arXiv:2302.06377 (2023) <https://arxiv.org/abs/2302.06377>`__\n\n    \"\"\"\n    from .x import MCXVChain\n    from qiskit.circuit.library.generalized_gates import UnitaryGate\n    from qiskit.quantum_info.operators.predicates import is_unitary_matrix\n    from qiskit.compiler import transpile\n    if unitary.shape != (2, 2):\n        raise QiskitError(f'The unitary must be a 2x2 matrix, but has shape {unitary.shape}.')\n    if not is_unitary_matrix(unitary):\n        raise QiskitError(f'The unitary in must be an unitary matrix, but is {unitary}.')\n    is_main_diag_real = np.isclose(unitary[0, 0].imag, 0.0) and np.isclose(unitary[1, 1].imag, 0.0)\n    is_secondary_diag_real = np.isclose(unitary[0, 1].imag, 0.0) and np.isclose(unitary[1, 0].imag, 0.0)\n    if not is_main_diag_real and (not is_secondary_diag_real):\n        raise QiskitError('The unitary must have one real diagonal.')\n    if is_secondary_diag_real:\n        x = unitary[0, 1]\n        z = unitary[1, 1]\n    else:\n        x = -unitary[0, 1].real\n        z = unitary[1, 1] - unitary[0, 1].imag * 1j\n    if np.isclose(z, -1):\n        s_op = [[1.0, 0.0], [0.0, 1j]]\n    else:\n        alpha_r = np.sqrt((np.sqrt((z.real + 1.0) / 2.0) + 1.0) / 2.0)\n        alpha_i = z.imag / (2.0 * np.sqrt((z.real + 1.0) * (np.sqrt((z.real + 1.0) / 2.0) + 1.0)))\n        alpha = alpha_r + 1j * alpha_i\n        beta = x / (2.0 * np.sqrt((z.real + 1.0) * (np.sqrt((z.real + 1.0) / 2.0) + 1.0)))\n        s_op = np.array([[alpha, -np.conj(beta)], [beta, np.conj(alpha)]])\n    s_gate = UnitaryGate(s_op)\n    k_1 = int(np.ceil(num_controls / 2.0))\n    k_2 = int(np.floor(num_controls / 2.0))\n    ctrl_state_k_1 = None\n    ctrl_state_k_2 = None\n    if ctrl_state is not None:\n        str_ctrl_state = f'{ctrl_state:0{num_controls}b}'\n        ctrl_state_k_1 = str_ctrl_state[::-1][:k_1][::-1]\n        ctrl_state_k_2 = str_ctrl_state[::-1][k_1:][::-1]\n    circuit = QuantumCircuit(num_controls + 1, name='MCSU2')\n    controls = list(range(num_controls))\n    target = num_controls\n    if not is_secondary_diag_real:\n        circuit.h(target)\n    mcx_1 = MCXVChain(num_ctrl_qubits=k_1, dirty_ancillas=True, ctrl_state=ctrl_state_k_1)\n    circuit.append(mcx_1, controls[:k_1] + [target] + controls[k_1:2 * k_1 - 2])\n    circuit.append(s_gate, [target])\n    mcx_2 = MCXVChain(num_ctrl_qubits=k_2, dirty_ancillas=True, ctrl_state=ctrl_state_k_2)\n    circuit.append(mcx_2.inverse(), controls[k_1:] + [target] + controls[k_1 - k_2 + 2:k_1])\n    circuit.append(s_gate.inverse(), [target])\n    mcx_3 = MCXVChain(num_ctrl_qubits=k_1, dirty_ancillas=True, ctrl_state=ctrl_state_k_1)\n    circuit.append(mcx_3, controls[:k_1] + [target] + controls[k_1:2 * k_1 - 2])\n    circuit.append(s_gate, [target])\n    mcx_4 = MCXVChain(num_ctrl_qubits=k_2, dirty_ancillas=True, ctrl_state=ctrl_state_k_2)\n    circuit.append(mcx_4, controls[k_1:] + [target] + controls[k_1 - k_2 + 2:k_1])\n    circuit.append(s_gate.inverse(), [target])\n    if not is_secondary_diag_real:\n        circuit.h(target)\n    if use_basis_gates:\n        circuit = transpile(circuit, basis_gates=['p', 'u', 'cx'])\n    return circuit",
        "mutated": [
            "def _mcsu2_real_diagonal(unitary: np.ndarray, num_controls: int, ctrl_state: Optional[str]=None, use_basis_gates: bool=False) -> QuantumCircuit:\n    if False:\n        i = 10\n    '\\n    Return a multi-controlled SU(2) gate [1]_ with a real main diagonal or secondary diagonal.\\n\\n    Args:\\n        unitary: SU(2) unitary matrix with one real diagonal.\\n        num_controls: The number of control qubits.\\n        ctrl_state: The state on which the SU(2) operation is controlled. Defaults to all\\n            control qubits being in state 1.\\n        use_basis_gates: If ``True``, use ``[p, u, cx]`` gates to implement the decomposition.\\n\\n    Returns:\\n        A :class:`.QuantumCircuit` implementing the multi-controlled SU(2) gate.\\n\\n    Raises:\\n        QiskitError: If the input matrix is invalid.\\n\\n    References:\\n\\n        .. [1]: R. Vale et al. Decomposition of Multi-controlled Special Unitary Single-Qubit Gates\\n            `arXiv:2302.06377 (2023) <https://arxiv.org/abs/2302.06377>`__\\n\\n    '\n    from .x import MCXVChain\n    from qiskit.circuit.library.generalized_gates import UnitaryGate\n    from qiskit.quantum_info.operators.predicates import is_unitary_matrix\n    from qiskit.compiler import transpile\n    if unitary.shape != (2, 2):\n        raise QiskitError(f'The unitary must be a 2x2 matrix, but has shape {unitary.shape}.')\n    if not is_unitary_matrix(unitary):\n        raise QiskitError(f'The unitary in must be an unitary matrix, but is {unitary}.')\n    is_main_diag_real = np.isclose(unitary[0, 0].imag, 0.0) and np.isclose(unitary[1, 1].imag, 0.0)\n    is_secondary_diag_real = np.isclose(unitary[0, 1].imag, 0.0) and np.isclose(unitary[1, 0].imag, 0.0)\n    if not is_main_diag_real and (not is_secondary_diag_real):\n        raise QiskitError('The unitary must have one real diagonal.')\n    if is_secondary_diag_real:\n        x = unitary[0, 1]\n        z = unitary[1, 1]\n    else:\n        x = -unitary[0, 1].real\n        z = unitary[1, 1] - unitary[0, 1].imag * 1j\n    if np.isclose(z, -1):\n        s_op = [[1.0, 0.0], [0.0, 1j]]\n    else:\n        alpha_r = np.sqrt((np.sqrt((z.real + 1.0) / 2.0) + 1.0) / 2.0)\n        alpha_i = z.imag / (2.0 * np.sqrt((z.real + 1.0) * (np.sqrt((z.real + 1.0) / 2.0) + 1.0)))\n        alpha = alpha_r + 1j * alpha_i\n        beta = x / (2.0 * np.sqrt((z.real + 1.0) * (np.sqrt((z.real + 1.0) / 2.0) + 1.0)))\n        s_op = np.array([[alpha, -np.conj(beta)], [beta, np.conj(alpha)]])\n    s_gate = UnitaryGate(s_op)\n    k_1 = int(np.ceil(num_controls / 2.0))\n    k_2 = int(np.floor(num_controls / 2.0))\n    ctrl_state_k_1 = None\n    ctrl_state_k_2 = None\n    if ctrl_state is not None:\n        str_ctrl_state = f'{ctrl_state:0{num_controls}b}'\n        ctrl_state_k_1 = str_ctrl_state[::-1][:k_1][::-1]\n        ctrl_state_k_2 = str_ctrl_state[::-1][k_1:][::-1]\n    circuit = QuantumCircuit(num_controls + 1, name='MCSU2')\n    controls = list(range(num_controls))\n    target = num_controls\n    if not is_secondary_diag_real:\n        circuit.h(target)\n    mcx_1 = MCXVChain(num_ctrl_qubits=k_1, dirty_ancillas=True, ctrl_state=ctrl_state_k_1)\n    circuit.append(mcx_1, controls[:k_1] + [target] + controls[k_1:2 * k_1 - 2])\n    circuit.append(s_gate, [target])\n    mcx_2 = MCXVChain(num_ctrl_qubits=k_2, dirty_ancillas=True, ctrl_state=ctrl_state_k_2)\n    circuit.append(mcx_2.inverse(), controls[k_1:] + [target] + controls[k_1 - k_2 + 2:k_1])\n    circuit.append(s_gate.inverse(), [target])\n    mcx_3 = MCXVChain(num_ctrl_qubits=k_1, dirty_ancillas=True, ctrl_state=ctrl_state_k_1)\n    circuit.append(mcx_3, controls[:k_1] + [target] + controls[k_1:2 * k_1 - 2])\n    circuit.append(s_gate, [target])\n    mcx_4 = MCXVChain(num_ctrl_qubits=k_2, dirty_ancillas=True, ctrl_state=ctrl_state_k_2)\n    circuit.append(mcx_4, controls[k_1:] + [target] + controls[k_1 - k_2 + 2:k_1])\n    circuit.append(s_gate.inverse(), [target])\n    if not is_secondary_diag_real:\n        circuit.h(target)\n    if use_basis_gates:\n        circuit = transpile(circuit, basis_gates=['p', 'u', 'cx'])\n    return circuit",
            "def _mcsu2_real_diagonal(unitary: np.ndarray, num_controls: int, ctrl_state: Optional[str]=None, use_basis_gates: bool=False) -> QuantumCircuit:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a multi-controlled SU(2) gate [1]_ with a real main diagonal or secondary diagonal.\\n\\n    Args:\\n        unitary: SU(2) unitary matrix with one real diagonal.\\n        num_controls: The number of control qubits.\\n        ctrl_state: The state on which the SU(2) operation is controlled. Defaults to all\\n            control qubits being in state 1.\\n        use_basis_gates: If ``True``, use ``[p, u, cx]`` gates to implement the decomposition.\\n\\n    Returns:\\n        A :class:`.QuantumCircuit` implementing the multi-controlled SU(2) gate.\\n\\n    Raises:\\n        QiskitError: If the input matrix is invalid.\\n\\n    References:\\n\\n        .. [1]: R. Vale et al. Decomposition of Multi-controlled Special Unitary Single-Qubit Gates\\n            `arXiv:2302.06377 (2023) <https://arxiv.org/abs/2302.06377>`__\\n\\n    '\n    from .x import MCXVChain\n    from qiskit.circuit.library.generalized_gates import UnitaryGate\n    from qiskit.quantum_info.operators.predicates import is_unitary_matrix\n    from qiskit.compiler import transpile\n    if unitary.shape != (2, 2):\n        raise QiskitError(f'The unitary must be a 2x2 matrix, but has shape {unitary.shape}.')\n    if not is_unitary_matrix(unitary):\n        raise QiskitError(f'The unitary in must be an unitary matrix, but is {unitary}.')\n    is_main_diag_real = np.isclose(unitary[0, 0].imag, 0.0) and np.isclose(unitary[1, 1].imag, 0.0)\n    is_secondary_diag_real = np.isclose(unitary[0, 1].imag, 0.0) and np.isclose(unitary[1, 0].imag, 0.0)\n    if not is_main_diag_real and (not is_secondary_diag_real):\n        raise QiskitError('The unitary must have one real diagonal.')\n    if is_secondary_diag_real:\n        x = unitary[0, 1]\n        z = unitary[1, 1]\n    else:\n        x = -unitary[0, 1].real\n        z = unitary[1, 1] - unitary[0, 1].imag * 1j\n    if np.isclose(z, -1):\n        s_op = [[1.0, 0.0], [0.0, 1j]]\n    else:\n        alpha_r = np.sqrt((np.sqrt((z.real + 1.0) / 2.0) + 1.0) / 2.0)\n        alpha_i = z.imag / (2.0 * np.sqrt((z.real + 1.0) * (np.sqrt((z.real + 1.0) / 2.0) + 1.0)))\n        alpha = alpha_r + 1j * alpha_i\n        beta = x / (2.0 * np.sqrt((z.real + 1.0) * (np.sqrt((z.real + 1.0) / 2.0) + 1.0)))\n        s_op = np.array([[alpha, -np.conj(beta)], [beta, np.conj(alpha)]])\n    s_gate = UnitaryGate(s_op)\n    k_1 = int(np.ceil(num_controls / 2.0))\n    k_2 = int(np.floor(num_controls / 2.0))\n    ctrl_state_k_1 = None\n    ctrl_state_k_2 = None\n    if ctrl_state is not None:\n        str_ctrl_state = f'{ctrl_state:0{num_controls}b}'\n        ctrl_state_k_1 = str_ctrl_state[::-1][:k_1][::-1]\n        ctrl_state_k_2 = str_ctrl_state[::-1][k_1:][::-1]\n    circuit = QuantumCircuit(num_controls + 1, name='MCSU2')\n    controls = list(range(num_controls))\n    target = num_controls\n    if not is_secondary_diag_real:\n        circuit.h(target)\n    mcx_1 = MCXVChain(num_ctrl_qubits=k_1, dirty_ancillas=True, ctrl_state=ctrl_state_k_1)\n    circuit.append(mcx_1, controls[:k_1] + [target] + controls[k_1:2 * k_1 - 2])\n    circuit.append(s_gate, [target])\n    mcx_2 = MCXVChain(num_ctrl_qubits=k_2, dirty_ancillas=True, ctrl_state=ctrl_state_k_2)\n    circuit.append(mcx_2.inverse(), controls[k_1:] + [target] + controls[k_1 - k_2 + 2:k_1])\n    circuit.append(s_gate.inverse(), [target])\n    mcx_3 = MCXVChain(num_ctrl_qubits=k_1, dirty_ancillas=True, ctrl_state=ctrl_state_k_1)\n    circuit.append(mcx_3, controls[:k_1] + [target] + controls[k_1:2 * k_1 - 2])\n    circuit.append(s_gate, [target])\n    mcx_4 = MCXVChain(num_ctrl_qubits=k_2, dirty_ancillas=True, ctrl_state=ctrl_state_k_2)\n    circuit.append(mcx_4, controls[k_1:] + [target] + controls[k_1 - k_2 + 2:k_1])\n    circuit.append(s_gate.inverse(), [target])\n    if not is_secondary_diag_real:\n        circuit.h(target)\n    if use_basis_gates:\n        circuit = transpile(circuit, basis_gates=['p', 'u', 'cx'])\n    return circuit",
            "def _mcsu2_real_diagonal(unitary: np.ndarray, num_controls: int, ctrl_state: Optional[str]=None, use_basis_gates: bool=False) -> QuantumCircuit:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a multi-controlled SU(2) gate [1]_ with a real main diagonal or secondary diagonal.\\n\\n    Args:\\n        unitary: SU(2) unitary matrix with one real diagonal.\\n        num_controls: The number of control qubits.\\n        ctrl_state: The state on which the SU(2) operation is controlled. Defaults to all\\n            control qubits being in state 1.\\n        use_basis_gates: If ``True``, use ``[p, u, cx]`` gates to implement the decomposition.\\n\\n    Returns:\\n        A :class:`.QuantumCircuit` implementing the multi-controlled SU(2) gate.\\n\\n    Raises:\\n        QiskitError: If the input matrix is invalid.\\n\\n    References:\\n\\n        .. [1]: R. Vale et al. Decomposition of Multi-controlled Special Unitary Single-Qubit Gates\\n            `arXiv:2302.06377 (2023) <https://arxiv.org/abs/2302.06377>`__\\n\\n    '\n    from .x import MCXVChain\n    from qiskit.circuit.library.generalized_gates import UnitaryGate\n    from qiskit.quantum_info.operators.predicates import is_unitary_matrix\n    from qiskit.compiler import transpile\n    if unitary.shape != (2, 2):\n        raise QiskitError(f'The unitary must be a 2x2 matrix, but has shape {unitary.shape}.')\n    if not is_unitary_matrix(unitary):\n        raise QiskitError(f'The unitary in must be an unitary matrix, but is {unitary}.')\n    is_main_diag_real = np.isclose(unitary[0, 0].imag, 0.0) and np.isclose(unitary[1, 1].imag, 0.0)\n    is_secondary_diag_real = np.isclose(unitary[0, 1].imag, 0.0) and np.isclose(unitary[1, 0].imag, 0.0)\n    if not is_main_diag_real and (not is_secondary_diag_real):\n        raise QiskitError('The unitary must have one real diagonal.')\n    if is_secondary_diag_real:\n        x = unitary[0, 1]\n        z = unitary[1, 1]\n    else:\n        x = -unitary[0, 1].real\n        z = unitary[1, 1] - unitary[0, 1].imag * 1j\n    if np.isclose(z, -1):\n        s_op = [[1.0, 0.0], [0.0, 1j]]\n    else:\n        alpha_r = np.sqrt((np.sqrt((z.real + 1.0) / 2.0) + 1.0) / 2.0)\n        alpha_i = z.imag / (2.0 * np.sqrt((z.real + 1.0) * (np.sqrt((z.real + 1.0) / 2.0) + 1.0)))\n        alpha = alpha_r + 1j * alpha_i\n        beta = x / (2.0 * np.sqrt((z.real + 1.0) * (np.sqrt((z.real + 1.0) / 2.0) + 1.0)))\n        s_op = np.array([[alpha, -np.conj(beta)], [beta, np.conj(alpha)]])\n    s_gate = UnitaryGate(s_op)\n    k_1 = int(np.ceil(num_controls / 2.0))\n    k_2 = int(np.floor(num_controls / 2.0))\n    ctrl_state_k_1 = None\n    ctrl_state_k_2 = None\n    if ctrl_state is not None:\n        str_ctrl_state = f'{ctrl_state:0{num_controls}b}'\n        ctrl_state_k_1 = str_ctrl_state[::-1][:k_1][::-1]\n        ctrl_state_k_2 = str_ctrl_state[::-1][k_1:][::-1]\n    circuit = QuantumCircuit(num_controls + 1, name='MCSU2')\n    controls = list(range(num_controls))\n    target = num_controls\n    if not is_secondary_diag_real:\n        circuit.h(target)\n    mcx_1 = MCXVChain(num_ctrl_qubits=k_1, dirty_ancillas=True, ctrl_state=ctrl_state_k_1)\n    circuit.append(mcx_1, controls[:k_1] + [target] + controls[k_1:2 * k_1 - 2])\n    circuit.append(s_gate, [target])\n    mcx_2 = MCXVChain(num_ctrl_qubits=k_2, dirty_ancillas=True, ctrl_state=ctrl_state_k_2)\n    circuit.append(mcx_2.inverse(), controls[k_1:] + [target] + controls[k_1 - k_2 + 2:k_1])\n    circuit.append(s_gate.inverse(), [target])\n    mcx_3 = MCXVChain(num_ctrl_qubits=k_1, dirty_ancillas=True, ctrl_state=ctrl_state_k_1)\n    circuit.append(mcx_3, controls[:k_1] + [target] + controls[k_1:2 * k_1 - 2])\n    circuit.append(s_gate, [target])\n    mcx_4 = MCXVChain(num_ctrl_qubits=k_2, dirty_ancillas=True, ctrl_state=ctrl_state_k_2)\n    circuit.append(mcx_4, controls[k_1:] + [target] + controls[k_1 - k_2 + 2:k_1])\n    circuit.append(s_gate.inverse(), [target])\n    if not is_secondary_diag_real:\n        circuit.h(target)\n    if use_basis_gates:\n        circuit = transpile(circuit, basis_gates=['p', 'u', 'cx'])\n    return circuit",
            "def _mcsu2_real_diagonal(unitary: np.ndarray, num_controls: int, ctrl_state: Optional[str]=None, use_basis_gates: bool=False) -> QuantumCircuit:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a multi-controlled SU(2) gate [1]_ with a real main diagonal or secondary diagonal.\\n\\n    Args:\\n        unitary: SU(2) unitary matrix with one real diagonal.\\n        num_controls: The number of control qubits.\\n        ctrl_state: The state on which the SU(2) operation is controlled. Defaults to all\\n            control qubits being in state 1.\\n        use_basis_gates: If ``True``, use ``[p, u, cx]`` gates to implement the decomposition.\\n\\n    Returns:\\n        A :class:`.QuantumCircuit` implementing the multi-controlled SU(2) gate.\\n\\n    Raises:\\n        QiskitError: If the input matrix is invalid.\\n\\n    References:\\n\\n        .. [1]: R. Vale et al. Decomposition of Multi-controlled Special Unitary Single-Qubit Gates\\n            `arXiv:2302.06377 (2023) <https://arxiv.org/abs/2302.06377>`__\\n\\n    '\n    from .x import MCXVChain\n    from qiskit.circuit.library.generalized_gates import UnitaryGate\n    from qiskit.quantum_info.operators.predicates import is_unitary_matrix\n    from qiskit.compiler import transpile\n    if unitary.shape != (2, 2):\n        raise QiskitError(f'The unitary must be a 2x2 matrix, but has shape {unitary.shape}.')\n    if not is_unitary_matrix(unitary):\n        raise QiskitError(f'The unitary in must be an unitary matrix, but is {unitary}.')\n    is_main_diag_real = np.isclose(unitary[0, 0].imag, 0.0) and np.isclose(unitary[1, 1].imag, 0.0)\n    is_secondary_diag_real = np.isclose(unitary[0, 1].imag, 0.0) and np.isclose(unitary[1, 0].imag, 0.0)\n    if not is_main_diag_real and (not is_secondary_diag_real):\n        raise QiskitError('The unitary must have one real diagonal.')\n    if is_secondary_diag_real:\n        x = unitary[0, 1]\n        z = unitary[1, 1]\n    else:\n        x = -unitary[0, 1].real\n        z = unitary[1, 1] - unitary[0, 1].imag * 1j\n    if np.isclose(z, -1):\n        s_op = [[1.0, 0.0], [0.0, 1j]]\n    else:\n        alpha_r = np.sqrt((np.sqrt((z.real + 1.0) / 2.0) + 1.0) / 2.0)\n        alpha_i = z.imag / (2.0 * np.sqrt((z.real + 1.0) * (np.sqrt((z.real + 1.0) / 2.0) + 1.0)))\n        alpha = alpha_r + 1j * alpha_i\n        beta = x / (2.0 * np.sqrt((z.real + 1.0) * (np.sqrt((z.real + 1.0) / 2.0) + 1.0)))\n        s_op = np.array([[alpha, -np.conj(beta)], [beta, np.conj(alpha)]])\n    s_gate = UnitaryGate(s_op)\n    k_1 = int(np.ceil(num_controls / 2.0))\n    k_2 = int(np.floor(num_controls / 2.0))\n    ctrl_state_k_1 = None\n    ctrl_state_k_2 = None\n    if ctrl_state is not None:\n        str_ctrl_state = f'{ctrl_state:0{num_controls}b}'\n        ctrl_state_k_1 = str_ctrl_state[::-1][:k_1][::-1]\n        ctrl_state_k_2 = str_ctrl_state[::-1][k_1:][::-1]\n    circuit = QuantumCircuit(num_controls + 1, name='MCSU2')\n    controls = list(range(num_controls))\n    target = num_controls\n    if not is_secondary_diag_real:\n        circuit.h(target)\n    mcx_1 = MCXVChain(num_ctrl_qubits=k_1, dirty_ancillas=True, ctrl_state=ctrl_state_k_1)\n    circuit.append(mcx_1, controls[:k_1] + [target] + controls[k_1:2 * k_1 - 2])\n    circuit.append(s_gate, [target])\n    mcx_2 = MCXVChain(num_ctrl_qubits=k_2, dirty_ancillas=True, ctrl_state=ctrl_state_k_2)\n    circuit.append(mcx_2.inverse(), controls[k_1:] + [target] + controls[k_1 - k_2 + 2:k_1])\n    circuit.append(s_gate.inverse(), [target])\n    mcx_3 = MCXVChain(num_ctrl_qubits=k_1, dirty_ancillas=True, ctrl_state=ctrl_state_k_1)\n    circuit.append(mcx_3, controls[:k_1] + [target] + controls[k_1:2 * k_1 - 2])\n    circuit.append(s_gate, [target])\n    mcx_4 = MCXVChain(num_ctrl_qubits=k_2, dirty_ancillas=True, ctrl_state=ctrl_state_k_2)\n    circuit.append(mcx_4, controls[k_1:] + [target] + controls[k_1 - k_2 + 2:k_1])\n    circuit.append(s_gate.inverse(), [target])\n    if not is_secondary_diag_real:\n        circuit.h(target)\n    if use_basis_gates:\n        circuit = transpile(circuit, basis_gates=['p', 'u', 'cx'])\n    return circuit",
            "def _mcsu2_real_diagonal(unitary: np.ndarray, num_controls: int, ctrl_state: Optional[str]=None, use_basis_gates: bool=False) -> QuantumCircuit:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a multi-controlled SU(2) gate [1]_ with a real main diagonal or secondary diagonal.\\n\\n    Args:\\n        unitary: SU(2) unitary matrix with one real diagonal.\\n        num_controls: The number of control qubits.\\n        ctrl_state: The state on which the SU(2) operation is controlled. Defaults to all\\n            control qubits being in state 1.\\n        use_basis_gates: If ``True``, use ``[p, u, cx]`` gates to implement the decomposition.\\n\\n    Returns:\\n        A :class:`.QuantumCircuit` implementing the multi-controlled SU(2) gate.\\n\\n    Raises:\\n        QiskitError: If the input matrix is invalid.\\n\\n    References:\\n\\n        .. [1]: R. Vale et al. Decomposition of Multi-controlled Special Unitary Single-Qubit Gates\\n            `arXiv:2302.06377 (2023) <https://arxiv.org/abs/2302.06377>`__\\n\\n    '\n    from .x import MCXVChain\n    from qiskit.circuit.library.generalized_gates import UnitaryGate\n    from qiskit.quantum_info.operators.predicates import is_unitary_matrix\n    from qiskit.compiler import transpile\n    if unitary.shape != (2, 2):\n        raise QiskitError(f'The unitary must be a 2x2 matrix, but has shape {unitary.shape}.')\n    if not is_unitary_matrix(unitary):\n        raise QiskitError(f'The unitary in must be an unitary matrix, but is {unitary}.')\n    is_main_diag_real = np.isclose(unitary[0, 0].imag, 0.0) and np.isclose(unitary[1, 1].imag, 0.0)\n    is_secondary_diag_real = np.isclose(unitary[0, 1].imag, 0.0) and np.isclose(unitary[1, 0].imag, 0.0)\n    if not is_main_diag_real and (not is_secondary_diag_real):\n        raise QiskitError('The unitary must have one real diagonal.')\n    if is_secondary_diag_real:\n        x = unitary[0, 1]\n        z = unitary[1, 1]\n    else:\n        x = -unitary[0, 1].real\n        z = unitary[1, 1] - unitary[0, 1].imag * 1j\n    if np.isclose(z, -1):\n        s_op = [[1.0, 0.0], [0.0, 1j]]\n    else:\n        alpha_r = np.sqrt((np.sqrt((z.real + 1.0) / 2.0) + 1.0) / 2.0)\n        alpha_i = z.imag / (2.0 * np.sqrt((z.real + 1.0) * (np.sqrt((z.real + 1.0) / 2.0) + 1.0)))\n        alpha = alpha_r + 1j * alpha_i\n        beta = x / (2.0 * np.sqrt((z.real + 1.0) * (np.sqrt((z.real + 1.0) / 2.0) + 1.0)))\n        s_op = np.array([[alpha, -np.conj(beta)], [beta, np.conj(alpha)]])\n    s_gate = UnitaryGate(s_op)\n    k_1 = int(np.ceil(num_controls / 2.0))\n    k_2 = int(np.floor(num_controls / 2.0))\n    ctrl_state_k_1 = None\n    ctrl_state_k_2 = None\n    if ctrl_state is not None:\n        str_ctrl_state = f'{ctrl_state:0{num_controls}b}'\n        ctrl_state_k_1 = str_ctrl_state[::-1][:k_1][::-1]\n        ctrl_state_k_2 = str_ctrl_state[::-1][k_1:][::-1]\n    circuit = QuantumCircuit(num_controls + 1, name='MCSU2')\n    controls = list(range(num_controls))\n    target = num_controls\n    if not is_secondary_diag_real:\n        circuit.h(target)\n    mcx_1 = MCXVChain(num_ctrl_qubits=k_1, dirty_ancillas=True, ctrl_state=ctrl_state_k_1)\n    circuit.append(mcx_1, controls[:k_1] + [target] + controls[k_1:2 * k_1 - 2])\n    circuit.append(s_gate, [target])\n    mcx_2 = MCXVChain(num_ctrl_qubits=k_2, dirty_ancillas=True, ctrl_state=ctrl_state_k_2)\n    circuit.append(mcx_2.inverse(), controls[k_1:] + [target] + controls[k_1 - k_2 + 2:k_1])\n    circuit.append(s_gate.inverse(), [target])\n    mcx_3 = MCXVChain(num_ctrl_qubits=k_1, dirty_ancillas=True, ctrl_state=ctrl_state_k_1)\n    circuit.append(mcx_3, controls[:k_1] + [target] + controls[k_1:2 * k_1 - 2])\n    circuit.append(s_gate, [target])\n    mcx_4 = MCXVChain(num_ctrl_qubits=k_2, dirty_ancillas=True, ctrl_state=ctrl_state_k_2)\n    circuit.append(mcx_4, controls[k_1:] + [target] + controls[k_1 - k_2 + 2:k_1])\n    circuit.append(s_gate.inverse(), [target])\n    if not is_secondary_diag_real:\n        circuit.h(target)\n    if use_basis_gates:\n        circuit = transpile(circuit, basis_gates=['p', 'u', 'cx'])\n    return circuit"
        ]
    },
    {
        "func_name": "mcrx",
        "original": "def mcrx(self, theta: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, use_basis_gates: bool=False):\n    \"\"\"\n    Apply Multiple-Controlled X rotation gate\n\n    Args:\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcrx gate on.\n        theta (float): angle theta\n        q_controls (QuantumRegister or list(Qubit)): The list of control qubits\n        q_target (Qubit): The target qubit\n        use_basis_gates (bool): use p, u, cx\n\n    Raises:\n        QiskitError: parameter errors\n    \"\"\"\n    from .rx import RXGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    all_qubits = control_qubits + target_qubit\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    n_c = len(control_qubits)\n    if n_c == 1:\n        _apply_cu(self, theta, -pi / 2, pi / 2, control_qubits[0], target_qubit, use_basis_gates=use_basis_gates)\n    elif n_c < 4:\n        theta_step = theta * (1 / 2 ** (n_c - 1))\n        _apply_mcu_graycode(self, theta_step, -pi / 2, pi / 2, control_qubits, target_qubit, use_basis_gates=use_basis_gates)\n    else:\n        cgate = _mcsu2_real_diagonal(RXGate(theta).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n        self.compose(cgate, control_qubits + [target_qubit], inplace=True)",
        "mutated": [
            "def mcrx(self, theta: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, use_basis_gates: bool=False):\n    if False:\n        i = 10\n    '\\n    Apply Multiple-Controlled X rotation gate\\n\\n    Args:\\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcrx gate on.\\n        theta (float): angle theta\\n        q_controls (QuantumRegister or list(Qubit)): The list of control qubits\\n        q_target (Qubit): The target qubit\\n        use_basis_gates (bool): use p, u, cx\\n\\n    Raises:\\n        QiskitError: parameter errors\\n    '\n    from .rx import RXGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    all_qubits = control_qubits + target_qubit\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    n_c = len(control_qubits)\n    if n_c == 1:\n        _apply_cu(self, theta, -pi / 2, pi / 2, control_qubits[0], target_qubit, use_basis_gates=use_basis_gates)\n    elif n_c < 4:\n        theta_step = theta * (1 / 2 ** (n_c - 1))\n        _apply_mcu_graycode(self, theta_step, -pi / 2, pi / 2, control_qubits, target_qubit, use_basis_gates=use_basis_gates)\n    else:\n        cgate = _mcsu2_real_diagonal(RXGate(theta).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n        self.compose(cgate, control_qubits + [target_qubit], inplace=True)",
            "def mcrx(self, theta: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, use_basis_gates: bool=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Apply Multiple-Controlled X rotation gate\\n\\n    Args:\\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcrx gate on.\\n        theta (float): angle theta\\n        q_controls (QuantumRegister or list(Qubit)): The list of control qubits\\n        q_target (Qubit): The target qubit\\n        use_basis_gates (bool): use p, u, cx\\n\\n    Raises:\\n        QiskitError: parameter errors\\n    '\n    from .rx import RXGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    all_qubits = control_qubits + target_qubit\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    n_c = len(control_qubits)\n    if n_c == 1:\n        _apply_cu(self, theta, -pi / 2, pi / 2, control_qubits[0], target_qubit, use_basis_gates=use_basis_gates)\n    elif n_c < 4:\n        theta_step = theta * (1 / 2 ** (n_c - 1))\n        _apply_mcu_graycode(self, theta_step, -pi / 2, pi / 2, control_qubits, target_qubit, use_basis_gates=use_basis_gates)\n    else:\n        cgate = _mcsu2_real_diagonal(RXGate(theta).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n        self.compose(cgate, control_qubits + [target_qubit], inplace=True)",
            "def mcrx(self, theta: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, use_basis_gates: bool=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Apply Multiple-Controlled X rotation gate\\n\\n    Args:\\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcrx gate on.\\n        theta (float): angle theta\\n        q_controls (QuantumRegister or list(Qubit)): The list of control qubits\\n        q_target (Qubit): The target qubit\\n        use_basis_gates (bool): use p, u, cx\\n\\n    Raises:\\n        QiskitError: parameter errors\\n    '\n    from .rx import RXGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    all_qubits = control_qubits + target_qubit\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    n_c = len(control_qubits)\n    if n_c == 1:\n        _apply_cu(self, theta, -pi / 2, pi / 2, control_qubits[0], target_qubit, use_basis_gates=use_basis_gates)\n    elif n_c < 4:\n        theta_step = theta * (1 / 2 ** (n_c - 1))\n        _apply_mcu_graycode(self, theta_step, -pi / 2, pi / 2, control_qubits, target_qubit, use_basis_gates=use_basis_gates)\n    else:\n        cgate = _mcsu2_real_diagonal(RXGate(theta).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n        self.compose(cgate, control_qubits + [target_qubit], inplace=True)",
            "def mcrx(self, theta: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, use_basis_gates: bool=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Apply Multiple-Controlled X rotation gate\\n\\n    Args:\\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcrx gate on.\\n        theta (float): angle theta\\n        q_controls (QuantumRegister or list(Qubit)): The list of control qubits\\n        q_target (Qubit): The target qubit\\n        use_basis_gates (bool): use p, u, cx\\n\\n    Raises:\\n        QiskitError: parameter errors\\n    '\n    from .rx import RXGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    all_qubits = control_qubits + target_qubit\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    n_c = len(control_qubits)\n    if n_c == 1:\n        _apply_cu(self, theta, -pi / 2, pi / 2, control_qubits[0], target_qubit, use_basis_gates=use_basis_gates)\n    elif n_c < 4:\n        theta_step = theta * (1 / 2 ** (n_c - 1))\n        _apply_mcu_graycode(self, theta_step, -pi / 2, pi / 2, control_qubits, target_qubit, use_basis_gates=use_basis_gates)\n    else:\n        cgate = _mcsu2_real_diagonal(RXGate(theta).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n        self.compose(cgate, control_qubits + [target_qubit], inplace=True)",
            "def mcrx(self, theta: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, use_basis_gates: bool=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Apply Multiple-Controlled X rotation gate\\n\\n    Args:\\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcrx gate on.\\n        theta (float): angle theta\\n        q_controls (QuantumRegister or list(Qubit)): The list of control qubits\\n        q_target (Qubit): The target qubit\\n        use_basis_gates (bool): use p, u, cx\\n\\n    Raises:\\n        QiskitError: parameter errors\\n    '\n    from .rx import RXGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    all_qubits = control_qubits + target_qubit\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    n_c = len(control_qubits)\n    if n_c == 1:\n        _apply_cu(self, theta, -pi / 2, pi / 2, control_qubits[0], target_qubit, use_basis_gates=use_basis_gates)\n    elif n_c < 4:\n        theta_step = theta * (1 / 2 ** (n_c - 1))\n        _apply_mcu_graycode(self, theta_step, -pi / 2, pi / 2, control_qubits, target_qubit, use_basis_gates=use_basis_gates)\n    else:\n        cgate = _mcsu2_real_diagonal(RXGate(theta).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n        self.compose(cgate, control_qubits + [target_qubit], inplace=True)"
        ]
    },
    {
        "func_name": "mcry",
        "original": "def mcry(self, theta: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, q_ancillae: Optional[Union[QuantumRegister, Tuple[QuantumRegister, int]]]=None, mode: str=None, use_basis_gates=False):\n    \"\"\"\n    Apply Multiple-Controlled Y rotation gate\n\n    Args:\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcry gate on.\n        theta (float): angle theta\n        q_controls (list(Qubit)): The list of control qubits\n        q_target (Qubit): The target qubit\n        q_ancillae (QuantumRegister or tuple(QuantumRegister, int)): The list of ancillary qubits.\n        mode (string): The implementation mode to use\n        use_basis_gates (bool): use p, u, cx\n\n    Raises:\n        QiskitError: parameter errors\n    \"\"\"\n    from .ry import RYGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    ancillary_qubits = [] if q_ancillae is None else self.qbit_argument_conversion(q_ancillae)\n    all_qubits = control_qubits + target_qubit + ancillary_qubits\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    if mode is None:\n        additional_vchain = MCXGate.get_num_ancilla_qubits(len(control_qubits), 'v-chain')\n        if len(ancillary_qubits) >= additional_vchain:\n            mode = 'basic'\n        else:\n            mode = 'noancilla'\n    if mode == 'basic':\n        self.ry(theta / 2, q_target)\n        self.mcx(q_controls, q_target, q_ancillae, mode='v-chain')\n        self.ry(-theta / 2, q_target)\n        self.mcx(q_controls, q_target, q_ancillae, mode='v-chain')\n    elif mode == 'noancilla':\n        n_c = len(control_qubits)\n        if n_c == 1:\n            _apply_cu(self, theta, 0, 0, control_qubits[0], target_qubit, use_basis_gates=use_basis_gates)\n        elif n_c < 4:\n            theta_step = theta * (1 / 2 ** (n_c - 1))\n            _apply_mcu_graycode(self, theta_step, 0, 0, control_qubits, target_qubit, use_basis_gates=use_basis_gates)\n        else:\n            cgate = _mcsu2_real_diagonal(RYGate(theta).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n            self.compose(cgate, control_qubits + [target_qubit], inplace=True)\n    else:\n        raise QiskitError(f'Unrecognized mode for building MCRY circuit: {mode}.')",
        "mutated": [
            "def mcry(self, theta: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, q_ancillae: Optional[Union[QuantumRegister, Tuple[QuantumRegister, int]]]=None, mode: str=None, use_basis_gates=False):\n    if False:\n        i = 10\n    '\\n    Apply Multiple-Controlled Y rotation gate\\n\\n    Args:\\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcry gate on.\\n        theta (float): angle theta\\n        q_controls (list(Qubit)): The list of control qubits\\n        q_target (Qubit): The target qubit\\n        q_ancillae (QuantumRegister or tuple(QuantumRegister, int)): The list of ancillary qubits.\\n        mode (string): The implementation mode to use\\n        use_basis_gates (bool): use p, u, cx\\n\\n    Raises:\\n        QiskitError: parameter errors\\n    '\n    from .ry import RYGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    ancillary_qubits = [] if q_ancillae is None else self.qbit_argument_conversion(q_ancillae)\n    all_qubits = control_qubits + target_qubit + ancillary_qubits\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    if mode is None:\n        additional_vchain = MCXGate.get_num_ancilla_qubits(len(control_qubits), 'v-chain')\n        if len(ancillary_qubits) >= additional_vchain:\n            mode = 'basic'\n        else:\n            mode = 'noancilla'\n    if mode == 'basic':\n        self.ry(theta / 2, q_target)\n        self.mcx(q_controls, q_target, q_ancillae, mode='v-chain')\n        self.ry(-theta / 2, q_target)\n        self.mcx(q_controls, q_target, q_ancillae, mode='v-chain')\n    elif mode == 'noancilla':\n        n_c = len(control_qubits)\n        if n_c == 1:\n            _apply_cu(self, theta, 0, 0, control_qubits[0], target_qubit, use_basis_gates=use_basis_gates)\n        elif n_c < 4:\n            theta_step = theta * (1 / 2 ** (n_c - 1))\n            _apply_mcu_graycode(self, theta_step, 0, 0, control_qubits, target_qubit, use_basis_gates=use_basis_gates)\n        else:\n            cgate = _mcsu2_real_diagonal(RYGate(theta).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n            self.compose(cgate, control_qubits + [target_qubit], inplace=True)\n    else:\n        raise QiskitError(f'Unrecognized mode for building MCRY circuit: {mode}.')",
            "def mcry(self, theta: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, q_ancillae: Optional[Union[QuantumRegister, Tuple[QuantumRegister, int]]]=None, mode: str=None, use_basis_gates=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Apply Multiple-Controlled Y rotation gate\\n\\n    Args:\\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcry gate on.\\n        theta (float): angle theta\\n        q_controls (list(Qubit)): The list of control qubits\\n        q_target (Qubit): The target qubit\\n        q_ancillae (QuantumRegister or tuple(QuantumRegister, int)): The list of ancillary qubits.\\n        mode (string): The implementation mode to use\\n        use_basis_gates (bool): use p, u, cx\\n\\n    Raises:\\n        QiskitError: parameter errors\\n    '\n    from .ry import RYGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    ancillary_qubits = [] if q_ancillae is None else self.qbit_argument_conversion(q_ancillae)\n    all_qubits = control_qubits + target_qubit + ancillary_qubits\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    if mode is None:\n        additional_vchain = MCXGate.get_num_ancilla_qubits(len(control_qubits), 'v-chain')\n        if len(ancillary_qubits) >= additional_vchain:\n            mode = 'basic'\n        else:\n            mode = 'noancilla'\n    if mode == 'basic':\n        self.ry(theta / 2, q_target)\n        self.mcx(q_controls, q_target, q_ancillae, mode='v-chain')\n        self.ry(-theta / 2, q_target)\n        self.mcx(q_controls, q_target, q_ancillae, mode='v-chain')\n    elif mode == 'noancilla':\n        n_c = len(control_qubits)\n        if n_c == 1:\n            _apply_cu(self, theta, 0, 0, control_qubits[0], target_qubit, use_basis_gates=use_basis_gates)\n        elif n_c < 4:\n            theta_step = theta * (1 / 2 ** (n_c - 1))\n            _apply_mcu_graycode(self, theta_step, 0, 0, control_qubits, target_qubit, use_basis_gates=use_basis_gates)\n        else:\n            cgate = _mcsu2_real_diagonal(RYGate(theta).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n            self.compose(cgate, control_qubits + [target_qubit], inplace=True)\n    else:\n        raise QiskitError(f'Unrecognized mode for building MCRY circuit: {mode}.')",
            "def mcry(self, theta: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, q_ancillae: Optional[Union[QuantumRegister, Tuple[QuantumRegister, int]]]=None, mode: str=None, use_basis_gates=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Apply Multiple-Controlled Y rotation gate\\n\\n    Args:\\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcry gate on.\\n        theta (float): angle theta\\n        q_controls (list(Qubit)): The list of control qubits\\n        q_target (Qubit): The target qubit\\n        q_ancillae (QuantumRegister or tuple(QuantumRegister, int)): The list of ancillary qubits.\\n        mode (string): The implementation mode to use\\n        use_basis_gates (bool): use p, u, cx\\n\\n    Raises:\\n        QiskitError: parameter errors\\n    '\n    from .ry import RYGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    ancillary_qubits = [] if q_ancillae is None else self.qbit_argument_conversion(q_ancillae)\n    all_qubits = control_qubits + target_qubit + ancillary_qubits\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    if mode is None:\n        additional_vchain = MCXGate.get_num_ancilla_qubits(len(control_qubits), 'v-chain')\n        if len(ancillary_qubits) >= additional_vchain:\n            mode = 'basic'\n        else:\n            mode = 'noancilla'\n    if mode == 'basic':\n        self.ry(theta / 2, q_target)\n        self.mcx(q_controls, q_target, q_ancillae, mode='v-chain')\n        self.ry(-theta / 2, q_target)\n        self.mcx(q_controls, q_target, q_ancillae, mode='v-chain')\n    elif mode == 'noancilla':\n        n_c = len(control_qubits)\n        if n_c == 1:\n            _apply_cu(self, theta, 0, 0, control_qubits[0], target_qubit, use_basis_gates=use_basis_gates)\n        elif n_c < 4:\n            theta_step = theta * (1 / 2 ** (n_c - 1))\n            _apply_mcu_graycode(self, theta_step, 0, 0, control_qubits, target_qubit, use_basis_gates=use_basis_gates)\n        else:\n            cgate = _mcsu2_real_diagonal(RYGate(theta).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n            self.compose(cgate, control_qubits + [target_qubit], inplace=True)\n    else:\n        raise QiskitError(f'Unrecognized mode for building MCRY circuit: {mode}.')",
            "def mcry(self, theta: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, q_ancillae: Optional[Union[QuantumRegister, Tuple[QuantumRegister, int]]]=None, mode: str=None, use_basis_gates=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Apply Multiple-Controlled Y rotation gate\\n\\n    Args:\\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcry gate on.\\n        theta (float): angle theta\\n        q_controls (list(Qubit)): The list of control qubits\\n        q_target (Qubit): The target qubit\\n        q_ancillae (QuantumRegister or tuple(QuantumRegister, int)): The list of ancillary qubits.\\n        mode (string): The implementation mode to use\\n        use_basis_gates (bool): use p, u, cx\\n\\n    Raises:\\n        QiskitError: parameter errors\\n    '\n    from .ry import RYGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    ancillary_qubits = [] if q_ancillae is None else self.qbit_argument_conversion(q_ancillae)\n    all_qubits = control_qubits + target_qubit + ancillary_qubits\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    if mode is None:\n        additional_vchain = MCXGate.get_num_ancilla_qubits(len(control_qubits), 'v-chain')\n        if len(ancillary_qubits) >= additional_vchain:\n            mode = 'basic'\n        else:\n            mode = 'noancilla'\n    if mode == 'basic':\n        self.ry(theta / 2, q_target)\n        self.mcx(q_controls, q_target, q_ancillae, mode='v-chain')\n        self.ry(-theta / 2, q_target)\n        self.mcx(q_controls, q_target, q_ancillae, mode='v-chain')\n    elif mode == 'noancilla':\n        n_c = len(control_qubits)\n        if n_c == 1:\n            _apply_cu(self, theta, 0, 0, control_qubits[0], target_qubit, use_basis_gates=use_basis_gates)\n        elif n_c < 4:\n            theta_step = theta * (1 / 2 ** (n_c - 1))\n            _apply_mcu_graycode(self, theta_step, 0, 0, control_qubits, target_qubit, use_basis_gates=use_basis_gates)\n        else:\n            cgate = _mcsu2_real_diagonal(RYGate(theta).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n            self.compose(cgate, control_qubits + [target_qubit], inplace=True)\n    else:\n        raise QiskitError(f'Unrecognized mode for building MCRY circuit: {mode}.')",
            "def mcry(self, theta: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, q_ancillae: Optional[Union[QuantumRegister, Tuple[QuantumRegister, int]]]=None, mode: str=None, use_basis_gates=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Apply Multiple-Controlled Y rotation gate\\n\\n    Args:\\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcry gate on.\\n        theta (float): angle theta\\n        q_controls (list(Qubit)): The list of control qubits\\n        q_target (Qubit): The target qubit\\n        q_ancillae (QuantumRegister or tuple(QuantumRegister, int)): The list of ancillary qubits.\\n        mode (string): The implementation mode to use\\n        use_basis_gates (bool): use p, u, cx\\n\\n    Raises:\\n        QiskitError: parameter errors\\n    '\n    from .ry import RYGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    ancillary_qubits = [] if q_ancillae is None else self.qbit_argument_conversion(q_ancillae)\n    all_qubits = control_qubits + target_qubit + ancillary_qubits\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    if mode is None:\n        additional_vchain = MCXGate.get_num_ancilla_qubits(len(control_qubits), 'v-chain')\n        if len(ancillary_qubits) >= additional_vchain:\n            mode = 'basic'\n        else:\n            mode = 'noancilla'\n    if mode == 'basic':\n        self.ry(theta / 2, q_target)\n        self.mcx(q_controls, q_target, q_ancillae, mode='v-chain')\n        self.ry(-theta / 2, q_target)\n        self.mcx(q_controls, q_target, q_ancillae, mode='v-chain')\n    elif mode == 'noancilla':\n        n_c = len(control_qubits)\n        if n_c == 1:\n            _apply_cu(self, theta, 0, 0, control_qubits[0], target_qubit, use_basis_gates=use_basis_gates)\n        elif n_c < 4:\n            theta_step = theta * (1 / 2 ** (n_c - 1))\n            _apply_mcu_graycode(self, theta_step, 0, 0, control_qubits, target_qubit, use_basis_gates=use_basis_gates)\n        else:\n            cgate = _mcsu2_real_diagonal(RYGate(theta).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n            self.compose(cgate, control_qubits + [target_qubit], inplace=True)\n    else:\n        raise QiskitError(f'Unrecognized mode for building MCRY circuit: {mode}.')"
        ]
    },
    {
        "func_name": "mcrz",
        "original": "def mcrz(self, lam: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, use_basis_gates: bool=False):\n    \"\"\"\n    Apply Multiple-Controlled Z rotation gate\n\n    Args:\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcrz gate on.\n        lam (float): angle lambda\n        q_controls (list(Qubit)): The list of control qubits\n        q_target (Qubit): The target qubit\n        use_basis_gates (bool): use p, u, cx\n\n    Raises:\n        QiskitError: parameter errors\n    \"\"\"\n    from .rz import CRZGate, RZGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    all_qubits = control_qubits + target_qubit\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    n_c = len(control_qubits)\n    if n_c == 1:\n        if use_basis_gates:\n            self.u(0, 0, lam / 2, target_qubit)\n            self.cx(control_qubits[0], target_qubit)\n            self.u(0, 0, -lam / 2, target_qubit)\n            self.cx(control_qubits[0], target_qubit)\n        else:\n            self.append(CRZGate(lam), control_qubits + [target_qubit])\n    else:\n        cgate = _mcsu2_real_diagonal(RZGate(lam).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n        self.compose(cgate, control_qubits + [target_qubit], inplace=True)",
        "mutated": [
            "def mcrz(self, lam: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, use_basis_gates: bool=False):\n    if False:\n        i = 10\n    '\\n    Apply Multiple-Controlled Z rotation gate\\n\\n    Args:\\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcrz gate on.\\n        lam (float): angle lambda\\n        q_controls (list(Qubit)): The list of control qubits\\n        q_target (Qubit): The target qubit\\n        use_basis_gates (bool): use p, u, cx\\n\\n    Raises:\\n        QiskitError: parameter errors\\n    '\n    from .rz import CRZGate, RZGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    all_qubits = control_qubits + target_qubit\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    n_c = len(control_qubits)\n    if n_c == 1:\n        if use_basis_gates:\n            self.u(0, 0, lam / 2, target_qubit)\n            self.cx(control_qubits[0], target_qubit)\n            self.u(0, 0, -lam / 2, target_qubit)\n            self.cx(control_qubits[0], target_qubit)\n        else:\n            self.append(CRZGate(lam), control_qubits + [target_qubit])\n    else:\n        cgate = _mcsu2_real_diagonal(RZGate(lam).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n        self.compose(cgate, control_qubits + [target_qubit], inplace=True)",
            "def mcrz(self, lam: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, use_basis_gates: bool=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Apply Multiple-Controlled Z rotation gate\\n\\n    Args:\\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcrz gate on.\\n        lam (float): angle lambda\\n        q_controls (list(Qubit)): The list of control qubits\\n        q_target (Qubit): The target qubit\\n        use_basis_gates (bool): use p, u, cx\\n\\n    Raises:\\n        QiskitError: parameter errors\\n    '\n    from .rz import CRZGate, RZGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    all_qubits = control_qubits + target_qubit\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    n_c = len(control_qubits)\n    if n_c == 1:\n        if use_basis_gates:\n            self.u(0, 0, lam / 2, target_qubit)\n            self.cx(control_qubits[0], target_qubit)\n            self.u(0, 0, -lam / 2, target_qubit)\n            self.cx(control_qubits[0], target_qubit)\n        else:\n            self.append(CRZGate(lam), control_qubits + [target_qubit])\n    else:\n        cgate = _mcsu2_real_diagonal(RZGate(lam).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n        self.compose(cgate, control_qubits + [target_qubit], inplace=True)",
            "def mcrz(self, lam: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, use_basis_gates: bool=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Apply Multiple-Controlled Z rotation gate\\n\\n    Args:\\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcrz gate on.\\n        lam (float): angle lambda\\n        q_controls (list(Qubit)): The list of control qubits\\n        q_target (Qubit): The target qubit\\n        use_basis_gates (bool): use p, u, cx\\n\\n    Raises:\\n        QiskitError: parameter errors\\n    '\n    from .rz import CRZGate, RZGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    all_qubits = control_qubits + target_qubit\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    n_c = len(control_qubits)\n    if n_c == 1:\n        if use_basis_gates:\n            self.u(0, 0, lam / 2, target_qubit)\n            self.cx(control_qubits[0], target_qubit)\n            self.u(0, 0, -lam / 2, target_qubit)\n            self.cx(control_qubits[0], target_qubit)\n        else:\n            self.append(CRZGate(lam), control_qubits + [target_qubit])\n    else:\n        cgate = _mcsu2_real_diagonal(RZGate(lam).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n        self.compose(cgate, control_qubits + [target_qubit], inplace=True)",
            "def mcrz(self, lam: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, use_basis_gates: bool=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Apply Multiple-Controlled Z rotation gate\\n\\n    Args:\\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcrz gate on.\\n        lam (float): angle lambda\\n        q_controls (list(Qubit)): The list of control qubits\\n        q_target (Qubit): The target qubit\\n        use_basis_gates (bool): use p, u, cx\\n\\n    Raises:\\n        QiskitError: parameter errors\\n    '\n    from .rz import CRZGate, RZGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    all_qubits = control_qubits + target_qubit\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    n_c = len(control_qubits)\n    if n_c == 1:\n        if use_basis_gates:\n            self.u(0, 0, lam / 2, target_qubit)\n            self.cx(control_qubits[0], target_qubit)\n            self.u(0, 0, -lam / 2, target_qubit)\n            self.cx(control_qubits[0], target_qubit)\n        else:\n            self.append(CRZGate(lam), control_qubits + [target_qubit])\n    else:\n        cgate = _mcsu2_real_diagonal(RZGate(lam).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n        self.compose(cgate, control_qubits + [target_qubit], inplace=True)",
            "def mcrz(self, lam: ParameterValueType, q_controls: Union[QuantumRegister, List[Qubit]], q_target: Qubit, use_basis_gates: bool=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Apply Multiple-Controlled Z rotation gate\\n\\n    Args:\\n        self (QuantumCircuit): The QuantumCircuit object to apply the mcrz gate on.\\n        lam (float): angle lambda\\n        q_controls (list(Qubit)): The list of control qubits\\n        q_target (Qubit): The target qubit\\n        use_basis_gates (bool): use p, u, cx\\n\\n    Raises:\\n        QiskitError: parameter errors\\n    '\n    from .rz import CRZGate, RZGate\n    control_qubits = self.qbit_argument_conversion(q_controls)\n    target_qubit = self.qbit_argument_conversion(q_target)\n    if len(target_qubit) != 1:\n        raise QiskitError('The mcrz gate needs a single qubit as target.')\n    all_qubits = control_qubits + target_qubit\n    target_qubit = target_qubit[0]\n    self._check_dups(all_qubits)\n    n_c = len(control_qubits)\n    if n_c == 1:\n        if use_basis_gates:\n            self.u(0, 0, lam / 2, target_qubit)\n            self.cx(control_qubits[0], target_qubit)\n            self.u(0, 0, -lam / 2, target_qubit)\n            self.cx(control_qubits[0], target_qubit)\n        else:\n            self.append(CRZGate(lam), control_qubits + [target_qubit])\n    else:\n        cgate = _mcsu2_real_diagonal(RZGate(lam).to_matrix(), num_controls=len(control_qubits), use_basis_gates=use_basis_gates)\n        self.compose(cgate, control_qubits + [target_qubit], inplace=True)"
        ]
    }
]