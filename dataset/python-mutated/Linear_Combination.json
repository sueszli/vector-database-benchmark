[
    {
        "func_name": "linear_combination",
        "original": "def linear_combination():\n    (URM, ICM_channel, ICM_event, ICM_genre, ICM_subgenre) = load_data('kaggle-data')\n    icm_channel_train = sp.csr_matrix((ICM_channel['data'], (ICM_channel['row'], ICM_channel['col'])))\n    icm_genre_train = sp.csr_matrix((ICM_genre['data'], (ICM_genre['row'], ICM_genre['col'])))\n    icm_subgenre_train = sp.csr_matrix((ICM_subgenre['data'], (ICM_subgenre['row'], ICM_subgenre['col'])))\n    icm_mixed_train = sp.hstack([icm_channel_train, icm_genre_train, icm_subgenre_train])\n    (urm_train_validation, urm_train, urm_validation, urm_test) = dataset_splits(URM, validation_percentage=0.2, testing_percentage=0.2)\n    icm_mixed_train *= 0.25122021\n    urm_stacked_mix_train = sp.vstack([urm_train, icm_mixed_train.T])\n    urm_stacked_mix_train_validation = sp.vstack([urm_train_validation, icm_mixed_train.T])\n    icm_subgenre_train *= 100.0\n    urm_stacked_sub_train = sp.vstack([urm_train, icm_subgenre_train.T])\n    urm_stacked_sub_train_validation = sp.vstack([urm_train_validation, icm_subgenre_train.T])\n    output_folder_path = 'Models/'\n    rec1 = MultVAERecommender_OptimizerMask(urm_stacked_mix_train_validation)\n    rec1.load_model(output_folder_path + 'MultVAE(0.2313)/', file_name=rec1.RECOMMENDER_NAME + '_best_model_last.zip')\n    print('Rec 1 is ready!')\n    rec2 = MultiThreadSLIM_SLIMElasticNetRecommender(urm_stacked_mix_train_validation)\n    rec2.load_model(output_folder_path + 'S_SLIM_ElasticNet/', file_name=rec2.RECOMMENDER_NAME + '_best_model_last.zip')\n    print('Rec 2 is ready!')\n    evaluator_validation = EvaluatorHoldout(urm_validation, [10])\n    evaluator_test = EvaluatorHoldout(urm_test, [10])\n    (result_df, _) = evaluator_test.evaluateRecommender(rec1)\n    print('{} FINAL MAP: {}'.format(rec1.RECOMMENDER_NAME, result_df.loc[10]['MAP']))\n    (result_df, _) = evaluator_test.evaluateRecommender(rec2)\n    print('{} FINAL MAP: {}'.format(rec2.RECOMMENDER_NAME, result_df.loc[10]['MAP']))\n    hyperparameters_range_dictionary = {'alpha': Real(low=0.0, high=1.0, prior='uniform')}\n    recommender_class = ScoresHybridRecommender\n    hyperparameterSearch = SearchBayesianSkopt(recommender_class, evaluator_validation=evaluator_test, evaluator_test=evaluator_test)\n    recommender_input_args = SearchInputRecommenderArgs(CONSTRUCTOR_POSITIONAL_ARGS=[urm_train_validation, rec1, rec2], CONSTRUCTOR_KEYWORD_ARGS={}, FIT_POSITIONAL_ARGS=[], FIT_KEYWORD_ARGS={})\n    recommender_input_args_last_test = SearchInputRecommenderArgs(CONSTRUCTOR_POSITIONAL_ARGS=[urm_train_validation, rec1, rec2], CONSTRUCTOR_KEYWORD_ARGS={}, FIT_POSITIONAL_ARGS=[], FIT_KEYWORD_ARGS={})\n    output_folder_path = 'result_experiments/'\n    n_cases = 100\n    n_random_starts = int(n_cases * 0.3)\n    metric_to_optimize = 'MAP'\n    cutoff_to_optimize = 10\n    hyperparameterSearch.search(recommender_input_args, recommender_input_args_last_test=recommender_input_args_last_test, hyperparameter_search_space=hyperparameters_range_dictionary, n_cases=n_cases, n_random_starts=n_random_starts, save_model='best', resume_from_saved=False, output_folder_path=output_folder_path, output_file_name_root=recommender_class.RECOMMENDER_NAME, metric_to_optimize=metric_to_optimize, cutoff_to_optimize=cutoff_to_optimize)",
        "mutated": [
            "def linear_combination():\n    if False:\n        i = 10\n    (URM, ICM_channel, ICM_event, ICM_genre, ICM_subgenre) = load_data('kaggle-data')\n    icm_channel_train = sp.csr_matrix((ICM_channel['data'], (ICM_channel['row'], ICM_channel['col'])))\n    icm_genre_train = sp.csr_matrix((ICM_genre['data'], (ICM_genre['row'], ICM_genre['col'])))\n    icm_subgenre_train = sp.csr_matrix((ICM_subgenre['data'], (ICM_subgenre['row'], ICM_subgenre['col'])))\n    icm_mixed_train = sp.hstack([icm_channel_train, icm_genre_train, icm_subgenre_train])\n    (urm_train_validation, urm_train, urm_validation, urm_test) = dataset_splits(URM, validation_percentage=0.2, testing_percentage=0.2)\n    icm_mixed_train *= 0.25122021\n    urm_stacked_mix_train = sp.vstack([urm_train, icm_mixed_train.T])\n    urm_stacked_mix_train_validation = sp.vstack([urm_train_validation, icm_mixed_train.T])\n    icm_subgenre_train *= 100.0\n    urm_stacked_sub_train = sp.vstack([urm_train, icm_subgenre_train.T])\n    urm_stacked_sub_train_validation = sp.vstack([urm_train_validation, icm_subgenre_train.T])\n    output_folder_path = 'Models/'\n    rec1 = MultVAERecommender_OptimizerMask(urm_stacked_mix_train_validation)\n    rec1.load_model(output_folder_path + 'MultVAE(0.2313)/', file_name=rec1.RECOMMENDER_NAME + '_best_model_last.zip')\n    print('Rec 1 is ready!')\n    rec2 = MultiThreadSLIM_SLIMElasticNetRecommender(urm_stacked_mix_train_validation)\n    rec2.load_model(output_folder_path + 'S_SLIM_ElasticNet/', file_name=rec2.RECOMMENDER_NAME + '_best_model_last.zip')\n    print('Rec 2 is ready!')\n    evaluator_validation = EvaluatorHoldout(urm_validation, [10])\n    evaluator_test = EvaluatorHoldout(urm_test, [10])\n    (result_df, _) = evaluator_test.evaluateRecommender(rec1)\n    print('{} FINAL MAP: {}'.format(rec1.RECOMMENDER_NAME, result_df.loc[10]['MAP']))\n    (result_df, _) = evaluator_test.evaluateRecommender(rec2)\n    print('{} FINAL MAP: {}'.format(rec2.RECOMMENDER_NAME, result_df.loc[10]['MAP']))\n    hyperparameters_range_dictionary = {'alpha': Real(low=0.0, high=1.0, prior='uniform')}\n    recommender_class = ScoresHybridRecommender\n    hyperparameterSearch = SearchBayesianSkopt(recommender_class, evaluator_validation=evaluator_test, evaluator_test=evaluator_test)\n    recommender_input_args = SearchInputRecommenderArgs(CONSTRUCTOR_POSITIONAL_ARGS=[urm_train_validation, rec1, rec2], CONSTRUCTOR_KEYWORD_ARGS={}, FIT_POSITIONAL_ARGS=[], FIT_KEYWORD_ARGS={})\n    recommender_input_args_last_test = SearchInputRecommenderArgs(CONSTRUCTOR_POSITIONAL_ARGS=[urm_train_validation, rec1, rec2], CONSTRUCTOR_KEYWORD_ARGS={}, FIT_POSITIONAL_ARGS=[], FIT_KEYWORD_ARGS={})\n    output_folder_path = 'result_experiments/'\n    n_cases = 100\n    n_random_starts = int(n_cases * 0.3)\n    metric_to_optimize = 'MAP'\n    cutoff_to_optimize = 10\n    hyperparameterSearch.search(recommender_input_args, recommender_input_args_last_test=recommender_input_args_last_test, hyperparameter_search_space=hyperparameters_range_dictionary, n_cases=n_cases, n_random_starts=n_random_starts, save_model='best', resume_from_saved=False, output_folder_path=output_folder_path, output_file_name_root=recommender_class.RECOMMENDER_NAME, metric_to_optimize=metric_to_optimize, cutoff_to_optimize=cutoff_to_optimize)",
            "def linear_combination():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (URM, ICM_channel, ICM_event, ICM_genre, ICM_subgenre) = load_data('kaggle-data')\n    icm_channel_train = sp.csr_matrix((ICM_channel['data'], (ICM_channel['row'], ICM_channel['col'])))\n    icm_genre_train = sp.csr_matrix((ICM_genre['data'], (ICM_genre['row'], ICM_genre['col'])))\n    icm_subgenre_train = sp.csr_matrix((ICM_subgenre['data'], (ICM_subgenre['row'], ICM_subgenre['col'])))\n    icm_mixed_train = sp.hstack([icm_channel_train, icm_genre_train, icm_subgenre_train])\n    (urm_train_validation, urm_train, urm_validation, urm_test) = dataset_splits(URM, validation_percentage=0.2, testing_percentage=0.2)\n    icm_mixed_train *= 0.25122021\n    urm_stacked_mix_train = sp.vstack([urm_train, icm_mixed_train.T])\n    urm_stacked_mix_train_validation = sp.vstack([urm_train_validation, icm_mixed_train.T])\n    icm_subgenre_train *= 100.0\n    urm_stacked_sub_train = sp.vstack([urm_train, icm_subgenre_train.T])\n    urm_stacked_sub_train_validation = sp.vstack([urm_train_validation, icm_subgenre_train.T])\n    output_folder_path = 'Models/'\n    rec1 = MultVAERecommender_OptimizerMask(urm_stacked_mix_train_validation)\n    rec1.load_model(output_folder_path + 'MultVAE(0.2313)/', file_name=rec1.RECOMMENDER_NAME + '_best_model_last.zip')\n    print('Rec 1 is ready!')\n    rec2 = MultiThreadSLIM_SLIMElasticNetRecommender(urm_stacked_mix_train_validation)\n    rec2.load_model(output_folder_path + 'S_SLIM_ElasticNet/', file_name=rec2.RECOMMENDER_NAME + '_best_model_last.zip')\n    print('Rec 2 is ready!')\n    evaluator_validation = EvaluatorHoldout(urm_validation, [10])\n    evaluator_test = EvaluatorHoldout(urm_test, [10])\n    (result_df, _) = evaluator_test.evaluateRecommender(rec1)\n    print('{} FINAL MAP: {}'.format(rec1.RECOMMENDER_NAME, result_df.loc[10]['MAP']))\n    (result_df, _) = evaluator_test.evaluateRecommender(rec2)\n    print('{} FINAL MAP: {}'.format(rec2.RECOMMENDER_NAME, result_df.loc[10]['MAP']))\n    hyperparameters_range_dictionary = {'alpha': Real(low=0.0, high=1.0, prior='uniform')}\n    recommender_class = ScoresHybridRecommender\n    hyperparameterSearch = SearchBayesianSkopt(recommender_class, evaluator_validation=evaluator_test, evaluator_test=evaluator_test)\n    recommender_input_args = SearchInputRecommenderArgs(CONSTRUCTOR_POSITIONAL_ARGS=[urm_train_validation, rec1, rec2], CONSTRUCTOR_KEYWORD_ARGS={}, FIT_POSITIONAL_ARGS=[], FIT_KEYWORD_ARGS={})\n    recommender_input_args_last_test = SearchInputRecommenderArgs(CONSTRUCTOR_POSITIONAL_ARGS=[urm_train_validation, rec1, rec2], CONSTRUCTOR_KEYWORD_ARGS={}, FIT_POSITIONAL_ARGS=[], FIT_KEYWORD_ARGS={})\n    output_folder_path = 'result_experiments/'\n    n_cases = 100\n    n_random_starts = int(n_cases * 0.3)\n    metric_to_optimize = 'MAP'\n    cutoff_to_optimize = 10\n    hyperparameterSearch.search(recommender_input_args, recommender_input_args_last_test=recommender_input_args_last_test, hyperparameter_search_space=hyperparameters_range_dictionary, n_cases=n_cases, n_random_starts=n_random_starts, save_model='best', resume_from_saved=False, output_folder_path=output_folder_path, output_file_name_root=recommender_class.RECOMMENDER_NAME, metric_to_optimize=metric_to_optimize, cutoff_to_optimize=cutoff_to_optimize)",
            "def linear_combination():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (URM, ICM_channel, ICM_event, ICM_genre, ICM_subgenre) = load_data('kaggle-data')\n    icm_channel_train = sp.csr_matrix((ICM_channel['data'], (ICM_channel['row'], ICM_channel['col'])))\n    icm_genre_train = sp.csr_matrix((ICM_genre['data'], (ICM_genre['row'], ICM_genre['col'])))\n    icm_subgenre_train = sp.csr_matrix((ICM_subgenre['data'], (ICM_subgenre['row'], ICM_subgenre['col'])))\n    icm_mixed_train = sp.hstack([icm_channel_train, icm_genre_train, icm_subgenre_train])\n    (urm_train_validation, urm_train, urm_validation, urm_test) = dataset_splits(URM, validation_percentage=0.2, testing_percentage=0.2)\n    icm_mixed_train *= 0.25122021\n    urm_stacked_mix_train = sp.vstack([urm_train, icm_mixed_train.T])\n    urm_stacked_mix_train_validation = sp.vstack([urm_train_validation, icm_mixed_train.T])\n    icm_subgenre_train *= 100.0\n    urm_stacked_sub_train = sp.vstack([urm_train, icm_subgenre_train.T])\n    urm_stacked_sub_train_validation = sp.vstack([urm_train_validation, icm_subgenre_train.T])\n    output_folder_path = 'Models/'\n    rec1 = MultVAERecommender_OptimizerMask(urm_stacked_mix_train_validation)\n    rec1.load_model(output_folder_path + 'MultVAE(0.2313)/', file_name=rec1.RECOMMENDER_NAME + '_best_model_last.zip')\n    print('Rec 1 is ready!')\n    rec2 = MultiThreadSLIM_SLIMElasticNetRecommender(urm_stacked_mix_train_validation)\n    rec2.load_model(output_folder_path + 'S_SLIM_ElasticNet/', file_name=rec2.RECOMMENDER_NAME + '_best_model_last.zip')\n    print('Rec 2 is ready!')\n    evaluator_validation = EvaluatorHoldout(urm_validation, [10])\n    evaluator_test = EvaluatorHoldout(urm_test, [10])\n    (result_df, _) = evaluator_test.evaluateRecommender(rec1)\n    print('{} FINAL MAP: {}'.format(rec1.RECOMMENDER_NAME, result_df.loc[10]['MAP']))\n    (result_df, _) = evaluator_test.evaluateRecommender(rec2)\n    print('{} FINAL MAP: {}'.format(rec2.RECOMMENDER_NAME, result_df.loc[10]['MAP']))\n    hyperparameters_range_dictionary = {'alpha': Real(low=0.0, high=1.0, prior='uniform')}\n    recommender_class = ScoresHybridRecommender\n    hyperparameterSearch = SearchBayesianSkopt(recommender_class, evaluator_validation=evaluator_test, evaluator_test=evaluator_test)\n    recommender_input_args = SearchInputRecommenderArgs(CONSTRUCTOR_POSITIONAL_ARGS=[urm_train_validation, rec1, rec2], CONSTRUCTOR_KEYWORD_ARGS={}, FIT_POSITIONAL_ARGS=[], FIT_KEYWORD_ARGS={})\n    recommender_input_args_last_test = SearchInputRecommenderArgs(CONSTRUCTOR_POSITIONAL_ARGS=[urm_train_validation, rec1, rec2], CONSTRUCTOR_KEYWORD_ARGS={}, FIT_POSITIONAL_ARGS=[], FIT_KEYWORD_ARGS={})\n    output_folder_path = 'result_experiments/'\n    n_cases = 100\n    n_random_starts = int(n_cases * 0.3)\n    metric_to_optimize = 'MAP'\n    cutoff_to_optimize = 10\n    hyperparameterSearch.search(recommender_input_args, recommender_input_args_last_test=recommender_input_args_last_test, hyperparameter_search_space=hyperparameters_range_dictionary, n_cases=n_cases, n_random_starts=n_random_starts, save_model='best', resume_from_saved=False, output_folder_path=output_folder_path, output_file_name_root=recommender_class.RECOMMENDER_NAME, metric_to_optimize=metric_to_optimize, cutoff_to_optimize=cutoff_to_optimize)",
            "def linear_combination():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (URM, ICM_channel, ICM_event, ICM_genre, ICM_subgenre) = load_data('kaggle-data')\n    icm_channel_train = sp.csr_matrix((ICM_channel['data'], (ICM_channel['row'], ICM_channel['col'])))\n    icm_genre_train = sp.csr_matrix((ICM_genre['data'], (ICM_genre['row'], ICM_genre['col'])))\n    icm_subgenre_train = sp.csr_matrix((ICM_subgenre['data'], (ICM_subgenre['row'], ICM_subgenre['col'])))\n    icm_mixed_train = sp.hstack([icm_channel_train, icm_genre_train, icm_subgenre_train])\n    (urm_train_validation, urm_train, urm_validation, urm_test) = dataset_splits(URM, validation_percentage=0.2, testing_percentage=0.2)\n    icm_mixed_train *= 0.25122021\n    urm_stacked_mix_train = sp.vstack([urm_train, icm_mixed_train.T])\n    urm_stacked_mix_train_validation = sp.vstack([urm_train_validation, icm_mixed_train.T])\n    icm_subgenre_train *= 100.0\n    urm_stacked_sub_train = sp.vstack([urm_train, icm_subgenre_train.T])\n    urm_stacked_sub_train_validation = sp.vstack([urm_train_validation, icm_subgenre_train.T])\n    output_folder_path = 'Models/'\n    rec1 = MultVAERecommender_OptimizerMask(urm_stacked_mix_train_validation)\n    rec1.load_model(output_folder_path + 'MultVAE(0.2313)/', file_name=rec1.RECOMMENDER_NAME + '_best_model_last.zip')\n    print('Rec 1 is ready!')\n    rec2 = MultiThreadSLIM_SLIMElasticNetRecommender(urm_stacked_mix_train_validation)\n    rec2.load_model(output_folder_path + 'S_SLIM_ElasticNet/', file_name=rec2.RECOMMENDER_NAME + '_best_model_last.zip')\n    print('Rec 2 is ready!')\n    evaluator_validation = EvaluatorHoldout(urm_validation, [10])\n    evaluator_test = EvaluatorHoldout(urm_test, [10])\n    (result_df, _) = evaluator_test.evaluateRecommender(rec1)\n    print('{} FINAL MAP: {}'.format(rec1.RECOMMENDER_NAME, result_df.loc[10]['MAP']))\n    (result_df, _) = evaluator_test.evaluateRecommender(rec2)\n    print('{} FINAL MAP: {}'.format(rec2.RECOMMENDER_NAME, result_df.loc[10]['MAP']))\n    hyperparameters_range_dictionary = {'alpha': Real(low=0.0, high=1.0, prior='uniform')}\n    recommender_class = ScoresHybridRecommender\n    hyperparameterSearch = SearchBayesianSkopt(recommender_class, evaluator_validation=evaluator_test, evaluator_test=evaluator_test)\n    recommender_input_args = SearchInputRecommenderArgs(CONSTRUCTOR_POSITIONAL_ARGS=[urm_train_validation, rec1, rec2], CONSTRUCTOR_KEYWORD_ARGS={}, FIT_POSITIONAL_ARGS=[], FIT_KEYWORD_ARGS={})\n    recommender_input_args_last_test = SearchInputRecommenderArgs(CONSTRUCTOR_POSITIONAL_ARGS=[urm_train_validation, rec1, rec2], CONSTRUCTOR_KEYWORD_ARGS={}, FIT_POSITIONAL_ARGS=[], FIT_KEYWORD_ARGS={})\n    output_folder_path = 'result_experiments/'\n    n_cases = 100\n    n_random_starts = int(n_cases * 0.3)\n    metric_to_optimize = 'MAP'\n    cutoff_to_optimize = 10\n    hyperparameterSearch.search(recommender_input_args, recommender_input_args_last_test=recommender_input_args_last_test, hyperparameter_search_space=hyperparameters_range_dictionary, n_cases=n_cases, n_random_starts=n_random_starts, save_model='best', resume_from_saved=False, output_folder_path=output_folder_path, output_file_name_root=recommender_class.RECOMMENDER_NAME, metric_to_optimize=metric_to_optimize, cutoff_to_optimize=cutoff_to_optimize)",
            "def linear_combination():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (URM, ICM_channel, ICM_event, ICM_genre, ICM_subgenre) = load_data('kaggle-data')\n    icm_channel_train = sp.csr_matrix((ICM_channel['data'], (ICM_channel['row'], ICM_channel['col'])))\n    icm_genre_train = sp.csr_matrix((ICM_genre['data'], (ICM_genre['row'], ICM_genre['col'])))\n    icm_subgenre_train = sp.csr_matrix((ICM_subgenre['data'], (ICM_subgenre['row'], ICM_subgenre['col'])))\n    icm_mixed_train = sp.hstack([icm_channel_train, icm_genre_train, icm_subgenre_train])\n    (urm_train_validation, urm_train, urm_validation, urm_test) = dataset_splits(URM, validation_percentage=0.2, testing_percentage=0.2)\n    icm_mixed_train *= 0.25122021\n    urm_stacked_mix_train = sp.vstack([urm_train, icm_mixed_train.T])\n    urm_stacked_mix_train_validation = sp.vstack([urm_train_validation, icm_mixed_train.T])\n    icm_subgenre_train *= 100.0\n    urm_stacked_sub_train = sp.vstack([urm_train, icm_subgenre_train.T])\n    urm_stacked_sub_train_validation = sp.vstack([urm_train_validation, icm_subgenre_train.T])\n    output_folder_path = 'Models/'\n    rec1 = MultVAERecommender_OptimizerMask(urm_stacked_mix_train_validation)\n    rec1.load_model(output_folder_path + 'MultVAE(0.2313)/', file_name=rec1.RECOMMENDER_NAME + '_best_model_last.zip')\n    print('Rec 1 is ready!')\n    rec2 = MultiThreadSLIM_SLIMElasticNetRecommender(urm_stacked_mix_train_validation)\n    rec2.load_model(output_folder_path + 'S_SLIM_ElasticNet/', file_name=rec2.RECOMMENDER_NAME + '_best_model_last.zip')\n    print('Rec 2 is ready!')\n    evaluator_validation = EvaluatorHoldout(urm_validation, [10])\n    evaluator_test = EvaluatorHoldout(urm_test, [10])\n    (result_df, _) = evaluator_test.evaluateRecommender(rec1)\n    print('{} FINAL MAP: {}'.format(rec1.RECOMMENDER_NAME, result_df.loc[10]['MAP']))\n    (result_df, _) = evaluator_test.evaluateRecommender(rec2)\n    print('{} FINAL MAP: {}'.format(rec2.RECOMMENDER_NAME, result_df.loc[10]['MAP']))\n    hyperparameters_range_dictionary = {'alpha': Real(low=0.0, high=1.0, prior='uniform')}\n    recommender_class = ScoresHybridRecommender\n    hyperparameterSearch = SearchBayesianSkopt(recommender_class, evaluator_validation=evaluator_test, evaluator_test=evaluator_test)\n    recommender_input_args = SearchInputRecommenderArgs(CONSTRUCTOR_POSITIONAL_ARGS=[urm_train_validation, rec1, rec2], CONSTRUCTOR_KEYWORD_ARGS={}, FIT_POSITIONAL_ARGS=[], FIT_KEYWORD_ARGS={})\n    recommender_input_args_last_test = SearchInputRecommenderArgs(CONSTRUCTOR_POSITIONAL_ARGS=[urm_train_validation, rec1, rec2], CONSTRUCTOR_KEYWORD_ARGS={}, FIT_POSITIONAL_ARGS=[], FIT_KEYWORD_ARGS={})\n    output_folder_path = 'result_experiments/'\n    n_cases = 100\n    n_random_starts = int(n_cases * 0.3)\n    metric_to_optimize = 'MAP'\n    cutoff_to_optimize = 10\n    hyperparameterSearch.search(recommender_input_args, recommender_input_args_last_test=recommender_input_args_last_test, hyperparameter_search_space=hyperparameters_range_dictionary, n_cases=n_cases, n_random_starts=n_random_starts, save_model='best', resume_from_saved=False, output_folder_path=output_folder_path, output_file_name_root=recommender_class.RECOMMENDER_NAME, metric_to_optimize=metric_to_optimize, cutoff_to_optimize=cutoff_to_optimize)"
        ]
    }
]