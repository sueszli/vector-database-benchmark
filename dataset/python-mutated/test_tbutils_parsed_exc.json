[
    {
        "func_name": "test_parsed_exc_basic",
        "original": "def test_parsed_exc_basic():\n    _tb_str = u'Traceback (most recent call last):\\n  File \"example.py\", line 2, in <module>\\n    plarp\\nNameError: name \\'plarp\\' is not defined'\n    parsed_tb = ParsedException.from_string(_tb_str)\n    print(parsed_tb)\n    assert parsed_tb.exc_type == 'NameError'\n    assert parsed_tb.exc_msg == \"name 'plarp' is not defined\"\n    assert parsed_tb.frames == [{'source_line': u'plarp', 'filepath': u'example.py', 'lineno': u'2', 'funcname': u'<module>'}]\n    assert parsed_tb.to_string() == _tb_str",
        "mutated": [
            "def test_parsed_exc_basic():\n    if False:\n        i = 10\n    _tb_str = u'Traceback (most recent call last):\\n  File \"example.py\", line 2, in <module>\\n    plarp\\nNameError: name \\'plarp\\' is not defined'\n    parsed_tb = ParsedException.from_string(_tb_str)\n    print(parsed_tb)\n    assert parsed_tb.exc_type == 'NameError'\n    assert parsed_tb.exc_msg == \"name 'plarp' is not defined\"\n    assert parsed_tb.frames == [{'source_line': u'plarp', 'filepath': u'example.py', 'lineno': u'2', 'funcname': u'<module>'}]\n    assert parsed_tb.to_string() == _tb_str",
            "def test_parsed_exc_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    _tb_str = u'Traceback (most recent call last):\\n  File \"example.py\", line 2, in <module>\\n    plarp\\nNameError: name \\'plarp\\' is not defined'\n    parsed_tb = ParsedException.from_string(_tb_str)\n    print(parsed_tb)\n    assert parsed_tb.exc_type == 'NameError'\n    assert parsed_tb.exc_msg == \"name 'plarp' is not defined\"\n    assert parsed_tb.frames == [{'source_line': u'plarp', 'filepath': u'example.py', 'lineno': u'2', 'funcname': u'<module>'}]\n    assert parsed_tb.to_string() == _tb_str",
            "def test_parsed_exc_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    _tb_str = u'Traceback (most recent call last):\\n  File \"example.py\", line 2, in <module>\\n    plarp\\nNameError: name \\'plarp\\' is not defined'\n    parsed_tb = ParsedException.from_string(_tb_str)\n    print(parsed_tb)\n    assert parsed_tb.exc_type == 'NameError'\n    assert parsed_tb.exc_msg == \"name 'plarp' is not defined\"\n    assert parsed_tb.frames == [{'source_line': u'plarp', 'filepath': u'example.py', 'lineno': u'2', 'funcname': u'<module>'}]\n    assert parsed_tb.to_string() == _tb_str",
            "def test_parsed_exc_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    _tb_str = u'Traceback (most recent call last):\\n  File \"example.py\", line 2, in <module>\\n    plarp\\nNameError: name \\'plarp\\' is not defined'\n    parsed_tb = ParsedException.from_string(_tb_str)\n    print(parsed_tb)\n    assert parsed_tb.exc_type == 'NameError'\n    assert parsed_tb.exc_msg == \"name 'plarp' is not defined\"\n    assert parsed_tb.frames == [{'source_line': u'plarp', 'filepath': u'example.py', 'lineno': u'2', 'funcname': u'<module>'}]\n    assert parsed_tb.to_string() == _tb_str",
            "def test_parsed_exc_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    _tb_str = u'Traceback (most recent call last):\\n  File \"example.py\", line 2, in <module>\\n    plarp\\nNameError: name \\'plarp\\' is not defined'\n    parsed_tb = ParsedException.from_string(_tb_str)\n    print(parsed_tb)\n    assert parsed_tb.exc_type == 'NameError'\n    assert parsed_tb.exc_msg == \"name 'plarp' is not defined\"\n    assert parsed_tb.frames == [{'source_line': u'plarp', 'filepath': u'example.py', 'lineno': u'2', 'funcname': u'<module>'}]\n    assert parsed_tb.to_string() == _tb_str"
        ]
    },
    {
        "func_name": "test_parsed_exc_nosrcline",
        "original": "def test_parsed_exc_nosrcline():\n    \"\"\"just making sure that everything can be parsed even if there is\n    a line without source and also if the exception has no message\"\"\"\n    _tb_str = u'Traceback (most recent call last):\\n  File \"/home/mahmoud/virtualenvs/chert/bin/chert\", line 9, in <module>\\n    load_entry_point(\\'chert==0.2.1.dev0\\', \\'console_scripts\\', \\'chert\\')()\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 1281, in main\\n    ch.process()\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 741, in process\\n    self.load()\\n  File \"<boltons.FunctionBuilder-0>\", line 2, in load\\n  File \"/home/mahmoud/projects/lithoxyl/lithoxyl/logger.py\", line 291, in logged_func\\n    return func_to_log(*a, **kw)\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 775, in load\\n    raise RuntimeError\\nRuntimeError'\n    parsed_tb = ParsedException.from_string(_tb_str)\n    assert parsed_tb.exc_type == 'RuntimeError'\n    assert parsed_tb.exc_msg == ''\n    assert len(parsed_tb.frames) == 6\n    assert parsed_tb.frames[3] == {'source_line': u'', 'filepath': u'<boltons.FunctionBuilder-0>', 'lineno': u'2', 'funcname': u'load'}\n    assert parsed_tb.to_string() == _tb_str",
        "mutated": [
            "def test_parsed_exc_nosrcline():\n    if False:\n        i = 10\n    'just making sure that everything can be parsed even if there is\\n    a line without source and also if the exception has no message'\n    _tb_str = u'Traceback (most recent call last):\\n  File \"/home/mahmoud/virtualenvs/chert/bin/chert\", line 9, in <module>\\n    load_entry_point(\\'chert==0.2.1.dev0\\', \\'console_scripts\\', \\'chert\\')()\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 1281, in main\\n    ch.process()\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 741, in process\\n    self.load()\\n  File \"<boltons.FunctionBuilder-0>\", line 2, in load\\n  File \"/home/mahmoud/projects/lithoxyl/lithoxyl/logger.py\", line 291, in logged_func\\n    return func_to_log(*a, **kw)\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 775, in load\\n    raise RuntimeError\\nRuntimeError'\n    parsed_tb = ParsedException.from_string(_tb_str)\n    assert parsed_tb.exc_type == 'RuntimeError'\n    assert parsed_tb.exc_msg == ''\n    assert len(parsed_tb.frames) == 6\n    assert parsed_tb.frames[3] == {'source_line': u'', 'filepath': u'<boltons.FunctionBuilder-0>', 'lineno': u'2', 'funcname': u'load'}\n    assert parsed_tb.to_string() == _tb_str",
            "def test_parsed_exc_nosrcline():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'just making sure that everything can be parsed even if there is\\n    a line without source and also if the exception has no message'\n    _tb_str = u'Traceback (most recent call last):\\n  File \"/home/mahmoud/virtualenvs/chert/bin/chert\", line 9, in <module>\\n    load_entry_point(\\'chert==0.2.1.dev0\\', \\'console_scripts\\', \\'chert\\')()\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 1281, in main\\n    ch.process()\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 741, in process\\n    self.load()\\n  File \"<boltons.FunctionBuilder-0>\", line 2, in load\\n  File \"/home/mahmoud/projects/lithoxyl/lithoxyl/logger.py\", line 291, in logged_func\\n    return func_to_log(*a, **kw)\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 775, in load\\n    raise RuntimeError\\nRuntimeError'\n    parsed_tb = ParsedException.from_string(_tb_str)\n    assert parsed_tb.exc_type == 'RuntimeError'\n    assert parsed_tb.exc_msg == ''\n    assert len(parsed_tb.frames) == 6\n    assert parsed_tb.frames[3] == {'source_line': u'', 'filepath': u'<boltons.FunctionBuilder-0>', 'lineno': u'2', 'funcname': u'load'}\n    assert parsed_tb.to_string() == _tb_str",
            "def test_parsed_exc_nosrcline():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'just making sure that everything can be parsed even if there is\\n    a line without source and also if the exception has no message'\n    _tb_str = u'Traceback (most recent call last):\\n  File \"/home/mahmoud/virtualenvs/chert/bin/chert\", line 9, in <module>\\n    load_entry_point(\\'chert==0.2.1.dev0\\', \\'console_scripts\\', \\'chert\\')()\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 1281, in main\\n    ch.process()\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 741, in process\\n    self.load()\\n  File \"<boltons.FunctionBuilder-0>\", line 2, in load\\n  File \"/home/mahmoud/projects/lithoxyl/lithoxyl/logger.py\", line 291, in logged_func\\n    return func_to_log(*a, **kw)\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 775, in load\\n    raise RuntimeError\\nRuntimeError'\n    parsed_tb = ParsedException.from_string(_tb_str)\n    assert parsed_tb.exc_type == 'RuntimeError'\n    assert parsed_tb.exc_msg == ''\n    assert len(parsed_tb.frames) == 6\n    assert parsed_tb.frames[3] == {'source_line': u'', 'filepath': u'<boltons.FunctionBuilder-0>', 'lineno': u'2', 'funcname': u'load'}\n    assert parsed_tb.to_string() == _tb_str",
            "def test_parsed_exc_nosrcline():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'just making sure that everything can be parsed even if there is\\n    a line without source and also if the exception has no message'\n    _tb_str = u'Traceback (most recent call last):\\n  File \"/home/mahmoud/virtualenvs/chert/bin/chert\", line 9, in <module>\\n    load_entry_point(\\'chert==0.2.1.dev0\\', \\'console_scripts\\', \\'chert\\')()\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 1281, in main\\n    ch.process()\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 741, in process\\n    self.load()\\n  File \"<boltons.FunctionBuilder-0>\", line 2, in load\\n  File \"/home/mahmoud/projects/lithoxyl/lithoxyl/logger.py\", line 291, in logged_func\\n    return func_to_log(*a, **kw)\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 775, in load\\n    raise RuntimeError\\nRuntimeError'\n    parsed_tb = ParsedException.from_string(_tb_str)\n    assert parsed_tb.exc_type == 'RuntimeError'\n    assert parsed_tb.exc_msg == ''\n    assert len(parsed_tb.frames) == 6\n    assert parsed_tb.frames[3] == {'source_line': u'', 'filepath': u'<boltons.FunctionBuilder-0>', 'lineno': u'2', 'funcname': u'load'}\n    assert parsed_tb.to_string() == _tb_str",
            "def test_parsed_exc_nosrcline():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'just making sure that everything can be parsed even if there is\\n    a line without source and also if the exception has no message'\n    _tb_str = u'Traceback (most recent call last):\\n  File \"/home/mahmoud/virtualenvs/chert/bin/chert\", line 9, in <module>\\n    load_entry_point(\\'chert==0.2.1.dev0\\', \\'console_scripts\\', \\'chert\\')()\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 1281, in main\\n    ch.process()\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 741, in process\\n    self.load()\\n  File \"<boltons.FunctionBuilder-0>\", line 2, in load\\n  File \"/home/mahmoud/projects/lithoxyl/lithoxyl/logger.py\", line 291, in logged_func\\n    return func_to_log(*a, **kw)\\n  File \"/home/mahmoud/projects/chert/chert/core.py\", line 775, in load\\n    raise RuntimeError\\nRuntimeError'\n    parsed_tb = ParsedException.from_string(_tb_str)\n    assert parsed_tb.exc_type == 'RuntimeError'\n    assert parsed_tb.exc_msg == ''\n    assert len(parsed_tb.frames) == 6\n    assert parsed_tb.frames[3] == {'source_line': u'', 'filepath': u'<boltons.FunctionBuilder-0>', 'lineno': u'2', 'funcname': u'load'}\n    assert parsed_tb.to_string() == _tb_str"
        ]
    },
    {
        "func_name": "test_parsed_exc_with_anchor",
        "original": "def test_parsed_exc_with_anchor():\n    \"\"\"parse a traceback with anchor lines beneath source lines\"\"\"\n    _tb_str = u'Traceback (most recent call last):\\n  File \"main.py\", line 3, in <module>\\n    print(add(1, \"two\"))\\n          ^^^^^^^^^^^^^\\n  File \"add.py\", line 2, in add\\n    return a + b\\n           ~~^~~\\nTypeError: unsupported operand type(s) for +: \\'int\\' and \\'str\\''\n    parsed_tb = ParsedException.from_string(_tb_str)\n    assert parsed_tb.exc_type == 'TypeError'\n    assert parsed_tb.exc_msg == \"unsupported operand type(s) for +: 'int' and 'str'\"\n    assert parsed_tb.frames == [{'source_line': u'print(add(1, \"two\"))', 'filepath': u'main.py', 'lineno': u'3', 'funcname': u'<module>'}, {'source_line': u'return a + b', 'filepath': u'add.py', 'lineno': u'2', 'funcname': u'add'}]\n    _tb_str_lines = _tb_str.splitlines()\n    _tb_str_without_anchor = '\\n'.join(_tb_str_lines[:3] + _tb_str_lines[4:6] + _tb_str_lines[7:])\n    assert parsed_tb.to_string() == _tb_str_without_anchor",
        "mutated": [
            "def test_parsed_exc_with_anchor():\n    if False:\n        i = 10\n    'parse a traceback with anchor lines beneath source lines'\n    _tb_str = u'Traceback (most recent call last):\\n  File \"main.py\", line 3, in <module>\\n    print(add(1, \"two\"))\\n          ^^^^^^^^^^^^^\\n  File \"add.py\", line 2, in add\\n    return a + b\\n           ~~^~~\\nTypeError: unsupported operand type(s) for +: \\'int\\' and \\'str\\''\n    parsed_tb = ParsedException.from_string(_tb_str)\n    assert parsed_tb.exc_type == 'TypeError'\n    assert parsed_tb.exc_msg == \"unsupported operand type(s) for +: 'int' and 'str'\"\n    assert parsed_tb.frames == [{'source_line': u'print(add(1, \"two\"))', 'filepath': u'main.py', 'lineno': u'3', 'funcname': u'<module>'}, {'source_line': u'return a + b', 'filepath': u'add.py', 'lineno': u'2', 'funcname': u'add'}]\n    _tb_str_lines = _tb_str.splitlines()\n    _tb_str_without_anchor = '\\n'.join(_tb_str_lines[:3] + _tb_str_lines[4:6] + _tb_str_lines[7:])\n    assert parsed_tb.to_string() == _tb_str_without_anchor",
            "def test_parsed_exc_with_anchor():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'parse a traceback with anchor lines beneath source lines'\n    _tb_str = u'Traceback (most recent call last):\\n  File \"main.py\", line 3, in <module>\\n    print(add(1, \"two\"))\\n          ^^^^^^^^^^^^^\\n  File \"add.py\", line 2, in add\\n    return a + b\\n           ~~^~~\\nTypeError: unsupported operand type(s) for +: \\'int\\' and \\'str\\''\n    parsed_tb = ParsedException.from_string(_tb_str)\n    assert parsed_tb.exc_type == 'TypeError'\n    assert parsed_tb.exc_msg == \"unsupported operand type(s) for +: 'int' and 'str'\"\n    assert parsed_tb.frames == [{'source_line': u'print(add(1, \"two\"))', 'filepath': u'main.py', 'lineno': u'3', 'funcname': u'<module>'}, {'source_line': u'return a + b', 'filepath': u'add.py', 'lineno': u'2', 'funcname': u'add'}]\n    _tb_str_lines = _tb_str.splitlines()\n    _tb_str_without_anchor = '\\n'.join(_tb_str_lines[:3] + _tb_str_lines[4:6] + _tb_str_lines[7:])\n    assert parsed_tb.to_string() == _tb_str_without_anchor",
            "def test_parsed_exc_with_anchor():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'parse a traceback with anchor lines beneath source lines'\n    _tb_str = u'Traceback (most recent call last):\\n  File \"main.py\", line 3, in <module>\\n    print(add(1, \"two\"))\\n          ^^^^^^^^^^^^^\\n  File \"add.py\", line 2, in add\\n    return a + b\\n           ~~^~~\\nTypeError: unsupported operand type(s) for +: \\'int\\' and \\'str\\''\n    parsed_tb = ParsedException.from_string(_tb_str)\n    assert parsed_tb.exc_type == 'TypeError'\n    assert parsed_tb.exc_msg == \"unsupported operand type(s) for +: 'int' and 'str'\"\n    assert parsed_tb.frames == [{'source_line': u'print(add(1, \"two\"))', 'filepath': u'main.py', 'lineno': u'3', 'funcname': u'<module>'}, {'source_line': u'return a + b', 'filepath': u'add.py', 'lineno': u'2', 'funcname': u'add'}]\n    _tb_str_lines = _tb_str.splitlines()\n    _tb_str_without_anchor = '\\n'.join(_tb_str_lines[:3] + _tb_str_lines[4:6] + _tb_str_lines[7:])\n    assert parsed_tb.to_string() == _tb_str_without_anchor",
            "def test_parsed_exc_with_anchor():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'parse a traceback with anchor lines beneath source lines'\n    _tb_str = u'Traceback (most recent call last):\\n  File \"main.py\", line 3, in <module>\\n    print(add(1, \"two\"))\\n          ^^^^^^^^^^^^^\\n  File \"add.py\", line 2, in add\\n    return a + b\\n           ~~^~~\\nTypeError: unsupported operand type(s) for +: \\'int\\' and \\'str\\''\n    parsed_tb = ParsedException.from_string(_tb_str)\n    assert parsed_tb.exc_type == 'TypeError'\n    assert parsed_tb.exc_msg == \"unsupported operand type(s) for +: 'int' and 'str'\"\n    assert parsed_tb.frames == [{'source_line': u'print(add(1, \"two\"))', 'filepath': u'main.py', 'lineno': u'3', 'funcname': u'<module>'}, {'source_line': u'return a + b', 'filepath': u'add.py', 'lineno': u'2', 'funcname': u'add'}]\n    _tb_str_lines = _tb_str.splitlines()\n    _tb_str_without_anchor = '\\n'.join(_tb_str_lines[:3] + _tb_str_lines[4:6] + _tb_str_lines[7:])\n    assert parsed_tb.to_string() == _tb_str_without_anchor",
            "def test_parsed_exc_with_anchor():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'parse a traceback with anchor lines beneath source lines'\n    _tb_str = u'Traceback (most recent call last):\\n  File \"main.py\", line 3, in <module>\\n    print(add(1, \"two\"))\\n          ^^^^^^^^^^^^^\\n  File \"add.py\", line 2, in add\\n    return a + b\\n           ~~^~~\\nTypeError: unsupported operand type(s) for +: \\'int\\' and \\'str\\''\n    parsed_tb = ParsedException.from_string(_tb_str)\n    assert parsed_tb.exc_type == 'TypeError'\n    assert parsed_tb.exc_msg == \"unsupported operand type(s) for +: 'int' and 'str'\"\n    assert parsed_tb.frames == [{'source_line': u'print(add(1, \"two\"))', 'filepath': u'main.py', 'lineno': u'3', 'funcname': u'<module>'}, {'source_line': u'return a + b', 'filepath': u'add.py', 'lineno': u'2', 'funcname': u'add'}]\n    _tb_str_lines = _tb_str.splitlines()\n    _tb_str_without_anchor = '\\n'.join(_tb_str_lines[:3] + _tb_str_lines[4:6] + _tb_str_lines[7:])\n    assert parsed_tb.to_string() == _tb_str_without_anchor"
        ]
    }
]