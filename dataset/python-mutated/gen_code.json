[
    {
        "func_name": "get_name",
        "original": "def get_name(proto):\n    name = proto.replace(' *', '* ').split()[1].split('(')[0]\n    name = name.replace('*', '')\n    if name == '':\n        raise ValueError(proto + 'gave empty name')\n    return name",
        "mutated": [
            "def get_name(proto):\n    if False:\n        i = 10\n    name = proto.replace(' *', '* ').split()[1].split('(')[0]\n    name = name.replace('*', '')\n    if name == '':\n        raise ValueError(proto + 'gave empty name')\n    return name",
            "def get_name(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    name = proto.replace(' *', '* ').split()[1].split('(')[0]\n    name = name.replace('*', '')\n    if name == '':\n        raise ValueError(proto + 'gave empty name')\n    return name",
            "def get_name(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    name = proto.replace(' *', '* ').split()[1].split('(')[0]\n    name = name.replace('*', '')\n    if name == '':\n        raise ValueError(proto + 'gave empty name')\n    return name",
            "def get_name(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    name = proto.replace(' *', '* ').split()[1].split('(')[0]\n    name = name.replace('*', '')\n    if name == '':\n        raise ValueError(proto + 'gave empty name')\n    return name",
            "def get_name(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    name = proto.replace(' *', '* ').split()[1].split('(')[0]\n    name = name.replace('*', '')\n    if name == '':\n        raise ValueError(proto + 'gave empty name')\n    return name"
        ]
    },
    {
        "func_name": "get_return_type",
        "original": "def get_return_type(proto):\n    import re\n    paramregex = re.compile('(\\\\w+ ?\\\\*?).*')\n    outputs = paramregex.findall(proto)\n    assert len(outputs) == 1\n    return outputs[0].replace(' ', '')",
        "mutated": [
            "def get_return_type(proto):\n    if False:\n        i = 10\n    import re\n    paramregex = re.compile('(\\\\w+ ?\\\\*?).*')\n    outputs = paramregex.findall(proto)\n    assert len(outputs) == 1\n    return outputs[0].replace(' ', '')",
            "def get_return_type(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    import re\n    paramregex = re.compile('(\\\\w+ ?\\\\*?).*')\n    outputs = paramregex.findall(proto)\n    assert len(outputs) == 1\n    return outputs[0].replace(' ', '')",
            "def get_return_type(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    import re\n    paramregex = re.compile('(\\\\w+ ?\\\\*?).*')\n    outputs = paramregex.findall(proto)\n    assert len(outputs) == 1\n    return outputs[0].replace(' ', '')",
            "def get_return_type(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    import re\n    paramregex = re.compile('(\\\\w+ ?\\\\*?).*')\n    outputs = paramregex.findall(proto)\n    assert len(outputs) == 1\n    return outputs[0].replace(' ', '')",
            "def get_return_type(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    import re\n    paramregex = re.compile('(\\\\w+ ?\\\\*?).*')\n    outputs = paramregex.findall(proto)\n    assert len(outputs) == 1\n    return outputs[0].replace(' ', '')"
        ]
    },
    {
        "func_name": "split_type",
        "original": "def split_type(arg):\n    \"\"\" arg = 'foo *name' \n        return ['foo*', 'name'] \"\"\"\n    l = arg.split()\n    type_arg = {}\n    type_arg['type'] = ' '.join(l[:-1])\n    type_arg['name'] = l[-1]\n    if type_arg['name'].startswith('*'):\n        type_arg['type'] += '*'\n        type_arg['name'] = type_arg['name'][1:]\n    if type_arg['type'].endswith(' *'):\n        type_arg['type'] = type_arg['type'].replace(' *', '*')\n    if type_arg['type'].startswith('const '):\n        type_arg['type'] = type_arg['type'].replace('const ', '')\n    return type_arg",
        "mutated": [
            "def split_type(arg):\n    if False:\n        i = 10\n    \" arg = 'foo *name' \\n        return ['foo*', 'name'] \"\n    l = arg.split()\n    type_arg = {}\n    type_arg['type'] = ' '.join(l[:-1])\n    type_arg['name'] = l[-1]\n    if type_arg['name'].startswith('*'):\n        type_arg['type'] += '*'\n        type_arg['name'] = type_arg['name'][1:]\n    if type_arg['type'].endswith(' *'):\n        type_arg['type'] = type_arg['type'].replace(' *', '*')\n    if type_arg['type'].startswith('const '):\n        type_arg['type'] = type_arg['type'].replace('const ', '')\n    return type_arg",
            "def split_type(arg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \" arg = 'foo *name' \\n        return ['foo*', 'name'] \"\n    l = arg.split()\n    type_arg = {}\n    type_arg['type'] = ' '.join(l[:-1])\n    type_arg['name'] = l[-1]\n    if type_arg['name'].startswith('*'):\n        type_arg['type'] += '*'\n        type_arg['name'] = type_arg['name'][1:]\n    if type_arg['type'].endswith(' *'):\n        type_arg['type'] = type_arg['type'].replace(' *', '*')\n    if type_arg['type'].startswith('const '):\n        type_arg['type'] = type_arg['type'].replace('const ', '')\n    return type_arg",
            "def split_type(arg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \" arg = 'foo *name' \\n        return ['foo*', 'name'] \"\n    l = arg.split()\n    type_arg = {}\n    type_arg['type'] = ' '.join(l[:-1])\n    type_arg['name'] = l[-1]\n    if type_arg['name'].startswith('*'):\n        type_arg['type'] += '*'\n        type_arg['name'] = type_arg['name'][1:]\n    if type_arg['type'].endswith(' *'):\n        type_arg['type'] = type_arg['type'].replace(' *', '*')\n    if type_arg['type'].startswith('const '):\n        type_arg['type'] = type_arg['type'].replace('const ', '')\n    return type_arg",
            "def split_type(arg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \" arg = 'foo *name' \\n        return ['foo*', 'name'] \"\n    l = arg.split()\n    type_arg = {}\n    type_arg['type'] = ' '.join(l[:-1])\n    type_arg['name'] = l[-1]\n    if type_arg['name'].startswith('*'):\n        type_arg['type'] += '*'\n        type_arg['name'] = type_arg['name'][1:]\n    if type_arg['type'].endswith(' *'):\n        type_arg['type'] = type_arg['type'].replace(' *', '*')\n    if type_arg['type'].startswith('const '):\n        type_arg['type'] = type_arg['type'].replace('const ', '')\n    return type_arg",
            "def split_type(arg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \" arg = 'foo *name' \\n        return ['foo*', 'name'] \"\n    l = arg.split()\n    type_arg = {}\n    type_arg['type'] = ' '.join(l[:-1])\n    type_arg['name'] = l[-1]\n    if type_arg['name'].startswith('*'):\n        type_arg['type'] += '*'\n        type_arg['name'] = type_arg['name'][1:]\n    if type_arg['type'].endswith(' *'):\n        type_arg['type'] = type_arg['type'].replace(' *', '*')\n    if type_arg['type'].startswith('const '):\n        type_arg['type'] = type_arg['type'].replace('const ', '')\n    return type_arg"
        ]
    },
    {
        "func_name": "get_params",
        "original": "def get_params(proto):\n    \"\"\" get the list of parameters from a function prototype\n    example: proto = \"int main (int argc, char ** argv)\"\n    returns: ['int argc', 'char ** argv']\n    \"\"\"\n    import re\n    paramregex = re.compile('.*\\\\((.*)\\\\);')\n    a = paramregex.findall(proto)[0].split(', ')\n    return a",
        "mutated": [
            "def get_params(proto):\n    if False:\n        i = 10\n    ' get the list of parameters from a function prototype\\n    example: proto = \"int main (int argc, char ** argv)\"\\n    returns: [\\'int argc\\', \\'char ** argv\\']\\n    '\n    import re\n    paramregex = re.compile('.*\\\\((.*)\\\\);')\n    a = paramregex.findall(proto)[0].split(', ')\n    return a",
            "def get_params(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' get the list of parameters from a function prototype\\n    example: proto = \"int main (int argc, char ** argv)\"\\n    returns: [\\'int argc\\', \\'char ** argv\\']\\n    '\n    import re\n    paramregex = re.compile('.*\\\\((.*)\\\\);')\n    a = paramregex.findall(proto)[0].split(', ')\n    return a",
            "def get_params(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' get the list of parameters from a function prototype\\n    example: proto = \"int main (int argc, char ** argv)\"\\n    returns: [\\'int argc\\', \\'char ** argv\\']\\n    '\n    import re\n    paramregex = re.compile('.*\\\\((.*)\\\\);')\n    a = paramregex.findall(proto)[0].split(', ')\n    return a",
            "def get_params(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' get the list of parameters from a function prototype\\n    example: proto = \"int main (int argc, char ** argv)\"\\n    returns: [\\'int argc\\', \\'char ** argv\\']\\n    '\n    import re\n    paramregex = re.compile('.*\\\\((.*)\\\\);')\n    a = paramregex.findall(proto)[0].split(', ')\n    return a",
            "def get_params(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' get the list of parameters from a function prototype\\n    example: proto = \"int main (int argc, char ** argv)\"\\n    returns: [\\'int argc\\', \\'char ** argv\\']\\n    '\n    import re\n    paramregex = re.compile('.*\\\\((.*)\\\\);')\n    a = paramregex.findall(proto)[0].split(', ')\n    return a"
        ]
    },
    {
        "func_name": "get_input_params",
        "original": "def get_input_params(proto):\n    a = get_params(proto)\n    return [i.replace('const ', '') for i in a if i.startswith('const ') or i.startswith('uint_t ') or i.startswith('smpl_t ')]",
        "mutated": [
            "def get_input_params(proto):\n    if False:\n        i = 10\n    a = get_params(proto)\n    return [i.replace('const ', '') for i in a if i.startswith('const ') or i.startswith('uint_t ') or i.startswith('smpl_t ')]",
            "def get_input_params(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    a = get_params(proto)\n    return [i.replace('const ', '') for i in a if i.startswith('const ') or i.startswith('uint_t ') or i.startswith('smpl_t ')]",
            "def get_input_params(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    a = get_params(proto)\n    return [i.replace('const ', '') for i in a if i.startswith('const ') or i.startswith('uint_t ') or i.startswith('smpl_t ')]",
            "def get_input_params(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    a = get_params(proto)\n    return [i.replace('const ', '') for i in a if i.startswith('const ') or i.startswith('uint_t ') or i.startswith('smpl_t ')]",
            "def get_input_params(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    a = get_params(proto)\n    return [i.replace('const ', '') for i in a if i.startswith('const ') or i.startswith('uint_t ') or i.startswith('smpl_t ')]"
        ]
    },
    {
        "func_name": "get_output_params",
        "original": "def get_output_params(proto):\n    a = get_params(proto)\n    return [i for i in a if not i.startswith('const ')][1:]",
        "mutated": [
            "def get_output_params(proto):\n    if False:\n        i = 10\n    a = get_params(proto)\n    return [i for i in a if not i.startswith('const ')][1:]",
            "def get_output_params(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    a = get_params(proto)\n    return [i for i in a if not i.startswith('const ')][1:]",
            "def get_output_params(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    a = get_params(proto)\n    return [i for i in a if not i.startswith('const ')][1:]",
            "def get_output_params(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    a = get_params(proto)\n    return [i for i in a if not i.startswith('const ')][1:]",
            "def get_output_params(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    a = get_params(proto)\n    return [i for i in a if not i.startswith('const ')][1:]"
        ]
    },
    {
        "func_name": "get_params_types_names",
        "original": "def get_params_types_names(proto):\n    \"\"\" get the list of parameters from a function prototype\n    example: proto = \"int main (int argc, char ** argv)\"\n    returns: [['int', 'argc'], ['char **','argv']]\n    \"\"\"\n    a = list(map(split_type, get_params(proto)))\n    return a",
        "mutated": [
            "def get_params_types_names(proto):\n    if False:\n        i = 10\n    ' get the list of parameters from a function prototype\\n    example: proto = \"int main (int argc, char ** argv)\"\\n    returns: [[\\'int\\', \\'argc\\'], [\\'char **\\',\\'argv\\']]\\n    '\n    a = list(map(split_type, get_params(proto)))\n    return a",
            "def get_params_types_names(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' get the list of parameters from a function prototype\\n    example: proto = \"int main (int argc, char ** argv)\"\\n    returns: [[\\'int\\', \\'argc\\'], [\\'char **\\',\\'argv\\']]\\n    '\n    a = list(map(split_type, get_params(proto)))\n    return a",
            "def get_params_types_names(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' get the list of parameters from a function prototype\\n    example: proto = \"int main (int argc, char ** argv)\"\\n    returns: [[\\'int\\', \\'argc\\'], [\\'char **\\',\\'argv\\']]\\n    '\n    a = list(map(split_type, get_params(proto)))\n    return a",
            "def get_params_types_names(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' get the list of parameters from a function prototype\\n    example: proto = \"int main (int argc, char ** argv)\"\\n    returns: [[\\'int\\', \\'argc\\'], [\\'char **\\',\\'argv\\']]\\n    '\n    a = list(map(split_type, get_params(proto)))\n    return a",
            "def get_params_types_names(proto):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' get the list of parameters from a function prototype\\n    example: proto = \"int main (int argc, char ** argv)\"\\n    returns: [[\\'int\\', \\'argc\\'], [\\'char **\\',\\'argv\\']]\\n    '\n    a = list(map(split_type, get_params(proto)))\n    return a"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, prototypes, usedouble=False):\n    if usedouble:\n        pyargparse_chars['smpl_t'] = 'd'\n    self.prototypes = prototypes\n    self.shortname = prototypes['shortname']\n    self.longname = prototypes['longname']\n    self.new_proto = prototypes['new'][0]\n    self.del_proto = prototypes['del'][0]\n    self.do_proto = prototypes['do'][0]\n    self.input_params = get_params_types_names(self.new_proto)\n    self.input_params_list = '; '.join(get_input_params(self.new_proto))\n    self.outputs = get_params_types_names(self.do_proto)[2:]\n    self.do_inputs = [get_params_types_names(self.do_proto)[1]]\n    self.do_outputs = get_params_types_names(self.do_proto)[2:]\n    struct_output_str = ['PyObject *{0[name]}; {1} c_{0[name]}'.format(i, i['type'][:-1]) for i in self.do_outputs]\n    if len(self.prototypes['rdo']):\n        rdo_outputs = get_params_types_names(prototypes['rdo'][0])[2:]\n        struct_output_str += ['PyObject *{0[name]}; {1} c_{0[name]}'.format(i, i['type'][:-1]) for i in rdo_outputs]\n        self.outputs += rdo_outputs\n    self.struct_outputs = ';\\n    '.join(struct_output_str)",
        "mutated": [
            "def __init__(self, prototypes, usedouble=False):\n    if False:\n        i = 10\n    if usedouble:\n        pyargparse_chars['smpl_t'] = 'd'\n    self.prototypes = prototypes\n    self.shortname = prototypes['shortname']\n    self.longname = prototypes['longname']\n    self.new_proto = prototypes['new'][0]\n    self.del_proto = prototypes['del'][0]\n    self.do_proto = prototypes['do'][0]\n    self.input_params = get_params_types_names(self.new_proto)\n    self.input_params_list = '; '.join(get_input_params(self.new_proto))\n    self.outputs = get_params_types_names(self.do_proto)[2:]\n    self.do_inputs = [get_params_types_names(self.do_proto)[1]]\n    self.do_outputs = get_params_types_names(self.do_proto)[2:]\n    struct_output_str = ['PyObject *{0[name]}; {1} c_{0[name]}'.format(i, i['type'][:-1]) for i in self.do_outputs]\n    if len(self.prototypes['rdo']):\n        rdo_outputs = get_params_types_names(prototypes['rdo'][0])[2:]\n        struct_output_str += ['PyObject *{0[name]}; {1} c_{0[name]}'.format(i, i['type'][:-1]) for i in rdo_outputs]\n        self.outputs += rdo_outputs\n    self.struct_outputs = ';\\n    '.join(struct_output_str)",
            "def __init__(self, prototypes, usedouble=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if usedouble:\n        pyargparse_chars['smpl_t'] = 'd'\n    self.prototypes = prototypes\n    self.shortname = prototypes['shortname']\n    self.longname = prototypes['longname']\n    self.new_proto = prototypes['new'][0]\n    self.del_proto = prototypes['del'][0]\n    self.do_proto = prototypes['do'][0]\n    self.input_params = get_params_types_names(self.new_proto)\n    self.input_params_list = '; '.join(get_input_params(self.new_proto))\n    self.outputs = get_params_types_names(self.do_proto)[2:]\n    self.do_inputs = [get_params_types_names(self.do_proto)[1]]\n    self.do_outputs = get_params_types_names(self.do_proto)[2:]\n    struct_output_str = ['PyObject *{0[name]}; {1} c_{0[name]}'.format(i, i['type'][:-1]) for i in self.do_outputs]\n    if len(self.prototypes['rdo']):\n        rdo_outputs = get_params_types_names(prototypes['rdo'][0])[2:]\n        struct_output_str += ['PyObject *{0[name]}; {1} c_{0[name]}'.format(i, i['type'][:-1]) for i in rdo_outputs]\n        self.outputs += rdo_outputs\n    self.struct_outputs = ';\\n    '.join(struct_output_str)",
            "def __init__(self, prototypes, usedouble=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if usedouble:\n        pyargparse_chars['smpl_t'] = 'd'\n    self.prototypes = prototypes\n    self.shortname = prototypes['shortname']\n    self.longname = prototypes['longname']\n    self.new_proto = prototypes['new'][0]\n    self.del_proto = prototypes['del'][0]\n    self.do_proto = prototypes['do'][0]\n    self.input_params = get_params_types_names(self.new_proto)\n    self.input_params_list = '; '.join(get_input_params(self.new_proto))\n    self.outputs = get_params_types_names(self.do_proto)[2:]\n    self.do_inputs = [get_params_types_names(self.do_proto)[1]]\n    self.do_outputs = get_params_types_names(self.do_proto)[2:]\n    struct_output_str = ['PyObject *{0[name]}; {1} c_{0[name]}'.format(i, i['type'][:-1]) for i in self.do_outputs]\n    if len(self.prototypes['rdo']):\n        rdo_outputs = get_params_types_names(prototypes['rdo'][0])[2:]\n        struct_output_str += ['PyObject *{0[name]}; {1} c_{0[name]}'.format(i, i['type'][:-1]) for i in rdo_outputs]\n        self.outputs += rdo_outputs\n    self.struct_outputs = ';\\n    '.join(struct_output_str)",
            "def __init__(self, prototypes, usedouble=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if usedouble:\n        pyargparse_chars['smpl_t'] = 'd'\n    self.prototypes = prototypes\n    self.shortname = prototypes['shortname']\n    self.longname = prototypes['longname']\n    self.new_proto = prototypes['new'][0]\n    self.del_proto = prototypes['del'][0]\n    self.do_proto = prototypes['do'][0]\n    self.input_params = get_params_types_names(self.new_proto)\n    self.input_params_list = '; '.join(get_input_params(self.new_proto))\n    self.outputs = get_params_types_names(self.do_proto)[2:]\n    self.do_inputs = [get_params_types_names(self.do_proto)[1]]\n    self.do_outputs = get_params_types_names(self.do_proto)[2:]\n    struct_output_str = ['PyObject *{0[name]}; {1} c_{0[name]}'.format(i, i['type'][:-1]) for i in self.do_outputs]\n    if len(self.prototypes['rdo']):\n        rdo_outputs = get_params_types_names(prototypes['rdo'][0])[2:]\n        struct_output_str += ['PyObject *{0[name]}; {1} c_{0[name]}'.format(i, i['type'][:-1]) for i in rdo_outputs]\n        self.outputs += rdo_outputs\n    self.struct_outputs = ';\\n    '.join(struct_output_str)",
            "def __init__(self, prototypes, usedouble=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if usedouble:\n        pyargparse_chars['smpl_t'] = 'd'\n    self.prototypes = prototypes\n    self.shortname = prototypes['shortname']\n    self.longname = prototypes['longname']\n    self.new_proto = prototypes['new'][0]\n    self.del_proto = prototypes['del'][0]\n    self.do_proto = prototypes['do'][0]\n    self.input_params = get_params_types_names(self.new_proto)\n    self.input_params_list = '; '.join(get_input_params(self.new_proto))\n    self.outputs = get_params_types_names(self.do_proto)[2:]\n    self.do_inputs = [get_params_types_names(self.do_proto)[1]]\n    self.do_outputs = get_params_types_names(self.do_proto)[2:]\n    struct_output_str = ['PyObject *{0[name]}; {1} c_{0[name]}'.format(i, i['type'][:-1]) for i in self.do_outputs]\n    if len(self.prototypes['rdo']):\n        rdo_outputs = get_params_types_names(prototypes['rdo'][0])[2:]\n        struct_output_str += ['PyObject *{0[name]}; {1} c_{0[name]}'.format(i, i['type'][:-1]) for i in rdo_outputs]\n        self.outputs += rdo_outputs\n    self.struct_outputs = ';\\n    '.join(struct_output_str)"
        ]
    },
    {
        "func_name": "gen_code",
        "original": "def gen_code(self):\n    out = ''\n    try:\n        out += self.gen_struct()\n        out += self.gen_doc()\n        out += self.gen_new()\n        out += self.gen_init()\n        out += self.gen_del()\n        out += self.gen_do()\n        if len(self.prototypes['rdo']):\n            self.do_proto = self.prototypes['rdo'][0]\n            self.do_inputs = [get_params_types_names(self.do_proto)[1]]\n            self.do_outputs = get_params_types_names(self.do_proto)[2:]\n            out += self.gen_do(method='rdo')\n        out += self.gen_memberdef()\n        out += self.gen_set()\n        out += self.gen_get()\n        out += self.gen_methodef()\n        out += self.gen_typeobject()\n    except Exception as e:\n        print('Failed generating code for', self.shortname)\n        raise\n    return out",
        "mutated": [
            "def gen_code(self):\n    if False:\n        i = 10\n    out = ''\n    try:\n        out += self.gen_struct()\n        out += self.gen_doc()\n        out += self.gen_new()\n        out += self.gen_init()\n        out += self.gen_del()\n        out += self.gen_do()\n        if len(self.prototypes['rdo']):\n            self.do_proto = self.prototypes['rdo'][0]\n            self.do_inputs = [get_params_types_names(self.do_proto)[1]]\n            self.do_outputs = get_params_types_names(self.do_proto)[2:]\n            out += self.gen_do(method='rdo')\n        out += self.gen_memberdef()\n        out += self.gen_set()\n        out += self.gen_get()\n        out += self.gen_methodef()\n        out += self.gen_typeobject()\n    except Exception as e:\n        print('Failed generating code for', self.shortname)\n        raise\n    return out",
            "def gen_code(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    out = ''\n    try:\n        out += self.gen_struct()\n        out += self.gen_doc()\n        out += self.gen_new()\n        out += self.gen_init()\n        out += self.gen_del()\n        out += self.gen_do()\n        if len(self.prototypes['rdo']):\n            self.do_proto = self.prototypes['rdo'][0]\n            self.do_inputs = [get_params_types_names(self.do_proto)[1]]\n            self.do_outputs = get_params_types_names(self.do_proto)[2:]\n            out += self.gen_do(method='rdo')\n        out += self.gen_memberdef()\n        out += self.gen_set()\n        out += self.gen_get()\n        out += self.gen_methodef()\n        out += self.gen_typeobject()\n    except Exception as e:\n        print('Failed generating code for', self.shortname)\n        raise\n    return out",
            "def gen_code(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    out = ''\n    try:\n        out += self.gen_struct()\n        out += self.gen_doc()\n        out += self.gen_new()\n        out += self.gen_init()\n        out += self.gen_del()\n        out += self.gen_do()\n        if len(self.prototypes['rdo']):\n            self.do_proto = self.prototypes['rdo'][0]\n            self.do_inputs = [get_params_types_names(self.do_proto)[1]]\n            self.do_outputs = get_params_types_names(self.do_proto)[2:]\n            out += self.gen_do(method='rdo')\n        out += self.gen_memberdef()\n        out += self.gen_set()\n        out += self.gen_get()\n        out += self.gen_methodef()\n        out += self.gen_typeobject()\n    except Exception as e:\n        print('Failed generating code for', self.shortname)\n        raise\n    return out",
            "def gen_code(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    out = ''\n    try:\n        out += self.gen_struct()\n        out += self.gen_doc()\n        out += self.gen_new()\n        out += self.gen_init()\n        out += self.gen_del()\n        out += self.gen_do()\n        if len(self.prototypes['rdo']):\n            self.do_proto = self.prototypes['rdo'][0]\n            self.do_inputs = [get_params_types_names(self.do_proto)[1]]\n            self.do_outputs = get_params_types_names(self.do_proto)[2:]\n            out += self.gen_do(method='rdo')\n        out += self.gen_memberdef()\n        out += self.gen_set()\n        out += self.gen_get()\n        out += self.gen_methodef()\n        out += self.gen_typeobject()\n    except Exception as e:\n        print('Failed generating code for', self.shortname)\n        raise\n    return out",
            "def gen_code(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    out = ''\n    try:\n        out += self.gen_struct()\n        out += self.gen_doc()\n        out += self.gen_new()\n        out += self.gen_init()\n        out += self.gen_del()\n        out += self.gen_do()\n        if len(self.prototypes['rdo']):\n            self.do_proto = self.prototypes['rdo'][0]\n            self.do_inputs = [get_params_types_names(self.do_proto)[1]]\n            self.do_outputs = get_params_types_names(self.do_proto)[2:]\n            out += self.gen_do(method='rdo')\n        out += self.gen_memberdef()\n        out += self.gen_set()\n        out += self.gen_get()\n        out += self.gen_methodef()\n        out += self.gen_typeobject()\n    except Exception as e:\n        print('Failed generating code for', self.shortname)\n        raise\n    return out"
        ]
    },
    {
        "func_name": "gen_struct",
        "original": "def gen_struct(self):\n    out = '\\n// {shortname} structure\\ntypedef struct{{\\n    PyObject_HEAD\\n    // pointer to aubio object\\n    {longname} *o;\\n    // input parameters\\n    {input_params_list};\\n    // do input vectors\\n    {do_inputs_list};\\n    // output results\\n    {struct_outputs};\\n}} Py_{shortname};\\n'\n    do_inputs_list = '; '.join(get_input_params(self.do_proto)).replace('fvec_t *', 'fvec_t').replace('fmat_t *', 'fmat_t').replace('cvec_t *', 'cvec_t')\n    return out.format(do_inputs_list=do_inputs_list, **self.__dict__)",
        "mutated": [
            "def gen_struct(self):\n    if False:\n        i = 10\n    out = '\\n// {shortname} structure\\ntypedef struct{{\\n    PyObject_HEAD\\n    // pointer to aubio object\\n    {longname} *o;\\n    // input parameters\\n    {input_params_list};\\n    // do input vectors\\n    {do_inputs_list};\\n    // output results\\n    {struct_outputs};\\n}} Py_{shortname};\\n'\n    do_inputs_list = '; '.join(get_input_params(self.do_proto)).replace('fvec_t *', 'fvec_t').replace('fmat_t *', 'fmat_t').replace('cvec_t *', 'cvec_t')\n    return out.format(do_inputs_list=do_inputs_list, **self.__dict__)",
            "def gen_struct(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    out = '\\n// {shortname} structure\\ntypedef struct{{\\n    PyObject_HEAD\\n    // pointer to aubio object\\n    {longname} *o;\\n    // input parameters\\n    {input_params_list};\\n    // do input vectors\\n    {do_inputs_list};\\n    // output results\\n    {struct_outputs};\\n}} Py_{shortname};\\n'\n    do_inputs_list = '; '.join(get_input_params(self.do_proto)).replace('fvec_t *', 'fvec_t').replace('fmat_t *', 'fmat_t').replace('cvec_t *', 'cvec_t')\n    return out.format(do_inputs_list=do_inputs_list, **self.__dict__)",
            "def gen_struct(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    out = '\\n// {shortname} structure\\ntypedef struct{{\\n    PyObject_HEAD\\n    // pointer to aubio object\\n    {longname} *o;\\n    // input parameters\\n    {input_params_list};\\n    // do input vectors\\n    {do_inputs_list};\\n    // output results\\n    {struct_outputs};\\n}} Py_{shortname};\\n'\n    do_inputs_list = '; '.join(get_input_params(self.do_proto)).replace('fvec_t *', 'fvec_t').replace('fmat_t *', 'fmat_t').replace('cvec_t *', 'cvec_t')\n    return out.format(do_inputs_list=do_inputs_list, **self.__dict__)",
            "def gen_struct(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    out = '\\n// {shortname} structure\\ntypedef struct{{\\n    PyObject_HEAD\\n    // pointer to aubio object\\n    {longname} *o;\\n    // input parameters\\n    {input_params_list};\\n    // do input vectors\\n    {do_inputs_list};\\n    // output results\\n    {struct_outputs};\\n}} Py_{shortname};\\n'\n    do_inputs_list = '; '.join(get_input_params(self.do_proto)).replace('fvec_t *', 'fvec_t').replace('fmat_t *', 'fmat_t').replace('cvec_t *', 'cvec_t')\n    return out.format(do_inputs_list=do_inputs_list, **self.__dict__)",
            "def gen_struct(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    out = '\\n// {shortname} structure\\ntypedef struct{{\\n    PyObject_HEAD\\n    // pointer to aubio object\\n    {longname} *o;\\n    // input parameters\\n    {input_params_list};\\n    // do input vectors\\n    {do_inputs_list};\\n    // output results\\n    {struct_outputs};\\n}} Py_{shortname};\\n'\n    do_inputs_list = '; '.join(get_input_params(self.do_proto)).replace('fvec_t *', 'fvec_t').replace('fmat_t *', 'fmat_t').replace('cvec_t *', 'cvec_t')\n    return out.format(do_inputs_list=do_inputs_list, **self.__dict__)"
        ]
    },
    {
        "func_name": "gen_doc",
        "original": "def gen_doc(self):\n    sig = []\n    for p in self.input_params:\n        name = p['name']\n        defval = aubiodefvalue[name].replace('\"', '\\\\\"')\n        sig.append('{name}={defval}'.format(defval=defval, name=name))\n    out = '\\n#ifndef PYAUBIO_{shortname}_doc\\n#define PYAUBIO_{shortname}_doc \"{shortname}({sig})\"\\n#endif /* PYAUBIO_{shortname}_doc */\\n\\nstatic char Py_{shortname}_doc[] = \"\"\\nPYAUBIO_{shortname}_doc\\n\"\";\\n'\n    return out.format(sig=', '.join(sig), **self.__dict__)",
        "mutated": [
            "def gen_doc(self):\n    if False:\n        i = 10\n    sig = []\n    for p in self.input_params:\n        name = p['name']\n        defval = aubiodefvalue[name].replace('\"', '\\\\\"')\n        sig.append('{name}={defval}'.format(defval=defval, name=name))\n    out = '\\n#ifndef PYAUBIO_{shortname}_doc\\n#define PYAUBIO_{shortname}_doc \"{shortname}({sig})\"\\n#endif /* PYAUBIO_{shortname}_doc */\\n\\nstatic char Py_{shortname}_doc[] = \"\"\\nPYAUBIO_{shortname}_doc\\n\"\";\\n'\n    return out.format(sig=', '.join(sig), **self.__dict__)",
            "def gen_doc(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    sig = []\n    for p in self.input_params:\n        name = p['name']\n        defval = aubiodefvalue[name].replace('\"', '\\\\\"')\n        sig.append('{name}={defval}'.format(defval=defval, name=name))\n    out = '\\n#ifndef PYAUBIO_{shortname}_doc\\n#define PYAUBIO_{shortname}_doc \"{shortname}({sig})\"\\n#endif /* PYAUBIO_{shortname}_doc */\\n\\nstatic char Py_{shortname}_doc[] = \"\"\\nPYAUBIO_{shortname}_doc\\n\"\";\\n'\n    return out.format(sig=', '.join(sig), **self.__dict__)",
            "def gen_doc(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    sig = []\n    for p in self.input_params:\n        name = p['name']\n        defval = aubiodefvalue[name].replace('\"', '\\\\\"')\n        sig.append('{name}={defval}'.format(defval=defval, name=name))\n    out = '\\n#ifndef PYAUBIO_{shortname}_doc\\n#define PYAUBIO_{shortname}_doc \"{shortname}({sig})\"\\n#endif /* PYAUBIO_{shortname}_doc */\\n\\nstatic char Py_{shortname}_doc[] = \"\"\\nPYAUBIO_{shortname}_doc\\n\"\";\\n'\n    return out.format(sig=', '.join(sig), **self.__dict__)",
            "def gen_doc(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    sig = []\n    for p in self.input_params:\n        name = p['name']\n        defval = aubiodefvalue[name].replace('\"', '\\\\\"')\n        sig.append('{name}={defval}'.format(defval=defval, name=name))\n    out = '\\n#ifndef PYAUBIO_{shortname}_doc\\n#define PYAUBIO_{shortname}_doc \"{shortname}({sig})\"\\n#endif /* PYAUBIO_{shortname}_doc */\\n\\nstatic char Py_{shortname}_doc[] = \"\"\\nPYAUBIO_{shortname}_doc\\n\"\";\\n'\n    return out.format(sig=', '.join(sig), **self.__dict__)",
            "def gen_doc(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    sig = []\n    for p in self.input_params:\n        name = p['name']\n        defval = aubiodefvalue[name].replace('\"', '\\\\\"')\n        sig.append('{name}={defval}'.format(defval=defval, name=name))\n    out = '\\n#ifndef PYAUBIO_{shortname}_doc\\n#define PYAUBIO_{shortname}_doc \"{shortname}({sig})\"\\n#endif /* PYAUBIO_{shortname}_doc */\\n\\nstatic char Py_{shortname}_doc[] = \"\"\\nPYAUBIO_{shortname}_doc\\n\"\";\\n'\n    return out.format(sig=', '.join(sig), **self.__dict__)"
        ]
    },
    {
        "func_name": "gen_new",
        "original": "def gen_new(self):\n    out = '\\n// new {shortname}\\nstatic PyObject *\\nPy_{shortname}_new (PyTypeObject * pytype, PyObject * args, PyObject * kwds)\\n{{\\n    Py_{shortname} *self;\\n'.format(**self.__dict__)\n    params = self.input_params\n    for p in params:\n        out += '\\n    {type} {name} = {defval};'.format(defval=param_init[p['type']], **p)\n    plist = ', '.join(['\"%s\"' % p['name'] for p in params])\n    out += '\\n    static char *kwlist[] = {{ {plist}, NULL }};'.format(plist=plist)\n    argchars = ''.join([pyargparse_chars[p['type']] for p in params])\n    arglist = ', '.join(['&%s' % p['name'] for p in params])\n    out += '\\n    if (!PyArg_ParseTupleAndKeywords (args, kwds, \"|{argchars}\", kwlist,\\n              {arglist})) {{\\n        return NULL;\\n    }}\\n'.format(argchars=argchars, arglist=arglist)\n    out += '\\n    self = (Py_{shortname} *) pytype->tp_alloc (pytype, 0);\\n    if (self == NULL) {{\\n        return NULL;\\n    }}\\n'.format(**self.__dict__)\n    params = self.input_params\n    for p in params:\n        out += self.check_valid(p)\n    out += '\\n    return (PyObject *)self;\\n}\\n'\n    return out",
        "mutated": [
            "def gen_new(self):\n    if False:\n        i = 10\n    out = '\\n// new {shortname}\\nstatic PyObject *\\nPy_{shortname}_new (PyTypeObject * pytype, PyObject * args, PyObject * kwds)\\n{{\\n    Py_{shortname} *self;\\n'.format(**self.__dict__)\n    params = self.input_params\n    for p in params:\n        out += '\\n    {type} {name} = {defval};'.format(defval=param_init[p['type']], **p)\n    plist = ', '.join(['\"%s\"' % p['name'] for p in params])\n    out += '\\n    static char *kwlist[] = {{ {plist}, NULL }};'.format(plist=plist)\n    argchars = ''.join([pyargparse_chars[p['type']] for p in params])\n    arglist = ', '.join(['&%s' % p['name'] for p in params])\n    out += '\\n    if (!PyArg_ParseTupleAndKeywords (args, kwds, \"|{argchars}\", kwlist,\\n              {arglist})) {{\\n        return NULL;\\n    }}\\n'.format(argchars=argchars, arglist=arglist)\n    out += '\\n    self = (Py_{shortname} *) pytype->tp_alloc (pytype, 0);\\n    if (self == NULL) {{\\n        return NULL;\\n    }}\\n'.format(**self.__dict__)\n    params = self.input_params\n    for p in params:\n        out += self.check_valid(p)\n    out += '\\n    return (PyObject *)self;\\n}\\n'\n    return out",
            "def gen_new(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    out = '\\n// new {shortname}\\nstatic PyObject *\\nPy_{shortname}_new (PyTypeObject * pytype, PyObject * args, PyObject * kwds)\\n{{\\n    Py_{shortname} *self;\\n'.format(**self.__dict__)\n    params = self.input_params\n    for p in params:\n        out += '\\n    {type} {name} = {defval};'.format(defval=param_init[p['type']], **p)\n    plist = ', '.join(['\"%s\"' % p['name'] for p in params])\n    out += '\\n    static char *kwlist[] = {{ {plist}, NULL }};'.format(plist=plist)\n    argchars = ''.join([pyargparse_chars[p['type']] for p in params])\n    arglist = ', '.join(['&%s' % p['name'] for p in params])\n    out += '\\n    if (!PyArg_ParseTupleAndKeywords (args, kwds, \"|{argchars}\", kwlist,\\n              {arglist})) {{\\n        return NULL;\\n    }}\\n'.format(argchars=argchars, arglist=arglist)\n    out += '\\n    self = (Py_{shortname} *) pytype->tp_alloc (pytype, 0);\\n    if (self == NULL) {{\\n        return NULL;\\n    }}\\n'.format(**self.__dict__)\n    params = self.input_params\n    for p in params:\n        out += self.check_valid(p)\n    out += '\\n    return (PyObject *)self;\\n}\\n'\n    return out",
            "def gen_new(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    out = '\\n// new {shortname}\\nstatic PyObject *\\nPy_{shortname}_new (PyTypeObject * pytype, PyObject * args, PyObject * kwds)\\n{{\\n    Py_{shortname} *self;\\n'.format(**self.__dict__)\n    params = self.input_params\n    for p in params:\n        out += '\\n    {type} {name} = {defval};'.format(defval=param_init[p['type']], **p)\n    plist = ', '.join(['\"%s\"' % p['name'] for p in params])\n    out += '\\n    static char *kwlist[] = {{ {plist}, NULL }};'.format(plist=plist)\n    argchars = ''.join([pyargparse_chars[p['type']] for p in params])\n    arglist = ', '.join(['&%s' % p['name'] for p in params])\n    out += '\\n    if (!PyArg_ParseTupleAndKeywords (args, kwds, \"|{argchars}\", kwlist,\\n              {arglist})) {{\\n        return NULL;\\n    }}\\n'.format(argchars=argchars, arglist=arglist)\n    out += '\\n    self = (Py_{shortname} *) pytype->tp_alloc (pytype, 0);\\n    if (self == NULL) {{\\n        return NULL;\\n    }}\\n'.format(**self.__dict__)\n    params = self.input_params\n    for p in params:\n        out += self.check_valid(p)\n    out += '\\n    return (PyObject *)self;\\n}\\n'\n    return out",
            "def gen_new(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    out = '\\n// new {shortname}\\nstatic PyObject *\\nPy_{shortname}_new (PyTypeObject * pytype, PyObject * args, PyObject * kwds)\\n{{\\n    Py_{shortname} *self;\\n'.format(**self.__dict__)\n    params = self.input_params\n    for p in params:\n        out += '\\n    {type} {name} = {defval};'.format(defval=param_init[p['type']], **p)\n    plist = ', '.join(['\"%s\"' % p['name'] for p in params])\n    out += '\\n    static char *kwlist[] = {{ {plist}, NULL }};'.format(plist=plist)\n    argchars = ''.join([pyargparse_chars[p['type']] for p in params])\n    arglist = ', '.join(['&%s' % p['name'] for p in params])\n    out += '\\n    if (!PyArg_ParseTupleAndKeywords (args, kwds, \"|{argchars}\", kwlist,\\n              {arglist})) {{\\n        return NULL;\\n    }}\\n'.format(argchars=argchars, arglist=arglist)\n    out += '\\n    self = (Py_{shortname} *) pytype->tp_alloc (pytype, 0);\\n    if (self == NULL) {{\\n        return NULL;\\n    }}\\n'.format(**self.__dict__)\n    params = self.input_params\n    for p in params:\n        out += self.check_valid(p)\n    out += '\\n    return (PyObject *)self;\\n}\\n'\n    return out",
            "def gen_new(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    out = '\\n// new {shortname}\\nstatic PyObject *\\nPy_{shortname}_new (PyTypeObject * pytype, PyObject * args, PyObject * kwds)\\n{{\\n    Py_{shortname} *self;\\n'.format(**self.__dict__)\n    params = self.input_params\n    for p in params:\n        out += '\\n    {type} {name} = {defval};'.format(defval=param_init[p['type']], **p)\n    plist = ', '.join(['\"%s\"' % p['name'] for p in params])\n    out += '\\n    static char *kwlist[] = {{ {plist}, NULL }};'.format(plist=plist)\n    argchars = ''.join([pyargparse_chars[p['type']] for p in params])\n    arglist = ', '.join(['&%s' % p['name'] for p in params])\n    out += '\\n    if (!PyArg_ParseTupleAndKeywords (args, kwds, \"|{argchars}\", kwlist,\\n              {arglist})) {{\\n        return NULL;\\n    }}\\n'.format(argchars=argchars, arglist=arglist)\n    out += '\\n    self = (Py_{shortname} *) pytype->tp_alloc (pytype, 0);\\n    if (self == NULL) {{\\n        return NULL;\\n    }}\\n'.format(**self.__dict__)\n    params = self.input_params\n    for p in params:\n        out += self.check_valid(p)\n    out += '\\n    return (PyObject *)self;\\n}\\n'\n    return out"
        ]
    },
    {
        "func_name": "check_valid",
        "original": "def check_valid(self, p):\n    if p['type'] == 'uint_t':\n        return self.check_valid_uint(p)\n    if p['type'] == 'char_t*':\n        return self.check_valid_char(p)\n    if p['type'] == 'smpl_t':\n        return self.check_valid_smpl(p)\n    else:\n        print('ERROR, no idea how to check %s for validity' % p['type'])",
        "mutated": [
            "def check_valid(self, p):\n    if False:\n        i = 10\n    if p['type'] == 'uint_t':\n        return self.check_valid_uint(p)\n    if p['type'] == 'char_t*':\n        return self.check_valid_char(p)\n    if p['type'] == 'smpl_t':\n        return self.check_valid_smpl(p)\n    else:\n        print('ERROR, no idea how to check %s for validity' % p['type'])",
            "def check_valid(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if p['type'] == 'uint_t':\n        return self.check_valid_uint(p)\n    if p['type'] == 'char_t*':\n        return self.check_valid_char(p)\n    if p['type'] == 'smpl_t':\n        return self.check_valid_smpl(p)\n    else:\n        print('ERROR, no idea how to check %s for validity' % p['type'])",
            "def check_valid(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if p['type'] == 'uint_t':\n        return self.check_valid_uint(p)\n    if p['type'] == 'char_t*':\n        return self.check_valid_char(p)\n    if p['type'] == 'smpl_t':\n        return self.check_valid_smpl(p)\n    else:\n        print('ERROR, no idea how to check %s for validity' % p['type'])",
            "def check_valid(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if p['type'] == 'uint_t':\n        return self.check_valid_uint(p)\n    if p['type'] == 'char_t*':\n        return self.check_valid_char(p)\n    if p['type'] == 'smpl_t':\n        return self.check_valid_smpl(p)\n    else:\n        print('ERROR, no idea how to check %s for validity' % p['type'])",
            "def check_valid(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if p['type'] == 'uint_t':\n        return self.check_valid_uint(p)\n    if p['type'] == 'char_t*':\n        return self.check_valid_char(p)\n    if p['type'] == 'smpl_t':\n        return self.check_valid_smpl(p)\n    else:\n        print('ERROR, no idea how to check %s for validity' % p['type'])"
        ]
    },
    {
        "func_name": "check_valid_uint",
        "original": "def check_valid_uint(self, p):\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ((sint_t){name} > 0) {{\\n        self->{name} = {name};\\n    }} else if ((sint_t){name} < 0) {{\\n        PyErr_SetString (PyExc_ValueError, \"can not use negative value for {name}\");\\n        return NULL;\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)",
        "mutated": [
            "def check_valid_uint(self, p):\n    if False:\n        i = 10\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ((sint_t){name} > 0) {{\\n        self->{name} = {name};\\n    }} else if ((sint_t){name} < 0) {{\\n        PyErr_SetString (PyExc_ValueError, \"can not use negative value for {name}\");\\n        return NULL;\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)",
            "def check_valid_uint(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ((sint_t){name} > 0) {{\\n        self->{name} = {name};\\n    }} else if ((sint_t){name} < 0) {{\\n        PyErr_SetString (PyExc_ValueError, \"can not use negative value for {name}\");\\n        return NULL;\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)",
            "def check_valid_uint(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ((sint_t){name} > 0) {{\\n        self->{name} = {name};\\n    }} else if ((sint_t){name} < 0) {{\\n        PyErr_SetString (PyExc_ValueError, \"can not use negative value for {name}\");\\n        return NULL;\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)",
            "def check_valid_uint(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ((sint_t){name} > 0) {{\\n        self->{name} = {name};\\n    }} else if ((sint_t){name} < 0) {{\\n        PyErr_SetString (PyExc_ValueError, \"can not use negative value for {name}\");\\n        return NULL;\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)",
            "def check_valid_uint(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ((sint_t){name} > 0) {{\\n        self->{name} = {name};\\n    }} else if ((sint_t){name} < 0) {{\\n        PyErr_SetString (PyExc_ValueError, \"can not use negative value for {name}\");\\n        return NULL;\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)"
        ]
    },
    {
        "func_name": "check_valid_char",
        "original": "def check_valid_char(self, p):\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ({name} != NULL) {{\\n        self->{name} = {name};\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)",
        "mutated": [
            "def check_valid_char(self, p):\n    if False:\n        i = 10\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ({name} != NULL) {{\\n        self->{name} = {name};\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)",
            "def check_valid_char(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ({name} != NULL) {{\\n        self->{name} = {name};\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)",
            "def check_valid_char(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ({name} != NULL) {{\\n        self->{name} = {name};\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)",
            "def check_valid_char(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ({name} != NULL) {{\\n        self->{name} = {name};\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)",
            "def check_valid_char(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ({name} != NULL) {{\\n        self->{name} = {name};\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)"
        ]
    },
    {
        "func_name": "check_valid_smpl",
        "original": "def check_valid_smpl(self, p):\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ({name} != 0.) {{\\n        self->{name} = {name};\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)",
        "mutated": [
            "def check_valid_smpl(self, p):\n    if False:\n        i = 10\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ({name} != 0.) {{\\n        self->{name} = {name};\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)",
            "def check_valid_smpl(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ({name} != 0.) {{\\n        self->{name} = {name};\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)",
            "def check_valid_smpl(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ({name} != 0.) {{\\n        self->{name} = {name};\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)",
            "def check_valid_smpl(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ({name} != 0.) {{\\n        self->{name} = {name};\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)",
            "def check_valid_smpl(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    name = p['name']\n    return '\\n    self->{name} = {defval};\\n    if ({name} != 0.) {{\\n        self->{name} = {name};\\n    }}\\n'.format(defval=aubiodefvalue[name], name=name)"
        ]
    },
    {
        "func_name": "gen_init",
        "original": "def gen_init(self):\n    out = '\\n// init {shortname}\\nstatic int\\nPy_{shortname}_init (Py_{shortname} * self, PyObject * args, PyObject * kwds)\\n{{\\n'.format(**self.__dict__)\n    new_name = get_name(self.new_proto)\n    new_params = ', '.join(['self->%s' % s['name'] for s in self.input_params])\n    out += '\\n  self->o = {new_name}({new_params});\\n'.format(new_name=new_name, new_params=new_params)\n    paramchars = '%s'\n    paramvals = 'self->method'\n    out += '\\n  // return -1 and set error string on failure\\n  if (self->o == NULL) {{\\n    PyErr_Format (PyExc_RuntimeError, \"failed creating {shortname}\");\\n    return -1;\\n  }}\\n'.format(paramchars=paramchars, paramvals=paramvals, **self.__dict__)\n    output_create = ''\n    for o in self.outputs:\n        output_create += '\\n  self->{name} = {create_fn}({output_size});'.format(name=o['name'], create_fn=newfromtype_fn[o['type']], output_size=objoutsize[self.shortname])\n    out += '\\n  // TODO get internal params after actual object creation?\\n'\n    out += '\\n  // create outputs{output_create}\\n'.format(output_create=output_create)\n    out += '\\n  return 0;\\n}\\n'\n    return out",
        "mutated": [
            "def gen_init(self):\n    if False:\n        i = 10\n    out = '\\n// init {shortname}\\nstatic int\\nPy_{shortname}_init (Py_{shortname} * self, PyObject * args, PyObject * kwds)\\n{{\\n'.format(**self.__dict__)\n    new_name = get_name(self.new_proto)\n    new_params = ', '.join(['self->%s' % s['name'] for s in self.input_params])\n    out += '\\n  self->o = {new_name}({new_params});\\n'.format(new_name=new_name, new_params=new_params)\n    paramchars = '%s'\n    paramvals = 'self->method'\n    out += '\\n  // return -1 and set error string on failure\\n  if (self->o == NULL) {{\\n    PyErr_Format (PyExc_RuntimeError, \"failed creating {shortname}\");\\n    return -1;\\n  }}\\n'.format(paramchars=paramchars, paramvals=paramvals, **self.__dict__)\n    output_create = ''\n    for o in self.outputs:\n        output_create += '\\n  self->{name} = {create_fn}({output_size});'.format(name=o['name'], create_fn=newfromtype_fn[o['type']], output_size=objoutsize[self.shortname])\n    out += '\\n  // TODO get internal params after actual object creation?\\n'\n    out += '\\n  // create outputs{output_create}\\n'.format(output_create=output_create)\n    out += '\\n  return 0;\\n}\\n'\n    return out",
            "def gen_init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    out = '\\n// init {shortname}\\nstatic int\\nPy_{shortname}_init (Py_{shortname} * self, PyObject * args, PyObject * kwds)\\n{{\\n'.format(**self.__dict__)\n    new_name = get_name(self.new_proto)\n    new_params = ', '.join(['self->%s' % s['name'] for s in self.input_params])\n    out += '\\n  self->o = {new_name}({new_params});\\n'.format(new_name=new_name, new_params=new_params)\n    paramchars = '%s'\n    paramvals = 'self->method'\n    out += '\\n  // return -1 and set error string on failure\\n  if (self->o == NULL) {{\\n    PyErr_Format (PyExc_RuntimeError, \"failed creating {shortname}\");\\n    return -1;\\n  }}\\n'.format(paramchars=paramchars, paramvals=paramvals, **self.__dict__)\n    output_create = ''\n    for o in self.outputs:\n        output_create += '\\n  self->{name} = {create_fn}({output_size});'.format(name=o['name'], create_fn=newfromtype_fn[o['type']], output_size=objoutsize[self.shortname])\n    out += '\\n  // TODO get internal params after actual object creation?\\n'\n    out += '\\n  // create outputs{output_create}\\n'.format(output_create=output_create)\n    out += '\\n  return 0;\\n}\\n'\n    return out",
            "def gen_init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    out = '\\n// init {shortname}\\nstatic int\\nPy_{shortname}_init (Py_{shortname} * self, PyObject * args, PyObject * kwds)\\n{{\\n'.format(**self.__dict__)\n    new_name = get_name(self.new_proto)\n    new_params = ', '.join(['self->%s' % s['name'] for s in self.input_params])\n    out += '\\n  self->o = {new_name}({new_params});\\n'.format(new_name=new_name, new_params=new_params)\n    paramchars = '%s'\n    paramvals = 'self->method'\n    out += '\\n  // return -1 and set error string on failure\\n  if (self->o == NULL) {{\\n    PyErr_Format (PyExc_RuntimeError, \"failed creating {shortname}\");\\n    return -1;\\n  }}\\n'.format(paramchars=paramchars, paramvals=paramvals, **self.__dict__)\n    output_create = ''\n    for o in self.outputs:\n        output_create += '\\n  self->{name} = {create_fn}({output_size});'.format(name=o['name'], create_fn=newfromtype_fn[o['type']], output_size=objoutsize[self.shortname])\n    out += '\\n  // TODO get internal params after actual object creation?\\n'\n    out += '\\n  // create outputs{output_create}\\n'.format(output_create=output_create)\n    out += '\\n  return 0;\\n}\\n'\n    return out",
            "def gen_init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    out = '\\n// init {shortname}\\nstatic int\\nPy_{shortname}_init (Py_{shortname} * self, PyObject * args, PyObject * kwds)\\n{{\\n'.format(**self.__dict__)\n    new_name = get_name(self.new_proto)\n    new_params = ', '.join(['self->%s' % s['name'] for s in self.input_params])\n    out += '\\n  self->o = {new_name}({new_params});\\n'.format(new_name=new_name, new_params=new_params)\n    paramchars = '%s'\n    paramvals = 'self->method'\n    out += '\\n  // return -1 and set error string on failure\\n  if (self->o == NULL) {{\\n    PyErr_Format (PyExc_RuntimeError, \"failed creating {shortname}\");\\n    return -1;\\n  }}\\n'.format(paramchars=paramchars, paramvals=paramvals, **self.__dict__)\n    output_create = ''\n    for o in self.outputs:\n        output_create += '\\n  self->{name} = {create_fn}({output_size});'.format(name=o['name'], create_fn=newfromtype_fn[o['type']], output_size=objoutsize[self.shortname])\n    out += '\\n  // TODO get internal params after actual object creation?\\n'\n    out += '\\n  // create outputs{output_create}\\n'.format(output_create=output_create)\n    out += '\\n  return 0;\\n}\\n'\n    return out",
            "def gen_init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    out = '\\n// init {shortname}\\nstatic int\\nPy_{shortname}_init (Py_{shortname} * self, PyObject * args, PyObject * kwds)\\n{{\\n'.format(**self.__dict__)\n    new_name = get_name(self.new_proto)\n    new_params = ', '.join(['self->%s' % s['name'] for s in self.input_params])\n    out += '\\n  self->o = {new_name}({new_params});\\n'.format(new_name=new_name, new_params=new_params)\n    paramchars = '%s'\n    paramvals = 'self->method'\n    out += '\\n  // return -1 and set error string on failure\\n  if (self->o == NULL) {{\\n    PyErr_Format (PyExc_RuntimeError, \"failed creating {shortname}\");\\n    return -1;\\n  }}\\n'.format(paramchars=paramchars, paramvals=paramvals, **self.__dict__)\n    output_create = ''\n    for o in self.outputs:\n        output_create += '\\n  self->{name} = {create_fn}({output_size});'.format(name=o['name'], create_fn=newfromtype_fn[o['type']], output_size=objoutsize[self.shortname])\n    out += '\\n  // TODO get internal params after actual object creation?\\n'\n    out += '\\n  // create outputs{output_create}\\n'.format(output_create=output_create)\n    out += '\\n  return 0;\\n}\\n'\n    return out"
        ]
    },
    {
        "func_name": "gen_memberdef",
        "original": "def gen_memberdef(self):\n    out = '\\nstatic PyMemberDef Py_{shortname}_members[] = {{\\n'.format(**self.__dict__)\n    for p in get_params_types_names(self.new_proto):\n        tmp = '  {{\"{name}\", {ttype}, offsetof (Py_{shortname}, {name}), READONLY, \"TODO documentation\"}},\\n'\n        pytype = member_types[p['type']]\n        out += tmp.format(name=p['name'], ttype=pytype, shortname=self.shortname)\n    out += '  {NULL}, // sentinel\\n};\\n'\n    return out",
        "mutated": [
            "def gen_memberdef(self):\n    if False:\n        i = 10\n    out = '\\nstatic PyMemberDef Py_{shortname}_members[] = {{\\n'.format(**self.__dict__)\n    for p in get_params_types_names(self.new_proto):\n        tmp = '  {{\"{name}\", {ttype}, offsetof (Py_{shortname}, {name}), READONLY, \"TODO documentation\"}},\\n'\n        pytype = member_types[p['type']]\n        out += tmp.format(name=p['name'], ttype=pytype, shortname=self.shortname)\n    out += '  {NULL}, // sentinel\\n};\\n'\n    return out",
            "def gen_memberdef(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    out = '\\nstatic PyMemberDef Py_{shortname}_members[] = {{\\n'.format(**self.__dict__)\n    for p in get_params_types_names(self.new_proto):\n        tmp = '  {{\"{name}\", {ttype}, offsetof (Py_{shortname}, {name}), READONLY, \"TODO documentation\"}},\\n'\n        pytype = member_types[p['type']]\n        out += tmp.format(name=p['name'], ttype=pytype, shortname=self.shortname)\n    out += '  {NULL}, // sentinel\\n};\\n'\n    return out",
            "def gen_memberdef(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    out = '\\nstatic PyMemberDef Py_{shortname}_members[] = {{\\n'.format(**self.__dict__)\n    for p in get_params_types_names(self.new_proto):\n        tmp = '  {{\"{name}\", {ttype}, offsetof (Py_{shortname}, {name}), READONLY, \"TODO documentation\"}},\\n'\n        pytype = member_types[p['type']]\n        out += tmp.format(name=p['name'], ttype=pytype, shortname=self.shortname)\n    out += '  {NULL}, // sentinel\\n};\\n'\n    return out",
            "def gen_memberdef(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    out = '\\nstatic PyMemberDef Py_{shortname}_members[] = {{\\n'.format(**self.__dict__)\n    for p in get_params_types_names(self.new_proto):\n        tmp = '  {{\"{name}\", {ttype}, offsetof (Py_{shortname}, {name}), READONLY, \"TODO documentation\"}},\\n'\n        pytype = member_types[p['type']]\n        out += tmp.format(name=p['name'], ttype=pytype, shortname=self.shortname)\n    out += '  {NULL}, // sentinel\\n};\\n'\n    return out",
            "def gen_memberdef(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    out = '\\nstatic PyMemberDef Py_{shortname}_members[] = {{\\n'.format(**self.__dict__)\n    for p in get_params_types_names(self.new_proto):\n        tmp = '  {{\"{name}\", {ttype}, offsetof (Py_{shortname}, {name}), READONLY, \"TODO documentation\"}},\\n'\n        pytype = member_types[p['type']]\n        out += tmp.format(name=p['name'], ttype=pytype, shortname=self.shortname)\n    out += '  {NULL}, // sentinel\\n};\\n'\n    return out"
        ]
    },
    {
        "func_name": "gen_del",
        "original": "def gen_del(self):\n    out = '\\n// del {shortname}\\nstatic void\\nPy_{shortname}_del  (Py_{shortname} * self, PyObject * unused)\\n{{'.format(**self.__dict__)\n    for input_param in self.do_inputs:\n        if input_param['type'] == 'fmat_t *':\n            out += '\\n  free(self->{0[name]}.data);'.format(input_param)\n    for o in self.outputs:\n        name = o['name']\n        del_out = delfromtype_fn[o['type']]\n        out += '\\n  if (self->{name}) {{\\n    {del_out}(self->{name});\\n  }}'.format(del_out=del_out, name=name)\n    del_fn = get_name(self.del_proto)\n    out += '\\n  if (self->o) {{\\n    {del_fn}(self->o);\\n  }}\\n  Py_TYPE(self)->tp_free((PyObject *) self);\\n}}\\n'.format(del_fn=del_fn)\n    return out",
        "mutated": [
            "def gen_del(self):\n    if False:\n        i = 10\n    out = '\\n// del {shortname}\\nstatic void\\nPy_{shortname}_del  (Py_{shortname} * self, PyObject * unused)\\n{{'.format(**self.__dict__)\n    for input_param in self.do_inputs:\n        if input_param['type'] == 'fmat_t *':\n            out += '\\n  free(self->{0[name]}.data);'.format(input_param)\n    for o in self.outputs:\n        name = o['name']\n        del_out = delfromtype_fn[o['type']]\n        out += '\\n  if (self->{name}) {{\\n    {del_out}(self->{name});\\n  }}'.format(del_out=del_out, name=name)\n    del_fn = get_name(self.del_proto)\n    out += '\\n  if (self->o) {{\\n    {del_fn}(self->o);\\n  }}\\n  Py_TYPE(self)->tp_free((PyObject *) self);\\n}}\\n'.format(del_fn=del_fn)\n    return out",
            "def gen_del(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    out = '\\n// del {shortname}\\nstatic void\\nPy_{shortname}_del  (Py_{shortname} * self, PyObject * unused)\\n{{'.format(**self.__dict__)\n    for input_param in self.do_inputs:\n        if input_param['type'] == 'fmat_t *':\n            out += '\\n  free(self->{0[name]}.data);'.format(input_param)\n    for o in self.outputs:\n        name = o['name']\n        del_out = delfromtype_fn[o['type']]\n        out += '\\n  if (self->{name}) {{\\n    {del_out}(self->{name});\\n  }}'.format(del_out=del_out, name=name)\n    del_fn = get_name(self.del_proto)\n    out += '\\n  if (self->o) {{\\n    {del_fn}(self->o);\\n  }}\\n  Py_TYPE(self)->tp_free((PyObject *) self);\\n}}\\n'.format(del_fn=del_fn)\n    return out",
            "def gen_del(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    out = '\\n// del {shortname}\\nstatic void\\nPy_{shortname}_del  (Py_{shortname} * self, PyObject * unused)\\n{{'.format(**self.__dict__)\n    for input_param in self.do_inputs:\n        if input_param['type'] == 'fmat_t *':\n            out += '\\n  free(self->{0[name]}.data);'.format(input_param)\n    for o in self.outputs:\n        name = o['name']\n        del_out = delfromtype_fn[o['type']]\n        out += '\\n  if (self->{name}) {{\\n    {del_out}(self->{name});\\n  }}'.format(del_out=del_out, name=name)\n    del_fn = get_name(self.del_proto)\n    out += '\\n  if (self->o) {{\\n    {del_fn}(self->o);\\n  }}\\n  Py_TYPE(self)->tp_free((PyObject *) self);\\n}}\\n'.format(del_fn=del_fn)\n    return out",
            "def gen_del(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    out = '\\n// del {shortname}\\nstatic void\\nPy_{shortname}_del  (Py_{shortname} * self, PyObject * unused)\\n{{'.format(**self.__dict__)\n    for input_param in self.do_inputs:\n        if input_param['type'] == 'fmat_t *':\n            out += '\\n  free(self->{0[name]}.data);'.format(input_param)\n    for o in self.outputs:\n        name = o['name']\n        del_out = delfromtype_fn[o['type']]\n        out += '\\n  if (self->{name}) {{\\n    {del_out}(self->{name});\\n  }}'.format(del_out=del_out, name=name)\n    del_fn = get_name(self.del_proto)\n    out += '\\n  if (self->o) {{\\n    {del_fn}(self->o);\\n  }}\\n  Py_TYPE(self)->tp_free((PyObject *) self);\\n}}\\n'.format(del_fn=del_fn)\n    return out",
            "def gen_del(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    out = '\\n// del {shortname}\\nstatic void\\nPy_{shortname}_del  (Py_{shortname} * self, PyObject * unused)\\n{{'.format(**self.__dict__)\n    for input_param in self.do_inputs:\n        if input_param['type'] == 'fmat_t *':\n            out += '\\n  free(self->{0[name]}.data);'.format(input_param)\n    for o in self.outputs:\n        name = o['name']\n        del_out = delfromtype_fn[o['type']]\n        out += '\\n  if (self->{name}) {{\\n    {del_out}(self->{name});\\n  }}'.format(del_out=del_out, name=name)\n    del_fn = get_name(self.del_proto)\n    out += '\\n  if (self->o) {{\\n    {del_fn}(self->o);\\n  }}\\n  Py_TYPE(self)->tp_free((PyObject *) self);\\n}}\\n'.format(del_fn=del_fn)\n    return out"
        ]
    },
    {
        "func_name": "gen_do",
        "original": "def gen_do(self, method='do'):\n    out = '\\n// do {shortname}\\nstatic PyObject*\\nPyaubio_{shortname}_{method}  (Py_{shortname} * self, PyObject * args)\\n{{'.format(method=method, **self.__dict__)\n    input_params = self.do_inputs\n    output_params = self.do_outputs\n    out += '\\n    PyObject *outputs;'\n    for input_param in input_params:\n        out += '\\n    PyObject *py_{0};'.format(input_param['name'])\n    refs = ', '.join(['&py_%s' % p['name'] for p in input_params])\n    pyparamtypes = ''.join([pyargparse_chars[p['type']] for p in input_params])\n    out += '\\n    if (!PyArg_ParseTuple (args, \"{pyparamtypes}\", {refs})) {{\\n        return NULL;\\n    }}'.format(refs=refs, pyparamtypes=pyparamtypes, **self.__dict__)\n    for input_param in input_params:\n        out += '\\n\\n    if (!{pytoaubio}(py_{0[name]}, &(self->{0[name]}))) {{\\n        return NULL;\\n    }}'.format(input_param, pytoaubio=pytoaubio_fn[input_param['type']])\n    if self.shortname in objinputsize:\n        out += '\\n\\n    if (self->{0[name]}.length != {expected_size}) {{\\n        PyErr_Format (PyExc_ValueError,\\n            \"input size of {shortname} should be %d, not %d\",\\n            {expected_size}, self->{0[name]}.length);\\n        return NULL;\\n    }}'.format(input_param, expected_size=objinputsize[self.shortname], **self.__dict__)\n    else:\n        out += '\\n\\n    // TODO: check input sizes'\n    for output_param in output_params:\n        out += '\\n\\n    Py_INCREF(self->{0[name]});\\n    if (!{pytoaubio}(self->{0[name]}, &(self->c_{0[name]}))) {{\\n        return NULL;\\n    }}'.format(output_param, pytoaubio=pytoaubio_fn[output_param['type']])\n    do_fn = get_name(self.do_proto)\n    inputs = ', '.join(['&(self->' + p['name'] + ')' for p in input_params])\n    c_outputs = ', '.join(['&(self->c_%s)' % p['name'] for p in self.do_outputs])\n    outputs = ', '.join(['self->%s' % p['name'] for p in self.do_outputs])\n    out += '\\n\\n    {do_fn}(self->o, {inputs}, {c_outputs});\\n'.format(do_fn=do_fn, inputs=inputs, c_outputs=c_outputs)\n    if len(self.do_outputs) > 1:\n        out += '\\n    outputs = PyTuple_New({:d});'.format(len(self.do_outputs))\n        for (i, p) in enumerate(self.do_outputs):\n            out += '\\n    PyTuple_SetItem( outputs, {i}, self->{p[name]});'.format(i=i, p=p)\n    else:\n        out += '\\n    outputs = self->{p[name]};'.format(p=self.do_outputs[0])\n    out += '\\n\\n    return outputs;\\n}}\\n'.format(outputs=outputs)\n    return out",
        "mutated": [
            "def gen_do(self, method='do'):\n    if False:\n        i = 10\n    out = '\\n// do {shortname}\\nstatic PyObject*\\nPyaubio_{shortname}_{method}  (Py_{shortname} * self, PyObject * args)\\n{{'.format(method=method, **self.__dict__)\n    input_params = self.do_inputs\n    output_params = self.do_outputs\n    out += '\\n    PyObject *outputs;'\n    for input_param in input_params:\n        out += '\\n    PyObject *py_{0};'.format(input_param['name'])\n    refs = ', '.join(['&py_%s' % p['name'] for p in input_params])\n    pyparamtypes = ''.join([pyargparse_chars[p['type']] for p in input_params])\n    out += '\\n    if (!PyArg_ParseTuple (args, \"{pyparamtypes}\", {refs})) {{\\n        return NULL;\\n    }}'.format(refs=refs, pyparamtypes=pyparamtypes, **self.__dict__)\n    for input_param in input_params:\n        out += '\\n\\n    if (!{pytoaubio}(py_{0[name]}, &(self->{0[name]}))) {{\\n        return NULL;\\n    }}'.format(input_param, pytoaubio=pytoaubio_fn[input_param['type']])\n    if self.shortname in objinputsize:\n        out += '\\n\\n    if (self->{0[name]}.length != {expected_size}) {{\\n        PyErr_Format (PyExc_ValueError,\\n            \"input size of {shortname} should be %d, not %d\",\\n            {expected_size}, self->{0[name]}.length);\\n        return NULL;\\n    }}'.format(input_param, expected_size=objinputsize[self.shortname], **self.__dict__)\n    else:\n        out += '\\n\\n    // TODO: check input sizes'\n    for output_param in output_params:\n        out += '\\n\\n    Py_INCREF(self->{0[name]});\\n    if (!{pytoaubio}(self->{0[name]}, &(self->c_{0[name]}))) {{\\n        return NULL;\\n    }}'.format(output_param, pytoaubio=pytoaubio_fn[output_param['type']])\n    do_fn = get_name(self.do_proto)\n    inputs = ', '.join(['&(self->' + p['name'] + ')' for p in input_params])\n    c_outputs = ', '.join(['&(self->c_%s)' % p['name'] for p in self.do_outputs])\n    outputs = ', '.join(['self->%s' % p['name'] for p in self.do_outputs])\n    out += '\\n\\n    {do_fn}(self->o, {inputs}, {c_outputs});\\n'.format(do_fn=do_fn, inputs=inputs, c_outputs=c_outputs)\n    if len(self.do_outputs) > 1:\n        out += '\\n    outputs = PyTuple_New({:d});'.format(len(self.do_outputs))\n        for (i, p) in enumerate(self.do_outputs):\n            out += '\\n    PyTuple_SetItem( outputs, {i}, self->{p[name]});'.format(i=i, p=p)\n    else:\n        out += '\\n    outputs = self->{p[name]};'.format(p=self.do_outputs[0])\n    out += '\\n\\n    return outputs;\\n}}\\n'.format(outputs=outputs)\n    return out",
            "def gen_do(self, method='do'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    out = '\\n// do {shortname}\\nstatic PyObject*\\nPyaubio_{shortname}_{method}  (Py_{shortname} * self, PyObject * args)\\n{{'.format(method=method, **self.__dict__)\n    input_params = self.do_inputs\n    output_params = self.do_outputs\n    out += '\\n    PyObject *outputs;'\n    for input_param in input_params:\n        out += '\\n    PyObject *py_{0};'.format(input_param['name'])\n    refs = ', '.join(['&py_%s' % p['name'] for p in input_params])\n    pyparamtypes = ''.join([pyargparse_chars[p['type']] for p in input_params])\n    out += '\\n    if (!PyArg_ParseTuple (args, \"{pyparamtypes}\", {refs})) {{\\n        return NULL;\\n    }}'.format(refs=refs, pyparamtypes=pyparamtypes, **self.__dict__)\n    for input_param in input_params:\n        out += '\\n\\n    if (!{pytoaubio}(py_{0[name]}, &(self->{0[name]}))) {{\\n        return NULL;\\n    }}'.format(input_param, pytoaubio=pytoaubio_fn[input_param['type']])\n    if self.shortname in objinputsize:\n        out += '\\n\\n    if (self->{0[name]}.length != {expected_size}) {{\\n        PyErr_Format (PyExc_ValueError,\\n            \"input size of {shortname} should be %d, not %d\",\\n            {expected_size}, self->{0[name]}.length);\\n        return NULL;\\n    }}'.format(input_param, expected_size=objinputsize[self.shortname], **self.__dict__)\n    else:\n        out += '\\n\\n    // TODO: check input sizes'\n    for output_param in output_params:\n        out += '\\n\\n    Py_INCREF(self->{0[name]});\\n    if (!{pytoaubio}(self->{0[name]}, &(self->c_{0[name]}))) {{\\n        return NULL;\\n    }}'.format(output_param, pytoaubio=pytoaubio_fn[output_param['type']])\n    do_fn = get_name(self.do_proto)\n    inputs = ', '.join(['&(self->' + p['name'] + ')' for p in input_params])\n    c_outputs = ', '.join(['&(self->c_%s)' % p['name'] for p in self.do_outputs])\n    outputs = ', '.join(['self->%s' % p['name'] for p in self.do_outputs])\n    out += '\\n\\n    {do_fn}(self->o, {inputs}, {c_outputs});\\n'.format(do_fn=do_fn, inputs=inputs, c_outputs=c_outputs)\n    if len(self.do_outputs) > 1:\n        out += '\\n    outputs = PyTuple_New({:d});'.format(len(self.do_outputs))\n        for (i, p) in enumerate(self.do_outputs):\n            out += '\\n    PyTuple_SetItem( outputs, {i}, self->{p[name]});'.format(i=i, p=p)\n    else:\n        out += '\\n    outputs = self->{p[name]};'.format(p=self.do_outputs[0])\n    out += '\\n\\n    return outputs;\\n}}\\n'.format(outputs=outputs)\n    return out",
            "def gen_do(self, method='do'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    out = '\\n// do {shortname}\\nstatic PyObject*\\nPyaubio_{shortname}_{method}  (Py_{shortname} * self, PyObject * args)\\n{{'.format(method=method, **self.__dict__)\n    input_params = self.do_inputs\n    output_params = self.do_outputs\n    out += '\\n    PyObject *outputs;'\n    for input_param in input_params:\n        out += '\\n    PyObject *py_{0};'.format(input_param['name'])\n    refs = ', '.join(['&py_%s' % p['name'] for p in input_params])\n    pyparamtypes = ''.join([pyargparse_chars[p['type']] for p in input_params])\n    out += '\\n    if (!PyArg_ParseTuple (args, \"{pyparamtypes}\", {refs})) {{\\n        return NULL;\\n    }}'.format(refs=refs, pyparamtypes=pyparamtypes, **self.__dict__)\n    for input_param in input_params:\n        out += '\\n\\n    if (!{pytoaubio}(py_{0[name]}, &(self->{0[name]}))) {{\\n        return NULL;\\n    }}'.format(input_param, pytoaubio=pytoaubio_fn[input_param['type']])\n    if self.shortname in objinputsize:\n        out += '\\n\\n    if (self->{0[name]}.length != {expected_size}) {{\\n        PyErr_Format (PyExc_ValueError,\\n            \"input size of {shortname} should be %d, not %d\",\\n            {expected_size}, self->{0[name]}.length);\\n        return NULL;\\n    }}'.format(input_param, expected_size=objinputsize[self.shortname], **self.__dict__)\n    else:\n        out += '\\n\\n    // TODO: check input sizes'\n    for output_param in output_params:\n        out += '\\n\\n    Py_INCREF(self->{0[name]});\\n    if (!{pytoaubio}(self->{0[name]}, &(self->c_{0[name]}))) {{\\n        return NULL;\\n    }}'.format(output_param, pytoaubio=pytoaubio_fn[output_param['type']])\n    do_fn = get_name(self.do_proto)\n    inputs = ', '.join(['&(self->' + p['name'] + ')' for p in input_params])\n    c_outputs = ', '.join(['&(self->c_%s)' % p['name'] for p in self.do_outputs])\n    outputs = ', '.join(['self->%s' % p['name'] for p in self.do_outputs])\n    out += '\\n\\n    {do_fn}(self->o, {inputs}, {c_outputs});\\n'.format(do_fn=do_fn, inputs=inputs, c_outputs=c_outputs)\n    if len(self.do_outputs) > 1:\n        out += '\\n    outputs = PyTuple_New({:d});'.format(len(self.do_outputs))\n        for (i, p) in enumerate(self.do_outputs):\n            out += '\\n    PyTuple_SetItem( outputs, {i}, self->{p[name]});'.format(i=i, p=p)\n    else:\n        out += '\\n    outputs = self->{p[name]};'.format(p=self.do_outputs[0])\n    out += '\\n\\n    return outputs;\\n}}\\n'.format(outputs=outputs)\n    return out",
            "def gen_do(self, method='do'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    out = '\\n// do {shortname}\\nstatic PyObject*\\nPyaubio_{shortname}_{method}  (Py_{shortname} * self, PyObject * args)\\n{{'.format(method=method, **self.__dict__)\n    input_params = self.do_inputs\n    output_params = self.do_outputs\n    out += '\\n    PyObject *outputs;'\n    for input_param in input_params:\n        out += '\\n    PyObject *py_{0};'.format(input_param['name'])\n    refs = ', '.join(['&py_%s' % p['name'] for p in input_params])\n    pyparamtypes = ''.join([pyargparse_chars[p['type']] for p in input_params])\n    out += '\\n    if (!PyArg_ParseTuple (args, \"{pyparamtypes}\", {refs})) {{\\n        return NULL;\\n    }}'.format(refs=refs, pyparamtypes=pyparamtypes, **self.__dict__)\n    for input_param in input_params:\n        out += '\\n\\n    if (!{pytoaubio}(py_{0[name]}, &(self->{0[name]}))) {{\\n        return NULL;\\n    }}'.format(input_param, pytoaubio=pytoaubio_fn[input_param['type']])\n    if self.shortname in objinputsize:\n        out += '\\n\\n    if (self->{0[name]}.length != {expected_size}) {{\\n        PyErr_Format (PyExc_ValueError,\\n            \"input size of {shortname} should be %d, not %d\",\\n            {expected_size}, self->{0[name]}.length);\\n        return NULL;\\n    }}'.format(input_param, expected_size=objinputsize[self.shortname], **self.__dict__)\n    else:\n        out += '\\n\\n    // TODO: check input sizes'\n    for output_param in output_params:\n        out += '\\n\\n    Py_INCREF(self->{0[name]});\\n    if (!{pytoaubio}(self->{0[name]}, &(self->c_{0[name]}))) {{\\n        return NULL;\\n    }}'.format(output_param, pytoaubio=pytoaubio_fn[output_param['type']])\n    do_fn = get_name(self.do_proto)\n    inputs = ', '.join(['&(self->' + p['name'] + ')' for p in input_params])\n    c_outputs = ', '.join(['&(self->c_%s)' % p['name'] for p in self.do_outputs])\n    outputs = ', '.join(['self->%s' % p['name'] for p in self.do_outputs])\n    out += '\\n\\n    {do_fn}(self->o, {inputs}, {c_outputs});\\n'.format(do_fn=do_fn, inputs=inputs, c_outputs=c_outputs)\n    if len(self.do_outputs) > 1:\n        out += '\\n    outputs = PyTuple_New({:d});'.format(len(self.do_outputs))\n        for (i, p) in enumerate(self.do_outputs):\n            out += '\\n    PyTuple_SetItem( outputs, {i}, self->{p[name]});'.format(i=i, p=p)\n    else:\n        out += '\\n    outputs = self->{p[name]};'.format(p=self.do_outputs[0])\n    out += '\\n\\n    return outputs;\\n}}\\n'.format(outputs=outputs)\n    return out",
            "def gen_do(self, method='do'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    out = '\\n// do {shortname}\\nstatic PyObject*\\nPyaubio_{shortname}_{method}  (Py_{shortname} * self, PyObject * args)\\n{{'.format(method=method, **self.__dict__)\n    input_params = self.do_inputs\n    output_params = self.do_outputs\n    out += '\\n    PyObject *outputs;'\n    for input_param in input_params:\n        out += '\\n    PyObject *py_{0};'.format(input_param['name'])\n    refs = ', '.join(['&py_%s' % p['name'] for p in input_params])\n    pyparamtypes = ''.join([pyargparse_chars[p['type']] for p in input_params])\n    out += '\\n    if (!PyArg_ParseTuple (args, \"{pyparamtypes}\", {refs})) {{\\n        return NULL;\\n    }}'.format(refs=refs, pyparamtypes=pyparamtypes, **self.__dict__)\n    for input_param in input_params:\n        out += '\\n\\n    if (!{pytoaubio}(py_{0[name]}, &(self->{0[name]}))) {{\\n        return NULL;\\n    }}'.format(input_param, pytoaubio=pytoaubio_fn[input_param['type']])\n    if self.shortname in objinputsize:\n        out += '\\n\\n    if (self->{0[name]}.length != {expected_size}) {{\\n        PyErr_Format (PyExc_ValueError,\\n            \"input size of {shortname} should be %d, not %d\",\\n            {expected_size}, self->{0[name]}.length);\\n        return NULL;\\n    }}'.format(input_param, expected_size=objinputsize[self.shortname], **self.__dict__)\n    else:\n        out += '\\n\\n    // TODO: check input sizes'\n    for output_param in output_params:\n        out += '\\n\\n    Py_INCREF(self->{0[name]});\\n    if (!{pytoaubio}(self->{0[name]}, &(self->c_{0[name]}))) {{\\n        return NULL;\\n    }}'.format(output_param, pytoaubio=pytoaubio_fn[output_param['type']])\n    do_fn = get_name(self.do_proto)\n    inputs = ', '.join(['&(self->' + p['name'] + ')' for p in input_params])\n    c_outputs = ', '.join(['&(self->c_%s)' % p['name'] for p in self.do_outputs])\n    outputs = ', '.join(['self->%s' % p['name'] for p in self.do_outputs])\n    out += '\\n\\n    {do_fn}(self->o, {inputs}, {c_outputs});\\n'.format(do_fn=do_fn, inputs=inputs, c_outputs=c_outputs)\n    if len(self.do_outputs) > 1:\n        out += '\\n    outputs = PyTuple_New({:d});'.format(len(self.do_outputs))\n        for (i, p) in enumerate(self.do_outputs):\n            out += '\\n    PyTuple_SetItem( outputs, {i}, self->{p[name]});'.format(i=i, p=p)\n    else:\n        out += '\\n    outputs = self->{p[name]};'.format(p=self.do_outputs[0])\n    out += '\\n\\n    return outputs;\\n}}\\n'.format(outputs=outputs)\n    return out"
        ]
    },
    {
        "func_name": "gen_set",
        "original": "def gen_set(self):\n    out = '\\n// {shortname} setters\\n'.format(**self.__dict__)\n    for set_param in self.prototypes['set']:\n        params = get_params_types_names(set_param)[1:]\n        param = self.shortname.split('_set_')[-1]\n        paramdecls = ''.join(['\\n   {0} {1};'.format(p['type'], p['name']) for p in params])\n        method_name = get_name(set_param)\n        param = method_name.split('aubio_' + self.shortname + '_set_')[-1]\n        refs = ', '.join(['&%s' % p['name'] for p in params])\n        paramlist = ', '.join(['%s' % p['name'] for p in params])\n        if len(params):\n            paramlist = ',' + paramlist\n        pyparamtypes = ''.join([pyargparse_chars[p['type']] for p in params])\n        out += '\\nstatic PyObject *\\nPyaubio_{shortname}_set_{param} (Py_{shortname} *self, PyObject *args)\\n{{\\n  uint_t err = 0;\\n  {paramdecls}\\n'.format(param=param, paramdecls=paramdecls, **self.__dict__)\n        if len(refs) and len(pyparamtypes):\n            out += '\\n\\n  if (!PyArg_ParseTuple (args, \"{pyparamtypes}\", {refs})) {{\\n    return NULL;\\n  }}\\n'.format(pyparamtypes=pyparamtypes, refs=refs)\n        out += '\\n  err = aubio_{shortname}_set_{param} (self->o {paramlist});\\n\\n  if (err > 0) {{\\n    if (PyErr_Occurred() == NULL) {{\\n      PyErr_SetString (PyExc_ValueError, \"error running aubio_{shortname}_set_{param}\");\\n    }} else {{\\n      // change the RuntimeError into ValueError\\n      PyObject *type, *value, *traceback;\\n      PyErr_Fetch(&type, &value, &traceback);\\n      Py_XDECREF(type);\\n      type = PyExc_ValueError;\\n      Py_XINCREF(type);\\n      PyErr_Restore(type, value, traceback);\\n    }}\\n    return NULL;\\n  }}\\n  Py_RETURN_NONE;\\n}}\\n'.format(param=param, refs=refs, paramdecls=paramdecls, pyparamtypes=pyparamtypes, paramlist=paramlist, **self.__dict__)\n    return out",
        "mutated": [
            "def gen_set(self):\n    if False:\n        i = 10\n    out = '\\n// {shortname} setters\\n'.format(**self.__dict__)\n    for set_param in self.prototypes['set']:\n        params = get_params_types_names(set_param)[1:]\n        param = self.shortname.split('_set_')[-1]\n        paramdecls = ''.join(['\\n   {0} {1};'.format(p['type'], p['name']) for p in params])\n        method_name = get_name(set_param)\n        param = method_name.split('aubio_' + self.shortname + '_set_')[-1]\n        refs = ', '.join(['&%s' % p['name'] for p in params])\n        paramlist = ', '.join(['%s' % p['name'] for p in params])\n        if len(params):\n            paramlist = ',' + paramlist\n        pyparamtypes = ''.join([pyargparse_chars[p['type']] for p in params])\n        out += '\\nstatic PyObject *\\nPyaubio_{shortname}_set_{param} (Py_{shortname} *self, PyObject *args)\\n{{\\n  uint_t err = 0;\\n  {paramdecls}\\n'.format(param=param, paramdecls=paramdecls, **self.__dict__)\n        if len(refs) and len(pyparamtypes):\n            out += '\\n\\n  if (!PyArg_ParseTuple (args, \"{pyparamtypes}\", {refs})) {{\\n    return NULL;\\n  }}\\n'.format(pyparamtypes=pyparamtypes, refs=refs)\n        out += '\\n  err = aubio_{shortname}_set_{param} (self->o {paramlist});\\n\\n  if (err > 0) {{\\n    if (PyErr_Occurred() == NULL) {{\\n      PyErr_SetString (PyExc_ValueError, \"error running aubio_{shortname}_set_{param}\");\\n    }} else {{\\n      // change the RuntimeError into ValueError\\n      PyObject *type, *value, *traceback;\\n      PyErr_Fetch(&type, &value, &traceback);\\n      Py_XDECREF(type);\\n      type = PyExc_ValueError;\\n      Py_XINCREF(type);\\n      PyErr_Restore(type, value, traceback);\\n    }}\\n    return NULL;\\n  }}\\n  Py_RETURN_NONE;\\n}}\\n'.format(param=param, refs=refs, paramdecls=paramdecls, pyparamtypes=pyparamtypes, paramlist=paramlist, **self.__dict__)\n    return out",
            "def gen_set(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    out = '\\n// {shortname} setters\\n'.format(**self.__dict__)\n    for set_param in self.prototypes['set']:\n        params = get_params_types_names(set_param)[1:]\n        param = self.shortname.split('_set_')[-1]\n        paramdecls = ''.join(['\\n   {0} {1};'.format(p['type'], p['name']) for p in params])\n        method_name = get_name(set_param)\n        param = method_name.split('aubio_' + self.shortname + '_set_')[-1]\n        refs = ', '.join(['&%s' % p['name'] for p in params])\n        paramlist = ', '.join(['%s' % p['name'] for p in params])\n        if len(params):\n            paramlist = ',' + paramlist\n        pyparamtypes = ''.join([pyargparse_chars[p['type']] for p in params])\n        out += '\\nstatic PyObject *\\nPyaubio_{shortname}_set_{param} (Py_{shortname} *self, PyObject *args)\\n{{\\n  uint_t err = 0;\\n  {paramdecls}\\n'.format(param=param, paramdecls=paramdecls, **self.__dict__)\n        if len(refs) and len(pyparamtypes):\n            out += '\\n\\n  if (!PyArg_ParseTuple (args, \"{pyparamtypes}\", {refs})) {{\\n    return NULL;\\n  }}\\n'.format(pyparamtypes=pyparamtypes, refs=refs)\n        out += '\\n  err = aubio_{shortname}_set_{param} (self->o {paramlist});\\n\\n  if (err > 0) {{\\n    if (PyErr_Occurred() == NULL) {{\\n      PyErr_SetString (PyExc_ValueError, \"error running aubio_{shortname}_set_{param}\");\\n    }} else {{\\n      // change the RuntimeError into ValueError\\n      PyObject *type, *value, *traceback;\\n      PyErr_Fetch(&type, &value, &traceback);\\n      Py_XDECREF(type);\\n      type = PyExc_ValueError;\\n      Py_XINCREF(type);\\n      PyErr_Restore(type, value, traceback);\\n    }}\\n    return NULL;\\n  }}\\n  Py_RETURN_NONE;\\n}}\\n'.format(param=param, refs=refs, paramdecls=paramdecls, pyparamtypes=pyparamtypes, paramlist=paramlist, **self.__dict__)\n    return out",
            "def gen_set(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    out = '\\n// {shortname} setters\\n'.format(**self.__dict__)\n    for set_param in self.prototypes['set']:\n        params = get_params_types_names(set_param)[1:]\n        param = self.shortname.split('_set_')[-1]\n        paramdecls = ''.join(['\\n   {0} {1};'.format(p['type'], p['name']) for p in params])\n        method_name = get_name(set_param)\n        param = method_name.split('aubio_' + self.shortname + '_set_')[-1]\n        refs = ', '.join(['&%s' % p['name'] for p in params])\n        paramlist = ', '.join(['%s' % p['name'] for p in params])\n        if len(params):\n            paramlist = ',' + paramlist\n        pyparamtypes = ''.join([pyargparse_chars[p['type']] for p in params])\n        out += '\\nstatic PyObject *\\nPyaubio_{shortname}_set_{param} (Py_{shortname} *self, PyObject *args)\\n{{\\n  uint_t err = 0;\\n  {paramdecls}\\n'.format(param=param, paramdecls=paramdecls, **self.__dict__)\n        if len(refs) and len(pyparamtypes):\n            out += '\\n\\n  if (!PyArg_ParseTuple (args, \"{pyparamtypes}\", {refs})) {{\\n    return NULL;\\n  }}\\n'.format(pyparamtypes=pyparamtypes, refs=refs)\n        out += '\\n  err = aubio_{shortname}_set_{param} (self->o {paramlist});\\n\\n  if (err > 0) {{\\n    if (PyErr_Occurred() == NULL) {{\\n      PyErr_SetString (PyExc_ValueError, \"error running aubio_{shortname}_set_{param}\");\\n    }} else {{\\n      // change the RuntimeError into ValueError\\n      PyObject *type, *value, *traceback;\\n      PyErr_Fetch(&type, &value, &traceback);\\n      Py_XDECREF(type);\\n      type = PyExc_ValueError;\\n      Py_XINCREF(type);\\n      PyErr_Restore(type, value, traceback);\\n    }}\\n    return NULL;\\n  }}\\n  Py_RETURN_NONE;\\n}}\\n'.format(param=param, refs=refs, paramdecls=paramdecls, pyparamtypes=pyparamtypes, paramlist=paramlist, **self.__dict__)\n    return out",
            "def gen_set(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    out = '\\n// {shortname} setters\\n'.format(**self.__dict__)\n    for set_param in self.prototypes['set']:\n        params = get_params_types_names(set_param)[1:]\n        param = self.shortname.split('_set_')[-1]\n        paramdecls = ''.join(['\\n   {0} {1};'.format(p['type'], p['name']) for p in params])\n        method_name = get_name(set_param)\n        param = method_name.split('aubio_' + self.shortname + '_set_')[-1]\n        refs = ', '.join(['&%s' % p['name'] for p in params])\n        paramlist = ', '.join(['%s' % p['name'] for p in params])\n        if len(params):\n            paramlist = ',' + paramlist\n        pyparamtypes = ''.join([pyargparse_chars[p['type']] for p in params])\n        out += '\\nstatic PyObject *\\nPyaubio_{shortname}_set_{param} (Py_{shortname} *self, PyObject *args)\\n{{\\n  uint_t err = 0;\\n  {paramdecls}\\n'.format(param=param, paramdecls=paramdecls, **self.__dict__)\n        if len(refs) and len(pyparamtypes):\n            out += '\\n\\n  if (!PyArg_ParseTuple (args, \"{pyparamtypes}\", {refs})) {{\\n    return NULL;\\n  }}\\n'.format(pyparamtypes=pyparamtypes, refs=refs)\n        out += '\\n  err = aubio_{shortname}_set_{param} (self->o {paramlist});\\n\\n  if (err > 0) {{\\n    if (PyErr_Occurred() == NULL) {{\\n      PyErr_SetString (PyExc_ValueError, \"error running aubio_{shortname}_set_{param}\");\\n    }} else {{\\n      // change the RuntimeError into ValueError\\n      PyObject *type, *value, *traceback;\\n      PyErr_Fetch(&type, &value, &traceback);\\n      Py_XDECREF(type);\\n      type = PyExc_ValueError;\\n      Py_XINCREF(type);\\n      PyErr_Restore(type, value, traceback);\\n    }}\\n    return NULL;\\n  }}\\n  Py_RETURN_NONE;\\n}}\\n'.format(param=param, refs=refs, paramdecls=paramdecls, pyparamtypes=pyparamtypes, paramlist=paramlist, **self.__dict__)\n    return out",
            "def gen_set(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    out = '\\n// {shortname} setters\\n'.format(**self.__dict__)\n    for set_param in self.prototypes['set']:\n        params = get_params_types_names(set_param)[1:]\n        param = self.shortname.split('_set_')[-1]\n        paramdecls = ''.join(['\\n   {0} {1};'.format(p['type'], p['name']) for p in params])\n        method_name = get_name(set_param)\n        param = method_name.split('aubio_' + self.shortname + '_set_')[-1]\n        refs = ', '.join(['&%s' % p['name'] for p in params])\n        paramlist = ', '.join(['%s' % p['name'] for p in params])\n        if len(params):\n            paramlist = ',' + paramlist\n        pyparamtypes = ''.join([pyargparse_chars[p['type']] for p in params])\n        out += '\\nstatic PyObject *\\nPyaubio_{shortname}_set_{param} (Py_{shortname} *self, PyObject *args)\\n{{\\n  uint_t err = 0;\\n  {paramdecls}\\n'.format(param=param, paramdecls=paramdecls, **self.__dict__)\n        if len(refs) and len(pyparamtypes):\n            out += '\\n\\n  if (!PyArg_ParseTuple (args, \"{pyparamtypes}\", {refs})) {{\\n    return NULL;\\n  }}\\n'.format(pyparamtypes=pyparamtypes, refs=refs)\n        out += '\\n  err = aubio_{shortname}_set_{param} (self->o {paramlist});\\n\\n  if (err > 0) {{\\n    if (PyErr_Occurred() == NULL) {{\\n      PyErr_SetString (PyExc_ValueError, \"error running aubio_{shortname}_set_{param}\");\\n    }} else {{\\n      // change the RuntimeError into ValueError\\n      PyObject *type, *value, *traceback;\\n      PyErr_Fetch(&type, &value, &traceback);\\n      Py_XDECREF(type);\\n      type = PyExc_ValueError;\\n      Py_XINCREF(type);\\n      PyErr_Restore(type, value, traceback);\\n    }}\\n    return NULL;\\n  }}\\n  Py_RETURN_NONE;\\n}}\\n'.format(param=param, refs=refs, paramdecls=paramdecls, pyparamtypes=pyparamtypes, paramlist=paramlist, **self.__dict__)\n    return out"
        ]
    },
    {
        "func_name": "gen_get",
        "original": "def gen_get(self):\n    out = '\\n// {shortname} getters\\n'.format(**self.__dict__)\n    for method in self.prototypes['get']:\n        params = get_params_types_names(method)\n        method_name = get_name(method)\n        assert len(params) == 1, 'get method has more than one parameter %s' % params\n        param = method_name.split('aubio_' + self.shortname + '_get_')[-1]\n        paramtype = get_return_type(method)\n        ptypeconv = pyfromtype_fn[paramtype]\n        out += '\\nstatic PyObject *\\nPyaubio_{shortname}_get_{param} (Py_{shortname} *self, PyObject *unused)\\n{{\\n  {ptype} {param} = aubio_{shortname}_get_{param} (self->o);\\n  return (PyObject *){ptypeconv} ({param});\\n}}\\n'.format(param=param, ptype=paramtype, ptypeconv=ptypeconv, **self.__dict__)\n    return out",
        "mutated": [
            "def gen_get(self):\n    if False:\n        i = 10\n    out = '\\n// {shortname} getters\\n'.format(**self.__dict__)\n    for method in self.prototypes['get']:\n        params = get_params_types_names(method)\n        method_name = get_name(method)\n        assert len(params) == 1, 'get method has more than one parameter %s' % params\n        param = method_name.split('aubio_' + self.shortname + '_get_')[-1]\n        paramtype = get_return_type(method)\n        ptypeconv = pyfromtype_fn[paramtype]\n        out += '\\nstatic PyObject *\\nPyaubio_{shortname}_get_{param} (Py_{shortname} *self, PyObject *unused)\\n{{\\n  {ptype} {param} = aubio_{shortname}_get_{param} (self->o);\\n  return (PyObject *){ptypeconv} ({param});\\n}}\\n'.format(param=param, ptype=paramtype, ptypeconv=ptypeconv, **self.__dict__)\n    return out",
            "def gen_get(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    out = '\\n// {shortname} getters\\n'.format(**self.__dict__)\n    for method in self.prototypes['get']:\n        params = get_params_types_names(method)\n        method_name = get_name(method)\n        assert len(params) == 1, 'get method has more than one parameter %s' % params\n        param = method_name.split('aubio_' + self.shortname + '_get_')[-1]\n        paramtype = get_return_type(method)\n        ptypeconv = pyfromtype_fn[paramtype]\n        out += '\\nstatic PyObject *\\nPyaubio_{shortname}_get_{param} (Py_{shortname} *self, PyObject *unused)\\n{{\\n  {ptype} {param} = aubio_{shortname}_get_{param} (self->o);\\n  return (PyObject *){ptypeconv} ({param});\\n}}\\n'.format(param=param, ptype=paramtype, ptypeconv=ptypeconv, **self.__dict__)\n    return out",
            "def gen_get(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    out = '\\n// {shortname} getters\\n'.format(**self.__dict__)\n    for method in self.prototypes['get']:\n        params = get_params_types_names(method)\n        method_name = get_name(method)\n        assert len(params) == 1, 'get method has more than one parameter %s' % params\n        param = method_name.split('aubio_' + self.shortname + '_get_')[-1]\n        paramtype = get_return_type(method)\n        ptypeconv = pyfromtype_fn[paramtype]\n        out += '\\nstatic PyObject *\\nPyaubio_{shortname}_get_{param} (Py_{shortname} *self, PyObject *unused)\\n{{\\n  {ptype} {param} = aubio_{shortname}_get_{param} (self->o);\\n  return (PyObject *){ptypeconv} ({param});\\n}}\\n'.format(param=param, ptype=paramtype, ptypeconv=ptypeconv, **self.__dict__)\n    return out",
            "def gen_get(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    out = '\\n// {shortname} getters\\n'.format(**self.__dict__)\n    for method in self.prototypes['get']:\n        params = get_params_types_names(method)\n        method_name = get_name(method)\n        assert len(params) == 1, 'get method has more than one parameter %s' % params\n        param = method_name.split('aubio_' + self.shortname + '_get_')[-1]\n        paramtype = get_return_type(method)\n        ptypeconv = pyfromtype_fn[paramtype]\n        out += '\\nstatic PyObject *\\nPyaubio_{shortname}_get_{param} (Py_{shortname} *self, PyObject *unused)\\n{{\\n  {ptype} {param} = aubio_{shortname}_get_{param} (self->o);\\n  return (PyObject *){ptypeconv} ({param});\\n}}\\n'.format(param=param, ptype=paramtype, ptypeconv=ptypeconv, **self.__dict__)\n    return out",
            "def gen_get(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    out = '\\n// {shortname} getters\\n'.format(**self.__dict__)\n    for method in self.prototypes['get']:\n        params = get_params_types_names(method)\n        method_name = get_name(method)\n        assert len(params) == 1, 'get method has more than one parameter %s' % params\n        param = method_name.split('aubio_' + self.shortname + '_get_')[-1]\n        paramtype = get_return_type(method)\n        ptypeconv = pyfromtype_fn[paramtype]\n        out += '\\nstatic PyObject *\\nPyaubio_{shortname}_get_{param} (Py_{shortname} *self, PyObject *unused)\\n{{\\n  {ptype} {param} = aubio_{shortname}_get_{param} (self->o);\\n  return (PyObject *){ptypeconv} ({param});\\n}}\\n'.format(param=param, ptype=paramtype, ptypeconv=ptypeconv, **self.__dict__)\n    return out"
        ]
    },
    {
        "func_name": "gen_methodef",
        "original": "def gen_methodef(self):\n    out = '\\nstatic PyMethodDef Py_{shortname}_methods[] = {{'.format(**self.__dict__)\n    for m in self.prototypes['set']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_VARARGS, \"\"}},'.format(name=name, shortname=shortname)\n    for m in self.prototypes['get']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_NOARGS, \"\"}},'.format(name=name, shortname=shortname)\n    for m in self.prototypes['rdo']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_VARARGS, \"\"}},'.format(name=name, shortname=shortname)\n    out += '\\n  {NULL} /* sentinel */\\n};\\n'\n    return out",
        "mutated": [
            "def gen_methodef(self):\n    if False:\n        i = 10\n    out = '\\nstatic PyMethodDef Py_{shortname}_methods[] = {{'.format(**self.__dict__)\n    for m in self.prototypes['set']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_VARARGS, \"\"}},'.format(name=name, shortname=shortname)\n    for m in self.prototypes['get']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_NOARGS, \"\"}},'.format(name=name, shortname=shortname)\n    for m in self.prototypes['rdo']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_VARARGS, \"\"}},'.format(name=name, shortname=shortname)\n    out += '\\n  {NULL} /* sentinel */\\n};\\n'\n    return out",
            "def gen_methodef(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    out = '\\nstatic PyMethodDef Py_{shortname}_methods[] = {{'.format(**self.__dict__)\n    for m in self.prototypes['set']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_VARARGS, \"\"}},'.format(name=name, shortname=shortname)\n    for m in self.prototypes['get']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_NOARGS, \"\"}},'.format(name=name, shortname=shortname)\n    for m in self.prototypes['rdo']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_VARARGS, \"\"}},'.format(name=name, shortname=shortname)\n    out += '\\n  {NULL} /* sentinel */\\n};\\n'\n    return out",
            "def gen_methodef(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    out = '\\nstatic PyMethodDef Py_{shortname}_methods[] = {{'.format(**self.__dict__)\n    for m in self.prototypes['set']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_VARARGS, \"\"}},'.format(name=name, shortname=shortname)\n    for m in self.prototypes['get']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_NOARGS, \"\"}},'.format(name=name, shortname=shortname)\n    for m in self.prototypes['rdo']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_VARARGS, \"\"}},'.format(name=name, shortname=shortname)\n    out += '\\n  {NULL} /* sentinel */\\n};\\n'\n    return out",
            "def gen_methodef(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    out = '\\nstatic PyMethodDef Py_{shortname}_methods[] = {{'.format(**self.__dict__)\n    for m in self.prototypes['set']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_VARARGS, \"\"}},'.format(name=name, shortname=shortname)\n    for m in self.prototypes['get']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_NOARGS, \"\"}},'.format(name=name, shortname=shortname)\n    for m in self.prototypes['rdo']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_VARARGS, \"\"}},'.format(name=name, shortname=shortname)\n    out += '\\n  {NULL} /* sentinel */\\n};\\n'\n    return out",
            "def gen_methodef(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    out = '\\nstatic PyMethodDef Py_{shortname}_methods[] = {{'.format(**self.__dict__)\n    for m in self.prototypes['set']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_VARARGS, \"\"}},'.format(name=name, shortname=shortname)\n    for m in self.prototypes['get']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_NOARGS, \"\"}},'.format(name=name, shortname=shortname)\n    for m in self.prototypes['rdo']:\n        name = get_name(m)\n        shortname = name.replace('aubio_%s_' % self.shortname, '')\n        out += '\\n  {{\"{shortname}\", (PyCFunction) Py{name},\\n    METH_VARARGS, \"\"}},'.format(name=name, shortname=shortname)\n    out += '\\n  {NULL} /* sentinel */\\n};\\n'\n    return out"
        ]
    },
    {
        "func_name": "gen_typeobject",
        "original": "def gen_typeobject(self):\n    return '\\nPyTypeObject Py_{shortname}Type = {{\\n  //PyObject_HEAD_INIT (NULL)\\n  //0,\\n  PyVarObject_HEAD_INIT (NULL, 0)\\n  \"aubio.{shortname}\",\\n  sizeof (Py_{shortname}),\\n  0,\\n  (destructor) Py_{shortname}_del,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  (ternaryfunc)Pyaubio_{shortname}_do,\\n  0,\\n  0,\\n  0,\\n  0,\\n  Py_TPFLAGS_DEFAULT,\\n  Py_{shortname}_doc,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  Py_{shortname}_methods,\\n  Py_{shortname}_members,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  (initproc) Py_{shortname}_init,\\n  0,\\n  Py_{shortname}_new,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n}};\\n'.format(**self.__dict__)",
        "mutated": [
            "def gen_typeobject(self):\n    if False:\n        i = 10\n    return '\\nPyTypeObject Py_{shortname}Type = {{\\n  //PyObject_HEAD_INIT (NULL)\\n  //0,\\n  PyVarObject_HEAD_INIT (NULL, 0)\\n  \"aubio.{shortname}\",\\n  sizeof (Py_{shortname}),\\n  0,\\n  (destructor) Py_{shortname}_del,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  (ternaryfunc)Pyaubio_{shortname}_do,\\n  0,\\n  0,\\n  0,\\n  0,\\n  Py_TPFLAGS_DEFAULT,\\n  Py_{shortname}_doc,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  Py_{shortname}_methods,\\n  Py_{shortname}_members,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  (initproc) Py_{shortname}_init,\\n  0,\\n  Py_{shortname}_new,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n}};\\n'.format(**self.__dict__)",
            "def gen_typeobject(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return '\\nPyTypeObject Py_{shortname}Type = {{\\n  //PyObject_HEAD_INIT (NULL)\\n  //0,\\n  PyVarObject_HEAD_INIT (NULL, 0)\\n  \"aubio.{shortname}\",\\n  sizeof (Py_{shortname}),\\n  0,\\n  (destructor) Py_{shortname}_del,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  (ternaryfunc)Pyaubio_{shortname}_do,\\n  0,\\n  0,\\n  0,\\n  0,\\n  Py_TPFLAGS_DEFAULT,\\n  Py_{shortname}_doc,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  Py_{shortname}_methods,\\n  Py_{shortname}_members,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  (initproc) Py_{shortname}_init,\\n  0,\\n  Py_{shortname}_new,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n}};\\n'.format(**self.__dict__)",
            "def gen_typeobject(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return '\\nPyTypeObject Py_{shortname}Type = {{\\n  //PyObject_HEAD_INIT (NULL)\\n  //0,\\n  PyVarObject_HEAD_INIT (NULL, 0)\\n  \"aubio.{shortname}\",\\n  sizeof (Py_{shortname}),\\n  0,\\n  (destructor) Py_{shortname}_del,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  (ternaryfunc)Pyaubio_{shortname}_do,\\n  0,\\n  0,\\n  0,\\n  0,\\n  Py_TPFLAGS_DEFAULT,\\n  Py_{shortname}_doc,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  Py_{shortname}_methods,\\n  Py_{shortname}_members,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  (initproc) Py_{shortname}_init,\\n  0,\\n  Py_{shortname}_new,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n}};\\n'.format(**self.__dict__)",
            "def gen_typeobject(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return '\\nPyTypeObject Py_{shortname}Type = {{\\n  //PyObject_HEAD_INIT (NULL)\\n  //0,\\n  PyVarObject_HEAD_INIT (NULL, 0)\\n  \"aubio.{shortname}\",\\n  sizeof (Py_{shortname}),\\n  0,\\n  (destructor) Py_{shortname}_del,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  (ternaryfunc)Pyaubio_{shortname}_do,\\n  0,\\n  0,\\n  0,\\n  0,\\n  Py_TPFLAGS_DEFAULT,\\n  Py_{shortname}_doc,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  Py_{shortname}_methods,\\n  Py_{shortname}_members,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  (initproc) Py_{shortname}_init,\\n  0,\\n  Py_{shortname}_new,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n}};\\n'.format(**self.__dict__)",
            "def gen_typeobject(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return '\\nPyTypeObject Py_{shortname}Type = {{\\n  //PyObject_HEAD_INIT (NULL)\\n  //0,\\n  PyVarObject_HEAD_INIT (NULL, 0)\\n  \"aubio.{shortname}\",\\n  sizeof (Py_{shortname}),\\n  0,\\n  (destructor) Py_{shortname}_del,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  (ternaryfunc)Pyaubio_{shortname}_do,\\n  0,\\n  0,\\n  0,\\n  0,\\n  Py_TPFLAGS_DEFAULT,\\n  Py_{shortname}_doc,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  Py_{shortname}_methods,\\n  Py_{shortname}_members,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  (initproc) Py_{shortname}_init,\\n  0,\\n  Py_{shortname}_new,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n  0,\\n}};\\n'.format(**self.__dict__)"
        ]
    }
]