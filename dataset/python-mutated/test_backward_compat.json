[
    {
        "func_name": "setUpClass",
        "original": "@classmethod\ndef setUpClass(cls):\n    ray.init(runtime_env={'pip_packages': ['gym==0.23.1']})",
        "mutated": [
            "@classmethod\ndef setUpClass(cls):\n    if False:\n        i = 10\n    ray.init(runtime_env={'pip_packages': ['gym==0.23.1']})",
            "@classmethod\ndef setUpClass(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ray.init(runtime_env={'pip_packages': ['gym==0.23.1']})",
            "@classmethod\ndef setUpClass(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ray.init(runtime_env={'pip_packages': ['gym==0.23.1']})",
            "@classmethod\ndef setUpClass(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ray.init(runtime_env={'pip_packages': ['gym==0.23.1']})",
            "@classmethod\ndef setUpClass(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ray.init(runtime_env={'pip_packages': ['gym==0.23.1']})"
        ]
    },
    {
        "func_name": "tearDownClass",
        "original": "@classmethod\ndef tearDownClass(cls):\n    ray.shutdown()",
        "mutated": [
            "@classmethod\ndef tearDownClass(cls):\n    if False:\n        i = 10\n    ray.shutdown()",
            "@classmethod\ndef tearDownClass(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ray.shutdown()",
            "@classmethod\ndef tearDownClass(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ray.shutdown()",
            "@classmethod\ndef tearDownClass(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ray.shutdown()",
            "@classmethod\ndef tearDownClass(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ray.shutdown()"
        ]
    },
    {
        "func_name": "test_old_checkpoint_formats",
        "original": "def test_old_checkpoint_formats(self):\n    \"\"\"Tests, whether we remain backward compatible (>=2.0.0) wrt checkpoints.\"\"\"\n    rllib_dir = Path(__file__).parent.parent.parent\n    print(f'rllib dir={rllib_dir} exists={os.path.isdir(rllib_dir)}')\n    for v in []:\n        v = version.Version(v)\n        for fw in framework_iterator():\n            path_to_checkpoint = os.path.join(rllib_dir, 'tests', 'backward_compat', 'checkpoints', 'v' + str(v), 'ppo_frozenlake_' + fw)\n            print(f'path_to_checkpoint={path_to_checkpoint} exists={os.path.isdir(path_to_checkpoint)}')\n            checkpoint_info = get_checkpoint_info(path_to_checkpoint)\n            if checkpoint_info['checkpoint_version'] == version.Version('0.1'):\n                with open(checkpoint_info['state_file'], 'rb') as f:\n                    state = pickle.load(f)\n                worker_state = pickle.loads(state['worker'])\n                algo = PPO(config=worker_state['policy_config'])\n                algo.load_checkpoint(path_to_checkpoint)\n            else:\n                algo = Algorithm.from_checkpoint(path_to_checkpoint)\n                policies = Policy.from_checkpoint(path_to_checkpoint)\n                self.assertTrue('default_policy' in policies)\n            print(algo.train())\n            algo.stop()",
        "mutated": [
            "def test_old_checkpoint_formats(self):\n    if False:\n        i = 10\n    'Tests, whether we remain backward compatible (>=2.0.0) wrt checkpoints.'\n    rllib_dir = Path(__file__).parent.parent.parent\n    print(f'rllib dir={rllib_dir} exists={os.path.isdir(rllib_dir)}')\n    for v in []:\n        v = version.Version(v)\n        for fw in framework_iterator():\n            path_to_checkpoint = os.path.join(rllib_dir, 'tests', 'backward_compat', 'checkpoints', 'v' + str(v), 'ppo_frozenlake_' + fw)\n            print(f'path_to_checkpoint={path_to_checkpoint} exists={os.path.isdir(path_to_checkpoint)}')\n            checkpoint_info = get_checkpoint_info(path_to_checkpoint)\n            if checkpoint_info['checkpoint_version'] == version.Version('0.1'):\n                with open(checkpoint_info['state_file'], 'rb') as f:\n                    state = pickle.load(f)\n                worker_state = pickle.loads(state['worker'])\n                algo = PPO(config=worker_state['policy_config'])\n                algo.load_checkpoint(path_to_checkpoint)\n            else:\n                algo = Algorithm.from_checkpoint(path_to_checkpoint)\n                policies = Policy.from_checkpoint(path_to_checkpoint)\n                self.assertTrue('default_policy' in policies)\n            print(algo.train())\n            algo.stop()",
            "def test_old_checkpoint_formats(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests, whether we remain backward compatible (>=2.0.0) wrt checkpoints.'\n    rllib_dir = Path(__file__).parent.parent.parent\n    print(f'rllib dir={rllib_dir} exists={os.path.isdir(rllib_dir)}')\n    for v in []:\n        v = version.Version(v)\n        for fw in framework_iterator():\n            path_to_checkpoint = os.path.join(rllib_dir, 'tests', 'backward_compat', 'checkpoints', 'v' + str(v), 'ppo_frozenlake_' + fw)\n            print(f'path_to_checkpoint={path_to_checkpoint} exists={os.path.isdir(path_to_checkpoint)}')\n            checkpoint_info = get_checkpoint_info(path_to_checkpoint)\n            if checkpoint_info['checkpoint_version'] == version.Version('0.1'):\n                with open(checkpoint_info['state_file'], 'rb') as f:\n                    state = pickle.load(f)\n                worker_state = pickle.loads(state['worker'])\n                algo = PPO(config=worker_state['policy_config'])\n                algo.load_checkpoint(path_to_checkpoint)\n            else:\n                algo = Algorithm.from_checkpoint(path_to_checkpoint)\n                policies = Policy.from_checkpoint(path_to_checkpoint)\n                self.assertTrue('default_policy' in policies)\n            print(algo.train())\n            algo.stop()",
            "def test_old_checkpoint_formats(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests, whether we remain backward compatible (>=2.0.0) wrt checkpoints.'\n    rllib_dir = Path(__file__).parent.parent.parent\n    print(f'rllib dir={rllib_dir} exists={os.path.isdir(rllib_dir)}')\n    for v in []:\n        v = version.Version(v)\n        for fw in framework_iterator():\n            path_to_checkpoint = os.path.join(rllib_dir, 'tests', 'backward_compat', 'checkpoints', 'v' + str(v), 'ppo_frozenlake_' + fw)\n            print(f'path_to_checkpoint={path_to_checkpoint} exists={os.path.isdir(path_to_checkpoint)}')\n            checkpoint_info = get_checkpoint_info(path_to_checkpoint)\n            if checkpoint_info['checkpoint_version'] == version.Version('0.1'):\n                with open(checkpoint_info['state_file'], 'rb') as f:\n                    state = pickle.load(f)\n                worker_state = pickle.loads(state['worker'])\n                algo = PPO(config=worker_state['policy_config'])\n                algo.load_checkpoint(path_to_checkpoint)\n            else:\n                algo = Algorithm.from_checkpoint(path_to_checkpoint)\n                policies = Policy.from_checkpoint(path_to_checkpoint)\n                self.assertTrue('default_policy' in policies)\n            print(algo.train())\n            algo.stop()",
            "def test_old_checkpoint_formats(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests, whether we remain backward compatible (>=2.0.0) wrt checkpoints.'\n    rllib_dir = Path(__file__).parent.parent.parent\n    print(f'rllib dir={rllib_dir} exists={os.path.isdir(rllib_dir)}')\n    for v in []:\n        v = version.Version(v)\n        for fw in framework_iterator():\n            path_to_checkpoint = os.path.join(rllib_dir, 'tests', 'backward_compat', 'checkpoints', 'v' + str(v), 'ppo_frozenlake_' + fw)\n            print(f'path_to_checkpoint={path_to_checkpoint} exists={os.path.isdir(path_to_checkpoint)}')\n            checkpoint_info = get_checkpoint_info(path_to_checkpoint)\n            if checkpoint_info['checkpoint_version'] == version.Version('0.1'):\n                with open(checkpoint_info['state_file'], 'rb') as f:\n                    state = pickle.load(f)\n                worker_state = pickle.loads(state['worker'])\n                algo = PPO(config=worker_state['policy_config'])\n                algo.load_checkpoint(path_to_checkpoint)\n            else:\n                algo = Algorithm.from_checkpoint(path_to_checkpoint)\n                policies = Policy.from_checkpoint(path_to_checkpoint)\n                self.assertTrue('default_policy' in policies)\n            print(algo.train())\n            algo.stop()",
            "def test_old_checkpoint_formats(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests, whether we remain backward compatible (>=2.0.0) wrt checkpoints.'\n    rllib_dir = Path(__file__).parent.parent.parent\n    print(f'rllib dir={rllib_dir} exists={os.path.isdir(rllib_dir)}')\n    for v in []:\n        v = version.Version(v)\n        for fw in framework_iterator():\n            path_to_checkpoint = os.path.join(rllib_dir, 'tests', 'backward_compat', 'checkpoints', 'v' + str(v), 'ppo_frozenlake_' + fw)\n            print(f'path_to_checkpoint={path_to_checkpoint} exists={os.path.isdir(path_to_checkpoint)}')\n            checkpoint_info = get_checkpoint_info(path_to_checkpoint)\n            if checkpoint_info['checkpoint_version'] == version.Version('0.1'):\n                with open(checkpoint_info['state_file'], 'rb') as f:\n                    state = pickle.load(f)\n                worker_state = pickle.loads(state['worker'])\n                algo = PPO(config=worker_state['policy_config'])\n                algo.load_checkpoint(path_to_checkpoint)\n            else:\n                algo = Algorithm.from_checkpoint(path_to_checkpoint)\n                policies = Policy.from_checkpoint(path_to_checkpoint)\n                self.assertTrue('default_policy' in policies)\n            print(algo.train())\n            algo.stop()"
        ]
    },
    {
        "func_name": "test_old_algorithm_config_dicts",
        "original": "def test_old_algorithm_config_dicts(self):\n    \"\"\"Tests, whether we can build Algorithm objects with old config dicts.\"\"\"\n    config_dict = {'evaluation_config': {'lr': 0.1}, 'lr': 0.2, 'multiagent': {'policies': {'pol1', 'pol2'}, 'policies_to_train': ['pol1'], 'policy_mapping_fn': lambda aid, episode, worker, **kwargs: 'pol1'}}\n    config = AlgorithmConfig.from_dict(config_dict)\n    self.assertFalse(config.in_evaluation)\n    self.assertTrue(config.lr == 0.2)\n    self.assertTrue(config.policies == {'pol1', 'pol2'})\n    self.assertTrue(config.policy_mapping_fn(1, 2, 3) == 'pol1')\n    eval_config = config.get_evaluation_config_object()\n    self.assertTrue(eval_config.in_evaluation)\n    self.assertTrue(eval_config.lr == 0.1)\n    register_env('test', lambda ctx: MultiAgentCartPole(config={'num_agents': ctx['num_agents']}))\n    config = {'env': 'test', 'env_config': {'num_agents': 1}, 'lr': 0.001, 'evaluation_config': {'num_envs_per_worker': 4, 'explore': False}, 'evaluation_num_workers': 1, 'multiagent': {'policies': {'policy1': PolicySpec()}, 'policy_mapping_fn': lambda aid, episode, worker, **kw: 'policy1', 'policies_to_train': ['policy1']}}\n    algo = DQN(config=config)\n    self.assertTrue(algo.config.lr == 0.001)\n    self.assertTrue(algo.config.evaluation_num_workers == 1)\n    self.assertTrue(list(algo.config.policies.keys()) == ['policy1'])\n    self.assertTrue(algo.config.explore is True)\n    self.assertTrue(algo.evaluation_config.explore is False)\n    print(algo.train())\n    algo.stop()",
        "mutated": [
            "def test_old_algorithm_config_dicts(self):\n    if False:\n        i = 10\n    'Tests, whether we can build Algorithm objects with old config dicts.'\n    config_dict = {'evaluation_config': {'lr': 0.1}, 'lr': 0.2, 'multiagent': {'policies': {'pol1', 'pol2'}, 'policies_to_train': ['pol1'], 'policy_mapping_fn': lambda aid, episode, worker, **kwargs: 'pol1'}}\n    config = AlgorithmConfig.from_dict(config_dict)\n    self.assertFalse(config.in_evaluation)\n    self.assertTrue(config.lr == 0.2)\n    self.assertTrue(config.policies == {'pol1', 'pol2'})\n    self.assertTrue(config.policy_mapping_fn(1, 2, 3) == 'pol1')\n    eval_config = config.get_evaluation_config_object()\n    self.assertTrue(eval_config.in_evaluation)\n    self.assertTrue(eval_config.lr == 0.1)\n    register_env('test', lambda ctx: MultiAgentCartPole(config={'num_agents': ctx['num_agents']}))\n    config = {'env': 'test', 'env_config': {'num_agents': 1}, 'lr': 0.001, 'evaluation_config': {'num_envs_per_worker': 4, 'explore': False}, 'evaluation_num_workers': 1, 'multiagent': {'policies': {'policy1': PolicySpec()}, 'policy_mapping_fn': lambda aid, episode, worker, **kw: 'policy1', 'policies_to_train': ['policy1']}}\n    algo = DQN(config=config)\n    self.assertTrue(algo.config.lr == 0.001)\n    self.assertTrue(algo.config.evaluation_num_workers == 1)\n    self.assertTrue(list(algo.config.policies.keys()) == ['policy1'])\n    self.assertTrue(algo.config.explore is True)\n    self.assertTrue(algo.evaluation_config.explore is False)\n    print(algo.train())\n    algo.stop()",
            "def test_old_algorithm_config_dicts(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests, whether we can build Algorithm objects with old config dicts.'\n    config_dict = {'evaluation_config': {'lr': 0.1}, 'lr': 0.2, 'multiagent': {'policies': {'pol1', 'pol2'}, 'policies_to_train': ['pol1'], 'policy_mapping_fn': lambda aid, episode, worker, **kwargs: 'pol1'}}\n    config = AlgorithmConfig.from_dict(config_dict)\n    self.assertFalse(config.in_evaluation)\n    self.assertTrue(config.lr == 0.2)\n    self.assertTrue(config.policies == {'pol1', 'pol2'})\n    self.assertTrue(config.policy_mapping_fn(1, 2, 3) == 'pol1')\n    eval_config = config.get_evaluation_config_object()\n    self.assertTrue(eval_config.in_evaluation)\n    self.assertTrue(eval_config.lr == 0.1)\n    register_env('test', lambda ctx: MultiAgentCartPole(config={'num_agents': ctx['num_agents']}))\n    config = {'env': 'test', 'env_config': {'num_agents': 1}, 'lr': 0.001, 'evaluation_config': {'num_envs_per_worker': 4, 'explore': False}, 'evaluation_num_workers': 1, 'multiagent': {'policies': {'policy1': PolicySpec()}, 'policy_mapping_fn': lambda aid, episode, worker, **kw: 'policy1', 'policies_to_train': ['policy1']}}\n    algo = DQN(config=config)\n    self.assertTrue(algo.config.lr == 0.001)\n    self.assertTrue(algo.config.evaluation_num_workers == 1)\n    self.assertTrue(list(algo.config.policies.keys()) == ['policy1'])\n    self.assertTrue(algo.config.explore is True)\n    self.assertTrue(algo.evaluation_config.explore is False)\n    print(algo.train())\n    algo.stop()",
            "def test_old_algorithm_config_dicts(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests, whether we can build Algorithm objects with old config dicts.'\n    config_dict = {'evaluation_config': {'lr': 0.1}, 'lr': 0.2, 'multiagent': {'policies': {'pol1', 'pol2'}, 'policies_to_train': ['pol1'], 'policy_mapping_fn': lambda aid, episode, worker, **kwargs: 'pol1'}}\n    config = AlgorithmConfig.from_dict(config_dict)\n    self.assertFalse(config.in_evaluation)\n    self.assertTrue(config.lr == 0.2)\n    self.assertTrue(config.policies == {'pol1', 'pol2'})\n    self.assertTrue(config.policy_mapping_fn(1, 2, 3) == 'pol1')\n    eval_config = config.get_evaluation_config_object()\n    self.assertTrue(eval_config.in_evaluation)\n    self.assertTrue(eval_config.lr == 0.1)\n    register_env('test', lambda ctx: MultiAgentCartPole(config={'num_agents': ctx['num_agents']}))\n    config = {'env': 'test', 'env_config': {'num_agents': 1}, 'lr': 0.001, 'evaluation_config': {'num_envs_per_worker': 4, 'explore': False}, 'evaluation_num_workers': 1, 'multiagent': {'policies': {'policy1': PolicySpec()}, 'policy_mapping_fn': lambda aid, episode, worker, **kw: 'policy1', 'policies_to_train': ['policy1']}}\n    algo = DQN(config=config)\n    self.assertTrue(algo.config.lr == 0.001)\n    self.assertTrue(algo.config.evaluation_num_workers == 1)\n    self.assertTrue(list(algo.config.policies.keys()) == ['policy1'])\n    self.assertTrue(algo.config.explore is True)\n    self.assertTrue(algo.evaluation_config.explore is False)\n    print(algo.train())\n    algo.stop()",
            "def test_old_algorithm_config_dicts(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests, whether we can build Algorithm objects with old config dicts.'\n    config_dict = {'evaluation_config': {'lr': 0.1}, 'lr': 0.2, 'multiagent': {'policies': {'pol1', 'pol2'}, 'policies_to_train': ['pol1'], 'policy_mapping_fn': lambda aid, episode, worker, **kwargs: 'pol1'}}\n    config = AlgorithmConfig.from_dict(config_dict)\n    self.assertFalse(config.in_evaluation)\n    self.assertTrue(config.lr == 0.2)\n    self.assertTrue(config.policies == {'pol1', 'pol2'})\n    self.assertTrue(config.policy_mapping_fn(1, 2, 3) == 'pol1')\n    eval_config = config.get_evaluation_config_object()\n    self.assertTrue(eval_config.in_evaluation)\n    self.assertTrue(eval_config.lr == 0.1)\n    register_env('test', lambda ctx: MultiAgentCartPole(config={'num_agents': ctx['num_agents']}))\n    config = {'env': 'test', 'env_config': {'num_agents': 1}, 'lr': 0.001, 'evaluation_config': {'num_envs_per_worker': 4, 'explore': False}, 'evaluation_num_workers': 1, 'multiagent': {'policies': {'policy1': PolicySpec()}, 'policy_mapping_fn': lambda aid, episode, worker, **kw: 'policy1', 'policies_to_train': ['policy1']}}\n    algo = DQN(config=config)\n    self.assertTrue(algo.config.lr == 0.001)\n    self.assertTrue(algo.config.evaluation_num_workers == 1)\n    self.assertTrue(list(algo.config.policies.keys()) == ['policy1'])\n    self.assertTrue(algo.config.explore is True)\n    self.assertTrue(algo.evaluation_config.explore is False)\n    print(algo.train())\n    algo.stop()",
            "def test_old_algorithm_config_dicts(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests, whether we can build Algorithm objects with old config dicts.'\n    config_dict = {'evaluation_config': {'lr': 0.1}, 'lr': 0.2, 'multiagent': {'policies': {'pol1', 'pol2'}, 'policies_to_train': ['pol1'], 'policy_mapping_fn': lambda aid, episode, worker, **kwargs: 'pol1'}}\n    config = AlgorithmConfig.from_dict(config_dict)\n    self.assertFalse(config.in_evaluation)\n    self.assertTrue(config.lr == 0.2)\n    self.assertTrue(config.policies == {'pol1', 'pol2'})\n    self.assertTrue(config.policy_mapping_fn(1, 2, 3) == 'pol1')\n    eval_config = config.get_evaluation_config_object()\n    self.assertTrue(eval_config.in_evaluation)\n    self.assertTrue(eval_config.lr == 0.1)\n    register_env('test', lambda ctx: MultiAgentCartPole(config={'num_agents': ctx['num_agents']}))\n    config = {'env': 'test', 'env_config': {'num_agents': 1}, 'lr': 0.001, 'evaluation_config': {'num_envs_per_worker': 4, 'explore': False}, 'evaluation_num_workers': 1, 'multiagent': {'policies': {'policy1': PolicySpec()}, 'policy_mapping_fn': lambda aid, episode, worker, **kw: 'policy1', 'policies_to_train': ['policy1']}}\n    algo = DQN(config=config)\n    self.assertTrue(algo.config.lr == 0.001)\n    self.assertTrue(algo.config.evaluation_num_workers == 1)\n    self.assertTrue(list(algo.config.policies.keys()) == ['policy1'])\n    self.assertTrue(algo.config.explore is True)\n    self.assertTrue(algo.evaluation_config.explore is False)\n    print(algo.train())\n    algo.stop()"
        ]
    }
]