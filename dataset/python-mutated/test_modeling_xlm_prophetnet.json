[
    {
        "func_name": "test_pretrained_checkpoint_hidden_states",
        "original": "@slow\ndef test_pretrained_checkpoint_hidden_states(self):\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\n    model.to(torch_device)\n    encoder_ids = torch.tensor([[17, 96208, 103471, 2]]).to(torch_device)\n    decoder_prev_ids = torch.tensor([[2, 250, 9953, 34, 69489, 1620, 32, 118424, 624, 210, 105, 2913, 1032, 351]]).to(torch_device)\n    output = model(input_ids=encoder_ids, attention_mask=None, encoder_outputs=None, decoder_input_ids=decoder_prev_ids)\n    output_predited_logis = output[0]\n    expected_shape = torch.Size((1, 14, 250012))\n    self.assertEqual(output_predited_logis.shape, expected_shape)\n    expected_slice = torch.tensor([[[-6.3986, -8.2391, 12.5189], [-6.3289, -8.0864, 12.6211], [-6.2418, -8.0445, 12.7968]]]).to(torch_device)\n    self.assertTrue(torch.allclose(output_predited_logis[:, :3, :3], expected_slice, atol=0.0001))\n    encoder_outputs = model.prophetnet.encoder(encoder_ids)[0]\n    expected_encoder_outputs_slice = torch.tensor([[[-1.426, -0.7628, 0.8453], [-1.4719, -0.1391, 0.7807], [-1.7678, 0.0114, 0.4646]]]).to(torch_device)\n    expected_shape_encoder = torch.Size((1, 4, 1024))\n    self.assertEqual(encoder_outputs.shape, expected_shape_encoder)\n    self.assertTrue(torch.allclose(encoder_outputs[:, :3, :3], expected_encoder_outputs_slice, atol=0.0001))\n    decoder_outputs = model.prophetnet.decoder(decoder_prev_ids, encoder_hidden_states=encoder_outputs)\n    predicting_streams = decoder_outputs[1].view(1, model.config.ngram, 14, -1)\n    predicting_streams_logits = model.lm_head(predicting_streams)\n    next_first_stream_logits = predicting_streams_logits[:, 0]\n    self.assertTrue(torch.allclose(next_first_stream_logits[:, :3, :3], expected_slice, atol=0.0001))",
        "mutated": [
            "@slow\ndef test_pretrained_checkpoint_hidden_states(self):\n    if False:\n        i = 10\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\n    model.to(torch_device)\n    encoder_ids = torch.tensor([[17, 96208, 103471, 2]]).to(torch_device)\n    decoder_prev_ids = torch.tensor([[2, 250, 9953, 34, 69489, 1620, 32, 118424, 624, 210, 105, 2913, 1032, 351]]).to(torch_device)\n    output = model(input_ids=encoder_ids, attention_mask=None, encoder_outputs=None, decoder_input_ids=decoder_prev_ids)\n    output_predited_logis = output[0]\n    expected_shape = torch.Size((1, 14, 250012))\n    self.assertEqual(output_predited_logis.shape, expected_shape)\n    expected_slice = torch.tensor([[[-6.3986, -8.2391, 12.5189], [-6.3289, -8.0864, 12.6211], [-6.2418, -8.0445, 12.7968]]]).to(torch_device)\n    self.assertTrue(torch.allclose(output_predited_logis[:, :3, :3], expected_slice, atol=0.0001))\n    encoder_outputs = model.prophetnet.encoder(encoder_ids)[0]\n    expected_encoder_outputs_slice = torch.tensor([[[-1.426, -0.7628, 0.8453], [-1.4719, -0.1391, 0.7807], [-1.7678, 0.0114, 0.4646]]]).to(torch_device)\n    expected_shape_encoder = torch.Size((1, 4, 1024))\n    self.assertEqual(encoder_outputs.shape, expected_shape_encoder)\n    self.assertTrue(torch.allclose(encoder_outputs[:, :3, :3], expected_encoder_outputs_slice, atol=0.0001))\n    decoder_outputs = model.prophetnet.decoder(decoder_prev_ids, encoder_hidden_states=encoder_outputs)\n    predicting_streams = decoder_outputs[1].view(1, model.config.ngram, 14, -1)\n    predicting_streams_logits = model.lm_head(predicting_streams)\n    next_first_stream_logits = predicting_streams_logits[:, 0]\n    self.assertTrue(torch.allclose(next_first_stream_logits[:, :3, :3], expected_slice, atol=0.0001))",
            "@slow\ndef test_pretrained_checkpoint_hidden_states(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\n    model.to(torch_device)\n    encoder_ids = torch.tensor([[17, 96208, 103471, 2]]).to(torch_device)\n    decoder_prev_ids = torch.tensor([[2, 250, 9953, 34, 69489, 1620, 32, 118424, 624, 210, 105, 2913, 1032, 351]]).to(torch_device)\n    output = model(input_ids=encoder_ids, attention_mask=None, encoder_outputs=None, decoder_input_ids=decoder_prev_ids)\n    output_predited_logis = output[0]\n    expected_shape = torch.Size((1, 14, 250012))\n    self.assertEqual(output_predited_logis.shape, expected_shape)\n    expected_slice = torch.tensor([[[-6.3986, -8.2391, 12.5189], [-6.3289, -8.0864, 12.6211], [-6.2418, -8.0445, 12.7968]]]).to(torch_device)\n    self.assertTrue(torch.allclose(output_predited_logis[:, :3, :3], expected_slice, atol=0.0001))\n    encoder_outputs = model.prophetnet.encoder(encoder_ids)[0]\n    expected_encoder_outputs_slice = torch.tensor([[[-1.426, -0.7628, 0.8453], [-1.4719, -0.1391, 0.7807], [-1.7678, 0.0114, 0.4646]]]).to(torch_device)\n    expected_shape_encoder = torch.Size((1, 4, 1024))\n    self.assertEqual(encoder_outputs.shape, expected_shape_encoder)\n    self.assertTrue(torch.allclose(encoder_outputs[:, :3, :3], expected_encoder_outputs_slice, atol=0.0001))\n    decoder_outputs = model.prophetnet.decoder(decoder_prev_ids, encoder_hidden_states=encoder_outputs)\n    predicting_streams = decoder_outputs[1].view(1, model.config.ngram, 14, -1)\n    predicting_streams_logits = model.lm_head(predicting_streams)\n    next_first_stream_logits = predicting_streams_logits[:, 0]\n    self.assertTrue(torch.allclose(next_first_stream_logits[:, :3, :3], expected_slice, atol=0.0001))",
            "@slow\ndef test_pretrained_checkpoint_hidden_states(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\n    model.to(torch_device)\n    encoder_ids = torch.tensor([[17, 96208, 103471, 2]]).to(torch_device)\n    decoder_prev_ids = torch.tensor([[2, 250, 9953, 34, 69489, 1620, 32, 118424, 624, 210, 105, 2913, 1032, 351]]).to(torch_device)\n    output = model(input_ids=encoder_ids, attention_mask=None, encoder_outputs=None, decoder_input_ids=decoder_prev_ids)\n    output_predited_logis = output[0]\n    expected_shape = torch.Size((1, 14, 250012))\n    self.assertEqual(output_predited_logis.shape, expected_shape)\n    expected_slice = torch.tensor([[[-6.3986, -8.2391, 12.5189], [-6.3289, -8.0864, 12.6211], [-6.2418, -8.0445, 12.7968]]]).to(torch_device)\n    self.assertTrue(torch.allclose(output_predited_logis[:, :3, :3], expected_slice, atol=0.0001))\n    encoder_outputs = model.prophetnet.encoder(encoder_ids)[0]\n    expected_encoder_outputs_slice = torch.tensor([[[-1.426, -0.7628, 0.8453], [-1.4719, -0.1391, 0.7807], [-1.7678, 0.0114, 0.4646]]]).to(torch_device)\n    expected_shape_encoder = torch.Size((1, 4, 1024))\n    self.assertEqual(encoder_outputs.shape, expected_shape_encoder)\n    self.assertTrue(torch.allclose(encoder_outputs[:, :3, :3], expected_encoder_outputs_slice, atol=0.0001))\n    decoder_outputs = model.prophetnet.decoder(decoder_prev_ids, encoder_hidden_states=encoder_outputs)\n    predicting_streams = decoder_outputs[1].view(1, model.config.ngram, 14, -1)\n    predicting_streams_logits = model.lm_head(predicting_streams)\n    next_first_stream_logits = predicting_streams_logits[:, 0]\n    self.assertTrue(torch.allclose(next_first_stream_logits[:, :3, :3], expected_slice, atol=0.0001))",
            "@slow\ndef test_pretrained_checkpoint_hidden_states(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\n    model.to(torch_device)\n    encoder_ids = torch.tensor([[17, 96208, 103471, 2]]).to(torch_device)\n    decoder_prev_ids = torch.tensor([[2, 250, 9953, 34, 69489, 1620, 32, 118424, 624, 210, 105, 2913, 1032, 351]]).to(torch_device)\n    output = model(input_ids=encoder_ids, attention_mask=None, encoder_outputs=None, decoder_input_ids=decoder_prev_ids)\n    output_predited_logis = output[0]\n    expected_shape = torch.Size((1, 14, 250012))\n    self.assertEqual(output_predited_logis.shape, expected_shape)\n    expected_slice = torch.tensor([[[-6.3986, -8.2391, 12.5189], [-6.3289, -8.0864, 12.6211], [-6.2418, -8.0445, 12.7968]]]).to(torch_device)\n    self.assertTrue(torch.allclose(output_predited_logis[:, :3, :3], expected_slice, atol=0.0001))\n    encoder_outputs = model.prophetnet.encoder(encoder_ids)[0]\n    expected_encoder_outputs_slice = torch.tensor([[[-1.426, -0.7628, 0.8453], [-1.4719, -0.1391, 0.7807], [-1.7678, 0.0114, 0.4646]]]).to(torch_device)\n    expected_shape_encoder = torch.Size((1, 4, 1024))\n    self.assertEqual(encoder_outputs.shape, expected_shape_encoder)\n    self.assertTrue(torch.allclose(encoder_outputs[:, :3, :3], expected_encoder_outputs_slice, atol=0.0001))\n    decoder_outputs = model.prophetnet.decoder(decoder_prev_ids, encoder_hidden_states=encoder_outputs)\n    predicting_streams = decoder_outputs[1].view(1, model.config.ngram, 14, -1)\n    predicting_streams_logits = model.lm_head(predicting_streams)\n    next_first_stream_logits = predicting_streams_logits[:, 0]\n    self.assertTrue(torch.allclose(next_first_stream_logits[:, :3, :3], expected_slice, atol=0.0001))",
            "@slow\ndef test_pretrained_checkpoint_hidden_states(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\n    model.to(torch_device)\n    encoder_ids = torch.tensor([[17, 96208, 103471, 2]]).to(torch_device)\n    decoder_prev_ids = torch.tensor([[2, 250, 9953, 34, 69489, 1620, 32, 118424, 624, 210, 105, 2913, 1032, 351]]).to(torch_device)\n    output = model(input_ids=encoder_ids, attention_mask=None, encoder_outputs=None, decoder_input_ids=decoder_prev_ids)\n    output_predited_logis = output[0]\n    expected_shape = torch.Size((1, 14, 250012))\n    self.assertEqual(output_predited_logis.shape, expected_shape)\n    expected_slice = torch.tensor([[[-6.3986, -8.2391, 12.5189], [-6.3289, -8.0864, 12.6211], [-6.2418, -8.0445, 12.7968]]]).to(torch_device)\n    self.assertTrue(torch.allclose(output_predited_logis[:, :3, :3], expected_slice, atol=0.0001))\n    encoder_outputs = model.prophetnet.encoder(encoder_ids)[0]\n    expected_encoder_outputs_slice = torch.tensor([[[-1.426, -0.7628, 0.8453], [-1.4719, -0.1391, 0.7807], [-1.7678, 0.0114, 0.4646]]]).to(torch_device)\n    expected_shape_encoder = torch.Size((1, 4, 1024))\n    self.assertEqual(encoder_outputs.shape, expected_shape_encoder)\n    self.assertTrue(torch.allclose(encoder_outputs[:, :3, :3], expected_encoder_outputs_slice, atol=0.0001))\n    decoder_outputs = model.prophetnet.decoder(decoder_prev_ids, encoder_hidden_states=encoder_outputs)\n    predicting_streams = decoder_outputs[1].view(1, model.config.ngram, 14, -1)\n    predicting_streams_logits = model.lm_head(predicting_streams)\n    next_first_stream_logits = predicting_streams_logits[:, 0]\n    self.assertTrue(torch.allclose(next_first_stream_logits[:, :3, :3], expected_slice, atol=0.0001))"
        ]
    },
    {
        "func_name": "test_ntg_hidden_states",
        "original": "@slow\ndef test_ntg_hidden_states(self):\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    model.to(torch_device)\n    encoder_ids = torch.tensor([[17, 96208, 103471, 2]]).to(torch_device)\n    decoder_prev_ids = torch.tensor([[2, 250, 9953, 34, 69489, 1620, 32, 118424, 624, 210, 105, 2913, 1032, 351]]).to(torch_device)\n    output = model(input_ids=encoder_ids, attention_mask=None, encoder_outputs=None, decoder_input_ids=decoder_prev_ids)\n    output_predited_logis = output[0]\n    expected_shape = torch.Size((1, 14, 250012))\n    self.assertEqual(output_predited_logis.shape, expected_shape)\n    expected_slice = torch.tensor([[[-9.2253, -9.7173, -6.3529], [-7.6701, -9.0145, -1.9382], [-8.0195, -7.0004, -0.1523]]]).to(torch_device)\n    self.assertTrue(torch.allclose(output_predited_logis[:, :3, :3], expected_slice, atol=0.0001))",
        "mutated": [
            "@slow\ndef test_ntg_hidden_states(self):\n    if False:\n        i = 10\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    model.to(torch_device)\n    encoder_ids = torch.tensor([[17, 96208, 103471, 2]]).to(torch_device)\n    decoder_prev_ids = torch.tensor([[2, 250, 9953, 34, 69489, 1620, 32, 118424, 624, 210, 105, 2913, 1032, 351]]).to(torch_device)\n    output = model(input_ids=encoder_ids, attention_mask=None, encoder_outputs=None, decoder_input_ids=decoder_prev_ids)\n    output_predited_logis = output[0]\n    expected_shape = torch.Size((1, 14, 250012))\n    self.assertEqual(output_predited_logis.shape, expected_shape)\n    expected_slice = torch.tensor([[[-9.2253, -9.7173, -6.3529], [-7.6701, -9.0145, -1.9382], [-8.0195, -7.0004, -0.1523]]]).to(torch_device)\n    self.assertTrue(torch.allclose(output_predited_logis[:, :3, :3], expected_slice, atol=0.0001))",
            "@slow\ndef test_ntg_hidden_states(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    model.to(torch_device)\n    encoder_ids = torch.tensor([[17, 96208, 103471, 2]]).to(torch_device)\n    decoder_prev_ids = torch.tensor([[2, 250, 9953, 34, 69489, 1620, 32, 118424, 624, 210, 105, 2913, 1032, 351]]).to(torch_device)\n    output = model(input_ids=encoder_ids, attention_mask=None, encoder_outputs=None, decoder_input_ids=decoder_prev_ids)\n    output_predited_logis = output[0]\n    expected_shape = torch.Size((1, 14, 250012))\n    self.assertEqual(output_predited_logis.shape, expected_shape)\n    expected_slice = torch.tensor([[[-9.2253, -9.7173, -6.3529], [-7.6701, -9.0145, -1.9382], [-8.0195, -7.0004, -0.1523]]]).to(torch_device)\n    self.assertTrue(torch.allclose(output_predited_logis[:, :3, :3], expected_slice, atol=0.0001))",
            "@slow\ndef test_ntg_hidden_states(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    model.to(torch_device)\n    encoder_ids = torch.tensor([[17, 96208, 103471, 2]]).to(torch_device)\n    decoder_prev_ids = torch.tensor([[2, 250, 9953, 34, 69489, 1620, 32, 118424, 624, 210, 105, 2913, 1032, 351]]).to(torch_device)\n    output = model(input_ids=encoder_ids, attention_mask=None, encoder_outputs=None, decoder_input_ids=decoder_prev_ids)\n    output_predited_logis = output[0]\n    expected_shape = torch.Size((1, 14, 250012))\n    self.assertEqual(output_predited_logis.shape, expected_shape)\n    expected_slice = torch.tensor([[[-9.2253, -9.7173, -6.3529], [-7.6701, -9.0145, -1.9382], [-8.0195, -7.0004, -0.1523]]]).to(torch_device)\n    self.assertTrue(torch.allclose(output_predited_logis[:, :3, :3], expected_slice, atol=0.0001))",
            "@slow\ndef test_ntg_hidden_states(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    model.to(torch_device)\n    encoder_ids = torch.tensor([[17, 96208, 103471, 2]]).to(torch_device)\n    decoder_prev_ids = torch.tensor([[2, 250, 9953, 34, 69489, 1620, 32, 118424, 624, 210, 105, 2913, 1032, 351]]).to(torch_device)\n    output = model(input_ids=encoder_ids, attention_mask=None, encoder_outputs=None, decoder_input_ids=decoder_prev_ids)\n    output_predited_logis = output[0]\n    expected_shape = torch.Size((1, 14, 250012))\n    self.assertEqual(output_predited_logis.shape, expected_shape)\n    expected_slice = torch.tensor([[[-9.2253, -9.7173, -6.3529], [-7.6701, -9.0145, -1.9382], [-8.0195, -7.0004, -0.1523]]]).to(torch_device)\n    self.assertTrue(torch.allclose(output_predited_logis[:, :3, :3], expected_slice, atol=0.0001))",
            "@slow\ndef test_ntg_hidden_states(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    model.to(torch_device)\n    encoder_ids = torch.tensor([[17, 96208, 103471, 2]]).to(torch_device)\n    decoder_prev_ids = torch.tensor([[2, 250, 9953, 34, 69489, 1620, 32, 118424, 624, 210, 105, 2913, 1032, 351]]).to(torch_device)\n    output = model(input_ids=encoder_ids, attention_mask=None, encoder_outputs=None, decoder_input_ids=decoder_prev_ids)\n    output_predited_logis = output[0]\n    expected_shape = torch.Size((1, 14, 250012))\n    self.assertEqual(output_predited_logis.shape, expected_shape)\n    expected_slice = torch.tensor([[[-9.2253, -9.7173, -6.3529], [-7.6701, -9.0145, -1.9382], [-8.0195, -7.0004, -0.1523]]]).to(torch_device)\n    self.assertTrue(torch.allclose(output_predited_logis[:, :3, :3], expected_slice, atol=0.0001))"
        ]
    },
    {
        "func_name": "test_xprophetnet_ntg_inference",
        "original": "@slow\ndef test_xprophetnet_ntg_inference(self):\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    model.to(torch_device)\n    model.config.max_length = 512\n    tokenizer = XLMProphetNetTokenizer.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    EN_SENTENCE = 'Microsoft Corporation intends to officially end free support for the Windows 7 operating system after January 14, 2020, according to the official portal of the organization. From that day, users of this system will not be able to receive security updates, which could make their computers vulnerable to cyber attacks.'\n    RU_SENTENCE = '\u043e\u0440\u043f\u043e\u0440\u0430\u0446\u0438\u044f Microsoft \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u0430 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e \u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438\u0442\u044c \u0431\u0435\u0441\u043f\u043b\u0430\u0442\u043d\u0443\u044e \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b Windows 7 \u043f\u043e\u0441\u043b\u0435 14 \u044f\u043d\u0432\u0430\u0440\u044f 2020 \u0433\u043e\u0434\u0430, \u0441\u043e\u043e\u0431\u0449\u0430\u0435\u0442\u0441\u044f \u043d\u0430 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u043c \u043f\u043e\u0440\u0442\u0430\u043b\u0435 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u0438 . \u0421 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e \u0434\u043d\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0438 \u044d\u0442\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b \u043d\u0435 \u0441\u043c\u043e\u0433\u0443\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0442\u044c \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u0438, \u0438\u0437-\u0437\u0430 \u0447\u0435\u0433\u043e \u0438\u0445 \u043a\u043e\u043c\u043f\u044c\u044e\u0442\u0435\u0440\u044b \u043c\u043e\u0433\u0443\u0442 \u0441\u0442\u0430\u0442\u044c \u0443\u044f\u0437\u0432\u0438\u043c\u044b\u043c\u0438 \u043a \u043a\u0438\u0431\u0435\u0440\u0430\u0442\u0430\u043a\u0430\u043c.'\n    ZH_SENTENCE = '\u6839\u636e\u8be5\u7ec4\u7ec7\u7684\u5b98\u65b9\u95e8\u6237\u7f51\u7ad9\uff0c\u5fae\u8f6f\u516c\u53f8\u6253\u7b97\u57282020\u5e741\u670814\u65e5\u4e4b\u540e\u6b63\u5f0f\u7ec8\u6b62\u5bf9Windows 7\u64cd\u4f5c\u7cfb\u7edf\u7684\u514d\u8d39\u652f\u6301\u3002\u4ece\u90a3\u65f6\u8d77\uff0c\u8be5\u7cfb\u7edf\u7684\u7528\u6237\u5c06\u65e0\u6cd5\u63a5\u6536\u5b89\u5168\u66f4\u65b0\uff0c\u8fd9\u53ef\u80fd\u4f1a\u4f7f\u4ed6\u4eec\u7684\u8ba1\u7b97\u673a\u5bb9\u6613\u53d7\u5230\u7f51\u7edc\u653b\u51fb\u3002'\n    input_ids = tokenizer([EN_SENTENCE, RU_SENTENCE, ZH_SENTENCE], padding=True, max_length=255, return_tensors='pt').input_ids\n    input_ids = input_ids.to(torch_device)\n    summary_ids = model.generate(input_ids, num_beams=10, length_penalty=1.0, no_repeat_ngram_size=3, early_stopping=True)\n    generated_titles = [tokenizer.decode(g, skip_special_tokens=True) for g in summary_ids]\n    EXPECTED_TITLE_EN = 'Microsoft to end Windows 7 free support after January 14, 2020'\n    EXPECTED_TITLE_RU = 'Microsoft \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u0430 \u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438\u0442\u044c \u0431\u0435\u0441\u043f\u043b\u0430\u0442\u043d\u0443\u044e \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 Windows 7 \u043f\u043e\u0441\u043b\u0435 14 \u044f\u043d\u0432\u0430\u0440\u044f 2020 \u0433\u043e\u0434\u0430'\n    EXPECTED_TITLE_ZH = '\u5fae\u8f6f\u6253\u7b97\u7ec8\u6b62\u5bf9Windows 7\u64cd\u4f5c\u7cfb\u7edf\u7684\u514d\u8d39\u652f\u6301'\n    self.assertListEqual([EXPECTED_TITLE_EN, EXPECTED_TITLE_RU, EXPECTED_TITLE_ZH], generated_titles)\n    summary_ids_beam1 = model.generate(input_ids, num_beams=1, length_penalty=1.0, no_repeat_ngram_size=3, early_stopping=True)\n    generated_titles_beam1_tok = [tokenizer.convert_ids_to_tokens(g, skip_special_tokens=True) for g in summary_ids_beam1]\n    EXPECTED_TITLE_EN_BEAM1_TOK = '\u2581Microsoft \u2581to \u2581end \u2581free \u2581support \u2581for \u2581Windows \u25817'.split(' ')\n    EXPECTED_TITLE_RU_BEAM1_TOK = '\u2581Microsoft \u2581\u043d\u0430\u043c\u0435\u0440\u0435\u043d \u0430 \u2581\u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438 \u0442\u044c \u2581\u0431\u0435\u0441 \u043f\u043b\u0430\u0442 \u043d\u0443\u044e \u2581\u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 \u2581Windows \u25817 \u2581\u043f\u043e\u0441\u043b\u0435 \u258114 \u2581\u044f\u043d\u0432\u0430\u0440\u044f \u25812020 \u2581\u0433\u043e\u0434\u0430'.split(' ')\n    EXPECTED_TITLE_ZH_BEAM1_TOK = '\u5fae\u8f6f \u516c\u53f8 \u6253\u7b97 \u7ec8\u6b62 \u5bf9 Windows \u25817 \u64cd\u4f5c \u7cfb\u7edf\u7684 \u514d\u8d39 \u652f\u6301'.split(' ')\n    self.assertListEqual([EXPECTED_TITLE_EN_BEAM1_TOK, EXPECTED_TITLE_RU_BEAM1_TOK, EXPECTED_TITLE_ZH_BEAM1_TOK], generated_titles_beam1_tok)",
        "mutated": [
            "@slow\ndef test_xprophetnet_ntg_inference(self):\n    if False:\n        i = 10\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    model.to(torch_device)\n    model.config.max_length = 512\n    tokenizer = XLMProphetNetTokenizer.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    EN_SENTENCE = 'Microsoft Corporation intends to officially end free support for the Windows 7 operating system after January 14, 2020, according to the official portal of the organization. From that day, users of this system will not be able to receive security updates, which could make their computers vulnerable to cyber attacks.'\n    RU_SENTENCE = '\u043e\u0440\u043f\u043e\u0440\u0430\u0446\u0438\u044f Microsoft \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u0430 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e \u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438\u0442\u044c \u0431\u0435\u0441\u043f\u043b\u0430\u0442\u043d\u0443\u044e \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b Windows 7 \u043f\u043e\u0441\u043b\u0435 14 \u044f\u043d\u0432\u0430\u0440\u044f 2020 \u0433\u043e\u0434\u0430, \u0441\u043e\u043e\u0431\u0449\u0430\u0435\u0442\u0441\u044f \u043d\u0430 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u043c \u043f\u043e\u0440\u0442\u0430\u043b\u0435 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u0438 . \u0421 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e \u0434\u043d\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0438 \u044d\u0442\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b \u043d\u0435 \u0441\u043c\u043e\u0433\u0443\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0442\u044c \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u0438, \u0438\u0437-\u0437\u0430 \u0447\u0435\u0433\u043e \u0438\u0445 \u043a\u043e\u043c\u043f\u044c\u044e\u0442\u0435\u0440\u044b \u043c\u043e\u0433\u0443\u0442 \u0441\u0442\u0430\u0442\u044c \u0443\u044f\u0437\u0432\u0438\u043c\u044b\u043c\u0438 \u043a \u043a\u0438\u0431\u0435\u0440\u0430\u0442\u0430\u043a\u0430\u043c.'\n    ZH_SENTENCE = '\u6839\u636e\u8be5\u7ec4\u7ec7\u7684\u5b98\u65b9\u95e8\u6237\u7f51\u7ad9\uff0c\u5fae\u8f6f\u516c\u53f8\u6253\u7b97\u57282020\u5e741\u670814\u65e5\u4e4b\u540e\u6b63\u5f0f\u7ec8\u6b62\u5bf9Windows 7\u64cd\u4f5c\u7cfb\u7edf\u7684\u514d\u8d39\u652f\u6301\u3002\u4ece\u90a3\u65f6\u8d77\uff0c\u8be5\u7cfb\u7edf\u7684\u7528\u6237\u5c06\u65e0\u6cd5\u63a5\u6536\u5b89\u5168\u66f4\u65b0\uff0c\u8fd9\u53ef\u80fd\u4f1a\u4f7f\u4ed6\u4eec\u7684\u8ba1\u7b97\u673a\u5bb9\u6613\u53d7\u5230\u7f51\u7edc\u653b\u51fb\u3002'\n    input_ids = tokenizer([EN_SENTENCE, RU_SENTENCE, ZH_SENTENCE], padding=True, max_length=255, return_tensors='pt').input_ids\n    input_ids = input_ids.to(torch_device)\n    summary_ids = model.generate(input_ids, num_beams=10, length_penalty=1.0, no_repeat_ngram_size=3, early_stopping=True)\n    generated_titles = [tokenizer.decode(g, skip_special_tokens=True) for g in summary_ids]\n    EXPECTED_TITLE_EN = 'Microsoft to end Windows 7 free support after January 14, 2020'\n    EXPECTED_TITLE_RU = 'Microsoft \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u0430 \u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438\u0442\u044c \u0431\u0435\u0441\u043f\u043b\u0430\u0442\u043d\u0443\u044e \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 Windows 7 \u043f\u043e\u0441\u043b\u0435 14 \u044f\u043d\u0432\u0430\u0440\u044f 2020 \u0433\u043e\u0434\u0430'\n    EXPECTED_TITLE_ZH = '\u5fae\u8f6f\u6253\u7b97\u7ec8\u6b62\u5bf9Windows 7\u64cd\u4f5c\u7cfb\u7edf\u7684\u514d\u8d39\u652f\u6301'\n    self.assertListEqual([EXPECTED_TITLE_EN, EXPECTED_TITLE_RU, EXPECTED_TITLE_ZH], generated_titles)\n    summary_ids_beam1 = model.generate(input_ids, num_beams=1, length_penalty=1.0, no_repeat_ngram_size=3, early_stopping=True)\n    generated_titles_beam1_tok = [tokenizer.convert_ids_to_tokens(g, skip_special_tokens=True) for g in summary_ids_beam1]\n    EXPECTED_TITLE_EN_BEAM1_TOK = '\u2581Microsoft \u2581to \u2581end \u2581free \u2581support \u2581for \u2581Windows \u25817'.split(' ')\n    EXPECTED_TITLE_RU_BEAM1_TOK = '\u2581Microsoft \u2581\u043d\u0430\u043c\u0435\u0440\u0435\u043d \u0430 \u2581\u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438 \u0442\u044c \u2581\u0431\u0435\u0441 \u043f\u043b\u0430\u0442 \u043d\u0443\u044e \u2581\u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 \u2581Windows \u25817 \u2581\u043f\u043e\u0441\u043b\u0435 \u258114 \u2581\u044f\u043d\u0432\u0430\u0440\u044f \u25812020 \u2581\u0433\u043e\u0434\u0430'.split(' ')\n    EXPECTED_TITLE_ZH_BEAM1_TOK = '\u5fae\u8f6f \u516c\u53f8 \u6253\u7b97 \u7ec8\u6b62 \u5bf9 Windows \u25817 \u64cd\u4f5c \u7cfb\u7edf\u7684 \u514d\u8d39 \u652f\u6301'.split(' ')\n    self.assertListEqual([EXPECTED_TITLE_EN_BEAM1_TOK, EXPECTED_TITLE_RU_BEAM1_TOK, EXPECTED_TITLE_ZH_BEAM1_TOK], generated_titles_beam1_tok)",
            "@slow\ndef test_xprophetnet_ntg_inference(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    model.to(torch_device)\n    model.config.max_length = 512\n    tokenizer = XLMProphetNetTokenizer.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    EN_SENTENCE = 'Microsoft Corporation intends to officially end free support for the Windows 7 operating system after January 14, 2020, according to the official portal of the organization. From that day, users of this system will not be able to receive security updates, which could make their computers vulnerable to cyber attacks.'\n    RU_SENTENCE = '\u043e\u0440\u043f\u043e\u0440\u0430\u0446\u0438\u044f Microsoft \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u0430 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e \u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438\u0442\u044c \u0431\u0435\u0441\u043f\u043b\u0430\u0442\u043d\u0443\u044e \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b Windows 7 \u043f\u043e\u0441\u043b\u0435 14 \u044f\u043d\u0432\u0430\u0440\u044f 2020 \u0433\u043e\u0434\u0430, \u0441\u043e\u043e\u0431\u0449\u0430\u0435\u0442\u0441\u044f \u043d\u0430 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u043c \u043f\u043e\u0440\u0442\u0430\u043b\u0435 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u0438 . \u0421 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e \u0434\u043d\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0438 \u044d\u0442\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b \u043d\u0435 \u0441\u043c\u043e\u0433\u0443\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0442\u044c \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u0438, \u0438\u0437-\u0437\u0430 \u0447\u0435\u0433\u043e \u0438\u0445 \u043a\u043e\u043c\u043f\u044c\u044e\u0442\u0435\u0440\u044b \u043c\u043e\u0433\u0443\u0442 \u0441\u0442\u0430\u0442\u044c \u0443\u044f\u0437\u0432\u0438\u043c\u044b\u043c\u0438 \u043a \u043a\u0438\u0431\u0435\u0440\u0430\u0442\u0430\u043a\u0430\u043c.'\n    ZH_SENTENCE = '\u6839\u636e\u8be5\u7ec4\u7ec7\u7684\u5b98\u65b9\u95e8\u6237\u7f51\u7ad9\uff0c\u5fae\u8f6f\u516c\u53f8\u6253\u7b97\u57282020\u5e741\u670814\u65e5\u4e4b\u540e\u6b63\u5f0f\u7ec8\u6b62\u5bf9Windows 7\u64cd\u4f5c\u7cfb\u7edf\u7684\u514d\u8d39\u652f\u6301\u3002\u4ece\u90a3\u65f6\u8d77\uff0c\u8be5\u7cfb\u7edf\u7684\u7528\u6237\u5c06\u65e0\u6cd5\u63a5\u6536\u5b89\u5168\u66f4\u65b0\uff0c\u8fd9\u53ef\u80fd\u4f1a\u4f7f\u4ed6\u4eec\u7684\u8ba1\u7b97\u673a\u5bb9\u6613\u53d7\u5230\u7f51\u7edc\u653b\u51fb\u3002'\n    input_ids = tokenizer([EN_SENTENCE, RU_SENTENCE, ZH_SENTENCE], padding=True, max_length=255, return_tensors='pt').input_ids\n    input_ids = input_ids.to(torch_device)\n    summary_ids = model.generate(input_ids, num_beams=10, length_penalty=1.0, no_repeat_ngram_size=3, early_stopping=True)\n    generated_titles = [tokenizer.decode(g, skip_special_tokens=True) for g in summary_ids]\n    EXPECTED_TITLE_EN = 'Microsoft to end Windows 7 free support after January 14, 2020'\n    EXPECTED_TITLE_RU = 'Microsoft \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u0430 \u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438\u0442\u044c \u0431\u0435\u0441\u043f\u043b\u0430\u0442\u043d\u0443\u044e \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 Windows 7 \u043f\u043e\u0441\u043b\u0435 14 \u044f\u043d\u0432\u0430\u0440\u044f 2020 \u0433\u043e\u0434\u0430'\n    EXPECTED_TITLE_ZH = '\u5fae\u8f6f\u6253\u7b97\u7ec8\u6b62\u5bf9Windows 7\u64cd\u4f5c\u7cfb\u7edf\u7684\u514d\u8d39\u652f\u6301'\n    self.assertListEqual([EXPECTED_TITLE_EN, EXPECTED_TITLE_RU, EXPECTED_TITLE_ZH], generated_titles)\n    summary_ids_beam1 = model.generate(input_ids, num_beams=1, length_penalty=1.0, no_repeat_ngram_size=3, early_stopping=True)\n    generated_titles_beam1_tok = [tokenizer.convert_ids_to_tokens(g, skip_special_tokens=True) for g in summary_ids_beam1]\n    EXPECTED_TITLE_EN_BEAM1_TOK = '\u2581Microsoft \u2581to \u2581end \u2581free \u2581support \u2581for \u2581Windows \u25817'.split(' ')\n    EXPECTED_TITLE_RU_BEAM1_TOK = '\u2581Microsoft \u2581\u043d\u0430\u043c\u0435\u0440\u0435\u043d \u0430 \u2581\u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438 \u0442\u044c \u2581\u0431\u0435\u0441 \u043f\u043b\u0430\u0442 \u043d\u0443\u044e \u2581\u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 \u2581Windows \u25817 \u2581\u043f\u043e\u0441\u043b\u0435 \u258114 \u2581\u044f\u043d\u0432\u0430\u0440\u044f \u25812020 \u2581\u0433\u043e\u0434\u0430'.split(' ')\n    EXPECTED_TITLE_ZH_BEAM1_TOK = '\u5fae\u8f6f \u516c\u53f8 \u6253\u7b97 \u7ec8\u6b62 \u5bf9 Windows \u25817 \u64cd\u4f5c \u7cfb\u7edf\u7684 \u514d\u8d39 \u652f\u6301'.split(' ')\n    self.assertListEqual([EXPECTED_TITLE_EN_BEAM1_TOK, EXPECTED_TITLE_RU_BEAM1_TOK, EXPECTED_TITLE_ZH_BEAM1_TOK], generated_titles_beam1_tok)",
            "@slow\ndef test_xprophetnet_ntg_inference(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    model.to(torch_device)\n    model.config.max_length = 512\n    tokenizer = XLMProphetNetTokenizer.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    EN_SENTENCE = 'Microsoft Corporation intends to officially end free support for the Windows 7 operating system after January 14, 2020, according to the official portal of the organization. From that day, users of this system will not be able to receive security updates, which could make their computers vulnerable to cyber attacks.'\n    RU_SENTENCE = '\u043e\u0440\u043f\u043e\u0440\u0430\u0446\u0438\u044f Microsoft \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u0430 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e \u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438\u0442\u044c \u0431\u0435\u0441\u043f\u043b\u0430\u0442\u043d\u0443\u044e \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b Windows 7 \u043f\u043e\u0441\u043b\u0435 14 \u044f\u043d\u0432\u0430\u0440\u044f 2020 \u0433\u043e\u0434\u0430, \u0441\u043e\u043e\u0431\u0449\u0430\u0435\u0442\u0441\u044f \u043d\u0430 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u043c \u043f\u043e\u0440\u0442\u0430\u043b\u0435 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u0438 . \u0421 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e \u0434\u043d\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0438 \u044d\u0442\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b \u043d\u0435 \u0441\u043c\u043e\u0433\u0443\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0442\u044c \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u0438, \u0438\u0437-\u0437\u0430 \u0447\u0435\u0433\u043e \u0438\u0445 \u043a\u043e\u043c\u043f\u044c\u044e\u0442\u0435\u0440\u044b \u043c\u043e\u0433\u0443\u0442 \u0441\u0442\u0430\u0442\u044c \u0443\u044f\u0437\u0432\u0438\u043c\u044b\u043c\u0438 \u043a \u043a\u0438\u0431\u0435\u0440\u0430\u0442\u0430\u043a\u0430\u043c.'\n    ZH_SENTENCE = '\u6839\u636e\u8be5\u7ec4\u7ec7\u7684\u5b98\u65b9\u95e8\u6237\u7f51\u7ad9\uff0c\u5fae\u8f6f\u516c\u53f8\u6253\u7b97\u57282020\u5e741\u670814\u65e5\u4e4b\u540e\u6b63\u5f0f\u7ec8\u6b62\u5bf9Windows 7\u64cd\u4f5c\u7cfb\u7edf\u7684\u514d\u8d39\u652f\u6301\u3002\u4ece\u90a3\u65f6\u8d77\uff0c\u8be5\u7cfb\u7edf\u7684\u7528\u6237\u5c06\u65e0\u6cd5\u63a5\u6536\u5b89\u5168\u66f4\u65b0\uff0c\u8fd9\u53ef\u80fd\u4f1a\u4f7f\u4ed6\u4eec\u7684\u8ba1\u7b97\u673a\u5bb9\u6613\u53d7\u5230\u7f51\u7edc\u653b\u51fb\u3002'\n    input_ids = tokenizer([EN_SENTENCE, RU_SENTENCE, ZH_SENTENCE], padding=True, max_length=255, return_tensors='pt').input_ids\n    input_ids = input_ids.to(torch_device)\n    summary_ids = model.generate(input_ids, num_beams=10, length_penalty=1.0, no_repeat_ngram_size=3, early_stopping=True)\n    generated_titles = [tokenizer.decode(g, skip_special_tokens=True) for g in summary_ids]\n    EXPECTED_TITLE_EN = 'Microsoft to end Windows 7 free support after January 14, 2020'\n    EXPECTED_TITLE_RU = 'Microsoft \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u0430 \u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438\u0442\u044c \u0431\u0435\u0441\u043f\u043b\u0430\u0442\u043d\u0443\u044e \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 Windows 7 \u043f\u043e\u0441\u043b\u0435 14 \u044f\u043d\u0432\u0430\u0440\u044f 2020 \u0433\u043e\u0434\u0430'\n    EXPECTED_TITLE_ZH = '\u5fae\u8f6f\u6253\u7b97\u7ec8\u6b62\u5bf9Windows 7\u64cd\u4f5c\u7cfb\u7edf\u7684\u514d\u8d39\u652f\u6301'\n    self.assertListEqual([EXPECTED_TITLE_EN, EXPECTED_TITLE_RU, EXPECTED_TITLE_ZH], generated_titles)\n    summary_ids_beam1 = model.generate(input_ids, num_beams=1, length_penalty=1.0, no_repeat_ngram_size=3, early_stopping=True)\n    generated_titles_beam1_tok = [tokenizer.convert_ids_to_tokens(g, skip_special_tokens=True) for g in summary_ids_beam1]\n    EXPECTED_TITLE_EN_BEAM1_TOK = '\u2581Microsoft \u2581to \u2581end \u2581free \u2581support \u2581for \u2581Windows \u25817'.split(' ')\n    EXPECTED_TITLE_RU_BEAM1_TOK = '\u2581Microsoft \u2581\u043d\u0430\u043c\u0435\u0440\u0435\u043d \u0430 \u2581\u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438 \u0442\u044c \u2581\u0431\u0435\u0441 \u043f\u043b\u0430\u0442 \u043d\u0443\u044e \u2581\u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 \u2581Windows \u25817 \u2581\u043f\u043e\u0441\u043b\u0435 \u258114 \u2581\u044f\u043d\u0432\u0430\u0440\u044f \u25812020 \u2581\u0433\u043e\u0434\u0430'.split(' ')\n    EXPECTED_TITLE_ZH_BEAM1_TOK = '\u5fae\u8f6f \u516c\u53f8 \u6253\u7b97 \u7ec8\u6b62 \u5bf9 Windows \u25817 \u64cd\u4f5c \u7cfb\u7edf\u7684 \u514d\u8d39 \u652f\u6301'.split(' ')\n    self.assertListEqual([EXPECTED_TITLE_EN_BEAM1_TOK, EXPECTED_TITLE_RU_BEAM1_TOK, EXPECTED_TITLE_ZH_BEAM1_TOK], generated_titles_beam1_tok)",
            "@slow\ndef test_xprophetnet_ntg_inference(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    model.to(torch_device)\n    model.config.max_length = 512\n    tokenizer = XLMProphetNetTokenizer.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    EN_SENTENCE = 'Microsoft Corporation intends to officially end free support for the Windows 7 operating system after January 14, 2020, according to the official portal of the organization. From that day, users of this system will not be able to receive security updates, which could make their computers vulnerable to cyber attacks.'\n    RU_SENTENCE = '\u043e\u0440\u043f\u043e\u0440\u0430\u0446\u0438\u044f Microsoft \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u0430 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e \u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438\u0442\u044c \u0431\u0435\u0441\u043f\u043b\u0430\u0442\u043d\u0443\u044e \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b Windows 7 \u043f\u043e\u0441\u043b\u0435 14 \u044f\u043d\u0432\u0430\u0440\u044f 2020 \u0433\u043e\u0434\u0430, \u0441\u043e\u043e\u0431\u0449\u0430\u0435\u0442\u0441\u044f \u043d\u0430 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u043c \u043f\u043e\u0440\u0442\u0430\u043b\u0435 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u0438 . \u0421 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e \u0434\u043d\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0438 \u044d\u0442\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b \u043d\u0435 \u0441\u043c\u043e\u0433\u0443\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0442\u044c \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u0438, \u0438\u0437-\u0437\u0430 \u0447\u0435\u0433\u043e \u0438\u0445 \u043a\u043e\u043c\u043f\u044c\u044e\u0442\u0435\u0440\u044b \u043c\u043e\u0433\u0443\u0442 \u0441\u0442\u0430\u0442\u044c \u0443\u044f\u0437\u0432\u0438\u043c\u044b\u043c\u0438 \u043a \u043a\u0438\u0431\u0435\u0440\u0430\u0442\u0430\u043a\u0430\u043c.'\n    ZH_SENTENCE = '\u6839\u636e\u8be5\u7ec4\u7ec7\u7684\u5b98\u65b9\u95e8\u6237\u7f51\u7ad9\uff0c\u5fae\u8f6f\u516c\u53f8\u6253\u7b97\u57282020\u5e741\u670814\u65e5\u4e4b\u540e\u6b63\u5f0f\u7ec8\u6b62\u5bf9Windows 7\u64cd\u4f5c\u7cfb\u7edf\u7684\u514d\u8d39\u652f\u6301\u3002\u4ece\u90a3\u65f6\u8d77\uff0c\u8be5\u7cfb\u7edf\u7684\u7528\u6237\u5c06\u65e0\u6cd5\u63a5\u6536\u5b89\u5168\u66f4\u65b0\uff0c\u8fd9\u53ef\u80fd\u4f1a\u4f7f\u4ed6\u4eec\u7684\u8ba1\u7b97\u673a\u5bb9\u6613\u53d7\u5230\u7f51\u7edc\u653b\u51fb\u3002'\n    input_ids = tokenizer([EN_SENTENCE, RU_SENTENCE, ZH_SENTENCE], padding=True, max_length=255, return_tensors='pt').input_ids\n    input_ids = input_ids.to(torch_device)\n    summary_ids = model.generate(input_ids, num_beams=10, length_penalty=1.0, no_repeat_ngram_size=3, early_stopping=True)\n    generated_titles = [tokenizer.decode(g, skip_special_tokens=True) for g in summary_ids]\n    EXPECTED_TITLE_EN = 'Microsoft to end Windows 7 free support after January 14, 2020'\n    EXPECTED_TITLE_RU = 'Microsoft \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u0430 \u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438\u0442\u044c \u0431\u0435\u0441\u043f\u043b\u0430\u0442\u043d\u0443\u044e \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 Windows 7 \u043f\u043e\u0441\u043b\u0435 14 \u044f\u043d\u0432\u0430\u0440\u044f 2020 \u0433\u043e\u0434\u0430'\n    EXPECTED_TITLE_ZH = '\u5fae\u8f6f\u6253\u7b97\u7ec8\u6b62\u5bf9Windows 7\u64cd\u4f5c\u7cfb\u7edf\u7684\u514d\u8d39\u652f\u6301'\n    self.assertListEqual([EXPECTED_TITLE_EN, EXPECTED_TITLE_RU, EXPECTED_TITLE_ZH], generated_titles)\n    summary_ids_beam1 = model.generate(input_ids, num_beams=1, length_penalty=1.0, no_repeat_ngram_size=3, early_stopping=True)\n    generated_titles_beam1_tok = [tokenizer.convert_ids_to_tokens(g, skip_special_tokens=True) for g in summary_ids_beam1]\n    EXPECTED_TITLE_EN_BEAM1_TOK = '\u2581Microsoft \u2581to \u2581end \u2581free \u2581support \u2581for \u2581Windows \u25817'.split(' ')\n    EXPECTED_TITLE_RU_BEAM1_TOK = '\u2581Microsoft \u2581\u043d\u0430\u043c\u0435\u0440\u0435\u043d \u0430 \u2581\u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438 \u0442\u044c \u2581\u0431\u0435\u0441 \u043f\u043b\u0430\u0442 \u043d\u0443\u044e \u2581\u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 \u2581Windows \u25817 \u2581\u043f\u043e\u0441\u043b\u0435 \u258114 \u2581\u044f\u043d\u0432\u0430\u0440\u044f \u25812020 \u2581\u0433\u043e\u0434\u0430'.split(' ')\n    EXPECTED_TITLE_ZH_BEAM1_TOK = '\u5fae\u8f6f \u516c\u53f8 \u6253\u7b97 \u7ec8\u6b62 \u5bf9 Windows \u25817 \u64cd\u4f5c \u7cfb\u7edf\u7684 \u514d\u8d39 \u652f\u6301'.split(' ')\n    self.assertListEqual([EXPECTED_TITLE_EN_BEAM1_TOK, EXPECTED_TITLE_RU_BEAM1_TOK, EXPECTED_TITLE_ZH_BEAM1_TOK], generated_titles_beam1_tok)",
            "@slow\ndef test_xprophetnet_ntg_inference(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    model = XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    model.to(torch_device)\n    model.config.max_length = 512\n    tokenizer = XLMProphetNetTokenizer.from_pretrained('microsoft/xprophetnet-large-wiki100-cased-xglue-ntg')\n    EN_SENTENCE = 'Microsoft Corporation intends to officially end free support for the Windows 7 operating system after January 14, 2020, according to the official portal of the organization. From that day, users of this system will not be able to receive security updates, which could make their computers vulnerable to cyber attacks.'\n    RU_SENTENCE = '\u043e\u0440\u043f\u043e\u0440\u0430\u0446\u0438\u044f Microsoft \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u0430 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e \u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438\u0442\u044c \u0431\u0435\u0441\u043f\u043b\u0430\u0442\u043d\u0443\u044e \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b Windows 7 \u043f\u043e\u0441\u043b\u0435 14 \u044f\u043d\u0432\u0430\u0440\u044f 2020 \u0433\u043e\u0434\u0430, \u0441\u043e\u043e\u0431\u0449\u0430\u0435\u0442\u0441\u044f \u043d\u0430 \u043e\u0444\u0438\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u043c \u043f\u043e\u0440\u0442\u0430\u043b\u0435 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u0438 . \u0421 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e \u0434\u043d\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0438 \u044d\u0442\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b \u043d\u0435 \u0441\u043c\u043e\u0433\u0443\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0442\u044c \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u0438, \u0438\u0437-\u0437\u0430 \u0447\u0435\u0433\u043e \u0438\u0445 \u043a\u043e\u043c\u043f\u044c\u044e\u0442\u0435\u0440\u044b \u043c\u043e\u0433\u0443\u0442 \u0441\u0442\u0430\u0442\u044c \u0443\u044f\u0437\u0432\u0438\u043c\u044b\u043c\u0438 \u043a \u043a\u0438\u0431\u0435\u0440\u0430\u0442\u0430\u043a\u0430\u043c.'\n    ZH_SENTENCE = '\u6839\u636e\u8be5\u7ec4\u7ec7\u7684\u5b98\u65b9\u95e8\u6237\u7f51\u7ad9\uff0c\u5fae\u8f6f\u516c\u53f8\u6253\u7b97\u57282020\u5e741\u670814\u65e5\u4e4b\u540e\u6b63\u5f0f\u7ec8\u6b62\u5bf9Windows 7\u64cd\u4f5c\u7cfb\u7edf\u7684\u514d\u8d39\u652f\u6301\u3002\u4ece\u90a3\u65f6\u8d77\uff0c\u8be5\u7cfb\u7edf\u7684\u7528\u6237\u5c06\u65e0\u6cd5\u63a5\u6536\u5b89\u5168\u66f4\u65b0\uff0c\u8fd9\u53ef\u80fd\u4f1a\u4f7f\u4ed6\u4eec\u7684\u8ba1\u7b97\u673a\u5bb9\u6613\u53d7\u5230\u7f51\u7edc\u653b\u51fb\u3002'\n    input_ids = tokenizer([EN_SENTENCE, RU_SENTENCE, ZH_SENTENCE], padding=True, max_length=255, return_tensors='pt').input_ids\n    input_ids = input_ids.to(torch_device)\n    summary_ids = model.generate(input_ids, num_beams=10, length_penalty=1.0, no_repeat_ngram_size=3, early_stopping=True)\n    generated_titles = [tokenizer.decode(g, skip_special_tokens=True) for g in summary_ids]\n    EXPECTED_TITLE_EN = 'Microsoft to end Windows 7 free support after January 14, 2020'\n    EXPECTED_TITLE_RU = 'Microsoft \u043d\u0430\u043c\u0435\u0440\u0435\u043d\u0430 \u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438\u0442\u044c \u0431\u0435\u0441\u043f\u043b\u0430\u0442\u043d\u0443\u044e \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 Windows 7 \u043f\u043e\u0441\u043b\u0435 14 \u044f\u043d\u0432\u0430\u0440\u044f 2020 \u0433\u043e\u0434\u0430'\n    EXPECTED_TITLE_ZH = '\u5fae\u8f6f\u6253\u7b97\u7ec8\u6b62\u5bf9Windows 7\u64cd\u4f5c\u7cfb\u7edf\u7684\u514d\u8d39\u652f\u6301'\n    self.assertListEqual([EXPECTED_TITLE_EN, EXPECTED_TITLE_RU, EXPECTED_TITLE_ZH], generated_titles)\n    summary_ids_beam1 = model.generate(input_ids, num_beams=1, length_penalty=1.0, no_repeat_ngram_size=3, early_stopping=True)\n    generated_titles_beam1_tok = [tokenizer.convert_ids_to_tokens(g, skip_special_tokens=True) for g in summary_ids_beam1]\n    EXPECTED_TITLE_EN_BEAM1_TOK = '\u2581Microsoft \u2581to \u2581end \u2581free \u2581support \u2581for \u2581Windows \u25817'.split(' ')\n    EXPECTED_TITLE_RU_BEAM1_TOK = '\u2581Microsoft \u2581\u043d\u0430\u043c\u0435\u0440\u0435\u043d \u0430 \u2581\u043f\u0440\u0435\u043a\u0440\u0430\u0442\u0438 \u0442\u044c \u2581\u0431\u0435\u0441 \u043f\u043b\u0430\u0442 \u043d\u0443\u044e \u2581\u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 \u2581Windows \u25817 \u2581\u043f\u043e\u0441\u043b\u0435 \u258114 \u2581\u044f\u043d\u0432\u0430\u0440\u044f \u25812020 \u2581\u0433\u043e\u0434\u0430'.split(' ')\n    EXPECTED_TITLE_ZH_BEAM1_TOK = '\u5fae\u8f6f \u516c\u53f8 \u6253\u7b97 \u7ec8\u6b62 \u5bf9 Windows \u25817 \u64cd\u4f5c \u7cfb\u7edf\u7684 \u514d\u8d39 \u652f\u6301'.split(' ')\n    self.assertListEqual([EXPECTED_TITLE_EN_BEAM1_TOK, EXPECTED_TITLE_RU_BEAM1_TOK, EXPECTED_TITLE_ZH_BEAM1_TOK], generated_titles_beam1_tok)"
        ]
    }
]