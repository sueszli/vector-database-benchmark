[
    {
        "func_name": "test_basic_conversion",
        "original": "def test_basic_conversion():\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    u2 = i.get_item_vector(0)\n    v2 = i.get_item_vector(1)\n    assert numpy.dot(u - u2, u - u2) == pytest.approx(0.0)\n    assert numpy.dot(v - v2, v - v2) == pytest.approx(0.0)\n    assert i.get_distance(0, 0) == pytest.approx(0.0)\n    assert i.get_distance(1, 1) == pytest.approx(0.0)\n    assert i.get_distance(0, 1) == pytest.approx(numpy.dot(u - v, u - v))\n    assert i.get_distance(1, 0) == pytest.approx(numpy.dot(u - v, u - v))",
        "mutated": [
            "def test_basic_conversion():\n    if False:\n        i = 10\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    u2 = i.get_item_vector(0)\n    v2 = i.get_item_vector(1)\n    assert numpy.dot(u - u2, u - u2) == pytest.approx(0.0)\n    assert numpy.dot(v - v2, v - v2) == pytest.approx(0.0)\n    assert i.get_distance(0, 0) == pytest.approx(0.0)\n    assert i.get_distance(1, 1) == pytest.approx(0.0)\n    assert i.get_distance(0, 1) == pytest.approx(numpy.dot(u - v, u - v))\n    assert i.get_distance(1, 0) == pytest.approx(numpy.dot(u - v, u - v))",
            "def test_basic_conversion():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    u2 = i.get_item_vector(0)\n    v2 = i.get_item_vector(1)\n    assert numpy.dot(u - u2, u - u2) == pytest.approx(0.0)\n    assert numpy.dot(v - v2, v - v2) == pytest.approx(0.0)\n    assert i.get_distance(0, 0) == pytest.approx(0.0)\n    assert i.get_distance(1, 1) == pytest.approx(0.0)\n    assert i.get_distance(0, 1) == pytest.approx(numpy.dot(u - v, u - v))\n    assert i.get_distance(1, 0) == pytest.approx(numpy.dot(u - v, u - v))",
            "def test_basic_conversion():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    u2 = i.get_item_vector(0)\n    v2 = i.get_item_vector(1)\n    assert numpy.dot(u - u2, u - u2) == pytest.approx(0.0)\n    assert numpy.dot(v - v2, v - v2) == pytest.approx(0.0)\n    assert i.get_distance(0, 0) == pytest.approx(0.0)\n    assert i.get_distance(1, 1) == pytest.approx(0.0)\n    assert i.get_distance(0, 1) == pytest.approx(numpy.dot(u - v, u - v))\n    assert i.get_distance(1, 0) == pytest.approx(numpy.dot(u - v, u - v))",
            "def test_basic_conversion():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    u2 = i.get_item_vector(0)\n    v2 = i.get_item_vector(1)\n    assert numpy.dot(u - u2, u - u2) == pytest.approx(0.0)\n    assert numpy.dot(v - v2, v - v2) == pytest.approx(0.0)\n    assert i.get_distance(0, 0) == pytest.approx(0.0)\n    assert i.get_distance(1, 1) == pytest.approx(0.0)\n    assert i.get_distance(0, 1) == pytest.approx(numpy.dot(u - v, u - v))\n    assert i.get_distance(1, 0) == pytest.approx(numpy.dot(u - v, u - v))",
            "def test_basic_conversion():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    u2 = i.get_item_vector(0)\n    v2 = i.get_item_vector(1)\n    assert numpy.dot(u - u2, u - u2) == pytest.approx(0.0)\n    assert numpy.dot(v - v2, v - v2) == pytest.approx(0.0)\n    assert i.get_distance(0, 0) == pytest.approx(0.0)\n    assert i.get_distance(1, 1) == pytest.approx(0.0)\n    assert i.get_distance(0, 1) == pytest.approx(numpy.dot(u - v, u - v))\n    assert i.get_distance(1, 0) == pytest.approx(numpy.dot(u - v, u - v))"
        ]
    },
    {
        "func_name": "test_basic_nns",
        "original": "def test_basic_nns():\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    i.build(10)\n    assert i.get_nns_by_item(0, 99) == [0, 1]\n    assert i.get_nns_by_item(1, 99) == [1, 0]\n    (rs, ds) = i.get_nns_by_item(0, 99, include_distances=True)\n    assert rs == [0, 1]\n    assert ds[0] == pytest.approx(0)\n    assert ds[1] == pytest.approx(numpy.dot(u - v, u - v))",
        "mutated": [
            "def test_basic_nns():\n    if False:\n        i = 10\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    i.build(10)\n    assert i.get_nns_by_item(0, 99) == [0, 1]\n    assert i.get_nns_by_item(1, 99) == [1, 0]\n    (rs, ds) = i.get_nns_by_item(0, 99, include_distances=True)\n    assert rs == [0, 1]\n    assert ds[0] == pytest.approx(0)\n    assert ds[1] == pytest.approx(numpy.dot(u - v, u - v))",
            "def test_basic_nns():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    i.build(10)\n    assert i.get_nns_by_item(0, 99) == [0, 1]\n    assert i.get_nns_by_item(1, 99) == [1, 0]\n    (rs, ds) = i.get_nns_by_item(0, 99, include_distances=True)\n    assert rs == [0, 1]\n    assert ds[0] == pytest.approx(0)\n    assert ds[1] == pytest.approx(numpy.dot(u - v, u - v))",
            "def test_basic_nns():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    i.build(10)\n    assert i.get_nns_by_item(0, 99) == [0, 1]\n    assert i.get_nns_by_item(1, 99) == [1, 0]\n    (rs, ds) = i.get_nns_by_item(0, 99, include_distances=True)\n    assert rs == [0, 1]\n    assert ds[0] == pytest.approx(0)\n    assert ds[1] == pytest.approx(numpy.dot(u - v, u - v))",
            "def test_basic_nns():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    i.build(10)\n    assert i.get_nns_by_item(0, 99) == [0, 1]\n    assert i.get_nns_by_item(1, 99) == [1, 0]\n    (rs, ds) = i.get_nns_by_item(0, 99, include_distances=True)\n    assert rs == [0, 1]\n    assert ds[0] == pytest.approx(0)\n    assert ds[1] == pytest.approx(numpy.dot(u - v, u - v))",
            "def test_basic_nns():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    i.build(10)\n    assert i.get_nns_by_item(0, 99) == [0, 1]\n    assert i.get_nns_by_item(1, 99) == [1, 0]\n    (rs, ds) = i.get_nns_by_item(0, 99, include_distances=True)\n    assert rs == [0, 1]\n    assert ds[0] == pytest.approx(0)\n    assert ds[1] == pytest.approx(numpy.dot(u - v, u - v))"
        ]
    },
    {
        "func_name": "test_save_load",
        "original": "def test_save_load():\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    i.build(10)\n    i.save('blah.ann')\n    j = AnnoyIndex(f, 'hamming')\n    j.load('blah.ann')\n    (rs, ds) = j.get_nns_by_item(0, 99, include_distances=True)\n    assert rs == [0, 1]\n    assert ds[0] == pytest.approx(0)\n    assert ds[1] == pytest.approx(numpy.dot(u - v, u - v))",
        "mutated": [
            "def test_save_load():\n    if False:\n        i = 10\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    i.build(10)\n    i.save('blah.ann')\n    j = AnnoyIndex(f, 'hamming')\n    j.load('blah.ann')\n    (rs, ds) = j.get_nns_by_item(0, 99, include_distances=True)\n    assert rs == [0, 1]\n    assert ds[0] == pytest.approx(0)\n    assert ds[1] == pytest.approx(numpy.dot(u - v, u - v))",
            "def test_save_load():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    i.build(10)\n    i.save('blah.ann')\n    j = AnnoyIndex(f, 'hamming')\n    j.load('blah.ann')\n    (rs, ds) = j.get_nns_by_item(0, 99, include_distances=True)\n    assert rs == [0, 1]\n    assert ds[0] == pytest.approx(0)\n    assert ds[1] == pytest.approx(numpy.dot(u - v, u - v))",
            "def test_save_load():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    i.build(10)\n    i.save('blah.ann')\n    j = AnnoyIndex(f, 'hamming')\n    j.load('blah.ann')\n    (rs, ds) = j.get_nns_by_item(0, 99, include_distances=True)\n    assert rs == [0, 1]\n    assert ds[0] == pytest.approx(0)\n    assert ds[1] == pytest.approx(numpy.dot(u - v, u - v))",
            "def test_save_load():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    i.build(10)\n    i.save('blah.ann')\n    j = AnnoyIndex(f, 'hamming')\n    j.load('blah.ann')\n    (rs, ds) = j.get_nns_by_item(0, 99, include_distances=True)\n    assert rs == [0, 1]\n    assert ds[0] == pytest.approx(0)\n    assert ds[1] == pytest.approx(numpy.dot(u - v, u - v))",
            "def test_save_load():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    f = 100\n    i = AnnoyIndex(f, 'hamming')\n    u = numpy.random.binomial(1, 0.5, f)\n    v = numpy.random.binomial(1, 0.5, f)\n    i.add_item(0, u)\n    i.add_item(1, v)\n    i.build(10)\n    i.save('blah.ann')\n    j = AnnoyIndex(f, 'hamming')\n    j.load('blah.ann')\n    (rs, ds) = j.get_nns_by_item(0, 99, include_distances=True)\n    assert rs == [0, 1]\n    assert ds[0] == pytest.approx(0)\n    assert ds[1] == pytest.approx(numpy.dot(u - v, u - v))"
        ]
    },
    {
        "func_name": "test_many_vectors",
        "original": "def test_many_vectors():\n    f = 10\n    i = AnnoyIndex(f, 'hamming')\n    for x in range(100000):\n        i.add_item(x, numpy.random.binomial(1, 0.5, f))\n    i.build(10)\n    (rs, ds) = i.get_nns_by_vector([0] * f, 10000, include_distances=True)\n    assert min(ds) >= 0\n    assert max(ds) <= f\n    dists = []\n    for x in range(1000):\n        (rs, ds) = i.get_nns_by_vector(numpy.random.binomial(1, 0.5, f), 1, search_k=1000, include_distances=True)\n        dists.append(ds[0])\n    avg_dist = 1.0 * sum(dists) / len(dists)\n    assert avg_dist <= 0.42",
        "mutated": [
            "def test_many_vectors():\n    if False:\n        i = 10\n    f = 10\n    i = AnnoyIndex(f, 'hamming')\n    for x in range(100000):\n        i.add_item(x, numpy.random.binomial(1, 0.5, f))\n    i.build(10)\n    (rs, ds) = i.get_nns_by_vector([0] * f, 10000, include_distances=True)\n    assert min(ds) >= 0\n    assert max(ds) <= f\n    dists = []\n    for x in range(1000):\n        (rs, ds) = i.get_nns_by_vector(numpy.random.binomial(1, 0.5, f), 1, search_k=1000, include_distances=True)\n        dists.append(ds[0])\n    avg_dist = 1.0 * sum(dists) / len(dists)\n    assert avg_dist <= 0.42",
            "def test_many_vectors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    f = 10\n    i = AnnoyIndex(f, 'hamming')\n    for x in range(100000):\n        i.add_item(x, numpy.random.binomial(1, 0.5, f))\n    i.build(10)\n    (rs, ds) = i.get_nns_by_vector([0] * f, 10000, include_distances=True)\n    assert min(ds) >= 0\n    assert max(ds) <= f\n    dists = []\n    for x in range(1000):\n        (rs, ds) = i.get_nns_by_vector(numpy.random.binomial(1, 0.5, f), 1, search_k=1000, include_distances=True)\n        dists.append(ds[0])\n    avg_dist = 1.0 * sum(dists) / len(dists)\n    assert avg_dist <= 0.42",
            "def test_many_vectors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    f = 10\n    i = AnnoyIndex(f, 'hamming')\n    for x in range(100000):\n        i.add_item(x, numpy.random.binomial(1, 0.5, f))\n    i.build(10)\n    (rs, ds) = i.get_nns_by_vector([0] * f, 10000, include_distances=True)\n    assert min(ds) >= 0\n    assert max(ds) <= f\n    dists = []\n    for x in range(1000):\n        (rs, ds) = i.get_nns_by_vector(numpy.random.binomial(1, 0.5, f), 1, search_k=1000, include_distances=True)\n        dists.append(ds[0])\n    avg_dist = 1.0 * sum(dists) / len(dists)\n    assert avg_dist <= 0.42",
            "def test_many_vectors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    f = 10\n    i = AnnoyIndex(f, 'hamming')\n    for x in range(100000):\n        i.add_item(x, numpy.random.binomial(1, 0.5, f))\n    i.build(10)\n    (rs, ds) = i.get_nns_by_vector([0] * f, 10000, include_distances=True)\n    assert min(ds) >= 0\n    assert max(ds) <= f\n    dists = []\n    for x in range(1000):\n        (rs, ds) = i.get_nns_by_vector(numpy.random.binomial(1, 0.5, f), 1, search_k=1000, include_distances=True)\n        dists.append(ds[0])\n    avg_dist = 1.0 * sum(dists) / len(dists)\n    assert avg_dist <= 0.42",
            "def test_many_vectors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    f = 10\n    i = AnnoyIndex(f, 'hamming')\n    for x in range(100000):\n        i.add_item(x, numpy.random.binomial(1, 0.5, f))\n    i.build(10)\n    (rs, ds) = i.get_nns_by_vector([0] * f, 10000, include_distances=True)\n    assert min(ds) >= 0\n    assert max(ds) <= f\n    dists = []\n    for x in range(1000):\n        (rs, ds) = i.get_nns_by_vector(numpy.random.binomial(1, 0.5, f), 1, search_k=1000, include_distances=True)\n        dists.append(ds[0])\n    avg_dist = 1.0 * sum(dists) / len(dists)\n    assert avg_dist <= 0.42"
        ]
    },
    {
        "func_name": "test_zero_vectors",
        "original": "@pytest.mark.skip\ndef test_zero_vectors():\n    bitstrings = ['0000000000011000001110000011111000101110111110000100000100000000', '0000000000011000001110000011111000101110111110000100000100000001', '0000000000011000001110000011111000101110111110000100000100000010', '0010010100011001001000010001100101011110000000110000011110001100', '1001011010000110100101101001111010001110100001101000111000001110', '0111100101111001011110010010001100010111000111100001101100011111', '0011000010011101000011010010111000101110100101111000011101001011', '0011000010011100000011010010111000101110100101111000011101001011', '1001100000111010001010000010110000111100100101001001010000000111', '0000000000111101010100010001000101101001000000011000001101000000', '1000101001010001011100010111001100110011001100110011001111001100', '1110011001001111100110010001100100001011000011010010111100100111']\n    vectors = [[int(bit) for bit in bitstring] for bitstring in bitstrings]\n    f = 64\n    idx = AnnoyIndex(f, 'hamming')\n    for (i, v) in enumerate(vectors):\n        idx.add_item(i, v)\n    idx.build(10)\n    idx.save('idx.ann')\n    idx = AnnoyIndex(f, 'hamming')\n    idx.load('idx.ann')\n    (js, ds) = idx.get_nns_by_item(0, 5, include_distances=True)\n    assert js[0] == 0\n    assert ds[:4] == [0, 1, 1, 22]",
        "mutated": [
            "@pytest.mark.skip\ndef test_zero_vectors():\n    if False:\n        i = 10\n    bitstrings = ['0000000000011000001110000011111000101110111110000100000100000000', '0000000000011000001110000011111000101110111110000100000100000001', '0000000000011000001110000011111000101110111110000100000100000010', '0010010100011001001000010001100101011110000000110000011110001100', '1001011010000110100101101001111010001110100001101000111000001110', '0111100101111001011110010010001100010111000111100001101100011111', '0011000010011101000011010010111000101110100101111000011101001011', '0011000010011100000011010010111000101110100101111000011101001011', '1001100000111010001010000010110000111100100101001001010000000111', '0000000000111101010100010001000101101001000000011000001101000000', '1000101001010001011100010111001100110011001100110011001111001100', '1110011001001111100110010001100100001011000011010010111100100111']\n    vectors = [[int(bit) for bit in bitstring] for bitstring in bitstrings]\n    f = 64\n    idx = AnnoyIndex(f, 'hamming')\n    for (i, v) in enumerate(vectors):\n        idx.add_item(i, v)\n    idx.build(10)\n    idx.save('idx.ann')\n    idx = AnnoyIndex(f, 'hamming')\n    idx.load('idx.ann')\n    (js, ds) = idx.get_nns_by_item(0, 5, include_distances=True)\n    assert js[0] == 0\n    assert ds[:4] == [0, 1, 1, 22]",
            "@pytest.mark.skip\ndef test_zero_vectors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    bitstrings = ['0000000000011000001110000011111000101110111110000100000100000000', '0000000000011000001110000011111000101110111110000100000100000001', '0000000000011000001110000011111000101110111110000100000100000010', '0010010100011001001000010001100101011110000000110000011110001100', '1001011010000110100101101001111010001110100001101000111000001110', '0111100101111001011110010010001100010111000111100001101100011111', '0011000010011101000011010010111000101110100101111000011101001011', '0011000010011100000011010010111000101110100101111000011101001011', '1001100000111010001010000010110000111100100101001001010000000111', '0000000000111101010100010001000101101001000000011000001101000000', '1000101001010001011100010111001100110011001100110011001111001100', '1110011001001111100110010001100100001011000011010010111100100111']\n    vectors = [[int(bit) for bit in bitstring] for bitstring in bitstrings]\n    f = 64\n    idx = AnnoyIndex(f, 'hamming')\n    for (i, v) in enumerate(vectors):\n        idx.add_item(i, v)\n    idx.build(10)\n    idx.save('idx.ann')\n    idx = AnnoyIndex(f, 'hamming')\n    idx.load('idx.ann')\n    (js, ds) = idx.get_nns_by_item(0, 5, include_distances=True)\n    assert js[0] == 0\n    assert ds[:4] == [0, 1, 1, 22]",
            "@pytest.mark.skip\ndef test_zero_vectors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    bitstrings = ['0000000000011000001110000011111000101110111110000100000100000000', '0000000000011000001110000011111000101110111110000100000100000001', '0000000000011000001110000011111000101110111110000100000100000010', '0010010100011001001000010001100101011110000000110000011110001100', '1001011010000110100101101001111010001110100001101000111000001110', '0111100101111001011110010010001100010111000111100001101100011111', '0011000010011101000011010010111000101110100101111000011101001011', '0011000010011100000011010010111000101110100101111000011101001011', '1001100000111010001010000010110000111100100101001001010000000111', '0000000000111101010100010001000101101001000000011000001101000000', '1000101001010001011100010111001100110011001100110011001111001100', '1110011001001111100110010001100100001011000011010010111100100111']\n    vectors = [[int(bit) for bit in bitstring] for bitstring in bitstrings]\n    f = 64\n    idx = AnnoyIndex(f, 'hamming')\n    for (i, v) in enumerate(vectors):\n        idx.add_item(i, v)\n    idx.build(10)\n    idx.save('idx.ann')\n    idx = AnnoyIndex(f, 'hamming')\n    idx.load('idx.ann')\n    (js, ds) = idx.get_nns_by_item(0, 5, include_distances=True)\n    assert js[0] == 0\n    assert ds[:4] == [0, 1, 1, 22]",
            "@pytest.mark.skip\ndef test_zero_vectors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    bitstrings = ['0000000000011000001110000011111000101110111110000100000100000000', '0000000000011000001110000011111000101110111110000100000100000001', '0000000000011000001110000011111000101110111110000100000100000010', '0010010100011001001000010001100101011110000000110000011110001100', '1001011010000110100101101001111010001110100001101000111000001110', '0111100101111001011110010010001100010111000111100001101100011111', '0011000010011101000011010010111000101110100101111000011101001011', '0011000010011100000011010010111000101110100101111000011101001011', '1001100000111010001010000010110000111100100101001001010000000111', '0000000000111101010100010001000101101001000000011000001101000000', '1000101001010001011100010111001100110011001100110011001111001100', '1110011001001111100110010001100100001011000011010010111100100111']\n    vectors = [[int(bit) for bit in bitstring] for bitstring in bitstrings]\n    f = 64\n    idx = AnnoyIndex(f, 'hamming')\n    for (i, v) in enumerate(vectors):\n        idx.add_item(i, v)\n    idx.build(10)\n    idx.save('idx.ann')\n    idx = AnnoyIndex(f, 'hamming')\n    idx.load('idx.ann')\n    (js, ds) = idx.get_nns_by_item(0, 5, include_distances=True)\n    assert js[0] == 0\n    assert ds[:4] == [0, 1, 1, 22]",
            "@pytest.mark.skip\ndef test_zero_vectors():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    bitstrings = ['0000000000011000001110000011111000101110111110000100000100000000', '0000000000011000001110000011111000101110111110000100000100000001', '0000000000011000001110000011111000101110111110000100000100000010', '0010010100011001001000010001100101011110000000110000011110001100', '1001011010000110100101101001111010001110100001101000111000001110', '0111100101111001011110010010001100010111000111100001101100011111', '0011000010011101000011010010111000101110100101111000011101001011', '0011000010011100000011010010111000101110100101111000011101001011', '1001100000111010001010000010110000111100100101001001010000000111', '0000000000111101010100010001000101101001000000011000001101000000', '1000101001010001011100010111001100110011001100110011001111001100', '1110011001001111100110010001100100001011000011010010111100100111']\n    vectors = [[int(bit) for bit in bitstring] for bitstring in bitstrings]\n    f = 64\n    idx = AnnoyIndex(f, 'hamming')\n    for (i, v) in enumerate(vectors):\n        idx.add_item(i, v)\n    idx.build(10)\n    idx.save('idx.ann')\n    idx = AnnoyIndex(f, 'hamming')\n    idx.load('idx.ann')\n    (js, ds) = idx.get_nns_by_item(0, 5, include_distances=True)\n    assert js[0] == 0\n    assert ds[:4] == [0, 1, 1, 22]"
        ]
    }
]