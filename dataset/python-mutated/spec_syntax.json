[
    {
        "func_name": "simple_package_name",
        "original": "def simple_package_name(name):\n    \"\"\"A simple package name in canonical form\"\"\"\n    return (name, [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=name)], name)",
        "mutated": [
            "def simple_package_name(name):\n    if False:\n        i = 10\n    'A simple package name in canonical form'\n    return (name, [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=name)], name)",
            "def simple_package_name(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A simple package name in canonical form'\n    return (name, [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=name)], name)",
            "def simple_package_name(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A simple package name in canonical form'\n    return (name, [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=name)], name)",
            "def simple_package_name(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A simple package name in canonical form'\n    return (name, [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=name)], name)",
            "def simple_package_name(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A simple package name in canonical form'\n    return (name, [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=name)], name)"
        ]
    },
    {
        "func_name": "dependency_with_version",
        "original": "def dependency_with_version(text):\n    (root, rest) = text.split('^')\n    (dependency, version) = rest.split('@')\n    return (text, [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=root.strip()), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=dependency.strip()), Token(TokenType.VERSION, value=f'@{version}')], text)",
        "mutated": [
            "def dependency_with_version(text):\n    if False:\n        i = 10\n    (root, rest) = text.split('^')\n    (dependency, version) = rest.split('@')\n    return (text, [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=root.strip()), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=dependency.strip()), Token(TokenType.VERSION, value=f'@{version}')], text)",
            "def dependency_with_version(text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (root, rest) = text.split('^')\n    (dependency, version) = rest.split('@')\n    return (text, [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=root.strip()), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=dependency.strip()), Token(TokenType.VERSION, value=f'@{version}')], text)",
            "def dependency_with_version(text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (root, rest) = text.split('^')\n    (dependency, version) = rest.split('@')\n    return (text, [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=root.strip()), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=dependency.strip()), Token(TokenType.VERSION, value=f'@{version}')], text)",
            "def dependency_with_version(text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (root, rest) = text.split('^')\n    (dependency, version) = rest.split('@')\n    return (text, [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=root.strip()), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=dependency.strip()), Token(TokenType.VERSION, value=f'@{version}')], text)",
            "def dependency_with_version(text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (root, rest) = text.split('^')\n    (dependency, version) = rest.split('@')\n    return (text, [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=root.strip()), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value=dependency.strip()), Token(TokenType.VERSION, value=f'@{version}')], text)"
        ]
    },
    {
        "func_name": "compiler_with_version_range",
        "original": "def compiler_with_version_range(text):\n    return (text, [Token(TokenType.COMPILER_AND_VERSION, value=text)], text)",
        "mutated": [
            "def compiler_with_version_range(text):\n    if False:\n        i = 10\n    return (text, [Token(TokenType.COMPILER_AND_VERSION, value=text)], text)",
            "def compiler_with_version_range(text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return (text, [Token(TokenType.COMPILER_AND_VERSION, value=text)], text)",
            "def compiler_with_version_range(text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return (text, [Token(TokenType.COMPILER_AND_VERSION, value=text)], text)",
            "def compiler_with_version_range(text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return (text, [Token(TokenType.COMPILER_AND_VERSION, value=text)], text)",
            "def compiler_with_version_range(text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return (text, [Token(TokenType.COMPILER_AND_VERSION, value=text)], text)"
        ]
    },
    {
        "func_name": "_specfile_for",
        "original": "def _specfile_for(spec_str, filename):\n    s = default_mock_concretization(spec_str)\n    is_json = str(filename).endswith('.json')\n    is_yaml = str(filename).endswith('.yaml')\n    if not is_json and (not is_yaml):\n        raise ValueError('wrong extension used for specfile')\n    with filename.open('w') as f:\n        if is_json:\n            f.write(s.to_json())\n        else:\n            f.write(s.to_yaml())\n    return s",
        "mutated": [
            "def _specfile_for(spec_str, filename):\n    if False:\n        i = 10\n    s = default_mock_concretization(spec_str)\n    is_json = str(filename).endswith('.json')\n    is_yaml = str(filename).endswith('.yaml')\n    if not is_json and (not is_yaml):\n        raise ValueError('wrong extension used for specfile')\n    with filename.open('w') as f:\n        if is_json:\n            f.write(s.to_json())\n        else:\n            f.write(s.to_yaml())\n    return s",
            "def _specfile_for(spec_str, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s = default_mock_concretization(spec_str)\n    is_json = str(filename).endswith('.json')\n    is_yaml = str(filename).endswith('.yaml')\n    if not is_json and (not is_yaml):\n        raise ValueError('wrong extension used for specfile')\n    with filename.open('w') as f:\n        if is_json:\n            f.write(s.to_json())\n        else:\n            f.write(s.to_yaml())\n    return s",
            "def _specfile_for(spec_str, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s = default_mock_concretization(spec_str)\n    is_json = str(filename).endswith('.json')\n    is_yaml = str(filename).endswith('.yaml')\n    if not is_json and (not is_yaml):\n        raise ValueError('wrong extension used for specfile')\n    with filename.open('w') as f:\n        if is_json:\n            f.write(s.to_json())\n        else:\n            f.write(s.to_yaml())\n    return s",
            "def _specfile_for(spec_str, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s = default_mock_concretization(spec_str)\n    is_json = str(filename).endswith('.json')\n    is_yaml = str(filename).endswith('.yaml')\n    if not is_json and (not is_yaml):\n        raise ValueError('wrong extension used for specfile')\n    with filename.open('w') as f:\n        if is_json:\n            f.write(s.to_json())\n        else:\n            f.write(s.to_yaml())\n    return s",
            "def _specfile_for(spec_str, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s = default_mock_concretization(spec_str)\n    is_json = str(filename).endswith('.json')\n    is_yaml = str(filename).endswith('.yaml')\n    if not is_json and (not is_yaml):\n        raise ValueError('wrong extension used for specfile')\n    with filename.open('w') as f:\n        if is_json:\n            f.write(s.to_json())\n        else:\n            f.write(s.to_yaml())\n    return s"
        ]
    },
    {
        "func_name": "specfile_for",
        "original": "@pytest.fixture()\ndef specfile_for(default_mock_concretization):\n\n    def _specfile_for(spec_str, filename):\n        s = default_mock_concretization(spec_str)\n        is_json = str(filename).endswith('.json')\n        is_yaml = str(filename).endswith('.yaml')\n        if not is_json and (not is_yaml):\n            raise ValueError('wrong extension used for specfile')\n        with filename.open('w') as f:\n            if is_json:\n                f.write(s.to_json())\n            else:\n                f.write(s.to_yaml())\n        return s\n    return _specfile_for",
        "mutated": [
            "@pytest.fixture()\ndef specfile_for(default_mock_concretization):\n    if False:\n        i = 10\n\n    def _specfile_for(spec_str, filename):\n        s = default_mock_concretization(spec_str)\n        is_json = str(filename).endswith('.json')\n        is_yaml = str(filename).endswith('.yaml')\n        if not is_json and (not is_yaml):\n            raise ValueError('wrong extension used for specfile')\n        with filename.open('w') as f:\n            if is_json:\n                f.write(s.to_json())\n            else:\n                f.write(s.to_yaml())\n        return s\n    return _specfile_for",
            "@pytest.fixture()\ndef specfile_for(default_mock_concretization):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def _specfile_for(spec_str, filename):\n        s = default_mock_concretization(spec_str)\n        is_json = str(filename).endswith('.json')\n        is_yaml = str(filename).endswith('.yaml')\n        if not is_json and (not is_yaml):\n            raise ValueError('wrong extension used for specfile')\n        with filename.open('w') as f:\n            if is_json:\n                f.write(s.to_json())\n            else:\n                f.write(s.to_yaml())\n        return s\n    return _specfile_for",
            "@pytest.fixture()\ndef specfile_for(default_mock_concretization):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def _specfile_for(spec_str, filename):\n        s = default_mock_concretization(spec_str)\n        is_json = str(filename).endswith('.json')\n        is_yaml = str(filename).endswith('.yaml')\n        if not is_json and (not is_yaml):\n            raise ValueError('wrong extension used for specfile')\n        with filename.open('w') as f:\n            if is_json:\n                f.write(s.to_json())\n            else:\n                f.write(s.to_yaml())\n        return s\n    return _specfile_for",
            "@pytest.fixture()\ndef specfile_for(default_mock_concretization):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def _specfile_for(spec_str, filename):\n        s = default_mock_concretization(spec_str)\n        is_json = str(filename).endswith('.json')\n        is_yaml = str(filename).endswith('.yaml')\n        if not is_json and (not is_yaml):\n            raise ValueError('wrong extension used for specfile')\n        with filename.open('w') as f:\n            if is_json:\n                f.write(s.to_json())\n            else:\n                f.write(s.to_yaml())\n        return s\n    return _specfile_for",
            "@pytest.fixture()\ndef specfile_for(default_mock_concretization):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def _specfile_for(spec_str, filename):\n        s = default_mock_concretization(spec_str)\n        is_json = str(filename).endswith('.json')\n        is_yaml = str(filename).endswith('.yaml')\n        if not is_json and (not is_yaml):\n            raise ValueError('wrong extension used for specfile')\n        with filename.open('w') as f:\n            if is_json:\n                f.write(s.to_json())\n            else:\n                f.write(s.to_yaml())\n        return s\n    return _specfile_for"
        ]
    },
    {
        "func_name": "test_parse_single_spec",
        "original": "@pytest.mark.parametrize('spec_str,tokens,expected_roundtrip', [simple_package_name('mvapich'), simple_package_name('mvapich_foo'), simple_package_name('_mvapich_foo'), simple_package_name('3dtk'), simple_package_name('ns-3-dev'), ('%intel', [Token(TokenType.COMPILER, value='%intel')], '%intel'), ('@2.7', [Token(TokenType.VERSION, value='@2.7')], '@2.7'), ('@2.7:', [Token(TokenType.VERSION, value='@2.7:')], '@2.7:'), ('@:2.7', [Token(TokenType.VERSION, value='@:2.7')], '@:2.7'), ('+foo', [Token(TokenType.BOOL_VARIANT, value='+foo')], '+foo'), ('~foo', [Token(TokenType.BOOL_VARIANT, value='~foo')], '~foo'), ('-foo', [Token(TokenType.BOOL_VARIANT, value='-foo')], '~foo'), ('platform=test', [Token(TokenType.KEY_VALUE_PAIR, value='platform=test')], 'arch=test-None-None'), ('languages=go @4.2:', [Token(TokenType.KEY_VALUE_PAIR, value='languages=go'), Token(TokenType.VERSION, value='@4.2:')], '@4.2: languages=go'), ('@4.2:     languages=go', [Token(TokenType.VERSION, value='@4.2:'), Token(TokenType.KEY_VALUE_PAIR, value='languages=go')], '@4.2: languages=go'), ('^zlib', [Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], '^zlib'), ('openmpi ^hwloc', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc')], 'openmpi ^hwloc'), ('openmpi ^hwloc ^libunwind', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='libunwind')], 'openmpi ^hwloc ^libunwind'), ('openmpi      ^hwloc^libunwind', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='libunwind')], 'openmpi ^hwloc ^libunwind'), ('foo %bar@1.0 @2.0', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.COMPILER_AND_VERSION, value='%bar@1.0'), Token(TokenType.VERSION, value='@2.0')], 'foo@2.0%bar@1.0'), dependency_with_version('openmpi ^hwloc@1.2e6'), dependency_with_version('openmpi ^hwloc@1.2e6:'), dependency_with_version('openmpi ^hwloc@:1.4b7-rc3'), dependency_with_version('openmpi ^hwloc@1.2e6:1.4b7-rc3'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1+debug~qt_4 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1+debug~qt_4 ^stackwalker@8.1_1e'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1~qt_4 debug=2 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.KEY_VALUE_PAIR, value='debug=2'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1~qt_4 debug=2 ^stackwalker@8.1_1e'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1 cppflags=-O3 +debug~qt_4 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.KEY_VALUE_PAIR, value='cppflags=-O3'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1 cppflags=\"-O3\" +debug~qt_4 ^stackwalker@8.1_1e'), ('yaml-cpp@0.1.8%intel@12.1 ^boost@3.1.4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='yaml-cpp'), Token(TokenType.VERSION, value='@0.1.8'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='boost'), Token(TokenType.VERSION, value='@3.1.4')], 'yaml-cpp@0.1.8%intel@12.1 ^boost@3.1.4'), ('builtin.yaml-cpp%gcc', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.COMPILER, value='%gcc')], 'yaml-cpp%gcc'), ('testrepo.yaml-cpp%gcc', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='testrepo.yaml-cpp'), Token(TokenType.COMPILER, value='%gcc')], 'yaml-cpp%gcc'), ('builtin.yaml-cpp@0.1.8%gcc@7.2.0 ^boost@3.1.4', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.VERSION, value='@0.1.8'), Token(TokenType.COMPILER_AND_VERSION, value='%gcc@7.2.0'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='boost'), Token(TokenType.VERSION, value='@3.1.4')], 'yaml-cpp@0.1.8%gcc@7.2.0 ^boost@3.1.4'), ('builtin.yaml-cpp ^testrepo.boost ^zlib', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='testrepo.boost'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], 'yaml-cpp ^boost ^zlib'), ('mvapich ^stackwalker ^_openmpi', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi')], 'mvapich ^_openmpi ^stackwalker'), ('y~f+e~d+c~b+a', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.BOOL_VARIANT, value='~f'), Token(TokenType.BOOL_VARIANT, value='+e'), Token(TokenType.BOOL_VARIANT, value='~d'), Token(TokenType.BOOL_VARIANT, value='+c'), Token(TokenType.BOOL_VARIANT, value='~b'), Token(TokenType.BOOL_VARIANT, value='+a')], 'y+a~b+c~d+e~f'), ('@:', [Token(TokenType.VERSION, value='@:')], ''), ('@1.6,1.2:1.4', [Token(TokenType.VERSION, value='@1.6,1.2:1.4')], '@1.2:1.4,1.6'), ('os=fe', [Token(TokenType.KEY_VALUE_PAIR, value='os=fe')], 'arch=test-redhat6-None'), ('os=default_os', [Token(TokenType.KEY_VALUE_PAIR, value='os=default_os')], 'arch=test-debian6-None'), ('target=be', [Token(TokenType.KEY_VALUE_PAIR, value='target=be')], f'arch=test-None-{spack.platforms.test.Test.default}'), ('target=default_target', [Token(TokenType.KEY_VALUE_PAIR, value='target=default_target')], f'arch=test-None-{spack.platforms.test.Test.default}'), ('platform=linux', [Token(TokenType.KEY_VALUE_PAIR, value='platform=linux')], 'arch=linux-None-None'), (f\"develop-branch-version@{'abc12' * 8}=develop\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='develop-branch-version'), Token(TokenType.VERSION_HASH_PAIR, value=f\"@{'abc12' * 8}=develop\")], f\"develop-branch-version@{'abc12' * 8}=develop\"), ('x ^y@foo ^y@foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo')], 'x ^y@foo'), ('x ^y@foo ^y+bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.BOOL_VARIANT, value='+bar')], 'x ^y@foo+bar'), ('x ^y@foo +bar ^y@foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.BOOL_VARIANT, value='+bar'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo')], 'x ^y@foo+bar'), ('_openmpi +debug-qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug-qt_4')], '_openmpi+debug-qt_4'), ('_openmpi +debug -qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='-qt_4')], '_openmpi+debug~qt_4'), ('_openmpi +debug~qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4')], '_openmpi+debug~qt_4'), ('target=:broadwell,icelake', [Token(TokenType.KEY_VALUE_PAIR, value='target=:broadwell,icelake')], 'arch=None-None-:broadwell,icelake'), (f\"develop-branch-version@git.{'a' * 40}=develop+var1+var2\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='develop-branch-version'), Token(TokenType.VERSION_HASH_PAIR, value=f\"@git.{'a' * 40}=develop\"), Token(TokenType.BOOL_VARIANT, value='+var1'), Token(TokenType.BOOL_VARIANT, value='+var2')], f\"develop-branch-version@git.{'a' * 40}=develop+var1+var2\"), compiler_with_version_range('%gcc@10.2.1:'), compiler_with_version_range('%gcc@:10.2.1'), compiler_with_version_range('%gcc@10.2.1:12.1.0'), compiler_with_version_range('%gcc@10.1.0,12.2.1:'), compiler_with_version_range('%gcc@:8.4.3,10.2.1:12.1.0'), ('dev_path=*', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=*')], 'dev_path=*'), ('dev_path=none', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=none')], 'dev_path=none'), ('dev_path=../relpath/work', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=../relpath/work')], 'dev_path=../relpath/work'), ('dev_path=/abspath/work', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=/abspath/work')], 'dev_path=/abspath/work'), ('cflags=a=b=c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c')], 'cflags=\"a=b=c\"'), ('cflags=a=b=c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c')], 'cflags=\"a=b=c\"'), ('cflags=a=b=c+~', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c+~')], 'cflags=\"a=b=c+~\"'), ('cflags=-Wl,a,b,c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=-Wl,a,b,c')], 'cflags=\"-Wl,a,b,c\"'), (\"cflags=''-Wl,a,b,c''\", [Token(TokenType.KEY_VALUE_PAIR, value=\"cflags=''-Wl,a,b,c''\")], 'cflags=\"-Wl,a,b,c\"'), ('cflags==\"-O3 -g\"', [Token(TokenType.PROPAGATED_KEY_VALUE_PAIR, value='cflags==\"-O3 -g\"')], 'cflags==\"-O3 -g\"'), ('@1.2:1.4 , 1.6 ', [Token(TokenType.VERSION, value='@1.2:1.4 , 1.6')], '@1.2:1.4,1.6'), ('a@1: b', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='a'), Token(TokenType.VERSION, value='@1:'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='b')], 'a@1:'), ('@1.2:   develop   = foo', [Token(TokenType.VERSION, value='@1.2:'), Token(TokenType.KEY_VALUE_PAIR, value='develop   = foo')], '@1.2: develop=foo'), ('@1.2:develop   = foo', [Token(TokenType.VERSION, value='@1.2:'), Token(TokenType.KEY_VALUE_PAIR, value='develop   = foo')], '@1.2: develop=foo'), ('% intel @ 12.1:12.6 + debug', [Token(TokenType.COMPILER_AND_VERSION, value='% intel @ 12.1:12.6'), Token(TokenType.BOOL_VARIANT, value='+ debug')], '%intel@12.1:12.6+debug'), ('@ 12.1:12.6 + debug - qt_4', [Token(TokenType.VERSION, value='@ 12.1:12.6'), Token(TokenType.BOOL_VARIANT, value='+ debug'), Token(TokenType.BOOL_VARIANT, value='- qt_4')], '@12.1:12.6+debug~qt_4'), ('@10.4.0:10,11.3.0:target=aarch64:', [Token(TokenType.VERSION, value='@10.4.0:10,11.3.0:'), Token(TokenType.KEY_VALUE_PAIR, value='target=aarch64:')], '@10.4.0:10,11.3.0: arch=None-None-aarch64:'), ('@:0.4 % nvhpc', [Token(TokenType.VERSION, value='@:0.4'), Token(TokenType.COMPILER, value='% nvhpc')], '@:0.4%nvhpc'), ('^[virtuals=mpi] openmpi', [Token(TokenType.START_EDGE_PROPERTIES, value='^['), Token(TokenType.KEY_VALUE_PAIR, value='virtuals=mpi'), Token(TokenType.END_EDGE_PROPERTIES, value=']'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi')], '^[virtuals=mpi] openmpi'), ('^[deptypes=link,build] zlib', [Token(TokenType.START_EDGE_PROPERTIES, value='^['), Token(TokenType.KEY_VALUE_PAIR, value='deptypes=link,build'), Token(TokenType.END_EDGE_PROPERTIES, value=']'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], '^[deptypes=build,link] zlib'), ('zlib@git.foo/bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.GIT_VERSION, '@git.foo/bar')], 'zlib@git.foo/bar'), ('zlib ++foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_BOOL_VARIANT, '++foo')], 'zlib++foo'), ('zlib ~~foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_BOOL_VARIANT, '~~foo')], 'zlib~~foo'), ('zlib foo==bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_KEY_VALUE_PAIR, 'foo==bar')], 'zlib foo==bar')])\ndef test_parse_single_spec(spec_str, tokens, expected_roundtrip):\n    parser = SpecParser(spec_str)\n    assert parser.tokens() == tokens\n    assert str(parser.next_spec()) == expected_roundtrip",
        "mutated": [
            "@pytest.mark.parametrize('spec_str,tokens,expected_roundtrip', [simple_package_name('mvapich'), simple_package_name('mvapich_foo'), simple_package_name('_mvapich_foo'), simple_package_name('3dtk'), simple_package_name('ns-3-dev'), ('%intel', [Token(TokenType.COMPILER, value='%intel')], '%intel'), ('@2.7', [Token(TokenType.VERSION, value='@2.7')], '@2.7'), ('@2.7:', [Token(TokenType.VERSION, value='@2.7:')], '@2.7:'), ('@:2.7', [Token(TokenType.VERSION, value='@:2.7')], '@:2.7'), ('+foo', [Token(TokenType.BOOL_VARIANT, value='+foo')], '+foo'), ('~foo', [Token(TokenType.BOOL_VARIANT, value='~foo')], '~foo'), ('-foo', [Token(TokenType.BOOL_VARIANT, value='-foo')], '~foo'), ('platform=test', [Token(TokenType.KEY_VALUE_PAIR, value='platform=test')], 'arch=test-None-None'), ('languages=go @4.2:', [Token(TokenType.KEY_VALUE_PAIR, value='languages=go'), Token(TokenType.VERSION, value='@4.2:')], '@4.2: languages=go'), ('@4.2:     languages=go', [Token(TokenType.VERSION, value='@4.2:'), Token(TokenType.KEY_VALUE_PAIR, value='languages=go')], '@4.2: languages=go'), ('^zlib', [Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], '^zlib'), ('openmpi ^hwloc', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc')], 'openmpi ^hwloc'), ('openmpi ^hwloc ^libunwind', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='libunwind')], 'openmpi ^hwloc ^libunwind'), ('openmpi      ^hwloc^libunwind', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='libunwind')], 'openmpi ^hwloc ^libunwind'), ('foo %bar@1.0 @2.0', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.COMPILER_AND_VERSION, value='%bar@1.0'), Token(TokenType.VERSION, value='@2.0')], 'foo@2.0%bar@1.0'), dependency_with_version('openmpi ^hwloc@1.2e6'), dependency_with_version('openmpi ^hwloc@1.2e6:'), dependency_with_version('openmpi ^hwloc@:1.4b7-rc3'), dependency_with_version('openmpi ^hwloc@1.2e6:1.4b7-rc3'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1+debug~qt_4 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1+debug~qt_4 ^stackwalker@8.1_1e'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1~qt_4 debug=2 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.KEY_VALUE_PAIR, value='debug=2'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1~qt_4 debug=2 ^stackwalker@8.1_1e'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1 cppflags=-O3 +debug~qt_4 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.KEY_VALUE_PAIR, value='cppflags=-O3'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1 cppflags=\"-O3\" +debug~qt_4 ^stackwalker@8.1_1e'), ('yaml-cpp@0.1.8%intel@12.1 ^boost@3.1.4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='yaml-cpp'), Token(TokenType.VERSION, value='@0.1.8'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='boost'), Token(TokenType.VERSION, value='@3.1.4')], 'yaml-cpp@0.1.8%intel@12.1 ^boost@3.1.4'), ('builtin.yaml-cpp%gcc', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.COMPILER, value='%gcc')], 'yaml-cpp%gcc'), ('testrepo.yaml-cpp%gcc', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='testrepo.yaml-cpp'), Token(TokenType.COMPILER, value='%gcc')], 'yaml-cpp%gcc'), ('builtin.yaml-cpp@0.1.8%gcc@7.2.0 ^boost@3.1.4', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.VERSION, value='@0.1.8'), Token(TokenType.COMPILER_AND_VERSION, value='%gcc@7.2.0'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='boost'), Token(TokenType.VERSION, value='@3.1.4')], 'yaml-cpp@0.1.8%gcc@7.2.0 ^boost@3.1.4'), ('builtin.yaml-cpp ^testrepo.boost ^zlib', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='testrepo.boost'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], 'yaml-cpp ^boost ^zlib'), ('mvapich ^stackwalker ^_openmpi', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi')], 'mvapich ^_openmpi ^stackwalker'), ('y~f+e~d+c~b+a', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.BOOL_VARIANT, value='~f'), Token(TokenType.BOOL_VARIANT, value='+e'), Token(TokenType.BOOL_VARIANT, value='~d'), Token(TokenType.BOOL_VARIANT, value='+c'), Token(TokenType.BOOL_VARIANT, value='~b'), Token(TokenType.BOOL_VARIANT, value='+a')], 'y+a~b+c~d+e~f'), ('@:', [Token(TokenType.VERSION, value='@:')], ''), ('@1.6,1.2:1.4', [Token(TokenType.VERSION, value='@1.6,1.2:1.4')], '@1.2:1.4,1.6'), ('os=fe', [Token(TokenType.KEY_VALUE_PAIR, value='os=fe')], 'arch=test-redhat6-None'), ('os=default_os', [Token(TokenType.KEY_VALUE_PAIR, value='os=default_os')], 'arch=test-debian6-None'), ('target=be', [Token(TokenType.KEY_VALUE_PAIR, value='target=be')], f'arch=test-None-{spack.platforms.test.Test.default}'), ('target=default_target', [Token(TokenType.KEY_VALUE_PAIR, value='target=default_target')], f'arch=test-None-{spack.platforms.test.Test.default}'), ('platform=linux', [Token(TokenType.KEY_VALUE_PAIR, value='platform=linux')], 'arch=linux-None-None'), (f\"develop-branch-version@{'abc12' * 8}=develop\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='develop-branch-version'), Token(TokenType.VERSION_HASH_PAIR, value=f\"@{'abc12' * 8}=develop\")], f\"develop-branch-version@{'abc12' * 8}=develop\"), ('x ^y@foo ^y@foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo')], 'x ^y@foo'), ('x ^y@foo ^y+bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.BOOL_VARIANT, value='+bar')], 'x ^y@foo+bar'), ('x ^y@foo +bar ^y@foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.BOOL_VARIANT, value='+bar'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo')], 'x ^y@foo+bar'), ('_openmpi +debug-qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug-qt_4')], '_openmpi+debug-qt_4'), ('_openmpi +debug -qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='-qt_4')], '_openmpi+debug~qt_4'), ('_openmpi +debug~qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4')], '_openmpi+debug~qt_4'), ('target=:broadwell,icelake', [Token(TokenType.KEY_VALUE_PAIR, value='target=:broadwell,icelake')], 'arch=None-None-:broadwell,icelake'), (f\"develop-branch-version@git.{'a' * 40}=develop+var1+var2\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='develop-branch-version'), Token(TokenType.VERSION_HASH_PAIR, value=f\"@git.{'a' * 40}=develop\"), Token(TokenType.BOOL_VARIANT, value='+var1'), Token(TokenType.BOOL_VARIANT, value='+var2')], f\"develop-branch-version@git.{'a' * 40}=develop+var1+var2\"), compiler_with_version_range('%gcc@10.2.1:'), compiler_with_version_range('%gcc@:10.2.1'), compiler_with_version_range('%gcc@10.2.1:12.1.0'), compiler_with_version_range('%gcc@10.1.0,12.2.1:'), compiler_with_version_range('%gcc@:8.4.3,10.2.1:12.1.0'), ('dev_path=*', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=*')], 'dev_path=*'), ('dev_path=none', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=none')], 'dev_path=none'), ('dev_path=../relpath/work', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=../relpath/work')], 'dev_path=../relpath/work'), ('dev_path=/abspath/work', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=/abspath/work')], 'dev_path=/abspath/work'), ('cflags=a=b=c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c')], 'cflags=\"a=b=c\"'), ('cflags=a=b=c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c')], 'cflags=\"a=b=c\"'), ('cflags=a=b=c+~', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c+~')], 'cflags=\"a=b=c+~\"'), ('cflags=-Wl,a,b,c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=-Wl,a,b,c')], 'cflags=\"-Wl,a,b,c\"'), (\"cflags=''-Wl,a,b,c''\", [Token(TokenType.KEY_VALUE_PAIR, value=\"cflags=''-Wl,a,b,c''\")], 'cflags=\"-Wl,a,b,c\"'), ('cflags==\"-O3 -g\"', [Token(TokenType.PROPAGATED_KEY_VALUE_PAIR, value='cflags==\"-O3 -g\"')], 'cflags==\"-O3 -g\"'), ('@1.2:1.4 , 1.6 ', [Token(TokenType.VERSION, value='@1.2:1.4 , 1.6')], '@1.2:1.4,1.6'), ('a@1: b', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='a'), Token(TokenType.VERSION, value='@1:'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='b')], 'a@1:'), ('@1.2:   develop   = foo', [Token(TokenType.VERSION, value='@1.2:'), Token(TokenType.KEY_VALUE_PAIR, value='develop   = foo')], '@1.2: develop=foo'), ('@1.2:develop   = foo', [Token(TokenType.VERSION, value='@1.2:'), Token(TokenType.KEY_VALUE_PAIR, value='develop   = foo')], '@1.2: develop=foo'), ('% intel @ 12.1:12.6 + debug', [Token(TokenType.COMPILER_AND_VERSION, value='% intel @ 12.1:12.6'), Token(TokenType.BOOL_VARIANT, value='+ debug')], '%intel@12.1:12.6+debug'), ('@ 12.1:12.6 + debug - qt_4', [Token(TokenType.VERSION, value='@ 12.1:12.6'), Token(TokenType.BOOL_VARIANT, value='+ debug'), Token(TokenType.BOOL_VARIANT, value='- qt_4')], '@12.1:12.6+debug~qt_4'), ('@10.4.0:10,11.3.0:target=aarch64:', [Token(TokenType.VERSION, value='@10.4.0:10,11.3.0:'), Token(TokenType.KEY_VALUE_PAIR, value='target=aarch64:')], '@10.4.0:10,11.3.0: arch=None-None-aarch64:'), ('@:0.4 % nvhpc', [Token(TokenType.VERSION, value='@:0.4'), Token(TokenType.COMPILER, value='% nvhpc')], '@:0.4%nvhpc'), ('^[virtuals=mpi] openmpi', [Token(TokenType.START_EDGE_PROPERTIES, value='^['), Token(TokenType.KEY_VALUE_PAIR, value='virtuals=mpi'), Token(TokenType.END_EDGE_PROPERTIES, value=']'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi')], '^[virtuals=mpi] openmpi'), ('^[deptypes=link,build] zlib', [Token(TokenType.START_EDGE_PROPERTIES, value='^['), Token(TokenType.KEY_VALUE_PAIR, value='deptypes=link,build'), Token(TokenType.END_EDGE_PROPERTIES, value=']'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], '^[deptypes=build,link] zlib'), ('zlib@git.foo/bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.GIT_VERSION, '@git.foo/bar')], 'zlib@git.foo/bar'), ('zlib ++foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_BOOL_VARIANT, '++foo')], 'zlib++foo'), ('zlib ~~foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_BOOL_VARIANT, '~~foo')], 'zlib~~foo'), ('zlib foo==bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_KEY_VALUE_PAIR, 'foo==bar')], 'zlib foo==bar')])\ndef test_parse_single_spec(spec_str, tokens, expected_roundtrip):\n    if False:\n        i = 10\n    parser = SpecParser(spec_str)\n    assert parser.tokens() == tokens\n    assert str(parser.next_spec()) == expected_roundtrip",
            "@pytest.mark.parametrize('spec_str,tokens,expected_roundtrip', [simple_package_name('mvapich'), simple_package_name('mvapich_foo'), simple_package_name('_mvapich_foo'), simple_package_name('3dtk'), simple_package_name('ns-3-dev'), ('%intel', [Token(TokenType.COMPILER, value='%intel')], '%intel'), ('@2.7', [Token(TokenType.VERSION, value='@2.7')], '@2.7'), ('@2.7:', [Token(TokenType.VERSION, value='@2.7:')], '@2.7:'), ('@:2.7', [Token(TokenType.VERSION, value='@:2.7')], '@:2.7'), ('+foo', [Token(TokenType.BOOL_VARIANT, value='+foo')], '+foo'), ('~foo', [Token(TokenType.BOOL_VARIANT, value='~foo')], '~foo'), ('-foo', [Token(TokenType.BOOL_VARIANT, value='-foo')], '~foo'), ('platform=test', [Token(TokenType.KEY_VALUE_PAIR, value='platform=test')], 'arch=test-None-None'), ('languages=go @4.2:', [Token(TokenType.KEY_VALUE_PAIR, value='languages=go'), Token(TokenType.VERSION, value='@4.2:')], '@4.2: languages=go'), ('@4.2:     languages=go', [Token(TokenType.VERSION, value='@4.2:'), Token(TokenType.KEY_VALUE_PAIR, value='languages=go')], '@4.2: languages=go'), ('^zlib', [Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], '^zlib'), ('openmpi ^hwloc', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc')], 'openmpi ^hwloc'), ('openmpi ^hwloc ^libunwind', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='libunwind')], 'openmpi ^hwloc ^libunwind'), ('openmpi      ^hwloc^libunwind', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='libunwind')], 'openmpi ^hwloc ^libunwind'), ('foo %bar@1.0 @2.0', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.COMPILER_AND_VERSION, value='%bar@1.0'), Token(TokenType.VERSION, value='@2.0')], 'foo@2.0%bar@1.0'), dependency_with_version('openmpi ^hwloc@1.2e6'), dependency_with_version('openmpi ^hwloc@1.2e6:'), dependency_with_version('openmpi ^hwloc@:1.4b7-rc3'), dependency_with_version('openmpi ^hwloc@1.2e6:1.4b7-rc3'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1+debug~qt_4 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1+debug~qt_4 ^stackwalker@8.1_1e'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1~qt_4 debug=2 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.KEY_VALUE_PAIR, value='debug=2'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1~qt_4 debug=2 ^stackwalker@8.1_1e'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1 cppflags=-O3 +debug~qt_4 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.KEY_VALUE_PAIR, value='cppflags=-O3'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1 cppflags=\"-O3\" +debug~qt_4 ^stackwalker@8.1_1e'), ('yaml-cpp@0.1.8%intel@12.1 ^boost@3.1.4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='yaml-cpp'), Token(TokenType.VERSION, value='@0.1.8'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='boost'), Token(TokenType.VERSION, value='@3.1.4')], 'yaml-cpp@0.1.8%intel@12.1 ^boost@3.1.4'), ('builtin.yaml-cpp%gcc', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.COMPILER, value='%gcc')], 'yaml-cpp%gcc'), ('testrepo.yaml-cpp%gcc', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='testrepo.yaml-cpp'), Token(TokenType.COMPILER, value='%gcc')], 'yaml-cpp%gcc'), ('builtin.yaml-cpp@0.1.8%gcc@7.2.0 ^boost@3.1.4', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.VERSION, value='@0.1.8'), Token(TokenType.COMPILER_AND_VERSION, value='%gcc@7.2.0'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='boost'), Token(TokenType.VERSION, value='@3.1.4')], 'yaml-cpp@0.1.8%gcc@7.2.0 ^boost@3.1.4'), ('builtin.yaml-cpp ^testrepo.boost ^zlib', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='testrepo.boost'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], 'yaml-cpp ^boost ^zlib'), ('mvapich ^stackwalker ^_openmpi', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi')], 'mvapich ^_openmpi ^stackwalker'), ('y~f+e~d+c~b+a', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.BOOL_VARIANT, value='~f'), Token(TokenType.BOOL_VARIANT, value='+e'), Token(TokenType.BOOL_VARIANT, value='~d'), Token(TokenType.BOOL_VARIANT, value='+c'), Token(TokenType.BOOL_VARIANT, value='~b'), Token(TokenType.BOOL_VARIANT, value='+a')], 'y+a~b+c~d+e~f'), ('@:', [Token(TokenType.VERSION, value='@:')], ''), ('@1.6,1.2:1.4', [Token(TokenType.VERSION, value='@1.6,1.2:1.4')], '@1.2:1.4,1.6'), ('os=fe', [Token(TokenType.KEY_VALUE_PAIR, value='os=fe')], 'arch=test-redhat6-None'), ('os=default_os', [Token(TokenType.KEY_VALUE_PAIR, value='os=default_os')], 'arch=test-debian6-None'), ('target=be', [Token(TokenType.KEY_VALUE_PAIR, value='target=be')], f'arch=test-None-{spack.platforms.test.Test.default}'), ('target=default_target', [Token(TokenType.KEY_VALUE_PAIR, value='target=default_target')], f'arch=test-None-{spack.platforms.test.Test.default}'), ('platform=linux', [Token(TokenType.KEY_VALUE_PAIR, value='platform=linux')], 'arch=linux-None-None'), (f\"develop-branch-version@{'abc12' * 8}=develop\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='develop-branch-version'), Token(TokenType.VERSION_HASH_PAIR, value=f\"@{'abc12' * 8}=develop\")], f\"develop-branch-version@{'abc12' * 8}=develop\"), ('x ^y@foo ^y@foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo')], 'x ^y@foo'), ('x ^y@foo ^y+bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.BOOL_VARIANT, value='+bar')], 'x ^y@foo+bar'), ('x ^y@foo +bar ^y@foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.BOOL_VARIANT, value='+bar'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo')], 'x ^y@foo+bar'), ('_openmpi +debug-qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug-qt_4')], '_openmpi+debug-qt_4'), ('_openmpi +debug -qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='-qt_4')], '_openmpi+debug~qt_4'), ('_openmpi +debug~qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4')], '_openmpi+debug~qt_4'), ('target=:broadwell,icelake', [Token(TokenType.KEY_VALUE_PAIR, value='target=:broadwell,icelake')], 'arch=None-None-:broadwell,icelake'), (f\"develop-branch-version@git.{'a' * 40}=develop+var1+var2\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='develop-branch-version'), Token(TokenType.VERSION_HASH_PAIR, value=f\"@git.{'a' * 40}=develop\"), Token(TokenType.BOOL_VARIANT, value='+var1'), Token(TokenType.BOOL_VARIANT, value='+var2')], f\"develop-branch-version@git.{'a' * 40}=develop+var1+var2\"), compiler_with_version_range('%gcc@10.2.1:'), compiler_with_version_range('%gcc@:10.2.1'), compiler_with_version_range('%gcc@10.2.1:12.1.0'), compiler_with_version_range('%gcc@10.1.0,12.2.1:'), compiler_with_version_range('%gcc@:8.4.3,10.2.1:12.1.0'), ('dev_path=*', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=*')], 'dev_path=*'), ('dev_path=none', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=none')], 'dev_path=none'), ('dev_path=../relpath/work', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=../relpath/work')], 'dev_path=../relpath/work'), ('dev_path=/abspath/work', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=/abspath/work')], 'dev_path=/abspath/work'), ('cflags=a=b=c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c')], 'cflags=\"a=b=c\"'), ('cflags=a=b=c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c')], 'cflags=\"a=b=c\"'), ('cflags=a=b=c+~', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c+~')], 'cflags=\"a=b=c+~\"'), ('cflags=-Wl,a,b,c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=-Wl,a,b,c')], 'cflags=\"-Wl,a,b,c\"'), (\"cflags=''-Wl,a,b,c''\", [Token(TokenType.KEY_VALUE_PAIR, value=\"cflags=''-Wl,a,b,c''\")], 'cflags=\"-Wl,a,b,c\"'), ('cflags==\"-O3 -g\"', [Token(TokenType.PROPAGATED_KEY_VALUE_PAIR, value='cflags==\"-O3 -g\"')], 'cflags==\"-O3 -g\"'), ('@1.2:1.4 , 1.6 ', [Token(TokenType.VERSION, value='@1.2:1.4 , 1.6')], '@1.2:1.4,1.6'), ('a@1: b', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='a'), Token(TokenType.VERSION, value='@1:'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='b')], 'a@1:'), ('@1.2:   develop   = foo', [Token(TokenType.VERSION, value='@1.2:'), Token(TokenType.KEY_VALUE_PAIR, value='develop   = foo')], '@1.2: develop=foo'), ('@1.2:develop   = foo', [Token(TokenType.VERSION, value='@1.2:'), Token(TokenType.KEY_VALUE_PAIR, value='develop   = foo')], '@1.2: develop=foo'), ('% intel @ 12.1:12.6 + debug', [Token(TokenType.COMPILER_AND_VERSION, value='% intel @ 12.1:12.6'), Token(TokenType.BOOL_VARIANT, value='+ debug')], '%intel@12.1:12.6+debug'), ('@ 12.1:12.6 + debug - qt_4', [Token(TokenType.VERSION, value='@ 12.1:12.6'), Token(TokenType.BOOL_VARIANT, value='+ debug'), Token(TokenType.BOOL_VARIANT, value='- qt_4')], '@12.1:12.6+debug~qt_4'), ('@10.4.0:10,11.3.0:target=aarch64:', [Token(TokenType.VERSION, value='@10.4.0:10,11.3.0:'), Token(TokenType.KEY_VALUE_PAIR, value='target=aarch64:')], '@10.4.0:10,11.3.0: arch=None-None-aarch64:'), ('@:0.4 % nvhpc', [Token(TokenType.VERSION, value='@:0.4'), Token(TokenType.COMPILER, value='% nvhpc')], '@:0.4%nvhpc'), ('^[virtuals=mpi] openmpi', [Token(TokenType.START_EDGE_PROPERTIES, value='^['), Token(TokenType.KEY_VALUE_PAIR, value='virtuals=mpi'), Token(TokenType.END_EDGE_PROPERTIES, value=']'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi')], '^[virtuals=mpi] openmpi'), ('^[deptypes=link,build] zlib', [Token(TokenType.START_EDGE_PROPERTIES, value='^['), Token(TokenType.KEY_VALUE_PAIR, value='deptypes=link,build'), Token(TokenType.END_EDGE_PROPERTIES, value=']'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], '^[deptypes=build,link] zlib'), ('zlib@git.foo/bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.GIT_VERSION, '@git.foo/bar')], 'zlib@git.foo/bar'), ('zlib ++foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_BOOL_VARIANT, '++foo')], 'zlib++foo'), ('zlib ~~foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_BOOL_VARIANT, '~~foo')], 'zlib~~foo'), ('zlib foo==bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_KEY_VALUE_PAIR, 'foo==bar')], 'zlib foo==bar')])\ndef test_parse_single_spec(spec_str, tokens, expected_roundtrip):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = SpecParser(spec_str)\n    assert parser.tokens() == tokens\n    assert str(parser.next_spec()) == expected_roundtrip",
            "@pytest.mark.parametrize('spec_str,tokens,expected_roundtrip', [simple_package_name('mvapich'), simple_package_name('mvapich_foo'), simple_package_name('_mvapich_foo'), simple_package_name('3dtk'), simple_package_name('ns-3-dev'), ('%intel', [Token(TokenType.COMPILER, value='%intel')], '%intel'), ('@2.7', [Token(TokenType.VERSION, value='@2.7')], '@2.7'), ('@2.7:', [Token(TokenType.VERSION, value='@2.7:')], '@2.7:'), ('@:2.7', [Token(TokenType.VERSION, value='@:2.7')], '@:2.7'), ('+foo', [Token(TokenType.BOOL_VARIANT, value='+foo')], '+foo'), ('~foo', [Token(TokenType.BOOL_VARIANT, value='~foo')], '~foo'), ('-foo', [Token(TokenType.BOOL_VARIANT, value='-foo')], '~foo'), ('platform=test', [Token(TokenType.KEY_VALUE_PAIR, value='platform=test')], 'arch=test-None-None'), ('languages=go @4.2:', [Token(TokenType.KEY_VALUE_PAIR, value='languages=go'), Token(TokenType.VERSION, value='@4.2:')], '@4.2: languages=go'), ('@4.2:     languages=go', [Token(TokenType.VERSION, value='@4.2:'), Token(TokenType.KEY_VALUE_PAIR, value='languages=go')], '@4.2: languages=go'), ('^zlib', [Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], '^zlib'), ('openmpi ^hwloc', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc')], 'openmpi ^hwloc'), ('openmpi ^hwloc ^libunwind', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='libunwind')], 'openmpi ^hwloc ^libunwind'), ('openmpi      ^hwloc^libunwind', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='libunwind')], 'openmpi ^hwloc ^libunwind'), ('foo %bar@1.0 @2.0', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.COMPILER_AND_VERSION, value='%bar@1.0'), Token(TokenType.VERSION, value='@2.0')], 'foo@2.0%bar@1.0'), dependency_with_version('openmpi ^hwloc@1.2e6'), dependency_with_version('openmpi ^hwloc@1.2e6:'), dependency_with_version('openmpi ^hwloc@:1.4b7-rc3'), dependency_with_version('openmpi ^hwloc@1.2e6:1.4b7-rc3'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1+debug~qt_4 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1+debug~qt_4 ^stackwalker@8.1_1e'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1~qt_4 debug=2 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.KEY_VALUE_PAIR, value='debug=2'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1~qt_4 debug=2 ^stackwalker@8.1_1e'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1 cppflags=-O3 +debug~qt_4 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.KEY_VALUE_PAIR, value='cppflags=-O3'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1 cppflags=\"-O3\" +debug~qt_4 ^stackwalker@8.1_1e'), ('yaml-cpp@0.1.8%intel@12.1 ^boost@3.1.4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='yaml-cpp'), Token(TokenType.VERSION, value='@0.1.8'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='boost'), Token(TokenType.VERSION, value='@3.1.4')], 'yaml-cpp@0.1.8%intel@12.1 ^boost@3.1.4'), ('builtin.yaml-cpp%gcc', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.COMPILER, value='%gcc')], 'yaml-cpp%gcc'), ('testrepo.yaml-cpp%gcc', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='testrepo.yaml-cpp'), Token(TokenType.COMPILER, value='%gcc')], 'yaml-cpp%gcc'), ('builtin.yaml-cpp@0.1.8%gcc@7.2.0 ^boost@3.1.4', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.VERSION, value='@0.1.8'), Token(TokenType.COMPILER_AND_VERSION, value='%gcc@7.2.0'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='boost'), Token(TokenType.VERSION, value='@3.1.4')], 'yaml-cpp@0.1.8%gcc@7.2.0 ^boost@3.1.4'), ('builtin.yaml-cpp ^testrepo.boost ^zlib', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='testrepo.boost'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], 'yaml-cpp ^boost ^zlib'), ('mvapich ^stackwalker ^_openmpi', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi')], 'mvapich ^_openmpi ^stackwalker'), ('y~f+e~d+c~b+a', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.BOOL_VARIANT, value='~f'), Token(TokenType.BOOL_VARIANT, value='+e'), Token(TokenType.BOOL_VARIANT, value='~d'), Token(TokenType.BOOL_VARIANT, value='+c'), Token(TokenType.BOOL_VARIANT, value='~b'), Token(TokenType.BOOL_VARIANT, value='+a')], 'y+a~b+c~d+e~f'), ('@:', [Token(TokenType.VERSION, value='@:')], ''), ('@1.6,1.2:1.4', [Token(TokenType.VERSION, value='@1.6,1.2:1.4')], '@1.2:1.4,1.6'), ('os=fe', [Token(TokenType.KEY_VALUE_PAIR, value='os=fe')], 'arch=test-redhat6-None'), ('os=default_os', [Token(TokenType.KEY_VALUE_PAIR, value='os=default_os')], 'arch=test-debian6-None'), ('target=be', [Token(TokenType.KEY_VALUE_PAIR, value='target=be')], f'arch=test-None-{spack.platforms.test.Test.default}'), ('target=default_target', [Token(TokenType.KEY_VALUE_PAIR, value='target=default_target')], f'arch=test-None-{spack.platforms.test.Test.default}'), ('platform=linux', [Token(TokenType.KEY_VALUE_PAIR, value='platform=linux')], 'arch=linux-None-None'), (f\"develop-branch-version@{'abc12' * 8}=develop\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='develop-branch-version'), Token(TokenType.VERSION_HASH_PAIR, value=f\"@{'abc12' * 8}=develop\")], f\"develop-branch-version@{'abc12' * 8}=develop\"), ('x ^y@foo ^y@foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo')], 'x ^y@foo'), ('x ^y@foo ^y+bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.BOOL_VARIANT, value='+bar')], 'x ^y@foo+bar'), ('x ^y@foo +bar ^y@foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.BOOL_VARIANT, value='+bar'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo')], 'x ^y@foo+bar'), ('_openmpi +debug-qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug-qt_4')], '_openmpi+debug-qt_4'), ('_openmpi +debug -qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='-qt_4')], '_openmpi+debug~qt_4'), ('_openmpi +debug~qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4')], '_openmpi+debug~qt_4'), ('target=:broadwell,icelake', [Token(TokenType.KEY_VALUE_PAIR, value='target=:broadwell,icelake')], 'arch=None-None-:broadwell,icelake'), (f\"develop-branch-version@git.{'a' * 40}=develop+var1+var2\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='develop-branch-version'), Token(TokenType.VERSION_HASH_PAIR, value=f\"@git.{'a' * 40}=develop\"), Token(TokenType.BOOL_VARIANT, value='+var1'), Token(TokenType.BOOL_VARIANT, value='+var2')], f\"develop-branch-version@git.{'a' * 40}=develop+var1+var2\"), compiler_with_version_range('%gcc@10.2.1:'), compiler_with_version_range('%gcc@:10.2.1'), compiler_with_version_range('%gcc@10.2.1:12.1.0'), compiler_with_version_range('%gcc@10.1.0,12.2.1:'), compiler_with_version_range('%gcc@:8.4.3,10.2.1:12.1.0'), ('dev_path=*', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=*')], 'dev_path=*'), ('dev_path=none', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=none')], 'dev_path=none'), ('dev_path=../relpath/work', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=../relpath/work')], 'dev_path=../relpath/work'), ('dev_path=/abspath/work', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=/abspath/work')], 'dev_path=/abspath/work'), ('cflags=a=b=c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c')], 'cflags=\"a=b=c\"'), ('cflags=a=b=c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c')], 'cflags=\"a=b=c\"'), ('cflags=a=b=c+~', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c+~')], 'cflags=\"a=b=c+~\"'), ('cflags=-Wl,a,b,c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=-Wl,a,b,c')], 'cflags=\"-Wl,a,b,c\"'), (\"cflags=''-Wl,a,b,c''\", [Token(TokenType.KEY_VALUE_PAIR, value=\"cflags=''-Wl,a,b,c''\")], 'cflags=\"-Wl,a,b,c\"'), ('cflags==\"-O3 -g\"', [Token(TokenType.PROPAGATED_KEY_VALUE_PAIR, value='cflags==\"-O3 -g\"')], 'cflags==\"-O3 -g\"'), ('@1.2:1.4 , 1.6 ', [Token(TokenType.VERSION, value='@1.2:1.4 , 1.6')], '@1.2:1.4,1.6'), ('a@1: b', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='a'), Token(TokenType.VERSION, value='@1:'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='b')], 'a@1:'), ('@1.2:   develop   = foo', [Token(TokenType.VERSION, value='@1.2:'), Token(TokenType.KEY_VALUE_PAIR, value='develop   = foo')], '@1.2: develop=foo'), ('@1.2:develop   = foo', [Token(TokenType.VERSION, value='@1.2:'), Token(TokenType.KEY_VALUE_PAIR, value='develop   = foo')], '@1.2: develop=foo'), ('% intel @ 12.1:12.6 + debug', [Token(TokenType.COMPILER_AND_VERSION, value='% intel @ 12.1:12.6'), Token(TokenType.BOOL_VARIANT, value='+ debug')], '%intel@12.1:12.6+debug'), ('@ 12.1:12.6 + debug - qt_4', [Token(TokenType.VERSION, value='@ 12.1:12.6'), Token(TokenType.BOOL_VARIANT, value='+ debug'), Token(TokenType.BOOL_VARIANT, value='- qt_4')], '@12.1:12.6+debug~qt_4'), ('@10.4.0:10,11.3.0:target=aarch64:', [Token(TokenType.VERSION, value='@10.4.0:10,11.3.0:'), Token(TokenType.KEY_VALUE_PAIR, value='target=aarch64:')], '@10.4.0:10,11.3.0: arch=None-None-aarch64:'), ('@:0.4 % nvhpc', [Token(TokenType.VERSION, value='@:0.4'), Token(TokenType.COMPILER, value='% nvhpc')], '@:0.4%nvhpc'), ('^[virtuals=mpi] openmpi', [Token(TokenType.START_EDGE_PROPERTIES, value='^['), Token(TokenType.KEY_VALUE_PAIR, value='virtuals=mpi'), Token(TokenType.END_EDGE_PROPERTIES, value=']'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi')], '^[virtuals=mpi] openmpi'), ('^[deptypes=link,build] zlib', [Token(TokenType.START_EDGE_PROPERTIES, value='^['), Token(TokenType.KEY_VALUE_PAIR, value='deptypes=link,build'), Token(TokenType.END_EDGE_PROPERTIES, value=']'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], '^[deptypes=build,link] zlib'), ('zlib@git.foo/bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.GIT_VERSION, '@git.foo/bar')], 'zlib@git.foo/bar'), ('zlib ++foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_BOOL_VARIANT, '++foo')], 'zlib++foo'), ('zlib ~~foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_BOOL_VARIANT, '~~foo')], 'zlib~~foo'), ('zlib foo==bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_KEY_VALUE_PAIR, 'foo==bar')], 'zlib foo==bar')])\ndef test_parse_single_spec(spec_str, tokens, expected_roundtrip):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = SpecParser(spec_str)\n    assert parser.tokens() == tokens\n    assert str(parser.next_spec()) == expected_roundtrip",
            "@pytest.mark.parametrize('spec_str,tokens,expected_roundtrip', [simple_package_name('mvapich'), simple_package_name('mvapich_foo'), simple_package_name('_mvapich_foo'), simple_package_name('3dtk'), simple_package_name('ns-3-dev'), ('%intel', [Token(TokenType.COMPILER, value='%intel')], '%intel'), ('@2.7', [Token(TokenType.VERSION, value='@2.7')], '@2.7'), ('@2.7:', [Token(TokenType.VERSION, value='@2.7:')], '@2.7:'), ('@:2.7', [Token(TokenType.VERSION, value='@:2.7')], '@:2.7'), ('+foo', [Token(TokenType.BOOL_VARIANT, value='+foo')], '+foo'), ('~foo', [Token(TokenType.BOOL_VARIANT, value='~foo')], '~foo'), ('-foo', [Token(TokenType.BOOL_VARIANT, value='-foo')], '~foo'), ('platform=test', [Token(TokenType.KEY_VALUE_PAIR, value='platform=test')], 'arch=test-None-None'), ('languages=go @4.2:', [Token(TokenType.KEY_VALUE_PAIR, value='languages=go'), Token(TokenType.VERSION, value='@4.2:')], '@4.2: languages=go'), ('@4.2:     languages=go', [Token(TokenType.VERSION, value='@4.2:'), Token(TokenType.KEY_VALUE_PAIR, value='languages=go')], '@4.2: languages=go'), ('^zlib', [Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], '^zlib'), ('openmpi ^hwloc', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc')], 'openmpi ^hwloc'), ('openmpi ^hwloc ^libunwind', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='libunwind')], 'openmpi ^hwloc ^libunwind'), ('openmpi      ^hwloc^libunwind', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='libunwind')], 'openmpi ^hwloc ^libunwind'), ('foo %bar@1.0 @2.0', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.COMPILER_AND_VERSION, value='%bar@1.0'), Token(TokenType.VERSION, value='@2.0')], 'foo@2.0%bar@1.0'), dependency_with_version('openmpi ^hwloc@1.2e6'), dependency_with_version('openmpi ^hwloc@1.2e6:'), dependency_with_version('openmpi ^hwloc@:1.4b7-rc3'), dependency_with_version('openmpi ^hwloc@1.2e6:1.4b7-rc3'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1+debug~qt_4 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1+debug~qt_4 ^stackwalker@8.1_1e'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1~qt_4 debug=2 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.KEY_VALUE_PAIR, value='debug=2'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1~qt_4 debug=2 ^stackwalker@8.1_1e'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1 cppflags=-O3 +debug~qt_4 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.KEY_VALUE_PAIR, value='cppflags=-O3'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1 cppflags=\"-O3\" +debug~qt_4 ^stackwalker@8.1_1e'), ('yaml-cpp@0.1.8%intel@12.1 ^boost@3.1.4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='yaml-cpp'), Token(TokenType.VERSION, value='@0.1.8'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='boost'), Token(TokenType.VERSION, value='@3.1.4')], 'yaml-cpp@0.1.8%intel@12.1 ^boost@3.1.4'), ('builtin.yaml-cpp%gcc', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.COMPILER, value='%gcc')], 'yaml-cpp%gcc'), ('testrepo.yaml-cpp%gcc', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='testrepo.yaml-cpp'), Token(TokenType.COMPILER, value='%gcc')], 'yaml-cpp%gcc'), ('builtin.yaml-cpp@0.1.8%gcc@7.2.0 ^boost@3.1.4', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.VERSION, value='@0.1.8'), Token(TokenType.COMPILER_AND_VERSION, value='%gcc@7.2.0'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='boost'), Token(TokenType.VERSION, value='@3.1.4')], 'yaml-cpp@0.1.8%gcc@7.2.0 ^boost@3.1.4'), ('builtin.yaml-cpp ^testrepo.boost ^zlib', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='testrepo.boost'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], 'yaml-cpp ^boost ^zlib'), ('mvapich ^stackwalker ^_openmpi', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi')], 'mvapich ^_openmpi ^stackwalker'), ('y~f+e~d+c~b+a', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.BOOL_VARIANT, value='~f'), Token(TokenType.BOOL_VARIANT, value='+e'), Token(TokenType.BOOL_VARIANT, value='~d'), Token(TokenType.BOOL_VARIANT, value='+c'), Token(TokenType.BOOL_VARIANT, value='~b'), Token(TokenType.BOOL_VARIANT, value='+a')], 'y+a~b+c~d+e~f'), ('@:', [Token(TokenType.VERSION, value='@:')], ''), ('@1.6,1.2:1.4', [Token(TokenType.VERSION, value='@1.6,1.2:1.4')], '@1.2:1.4,1.6'), ('os=fe', [Token(TokenType.KEY_VALUE_PAIR, value='os=fe')], 'arch=test-redhat6-None'), ('os=default_os', [Token(TokenType.KEY_VALUE_PAIR, value='os=default_os')], 'arch=test-debian6-None'), ('target=be', [Token(TokenType.KEY_VALUE_PAIR, value='target=be')], f'arch=test-None-{spack.platforms.test.Test.default}'), ('target=default_target', [Token(TokenType.KEY_VALUE_PAIR, value='target=default_target')], f'arch=test-None-{spack.platforms.test.Test.default}'), ('platform=linux', [Token(TokenType.KEY_VALUE_PAIR, value='platform=linux')], 'arch=linux-None-None'), (f\"develop-branch-version@{'abc12' * 8}=develop\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='develop-branch-version'), Token(TokenType.VERSION_HASH_PAIR, value=f\"@{'abc12' * 8}=develop\")], f\"develop-branch-version@{'abc12' * 8}=develop\"), ('x ^y@foo ^y@foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo')], 'x ^y@foo'), ('x ^y@foo ^y+bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.BOOL_VARIANT, value='+bar')], 'x ^y@foo+bar'), ('x ^y@foo +bar ^y@foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.BOOL_VARIANT, value='+bar'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo')], 'x ^y@foo+bar'), ('_openmpi +debug-qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug-qt_4')], '_openmpi+debug-qt_4'), ('_openmpi +debug -qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='-qt_4')], '_openmpi+debug~qt_4'), ('_openmpi +debug~qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4')], '_openmpi+debug~qt_4'), ('target=:broadwell,icelake', [Token(TokenType.KEY_VALUE_PAIR, value='target=:broadwell,icelake')], 'arch=None-None-:broadwell,icelake'), (f\"develop-branch-version@git.{'a' * 40}=develop+var1+var2\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='develop-branch-version'), Token(TokenType.VERSION_HASH_PAIR, value=f\"@git.{'a' * 40}=develop\"), Token(TokenType.BOOL_VARIANT, value='+var1'), Token(TokenType.BOOL_VARIANT, value='+var2')], f\"develop-branch-version@git.{'a' * 40}=develop+var1+var2\"), compiler_with_version_range('%gcc@10.2.1:'), compiler_with_version_range('%gcc@:10.2.1'), compiler_with_version_range('%gcc@10.2.1:12.1.0'), compiler_with_version_range('%gcc@10.1.0,12.2.1:'), compiler_with_version_range('%gcc@:8.4.3,10.2.1:12.1.0'), ('dev_path=*', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=*')], 'dev_path=*'), ('dev_path=none', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=none')], 'dev_path=none'), ('dev_path=../relpath/work', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=../relpath/work')], 'dev_path=../relpath/work'), ('dev_path=/abspath/work', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=/abspath/work')], 'dev_path=/abspath/work'), ('cflags=a=b=c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c')], 'cflags=\"a=b=c\"'), ('cflags=a=b=c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c')], 'cflags=\"a=b=c\"'), ('cflags=a=b=c+~', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c+~')], 'cflags=\"a=b=c+~\"'), ('cflags=-Wl,a,b,c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=-Wl,a,b,c')], 'cflags=\"-Wl,a,b,c\"'), (\"cflags=''-Wl,a,b,c''\", [Token(TokenType.KEY_VALUE_PAIR, value=\"cflags=''-Wl,a,b,c''\")], 'cflags=\"-Wl,a,b,c\"'), ('cflags==\"-O3 -g\"', [Token(TokenType.PROPAGATED_KEY_VALUE_PAIR, value='cflags==\"-O3 -g\"')], 'cflags==\"-O3 -g\"'), ('@1.2:1.4 , 1.6 ', [Token(TokenType.VERSION, value='@1.2:1.4 , 1.6')], '@1.2:1.4,1.6'), ('a@1: b', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='a'), Token(TokenType.VERSION, value='@1:'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='b')], 'a@1:'), ('@1.2:   develop   = foo', [Token(TokenType.VERSION, value='@1.2:'), Token(TokenType.KEY_VALUE_PAIR, value='develop   = foo')], '@1.2: develop=foo'), ('@1.2:develop   = foo', [Token(TokenType.VERSION, value='@1.2:'), Token(TokenType.KEY_VALUE_PAIR, value='develop   = foo')], '@1.2: develop=foo'), ('% intel @ 12.1:12.6 + debug', [Token(TokenType.COMPILER_AND_VERSION, value='% intel @ 12.1:12.6'), Token(TokenType.BOOL_VARIANT, value='+ debug')], '%intel@12.1:12.6+debug'), ('@ 12.1:12.6 + debug - qt_4', [Token(TokenType.VERSION, value='@ 12.1:12.6'), Token(TokenType.BOOL_VARIANT, value='+ debug'), Token(TokenType.BOOL_VARIANT, value='- qt_4')], '@12.1:12.6+debug~qt_4'), ('@10.4.0:10,11.3.0:target=aarch64:', [Token(TokenType.VERSION, value='@10.4.0:10,11.3.0:'), Token(TokenType.KEY_VALUE_PAIR, value='target=aarch64:')], '@10.4.0:10,11.3.0: arch=None-None-aarch64:'), ('@:0.4 % nvhpc', [Token(TokenType.VERSION, value='@:0.4'), Token(TokenType.COMPILER, value='% nvhpc')], '@:0.4%nvhpc'), ('^[virtuals=mpi] openmpi', [Token(TokenType.START_EDGE_PROPERTIES, value='^['), Token(TokenType.KEY_VALUE_PAIR, value='virtuals=mpi'), Token(TokenType.END_EDGE_PROPERTIES, value=']'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi')], '^[virtuals=mpi] openmpi'), ('^[deptypes=link,build] zlib', [Token(TokenType.START_EDGE_PROPERTIES, value='^['), Token(TokenType.KEY_VALUE_PAIR, value='deptypes=link,build'), Token(TokenType.END_EDGE_PROPERTIES, value=']'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], '^[deptypes=build,link] zlib'), ('zlib@git.foo/bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.GIT_VERSION, '@git.foo/bar')], 'zlib@git.foo/bar'), ('zlib ++foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_BOOL_VARIANT, '++foo')], 'zlib++foo'), ('zlib ~~foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_BOOL_VARIANT, '~~foo')], 'zlib~~foo'), ('zlib foo==bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_KEY_VALUE_PAIR, 'foo==bar')], 'zlib foo==bar')])\ndef test_parse_single_spec(spec_str, tokens, expected_roundtrip):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = SpecParser(spec_str)\n    assert parser.tokens() == tokens\n    assert str(parser.next_spec()) == expected_roundtrip",
            "@pytest.mark.parametrize('spec_str,tokens,expected_roundtrip', [simple_package_name('mvapich'), simple_package_name('mvapich_foo'), simple_package_name('_mvapich_foo'), simple_package_name('3dtk'), simple_package_name('ns-3-dev'), ('%intel', [Token(TokenType.COMPILER, value='%intel')], '%intel'), ('@2.7', [Token(TokenType.VERSION, value='@2.7')], '@2.7'), ('@2.7:', [Token(TokenType.VERSION, value='@2.7:')], '@2.7:'), ('@:2.7', [Token(TokenType.VERSION, value='@:2.7')], '@:2.7'), ('+foo', [Token(TokenType.BOOL_VARIANT, value='+foo')], '+foo'), ('~foo', [Token(TokenType.BOOL_VARIANT, value='~foo')], '~foo'), ('-foo', [Token(TokenType.BOOL_VARIANT, value='-foo')], '~foo'), ('platform=test', [Token(TokenType.KEY_VALUE_PAIR, value='platform=test')], 'arch=test-None-None'), ('languages=go @4.2:', [Token(TokenType.KEY_VALUE_PAIR, value='languages=go'), Token(TokenType.VERSION, value='@4.2:')], '@4.2: languages=go'), ('@4.2:     languages=go', [Token(TokenType.VERSION, value='@4.2:'), Token(TokenType.KEY_VALUE_PAIR, value='languages=go')], '@4.2: languages=go'), ('^zlib', [Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], '^zlib'), ('openmpi ^hwloc', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc')], 'openmpi ^hwloc'), ('openmpi ^hwloc ^libunwind', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='libunwind')], 'openmpi ^hwloc ^libunwind'), ('openmpi      ^hwloc^libunwind', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='hwloc'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='libunwind')], 'openmpi ^hwloc ^libunwind'), ('foo %bar@1.0 @2.0', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.COMPILER_AND_VERSION, value='%bar@1.0'), Token(TokenType.VERSION, value='@2.0')], 'foo@2.0%bar@1.0'), dependency_with_version('openmpi ^hwloc@1.2e6'), dependency_with_version('openmpi ^hwloc@1.2e6:'), dependency_with_version('openmpi ^hwloc@:1.4b7-rc3'), dependency_with_version('openmpi ^hwloc@1.2e6:1.4b7-rc3'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1+debug~qt_4 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1+debug~qt_4 ^stackwalker@8.1_1e'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1~qt_4 debug=2 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.KEY_VALUE_PAIR, value='debug=2'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1~qt_4 debug=2 ^stackwalker@8.1_1e'), ('mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1 cppflags=-O3 +debug~qt_4 ^stackwalker@8.1_1e', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich_foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.VERSION, value='@1.2:1.4,1.6'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.KEY_VALUE_PAIR, value='cppflags=-O3'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.VERSION, value='@8.1_1e')], 'mvapich_foo ^_openmpi@1.2:1.4,1.6%intel@12.1 cppflags=\"-O3\" +debug~qt_4 ^stackwalker@8.1_1e'), ('yaml-cpp@0.1.8%intel@12.1 ^boost@3.1.4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='yaml-cpp'), Token(TokenType.VERSION, value='@0.1.8'), Token(TokenType.COMPILER_AND_VERSION, value='%intel@12.1'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='boost'), Token(TokenType.VERSION, value='@3.1.4')], 'yaml-cpp@0.1.8%intel@12.1 ^boost@3.1.4'), ('builtin.yaml-cpp%gcc', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.COMPILER, value='%gcc')], 'yaml-cpp%gcc'), ('testrepo.yaml-cpp%gcc', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='testrepo.yaml-cpp'), Token(TokenType.COMPILER, value='%gcc')], 'yaml-cpp%gcc'), ('builtin.yaml-cpp@0.1.8%gcc@7.2.0 ^boost@3.1.4', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.VERSION, value='@0.1.8'), Token(TokenType.COMPILER_AND_VERSION, value='%gcc@7.2.0'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='boost'), Token(TokenType.VERSION, value='@3.1.4')], 'yaml-cpp@0.1.8%gcc@7.2.0 ^boost@3.1.4'), ('builtin.yaml-cpp ^testrepo.boost ^zlib', [Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='builtin.yaml-cpp'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.FULLY_QUALIFIED_PACKAGE_NAME, value='testrepo.boost'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], 'yaml-cpp ^boost ^zlib'), ('mvapich ^stackwalker ^_openmpi', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='stackwalker'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi')], 'mvapich ^_openmpi ^stackwalker'), ('y~f+e~d+c~b+a', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.BOOL_VARIANT, value='~f'), Token(TokenType.BOOL_VARIANT, value='+e'), Token(TokenType.BOOL_VARIANT, value='~d'), Token(TokenType.BOOL_VARIANT, value='+c'), Token(TokenType.BOOL_VARIANT, value='~b'), Token(TokenType.BOOL_VARIANT, value='+a')], 'y+a~b+c~d+e~f'), ('@:', [Token(TokenType.VERSION, value='@:')], ''), ('@1.6,1.2:1.4', [Token(TokenType.VERSION, value='@1.6,1.2:1.4')], '@1.2:1.4,1.6'), ('os=fe', [Token(TokenType.KEY_VALUE_PAIR, value='os=fe')], 'arch=test-redhat6-None'), ('os=default_os', [Token(TokenType.KEY_VALUE_PAIR, value='os=default_os')], 'arch=test-debian6-None'), ('target=be', [Token(TokenType.KEY_VALUE_PAIR, value='target=be')], f'arch=test-None-{spack.platforms.test.Test.default}'), ('target=default_target', [Token(TokenType.KEY_VALUE_PAIR, value='target=default_target')], f'arch=test-None-{spack.platforms.test.Test.default}'), ('platform=linux', [Token(TokenType.KEY_VALUE_PAIR, value='platform=linux')], 'arch=linux-None-None'), (f\"develop-branch-version@{'abc12' * 8}=develop\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='develop-branch-version'), Token(TokenType.VERSION_HASH_PAIR, value=f\"@{'abc12' * 8}=develop\")], f\"develop-branch-version@{'abc12' * 8}=develop\"), ('x ^y@foo ^y@foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo')], 'x ^y@foo'), ('x ^y@foo ^y+bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.BOOL_VARIANT, value='+bar')], 'x ^y@foo+bar'), ('x ^y@foo +bar ^y@foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='x'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo'), Token(TokenType.BOOL_VARIANT, value='+bar'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='y'), Token(TokenType.VERSION, value='@foo')], 'x ^y@foo+bar'), ('_openmpi +debug-qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug-qt_4')], '_openmpi+debug-qt_4'), ('_openmpi +debug -qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='-qt_4')], '_openmpi+debug~qt_4'), ('_openmpi +debug~qt_4', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='_openmpi'), Token(TokenType.BOOL_VARIANT, value='+debug'), Token(TokenType.BOOL_VARIANT, value='~qt_4')], '_openmpi+debug~qt_4'), ('target=:broadwell,icelake', [Token(TokenType.KEY_VALUE_PAIR, value='target=:broadwell,icelake')], 'arch=None-None-:broadwell,icelake'), (f\"develop-branch-version@git.{'a' * 40}=develop+var1+var2\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='develop-branch-version'), Token(TokenType.VERSION_HASH_PAIR, value=f\"@git.{'a' * 40}=develop\"), Token(TokenType.BOOL_VARIANT, value='+var1'), Token(TokenType.BOOL_VARIANT, value='+var2')], f\"develop-branch-version@git.{'a' * 40}=develop+var1+var2\"), compiler_with_version_range('%gcc@10.2.1:'), compiler_with_version_range('%gcc@:10.2.1'), compiler_with_version_range('%gcc@10.2.1:12.1.0'), compiler_with_version_range('%gcc@10.1.0,12.2.1:'), compiler_with_version_range('%gcc@:8.4.3,10.2.1:12.1.0'), ('dev_path=*', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=*')], 'dev_path=*'), ('dev_path=none', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=none')], 'dev_path=none'), ('dev_path=../relpath/work', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=../relpath/work')], 'dev_path=../relpath/work'), ('dev_path=/abspath/work', [Token(TokenType.KEY_VALUE_PAIR, value='dev_path=/abspath/work')], 'dev_path=/abspath/work'), ('cflags=a=b=c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c')], 'cflags=\"a=b=c\"'), ('cflags=a=b=c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c')], 'cflags=\"a=b=c\"'), ('cflags=a=b=c+~', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=a=b=c+~')], 'cflags=\"a=b=c+~\"'), ('cflags=-Wl,a,b,c', [Token(TokenType.KEY_VALUE_PAIR, value='cflags=-Wl,a,b,c')], 'cflags=\"-Wl,a,b,c\"'), (\"cflags=''-Wl,a,b,c''\", [Token(TokenType.KEY_VALUE_PAIR, value=\"cflags=''-Wl,a,b,c''\")], 'cflags=\"-Wl,a,b,c\"'), ('cflags==\"-O3 -g\"', [Token(TokenType.PROPAGATED_KEY_VALUE_PAIR, value='cflags==\"-O3 -g\"')], 'cflags==\"-O3 -g\"'), ('@1.2:1.4 , 1.6 ', [Token(TokenType.VERSION, value='@1.2:1.4 , 1.6')], '@1.2:1.4,1.6'), ('a@1: b', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='a'), Token(TokenType.VERSION, value='@1:'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='b')], 'a@1:'), ('@1.2:   develop   = foo', [Token(TokenType.VERSION, value='@1.2:'), Token(TokenType.KEY_VALUE_PAIR, value='develop   = foo')], '@1.2: develop=foo'), ('@1.2:develop   = foo', [Token(TokenType.VERSION, value='@1.2:'), Token(TokenType.KEY_VALUE_PAIR, value='develop   = foo')], '@1.2: develop=foo'), ('% intel @ 12.1:12.6 + debug', [Token(TokenType.COMPILER_AND_VERSION, value='% intel @ 12.1:12.6'), Token(TokenType.BOOL_VARIANT, value='+ debug')], '%intel@12.1:12.6+debug'), ('@ 12.1:12.6 + debug - qt_4', [Token(TokenType.VERSION, value='@ 12.1:12.6'), Token(TokenType.BOOL_VARIANT, value='+ debug'), Token(TokenType.BOOL_VARIANT, value='- qt_4')], '@12.1:12.6+debug~qt_4'), ('@10.4.0:10,11.3.0:target=aarch64:', [Token(TokenType.VERSION, value='@10.4.0:10,11.3.0:'), Token(TokenType.KEY_VALUE_PAIR, value='target=aarch64:')], '@10.4.0:10,11.3.0: arch=None-None-aarch64:'), ('@:0.4 % nvhpc', [Token(TokenType.VERSION, value='@:0.4'), Token(TokenType.COMPILER, value='% nvhpc')], '@:0.4%nvhpc'), ('^[virtuals=mpi] openmpi', [Token(TokenType.START_EDGE_PROPERTIES, value='^['), Token(TokenType.KEY_VALUE_PAIR, value='virtuals=mpi'), Token(TokenType.END_EDGE_PROPERTIES, value=']'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='openmpi')], '^[virtuals=mpi] openmpi'), ('^[deptypes=link,build] zlib', [Token(TokenType.START_EDGE_PROPERTIES, value='^['), Token(TokenType.KEY_VALUE_PAIR, value='deptypes=link,build'), Token(TokenType.END_EDGE_PROPERTIES, value=']'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='zlib')], '^[deptypes=build,link] zlib'), ('zlib@git.foo/bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.GIT_VERSION, '@git.foo/bar')], 'zlib@git.foo/bar'), ('zlib ++foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_BOOL_VARIANT, '++foo')], 'zlib++foo'), ('zlib ~~foo', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_BOOL_VARIANT, '~~foo')], 'zlib~~foo'), ('zlib foo==bar', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, 'zlib'), Token(TokenType.PROPAGATED_KEY_VALUE_PAIR, 'foo==bar')], 'zlib foo==bar')])\ndef test_parse_single_spec(spec_str, tokens, expected_roundtrip):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = SpecParser(spec_str)\n    assert parser.tokens() == tokens\n    assert str(parser.next_spec()) == expected_roundtrip"
        ]
    },
    {
        "func_name": "test_parse_multiple_specs",
        "original": "@pytest.mark.parametrize('text,tokens,expected_specs', [('mvapich emacs', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], ['mvapich', 'emacs']), (\"mvapich cppflags='-O3 -fPIC' emacs\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value=\"cppflags='-O3 -fPIC'\"), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], [\"mvapich cppflags='-O3 -fPIC'\", 'emacs']), ('mvapich cppflags=-O3 emacs', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value='cppflags=-O3'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], ['mvapich cppflags=-O3', 'emacs']), ('mvapich emacs @1.1.1 %intel cflags=-O3', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs'), Token(TokenType.VERSION, value='@1.1.1'), Token(TokenType.COMPILER, value='%intel'), Token(TokenType.KEY_VALUE_PAIR, value='cflags=-O3')], ['mvapich', 'emacs @1.1.1 %intel cflags=-O3']), ('mvapich cflags=\"-O3 -fPIC\" emacs^ncurses%intel', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value='cflags=\"-O3 -fPIC\"'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='ncurses'), Token(TokenType.COMPILER, value='%intel')], ['mvapich cflags=\"-O3 -fPIC\"', 'emacs ^ncurses%intel'])])\ndef test_parse_multiple_specs(text, tokens, expected_specs):\n    total_parser = SpecParser(text)\n    assert total_parser.tokens() == tokens\n    for single_spec_text in expected_specs:\n        single_spec_parser = SpecParser(single_spec_text)\n        assert str(total_parser.next_spec()) == str(single_spec_parser.next_spec())",
        "mutated": [
            "@pytest.mark.parametrize('text,tokens,expected_specs', [('mvapich emacs', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], ['mvapich', 'emacs']), (\"mvapich cppflags='-O3 -fPIC' emacs\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value=\"cppflags='-O3 -fPIC'\"), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], [\"mvapich cppflags='-O3 -fPIC'\", 'emacs']), ('mvapich cppflags=-O3 emacs', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value='cppflags=-O3'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], ['mvapich cppflags=-O3', 'emacs']), ('mvapich emacs @1.1.1 %intel cflags=-O3', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs'), Token(TokenType.VERSION, value='@1.1.1'), Token(TokenType.COMPILER, value='%intel'), Token(TokenType.KEY_VALUE_PAIR, value='cflags=-O3')], ['mvapich', 'emacs @1.1.1 %intel cflags=-O3']), ('mvapich cflags=\"-O3 -fPIC\" emacs^ncurses%intel', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value='cflags=\"-O3 -fPIC\"'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='ncurses'), Token(TokenType.COMPILER, value='%intel')], ['mvapich cflags=\"-O3 -fPIC\"', 'emacs ^ncurses%intel'])])\ndef test_parse_multiple_specs(text, tokens, expected_specs):\n    if False:\n        i = 10\n    total_parser = SpecParser(text)\n    assert total_parser.tokens() == tokens\n    for single_spec_text in expected_specs:\n        single_spec_parser = SpecParser(single_spec_text)\n        assert str(total_parser.next_spec()) == str(single_spec_parser.next_spec())",
            "@pytest.mark.parametrize('text,tokens,expected_specs', [('mvapich emacs', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], ['mvapich', 'emacs']), (\"mvapich cppflags='-O3 -fPIC' emacs\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value=\"cppflags='-O3 -fPIC'\"), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], [\"mvapich cppflags='-O3 -fPIC'\", 'emacs']), ('mvapich cppflags=-O3 emacs', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value='cppflags=-O3'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], ['mvapich cppflags=-O3', 'emacs']), ('mvapich emacs @1.1.1 %intel cflags=-O3', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs'), Token(TokenType.VERSION, value='@1.1.1'), Token(TokenType.COMPILER, value='%intel'), Token(TokenType.KEY_VALUE_PAIR, value='cflags=-O3')], ['mvapich', 'emacs @1.1.1 %intel cflags=-O3']), ('mvapich cflags=\"-O3 -fPIC\" emacs^ncurses%intel', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value='cflags=\"-O3 -fPIC\"'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='ncurses'), Token(TokenType.COMPILER, value='%intel')], ['mvapich cflags=\"-O3 -fPIC\"', 'emacs ^ncurses%intel'])])\ndef test_parse_multiple_specs(text, tokens, expected_specs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    total_parser = SpecParser(text)\n    assert total_parser.tokens() == tokens\n    for single_spec_text in expected_specs:\n        single_spec_parser = SpecParser(single_spec_text)\n        assert str(total_parser.next_spec()) == str(single_spec_parser.next_spec())",
            "@pytest.mark.parametrize('text,tokens,expected_specs', [('mvapich emacs', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], ['mvapich', 'emacs']), (\"mvapich cppflags='-O3 -fPIC' emacs\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value=\"cppflags='-O3 -fPIC'\"), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], [\"mvapich cppflags='-O3 -fPIC'\", 'emacs']), ('mvapich cppflags=-O3 emacs', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value='cppflags=-O3'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], ['mvapich cppflags=-O3', 'emacs']), ('mvapich emacs @1.1.1 %intel cflags=-O3', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs'), Token(TokenType.VERSION, value='@1.1.1'), Token(TokenType.COMPILER, value='%intel'), Token(TokenType.KEY_VALUE_PAIR, value='cflags=-O3')], ['mvapich', 'emacs @1.1.1 %intel cflags=-O3']), ('mvapich cflags=\"-O3 -fPIC\" emacs^ncurses%intel', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value='cflags=\"-O3 -fPIC\"'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='ncurses'), Token(TokenType.COMPILER, value='%intel')], ['mvapich cflags=\"-O3 -fPIC\"', 'emacs ^ncurses%intel'])])\ndef test_parse_multiple_specs(text, tokens, expected_specs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    total_parser = SpecParser(text)\n    assert total_parser.tokens() == tokens\n    for single_spec_text in expected_specs:\n        single_spec_parser = SpecParser(single_spec_text)\n        assert str(total_parser.next_spec()) == str(single_spec_parser.next_spec())",
            "@pytest.mark.parametrize('text,tokens,expected_specs', [('mvapich emacs', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], ['mvapich', 'emacs']), (\"mvapich cppflags='-O3 -fPIC' emacs\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value=\"cppflags='-O3 -fPIC'\"), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], [\"mvapich cppflags='-O3 -fPIC'\", 'emacs']), ('mvapich cppflags=-O3 emacs', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value='cppflags=-O3'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], ['mvapich cppflags=-O3', 'emacs']), ('mvapich emacs @1.1.1 %intel cflags=-O3', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs'), Token(TokenType.VERSION, value='@1.1.1'), Token(TokenType.COMPILER, value='%intel'), Token(TokenType.KEY_VALUE_PAIR, value='cflags=-O3')], ['mvapich', 'emacs @1.1.1 %intel cflags=-O3']), ('mvapich cflags=\"-O3 -fPIC\" emacs^ncurses%intel', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value='cflags=\"-O3 -fPIC\"'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='ncurses'), Token(TokenType.COMPILER, value='%intel')], ['mvapich cflags=\"-O3 -fPIC\"', 'emacs ^ncurses%intel'])])\ndef test_parse_multiple_specs(text, tokens, expected_specs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    total_parser = SpecParser(text)\n    assert total_parser.tokens() == tokens\n    for single_spec_text in expected_specs:\n        single_spec_parser = SpecParser(single_spec_text)\n        assert str(total_parser.next_spec()) == str(single_spec_parser.next_spec())",
            "@pytest.mark.parametrize('text,tokens,expected_specs', [('mvapich emacs', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], ['mvapich', 'emacs']), (\"mvapich cppflags='-O3 -fPIC' emacs\", [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value=\"cppflags='-O3 -fPIC'\"), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], [\"mvapich cppflags='-O3 -fPIC'\", 'emacs']), ('mvapich cppflags=-O3 emacs', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value='cppflags=-O3'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs')], ['mvapich cppflags=-O3', 'emacs']), ('mvapich emacs @1.1.1 %intel cflags=-O3', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs'), Token(TokenType.VERSION, value='@1.1.1'), Token(TokenType.COMPILER, value='%intel'), Token(TokenType.KEY_VALUE_PAIR, value='cflags=-O3')], ['mvapich', 'emacs @1.1.1 %intel cflags=-O3']), ('mvapich cflags=\"-O3 -fPIC\" emacs^ncurses%intel', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='mvapich'), Token(TokenType.KEY_VALUE_PAIR, value='cflags=\"-O3 -fPIC\"'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='emacs'), Token(TokenType.DEPENDENCY, value='^'), Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='ncurses'), Token(TokenType.COMPILER, value='%intel')], ['mvapich cflags=\"-O3 -fPIC\"', 'emacs ^ncurses%intel'])])\ndef test_parse_multiple_specs(text, tokens, expected_specs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    total_parser = SpecParser(text)\n    assert total_parser.tokens() == tokens\n    for single_spec_text in expected_specs:\n        single_spec_parser = SpecParser(single_spec_text)\n        assert str(total_parser.next_spec()) == str(single_spec_parser.next_spec())"
        ]
    },
    {
        "func_name": "test_error_reporting",
        "original": "@pytest.mark.parametrize('text,expected_in_error', [('x@@1.2', 'x@@1.2\\n ^^^^^'), ('y ^x@@1.2', 'y ^x@@1.2\\n   ^^^^^'), ('x@1.2::', 'x@1.2::\\n      ^'), ('x::', 'x::\\n ^^')])\ndef test_error_reporting(text, expected_in_error):\n    parser = SpecParser(text)\n    with pytest.raises(SpecTokenizationError) as exc:\n        parser.tokens()\n        assert expected_in_error in str(exc), parser.tokens()",
        "mutated": [
            "@pytest.mark.parametrize('text,expected_in_error', [('x@@1.2', 'x@@1.2\\n ^^^^^'), ('y ^x@@1.2', 'y ^x@@1.2\\n   ^^^^^'), ('x@1.2::', 'x@1.2::\\n      ^'), ('x::', 'x::\\n ^^')])\ndef test_error_reporting(text, expected_in_error):\n    if False:\n        i = 10\n    parser = SpecParser(text)\n    with pytest.raises(SpecTokenizationError) as exc:\n        parser.tokens()\n        assert expected_in_error in str(exc), parser.tokens()",
            "@pytest.mark.parametrize('text,expected_in_error', [('x@@1.2', 'x@@1.2\\n ^^^^^'), ('y ^x@@1.2', 'y ^x@@1.2\\n   ^^^^^'), ('x@1.2::', 'x@1.2::\\n      ^'), ('x::', 'x::\\n ^^')])\ndef test_error_reporting(text, expected_in_error):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = SpecParser(text)\n    with pytest.raises(SpecTokenizationError) as exc:\n        parser.tokens()\n        assert expected_in_error in str(exc), parser.tokens()",
            "@pytest.mark.parametrize('text,expected_in_error', [('x@@1.2', 'x@@1.2\\n ^^^^^'), ('y ^x@@1.2', 'y ^x@@1.2\\n   ^^^^^'), ('x@1.2::', 'x@1.2::\\n      ^'), ('x::', 'x::\\n ^^')])\ndef test_error_reporting(text, expected_in_error):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = SpecParser(text)\n    with pytest.raises(SpecTokenizationError) as exc:\n        parser.tokens()\n        assert expected_in_error in str(exc), parser.tokens()",
            "@pytest.mark.parametrize('text,expected_in_error', [('x@@1.2', 'x@@1.2\\n ^^^^^'), ('y ^x@@1.2', 'y ^x@@1.2\\n   ^^^^^'), ('x@1.2::', 'x@1.2::\\n      ^'), ('x::', 'x::\\n ^^')])\ndef test_error_reporting(text, expected_in_error):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = SpecParser(text)\n    with pytest.raises(SpecTokenizationError) as exc:\n        parser.tokens()\n        assert expected_in_error in str(exc), parser.tokens()",
            "@pytest.mark.parametrize('text,expected_in_error', [('x@@1.2', 'x@@1.2\\n ^^^^^'), ('y ^x@@1.2', 'y ^x@@1.2\\n   ^^^^^'), ('x@1.2::', 'x@1.2::\\n      ^'), ('x::', 'x::\\n ^^')])\ndef test_error_reporting(text, expected_in_error):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = SpecParser(text)\n    with pytest.raises(SpecTokenizationError) as exc:\n        parser.tokens()\n        assert expected_in_error in str(exc), parser.tokens()"
        ]
    },
    {
        "func_name": "test_spec_by_hash_tokens",
        "original": "@pytest.mark.parametrize('text,tokens', [('/abcde', [Token(TokenType.DAG_HASH, value='/abcde')]), ('foo/abcde', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.DAG_HASH, value='/abcde')]), ('foo@1.2.3 /abcde', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.VERSION, value='@1.2.3'), Token(TokenType.DAG_HASH, value='/abcde')])])\ndef test_spec_by_hash_tokens(text, tokens):\n    parser = SpecParser(text)\n    assert parser.tokens() == tokens",
        "mutated": [
            "@pytest.mark.parametrize('text,tokens', [('/abcde', [Token(TokenType.DAG_HASH, value='/abcde')]), ('foo/abcde', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.DAG_HASH, value='/abcde')]), ('foo@1.2.3 /abcde', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.VERSION, value='@1.2.3'), Token(TokenType.DAG_HASH, value='/abcde')])])\ndef test_spec_by_hash_tokens(text, tokens):\n    if False:\n        i = 10\n    parser = SpecParser(text)\n    assert parser.tokens() == tokens",
            "@pytest.mark.parametrize('text,tokens', [('/abcde', [Token(TokenType.DAG_HASH, value='/abcde')]), ('foo/abcde', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.DAG_HASH, value='/abcde')]), ('foo@1.2.3 /abcde', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.VERSION, value='@1.2.3'), Token(TokenType.DAG_HASH, value='/abcde')])])\ndef test_spec_by_hash_tokens(text, tokens):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = SpecParser(text)\n    assert parser.tokens() == tokens",
            "@pytest.mark.parametrize('text,tokens', [('/abcde', [Token(TokenType.DAG_HASH, value='/abcde')]), ('foo/abcde', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.DAG_HASH, value='/abcde')]), ('foo@1.2.3 /abcde', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.VERSION, value='@1.2.3'), Token(TokenType.DAG_HASH, value='/abcde')])])\ndef test_spec_by_hash_tokens(text, tokens):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = SpecParser(text)\n    assert parser.tokens() == tokens",
            "@pytest.mark.parametrize('text,tokens', [('/abcde', [Token(TokenType.DAG_HASH, value='/abcde')]), ('foo/abcde', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.DAG_HASH, value='/abcde')]), ('foo@1.2.3 /abcde', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.VERSION, value='@1.2.3'), Token(TokenType.DAG_HASH, value='/abcde')])])\ndef test_spec_by_hash_tokens(text, tokens):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = SpecParser(text)\n    assert parser.tokens() == tokens",
            "@pytest.mark.parametrize('text,tokens', [('/abcde', [Token(TokenType.DAG_HASH, value='/abcde')]), ('foo/abcde', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.DAG_HASH, value='/abcde')]), ('foo@1.2.3 /abcde', [Token(TokenType.UNQUALIFIED_PACKAGE_NAME, value='foo'), Token(TokenType.VERSION, value='@1.2.3'), Token(TokenType.DAG_HASH, value='/abcde')])])\ndef test_spec_by_hash_tokens(text, tokens):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = SpecParser(text)\n    assert parser.tokens() == tokens"
        ]
    },
    {
        "func_name": "test_spec_by_hash",
        "original": "@pytest.mark.db\ndef test_spec_by_hash(database, monkeypatch, config):\n    mpileaks = database.query_one('mpileaks ^zmpi')\n    b = spack.spec.Spec('b').concretized()\n    monkeypatch.setattr(spack.binary_distribution, 'update_cache_and_get_specs', lambda : [b])\n    hash_str = f'/{mpileaks.dag_hash()}'\n    parsed_spec = SpecParser(hash_str).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    short_hash_str = f'/{mpileaks.dag_hash()[:5]}'\n    parsed_spec = SpecParser(short_hash_str).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    name_version_and_hash = f'{mpileaks.name}@{mpileaks.version} /{mpileaks.dag_hash()[:5]}'\n    parsed_spec = SpecParser(name_version_and_hash).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    b_hash = f'/{b.dag_hash()}'\n    parsed_spec = SpecParser(b_hash).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == b",
        "mutated": [
            "@pytest.mark.db\ndef test_spec_by_hash(database, monkeypatch, config):\n    if False:\n        i = 10\n    mpileaks = database.query_one('mpileaks ^zmpi')\n    b = spack.spec.Spec('b').concretized()\n    monkeypatch.setattr(spack.binary_distribution, 'update_cache_and_get_specs', lambda : [b])\n    hash_str = f'/{mpileaks.dag_hash()}'\n    parsed_spec = SpecParser(hash_str).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    short_hash_str = f'/{mpileaks.dag_hash()[:5]}'\n    parsed_spec = SpecParser(short_hash_str).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    name_version_and_hash = f'{mpileaks.name}@{mpileaks.version} /{mpileaks.dag_hash()[:5]}'\n    parsed_spec = SpecParser(name_version_and_hash).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    b_hash = f'/{b.dag_hash()}'\n    parsed_spec = SpecParser(b_hash).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == b",
            "@pytest.mark.db\ndef test_spec_by_hash(database, monkeypatch, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mpileaks = database.query_one('mpileaks ^zmpi')\n    b = spack.spec.Spec('b').concretized()\n    monkeypatch.setattr(spack.binary_distribution, 'update_cache_and_get_specs', lambda : [b])\n    hash_str = f'/{mpileaks.dag_hash()}'\n    parsed_spec = SpecParser(hash_str).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    short_hash_str = f'/{mpileaks.dag_hash()[:5]}'\n    parsed_spec = SpecParser(short_hash_str).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    name_version_and_hash = f'{mpileaks.name}@{mpileaks.version} /{mpileaks.dag_hash()[:5]}'\n    parsed_spec = SpecParser(name_version_and_hash).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    b_hash = f'/{b.dag_hash()}'\n    parsed_spec = SpecParser(b_hash).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == b",
            "@pytest.mark.db\ndef test_spec_by_hash(database, monkeypatch, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mpileaks = database.query_one('mpileaks ^zmpi')\n    b = spack.spec.Spec('b').concretized()\n    monkeypatch.setattr(spack.binary_distribution, 'update_cache_and_get_specs', lambda : [b])\n    hash_str = f'/{mpileaks.dag_hash()}'\n    parsed_spec = SpecParser(hash_str).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    short_hash_str = f'/{mpileaks.dag_hash()[:5]}'\n    parsed_spec = SpecParser(short_hash_str).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    name_version_and_hash = f'{mpileaks.name}@{mpileaks.version} /{mpileaks.dag_hash()[:5]}'\n    parsed_spec = SpecParser(name_version_and_hash).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    b_hash = f'/{b.dag_hash()}'\n    parsed_spec = SpecParser(b_hash).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == b",
            "@pytest.mark.db\ndef test_spec_by_hash(database, monkeypatch, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mpileaks = database.query_one('mpileaks ^zmpi')\n    b = spack.spec.Spec('b').concretized()\n    monkeypatch.setattr(spack.binary_distribution, 'update_cache_and_get_specs', lambda : [b])\n    hash_str = f'/{mpileaks.dag_hash()}'\n    parsed_spec = SpecParser(hash_str).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    short_hash_str = f'/{mpileaks.dag_hash()[:5]}'\n    parsed_spec = SpecParser(short_hash_str).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    name_version_and_hash = f'{mpileaks.name}@{mpileaks.version} /{mpileaks.dag_hash()[:5]}'\n    parsed_spec = SpecParser(name_version_and_hash).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    b_hash = f'/{b.dag_hash()}'\n    parsed_spec = SpecParser(b_hash).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == b",
            "@pytest.mark.db\ndef test_spec_by_hash(database, monkeypatch, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mpileaks = database.query_one('mpileaks ^zmpi')\n    b = spack.spec.Spec('b').concretized()\n    monkeypatch.setattr(spack.binary_distribution, 'update_cache_and_get_specs', lambda : [b])\n    hash_str = f'/{mpileaks.dag_hash()}'\n    parsed_spec = SpecParser(hash_str).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    short_hash_str = f'/{mpileaks.dag_hash()[:5]}'\n    parsed_spec = SpecParser(short_hash_str).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    name_version_and_hash = f'{mpileaks.name}@{mpileaks.version} /{mpileaks.dag_hash()[:5]}'\n    parsed_spec = SpecParser(name_version_and_hash).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == mpileaks\n    b_hash = f'/{b.dag_hash()}'\n    parsed_spec = SpecParser(b_hash).next_spec()\n    parsed_spec.replace_hash()\n    assert parsed_spec == b"
        ]
    },
    {
        "func_name": "test_dep_spec_by_hash",
        "original": "@pytest.mark.db\ndef test_dep_spec_by_hash(database, config):\n    mpileaks_zmpi = database.query_one('mpileaks ^zmpi')\n    zmpi = database.query_one('zmpi')\n    fake = database.query_one('fake')\n    assert 'fake' in mpileaks_zmpi\n    assert 'zmpi' in mpileaks_zmpi\n    mpileaks_hash_fake = SpecParser(f'mpileaks ^/{fake.dag_hash()} ^zmpi').next_spec()\n    mpileaks_hash_fake.replace_hash()\n    assert 'fake' in mpileaks_hash_fake\n    assert mpileaks_hash_fake['fake'] == fake\n    assert 'zmpi' in mpileaks_hash_fake\n    assert mpileaks_hash_fake['zmpi'] == spack.spec.Spec('zmpi')\n    mpileaks_hash_zmpi = SpecParser(f'mpileaks %{mpileaks_zmpi.compiler} ^ /{zmpi.dag_hash()}').next_spec()\n    mpileaks_hash_zmpi.replace_hash()\n    assert 'zmpi' in mpileaks_hash_zmpi\n    assert mpileaks_hash_zmpi['zmpi'] == zmpi\n    assert mpileaks_zmpi.compiler.satisfies(mpileaks_hash_zmpi.compiler)\n    mpileaks_hash_fake_and_zmpi = SpecParser(f'mpileaks ^/{fake.dag_hash()[:4]} ^ /{zmpi.dag_hash()[:5]}').next_spec()\n    mpileaks_hash_fake_and_zmpi.replace_hash()\n    assert 'zmpi' in mpileaks_hash_fake_and_zmpi\n    assert mpileaks_hash_fake_and_zmpi['zmpi'] == zmpi\n    assert 'fake' in mpileaks_hash_fake_and_zmpi\n    assert mpileaks_hash_fake_and_zmpi['fake'] == fake",
        "mutated": [
            "@pytest.mark.db\ndef test_dep_spec_by_hash(database, config):\n    if False:\n        i = 10\n    mpileaks_zmpi = database.query_one('mpileaks ^zmpi')\n    zmpi = database.query_one('zmpi')\n    fake = database.query_one('fake')\n    assert 'fake' in mpileaks_zmpi\n    assert 'zmpi' in mpileaks_zmpi\n    mpileaks_hash_fake = SpecParser(f'mpileaks ^/{fake.dag_hash()} ^zmpi').next_spec()\n    mpileaks_hash_fake.replace_hash()\n    assert 'fake' in mpileaks_hash_fake\n    assert mpileaks_hash_fake['fake'] == fake\n    assert 'zmpi' in mpileaks_hash_fake\n    assert mpileaks_hash_fake['zmpi'] == spack.spec.Spec('zmpi')\n    mpileaks_hash_zmpi = SpecParser(f'mpileaks %{mpileaks_zmpi.compiler} ^ /{zmpi.dag_hash()}').next_spec()\n    mpileaks_hash_zmpi.replace_hash()\n    assert 'zmpi' in mpileaks_hash_zmpi\n    assert mpileaks_hash_zmpi['zmpi'] == zmpi\n    assert mpileaks_zmpi.compiler.satisfies(mpileaks_hash_zmpi.compiler)\n    mpileaks_hash_fake_and_zmpi = SpecParser(f'mpileaks ^/{fake.dag_hash()[:4]} ^ /{zmpi.dag_hash()[:5]}').next_spec()\n    mpileaks_hash_fake_and_zmpi.replace_hash()\n    assert 'zmpi' in mpileaks_hash_fake_and_zmpi\n    assert mpileaks_hash_fake_and_zmpi['zmpi'] == zmpi\n    assert 'fake' in mpileaks_hash_fake_and_zmpi\n    assert mpileaks_hash_fake_and_zmpi['fake'] == fake",
            "@pytest.mark.db\ndef test_dep_spec_by_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mpileaks_zmpi = database.query_one('mpileaks ^zmpi')\n    zmpi = database.query_one('zmpi')\n    fake = database.query_one('fake')\n    assert 'fake' in mpileaks_zmpi\n    assert 'zmpi' in mpileaks_zmpi\n    mpileaks_hash_fake = SpecParser(f'mpileaks ^/{fake.dag_hash()} ^zmpi').next_spec()\n    mpileaks_hash_fake.replace_hash()\n    assert 'fake' in mpileaks_hash_fake\n    assert mpileaks_hash_fake['fake'] == fake\n    assert 'zmpi' in mpileaks_hash_fake\n    assert mpileaks_hash_fake['zmpi'] == spack.spec.Spec('zmpi')\n    mpileaks_hash_zmpi = SpecParser(f'mpileaks %{mpileaks_zmpi.compiler} ^ /{zmpi.dag_hash()}').next_spec()\n    mpileaks_hash_zmpi.replace_hash()\n    assert 'zmpi' in mpileaks_hash_zmpi\n    assert mpileaks_hash_zmpi['zmpi'] == zmpi\n    assert mpileaks_zmpi.compiler.satisfies(mpileaks_hash_zmpi.compiler)\n    mpileaks_hash_fake_and_zmpi = SpecParser(f'mpileaks ^/{fake.dag_hash()[:4]} ^ /{zmpi.dag_hash()[:5]}').next_spec()\n    mpileaks_hash_fake_and_zmpi.replace_hash()\n    assert 'zmpi' in mpileaks_hash_fake_and_zmpi\n    assert mpileaks_hash_fake_and_zmpi['zmpi'] == zmpi\n    assert 'fake' in mpileaks_hash_fake_and_zmpi\n    assert mpileaks_hash_fake_and_zmpi['fake'] == fake",
            "@pytest.mark.db\ndef test_dep_spec_by_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mpileaks_zmpi = database.query_one('mpileaks ^zmpi')\n    zmpi = database.query_one('zmpi')\n    fake = database.query_one('fake')\n    assert 'fake' in mpileaks_zmpi\n    assert 'zmpi' in mpileaks_zmpi\n    mpileaks_hash_fake = SpecParser(f'mpileaks ^/{fake.dag_hash()} ^zmpi').next_spec()\n    mpileaks_hash_fake.replace_hash()\n    assert 'fake' in mpileaks_hash_fake\n    assert mpileaks_hash_fake['fake'] == fake\n    assert 'zmpi' in mpileaks_hash_fake\n    assert mpileaks_hash_fake['zmpi'] == spack.spec.Spec('zmpi')\n    mpileaks_hash_zmpi = SpecParser(f'mpileaks %{mpileaks_zmpi.compiler} ^ /{zmpi.dag_hash()}').next_spec()\n    mpileaks_hash_zmpi.replace_hash()\n    assert 'zmpi' in mpileaks_hash_zmpi\n    assert mpileaks_hash_zmpi['zmpi'] == zmpi\n    assert mpileaks_zmpi.compiler.satisfies(mpileaks_hash_zmpi.compiler)\n    mpileaks_hash_fake_and_zmpi = SpecParser(f'mpileaks ^/{fake.dag_hash()[:4]} ^ /{zmpi.dag_hash()[:5]}').next_spec()\n    mpileaks_hash_fake_and_zmpi.replace_hash()\n    assert 'zmpi' in mpileaks_hash_fake_and_zmpi\n    assert mpileaks_hash_fake_and_zmpi['zmpi'] == zmpi\n    assert 'fake' in mpileaks_hash_fake_and_zmpi\n    assert mpileaks_hash_fake_and_zmpi['fake'] == fake",
            "@pytest.mark.db\ndef test_dep_spec_by_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mpileaks_zmpi = database.query_one('mpileaks ^zmpi')\n    zmpi = database.query_one('zmpi')\n    fake = database.query_one('fake')\n    assert 'fake' in mpileaks_zmpi\n    assert 'zmpi' in mpileaks_zmpi\n    mpileaks_hash_fake = SpecParser(f'mpileaks ^/{fake.dag_hash()} ^zmpi').next_spec()\n    mpileaks_hash_fake.replace_hash()\n    assert 'fake' in mpileaks_hash_fake\n    assert mpileaks_hash_fake['fake'] == fake\n    assert 'zmpi' in mpileaks_hash_fake\n    assert mpileaks_hash_fake['zmpi'] == spack.spec.Spec('zmpi')\n    mpileaks_hash_zmpi = SpecParser(f'mpileaks %{mpileaks_zmpi.compiler} ^ /{zmpi.dag_hash()}').next_spec()\n    mpileaks_hash_zmpi.replace_hash()\n    assert 'zmpi' in mpileaks_hash_zmpi\n    assert mpileaks_hash_zmpi['zmpi'] == zmpi\n    assert mpileaks_zmpi.compiler.satisfies(mpileaks_hash_zmpi.compiler)\n    mpileaks_hash_fake_and_zmpi = SpecParser(f'mpileaks ^/{fake.dag_hash()[:4]} ^ /{zmpi.dag_hash()[:5]}').next_spec()\n    mpileaks_hash_fake_and_zmpi.replace_hash()\n    assert 'zmpi' in mpileaks_hash_fake_and_zmpi\n    assert mpileaks_hash_fake_and_zmpi['zmpi'] == zmpi\n    assert 'fake' in mpileaks_hash_fake_and_zmpi\n    assert mpileaks_hash_fake_and_zmpi['fake'] == fake",
            "@pytest.mark.db\ndef test_dep_spec_by_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mpileaks_zmpi = database.query_one('mpileaks ^zmpi')\n    zmpi = database.query_one('zmpi')\n    fake = database.query_one('fake')\n    assert 'fake' in mpileaks_zmpi\n    assert 'zmpi' in mpileaks_zmpi\n    mpileaks_hash_fake = SpecParser(f'mpileaks ^/{fake.dag_hash()} ^zmpi').next_spec()\n    mpileaks_hash_fake.replace_hash()\n    assert 'fake' in mpileaks_hash_fake\n    assert mpileaks_hash_fake['fake'] == fake\n    assert 'zmpi' in mpileaks_hash_fake\n    assert mpileaks_hash_fake['zmpi'] == spack.spec.Spec('zmpi')\n    mpileaks_hash_zmpi = SpecParser(f'mpileaks %{mpileaks_zmpi.compiler} ^ /{zmpi.dag_hash()}').next_spec()\n    mpileaks_hash_zmpi.replace_hash()\n    assert 'zmpi' in mpileaks_hash_zmpi\n    assert mpileaks_hash_zmpi['zmpi'] == zmpi\n    assert mpileaks_zmpi.compiler.satisfies(mpileaks_hash_zmpi.compiler)\n    mpileaks_hash_fake_and_zmpi = SpecParser(f'mpileaks ^/{fake.dag_hash()[:4]} ^ /{zmpi.dag_hash()[:5]}').next_spec()\n    mpileaks_hash_fake_and_zmpi.replace_hash()\n    assert 'zmpi' in mpileaks_hash_fake_and_zmpi\n    assert mpileaks_hash_fake_and_zmpi['zmpi'] == zmpi\n    assert 'fake' in mpileaks_hash_fake_and_zmpi\n    assert mpileaks_hash_fake_and_zmpi['fake'] == fake"
        ]
    },
    {
        "func_name": "test_multiple_specs_with_hash",
        "original": "@pytest.mark.db\ndef test_multiple_specs_with_hash(database, config):\n    mpileaks_zmpi = database.query_one('mpileaks ^zmpi')\n    callpath_mpich2 = database.query_one('callpath ^mpich2')\n    specs = SpecParser(f'mpileaks /{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()} callpath').all_specs()\n    assert len(specs) == 3\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} callpath callpath').all_specs()\n    assert len(specs) == 3\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} callpath /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2",
        "mutated": [
            "@pytest.mark.db\ndef test_multiple_specs_with_hash(database, config):\n    if False:\n        i = 10\n    mpileaks_zmpi = database.query_one('mpileaks ^zmpi')\n    callpath_mpich2 = database.query_one('callpath ^mpich2')\n    specs = SpecParser(f'mpileaks /{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()} callpath').all_specs()\n    assert len(specs) == 3\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} callpath callpath').all_specs()\n    assert len(specs) == 3\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} callpath /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2",
            "@pytest.mark.db\ndef test_multiple_specs_with_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mpileaks_zmpi = database.query_one('mpileaks ^zmpi')\n    callpath_mpich2 = database.query_one('callpath ^mpich2')\n    specs = SpecParser(f'mpileaks /{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()} callpath').all_specs()\n    assert len(specs) == 3\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} callpath callpath').all_specs()\n    assert len(specs) == 3\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} callpath /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2",
            "@pytest.mark.db\ndef test_multiple_specs_with_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mpileaks_zmpi = database.query_one('mpileaks ^zmpi')\n    callpath_mpich2 = database.query_one('callpath ^mpich2')\n    specs = SpecParser(f'mpileaks /{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()} callpath').all_specs()\n    assert len(specs) == 3\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} callpath callpath').all_specs()\n    assert len(specs) == 3\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} callpath /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2",
            "@pytest.mark.db\ndef test_multiple_specs_with_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mpileaks_zmpi = database.query_one('mpileaks ^zmpi')\n    callpath_mpich2 = database.query_one('callpath ^mpich2')\n    specs = SpecParser(f'mpileaks /{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()} callpath').all_specs()\n    assert len(specs) == 3\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} callpath callpath').all_specs()\n    assert len(specs) == 3\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} callpath /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2",
            "@pytest.mark.db\ndef test_multiple_specs_with_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mpileaks_zmpi = database.query_one('mpileaks ^zmpi')\n    callpath_mpich2 = database.query_one('callpath ^mpich2')\n    specs = SpecParser(f'mpileaks /{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} /{callpath_mpich2.dag_hash()} callpath').all_specs()\n    assert len(specs) == 3\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} callpath callpath').all_specs()\n    assert len(specs) == 3\n    specs = SpecParser(f'/{mpileaks_zmpi.dag_hash()} callpath /{callpath_mpich2.dag_hash()}').all_specs()\n    assert len(specs) == 2"
        ]
    },
    {
        "func_name": "test_ambiguous_hash",
        "original": "@pytest.mark.db\ndef test_ambiguous_hash(mutable_database, default_mock_concretization, config):\n    \"\"\"Test that abstract hash ambiguity is delayed until concretization.\n    In the past this ambiguity error would happen during parse time.\"\"\"\n    x1 = default_mock_concretization('a')\n    x2 = x1.copy()\n    x1._hash = 'xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'\n    x1._process_hash = 'xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'\n    x2._hash = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\n    x2._process_hash = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\n    assert x1 != x2\n    mutable_database.add(x1, directory_layout=None)\n    mutable_database.add(x2, directory_layout=None)\n    s1 = SpecParser('/x').next_spec()\n    with pytest.raises(spack.spec.AmbiguousHashError):\n        s1.lookup_hash()\n    s2 = SpecParser('a/x').next_spec()\n    with pytest.raises(spack.spec.AmbiguousHashError):\n        s2.lookup_hash()",
        "mutated": [
            "@pytest.mark.db\ndef test_ambiguous_hash(mutable_database, default_mock_concretization, config):\n    if False:\n        i = 10\n    'Test that abstract hash ambiguity is delayed until concretization.\\n    In the past this ambiguity error would happen during parse time.'\n    x1 = default_mock_concretization('a')\n    x2 = x1.copy()\n    x1._hash = 'xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'\n    x1._process_hash = 'xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'\n    x2._hash = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\n    x2._process_hash = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\n    assert x1 != x2\n    mutable_database.add(x1, directory_layout=None)\n    mutable_database.add(x2, directory_layout=None)\n    s1 = SpecParser('/x').next_spec()\n    with pytest.raises(spack.spec.AmbiguousHashError):\n        s1.lookup_hash()\n    s2 = SpecParser('a/x').next_spec()\n    with pytest.raises(spack.spec.AmbiguousHashError):\n        s2.lookup_hash()",
            "@pytest.mark.db\ndef test_ambiguous_hash(mutable_database, default_mock_concretization, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test that abstract hash ambiguity is delayed until concretization.\\n    In the past this ambiguity error would happen during parse time.'\n    x1 = default_mock_concretization('a')\n    x2 = x1.copy()\n    x1._hash = 'xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'\n    x1._process_hash = 'xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'\n    x2._hash = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\n    x2._process_hash = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\n    assert x1 != x2\n    mutable_database.add(x1, directory_layout=None)\n    mutable_database.add(x2, directory_layout=None)\n    s1 = SpecParser('/x').next_spec()\n    with pytest.raises(spack.spec.AmbiguousHashError):\n        s1.lookup_hash()\n    s2 = SpecParser('a/x').next_spec()\n    with pytest.raises(spack.spec.AmbiguousHashError):\n        s2.lookup_hash()",
            "@pytest.mark.db\ndef test_ambiguous_hash(mutable_database, default_mock_concretization, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test that abstract hash ambiguity is delayed until concretization.\\n    In the past this ambiguity error would happen during parse time.'\n    x1 = default_mock_concretization('a')\n    x2 = x1.copy()\n    x1._hash = 'xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'\n    x1._process_hash = 'xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'\n    x2._hash = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\n    x2._process_hash = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\n    assert x1 != x2\n    mutable_database.add(x1, directory_layout=None)\n    mutable_database.add(x2, directory_layout=None)\n    s1 = SpecParser('/x').next_spec()\n    with pytest.raises(spack.spec.AmbiguousHashError):\n        s1.lookup_hash()\n    s2 = SpecParser('a/x').next_spec()\n    with pytest.raises(spack.spec.AmbiguousHashError):\n        s2.lookup_hash()",
            "@pytest.mark.db\ndef test_ambiguous_hash(mutable_database, default_mock_concretization, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test that abstract hash ambiguity is delayed until concretization.\\n    In the past this ambiguity error would happen during parse time.'\n    x1 = default_mock_concretization('a')\n    x2 = x1.copy()\n    x1._hash = 'xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'\n    x1._process_hash = 'xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'\n    x2._hash = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\n    x2._process_hash = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\n    assert x1 != x2\n    mutable_database.add(x1, directory_layout=None)\n    mutable_database.add(x2, directory_layout=None)\n    s1 = SpecParser('/x').next_spec()\n    with pytest.raises(spack.spec.AmbiguousHashError):\n        s1.lookup_hash()\n    s2 = SpecParser('a/x').next_spec()\n    with pytest.raises(spack.spec.AmbiguousHashError):\n        s2.lookup_hash()",
            "@pytest.mark.db\ndef test_ambiguous_hash(mutable_database, default_mock_concretization, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test that abstract hash ambiguity is delayed until concretization.\\n    In the past this ambiguity error would happen during parse time.'\n    x1 = default_mock_concretization('a')\n    x2 = x1.copy()\n    x1._hash = 'xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'\n    x1._process_hash = 'xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'\n    x2._hash = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\n    x2._process_hash = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\n    assert x1 != x2\n    mutable_database.add(x1, directory_layout=None)\n    mutable_database.add(x2, directory_layout=None)\n    s1 = SpecParser('/x').next_spec()\n    with pytest.raises(spack.spec.AmbiguousHashError):\n        s1.lookup_hash()\n    s2 = SpecParser('a/x').next_spec()\n    with pytest.raises(spack.spec.AmbiguousHashError):\n        s2.lookup_hash()"
        ]
    },
    {
        "func_name": "test_invalid_hash",
        "original": "@pytest.mark.db\ndef test_invalid_hash(database, config):\n    zmpi = database.query_one('zmpi')\n    mpich = database.query_one('mpich')\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'zmpi /{mpich.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'mpich /{zmpi.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'mpileaks ^zmpi /{mpich.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()",
        "mutated": [
            "@pytest.mark.db\ndef test_invalid_hash(database, config):\n    if False:\n        i = 10\n    zmpi = database.query_one('zmpi')\n    mpich = database.query_one('mpich')\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'zmpi /{mpich.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'mpich /{zmpi.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'mpileaks ^zmpi /{mpich.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()",
            "@pytest.mark.db\ndef test_invalid_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    zmpi = database.query_one('zmpi')\n    mpich = database.query_one('mpich')\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'zmpi /{mpich.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'mpich /{zmpi.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'mpileaks ^zmpi /{mpich.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()",
            "@pytest.mark.db\ndef test_invalid_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    zmpi = database.query_one('zmpi')\n    mpich = database.query_one('mpich')\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'zmpi /{mpich.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'mpich /{zmpi.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'mpileaks ^zmpi /{mpich.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()",
            "@pytest.mark.db\ndef test_invalid_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    zmpi = database.query_one('zmpi')\n    mpich = database.query_one('mpich')\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'zmpi /{mpich.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'mpich /{zmpi.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'mpileaks ^zmpi /{mpich.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()",
            "@pytest.mark.db\ndef test_invalid_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    zmpi = database.query_one('zmpi')\n    mpich = database.query_one('mpich')\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'zmpi /{mpich.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'mpich /{zmpi.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'mpileaks ^zmpi /{mpich.dag_hash()}').next_spec()\n        parsed_spec.replace_hash()"
        ]
    },
    {
        "func_name": "test_invalid_hash_dep",
        "original": "def test_invalid_hash_dep(database, config):\n    mpich = database.query_one('mpich')\n    hash = mpich.dag_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        spack.spec.Spec(f'callpath ^zlib/{hash}').replace_hash()",
        "mutated": [
            "def test_invalid_hash_dep(database, config):\n    if False:\n        i = 10\n    mpich = database.query_one('mpich')\n    hash = mpich.dag_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        spack.spec.Spec(f'callpath ^zlib/{hash}').replace_hash()",
            "def test_invalid_hash_dep(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mpich = database.query_one('mpich')\n    hash = mpich.dag_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        spack.spec.Spec(f'callpath ^zlib/{hash}').replace_hash()",
            "def test_invalid_hash_dep(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mpich = database.query_one('mpich')\n    hash = mpich.dag_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        spack.spec.Spec(f'callpath ^zlib/{hash}').replace_hash()",
            "def test_invalid_hash_dep(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mpich = database.query_one('mpich')\n    hash = mpich.dag_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        spack.spec.Spec(f'callpath ^zlib/{hash}').replace_hash()",
            "def test_invalid_hash_dep(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mpich = database.query_one('mpich')\n    hash = mpich.dag_hash()\n    with pytest.raises(spack.spec.InvalidHashError):\n        spack.spec.Spec(f'callpath ^zlib/{hash}').replace_hash()"
        ]
    },
    {
        "func_name": "test_nonexistent_hash",
        "original": "@pytest.mark.db\ndef test_nonexistent_hash(database, config):\n    \"\"\"Ensure we get errors for non existent hashes.\"\"\"\n    specs = database.query()\n    no_such_hash = 'aaaaaaaaaaaaaaa'\n    hashes = [s._hash for s in specs]\n    assert no_such_hash not in [h[:len(no_such_hash)] for h in hashes]\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'/{no_such_hash}').next_spec()\n        parsed_spec.replace_hash()",
        "mutated": [
            "@pytest.mark.db\ndef test_nonexistent_hash(database, config):\n    if False:\n        i = 10\n    'Ensure we get errors for non existent hashes.'\n    specs = database.query()\n    no_such_hash = 'aaaaaaaaaaaaaaa'\n    hashes = [s._hash for s in specs]\n    assert no_such_hash not in [h[:len(no_such_hash)] for h in hashes]\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'/{no_such_hash}').next_spec()\n        parsed_spec.replace_hash()",
            "@pytest.mark.db\ndef test_nonexistent_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Ensure we get errors for non existent hashes.'\n    specs = database.query()\n    no_such_hash = 'aaaaaaaaaaaaaaa'\n    hashes = [s._hash for s in specs]\n    assert no_such_hash not in [h[:len(no_such_hash)] for h in hashes]\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'/{no_such_hash}').next_spec()\n        parsed_spec.replace_hash()",
            "@pytest.mark.db\ndef test_nonexistent_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Ensure we get errors for non existent hashes.'\n    specs = database.query()\n    no_such_hash = 'aaaaaaaaaaaaaaa'\n    hashes = [s._hash for s in specs]\n    assert no_such_hash not in [h[:len(no_such_hash)] for h in hashes]\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'/{no_such_hash}').next_spec()\n        parsed_spec.replace_hash()",
            "@pytest.mark.db\ndef test_nonexistent_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Ensure we get errors for non existent hashes.'\n    specs = database.query()\n    no_such_hash = 'aaaaaaaaaaaaaaa'\n    hashes = [s._hash for s in specs]\n    assert no_such_hash not in [h[:len(no_such_hash)] for h in hashes]\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'/{no_such_hash}').next_spec()\n        parsed_spec.replace_hash()",
            "@pytest.mark.db\ndef test_nonexistent_hash(database, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Ensure we get errors for non existent hashes.'\n    specs = database.query()\n    no_such_hash = 'aaaaaaaaaaaaaaa'\n    hashes = [s._hash for s in specs]\n    assert no_such_hash not in [h[:len(no_such_hash)] for h in hashes]\n    with pytest.raises(spack.spec.InvalidHashError):\n        parsed_spec = SpecParser(f'/{no_such_hash}').next_spec()\n        parsed_spec.replace_hash()"
        ]
    },
    {
        "func_name": "test_disambiguate_hash_by_spec",
        "original": "@pytest.mark.parametrize('spec1,spec2,constraint', [('zlib', 'hdf5', None), ('zlib+shared', 'zlib~shared', '+shared'), ('hdf5+mpi^zmpi', 'hdf5~mpi', '^zmpi'), ('hdf5+mpi^mpich+debug', 'hdf5+mpi^mpich~debug', '^mpich+debug')])\ndef test_disambiguate_hash_by_spec(spec1, spec2, constraint, mock_packages, monkeypatch, config):\n    spec1_concrete = spack.spec.Spec(spec1).concretized()\n    spec2_concrete = spack.spec.Spec(spec2).concretized()\n    spec1_concrete._hash = 'spec1'\n    spec2_concrete._hash = 'spec2'\n    monkeypatch.setattr(spack.binary_distribution, 'update_cache_and_get_specs', lambda : [spec1_concrete, spec2_concrete])\n    if not constraint:\n        spec = spack.spec.Spec(spec1 + '/spec')\n    else:\n        spec = spack.spec.Spec('/spec' + constraint)\n    assert spec.lookup_hash() == spec1_concrete",
        "mutated": [
            "@pytest.mark.parametrize('spec1,spec2,constraint', [('zlib', 'hdf5', None), ('zlib+shared', 'zlib~shared', '+shared'), ('hdf5+mpi^zmpi', 'hdf5~mpi', '^zmpi'), ('hdf5+mpi^mpich+debug', 'hdf5+mpi^mpich~debug', '^mpich+debug')])\ndef test_disambiguate_hash_by_spec(spec1, spec2, constraint, mock_packages, monkeypatch, config):\n    if False:\n        i = 10\n    spec1_concrete = spack.spec.Spec(spec1).concretized()\n    spec2_concrete = spack.spec.Spec(spec2).concretized()\n    spec1_concrete._hash = 'spec1'\n    spec2_concrete._hash = 'spec2'\n    monkeypatch.setattr(spack.binary_distribution, 'update_cache_and_get_specs', lambda : [spec1_concrete, spec2_concrete])\n    if not constraint:\n        spec = spack.spec.Spec(spec1 + '/spec')\n    else:\n        spec = spack.spec.Spec('/spec' + constraint)\n    assert spec.lookup_hash() == spec1_concrete",
            "@pytest.mark.parametrize('spec1,spec2,constraint', [('zlib', 'hdf5', None), ('zlib+shared', 'zlib~shared', '+shared'), ('hdf5+mpi^zmpi', 'hdf5~mpi', '^zmpi'), ('hdf5+mpi^mpich+debug', 'hdf5+mpi^mpich~debug', '^mpich+debug')])\ndef test_disambiguate_hash_by_spec(spec1, spec2, constraint, mock_packages, monkeypatch, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    spec1_concrete = spack.spec.Spec(spec1).concretized()\n    spec2_concrete = spack.spec.Spec(spec2).concretized()\n    spec1_concrete._hash = 'spec1'\n    spec2_concrete._hash = 'spec2'\n    monkeypatch.setattr(spack.binary_distribution, 'update_cache_and_get_specs', lambda : [spec1_concrete, spec2_concrete])\n    if not constraint:\n        spec = spack.spec.Spec(spec1 + '/spec')\n    else:\n        spec = spack.spec.Spec('/spec' + constraint)\n    assert spec.lookup_hash() == spec1_concrete",
            "@pytest.mark.parametrize('spec1,spec2,constraint', [('zlib', 'hdf5', None), ('zlib+shared', 'zlib~shared', '+shared'), ('hdf5+mpi^zmpi', 'hdf5~mpi', '^zmpi'), ('hdf5+mpi^mpich+debug', 'hdf5+mpi^mpich~debug', '^mpich+debug')])\ndef test_disambiguate_hash_by_spec(spec1, spec2, constraint, mock_packages, monkeypatch, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    spec1_concrete = spack.spec.Spec(spec1).concretized()\n    spec2_concrete = spack.spec.Spec(spec2).concretized()\n    spec1_concrete._hash = 'spec1'\n    spec2_concrete._hash = 'spec2'\n    monkeypatch.setattr(spack.binary_distribution, 'update_cache_and_get_specs', lambda : [spec1_concrete, spec2_concrete])\n    if not constraint:\n        spec = spack.spec.Spec(spec1 + '/spec')\n    else:\n        spec = spack.spec.Spec('/spec' + constraint)\n    assert spec.lookup_hash() == spec1_concrete",
            "@pytest.mark.parametrize('spec1,spec2,constraint', [('zlib', 'hdf5', None), ('zlib+shared', 'zlib~shared', '+shared'), ('hdf5+mpi^zmpi', 'hdf5~mpi', '^zmpi'), ('hdf5+mpi^mpich+debug', 'hdf5+mpi^mpich~debug', '^mpich+debug')])\ndef test_disambiguate_hash_by_spec(spec1, spec2, constraint, mock_packages, monkeypatch, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    spec1_concrete = spack.spec.Spec(spec1).concretized()\n    spec2_concrete = spack.spec.Spec(spec2).concretized()\n    spec1_concrete._hash = 'spec1'\n    spec2_concrete._hash = 'spec2'\n    monkeypatch.setattr(spack.binary_distribution, 'update_cache_and_get_specs', lambda : [spec1_concrete, spec2_concrete])\n    if not constraint:\n        spec = spack.spec.Spec(spec1 + '/spec')\n    else:\n        spec = spack.spec.Spec('/spec' + constraint)\n    assert spec.lookup_hash() == spec1_concrete",
            "@pytest.mark.parametrize('spec1,spec2,constraint', [('zlib', 'hdf5', None), ('zlib+shared', 'zlib~shared', '+shared'), ('hdf5+mpi^zmpi', 'hdf5~mpi', '^zmpi'), ('hdf5+mpi^mpich+debug', 'hdf5+mpi^mpich~debug', '^mpich+debug')])\ndef test_disambiguate_hash_by_spec(spec1, spec2, constraint, mock_packages, monkeypatch, config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    spec1_concrete = spack.spec.Spec(spec1).concretized()\n    spec2_concrete = spack.spec.Spec(spec2).concretized()\n    spec1_concrete._hash = 'spec1'\n    spec2_concrete._hash = 'spec2'\n    monkeypatch.setattr(spack.binary_distribution, 'update_cache_and_get_specs', lambda : [spec1_concrete, spec2_concrete])\n    if not constraint:\n        spec = spack.spec.Spec(spec1 + '/spec')\n    else:\n        spec = spack.spec.Spec('/spec' + constraint)\n    assert spec.lookup_hash() == spec1_concrete"
        ]
    },
    {
        "func_name": "test_error_conditions",
        "original": "@pytest.mark.parametrize('text,exc_cls', [('x@1.2+debug+debug', spack.variant.DuplicateVariantError), ('x ^y@1.2+debug debug=true', spack.variant.DuplicateVariantError), ('x ^y@1.2 debug=false debug=true', spack.variant.DuplicateVariantError), ('x ^y@1.2 debug=false ~debug', spack.variant.DuplicateVariantError), ('x@1.2@2.3', spack.spec.MultipleVersionError), ('x@1.2:2.3@1.4', spack.spec.MultipleVersionError), ('x@1.2@2.3:2.4', spack.spec.MultipleVersionError), ('x@1.2@2.3,2.4', spack.spec.MultipleVersionError), ('x@1.2 +foo~bar @2.3', spack.spec.MultipleVersionError), ('x@1.2%y@1.2@2.3:2.4', spack.spec.MultipleVersionError), ('x ^y@1 ^y@2', spack.spec.DuplicateDependencyError), ('x%intel%intel', spack.spec.DuplicateCompilerSpecError), ('x%intel%gcc', spack.spec.DuplicateCompilerSpecError), ('x%gcc%intel', spack.spec.DuplicateCompilerSpecError), ('x ^y%intel%intel', spack.spec.DuplicateCompilerSpecError), ('x ^y%intel%gcc', spack.spec.DuplicateCompilerSpecError), ('x ^y%gcc%intel', spack.spec.DuplicateCompilerSpecError), ('x arch=linux-rhel7-x86_64 arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('x arch=linux-rhel7-x86_64 arch=linux-rhel7-ppc64le', spack.spec.DuplicateArchitectureError), ('x arch=linux-rhel7-ppc64le arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('y ^x arch=linux-rhel7-x86_64 arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('y ^x arch=linux-rhel7-x86_64 arch=linux-rhel7-ppc64le', spack.spec.DuplicateArchitectureError), ('x os=fe os=fe', spack.spec.DuplicateArchitectureError), ('x os=fe os=be', spack.spec.DuplicateArchitectureError), ('x target=fe target=fe', spack.spec.DuplicateArchitectureError), ('x target=fe target=be', spack.spec.DuplicateArchitectureError), ('x platform=test platform=test', spack.spec.DuplicateArchitectureError), ('x os=fe platform=test target=fe os=fe', spack.spec.DuplicateArchitectureError), ('x target=be platform=test os=be os=fe', spack.spec.DuplicateArchitectureError), ('^[@foo] zlib', spack.parser.SpecParsingError), ('^[foo=bar] zlib', spack.parser.SpecParsingError)])\ndef test_error_conditions(text, exc_cls):\n    with pytest.raises(exc_cls):\n        SpecParser(text).next_spec()",
        "mutated": [
            "@pytest.mark.parametrize('text,exc_cls', [('x@1.2+debug+debug', spack.variant.DuplicateVariantError), ('x ^y@1.2+debug debug=true', spack.variant.DuplicateVariantError), ('x ^y@1.2 debug=false debug=true', spack.variant.DuplicateVariantError), ('x ^y@1.2 debug=false ~debug', spack.variant.DuplicateVariantError), ('x@1.2@2.3', spack.spec.MultipleVersionError), ('x@1.2:2.3@1.4', spack.spec.MultipleVersionError), ('x@1.2@2.3:2.4', spack.spec.MultipleVersionError), ('x@1.2@2.3,2.4', spack.spec.MultipleVersionError), ('x@1.2 +foo~bar @2.3', spack.spec.MultipleVersionError), ('x@1.2%y@1.2@2.3:2.4', spack.spec.MultipleVersionError), ('x ^y@1 ^y@2', spack.spec.DuplicateDependencyError), ('x%intel%intel', spack.spec.DuplicateCompilerSpecError), ('x%intel%gcc', spack.spec.DuplicateCompilerSpecError), ('x%gcc%intel', spack.spec.DuplicateCompilerSpecError), ('x ^y%intel%intel', spack.spec.DuplicateCompilerSpecError), ('x ^y%intel%gcc', spack.spec.DuplicateCompilerSpecError), ('x ^y%gcc%intel', spack.spec.DuplicateCompilerSpecError), ('x arch=linux-rhel7-x86_64 arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('x arch=linux-rhel7-x86_64 arch=linux-rhel7-ppc64le', spack.spec.DuplicateArchitectureError), ('x arch=linux-rhel7-ppc64le arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('y ^x arch=linux-rhel7-x86_64 arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('y ^x arch=linux-rhel7-x86_64 arch=linux-rhel7-ppc64le', spack.spec.DuplicateArchitectureError), ('x os=fe os=fe', spack.spec.DuplicateArchitectureError), ('x os=fe os=be', spack.spec.DuplicateArchitectureError), ('x target=fe target=fe', spack.spec.DuplicateArchitectureError), ('x target=fe target=be', spack.spec.DuplicateArchitectureError), ('x platform=test platform=test', spack.spec.DuplicateArchitectureError), ('x os=fe platform=test target=fe os=fe', spack.spec.DuplicateArchitectureError), ('x target=be platform=test os=be os=fe', spack.spec.DuplicateArchitectureError), ('^[@foo] zlib', spack.parser.SpecParsingError), ('^[foo=bar] zlib', spack.parser.SpecParsingError)])\ndef test_error_conditions(text, exc_cls):\n    if False:\n        i = 10\n    with pytest.raises(exc_cls):\n        SpecParser(text).next_spec()",
            "@pytest.mark.parametrize('text,exc_cls', [('x@1.2+debug+debug', spack.variant.DuplicateVariantError), ('x ^y@1.2+debug debug=true', spack.variant.DuplicateVariantError), ('x ^y@1.2 debug=false debug=true', spack.variant.DuplicateVariantError), ('x ^y@1.2 debug=false ~debug', spack.variant.DuplicateVariantError), ('x@1.2@2.3', spack.spec.MultipleVersionError), ('x@1.2:2.3@1.4', spack.spec.MultipleVersionError), ('x@1.2@2.3:2.4', spack.spec.MultipleVersionError), ('x@1.2@2.3,2.4', spack.spec.MultipleVersionError), ('x@1.2 +foo~bar @2.3', spack.spec.MultipleVersionError), ('x@1.2%y@1.2@2.3:2.4', spack.spec.MultipleVersionError), ('x ^y@1 ^y@2', spack.spec.DuplicateDependencyError), ('x%intel%intel', spack.spec.DuplicateCompilerSpecError), ('x%intel%gcc', spack.spec.DuplicateCompilerSpecError), ('x%gcc%intel', spack.spec.DuplicateCompilerSpecError), ('x ^y%intel%intel', spack.spec.DuplicateCompilerSpecError), ('x ^y%intel%gcc', spack.spec.DuplicateCompilerSpecError), ('x ^y%gcc%intel', spack.spec.DuplicateCompilerSpecError), ('x arch=linux-rhel7-x86_64 arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('x arch=linux-rhel7-x86_64 arch=linux-rhel7-ppc64le', spack.spec.DuplicateArchitectureError), ('x arch=linux-rhel7-ppc64le arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('y ^x arch=linux-rhel7-x86_64 arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('y ^x arch=linux-rhel7-x86_64 arch=linux-rhel7-ppc64le', spack.spec.DuplicateArchitectureError), ('x os=fe os=fe', spack.spec.DuplicateArchitectureError), ('x os=fe os=be', spack.spec.DuplicateArchitectureError), ('x target=fe target=fe', spack.spec.DuplicateArchitectureError), ('x target=fe target=be', spack.spec.DuplicateArchitectureError), ('x platform=test platform=test', spack.spec.DuplicateArchitectureError), ('x os=fe platform=test target=fe os=fe', spack.spec.DuplicateArchitectureError), ('x target=be platform=test os=be os=fe', spack.spec.DuplicateArchitectureError), ('^[@foo] zlib', spack.parser.SpecParsingError), ('^[foo=bar] zlib', spack.parser.SpecParsingError)])\ndef test_error_conditions(text, exc_cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with pytest.raises(exc_cls):\n        SpecParser(text).next_spec()",
            "@pytest.mark.parametrize('text,exc_cls', [('x@1.2+debug+debug', spack.variant.DuplicateVariantError), ('x ^y@1.2+debug debug=true', spack.variant.DuplicateVariantError), ('x ^y@1.2 debug=false debug=true', spack.variant.DuplicateVariantError), ('x ^y@1.2 debug=false ~debug', spack.variant.DuplicateVariantError), ('x@1.2@2.3', spack.spec.MultipleVersionError), ('x@1.2:2.3@1.4', spack.spec.MultipleVersionError), ('x@1.2@2.3:2.4', spack.spec.MultipleVersionError), ('x@1.2@2.3,2.4', spack.spec.MultipleVersionError), ('x@1.2 +foo~bar @2.3', spack.spec.MultipleVersionError), ('x@1.2%y@1.2@2.3:2.4', spack.spec.MultipleVersionError), ('x ^y@1 ^y@2', spack.spec.DuplicateDependencyError), ('x%intel%intel', spack.spec.DuplicateCompilerSpecError), ('x%intel%gcc', spack.spec.DuplicateCompilerSpecError), ('x%gcc%intel', spack.spec.DuplicateCompilerSpecError), ('x ^y%intel%intel', spack.spec.DuplicateCompilerSpecError), ('x ^y%intel%gcc', spack.spec.DuplicateCompilerSpecError), ('x ^y%gcc%intel', spack.spec.DuplicateCompilerSpecError), ('x arch=linux-rhel7-x86_64 arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('x arch=linux-rhel7-x86_64 arch=linux-rhel7-ppc64le', spack.spec.DuplicateArchitectureError), ('x arch=linux-rhel7-ppc64le arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('y ^x arch=linux-rhel7-x86_64 arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('y ^x arch=linux-rhel7-x86_64 arch=linux-rhel7-ppc64le', spack.spec.DuplicateArchitectureError), ('x os=fe os=fe', spack.spec.DuplicateArchitectureError), ('x os=fe os=be', spack.spec.DuplicateArchitectureError), ('x target=fe target=fe', spack.spec.DuplicateArchitectureError), ('x target=fe target=be', spack.spec.DuplicateArchitectureError), ('x platform=test platform=test', spack.spec.DuplicateArchitectureError), ('x os=fe platform=test target=fe os=fe', spack.spec.DuplicateArchitectureError), ('x target=be platform=test os=be os=fe', spack.spec.DuplicateArchitectureError), ('^[@foo] zlib', spack.parser.SpecParsingError), ('^[foo=bar] zlib', spack.parser.SpecParsingError)])\ndef test_error_conditions(text, exc_cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with pytest.raises(exc_cls):\n        SpecParser(text).next_spec()",
            "@pytest.mark.parametrize('text,exc_cls', [('x@1.2+debug+debug', spack.variant.DuplicateVariantError), ('x ^y@1.2+debug debug=true', spack.variant.DuplicateVariantError), ('x ^y@1.2 debug=false debug=true', spack.variant.DuplicateVariantError), ('x ^y@1.2 debug=false ~debug', spack.variant.DuplicateVariantError), ('x@1.2@2.3', spack.spec.MultipleVersionError), ('x@1.2:2.3@1.4', spack.spec.MultipleVersionError), ('x@1.2@2.3:2.4', spack.spec.MultipleVersionError), ('x@1.2@2.3,2.4', spack.spec.MultipleVersionError), ('x@1.2 +foo~bar @2.3', spack.spec.MultipleVersionError), ('x@1.2%y@1.2@2.3:2.4', spack.spec.MultipleVersionError), ('x ^y@1 ^y@2', spack.spec.DuplicateDependencyError), ('x%intel%intel', spack.spec.DuplicateCompilerSpecError), ('x%intel%gcc', spack.spec.DuplicateCompilerSpecError), ('x%gcc%intel', spack.spec.DuplicateCompilerSpecError), ('x ^y%intel%intel', spack.spec.DuplicateCompilerSpecError), ('x ^y%intel%gcc', spack.spec.DuplicateCompilerSpecError), ('x ^y%gcc%intel', spack.spec.DuplicateCompilerSpecError), ('x arch=linux-rhel7-x86_64 arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('x arch=linux-rhel7-x86_64 arch=linux-rhel7-ppc64le', spack.spec.DuplicateArchitectureError), ('x arch=linux-rhel7-ppc64le arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('y ^x arch=linux-rhel7-x86_64 arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('y ^x arch=linux-rhel7-x86_64 arch=linux-rhel7-ppc64le', spack.spec.DuplicateArchitectureError), ('x os=fe os=fe', spack.spec.DuplicateArchitectureError), ('x os=fe os=be', spack.spec.DuplicateArchitectureError), ('x target=fe target=fe', spack.spec.DuplicateArchitectureError), ('x target=fe target=be', spack.spec.DuplicateArchitectureError), ('x platform=test platform=test', spack.spec.DuplicateArchitectureError), ('x os=fe platform=test target=fe os=fe', spack.spec.DuplicateArchitectureError), ('x target=be platform=test os=be os=fe', spack.spec.DuplicateArchitectureError), ('^[@foo] zlib', spack.parser.SpecParsingError), ('^[foo=bar] zlib', spack.parser.SpecParsingError)])\ndef test_error_conditions(text, exc_cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with pytest.raises(exc_cls):\n        SpecParser(text).next_spec()",
            "@pytest.mark.parametrize('text,exc_cls', [('x@1.2+debug+debug', spack.variant.DuplicateVariantError), ('x ^y@1.2+debug debug=true', spack.variant.DuplicateVariantError), ('x ^y@1.2 debug=false debug=true', spack.variant.DuplicateVariantError), ('x ^y@1.2 debug=false ~debug', spack.variant.DuplicateVariantError), ('x@1.2@2.3', spack.spec.MultipleVersionError), ('x@1.2:2.3@1.4', spack.spec.MultipleVersionError), ('x@1.2@2.3:2.4', spack.spec.MultipleVersionError), ('x@1.2@2.3,2.4', spack.spec.MultipleVersionError), ('x@1.2 +foo~bar @2.3', spack.spec.MultipleVersionError), ('x@1.2%y@1.2@2.3:2.4', spack.spec.MultipleVersionError), ('x ^y@1 ^y@2', spack.spec.DuplicateDependencyError), ('x%intel%intel', spack.spec.DuplicateCompilerSpecError), ('x%intel%gcc', spack.spec.DuplicateCompilerSpecError), ('x%gcc%intel', spack.spec.DuplicateCompilerSpecError), ('x ^y%intel%intel', spack.spec.DuplicateCompilerSpecError), ('x ^y%intel%gcc', spack.spec.DuplicateCompilerSpecError), ('x ^y%gcc%intel', spack.spec.DuplicateCompilerSpecError), ('x arch=linux-rhel7-x86_64 arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('x arch=linux-rhel7-x86_64 arch=linux-rhel7-ppc64le', spack.spec.DuplicateArchitectureError), ('x arch=linux-rhel7-ppc64le arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('y ^x arch=linux-rhel7-x86_64 arch=linux-rhel7-x86_64', spack.spec.DuplicateArchitectureError), ('y ^x arch=linux-rhel7-x86_64 arch=linux-rhel7-ppc64le', spack.spec.DuplicateArchitectureError), ('x os=fe os=fe', spack.spec.DuplicateArchitectureError), ('x os=fe os=be', spack.spec.DuplicateArchitectureError), ('x target=fe target=fe', spack.spec.DuplicateArchitectureError), ('x target=fe target=be', spack.spec.DuplicateArchitectureError), ('x platform=test platform=test', spack.spec.DuplicateArchitectureError), ('x os=fe platform=test target=fe os=fe', spack.spec.DuplicateArchitectureError), ('x target=be platform=test os=be os=fe', spack.spec.DuplicateArchitectureError), ('^[@foo] zlib', spack.parser.SpecParsingError), ('^[foo=bar] zlib', spack.parser.SpecParsingError)])\ndef test_error_conditions(text, exc_cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with pytest.raises(exc_cls):\n        SpecParser(text).next_spec()"
        ]
    },
    {
        "func_name": "test_specfile_error_conditions_windows",
        "original": "@pytest.mark.parametrize('text,exc_cls', [pytest.param('/bogus/path/libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('../../libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('./libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^/bogus/path/libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^../../libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^./libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('/bogus/path/libdwarf.yamlfoobar', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libdwarf^/bogus/path/libelf.yamlfoobar ^/path/to/bogus.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('c:\\\\bogus\\\\path\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('..\\\\..\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('.\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^c:\\\\bogus\\\\path\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^..\\\\..\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^.\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('c:\\\\bogus\\\\path\\\\libdwarf.yamlfoobar', spack.spec.SpecFilenameError, marks=FAIL_ON_UNIX), pytest.param('libdwarf^c:\\\\bogus\\\\path\\\\libelf.yamlfoobar ^c:\\\\path\\\\to\\\\bogus.yaml', spack.spec.SpecFilenameError, marks=FAIL_ON_UNIX)])\ndef test_specfile_error_conditions_windows(text, exc_cls):\n    with pytest.raises(exc_cls):\n        SpecParser(text).all_specs()",
        "mutated": [
            "@pytest.mark.parametrize('text,exc_cls', [pytest.param('/bogus/path/libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('../../libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('./libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^/bogus/path/libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^../../libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^./libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('/bogus/path/libdwarf.yamlfoobar', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libdwarf^/bogus/path/libelf.yamlfoobar ^/path/to/bogus.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('c:\\\\bogus\\\\path\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('..\\\\..\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('.\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^c:\\\\bogus\\\\path\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^..\\\\..\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^.\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('c:\\\\bogus\\\\path\\\\libdwarf.yamlfoobar', spack.spec.SpecFilenameError, marks=FAIL_ON_UNIX), pytest.param('libdwarf^c:\\\\bogus\\\\path\\\\libelf.yamlfoobar ^c:\\\\path\\\\to\\\\bogus.yaml', spack.spec.SpecFilenameError, marks=FAIL_ON_UNIX)])\ndef test_specfile_error_conditions_windows(text, exc_cls):\n    if False:\n        i = 10\n    with pytest.raises(exc_cls):\n        SpecParser(text).all_specs()",
            "@pytest.mark.parametrize('text,exc_cls', [pytest.param('/bogus/path/libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('../../libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('./libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^/bogus/path/libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^../../libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^./libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('/bogus/path/libdwarf.yamlfoobar', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libdwarf^/bogus/path/libelf.yamlfoobar ^/path/to/bogus.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('c:\\\\bogus\\\\path\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('..\\\\..\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('.\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^c:\\\\bogus\\\\path\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^..\\\\..\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^.\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('c:\\\\bogus\\\\path\\\\libdwarf.yamlfoobar', spack.spec.SpecFilenameError, marks=FAIL_ON_UNIX), pytest.param('libdwarf^c:\\\\bogus\\\\path\\\\libelf.yamlfoobar ^c:\\\\path\\\\to\\\\bogus.yaml', spack.spec.SpecFilenameError, marks=FAIL_ON_UNIX)])\ndef test_specfile_error_conditions_windows(text, exc_cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with pytest.raises(exc_cls):\n        SpecParser(text).all_specs()",
            "@pytest.mark.parametrize('text,exc_cls', [pytest.param('/bogus/path/libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('../../libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('./libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^/bogus/path/libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^../../libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^./libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('/bogus/path/libdwarf.yamlfoobar', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libdwarf^/bogus/path/libelf.yamlfoobar ^/path/to/bogus.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('c:\\\\bogus\\\\path\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('..\\\\..\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('.\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^c:\\\\bogus\\\\path\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^..\\\\..\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^.\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('c:\\\\bogus\\\\path\\\\libdwarf.yamlfoobar', spack.spec.SpecFilenameError, marks=FAIL_ON_UNIX), pytest.param('libdwarf^c:\\\\bogus\\\\path\\\\libelf.yamlfoobar ^c:\\\\path\\\\to\\\\bogus.yaml', spack.spec.SpecFilenameError, marks=FAIL_ON_UNIX)])\ndef test_specfile_error_conditions_windows(text, exc_cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with pytest.raises(exc_cls):\n        SpecParser(text).all_specs()",
            "@pytest.mark.parametrize('text,exc_cls', [pytest.param('/bogus/path/libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('../../libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('./libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^/bogus/path/libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^../../libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^./libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('/bogus/path/libdwarf.yamlfoobar', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libdwarf^/bogus/path/libelf.yamlfoobar ^/path/to/bogus.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('c:\\\\bogus\\\\path\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('..\\\\..\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('.\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^c:\\\\bogus\\\\path\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^..\\\\..\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^.\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('c:\\\\bogus\\\\path\\\\libdwarf.yamlfoobar', spack.spec.SpecFilenameError, marks=FAIL_ON_UNIX), pytest.param('libdwarf^c:\\\\bogus\\\\path\\\\libelf.yamlfoobar ^c:\\\\path\\\\to\\\\bogus.yaml', spack.spec.SpecFilenameError, marks=FAIL_ON_UNIX)])\ndef test_specfile_error_conditions_windows(text, exc_cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with pytest.raises(exc_cls):\n        SpecParser(text).all_specs()",
            "@pytest.mark.parametrize('text,exc_cls', [pytest.param('/bogus/path/libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('../../libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('./libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^/bogus/path/libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^../../libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libfoo ^./libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('/bogus/path/libdwarf.yamlfoobar', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('libdwarf^/bogus/path/libelf.yamlfoobar ^/path/to/bogus.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_WINDOWS), pytest.param('c:\\\\bogus\\\\path\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('..\\\\..\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('.\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^c:\\\\bogus\\\\path\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^..\\\\..\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('libfoo ^.\\\\libdwarf.yaml', spack.spec.NoSuchSpecFileError, marks=FAIL_ON_UNIX), pytest.param('c:\\\\bogus\\\\path\\\\libdwarf.yamlfoobar', spack.spec.SpecFilenameError, marks=FAIL_ON_UNIX), pytest.param('libdwarf^c:\\\\bogus\\\\path\\\\libelf.yamlfoobar ^c:\\\\path\\\\to\\\\bogus.yaml', spack.spec.SpecFilenameError, marks=FAIL_ON_UNIX)])\ndef test_specfile_error_conditions_windows(text, exc_cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with pytest.raises(exc_cls):\n        SpecParser(text).all_specs()"
        ]
    },
    {
        "func_name": "test_specfile_parsing",
        "original": "@pytest.mark.parametrize('filename,regex', [('c:\\\\abs\\\\windows\\\\\\\\path.yaml', WINDOWS_FILENAME), ('.\\\\\\\\relative\\\\\\\\dot\\\\\\\\win\\\\\\\\path.yaml', WINDOWS_FILENAME), ('relative\\\\\\\\windows\\\\\\\\path.yaml', WINDOWS_FILENAME), ('/absolute/path/to/file.yaml', UNIX_FILENAME), ('relative/path/to/file.yaml', UNIX_FILENAME), ('./dot/rel/to/file.yaml', UNIX_FILENAME)])\ndef test_specfile_parsing(filename, regex):\n    match = re.match(regex, filename)\n    assert match\n    assert match.end() == len(filename)",
        "mutated": [
            "@pytest.mark.parametrize('filename,regex', [('c:\\\\abs\\\\windows\\\\\\\\path.yaml', WINDOWS_FILENAME), ('.\\\\\\\\relative\\\\\\\\dot\\\\\\\\win\\\\\\\\path.yaml', WINDOWS_FILENAME), ('relative\\\\\\\\windows\\\\\\\\path.yaml', WINDOWS_FILENAME), ('/absolute/path/to/file.yaml', UNIX_FILENAME), ('relative/path/to/file.yaml', UNIX_FILENAME), ('./dot/rel/to/file.yaml', UNIX_FILENAME)])\ndef test_specfile_parsing(filename, regex):\n    if False:\n        i = 10\n    match = re.match(regex, filename)\n    assert match\n    assert match.end() == len(filename)",
            "@pytest.mark.parametrize('filename,regex', [('c:\\\\abs\\\\windows\\\\\\\\path.yaml', WINDOWS_FILENAME), ('.\\\\\\\\relative\\\\\\\\dot\\\\\\\\win\\\\\\\\path.yaml', WINDOWS_FILENAME), ('relative\\\\\\\\windows\\\\\\\\path.yaml', WINDOWS_FILENAME), ('/absolute/path/to/file.yaml', UNIX_FILENAME), ('relative/path/to/file.yaml', UNIX_FILENAME), ('./dot/rel/to/file.yaml', UNIX_FILENAME)])\ndef test_specfile_parsing(filename, regex):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    match = re.match(regex, filename)\n    assert match\n    assert match.end() == len(filename)",
            "@pytest.mark.parametrize('filename,regex', [('c:\\\\abs\\\\windows\\\\\\\\path.yaml', WINDOWS_FILENAME), ('.\\\\\\\\relative\\\\\\\\dot\\\\\\\\win\\\\\\\\path.yaml', WINDOWS_FILENAME), ('relative\\\\\\\\windows\\\\\\\\path.yaml', WINDOWS_FILENAME), ('/absolute/path/to/file.yaml', UNIX_FILENAME), ('relative/path/to/file.yaml', UNIX_FILENAME), ('./dot/rel/to/file.yaml', UNIX_FILENAME)])\ndef test_specfile_parsing(filename, regex):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    match = re.match(regex, filename)\n    assert match\n    assert match.end() == len(filename)",
            "@pytest.mark.parametrize('filename,regex', [('c:\\\\abs\\\\windows\\\\\\\\path.yaml', WINDOWS_FILENAME), ('.\\\\\\\\relative\\\\\\\\dot\\\\\\\\win\\\\\\\\path.yaml', WINDOWS_FILENAME), ('relative\\\\\\\\windows\\\\\\\\path.yaml', WINDOWS_FILENAME), ('/absolute/path/to/file.yaml', UNIX_FILENAME), ('relative/path/to/file.yaml', UNIX_FILENAME), ('./dot/rel/to/file.yaml', UNIX_FILENAME)])\ndef test_specfile_parsing(filename, regex):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    match = re.match(regex, filename)\n    assert match\n    assert match.end() == len(filename)",
            "@pytest.mark.parametrize('filename,regex', [('c:\\\\abs\\\\windows\\\\\\\\path.yaml', WINDOWS_FILENAME), ('.\\\\\\\\relative\\\\\\\\dot\\\\\\\\win\\\\\\\\path.yaml', WINDOWS_FILENAME), ('relative\\\\\\\\windows\\\\\\\\path.yaml', WINDOWS_FILENAME), ('/absolute/path/to/file.yaml', UNIX_FILENAME), ('relative/path/to/file.yaml', UNIX_FILENAME), ('./dot/rel/to/file.yaml', UNIX_FILENAME)])\ndef test_specfile_parsing(filename, regex):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    match = re.match(regex, filename)\n    assert match\n    assert match.end() == len(filename)"
        ]
    },
    {
        "func_name": "test_parse_specfile_simple",
        "original": "def test_parse_specfile_simple(specfile_for, tmpdir):\n    specfile = tmpdir.join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    spec = SpecParser(specfile.strpath).next_spec()\n    assert spec == s\n    specs = SpecParser(f'mvapich_foo {specfile.strpath}').all_specs()\n    assert len(specs) == 2",
        "mutated": [
            "def test_parse_specfile_simple(specfile_for, tmpdir):\n    if False:\n        i = 10\n    specfile = tmpdir.join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    spec = SpecParser(specfile.strpath).next_spec()\n    assert spec == s\n    specs = SpecParser(f'mvapich_foo {specfile.strpath}').all_specs()\n    assert len(specs) == 2",
            "def test_parse_specfile_simple(specfile_for, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    specfile = tmpdir.join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    spec = SpecParser(specfile.strpath).next_spec()\n    assert spec == s\n    specs = SpecParser(f'mvapich_foo {specfile.strpath}').all_specs()\n    assert len(specs) == 2",
            "def test_parse_specfile_simple(specfile_for, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    specfile = tmpdir.join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    spec = SpecParser(specfile.strpath).next_spec()\n    assert spec == s\n    specs = SpecParser(f'mvapich_foo {specfile.strpath}').all_specs()\n    assert len(specs) == 2",
            "def test_parse_specfile_simple(specfile_for, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    specfile = tmpdir.join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    spec = SpecParser(specfile.strpath).next_spec()\n    assert spec == s\n    specs = SpecParser(f'mvapich_foo {specfile.strpath}').all_specs()\n    assert len(specs) == 2",
            "def test_parse_specfile_simple(specfile_for, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    specfile = tmpdir.join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    spec = SpecParser(specfile.strpath).next_spec()\n    assert spec == s\n    specs = SpecParser(f'mvapich_foo {specfile.strpath}').all_specs()\n    assert len(specs) == 2"
        ]
    },
    {
        "func_name": "test_parse_filename_missing_slash_as_spec",
        "original": "@pytest.mark.parametrize('filename', ['libelf.yaml', 'libelf.json'])\ndef test_parse_filename_missing_slash_as_spec(specfile_for, tmpdir, filename):\n    \"\"\"Ensure that libelf(.yaml|.json) parses as a spec, NOT a file.\"\"\"\n    specfile = tmpdir.join(filename)\n    specfile_for(filename.split('.')[0], specfile)\n    with tmpdir.as_cwd():\n        specs = SpecParser('libelf.yaml').all_specs()\n    assert len(specs) == 1\n    spec = specs[0]\n    assert spec.name == 'yaml'\n    assert spec.namespace == 'libelf'\n    assert spec.fullname == 'libelf.yaml'\n    with pytest.raises(spack.repo.UnknownEntityError) as exc_info:\n        spec.concretize()\n    assert exc_info.value.long_message\n    assert \"Did you mean to specify a filename with './libelf.yaml'?\" in exc_info.value.long_message\n    with pytest.raises(spack.repo.UnknownPackageError) as exc_info:\n        SpecParser('builtin.mock.doesnotexist').next_spec().concretize()\n    assert not exc_info.value.long_message or 'Did you mean to specify a filename with' not in exc_info.value.long_message",
        "mutated": [
            "@pytest.mark.parametrize('filename', ['libelf.yaml', 'libelf.json'])\ndef test_parse_filename_missing_slash_as_spec(specfile_for, tmpdir, filename):\n    if False:\n        i = 10\n    'Ensure that libelf(.yaml|.json) parses as a spec, NOT a file.'\n    specfile = tmpdir.join(filename)\n    specfile_for(filename.split('.')[0], specfile)\n    with tmpdir.as_cwd():\n        specs = SpecParser('libelf.yaml').all_specs()\n    assert len(specs) == 1\n    spec = specs[0]\n    assert spec.name == 'yaml'\n    assert spec.namespace == 'libelf'\n    assert spec.fullname == 'libelf.yaml'\n    with pytest.raises(spack.repo.UnknownEntityError) as exc_info:\n        spec.concretize()\n    assert exc_info.value.long_message\n    assert \"Did you mean to specify a filename with './libelf.yaml'?\" in exc_info.value.long_message\n    with pytest.raises(spack.repo.UnknownPackageError) as exc_info:\n        SpecParser('builtin.mock.doesnotexist').next_spec().concretize()\n    assert not exc_info.value.long_message or 'Did you mean to specify a filename with' not in exc_info.value.long_message",
            "@pytest.mark.parametrize('filename', ['libelf.yaml', 'libelf.json'])\ndef test_parse_filename_missing_slash_as_spec(specfile_for, tmpdir, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Ensure that libelf(.yaml|.json) parses as a spec, NOT a file.'\n    specfile = tmpdir.join(filename)\n    specfile_for(filename.split('.')[0], specfile)\n    with tmpdir.as_cwd():\n        specs = SpecParser('libelf.yaml').all_specs()\n    assert len(specs) == 1\n    spec = specs[0]\n    assert spec.name == 'yaml'\n    assert spec.namespace == 'libelf'\n    assert spec.fullname == 'libelf.yaml'\n    with pytest.raises(spack.repo.UnknownEntityError) as exc_info:\n        spec.concretize()\n    assert exc_info.value.long_message\n    assert \"Did you mean to specify a filename with './libelf.yaml'?\" in exc_info.value.long_message\n    with pytest.raises(spack.repo.UnknownPackageError) as exc_info:\n        SpecParser('builtin.mock.doesnotexist').next_spec().concretize()\n    assert not exc_info.value.long_message or 'Did you mean to specify a filename with' not in exc_info.value.long_message",
            "@pytest.mark.parametrize('filename', ['libelf.yaml', 'libelf.json'])\ndef test_parse_filename_missing_slash_as_spec(specfile_for, tmpdir, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Ensure that libelf(.yaml|.json) parses as a spec, NOT a file.'\n    specfile = tmpdir.join(filename)\n    specfile_for(filename.split('.')[0], specfile)\n    with tmpdir.as_cwd():\n        specs = SpecParser('libelf.yaml').all_specs()\n    assert len(specs) == 1\n    spec = specs[0]\n    assert spec.name == 'yaml'\n    assert spec.namespace == 'libelf'\n    assert spec.fullname == 'libelf.yaml'\n    with pytest.raises(spack.repo.UnknownEntityError) as exc_info:\n        spec.concretize()\n    assert exc_info.value.long_message\n    assert \"Did you mean to specify a filename with './libelf.yaml'?\" in exc_info.value.long_message\n    with pytest.raises(spack.repo.UnknownPackageError) as exc_info:\n        SpecParser('builtin.mock.doesnotexist').next_spec().concretize()\n    assert not exc_info.value.long_message or 'Did you mean to specify a filename with' not in exc_info.value.long_message",
            "@pytest.mark.parametrize('filename', ['libelf.yaml', 'libelf.json'])\ndef test_parse_filename_missing_slash_as_spec(specfile_for, tmpdir, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Ensure that libelf(.yaml|.json) parses as a spec, NOT a file.'\n    specfile = tmpdir.join(filename)\n    specfile_for(filename.split('.')[0], specfile)\n    with tmpdir.as_cwd():\n        specs = SpecParser('libelf.yaml').all_specs()\n    assert len(specs) == 1\n    spec = specs[0]\n    assert spec.name == 'yaml'\n    assert spec.namespace == 'libelf'\n    assert spec.fullname == 'libelf.yaml'\n    with pytest.raises(spack.repo.UnknownEntityError) as exc_info:\n        spec.concretize()\n    assert exc_info.value.long_message\n    assert \"Did you mean to specify a filename with './libelf.yaml'?\" in exc_info.value.long_message\n    with pytest.raises(spack.repo.UnknownPackageError) as exc_info:\n        SpecParser('builtin.mock.doesnotexist').next_spec().concretize()\n    assert not exc_info.value.long_message or 'Did you mean to specify a filename with' not in exc_info.value.long_message",
            "@pytest.mark.parametrize('filename', ['libelf.yaml', 'libelf.json'])\ndef test_parse_filename_missing_slash_as_spec(specfile_for, tmpdir, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Ensure that libelf(.yaml|.json) parses as a spec, NOT a file.'\n    specfile = tmpdir.join(filename)\n    specfile_for(filename.split('.')[0], specfile)\n    with tmpdir.as_cwd():\n        specs = SpecParser('libelf.yaml').all_specs()\n    assert len(specs) == 1\n    spec = specs[0]\n    assert spec.name == 'yaml'\n    assert spec.namespace == 'libelf'\n    assert spec.fullname == 'libelf.yaml'\n    with pytest.raises(spack.repo.UnknownEntityError) as exc_info:\n        spec.concretize()\n    assert exc_info.value.long_message\n    assert \"Did you mean to specify a filename with './libelf.yaml'?\" in exc_info.value.long_message\n    with pytest.raises(spack.repo.UnknownPackageError) as exc_info:\n        SpecParser('builtin.mock.doesnotexist').next_spec().concretize()\n    assert not exc_info.value.long_message or 'Did you mean to specify a filename with' not in exc_info.value.long_message"
        ]
    },
    {
        "func_name": "test_parse_specfile_dependency",
        "original": "def test_parse_specfile_dependency(default_mock_concretization, tmpdir):\n    \"\"\"Ensure we can use a specfile as a dependency\"\"\"\n    s = default_mock_concretization('libdwarf')\n    specfile = tmpdir.join('libelf.json')\n    with specfile.open('w') as f:\n        f.write(s['libelf'].to_json())\n    spec = SpecParser(f'libdwarf ^ {specfile.strpath}').next_spec()\n    assert spec['libelf'] == s['libelf']\n    with specfile.dirpath().as_cwd():\n        spec = SpecParser(f'libdwarf^.{os.path.sep}{specfile.basename}').next_spec()\n        assert spec['libelf'] == s['libelf']\n        spec = SpecParser(f'libdwarf^..{os.path.sep}{specfile.dirpath().basename}{os.path.sep}{specfile.basename}').next_spec()\n        assert spec['libelf'] == s['libelf']",
        "mutated": [
            "def test_parse_specfile_dependency(default_mock_concretization, tmpdir):\n    if False:\n        i = 10\n    'Ensure we can use a specfile as a dependency'\n    s = default_mock_concretization('libdwarf')\n    specfile = tmpdir.join('libelf.json')\n    with specfile.open('w') as f:\n        f.write(s['libelf'].to_json())\n    spec = SpecParser(f'libdwarf ^ {specfile.strpath}').next_spec()\n    assert spec['libelf'] == s['libelf']\n    with specfile.dirpath().as_cwd():\n        spec = SpecParser(f'libdwarf^.{os.path.sep}{specfile.basename}').next_spec()\n        assert spec['libelf'] == s['libelf']\n        spec = SpecParser(f'libdwarf^..{os.path.sep}{specfile.dirpath().basename}{os.path.sep}{specfile.basename}').next_spec()\n        assert spec['libelf'] == s['libelf']",
            "def test_parse_specfile_dependency(default_mock_concretization, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Ensure we can use a specfile as a dependency'\n    s = default_mock_concretization('libdwarf')\n    specfile = tmpdir.join('libelf.json')\n    with specfile.open('w') as f:\n        f.write(s['libelf'].to_json())\n    spec = SpecParser(f'libdwarf ^ {specfile.strpath}').next_spec()\n    assert spec['libelf'] == s['libelf']\n    with specfile.dirpath().as_cwd():\n        spec = SpecParser(f'libdwarf^.{os.path.sep}{specfile.basename}').next_spec()\n        assert spec['libelf'] == s['libelf']\n        spec = SpecParser(f'libdwarf^..{os.path.sep}{specfile.dirpath().basename}{os.path.sep}{specfile.basename}').next_spec()\n        assert spec['libelf'] == s['libelf']",
            "def test_parse_specfile_dependency(default_mock_concretization, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Ensure we can use a specfile as a dependency'\n    s = default_mock_concretization('libdwarf')\n    specfile = tmpdir.join('libelf.json')\n    with specfile.open('w') as f:\n        f.write(s['libelf'].to_json())\n    spec = SpecParser(f'libdwarf ^ {specfile.strpath}').next_spec()\n    assert spec['libelf'] == s['libelf']\n    with specfile.dirpath().as_cwd():\n        spec = SpecParser(f'libdwarf^.{os.path.sep}{specfile.basename}').next_spec()\n        assert spec['libelf'] == s['libelf']\n        spec = SpecParser(f'libdwarf^..{os.path.sep}{specfile.dirpath().basename}{os.path.sep}{specfile.basename}').next_spec()\n        assert spec['libelf'] == s['libelf']",
            "def test_parse_specfile_dependency(default_mock_concretization, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Ensure we can use a specfile as a dependency'\n    s = default_mock_concretization('libdwarf')\n    specfile = tmpdir.join('libelf.json')\n    with specfile.open('w') as f:\n        f.write(s['libelf'].to_json())\n    spec = SpecParser(f'libdwarf ^ {specfile.strpath}').next_spec()\n    assert spec['libelf'] == s['libelf']\n    with specfile.dirpath().as_cwd():\n        spec = SpecParser(f'libdwarf^.{os.path.sep}{specfile.basename}').next_spec()\n        assert spec['libelf'] == s['libelf']\n        spec = SpecParser(f'libdwarf^..{os.path.sep}{specfile.dirpath().basename}{os.path.sep}{specfile.basename}').next_spec()\n        assert spec['libelf'] == s['libelf']",
            "def test_parse_specfile_dependency(default_mock_concretization, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Ensure we can use a specfile as a dependency'\n    s = default_mock_concretization('libdwarf')\n    specfile = tmpdir.join('libelf.json')\n    with specfile.open('w') as f:\n        f.write(s['libelf'].to_json())\n    spec = SpecParser(f'libdwarf ^ {specfile.strpath}').next_spec()\n    assert spec['libelf'] == s['libelf']\n    with specfile.dirpath().as_cwd():\n        spec = SpecParser(f'libdwarf^.{os.path.sep}{specfile.basename}').next_spec()\n        assert spec['libelf'] == s['libelf']\n        spec = SpecParser(f'libdwarf^..{os.path.sep}{specfile.dirpath().basename}{os.path.sep}{specfile.basename}').next_spec()\n        assert spec['libelf'] == s['libelf']"
        ]
    },
    {
        "func_name": "test_parse_specfile_relative_paths",
        "original": "def test_parse_specfile_relative_paths(specfile_for, tmpdir):\n    specfile = tmpdir.join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    basename = specfile.basename\n    parent_dir = specfile.dirpath()\n    with parent_dir.as_cwd():\n        spec = SpecParser(f'.{os.path.sep}{basename}').next_spec()\n        assert spec == s\n        spec = SpecParser(f'..{os.path.sep}{parent_dir.basename}{os.path.sep}{basename}').next_spec()\n        assert spec == s\n        specs = SpecParser(f'mvapich_foo ..{os.path.sep}{parent_dir.basename}{os.path.sep}{basename}').all_specs()\n        assert len(specs) == 2\n        assert specs[1] == s",
        "mutated": [
            "def test_parse_specfile_relative_paths(specfile_for, tmpdir):\n    if False:\n        i = 10\n    specfile = tmpdir.join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    basename = specfile.basename\n    parent_dir = specfile.dirpath()\n    with parent_dir.as_cwd():\n        spec = SpecParser(f'.{os.path.sep}{basename}').next_spec()\n        assert spec == s\n        spec = SpecParser(f'..{os.path.sep}{parent_dir.basename}{os.path.sep}{basename}').next_spec()\n        assert spec == s\n        specs = SpecParser(f'mvapich_foo ..{os.path.sep}{parent_dir.basename}{os.path.sep}{basename}').all_specs()\n        assert len(specs) == 2\n        assert specs[1] == s",
            "def test_parse_specfile_relative_paths(specfile_for, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    specfile = tmpdir.join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    basename = specfile.basename\n    parent_dir = specfile.dirpath()\n    with parent_dir.as_cwd():\n        spec = SpecParser(f'.{os.path.sep}{basename}').next_spec()\n        assert spec == s\n        spec = SpecParser(f'..{os.path.sep}{parent_dir.basename}{os.path.sep}{basename}').next_spec()\n        assert spec == s\n        specs = SpecParser(f'mvapich_foo ..{os.path.sep}{parent_dir.basename}{os.path.sep}{basename}').all_specs()\n        assert len(specs) == 2\n        assert specs[1] == s",
            "def test_parse_specfile_relative_paths(specfile_for, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    specfile = tmpdir.join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    basename = specfile.basename\n    parent_dir = specfile.dirpath()\n    with parent_dir.as_cwd():\n        spec = SpecParser(f'.{os.path.sep}{basename}').next_spec()\n        assert spec == s\n        spec = SpecParser(f'..{os.path.sep}{parent_dir.basename}{os.path.sep}{basename}').next_spec()\n        assert spec == s\n        specs = SpecParser(f'mvapich_foo ..{os.path.sep}{parent_dir.basename}{os.path.sep}{basename}').all_specs()\n        assert len(specs) == 2\n        assert specs[1] == s",
            "def test_parse_specfile_relative_paths(specfile_for, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    specfile = tmpdir.join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    basename = specfile.basename\n    parent_dir = specfile.dirpath()\n    with parent_dir.as_cwd():\n        spec = SpecParser(f'.{os.path.sep}{basename}').next_spec()\n        assert spec == s\n        spec = SpecParser(f'..{os.path.sep}{parent_dir.basename}{os.path.sep}{basename}').next_spec()\n        assert spec == s\n        specs = SpecParser(f'mvapich_foo ..{os.path.sep}{parent_dir.basename}{os.path.sep}{basename}').all_specs()\n        assert len(specs) == 2\n        assert specs[1] == s",
            "def test_parse_specfile_relative_paths(specfile_for, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    specfile = tmpdir.join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    basename = specfile.basename\n    parent_dir = specfile.dirpath()\n    with parent_dir.as_cwd():\n        spec = SpecParser(f'.{os.path.sep}{basename}').next_spec()\n        assert spec == s\n        spec = SpecParser(f'..{os.path.sep}{parent_dir.basename}{os.path.sep}{basename}').next_spec()\n        assert spec == s\n        specs = SpecParser(f'mvapich_foo ..{os.path.sep}{parent_dir.basename}{os.path.sep}{basename}').all_specs()\n        assert len(specs) == 2\n        assert specs[1] == s"
        ]
    },
    {
        "func_name": "test_parse_specfile_relative_subdir_path",
        "original": "def test_parse_specfile_relative_subdir_path(specfile_for, tmpdir):\n    specfile = tmpdir.mkdir('subdir').join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    with tmpdir.as_cwd():\n        spec = SpecParser(f'subdir{os.path.sep}{specfile.basename}').next_spec()\n        assert spec == s",
        "mutated": [
            "def test_parse_specfile_relative_subdir_path(specfile_for, tmpdir):\n    if False:\n        i = 10\n    specfile = tmpdir.mkdir('subdir').join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    with tmpdir.as_cwd():\n        spec = SpecParser(f'subdir{os.path.sep}{specfile.basename}').next_spec()\n        assert spec == s",
            "def test_parse_specfile_relative_subdir_path(specfile_for, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    specfile = tmpdir.mkdir('subdir').join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    with tmpdir.as_cwd():\n        spec = SpecParser(f'subdir{os.path.sep}{specfile.basename}').next_spec()\n        assert spec == s",
            "def test_parse_specfile_relative_subdir_path(specfile_for, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    specfile = tmpdir.mkdir('subdir').join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    with tmpdir.as_cwd():\n        spec = SpecParser(f'subdir{os.path.sep}{specfile.basename}').next_spec()\n        assert spec == s",
            "def test_parse_specfile_relative_subdir_path(specfile_for, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    specfile = tmpdir.mkdir('subdir').join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    with tmpdir.as_cwd():\n        spec = SpecParser(f'subdir{os.path.sep}{specfile.basename}').next_spec()\n        assert spec == s",
            "def test_parse_specfile_relative_subdir_path(specfile_for, tmpdir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    specfile = tmpdir.mkdir('subdir').join('libdwarf.json')\n    s = specfile_for('libdwarf', specfile)\n    with tmpdir.as_cwd():\n        spec = SpecParser(f'subdir{os.path.sep}{specfile.basename}').next_spec()\n        assert spec == s"
        ]
    },
    {
        "func_name": "test_compare_abstract_specs",
        "original": "@pytest.mark.regression('20310')\ndef test_compare_abstract_specs():\n    \"\"\"Spec comparisons must be valid for abstract specs.\n\n    Check that the spec cmp_key appropriately handles comparing specs for\n    which some attributes are None in exactly one of two specs\n    \"\"\"\n    constraints = ['foo', 'foo.foo', 'foo.foo@foo', 'foo.foo@foo+foo', 'foo.foo@foo+foo arch=foo-foo-foo', 'foo.foo@foo+foo arch=foo-foo-foo %foo', 'foo.foo@foo+foo arch=foo-foo-foo %foo cflags=foo']\n    specs = [SpecParser(s).next_spec() for s in constraints]\n    for (a, b) in itertools.product(specs, repeat=2):\n        assert a <= b or b < a",
        "mutated": [
            "@pytest.mark.regression('20310')\ndef test_compare_abstract_specs():\n    if False:\n        i = 10\n    'Spec comparisons must be valid for abstract specs.\\n\\n    Check that the spec cmp_key appropriately handles comparing specs for\\n    which some attributes are None in exactly one of two specs\\n    '\n    constraints = ['foo', 'foo.foo', 'foo.foo@foo', 'foo.foo@foo+foo', 'foo.foo@foo+foo arch=foo-foo-foo', 'foo.foo@foo+foo arch=foo-foo-foo %foo', 'foo.foo@foo+foo arch=foo-foo-foo %foo cflags=foo']\n    specs = [SpecParser(s).next_spec() for s in constraints]\n    for (a, b) in itertools.product(specs, repeat=2):\n        assert a <= b or b < a",
            "@pytest.mark.regression('20310')\ndef test_compare_abstract_specs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Spec comparisons must be valid for abstract specs.\\n\\n    Check that the spec cmp_key appropriately handles comparing specs for\\n    which some attributes are None in exactly one of two specs\\n    '\n    constraints = ['foo', 'foo.foo', 'foo.foo@foo', 'foo.foo@foo+foo', 'foo.foo@foo+foo arch=foo-foo-foo', 'foo.foo@foo+foo arch=foo-foo-foo %foo', 'foo.foo@foo+foo arch=foo-foo-foo %foo cflags=foo']\n    specs = [SpecParser(s).next_spec() for s in constraints]\n    for (a, b) in itertools.product(specs, repeat=2):\n        assert a <= b or b < a",
            "@pytest.mark.regression('20310')\ndef test_compare_abstract_specs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Spec comparisons must be valid for abstract specs.\\n\\n    Check that the spec cmp_key appropriately handles comparing specs for\\n    which some attributes are None in exactly one of two specs\\n    '\n    constraints = ['foo', 'foo.foo', 'foo.foo@foo', 'foo.foo@foo+foo', 'foo.foo@foo+foo arch=foo-foo-foo', 'foo.foo@foo+foo arch=foo-foo-foo %foo', 'foo.foo@foo+foo arch=foo-foo-foo %foo cflags=foo']\n    specs = [SpecParser(s).next_spec() for s in constraints]\n    for (a, b) in itertools.product(specs, repeat=2):\n        assert a <= b or b < a",
            "@pytest.mark.regression('20310')\ndef test_compare_abstract_specs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Spec comparisons must be valid for abstract specs.\\n\\n    Check that the spec cmp_key appropriately handles comparing specs for\\n    which some attributes are None in exactly one of two specs\\n    '\n    constraints = ['foo', 'foo.foo', 'foo.foo@foo', 'foo.foo@foo+foo', 'foo.foo@foo+foo arch=foo-foo-foo', 'foo.foo@foo+foo arch=foo-foo-foo %foo', 'foo.foo@foo+foo arch=foo-foo-foo %foo cflags=foo']\n    specs = [SpecParser(s).next_spec() for s in constraints]\n    for (a, b) in itertools.product(specs, repeat=2):\n        assert a <= b or b < a",
            "@pytest.mark.regression('20310')\ndef test_compare_abstract_specs():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Spec comparisons must be valid for abstract specs.\\n\\n    Check that the spec cmp_key appropriately handles comparing specs for\\n    which some attributes are None in exactly one of two specs\\n    '\n    constraints = ['foo', 'foo.foo', 'foo.foo@foo', 'foo.foo@foo+foo', 'foo.foo@foo+foo arch=foo-foo-foo', 'foo.foo@foo+foo arch=foo-foo-foo %foo', 'foo.foo@foo+foo arch=foo-foo-foo %foo cflags=foo']\n    specs = [SpecParser(s).next_spec() for s in constraints]\n    for (a, b) in itertools.product(specs, repeat=2):\n        assert a <= b or b < a"
        ]
    },
    {
        "func_name": "test_git_ref_spec_equivalences",
        "original": "@pytest.mark.parametrize('lhs_str,rhs_str,expected', [(f\"develop-branch-version@git.{'a' * 40}=develop\", 'develop-branch-version@develop', (True, True, False)), (f\"develop-branch-version@git.{'a' * 40}=develop\", f\"develop-branch-version@git.{'b' * 40}=develop\", (False, False, False)), (f\"develop-branch-version@git.{'a' * 40}=develop\", 'develop-branch-version@git.0.2.15=develop', (False, False, False)), ('develop-branch-version@git.0.2.15=develop', 'develop-branch-version@develop', (True, True, False))])\ndef test_git_ref_spec_equivalences(mock_packages, lhs_str, rhs_str, expected):\n    lhs = SpecParser(lhs_str).next_spec()\n    rhs = SpecParser(rhs_str).next_spec()\n    (intersect, lhs_sat_rhs, rhs_sat_lhs) = expected\n    assert lhs.intersects(rhs) is intersect\n    assert rhs.intersects(lhs) is intersect\n    assert lhs.satisfies(rhs) is lhs_sat_rhs\n    assert rhs.satisfies(lhs) is rhs_sat_lhs",
        "mutated": [
            "@pytest.mark.parametrize('lhs_str,rhs_str,expected', [(f\"develop-branch-version@git.{'a' * 40}=develop\", 'develop-branch-version@develop', (True, True, False)), (f\"develop-branch-version@git.{'a' * 40}=develop\", f\"develop-branch-version@git.{'b' * 40}=develop\", (False, False, False)), (f\"develop-branch-version@git.{'a' * 40}=develop\", 'develop-branch-version@git.0.2.15=develop', (False, False, False)), ('develop-branch-version@git.0.2.15=develop', 'develop-branch-version@develop', (True, True, False))])\ndef test_git_ref_spec_equivalences(mock_packages, lhs_str, rhs_str, expected):\n    if False:\n        i = 10\n    lhs = SpecParser(lhs_str).next_spec()\n    rhs = SpecParser(rhs_str).next_spec()\n    (intersect, lhs_sat_rhs, rhs_sat_lhs) = expected\n    assert lhs.intersects(rhs) is intersect\n    assert rhs.intersects(lhs) is intersect\n    assert lhs.satisfies(rhs) is lhs_sat_rhs\n    assert rhs.satisfies(lhs) is rhs_sat_lhs",
            "@pytest.mark.parametrize('lhs_str,rhs_str,expected', [(f\"develop-branch-version@git.{'a' * 40}=develop\", 'develop-branch-version@develop', (True, True, False)), (f\"develop-branch-version@git.{'a' * 40}=develop\", f\"develop-branch-version@git.{'b' * 40}=develop\", (False, False, False)), (f\"develop-branch-version@git.{'a' * 40}=develop\", 'develop-branch-version@git.0.2.15=develop', (False, False, False)), ('develop-branch-version@git.0.2.15=develop', 'develop-branch-version@develop', (True, True, False))])\ndef test_git_ref_spec_equivalences(mock_packages, lhs_str, rhs_str, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    lhs = SpecParser(lhs_str).next_spec()\n    rhs = SpecParser(rhs_str).next_spec()\n    (intersect, lhs_sat_rhs, rhs_sat_lhs) = expected\n    assert lhs.intersects(rhs) is intersect\n    assert rhs.intersects(lhs) is intersect\n    assert lhs.satisfies(rhs) is lhs_sat_rhs\n    assert rhs.satisfies(lhs) is rhs_sat_lhs",
            "@pytest.mark.parametrize('lhs_str,rhs_str,expected', [(f\"develop-branch-version@git.{'a' * 40}=develop\", 'develop-branch-version@develop', (True, True, False)), (f\"develop-branch-version@git.{'a' * 40}=develop\", f\"develop-branch-version@git.{'b' * 40}=develop\", (False, False, False)), (f\"develop-branch-version@git.{'a' * 40}=develop\", 'develop-branch-version@git.0.2.15=develop', (False, False, False)), ('develop-branch-version@git.0.2.15=develop', 'develop-branch-version@develop', (True, True, False))])\ndef test_git_ref_spec_equivalences(mock_packages, lhs_str, rhs_str, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    lhs = SpecParser(lhs_str).next_spec()\n    rhs = SpecParser(rhs_str).next_spec()\n    (intersect, lhs_sat_rhs, rhs_sat_lhs) = expected\n    assert lhs.intersects(rhs) is intersect\n    assert rhs.intersects(lhs) is intersect\n    assert lhs.satisfies(rhs) is lhs_sat_rhs\n    assert rhs.satisfies(lhs) is rhs_sat_lhs",
            "@pytest.mark.parametrize('lhs_str,rhs_str,expected', [(f\"develop-branch-version@git.{'a' * 40}=develop\", 'develop-branch-version@develop', (True, True, False)), (f\"develop-branch-version@git.{'a' * 40}=develop\", f\"develop-branch-version@git.{'b' * 40}=develop\", (False, False, False)), (f\"develop-branch-version@git.{'a' * 40}=develop\", 'develop-branch-version@git.0.2.15=develop', (False, False, False)), ('develop-branch-version@git.0.2.15=develop', 'develop-branch-version@develop', (True, True, False))])\ndef test_git_ref_spec_equivalences(mock_packages, lhs_str, rhs_str, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    lhs = SpecParser(lhs_str).next_spec()\n    rhs = SpecParser(rhs_str).next_spec()\n    (intersect, lhs_sat_rhs, rhs_sat_lhs) = expected\n    assert lhs.intersects(rhs) is intersect\n    assert rhs.intersects(lhs) is intersect\n    assert lhs.satisfies(rhs) is lhs_sat_rhs\n    assert rhs.satisfies(lhs) is rhs_sat_lhs",
            "@pytest.mark.parametrize('lhs_str,rhs_str,expected', [(f\"develop-branch-version@git.{'a' * 40}=develop\", 'develop-branch-version@develop', (True, True, False)), (f\"develop-branch-version@git.{'a' * 40}=develop\", f\"develop-branch-version@git.{'b' * 40}=develop\", (False, False, False)), (f\"develop-branch-version@git.{'a' * 40}=develop\", 'develop-branch-version@git.0.2.15=develop', (False, False, False)), ('develop-branch-version@git.0.2.15=develop', 'develop-branch-version@develop', (True, True, False))])\ndef test_git_ref_spec_equivalences(mock_packages, lhs_str, rhs_str, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    lhs = SpecParser(lhs_str).next_spec()\n    rhs = SpecParser(rhs_str).next_spec()\n    (intersect, lhs_sat_rhs, rhs_sat_lhs) = expected\n    assert lhs.intersects(rhs) is intersect\n    assert rhs.intersects(lhs) is intersect\n    assert lhs.satisfies(rhs) is lhs_sat_rhs\n    assert rhs.satisfies(lhs) is rhs_sat_lhs"
        ]
    },
    {
        "func_name": "test_platform_is_none_if_not_present",
        "original": "@pytest.mark.regression('32471')\n@pytest.mark.parametrize('spec_str', ['target=x86_64', 'os=redhat6', 'target=x86_64:'])\ndef test_platform_is_none_if_not_present(spec_str):\n    s = SpecParser(spec_str).next_spec()\n    assert s.architecture.platform is None, s",
        "mutated": [
            "@pytest.mark.regression('32471')\n@pytest.mark.parametrize('spec_str', ['target=x86_64', 'os=redhat6', 'target=x86_64:'])\ndef test_platform_is_none_if_not_present(spec_str):\n    if False:\n        i = 10\n    s = SpecParser(spec_str).next_spec()\n    assert s.architecture.platform is None, s",
            "@pytest.mark.regression('32471')\n@pytest.mark.parametrize('spec_str', ['target=x86_64', 'os=redhat6', 'target=x86_64:'])\ndef test_platform_is_none_if_not_present(spec_str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s = SpecParser(spec_str).next_spec()\n    assert s.architecture.platform is None, s",
            "@pytest.mark.regression('32471')\n@pytest.mark.parametrize('spec_str', ['target=x86_64', 'os=redhat6', 'target=x86_64:'])\ndef test_platform_is_none_if_not_present(spec_str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s = SpecParser(spec_str).next_spec()\n    assert s.architecture.platform is None, s",
            "@pytest.mark.regression('32471')\n@pytest.mark.parametrize('spec_str', ['target=x86_64', 'os=redhat6', 'target=x86_64:'])\ndef test_platform_is_none_if_not_present(spec_str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s = SpecParser(spec_str).next_spec()\n    assert s.architecture.platform is None, s",
            "@pytest.mark.regression('32471')\n@pytest.mark.parametrize('spec_str', ['target=x86_64', 'os=redhat6', 'target=x86_64:'])\ndef test_platform_is_none_if_not_present(spec_str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s = SpecParser(spec_str).next_spec()\n    assert s.architecture.platform is None, s"
        ]
    }
]