[
    {
        "func_name": "randintw",
        "original": "def randintw(w, size=1):\n    \"\"\"generate integer random variables given probabilties\n\n    useful because it can be used as index into any array or sequence type\n\n    Parameters\n    ----------\n    w : 1d array_like\n        sequence of weights, probabilities. The weights are normalized to add\n        to one.\n    size : int or tuple of ints\n        shape of output array\n\n    Returns\n    -------\n    rvs : array of shape given by size\n        random variables each distributed according to the same discrete\n        distribution defined by (normalized) w.\n\n    Examples\n    --------\n    >>> np.random.seed(0)\n    >>> randintw([0.4, 0.4, 0.2], size=(2,6))\n    array([[1, 1, 1, 1, 1, 1],\n           [1, 2, 2, 0, 1, 1]])\n\n    >>> np.bincount(randintw([0.6, 0.4, 0.0], size=3000))/3000.\n    array([ 0.59566667,  0.40433333])\n\n    \"\"\"\n    from numpy.random import random\n    p = np.cumsum(w) / np.sum(w)\n    rvs = p.searchsorted(random(np.prod(size))).reshape(size)\n    return rvs",
        "mutated": [
            "def randintw(w, size=1):\n    if False:\n        i = 10\n    'generate integer random variables given probabilties\\n\\n    useful because it can be used as index into any array or sequence type\\n\\n    Parameters\\n    ----------\\n    w : 1d array_like\\n        sequence of weights, probabilities. The weights are normalized to add\\n        to one.\\n    size : int or tuple of ints\\n        shape of output array\\n\\n    Returns\\n    -------\\n    rvs : array of shape given by size\\n        random variables each distributed according to the same discrete\\n        distribution defined by (normalized) w.\\n\\n    Examples\\n    --------\\n    >>> np.random.seed(0)\\n    >>> randintw([0.4, 0.4, 0.2], size=(2,6))\\n    array([[1, 1, 1, 1, 1, 1],\\n           [1, 2, 2, 0, 1, 1]])\\n\\n    >>> np.bincount(randintw([0.6, 0.4, 0.0], size=3000))/3000.\\n    array([ 0.59566667,  0.40433333])\\n\\n    '\n    from numpy.random import random\n    p = np.cumsum(w) / np.sum(w)\n    rvs = p.searchsorted(random(np.prod(size))).reshape(size)\n    return rvs",
            "def randintw(w, size=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'generate integer random variables given probabilties\\n\\n    useful because it can be used as index into any array or sequence type\\n\\n    Parameters\\n    ----------\\n    w : 1d array_like\\n        sequence of weights, probabilities. The weights are normalized to add\\n        to one.\\n    size : int or tuple of ints\\n        shape of output array\\n\\n    Returns\\n    -------\\n    rvs : array of shape given by size\\n        random variables each distributed according to the same discrete\\n        distribution defined by (normalized) w.\\n\\n    Examples\\n    --------\\n    >>> np.random.seed(0)\\n    >>> randintw([0.4, 0.4, 0.2], size=(2,6))\\n    array([[1, 1, 1, 1, 1, 1],\\n           [1, 2, 2, 0, 1, 1]])\\n\\n    >>> np.bincount(randintw([0.6, 0.4, 0.0], size=3000))/3000.\\n    array([ 0.59566667,  0.40433333])\\n\\n    '\n    from numpy.random import random\n    p = np.cumsum(w) / np.sum(w)\n    rvs = p.searchsorted(random(np.prod(size))).reshape(size)\n    return rvs",
            "def randintw(w, size=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'generate integer random variables given probabilties\\n\\n    useful because it can be used as index into any array or sequence type\\n\\n    Parameters\\n    ----------\\n    w : 1d array_like\\n        sequence of weights, probabilities. The weights are normalized to add\\n        to one.\\n    size : int or tuple of ints\\n        shape of output array\\n\\n    Returns\\n    -------\\n    rvs : array of shape given by size\\n        random variables each distributed according to the same discrete\\n        distribution defined by (normalized) w.\\n\\n    Examples\\n    --------\\n    >>> np.random.seed(0)\\n    >>> randintw([0.4, 0.4, 0.2], size=(2,6))\\n    array([[1, 1, 1, 1, 1, 1],\\n           [1, 2, 2, 0, 1, 1]])\\n\\n    >>> np.bincount(randintw([0.6, 0.4, 0.0], size=3000))/3000.\\n    array([ 0.59566667,  0.40433333])\\n\\n    '\n    from numpy.random import random\n    p = np.cumsum(w) / np.sum(w)\n    rvs = p.searchsorted(random(np.prod(size))).reshape(size)\n    return rvs",
            "def randintw(w, size=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'generate integer random variables given probabilties\\n\\n    useful because it can be used as index into any array or sequence type\\n\\n    Parameters\\n    ----------\\n    w : 1d array_like\\n        sequence of weights, probabilities. The weights are normalized to add\\n        to one.\\n    size : int or tuple of ints\\n        shape of output array\\n\\n    Returns\\n    -------\\n    rvs : array of shape given by size\\n        random variables each distributed according to the same discrete\\n        distribution defined by (normalized) w.\\n\\n    Examples\\n    --------\\n    >>> np.random.seed(0)\\n    >>> randintw([0.4, 0.4, 0.2], size=(2,6))\\n    array([[1, 1, 1, 1, 1, 1],\\n           [1, 2, 2, 0, 1, 1]])\\n\\n    >>> np.bincount(randintw([0.6, 0.4, 0.0], size=3000))/3000.\\n    array([ 0.59566667,  0.40433333])\\n\\n    '\n    from numpy.random import random\n    p = np.cumsum(w) / np.sum(w)\n    rvs = p.searchsorted(random(np.prod(size))).reshape(size)\n    return rvs",
            "def randintw(w, size=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'generate integer random variables given probabilties\\n\\n    useful because it can be used as index into any array or sequence type\\n\\n    Parameters\\n    ----------\\n    w : 1d array_like\\n        sequence of weights, probabilities. The weights are normalized to add\\n        to one.\\n    size : int or tuple of ints\\n        shape of output array\\n\\n    Returns\\n    -------\\n    rvs : array of shape given by size\\n        random variables each distributed according to the same discrete\\n        distribution defined by (normalized) w.\\n\\n    Examples\\n    --------\\n    >>> np.random.seed(0)\\n    >>> randintw([0.4, 0.4, 0.2], size=(2,6))\\n    array([[1, 1, 1, 1, 1, 1],\\n           [1, 2, 2, 0, 1, 1]])\\n\\n    >>> np.bincount(randintw([0.6, 0.4, 0.0], size=3000))/3000.\\n    array([ 0.59566667,  0.40433333])\\n\\n    '\n    from numpy.random import random\n    p = np.cumsum(w) / np.sum(w)\n    rvs = p.searchsorted(random(np.prod(size))).reshape(size)\n    return rvs"
        ]
    },
    {
        "func_name": "getbranches",
        "original": "def getbranches(tree):\n    \"\"\"\n    walk tree to get list of branches\n\n    Parameters\n    ----------\n    tree : list of tuples\n        tree as defined for RU2NMNL\n\n    Returns\n    -------\n    branch : list\n        list of all branch names\n\n    \"\"\"\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        a = [name]\n        for st in subtree:\n            a.extend(getbranches(st))\n        return a\n    return []",
        "mutated": [
            "def getbranches(tree):\n    if False:\n        i = 10\n    '\\n    walk tree to get list of branches\\n\\n    Parameters\\n    ----------\\n    tree : list of tuples\\n        tree as defined for RU2NMNL\\n\\n    Returns\\n    -------\\n    branch : list\\n        list of all branch names\\n\\n    '\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        a = [name]\n        for st in subtree:\n            a.extend(getbranches(st))\n        return a\n    return []",
            "def getbranches(tree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    walk tree to get list of branches\\n\\n    Parameters\\n    ----------\\n    tree : list of tuples\\n        tree as defined for RU2NMNL\\n\\n    Returns\\n    -------\\n    branch : list\\n        list of all branch names\\n\\n    '\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        a = [name]\n        for st in subtree:\n            a.extend(getbranches(st))\n        return a\n    return []",
            "def getbranches(tree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    walk tree to get list of branches\\n\\n    Parameters\\n    ----------\\n    tree : list of tuples\\n        tree as defined for RU2NMNL\\n\\n    Returns\\n    -------\\n    branch : list\\n        list of all branch names\\n\\n    '\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        a = [name]\n        for st in subtree:\n            a.extend(getbranches(st))\n        return a\n    return []",
            "def getbranches(tree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    walk tree to get list of branches\\n\\n    Parameters\\n    ----------\\n    tree : list of tuples\\n        tree as defined for RU2NMNL\\n\\n    Returns\\n    -------\\n    branch : list\\n        list of all branch names\\n\\n    '\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        a = [name]\n        for st in subtree:\n            a.extend(getbranches(st))\n        return a\n    return []",
            "def getbranches(tree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    walk tree to get list of branches\\n\\n    Parameters\\n    ----------\\n    tree : list of tuples\\n        tree as defined for RU2NMNL\\n\\n    Returns\\n    -------\\n    branch : list\\n        list of all branch names\\n\\n    '\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        a = [name]\n        for st in subtree:\n            a.extend(getbranches(st))\n        return a\n    return []"
        ]
    },
    {
        "func_name": "getnodes",
        "original": "def getnodes(tree):\n    \"\"\"\n    walk tree to get list of branches and list of leaves\n\n    Parameters\n    ----------\n    tree : list of tuples\n        tree as defined for RU2NMNL\n\n    Returns\n    -------\n    branch : list\n        list of all branch names\n    leaves : list\n        list of all leaves names\n\n    \"\"\"\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        ab = [name]\n        al = []\n        if len(subtree) == 1:\n            adeg = [name]\n        else:\n            adeg = []\n        for st in subtree:\n            (b, l, d) = getnodes(st)\n            ab.extend(b)\n            al.extend(l)\n            adeg.extend(d)\n        return (ab, al, adeg)\n    return ([], [tree], [])",
        "mutated": [
            "def getnodes(tree):\n    if False:\n        i = 10\n    '\\n    walk tree to get list of branches and list of leaves\\n\\n    Parameters\\n    ----------\\n    tree : list of tuples\\n        tree as defined for RU2NMNL\\n\\n    Returns\\n    -------\\n    branch : list\\n        list of all branch names\\n    leaves : list\\n        list of all leaves names\\n\\n    '\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        ab = [name]\n        al = []\n        if len(subtree) == 1:\n            adeg = [name]\n        else:\n            adeg = []\n        for st in subtree:\n            (b, l, d) = getnodes(st)\n            ab.extend(b)\n            al.extend(l)\n            adeg.extend(d)\n        return (ab, al, adeg)\n    return ([], [tree], [])",
            "def getnodes(tree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    walk tree to get list of branches and list of leaves\\n\\n    Parameters\\n    ----------\\n    tree : list of tuples\\n        tree as defined for RU2NMNL\\n\\n    Returns\\n    -------\\n    branch : list\\n        list of all branch names\\n    leaves : list\\n        list of all leaves names\\n\\n    '\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        ab = [name]\n        al = []\n        if len(subtree) == 1:\n            adeg = [name]\n        else:\n            adeg = []\n        for st in subtree:\n            (b, l, d) = getnodes(st)\n            ab.extend(b)\n            al.extend(l)\n            adeg.extend(d)\n        return (ab, al, adeg)\n    return ([], [tree], [])",
            "def getnodes(tree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    walk tree to get list of branches and list of leaves\\n\\n    Parameters\\n    ----------\\n    tree : list of tuples\\n        tree as defined for RU2NMNL\\n\\n    Returns\\n    -------\\n    branch : list\\n        list of all branch names\\n    leaves : list\\n        list of all leaves names\\n\\n    '\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        ab = [name]\n        al = []\n        if len(subtree) == 1:\n            adeg = [name]\n        else:\n            adeg = []\n        for st in subtree:\n            (b, l, d) = getnodes(st)\n            ab.extend(b)\n            al.extend(l)\n            adeg.extend(d)\n        return (ab, al, adeg)\n    return ([], [tree], [])",
            "def getnodes(tree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    walk tree to get list of branches and list of leaves\\n\\n    Parameters\\n    ----------\\n    tree : list of tuples\\n        tree as defined for RU2NMNL\\n\\n    Returns\\n    -------\\n    branch : list\\n        list of all branch names\\n    leaves : list\\n        list of all leaves names\\n\\n    '\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        ab = [name]\n        al = []\n        if len(subtree) == 1:\n            adeg = [name]\n        else:\n            adeg = []\n        for st in subtree:\n            (b, l, d) = getnodes(st)\n            ab.extend(b)\n            al.extend(l)\n            adeg.extend(d)\n        return (ab, al, adeg)\n    return ([], [tree], [])",
            "def getnodes(tree):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    walk tree to get list of branches and list of leaves\\n\\n    Parameters\\n    ----------\\n    tree : list of tuples\\n        tree as defined for RU2NMNL\\n\\n    Returns\\n    -------\\n    branch : list\\n        list of all branch names\\n    leaves : list\\n        list of all leaves names\\n\\n    '\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        ab = [name]\n        al = []\n        if len(subtree) == 1:\n            adeg = [name]\n        else:\n            adeg = []\n        for st in subtree:\n            (b, l, d) = getnodes(st)\n            ab.extend(b)\n            al.extend(l)\n            adeg.extend(d)\n        return (ab, al, adeg)\n    return ([], [tree], [])"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, endog, exog, tree, paramsind):\n    self.endog = endog\n    self.datadict = exog\n    self.tree = tree\n    self.paramsind = paramsind\n    self.branchsum = ''\n    self.probs = {}\n    self.probstxt = {}\n    self.branchleaves = {}\n    self.branchvalues = {}\n    self.branchsums = {}\n    self.bprobs = {}\n    (self.branches, self.leaves, self.branches_degenerate) = getnodes(tree)\n    self.nbranches = len(self.branches)\n    self.paramsnames = sorted(set([i for j in paramsind.values() for i in j])) + ['tau_%s' % bname for bname in self.branches]\n    self.nparams = len(self.paramsnames)\n    self.paramsidx = dict(((name, idx) for (idx, name) in enumerate(self.paramsnames)))\n    self.parinddict = dict(((k, [self.paramsidx[j] for j in v]) for (k, v) in self.paramsind.items()))\n    self.recursionparams = 1.0 + np.arange(len(self.paramsnames))\n    self.recursionparams = np.zeros(len(self.paramsnames))\n    self.recursionparams[-self.nbranches:] = 1",
        "mutated": [
            "def __init__(self, endog, exog, tree, paramsind):\n    if False:\n        i = 10\n    self.endog = endog\n    self.datadict = exog\n    self.tree = tree\n    self.paramsind = paramsind\n    self.branchsum = ''\n    self.probs = {}\n    self.probstxt = {}\n    self.branchleaves = {}\n    self.branchvalues = {}\n    self.branchsums = {}\n    self.bprobs = {}\n    (self.branches, self.leaves, self.branches_degenerate) = getnodes(tree)\n    self.nbranches = len(self.branches)\n    self.paramsnames = sorted(set([i for j in paramsind.values() for i in j])) + ['tau_%s' % bname for bname in self.branches]\n    self.nparams = len(self.paramsnames)\n    self.paramsidx = dict(((name, idx) for (idx, name) in enumerate(self.paramsnames)))\n    self.parinddict = dict(((k, [self.paramsidx[j] for j in v]) for (k, v) in self.paramsind.items()))\n    self.recursionparams = 1.0 + np.arange(len(self.paramsnames))\n    self.recursionparams = np.zeros(len(self.paramsnames))\n    self.recursionparams[-self.nbranches:] = 1",
            "def __init__(self, endog, exog, tree, paramsind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.endog = endog\n    self.datadict = exog\n    self.tree = tree\n    self.paramsind = paramsind\n    self.branchsum = ''\n    self.probs = {}\n    self.probstxt = {}\n    self.branchleaves = {}\n    self.branchvalues = {}\n    self.branchsums = {}\n    self.bprobs = {}\n    (self.branches, self.leaves, self.branches_degenerate) = getnodes(tree)\n    self.nbranches = len(self.branches)\n    self.paramsnames = sorted(set([i for j in paramsind.values() for i in j])) + ['tau_%s' % bname for bname in self.branches]\n    self.nparams = len(self.paramsnames)\n    self.paramsidx = dict(((name, idx) for (idx, name) in enumerate(self.paramsnames)))\n    self.parinddict = dict(((k, [self.paramsidx[j] for j in v]) for (k, v) in self.paramsind.items()))\n    self.recursionparams = 1.0 + np.arange(len(self.paramsnames))\n    self.recursionparams = np.zeros(len(self.paramsnames))\n    self.recursionparams[-self.nbranches:] = 1",
            "def __init__(self, endog, exog, tree, paramsind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.endog = endog\n    self.datadict = exog\n    self.tree = tree\n    self.paramsind = paramsind\n    self.branchsum = ''\n    self.probs = {}\n    self.probstxt = {}\n    self.branchleaves = {}\n    self.branchvalues = {}\n    self.branchsums = {}\n    self.bprobs = {}\n    (self.branches, self.leaves, self.branches_degenerate) = getnodes(tree)\n    self.nbranches = len(self.branches)\n    self.paramsnames = sorted(set([i for j in paramsind.values() for i in j])) + ['tau_%s' % bname for bname in self.branches]\n    self.nparams = len(self.paramsnames)\n    self.paramsidx = dict(((name, idx) for (idx, name) in enumerate(self.paramsnames)))\n    self.parinddict = dict(((k, [self.paramsidx[j] for j in v]) for (k, v) in self.paramsind.items()))\n    self.recursionparams = 1.0 + np.arange(len(self.paramsnames))\n    self.recursionparams = np.zeros(len(self.paramsnames))\n    self.recursionparams[-self.nbranches:] = 1",
            "def __init__(self, endog, exog, tree, paramsind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.endog = endog\n    self.datadict = exog\n    self.tree = tree\n    self.paramsind = paramsind\n    self.branchsum = ''\n    self.probs = {}\n    self.probstxt = {}\n    self.branchleaves = {}\n    self.branchvalues = {}\n    self.branchsums = {}\n    self.bprobs = {}\n    (self.branches, self.leaves, self.branches_degenerate) = getnodes(tree)\n    self.nbranches = len(self.branches)\n    self.paramsnames = sorted(set([i for j in paramsind.values() for i in j])) + ['tau_%s' % bname for bname in self.branches]\n    self.nparams = len(self.paramsnames)\n    self.paramsidx = dict(((name, idx) for (idx, name) in enumerate(self.paramsnames)))\n    self.parinddict = dict(((k, [self.paramsidx[j] for j in v]) for (k, v) in self.paramsind.items()))\n    self.recursionparams = 1.0 + np.arange(len(self.paramsnames))\n    self.recursionparams = np.zeros(len(self.paramsnames))\n    self.recursionparams[-self.nbranches:] = 1",
            "def __init__(self, endog, exog, tree, paramsind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.endog = endog\n    self.datadict = exog\n    self.tree = tree\n    self.paramsind = paramsind\n    self.branchsum = ''\n    self.probs = {}\n    self.probstxt = {}\n    self.branchleaves = {}\n    self.branchvalues = {}\n    self.branchsums = {}\n    self.bprobs = {}\n    (self.branches, self.leaves, self.branches_degenerate) = getnodes(tree)\n    self.nbranches = len(self.branches)\n    self.paramsnames = sorted(set([i for j in paramsind.values() for i in j])) + ['tau_%s' % bname for bname in self.branches]\n    self.nparams = len(self.paramsnames)\n    self.paramsidx = dict(((name, idx) for (idx, name) in enumerate(self.paramsnames)))\n    self.parinddict = dict(((k, [self.paramsidx[j] for j in v]) for (k, v) in self.paramsind.items()))\n    self.recursionparams = 1.0 + np.arange(len(self.paramsnames))\n    self.recursionparams = np.zeros(len(self.paramsnames))\n    self.recursionparams[-self.nbranches:] = 1"
        ]
    },
    {
        "func_name": "get_probs",
        "original": "def get_probs(self, params):\n    \"\"\"\n        obtain the probability array given an array of parameters\n\n        This is the function that can be called by loglike or other methods\n        that need the probabilities as function of the params.\n\n        Parameters\n        ----------\n        params : 1d array, (nparams,)\n            coefficients and tau that parameterize the model. The required\n            length can be obtained by nparams. (and will depend on the number\n            of degenerate leaves - not yet)\n\n        Returns\n        -------\n        probs : ndarray, (nobs, nchoices)\n            probabilities for all choices for each observation. The order\n            is available by attribute leaves. See note in docstring of class\n\n\n\n        \"\"\"\n    self.recursionparams = params\n    self.calc_prob(self.tree)\n    probs_array = np.array([self.probs[leaf] for leaf in self.leaves])\n    return probs_array",
        "mutated": [
            "def get_probs(self, params):\n    if False:\n        i = 10\n    '\\n        obtain the probability array given an array of parameters\\n\\n        This is the function that can be called by loglike or other methods\\n        that need the probabilities as function of the params.\\n\\n        Parameters\\n        ----------\\n        params : 1d array, (nparams,)\\n            coefficients and tau that parameterize the model. The required\\n            length can be obtained by nparams. (and will depend on the number\\n            of degenerate leaves - not yet)\\n\\n        Returns\\n        -------\\n        probs : ndarray, (nobs, nchoices)\\n            probabilities for all choices for each observation. The order\\n            is available by attribute leaves. See note in docstring of class\\n\\n\\n\\n        '\n    self.recursionparams = params\n    self.calc_prob(self.tree)\n    probs_array = np.array([self.probs[leaf] for leaf in self.leaves])\n    return probs_array",
            "def get_probs(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        obtain the probability array given an array of parameters\\n\\n        This is the function that can be called by loglike or other methods\\n        that need the probabilities as function of the params.\\n\\n        Parameters\\n        ----------\\n        params : 1d array, (nparams,)\\n            coefficients and tau that parameterize the model. The required\\n            length can be obtained by nparams. (and will depend on the number\\n            of degenerate leaves - not yet)\\n\\n        Returns\\n        -------\\n        probs : ndarray, (nobs, nchoices)\\n            probabilities for all choices for each observation. The order\\n            is available by attribute leaves. See note in docstring of class\\n\\n\\n\\n        '\n    self.recursionparams = params\n    self.calc_prob(self.tree)\n    probs_array = np.array([self.probs[leaf] for leaf in self.leaves])\n    return probs_array",
            "def get_probs(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        obtain the probability array given an array of parameters\\n\\n        This is the function that can be called by loglike or other methods\\n        that need the probabilities as function of the params.\\n\\n        Parameters\\n        ----------\\n        params : 1d array, (nparams,)\\n            coefficients and tau that parameterize the model. The required\\n            length can be obtained by nparams. (and will depend on the number\\n            of degenerate leaves - not yet)\\n\\n        Returns\\n        -------\\n        probs : ndarray, (nobs, nchoices)\\n            probabilities for all choices for each observation. The order\\n            is available by attribute leaves. See note in docstring of class\\n\\n\\n\\n        '\n    self.recursionparams = params\n    self.calc_prob(self.tree)\n    probs_array = np.array([self.probs[leaf] for leaf in self.leaves])\n    return probs_array",
            "def get_probs(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        obtain the probability array given an array of parameters\\n\\n        This is the function that can be called by loglike or other methods\\n        that need the probabilities as function of the params.\\n\\n        Parameters\\n        ----------\\n        params : 1d array, (nparams,)\\n            coefficients and tau that parameterize the model. The required\\n            length can be obtained by nparams. (and will depend on the number\\n            of degenerate leaves - not yet)\\n\\n        Returns\\n        -------\\n        probs : ndarray, (nobs, nchoices)\\n            probabilities for all choices for each observation. The order\\n            is available by attribute leaves. See note in docstring of class\\n\\n\\n\\n        '\n    self.recursionparams = params\n    self.calc_prob(self.tree)\n    probs_array = np.array([self.probs[leaf] for leaf in self.leaves])\n    return probs_array",
            "def get_probs(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        obtain the probability array given an array of parameters\\n\\n        This is the function that can be called by loglike or other methods\\n        that need the probabilities as function of the params.\\n\\n        Parameters\\n        ----------\\n        params : 1d array, (nparams,)\\n            coefficients and tau that parameterize the model. The required\\n            length can be obtained by nparams. (and will depend on the number\\n            of degenerate leaves - not yet)\\n\\n        Returns\\n        -------\\n        probs : ndarray, (nobs, nchoices)\\n            probabilities for all choices for each observation. The order\\n            is available by attribute leaves. See note in docstring of class\\n\\n\\n\\n        '\n    self.recursionparams = params\n    self.calc_prob(self.tree)\n    probs_array = np.array([self.probs[leaf] for leaf in self.leaves])\n    return probs_array"
        ]
    },
    {
        "func_name": "calc_prob",
        "original": "def calc_prob(self, tree, parent=None):\n    \"\"\"walking a tree bottom-up based on dictionary\n        \"\"\"\n    endog = self.endog\n    datadict = self.datadict\n    paramsind = self.paramsind\n    branchsum = self.branchsum\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        self.branchleaves[name] = []\n        tau = self.recursionparams[self.paramsidx['tau_' + name]]\n        if DEBUG:\n            print('----------- starting next branch-----------')\n            print(name, datadict[name], 'tau=', tau)\n            print('subtree', subtree)\n        branchvalue = []\n        if testxb == 2:\n            branchsum = 0\n        elif testxb == 1:\n            branchsum = datadict[name]\n        else:\n            branchsum = name\n        for b in subtree:\n            if DEBUG:\n                print(b)\n            bv = self.calc_prob(b, name)\n            bv = np.exp(bv / tau)\n            branchvalue.append(bv)\n            branchsum = branchsum + bv\n        self.branchvalues[name] = branchvalue\n        if DEBUG:\n            print('----------- returning to branch-----------')\n            print(name)\n            print('branchsum in branch', name, branchsum)\n        if parent:\n            if DEBUG:\n                print('parent', parent)\n            self.branchleaves[parent].extend(self.branchleaves[name])\n        if 0:\n            tmpsum = 0\n            for k in self.branchleaves[name]:\n                tmpsum += self.probs[k]\n                iv = np.log(tmpsum)\n            for k in self.branchleaves[name]:\n                self.probstxt[k] = self.probstxt[k] + ['*' + name + '-prob' + '(%s)' % ', '.join(self.paramsind[name])]\n                self.probs[k] = self.probs[k] / tmpsum\n                if np.size(self.datadict[name]) > 0:\n                    if DEBUG:\n                        print('self.datadict[name], self.probs[k]')\n                        print(self.datadict[name], self.probs[k])\n        self.bprobs[name] = []\n        for (bidx, b) in enumerate(subtree):\n            if DEBUG:\n                print('repr(b)', repr(b), bidx)\n            if not isinstance(b, tuple):\n                self.bprobs[name].append(self.probs[b])\n                self.probs[b] = self.probs[b] / branchsum\n                if DEBUG:\n                    print('*********** branchsum at bottom branch', branchsum)\n            else:\n                bname = b[0]\n                branchsum2 = sum(self.branchvalues[name])\n                assert np.abs(branchsum - branchsum2).sum() < 1e-08\n                bprob = branchvalue[bidx] / branchsum\n                self.bprobs[name].append(bprob)\n                for k in self.branchleaves[bname]:\n                    if DEBUG:\n                        print('branchprob', bname, k, bprob, branchsum)\n                    self.probs[k] = self.probs[k] * np.maximum(bprob, 0.0001)\n        if DEBUG:\n            print('working on branch', tree, branchsum)\n        if testxb < 2:\n            return branchsum\n        else:\n            self.branchsums[name] = branchsum\n            if np.size(self.datadict[name]) > 0:\n                branchxb = np.sum(self.datadict[name] * self.recursionparams[self.parinddict[name]])\n            else:\n                branchxb = 0\n            if not name == 'top':\n                tau = self.recursionparams[self.paramsidx['tau_' + name]]\n            else:\n                tau = 1\n            iv = branchxb + tau * branchsum\n            return branchxb + tau * np.log(branchsum)\n    else:\n        tau = self.recursionparams[self.paramsidx['tau_' + parent]]\n        if DEBUG:\n            print('parent', parent)\n        self.branchleaves[parent].append(tree)\n        self.probstxt[tree] = [tree + '-prob' + '(%s)' % ', '.join(self.paramsind[tree])]\n        leafprob = np.exp(np.sum(self.datadict[tree] * self.recursionparams[self.parinddict[tree]]) / tau)\n        self.probs[tree] = leafprob\n        if testxb == 2:\n            return np.log(leafprob)\n        elif testxb == 1:\n            leavessum = np.array(datadict[tree])\n            if DEBUG:\n                print('final branch with', tree, ''.join(tree), leavessum)\n            return leavessum\n        elif testxb == 0:\n            return ''.join(tree)",
        "mutated": [
            "def calc_prob(self, tree, parent=None):\n    if False:\n        i = 10\n    'walking a tree bottom-up based on dictionary\\n        '\n    endog = self.endog\n    datadict = self.datadict\n    paramsind = self.paramsind\n    branchsum = self.branchsum\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        self.branchleaves[name] = []\n        tau = self.recursionparams[self.paramsidx['tau_' + name]]\n        if DEBUG:\n            print('----------- starting next branch-----------')\n            print(name, datadict[name], 'tau=', tau)\n            print('subtree', subtree)\n        branchvalue = []\n        if testxb == 2:\n            branchsum = 0\n        elif testxb == 1:\n            branchsum = datadict[name]\n        else:\n            branchsum = name\n        for b in subtree:\n            if DEBUG:\n                print(b)\n            bv = self.calc_prob(b, name)\n            bv = np.exp(bv / tau)\n            branchvalue.append(bv)\n            branchsum = branchsum + bv\n        self.branchvalues[name] = branchvalue\n        if DEBUG:\n            print('----------- returning to branch-----------')\n            print(name)\n            print('branchsum in branch', name, branchsum)\n        if parent:\n            if DEBUG:\n                print('parent', parent)\n            self.branchleaves[parent].extend(self.branchleaves[name])\n        if 0:\n            tmpsum = 0\n            for k in self.branchleaves[name]:\n                tmpsum += self.probs[k]\n                iv = np.log(tmpsum)\n            for k in self.branchleaves[name]:\n                self.probstxt[k] = self.probstxt[k] + ['*' + name + '-prob' + '(%s)' % ', '.join(self.paramsind[name])]\n                self.probs[k] = self.probs[k] / tmpsum\n                if np.size(self.datadict[name]) > 0:\n                    if DEBUG:\n                        print('self.datadict[name], self.probs[k]')\n                        print(self.datadict[name], self.probs[k])\n        self.bprobs[name] = []\n        for (bidx, b) in enumerate(subtree):\n            if DEBUG:\n                print('repr(b)', repr(b), bidx)\n            if not isinstance(b, tuple):\n                self.bprobs[name].append(self.probs[b])\n                self.probs[b] = self.probs[b] / branchsum\n                if DEBUG:\n                    print('*********** branchsum at bottom branch', branchsum)\n            else:\n                bname = b[0]\n                branchsum2 = sum(self.branchvalues[name])\n                assert np.abs(branchsum - branchsum2).sum() < 1e-08\n                bprob = branchvalue[bidx] / branchsum\n                self.bprobs[name].append(bprob)\n                for k in self.branchleaves[bname]:\n                    if DEBUG:\n                        print('branchprob', bname, k, bprob, branchsum)\n                    self.probs[k] = self.probs[k] * np.maximum(bprob, 0.0001)\n        if DEBUG:\n            print('working on branch', tree, branchsum)\n        if testxb < 2:\n            return branchsum\n        else:\n            self.branchsums[name] = branchsum\n            if np.size(self.datadict[name]) > 0:\n                branchxb = np.sum(self.datadict[name] * self.recursionparams[self.parinddict[name]])\n            else:\n                branchxb = 0\n            if not name == 'top':\n                tau = self.recursionparams[self.paramsidx['tau_' + name]]\n            else:\n                tau = 1\n            iv = branchxb + tau * branchsum\n            return branchxb + tau * np.log(branchsum)\n    else:\n        tau = self.recursionparams[self.paramsidx['tau_' + parent]]\n        if DEBUG:\n            print('parent', parent)\n        self.branchleaves[parent].append(tree)\n        self.probstxt[tree] = [tree + '-prob' + '(%s)' % ', '.join(self.paramsind[tree])]\n        leafprob = np.exp(np.sum(self.datadict[tree] * self.recursionparams[self.parinddict[tree]]) / tau)\n        self.probs[tree] = leafprob\n        if testxb == 2:\n            return np.log(leafprob)\n        elif testxb == 1:\n            leavessum = np.array(datadict[tree])\n            if DEBUG:\n                print('final branch with', tree, ''.join(tree), leavessum)\n            return leavessum\n        elif testxb == 0:\n            return ''.join(tree)",
            "def calc_prob(self, tree, parent=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'walking a tree bottom-up based on dictionary\\n        '\n    endog = self.endog\n    datadict = self.datadict\n    paramsind = self.paramsind\n    branchsum = self.branchsum\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        self.branchleaves[name] = []\n        tau = self.recursionparams[self.paramsidx['tau_' + name]]\n        if DEBUG:\n            print('----------- starting next branch-----------')\n            print(name, datadict[name], 'tau=', tau)\n            print('subtree', subtree)\n        branchvalue = []\n        if testxb == 2:\n            branchsum = 0\n        elif testxb == 1:\n            branchsum = datadict[name]\n        else:\n            branchsum = name\n        for b in subtree:\n            if DEBUG:\n                print(b)\n            bv = self.calc_prob(b, name)\n            bv = np.exp(bv / tau)\n            branchvalue.append(bv)\n            branchsum = branchsum + bv\n        self.branchvalues[name] = branchvalue\n        if DEBUG:\n            print('----------- returning to branch-----------')\n            print(name)\n            print('branchsum in branch', name, branchsum)\n        if parent:\n            if DEBUG:\n                print('parent', parent)\n            self.branchleaves[parent].extend(self.branchleaves[name])\n        if 0:\n            tmpsum = 0\n            for k in self.branchleaves[name]:\n                tmpsum += self.probs[k]\n                iv = np.log(tmpsum)\n            for k in self.branchleaves[name]:\n                self.probstxt[k] = self.probstxt[k] + ['*' + name + '-prob' + '(%s)' % ', '.join(self.paramsind[name])]\n                self.probs[k] = self.probs[k] / tmpsum\n                if np.size(self.datadict[name]) > 0:\n                    if DEBUG:\n                        print('self.datadict[name], self.probs[k]')\n                        print(self.datadict[name], self.probs[k])\n        self.bprobs[name] = []\n        for (bidx, b) in enumerate(subtree):\n            if DEBUG:\n                print('repr(b)', repr(b), bidx)\n            if not isinstance(b, tuple):\n                self.bprobs[name].append(self.probs[b])\n                self.probs[b] = self.probs[b] / branchsum\n                if DEBUG:\n                    print('*********** branchsum at bottom branch', branchsum)\n            else:\n                bname = b[0]\n                branchsum2 = sum(self.branchvalues[name])\n                assert np.abs(branchsum - branchsum2).sum() < 1e-08\n                bprob = branchvalue[bidx] / branchsum\n                self.bprobs[name].append(bprob)\n                for k in self.branchleaves[bname]:\n                    if DEBUG:\n                        print('branchprob', bname, k, bprob, branchsum)\n                    self.probs[k] = self.probs[k] * np.maximum(bprob, 0.0001)\n        if DEBUG:\n            print('working on branch', tree, branchsum)\n        if testxb < 2:\n            return branchsum\n        else:\n            self.branchsums[name] = branchsum\n            if np.size(self.datadict[name]) > 0:\n                branchxb = np.sum(self.datadict[name] * self.recursionparams[self.parinddict[name]])\n            else:\n                branchxb = 0\n            if not name == 'top':\n                tau = self.recursionparams[self.paramsidx['tau_' + name]]\n            else:\n                tau = 1\n            iv = branchxb + tau * branchsum\n            return branchxb + tau * np.log(branchsum)\n    else:\n        tau = self.recursionparams[self.paramsidx['tau_' + parent]]\n        if DEBUG:\n            print('parent', parent)\n        self.branchleaves[parent].append(tree)\n        self.probstxt[tree] = [tree + '-prob' + '(%s)' % ', '.join(self.paramsind[tree])]\n        leafprob = np.exp(np.sum(self.datadict[tree] * self.recursionparams[self.parinddict[tree]]) / tau)\n        self.probs[tree] = leafprob\n        if testxb == 2:\n            return np.log(leafprob)\n        elif testxb == 1:\n            leavessum = np.array(datadict[tree])\n            if DEBUG:\n                print('final branch with', tree, ''.join(tree), leavessum)\n            return leavessum\n        elif testxb == 0:\n            return ''.join(tree)",
            "def calc_prob(self, tree, parent=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'walking a tree bottom-up based on dictionary\\n        '\n    endog = self.endog\n    datadict = self.datadict\n    paramsind = self.paramsind\n    branchsum = self.branchsum\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        self.branchleaves[name] = []\n        tau = self.recursionparams[self.paramsidx['tau_' + name]]\n        if DEBUG:\n            print('----------- starting next branch-----------')\n            print(name, datadict[name], 'tau=', tau)\n            print('subtree', subtree)\n        branchvalue = []\n        if testxb == 2:\n            branchsum = 0\n        elif testxb == 1:\n            branchsum = datadict[name]\n        else:\n            branchsum = name\n        for b in subtree:\n            if DEBUG:\n                print(b)\n            bv = self.calc_prob(b, name)\n            bv = np.exp(bv / tau)\n            branchvalue.append(bv)\n            branchsum = branchsum + bv\n        self.branchvalues[name] = branchvalue\n        if DEBUG:\n            print('----------- returning to branch-----------')\n            print(name)\n            print('branchsum in branch', name, branchsum)\n        if parent:\n            if DEBUG:\n                print('parent', parent)\n            self.branchleaves[parent].extend(self.branchleaves[name])\n        if 0:\n            tmpsum = 0\n            for k in self.branchleaves[name]:\n                tmpsum += self.probs[k]\n                iv = np.log(tmpsum)\n            for k in self.branchleaves[name]:\n                self.probstxt[k] = self.probstxt[k] + ['*' + name + '-prob' + '(%s)' % ', '.join(self.paramsind[name])]\n                self.probs[k] = self.probs[k] / tmpsum\n                if np.size(self.datadict[name]) > 0:\n                    if DEBUG:\n                        print('self.datadict[name], self.probs[k]')\n                        print(self.datadict[name], self.probs[k])\n        self.bprobs[name] = []\n        for (bidx, b) in enumerate(subtree):\n            if DEBUG:\n                print('repr(b)', repr(b), bidx)\n            if not isinstance(b, tuple):\n                self.bprobs[name].append(self.probs[b])\n                self.probs[b] = self.probs[b] / branchsum\n                if DEBUG:\n                    print('*********** branchsum at bottom branch', branchsum)\n            else:\n                bname = b[0]\n                branchsum2 = sum(self.branchvalues[name])\n                assert np.abs(branchsum - branchsum2).sum() < 1e-08\n                bprob = branchvalue[bidx] / branchsum\n                self.bprobs[name].append(bprob)\n                for k in self.branchleaves[bname]:\n                    if DEBUG:\n                        print('branchprob', bname, k, bprob, branchsum)\n                    self.probs[k] = self.probs[k] * np.maximum(bprob, 0.0001)\n        if DEBUG:\n            print('working on branch', tree, branchsum)\n        if testxb < 2:\n            return branchsum\n        else:\n            self.branchsums[name] = branchsum\n            if np.size(self.datadict[name]) > 0:\n                branchxb = np.sum(self.datadict[name] * self.recursionparams[self.parinddict[name]])\n            else:\n                branchxb = 0\n            if not name == 'top':\n                tau = self.recursionparams[self.paramsidx['tau_' + name]]\n            else:\n                tau = 1\n            iv = branchxb + tau * branchsum\n            return branchxb + tau * np.log(branchsum)\n    else:\n        tau = self.recursionparams[self.paramsidx['tau_' + parent]]\n        if DEBUG:\n            print('parent', parent)\n        self.branchleaves[parent].append(tree)\n        self.probstxt[tree] = [tree + '-prob' + '(%s)' % ', '.join(self.paramsind[tree])]\n        leafprob = np.exp(np.sum(self.datadict[tree] * self.recursionparams[self.parinddict[tree]]) / tau)\n        self.probs[tree] = leafprob\n        if testxb == 2:\n            return np.log(leafprob)\n        elif testxb == 1:\n            leavessum = np.array(datadict[tree])\n            if DEBUG:\n                print('final branch with', tree, ''.join(tree), leavessum)\n            return leavessum\n        elif testxb == 0:\n            return ''.join(tree)",
            "def calc_prob(self, tree, parent=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'walking a tree bottom-up based on dictionary\\n        '\n    endog = self.endog\n    datadict = self.datadict\n    paramsind = self.paramsind\n    branchsum = self.branchsum\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        self.branchleaves[name] = []\n        tau = self.recursionparams[self.paramsidx['tau_' + name]]\n        if DEBUG:\n            print('----------- starting next branch-----------')\n            print(name, datadict[name], 'tau=', tau)\n            print('subtree', subtree)\n        branchvalue = []\n        if testxb == 2:\n            branchsum = 0\n        elif testxb == 1:\n            branchsum = datadict[name]\n        else:\n            branchsum = name\n        for b in subtree:\n            if DEBUG:\n                print(b)\n            bv = self.calc_prob(b, name)\n            bv = np.exp(bv / tau)\n            branchvalue.append(bv)\n            branchsum = branchsum + bv\n        self.branchvalues[name] = branchvalue\n        if DEBUG:\n            print('----------- returning to branch-----------')\n            print(name)\n            print('branchsum in branch', name, branchsum)\n        if parent:\n            if DEBUG:\n                print('parent', parent)\n            self.branchleaves[parent].extend(self.branchleaves[name])\n        if 0:\n            tmpsum = 0\n            for k in self.branchleaves[name]:\n                tmpsum += self.probs[k]\n                iv = np.log(tmpsum)\n            for k in self.branchleaves[name]:\n                self.probstxt[k] = self.probstxt[k] + ['*' + name + '-prob' + '(%s)' % ', '.join(self.paramsind[name])]\n                self.probs[k] = self.probs[k] / tmpsum\n                if np.size(self.datadict[name]) > 0:\n                    if DEBUG:\n                        print('self.datadict[name], self.probs[k]')\n                        print(self.datadict[name], self.probs[k])\n        self.bprobs[name] = []\n        for (bidx, b) in enumerate(subtree):\n            if DEBUG:\n                print('repr(b)', repr(b), bidx)\n            if not isinstance(b, tuple):\n                self.bprobs[name].append(self.probs[b])\n                self.probs[b] = self.probs[b] / branchsum\n                if DEBUG:\n                    print('*********** branchsum at bottom branch', branchsum)\n            else:\n                bname = b[0]\n                branchsum2 = sum(self.branchvalues[name])\n                assert np.abs(branchsum - branchsum2).sum() < 1e-08\n                bprob = branchvalue[bidx] / branchsum\n                self.bprobs[name].append(bprob)\n                for k in self.branchleaves[bname]:\n                    if DEBUG:\n                        print('branchprob', bname, k, bprob, branchsum)\n                    self.probs[k] = self.probs[k] * np.maximum(bprob, 0.0001)\n        if DEBUG:\n            print('working on branch', tree, branchsum)\n        if testxb < 2:\n            return branchsum\n        else:\n            self.branchsums[name] = branchsum\n            if np.size(self.datadict[name]) > 0:\n                branchxb = np.sum(self.datadict[name] * self.recursionparams[self.parinddict[name]])\n            else:\n                branchxb = 0\n            if not name == 'top':\n                tau = self.recursionparams[self.paramsidx['tau_' + name]]\n            else:\n                tau = 1\n            iv = branchxb + tau * branchsum\n            return branchxb + tau * np.log(branchsum)\n    else:\n        tau = self.recursionparams[self.paramsidx['tau_' + parent]]\n        if DEBUG:\n            print('parent', parent)\n        self.branchleaves[parent].append(tree)\n        self.probstxt[tree] = [tree + '-prob' + '(%s)' % ', '.join(self.paramsind[tree])]\n        leafprob = np.exp(np.sum(self.datadict[tree] * self.recursionparams[self.parinddict[tree]]) / tau)\n        self.probs[tree] = leafprob\n        if testxb == 2:\n            return np.log(leafprob)\n        elif testxb == 1:\n            leavessum = np.array(datadict[tree])\n            if DEBUG:\n                print('final branch with', tree, ''.join(tree), leavessum)\n            return leavessum\n        elif testxb == 0:\n            return ''.join(tree)",
            "def calc_prob(self, tree, parent=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'walking a tree bottom-up based on dictionary\\n        '\n    endog = self.endog\n    datadict = self.datadict\n    paramsind = self.paramsind\n    branchsum = self.branchsum\n    if isinstance(tree, tuple):\n        (name, subtree) = tree\n        self.branchleaves[name] = []\n        tau = self.recursionparams[self.paramsidx['tau_' + name]]\n        if DEBUG:\n            print('----------- starting next branch-----------')\n            print(name, datadict[name], 'tau=', tau)\n            print('subtree', subtree)\n        branchvalue = []\n        if testxb == 2:\n            branchsum = 0\n        elif testxb == 1:\n            branchsum = datadict[name]\n        else:\n            branchsum = name\n        for b in subtree:\n            if DEBUG:\n                print(b)\n            bv = self.calc_prob(b, name)\n            bv = np.exp(bv / tau)\n            branchvalue.append(bv)\n            branchsum = branchsum + bv\n        self.branchvalues[name] = branchvalue\n        if DEBUG:\n            print('----------- returning to branch-----------')\n            print(name)\n            print('branchsum in branch', name, branchsum)\n        if parent:\n            if DEBUG:\n                print('parent', parent)\n            self.branchleaves[parent].extend(self.branchleaves[name])\n        if 0:\n            tmpsum = 0\n            for k in self.branchleaves[name]:\n                tmpsum += self.probs[k]\n                iv = np.log(tmpsum)\n            for k in self.branchleaves[name]:\n                self.probstxt[k] = self.probstxt[k] + ['*' + name + '-prob' + '(%s)' % ', '.join(self.paramsind[name])]\n                self.probs[k] = self.probs[k] / tmpsum\n                if np.size(self.datadict[name]) > 0:\n                    if DEBUG:\n                        print('self.datadict[name], self.probs[k]')\n                        print(self.datadict[name], self.probs[k])\n        self.bprobs[name] = []\n        for (bidx, b) in enumerate(subtree):\n            if DEBUG:\n                print('repr(b)', repr(b), bidx)\n            if not isinstance(b, tuple):\n                self.bprobs[name].append(self.probs[b])\n                self.probs[b] = self.probs[b] / branchsum\n                if DEBUG:\n                    print('*********** branchsum at bottom branch', branchsum)\n            else:\n                bname = b[0]\n                branchsum2 = sum(self.branchvalues[name])\n                assert np.abs(branchsum - branchsum2).sum() < 1e-08\n                bprob = branchvalue[bidx] / branchsum\n                self.bprobs[name].append(bprob)\n                for k in self.branchleaves[bname]:\n                    if DEBUG:\n                        print('branchprob', bname, k, bprob, branchsum)\n                    self.probs[k] = self.probs[k] * np.maximum(bprob, 0.0001)\n        if DEBUG:\n            print('working on branch', tree, branchsum)\n        if testxb < 2:\n            return branchsum\n        else:\n            self.branchsums[name] = branchsum\n            if np.size(self.datadict[name]) > 0:\n                branchxb = np.sum(self.datadict[name] * self.recursionparams[self.parinddict[name]])\n            else:\n                branchxb = 0\n            if not name == 'top':\n                tau = self.recursionparams[self.paramsidx['tau_' + name]]\n            else:\n                tau = 1\n            iv = branchxb + tau * branchsum\n            return branchxb + tau * np.log(branchsum)\n    else:\n        tau = self.recursionparams[self.paramsidx['tau_' + parent]]\n        if DEBUG:\n            print('parent', parent)\n        self.branchleaves[parent].append(tree)\n        self.probstxt[tree] = [tree + '-prob' + '(%s)' % ', '.join(self.paramsind[tree])]\n        leafprob = np.exp(np.sum(self.datadict[tree] * self.recursionparams[self.parinddict[tree]]) / tau)\n        self.probs[tree] = leafprob\n        if testxb == 2:\n            return np.log(leafprob)\n        elif testxb == 1:\n            leavessum = np.array(datadict[tree])\n            if DEBUG:\n                print('final branch with', tree, ''.join(tree), leavessum)\n            return leavessum\n        elif testxb == 0:\n            return ''.join(tree)"
        ]
    }
]