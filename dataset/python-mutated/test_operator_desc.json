[
    {
        "func_name": "test_error_type",
        "original": "def test_error_type(self):\n    block = main_program._create_block()\n    try:\n        block.append_op()\n        self.assertFail()\n    except ValueError as v_err:\n        self.assertEqual(str(v_err), '`type` to initialized an Operator can not be None.')\n    try:\n        block.append_op(type='no_such_op')\n        self.assertFail()\n    except ValueError as a_err:\n        self.assertEqual(str(a_err), 'Operator \"no_such_op\" has not been registered.')",
        "mutated": [
            "def test_error_type(self):\n    if False:\n        i = 10\n    block = main_program._create_block()\n    try:\n        block.append_op()\n        self.assertFail()\n    except ValueError as v_err:\n        self.assertEqual(str(v_err), '`type` to initialized an Operator can not be None.')\n    try:\n        block.append_op(type='no_such_op')\n        self.assertFail()\n    except ValueError as a_err:\n        self.assertEqual(str(a_err), 'Operator \"no_such_op\" has not been registered.')",
            "def test_error_type(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    block = main_program._create_block()\n    try:\n        block.append_op()\n        self.assertFail()\n    except ValueError as v_err:\n        self.assertEqual(str(v_err), '`type` to initialized an Operator can not be None.')\n    try:\n        block.append_op(type='no_such_op')\n        self.assertFail()\n    except ValueError as a_err:\n        self.assertEqual(str(a_err), 'Operator \"no_such_op\" has not been registered.')",
            "def test_error_type(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    block = main_program._create_block()\n    try:\n        block.append_op()\n        self.assertFail()\n    except ValueError as v_err:\n        self.assertEqual(str(v_err), '`type` to initialized an Operator can not be None.')\n    try:\n        block.append_op(type='no_such_op')\n        self.assertFail()\n    except ValueError as a_err:\n        self.assertEqual(str(a_err), 'Operator \"no_such_op\" has not been registered.')",
            "def test_error_type(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    block = main_program._create_block()\n    try:\n        block.append_op()\n        self.assertFail()\n    except ValueError as v_err:\n        self.assertEqual(str(v_err), '`type` to initialized an Operator can not be None.')\n    try:\n        block.append_op(type='no_such_op')\n        self.assertFail()\n    except ValueError as a_err:\n        self.assertEqual(str(a_err), 'Operator \"no_such_op\" has not been registered.')",
            "def test_error_type(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    block = main_program._create_block()\n    try:\n        block.append_op()\n        self.assertFail()\n    except ValueError as v_err:\n        self.assertEqual(str(v_err), '`type` to initialized an Operator can not be None.')\n    try:\n        block.append_op(type='no_such_op')\n        self.assertFail()\n    except ValueError as a_err:\n        self.assertEqual(str(a_err), 'Operator \"no_such_op\" has not been registered.')"
        ]
    },
    {
        "func_name": "test_op_desc_creation",
        "original": "def test_op_desc_creation(self):\n    program = Program()\n    block = program.current_block()\n    mul_x = block.create_var(dtype='float32', shape=[5, 10], lod_level=0, name='mul.x')\n    mul_y = block.create_var(dtype='float32', shape=[10, 8], lod_level=0, name='mul.y')\n    mul_out = block.create_var(dtype='float32', shape=[5, 8], lod_level=0, name='mul.out')\n    mul_op = block.append_op(type='mul', inputs={'X': [mul_x], 'Y': mul_y}, outputs={'Out': [mul_out]}, attrs={'x_num_col_dims': 1})\n    self.assertNotEqual(str(mul_op), '')\n    self.assertEqual(mul_op.type, 'mul')\n    self.assertEqual(mul_op.input_names, ['X', 'Y'])\n    self.assertEqual(mul_op.input('X'), ['mul.x'])\n    self.assertEqual(mul_op.input('Y'), ['mul.y'])\n    self.assertEqual(mul_op.output_names, ['Out'])\n    self.assertEqual(mul_op.output('Out'), ['mul.out'])\n    self.assertEqual(set(mul_op.attr_names), {'x_num_col_dims', 'y_num_col_dims', 'op_role', 'op_role_var', 'op_namescope', 'op_callstack', 'op_device', 'with_quant_attr'})\n    self.assertEqual(mul_op.has_attr('x_num_col_dims'), True)\n    self.assertEqual(mul_op.attr_type('x_num_col_dims'), core.AttrType.INT)\n    self.assertEqual(mul_op.attr('x_num_col_dims'), 1)\n    self.assertEqual(mul_op.has_attr('y_num_col_dims'), True)\n    self.assertEqual(mul_op.attr_type('y_num_col_dims'), core.AttrType.INT)\n    self.assertEqual(mul_op.attr('y_num_col_dims'), 1)\n    self.assertEqual(mul_op.idx, 0)\n    self.assertEqual(mul_out.op, mul_op)\n    mul_op.desc.remove_input('X')\n    self.assertEqual(mul_op.input_names, ['Y'])",
        "mutated": [
            "def test_op_desc_creation(self):\n    if False:\n        i = 10\n    program = Program()\n    block = program.current_block()\n    mul_x = block.create_var(dtype='float32', shape=[5, 10], lod_level=0, name='mul.x')\n    mul_y = block.create_var(dtype='float32', shape=[10, 8], lod_level=0, name='mul.y')\n    mul_out = block.create_var(dtype='float32', shape=[5, 8], lod_level=0, name='mul.out')\n    mul_op = block.append_op(type='mul', inputs={'X': [mul_x], 'Y': mul_y}, outputs={'Out': [mul_out]}, attrs={'x_num_col_dims': 1})\n    self.assertNotEqual(str(mul_op), '')\n    self.assertEqual(mul_op.type, 'mul')\n    self.assertEqual(mul_op.input_names, ['X', 'Y'])\n    self.assertEqual(mul_op.input('X'), ['mul.x'])\n    self.assertEqual(mul_op.input('Y'), ['mul.y'])\n    self.assertEqual(mul_op.output_names, ['Out'])\n    self.assertEqual(mul_op.output('Out'), ['mul.out'])\n    self.assertEqual(set(mul_op.attr_names), {'x_num_col_dims', 'y_num_col_dims', 'op_role', 'op_role_var', 'op_namescope', 'op_callstack', 'op_device', 'with_quant_attr'})\n    self.assertEqual(mul_op.has_attr('x_num_col_dims'), True)\n    self.assertEqual(mul_op.attr_type('x_num_col_dims'), core.AttrType.INT)\n    self.assertEqual(mul_op.attr('x_num_col_dims'), 1)\n    self.assertEqual(mul_op.has_attr('y_num_col_dims'), True)\n    self.assertEqual(mul_op.attr_type('y_num_col_dims'), core.AttrType.INT)\n    self.assertEqual(mul_op.attr('y_num_col_dims'), 1)\n    self.assertEqual(mul_op.idx, 0)\n    self.assertEqual(mul_out.op, mul_op)\n    mul_op.desc.remove_input('X')\n    self.assertEqual(mul_op.input_names, ['Y'])",
            "def test_op_desc_creation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    program = Program()\n    block = program.current_block()\n    mul_x = block.create_var(dtype='float32', shape=[5, 10], lod_level=0, name='mul.x')\n    mul_y = block.create_var(dtype='float32', shape=[10, 8], lod_level=0, name='mul.y')\n    mul_out = block.create_var(dtype='float32', shape=[5, 8], lod_level=0, name='mul.out')\n    mul_op = block.append_op(type='mul', inputs={'X': [mul_x], 'Y': mul_y}, outputs={'Out': [mul_out]}, attrs={'x_num_col_dims': 1})\n    self.assertNotEqual(str(mul_op), '')\n    self.assertEqual(mul_op.type, 'mul')\n    self.assertEqual(mul_op.input_names, ['X', 'Y'])\n    self.assertEqual(mul_op.input('X'), ['mul.x'])\n    self.assertEqual(mul_op.input('Y'), ['mul.y'])\n    self.assertEqual(mul_op.output_names, ['Out'])\n    self.assertEqual(mul_op.output('Out'), ['mul.out'])\n    self.assertEqual(set(mul_op.attr_names), {'x_num_col_dims', 'y_num_col_dims', 'op_role', 'op_role_var', 'op_namescope', 'op_callstack', 'op_device', 'with_quant_attr'})\n    self.assertEqual(mul_op.has_attr('x_num_col_dims'), True)\n    self.assertEqual(mul_op.attr_type('x_num_col_dims'), core.AttrType.INT)\n    self.assertEqual(mul_op.attr('x_num_col_dims'), 1)\n    self.assertEqual(mul_op.has_attr('y_num_col_dims'), True)\n    self.assertEqual(mul_op.attr_type('y_num_col_dims'), core.AttrType.INT)\n    self.assertEqual(mul_op.attr('y_num_col_dims'), 1)\n    self.assertEqual(mul_op.idx, 0)\n    self.assertEqual(mul_out.op, mul_op)\n    mul_op.desc.remove_input('X')\n    self.assertEqual(mul_op.input_names, ['Y'])",
            "def test_op_desc_creation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    program = Program()\n    block = program.current_block()\n    mul_x = block.create_var(dtype='float32', shape=[5, 10], lod_level=0, name='mul.x')\n    mul_y = block.create_var(dtype='float32', shape=[10, 8], lod_level=0, name='mul.y')\n    mul_out = block.create_var(dtype='float32', shape=[5, 8], lod_level=0, name='mul.out')\n    mul_op = block.append_op(type='mul', inputs={'X': [mul_x], 'Y': mul_y}, outputs={'Out': [mul_out]}, attrs={'x_num_col_dims': 1})\n    self.assertNotEqual(str(mul_op), '')\n    self.assertEqual(mul_op.type, 'mul')\n    self.assertEqual(mul_op.input_names, ['X', 'Y'])\n    self.assertEqual(mul_op.input('X'), ['mul.x'])\n    self.assertEqual(mul_op.input('Y'), ['mul.y'])\n    self.assertEqual(mul_op.output_names, ['Out'])\n    self.assertEqual(mul_op.output('Out'), ['mul.out'])\n    self.assertEqual(set(mul_op.attr_names), {'x_num_col_dims', 'y_num_col_dims', 'op_role', 'op_role_var', 'op_namescope', 'op_callstack', 'op_device', 'with_quant_attr'})\n    self.assertEqual(mul_op.has_attr('x_num_col_dims'), True)\n    self.assertEqual(mul_op.attr_type('x_num_col_dims'), core.AttrType.INT)\n    self.assertEqual(mul_op.attr('x_num_col_dims'), 1)\n    self.assertEqual(mul_op.has_attr('y_num_col_dims'), True)\n    self.assertEqual(mul_op.attr_type('y_num_col_dims'), core.AttrType.INT)\n    self.assertEqual(mul_op.attr('y_num_col_dims'), 1)\n    self.assertEqual(mul_op.idx, 0)\n    self.assertEqual(mul_out.op, mul_op)\n    mul_op.desc.remove_input('X')\n    self.assertEqual(mul_op.input_names, ['Y'])",
            "def test_op_desc_creation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    program = Program()\n    block = program.current_block()\n    mul_x = block.create_var(dtype='float32', shape=[5, 10], lod_level=0, name='mul.x')\n    mul_y = block.create_var(dtype='float32', shape=[10, 8], lod_level=0, name='mul.y')\n    mul_out = block.create_var(dtype='float32', shape=[5, 8], lod_level=0, name='mul.out')\n    mul_op = block.append_op(type='mul', inputs={'X': [mul_x], 'Y': mul_y}, outputs={'Out': [mul_out]}, attrs={'x_num_col_dims': 1})\n    self.assertNotEqual(str(mul_op), '')\n    self.assertEqual(mul_op.type, 'mul')\n    self.assertEqual(mul_op.input_names, ['X', 'Y'])\n    self.assertEqual(mul_op.input('X'), ['mul.x'])\n    self.assertEqual(mul_op.input('Y'), ['mul.y'])\n    self.assertEqual(mul_op.output_names, ['Out'])\n    self.assertEqual(mul_op.output('Out'), ['mul.out'])\n    self.assertEqual(set(mul_op.attr_names), {'x_num_col_dims', 'y_num_col_dims', 'op_role', 'op_role_var', 'op_namescope', 'op_callstack', 'op_device', 'with_quant_attr'})\n    self.assertEqual(mul_op.has_attr('x_num_col_dims'), True)\n    self.assertEqual(mul_op.attr_type('x_num_col_dims'), core.AttrType.INT)\n    self.assertEqual(mul_op.attr('x_num_col_dims'), 1)\n    self.assertEqual(mul_op.has_attr('y_num_col_dims'), True)\n    self.assertEqual(mul_op.attr_type('y_num_col_dims'), core.AttrType.INT)\n    self.assertEqual(mul_op.attr('y_num_col_dims'), 1)\n    self.assertEqual(mul_op.idx, 0)\n    self.assertEqual(mul_out.op, mul_op)\n    mul_op.desc.remove_input('X')\n    self.assertEqual(mul_op.input_names, ['Y'])",
            "def test_op_desc_creation(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    program = Program()\n    block = program.current_block()\n    mul_x = block.create_var(dtype='float32', shape=[5, 10], lod_level=0, name='mul.x')\n    mul_y = block.create_var(dtype='float32', shape=[10, 8], lod_level=0, name='mul.y')\n    mul_out = block.create_var(dtype='float32', shape=[5, 8], lod_level=0, name='mul.out')\n    mul_op = block.append_op(type='mul', inputs={'X': [mul_x], 'Y': mul_y}, outputs={'Out': [mul_out]}, attrs={'x_num_col_dims': 1})\n    self.assertNotEqual(str(mul_op), '')\n    self.assertEqual(mul_op.type, 'mul')\n    self.assertEqual(mul_op.input_names, ['X', 'Y'])\n    self.assertEqual(mul_op.input('X'), ['mul.x'])\n    self.assertEqual(mul_op.input('Y'), ['mul.y'])\n    self.assertEqual(mul_op.output_names, ['Out'])\n    self.assertEqual(mul_op.output('Out'), ['mul.out'])\n    self.assertEqual(set(mul_op.attr_names), {'x_num_col_dims', 'y_num_col_dims', 'op_role', 'op_role_var', 'op_namescope', 'op_callstack', 'op_device', 'with_quant_attr'})\n    self.assertEqual(mul_op.has_attr('x_num_col_dims'), True)\n    self.assertEqual(mul_op.attr_type('x_num_col_dims'), core.AttrType.INT)\n    self.assertEqual(mul_op.attr('x_num_col_dims'), 1)\n    self.assertEqual(mul_op.has_attr('y_num_col_dims'), True)\n    self.assertEqual(mul_op.attr_type('y_num_col_dims'), core.AttrType.INT)\n    self.assertEqual(mul_op.attr('y_num_col_dims'), 1)\n    self.assertEqual(mul_op.idx, 0)\n    self.assertEqual(mul_out.op, mul_op)\n    mul_op.desc.remove_input('X')\n    self.assertEqual(mul_op.input_names, ['Y'])"
        ]
    },
    {
        "func_name": "test_mult_input",
        "original": "def test_mult_input(self):\n    program = Program()\n    block = program.current_block()\n    sum_x1 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x1')\n    sum_x2 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x2')\n    sum_x3 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x3')\n    sum_out = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.out')\n    sum_op = block.append_op(type='sum', inputs={'X': [sum_x1, sum_x2, sum_x3]}, outputs={'Out': sum_out})\n    self.assertEqual(sum_op.type, 'sum')\n    self.assertEqual(sum_op.input_names, ['X'])\n    self.assertEqual(sum_op.input('X'), ['sum.x1', 'sum.x2', 'sum.x3'])\n    self.assertEqual(sum_op.output_names, ['Out'])\n    self.assertEqual(sum_op.output('Out'), ['sum.out'])\n    self.assertEqual(sum_op.idx, 0)\n    self.assertEqual(sum_out.op, sum_op)",
        "mutated": [
            "def test_mult_input(self):\n    if False:\n        i = 10\n    program = Program()\n    block = program.current_block()\n    sum_x1 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x1')\n    sum_x2 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x2')\n    sum_x3 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x3')\n    sum_out = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.out')\n    sum_op = block.append_op(type='sum', inputs={'X': [sum_x1, sum_x2, sum_x3]}, outputs={'Out': sum_out})\n    self.assertEqual(sum_op.type, 'sum')\n    self.assertEqual(sum_op.input_names, ['X'])\n    self.assertEqual(sum_op.input('X'), ['sum.x1', 'sum.x2', 'sum.x3'])\n    self.assertEqual(sum_op.output_names, ['Out'])\n    self.assertEqual(sum_op.output('Out'), ['sum.out'])\n    self.assertEqual(sum_op.idx, 0)\n    self.assertEqual(sum_out.op, sum_op)",
            "def test_mult_input(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    program = Program()\n    block = program.current_block()\n    sum_x1 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x1')\n    sum_x2 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x2')\n    sum_x3 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x3')\n    sum_out = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.out')\n    sum_op = block.append_op(type='sum', inputs={'X': [sum_x1, sum_x2, sum_x3]}, outputs={'Out': sum_out})\n    self.assertEqual(sum_op.type, 'sum')\n    self.assertEqual(sum_op.input_names, ['X'])\n    self.assertEqual(sum_op.input('X'), ['sum.x1', 'sum.x2', 'sum.x3'])\n    self.assertEqual(sum_op.output_names, ['Out'])\n    self.assertEqual(sum_op.output('Out'), ['sum.out'])\n    self.assertEqual(sum_op.idx, 0)\n    self.assertEqual(sum_out.op, sum_op)",
            "def test_mult_input(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    program = Program()\n    block = program.current_block()\n    sum_x1 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x1')\n    sum_x2 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x2')\n    sum_x3 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x3')\n    sum_out = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.out')\n    sum_op = block.append_op(type='sum', inputs={'X': [sum_x1, sum_x2, sum_x3]}, outputs={'Out': sum_out})\n    self.assertEqual(sum_op.type, 'sum')\n    self.assertEqual(sum_op.input_names, ['X'])\n    self.assertEqual(sum_op.input('X'), ['sum.x1', 'sum.x2', 'sum.x3'])\n    self.assertEqual(sum_op.output_names, ['Out'])\n    self.assertEqual(sum_op.output('Out'), ['sum.out'])\n    self.assertEqual(sum_op.idx, 0)\n    self.assertEqual(sum_out.op, sum_op)",
            "def test_mult_input(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    program = Program()\n    block = program.current_block()\n    sum_x1 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x1')\n    sum_x2 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x2')\n    sum_x3 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x3')\n    sum_out = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.out')\n    sum_op = block.append_op(type='sum', inputs={'X': [sum_x1, sum_x2, sum_x3]}, outputs={'Out': sum_out})\n    self.assertEqual(sum_op.type, 'sum')\n    self.assertEqual(sum_op.input_names, ['X'])\n    self.assertEqual(sum_op.input('X'), ['sum.x1', 'sum.x2', 'sum.x3'])\n    self.assertEqual(sum_op.output_names, ['Out'])\n    self.assertEqual(sum_op.output('Out'), ['sum.out'])\n    self.assertEqual(sum_op.idx, 0)\n    self.assertEqual(sum_out.op, sum_op)",
            "def test_mult_input(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    program = Program()\n    block = program.current_block()\n    sum_x1 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x1')\n    sum_x2 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x2')\n    sum_x3 = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.x3')\n    sum_out = block.create_var(dtype='int', shape=[3, 4], lod_level=0, name='sum.out')\n    sum_op = block.append_op(type='sum', inputs={'X': [sum_x1, sum_x2, sum_x3]}, outputs={'Out': sum_out})\n    self.assertEqual(sum_op.type, 'sum')\n    self.assertEqual(sum_op.input_names, ['X'])\n    self.assertEqual(sum_op.input('X'), ['sum.x1', 'sum.x2', 'sum.x3'])\n    self.assertEqual(sum_op.output_names, ['Out'])\n    self.assertEqual(sum_op.output('Out'), ['sum.out'])\n    self.assertEqual(sum_op.idx, 0)\n    self.assertEqual(sum_out.op, sum_op)"
        ]
    }
]