[
    {
        "func_name": "DirectProduct",
        "original": "def DirectProduct(*groups):\n    \"\"\"\n    Returns the direct product of several groups as a permutation group.\n\n    Explanation\n    ===========\n\n    This is implemented much like the __mul__ procedure for taking the direct\n    product of two permutation groups, but the idea of shifting the\n    generators is realized in the case of an arbitrary number of groups.\n    A call to DirectProduct(G1, G2, ..., Gn) is generally expected to be faster\n    than a call to G1*G2*...*Gn (and thus the need for this algorithm).\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.group_constructs import DirectProduct\n    >>> from sympy.combinatorics.named_groups import CyclicGroup\n    >>> C = CyclicGroup(4)\n    >>> G = DirectProduct(C, C, C)\n    >>> G.order()\n    64\n\n    See Also\n    ========\n\n    sympy.combinatorics.perm_groups.PermutationGroup.__mul__\n\n    \"\"\"\n    degrees = []\n    gens_count = []\n    total_degree = 0\n    total_gens = 0\n    for group in groups:\n        current_deg = group.degree\n        current_num_gens = len(group.generators)\n        degrees.append(current_deg)\n        total_degree += current_deg\n        gens_count.append(current_num_gens)\n        total_gens += current_num_gens\n    array_gens = []\n    for i in range(total_gens):\n        array_gens.append(list(range(total_degree)))\n    current_gen = 0\n    current_deg = 0\n    for i in range(len(gens_count)):\n        for j in range(current_gen, current_gen + gens_count[i]):\n            gen = groups[i].generators[j - current_gen].array_form\n            array_gens[j][current_deg:current_deg + degrees[i]] = [x + current_deg for x in gen]\n        current_gen += gens_count[i]\n        current_deg += degrees[i]\n    perm_gens = list(uniq([_af_new(list(a)) for a in array_gens]))\n    return PermutationGroup(perm_gens, dups=False)",
        "mutated": [
            "def DirectProduct(*groups):\n    if False:\n        i = 10\n    '\\n    Returns the direct product of several groups as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    This is implemented much like the __mul__ procedure for taking the direct\\n    product of two permutation groups, but the idea of shifting the\\n    generators is realized in the case of an arbitrary number of groups.\\n    A call to DirectProduct(G1, G2, ..., Gn) is generally expected to be faster\\n    than a call to G1*G2*...*Gn (and thus the need for this algorithm).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_constructs import DirectProduct\\n    >>> from sympy.combinatorics.named_groups import CyclicGroup\\n    >>> C = CyclicGroup(4)\\n    >>> G = DirectProduct(C, C, C)\\n    >>> G.order()\\n    64\\n\\n    See Also\\n    ========\\n\\n    sympy.combinatorics.perm_groups.PermutationGroup.__mul__\\n\\n    '\n    degrees = []\n    gens_count = []\n    total_degree = 0\n    total_gens = 0\n    for group in groups:\n        current_deg = group.degree\n        current_num_gens = len(group.generators)\n        degrees.append(current_deg)\n        total_degree += current_deg\n        gens_count.append(current_num_gens)\n        total_gens += current_num_gens\n    array_gens = []\n    for i in range(total_gens):\n        array_gens.append(list(range(total_degree)))\n    current_gen = 0\n    current_deg = 0\n    for i in range(len(gens_count)):\n        for j in range(current_gen, current_gen + gens_count[i]):\n            gen = groups[i].generators[j - current_gen].array_form\n            array_gens[j][current_deg:current_deg + degrees[i]] = [x + current_deg for x in gen]\n        current_gen += gens_count[i]\n        current_deg += degrees[i]\n    perm_gens = list(uniq([_af_new(list(a)) for a in array_gens]))\n    return PermutationGroup(perm_gens, dups=False)",
            "def DirectProduct(*groups):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns the direct product of several groups as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    This is implemented much like the __mul__ procedure for taking the direct\\n    product of two permutation groups, but the idea of shifting the\\n    generators is realized in the case of an arbitrary number of groups.\\n    A call to DirectProduct(G1, G2, ..., Gn) is generally expected to be faster\\n    than a call to G1*G2*...*Gn (and thus the need for this algorithm).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_constructs import DirectProduct\\n    >>> from sympy.combinatorics.named_groups import CyclicGroup\\n    >>> C = CyclicGroup(4)\\n    >>> G = DirectProduct(C, C, C)\\n    >>> G.order()\\n    64\\n\\n    See Also\\n    ========\\n\\n    sympy.combinatorics.perm_groups.PermutationGroup.__mul__\\n\\n    '\n    degrees = []\n    gens_count = []\n    total_degree = 0\n    total_gens = 0\n    for group in groups:\n        current_deg = group.degree\n        current_num_gens = len(group.generators)\n        degrees.append(current_deg)\n        total_degree += current_deg\n        gens_count.append(current_num_gens)\n        total_gens += current_num_gens\n    array_gens = []\n    for i in range(total_gens):\n        array_gens.append(list(range(total_degree)))\n    current_gen = 0\n    current_deg = 0\n    for i in range(len(gens_count)):\n        for j in range(current_gen, current_gen + gens_count[i]):\n            gen = groups[i].generators[j - current_gen].array_form\n            array_gens[j][current_deg:current_deg + degrees[i]] = [x + current_deg for x in gen]\n        current_gen += gens_count[i]\n        current_deg += degrees[i]\n    perm_gens = list(uniq([_af_new(list(a)) for a in array_gens]))\n    return PermutationGroup(perm_gens, dups=False)",
            "def DirectProduct(*groups):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns the direct product of several groups as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    This is implemented much like the __mul__ procedure for taking the direct\\n    product of two permutation groups, but the idea of shifting the\\n    generators is realized in the case of an arbitrary number of groups.\\n    A call to DirectProduct(G1, G2, ..., Gn) is generally expected to be faster\\n    than a call to G1*G2*...*Gn (and thus the need for this algorithm).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_constructs import DirectProduct\\n    >>> from sympy.combinatorics.named_groups import CyclicGroup\\n    >>> C = CyclicGroup(4)\\n    >>> G = DirectProduct(C, C, C)\\n    >>> G.order()\\n    64\\n\\n    See Also\\n    ========\\n\\n    sympy.combinatorics.perm_groups.PermutationGroup.__mul__\\n\\n    '\n    degrees = []\n    gens_count = []\n    total_degree = 0\n    total_gens = 0\n    for group in groups:\n        current_deg = group.degree\n        current_num_gens = len(group.generators)\n        degrees.append(current_deg)\n        total_degree += current_deg\n        gens_count.append(current_num_gens)\n        total_gens += current_num_gens\n    array_gens = []\n    for i in range(total_gens):\n        array_gens.append(list(range(total_degree)))\n    current_gen = 0\n    current_deg = 0\n    for i in range(len(gens_count)):\n        for j in range(current_gen, current_gen + gens_count[i]):\n            gen = groups[i].generators[j - current_gen].array_form\n            array_gens[j][current_deg:current_deg + degrees[i]] = [x + current_deg for x in gen]\n        current_gen += gens_count[i]\n        current_deg += degrees[i]\n    perm_gens = list(uniq([_af_new(list(a)) for a in array_gens]))\n    return PermutationGroup(perm_gens, dups=False)",
            "def DirectProduct(*groups):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns the direct product of several groups as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    This is implemented much like the __mul__ procedure for taking the direct\\n    product of two permutation groups, but the idea of shifting the\\n    generators is realized in the case of an arbitrary number of groups.\\n    A call to DirectProduct(G1, G2, ..., Gn) is generally expected to be faster\\n    than a call to G1*G2*...*Gn (and thus the need for this algorithm).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_constructs import DirectProduct\\n    >>> from sympy.combinatorics.named_groups import CyclicGroup\\n    >>> C = CyclicGroup(4)\\n    >>> G = DirectProduct(C, C, C)\\n    >>> G.order()\\n    64\\n\\n    See Also\\n    ========\\n\\n    sympy.combinatorics.perm_groups.PermutationGroup.__mul__\\n\\n    '\n    degrees = []\n    gens_count = []\n    total_degree = 0\n    total_gens = 0\n    for group in groups:\n        current_deg = group.degree\n        current_num_gens = len(group.generators)\n        degrees.append(current_deg)\n        total_degree += current_deg\n        gens_count.append(current_num_gens)\n        total_gens += current_num_gens\n    array_gens = []\n    for i in range(total_gens):\n        array_gens.append(list(range(total_degree)))\n    current_gen = 0\n    current_deg = 0\n    for i in range(len(gens_count)):\n        for j in range(current_gen, current_gen + gens_count[i]):\n            gen = groups[i].generators[j - current_gen].array_form\n            array_gens[j][current_deg:current_deg + degrees[i]] = [x + current_deg for x in gen]\n        current_gen += gens_count[i]\n        current_deg += degrees[i]\n    perm_gens = list(uniq([_af_new(list(a)) for a in array_gens]))\n    return PermutationGroup(perm_gens, dups=False)",
            "def DirectProduct(*groups):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns the direct product of several groups as a permutation group.\\n\\n    Explanation\\n    ===========\\n\\n    This is implemented much like the __mul__ procedure for taking the direct\\n    product of two permutation groups, but the idea of shifting the\\n    generators is realized in the case of an arbitrary number of groups.\\n    A call to DirectProduct(G1, G2, ..., Gn) is generally expected to be faster\\n    than a call to G1*G2*...*Gn (and thus the need for this algorithm).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_constructs import DirectProduct\\n    >>> from sympy.combinatorics.named_groups import CyclicGroup\\n    >>> C = CyclicGroup(4)\\n    >>> G = DirectProduct(C, C, C)\\n    >>> G.order()\\n    64\\n\\n    See Also\\n    ========\\n\\n    sympy.combinatorics.perm_groups.PermutationGroup.__mul__\\n\\n    '\n    degrees = []\n    gens_count = []\n    total_degree = 0\n    total_gens = 0\n    for group in groups:\n        current_deg = group.degree\n        current_num_gens = len(group.generators)\n        degrees.append(current_deg)\n        total_degree += current_deg\n        gens_count.append(current_num_gens)\n        total_gens += current_num_gens\n    array_gens = []\n    for i in range(total_gens):\n        array_gens.append(list(range(total_degree)))\n    current_gen = 0\n    current_deg = 0\n    for i in range(len(gens_count)):\n        for j in range(current_gen, current_gen + gens_count[i]):\n            gen = groups[i].generators[j - current_gen].array_form\n            array_gens[j][current_deg:current_deg + degrees[i]] = [x + current_deg for x in gen]\n        current_gen += gens_count[i]\n        current_deg += degrees[i]\n    perm_gens = list(uniq([_af_new(list(a)) for a in array_gens]))\n    return PermutationGroup(perm_gens, dups=False)"
        ]
    }
]