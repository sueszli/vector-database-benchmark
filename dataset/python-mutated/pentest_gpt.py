from pentestgpt.config.chatgpt_config import ChatGPTConfig
from rich.spinner import Spinner
from pentestgpt.utils.chatgpt import ChatGPT
from pentestgpt.utils.APIs.module_import import dynamic_import
from rich.console import Console
from pentestgpt.prompts.prompt_class import PentestGPTPrompt
from pentestgpt.utils.prompt_select import prompt_select, prompt_ask
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.shortcuts import confirm
from pentestgpt.utils.task_handler import main_task_entry, mainTaskCompleter, local_task_entry, localTaskCompleter
from pentestgpt.utils.web_parser import google_search
import loguru
import time, os, textwrap, json, sys, traceback
logger = loguru.logger

def prompt_continuation(width, line_number, wrap_count):
    if False:
        while True:
            i = 10
    "\n    The continuation: display line numbers and '->' before soft wraps.\n    Notice that we can return any kind of formatted text from here.\n    The prompt continuation doesn't have to be the same width as the prompt\n    which is displayed before the first line, but in this example we choose to\n    align them. The `width` input that we receive here represents the width of\n    the prompt.\n    "
    if wrap_count > 0:
        return ' ' * (width - 3) + '-> '
    text = ('- %i - ' % (line_number + 1)).rjust(width)
    return HTML('<strong>%s</strong>') % text

class pentestGPT:
    postfix_options = {'tool': 'The input content is from a security testing tool. You need to list down all the points that are interesting to you; you should summarize it as if you are reporting to a senior penetration tester for further guidance.\n', 'user-comments': 'The input content is from user comments.\n', 'web': 'The input content is from web pages. You need to summarize the readable-contents, and list down all the points that can be interesting for penetration testing.\n', 'default': 'The user did not specify the input source. You need to summarize based on the contents.\n'}
    options_desc = {'tool': ' Paste the output of the security test tool used', 'user-comments': '', 'web': ' Paste the relevant content of a web page', 'deafult': ' Write whatever you want, the tool will handle it'}

    def __init__(self, log_dir='logs', reasoning_model='gpt-4-1106-preview', parsing_model='gpt-4-1106-preview', useAPI=True, azure=False, use_langfuse_logging=False):
        if False:
            print('Hello World!')
        self.log_dir = log_dir
        logger.add(sink=os.path.join(log_dir, 'pentestGPT.log'))
        self.save_dir = 'test_history'
        self.task_log = {}
        self.useAPI = useAPI
        self.parsing_char_window = 16000
        reasoning_model_object = dynamic_import(reasoning_model, self.log_dir, use_langfuse_logging=use_langfuse_logging)
        generation_model_object = dynamic_import(reasoning_model, self.log_dir, use_langfuse_logging=use_langfuse_logging)
        parsing_model_object = dynamic_import(parsing_model, self.log_dir, use_langfuse_logging=use_langfuse_logging)
        if useAPI is False:
            self.parsingAgent = ChatGPT(ChatGPTConfig(log_dir=self.log_dir))
            self.reasoningAgent = ChatGPT(ChatGPTConfig(model=reasoning_model, log_dir=self.log_dir))
        else:
            self.parsingAgent = parsing_model_object
            self.generationAgent = generation_model_object
            self.reasoningAgent = reasoning_model_object
        self.prompts = PentestGPTPrompt
        self.console = Console()
        self.spinner = Spinner('line', 'Processing')
        self.test_generation_session_id = None
        self.test_reasoning_session_id = None
        self.input_parsing_session_id = None
        self.chat_count = 0
        self.step_reasoning = None
        self.history = {'user': [], 'pentestGPT': [], 'reasoning': [], 'input_parsing': [], 'generation': [], 'exception': []}
        self.console.print('Welcome to pentestGPT, an automated penetration testing parser empowered by GPT.', style='bold green')
        self.console.print('The settings are: ')
        self.console.print(f' - parsing model: {parsing_model_object.name}', style='bold green')
        self.console.print(f' - reasoning model: {reasoning_model_object.name}', style='bold green')
        self.console.print(f' - use API: {useAPI}', style='bold green')
        self.console.print(f' - log directory: {log_dir}', style='bold green')

    def log_conversation(self, source, text):
        if False:
            print('Hello World!')
        '\n        append the conversation into the history\n\n        Parameters:\n        ----------\n        source: str\n            the source of the conversation\n        text: str\n            the content of the conversation\n        '
        timestamp = time.time()
        if source not in self.history.keys():
            source = 'exception'
        self.history[source].append((timestamp, text))

    def refresh_session(self):
        if False:
            while True:
                i = 10
        if self.useAPI:
            self.console.print("You're using API mode, so no need to refresh the session.")
            self.log_conversation('pentestGPT', "You're using API mode, so no need to refresh the session.")
        else:
            self.console.print('Please ensure that you put the curl command into `config/chatgpt_config_curl.txt`', style='bold green')
            self.log_conversation('pentestGPT', 'Please ensure that you put the curl command into `config/chatgpt_config_curl.txt`')
            input('Press Enter to continue...')
            self.parsingAgent.refresh()
            self.reasoningAgent.refresh()
            self.console.print('Session refreshed. If you receive the same session refresh request, please refresh the ChatGPT page and paste the new curl request again.', style='bold green')
            self.log_conversation('pentestGPT', 'Session refreshed.')
            return 'Session refreshed.'

    def _feed_init_prompts(self):
        if False:
            for i in range(10):
                print('nop')
        init_description = prompt_ask('Please describe the penetration testing task in one line, including the target IP, task type, etc.\n> ', multiline=False)
        self.log_conversation('user', init_description)
        self.task_log['task description'] = init_description
        prefixed_init_description = self.prompts.task_description + init_description
        with self.console.status('[bold green] Constructing Initial Penetration Testing Tree...') as status:
            _reasoning_response = self.reasoningAgent.send_message(prefixed_init_description, self.test_reasoning_session_id)
        with self.console.status('[bold green] Generating Initial Task') as status:
            _generation_response = self.generationAgent.send_message(self.prompts.todo_to_command + _reasoning_response, self.test_generation_session_id)
        response = _reasoning_response + '\n' + _generation_response
        self.console.print('PentestGPT output: ', style='bold green')
        self.console.print(response)
        self.log_conversation('PentestGPT', 'PentestGPT output:' + response)

    def initialize(self, previous_session_ids=None):
        if False:
            i = 10
            return i + 15
        if previous_session_ids is not None and self.useAPI is False:
            self.test_generation_session_id = previous_session_ids.get('test_generation', None)
            self.test_reasoning_session_id = previous_session_ids.get('reasoning', None)
            self.input_parsing_session_id = previous_session_ids.get('parsing', None)
            print(f'Previous session ids: {str(previous_session_ids)}')
            print(f'Test generation session id: {str(self.test_generation_session_id)}')
            print(f'Test reasoning session id: {str(self.test_reasoning_session_id)}')
            print(f'Input parsing session id: {str(self.input_parsing_session_id)}')
            print('-----------------')
            self.task_log = previous_session_ids.get('task_log', {})
            self.console.print(f'Task log: {str(self.task_log)}', style='bold green')
            print('You may use discussion function to remind yourself of the task.')
            if self.test_generation_session_id is None or self.test_reasoning_session_id is None or self.input_parsing_session_id is None:
                self.console.print('[bold red] Error: the previous session ids are not valid. Loading new sessions')
                self.initialize()
        else:
            with self.console.status('[bold green] Initialize ChatGPT Sessions...') as status:
                try:
                    (text_0, self.test_generation_session_id) = self.generationAgent.send_new_message(self.prompts.generation_session_init)
                    (text_1, self.test_reasoning_session_id) = self.reasoningAgent.send_new_message(self.prompts.reasoning_session_init)
                    (text_2, self.input_parsing_session_id) = self.parsingAgent.send_new_message(self.prompts.input_parsing_init)
                except Exception as e:
                    logger.error(e)
            self.console.print('- ChatGPT Sessions Initialized.', style='bold green')
            self._feed_init_prompts()

    def reasoning_handler(self, text) -> str:
        if False:
            for i in range(10):
                print('nop')
        if len(text) > self.parsing_char_window:
            text = self.input_parsing_handler(text)
        '\n        # pass the information to reasoning_handler and obtain the results\n        response = self.reasoningAgent.send_message(\n            self.prompts.process_results + text, self.test_reasoning_session_id\n        )\n        # log the conversation\n        '
        _updated_ptt_response = self.reasoningAgent.send_message(self.prompts.process_results + text, self.test_reasoning_session_id)
        _task_selection_response = self.reasoningAgent.send_message(self.prompts.process_results_task_selection, self.test_reasoning_session_id)
        response = _updated_ptt_response + _task_selection_response
        self.log_conversation('reasoning', response)
        return response

    def input_parsing_handler(self, text, source=None) -> str:
        if False:
            for i in range(10):
                print('nop')
        prefix = 'Please summarize the following input. '
        if source is not None and source in self.postfix_options.keys():
            prefix += self.postfix_options[source]
        text = text.replace('\r', ' ').replace('\n', ' ')
        wrapped_text = textwrap.fill(text, 8000)
        wrapped_inputs = wrapped_text.split('\n')
        summarized_content = ''
        for wrapped_input in wrapped_inputs:
            word_limit = f'Please ensure that the input is less than {8000 / len(wrapped_inputs)} words.\n'
            summarized_content += self.parsingAgent.send_message(prefix + word_limit + wrapped_input, self.input_parsing_session_id)
        self.log_conversation('input_parsing', summarized_content)
        return summarized_content

    def test_generation_handler(self, text):
        if False:
            print('Hello World!')
        response = self.generationAgent.send_message(text, self.test_generation_session_id)
        self.log_conversation('generation', response)
        return response

    def local_input_handler(self) -> str:
        if False:
            print('Hello World!')
        "\n        Request for user's input to handle the local task\n        "
        local_task_response = ''
        self.chat_count += 1
        local_request_option = local_task_entry()
        self.log_conversation('user', local_request_option)
        if local_request_option == 'help':
            print(localTaskCompleter().task_details)
        elif local_request_option == 'discuss':
            self.console.print('Please share your findings and questions with PentestGPT.')
            self.log_conversation('pentestGPT', 'Please share your findings and questions with PentestGPT. (End with <shift + right-arrow>)')
            user_input = prompt_ask('Your input: ', multiline=True)
            self.log_conversation('user', user_input)
            with self.console.status('[bold green] PentestGPT Thinking...') as status:
                local_task_response = self.test_generation_handler(self.prompts.local_task_prefix + user_input)
            self.console.print('PentestGPT:\n', style='bold green')
            self.console.print(local_task_response + '\n', style='yellow')
            self.log_conversation('pentestGPT', local_task_response)
        elif local_request_option == 'brainstorm':
            self.console.print('Please share your concerns and questions with PentestGPT.')
            self.log_conversation('pentestGPT', 'Please share your concerns and questions with PentestGPT. End with <shift + right-arrow>)')
            user_input = prompt_ask('Your input: ', multiline=True)
            self.log_conversation('user', user_input)
            with self.console.status('[bold green] PentestGPT Thinking...') as status:
                local_task_response = self.test_generation_handler(self.prompts.local_task_brainstorm + user_input)
            self.console.print('PentestGPT:\n', style='bold green')
            self.console.print(local_task_response + '\n', style='yellow')
            self.log_conversation('pentestGPT', local_task_response)
        elif local_request_option == 'google':
            self.console.print('Please enter your search query. PentestGPT will summarize the info from google. (End with <shift + right-arrow>) ', style='bold green')
            self.log_conversation('pentestGPT', 'Please enter your search query. PentestGPT will summarize the info from google.')
            user_input = prompt_ask('Your input: ', multiline=False)
            self.log_conversation('user', user_input)
            with self.console.status('[bold green] PentestGPT Thinking...') as status:
                result: dict = google_search(user_input, 5)
                local_task_response = 'Google search results:\n' + 'still under development.'
            self.console.print(local_task_response + '\n', style='yellow')
            self.log_conversation('pentestGPT', local_task_response)
            return local_task_response
        elif local_request_option == 'continue':
            self.console.print('Exit the local task and continue the main task.')
            self.log_conversation('pentestGPT', 'Exit the local task and continue the main task.')
            local_task_response = 'continue'
        return local_task_response

    def input_handler(self) -> str:
        if False:
            print('Hello World!')
        "\n        Request for user's input to:\n            (1) input test results,\n            (2) ask for todos,\n            (3) input other information (discuss),\n            (4) google.\n            (4) end.\n        The design details are based on PentestGPT_design.md\n\n        Return\n        -----\n        response: str\n            The response from the chatGPT model.\n        "
        self.chat_count += 1
        request_option = main_task_entry()
        self.log_conversation('user', request_option)
        if not self.useAPI:
            conversation_history = self.parsingAgent.get_conversation_history()
            while conversation_history is None:
                self.refresh_session()
                conversation_history = self.parsingAgent.get_conversation_history()
        if request_option == 'help':
            print(mainTaskCompleter().task_details)
        if request_option == 'next':
            options = list(self.postfix_options.keys())
            opt_desc = list(self.options_desc.values())
            value_list = [(i, HTML(f'<style fg="cyan">{options[i]}</style><style fg="LightSeaGreen">{opt_desc[i]}</style>')) for i in range(len(options))]
            source = prompt_select(title='Please choose the source of the information.', values=value_list)
            self.console.print('Your input: (End with <shift + right-arrow>)', style='bold green')
            user_input = prompt_ask('> ', multiline=True)
            self.log_conversation('user', f'Source: {options[int(source)]}' + '\n' + user_input)
            with self.console.status('[bold green] PentestGPT Thinking...') as status:
                parsed_input = self.input_parsing_handler(user_input, source=options[int(source)])
                reasoning_response = self.reasoning_handler(parsed_input)
                self.step_reasoning_response = reasoning_response
            self.console.print('Based on the analysis, the following tasks are recommended:', style='bold green')
            self.console.print(reasoning_response + '\n')
            self.log_conversation('pentestGPT', 'Based on the analysis, the following tasks are recommended:' + reasoning_response)
            response = reasoning_response
        elif request_option == 'more':
            self.log_conversation('user', 'more')
            if not hasattr(self, 'step_reasoning_response'):
                self.console.print('You have not initialized the task yet. Please perform the basic testing following `next` option.', style='bold red')
                response = 'You have not initialized the task yet. Please perform the basic testing following `next` option.'
                self.log_conversation('pentestGPT', response)
                return response
            self.console.print('PentestGPT will generate more test details, and enter the sub-task generation mode. (Pressing Enter to continue)', style='bold green')
            self.log_conversation('pentestGPT', 'PentestGPT will generate more test details, and enter the sub-task generation mode.')
            input()
            with self.console.status('[bold green] PentestGPT Thinking...') as status:
                generation_response = self.test_generation_handler(self.step_reasoning_response)
                _local_init_response = self.test_generation_handler(self.prompts.local_task_init)
            self.console.print('Below are the further details.', style='bold green')
            self.console.print(generation_response + '\n')
            response = generation_response
            self.log_conversation('pentestGPT', response)
            while True:
                local_task_response = self.local_input_handler()
                if local_task_response == 'continue':
                    break
        elif request_option == 'todo':
            self.log_conversation('user', 'todo')
            with self.console.status('[bold green] PentestGPT Thinking...') as status:
                reasoning_response = self.reasoning_handler(self.prompts.ask_todo)
                message = self.prompts.todo_to_command + '\n' + reasoning_response
                generation_response = self.test_generation_handler(message)
            self.console.print('Based on the analysis, the following tasks are recommended:', style='bold green')
            self.console.print(reasoning_response + '\n')
            self.console.print('You can follow the instructions below to complete the tasks.', style='bold green')
            self.console.print(generation_response + '\n')
            response = reasoning_response
            self.log_conversation('pentestGPT', 'Based on the analysis, the following tasks are recommended:' + response + '\n' + 'You can follow the instructions below to complete the tasks.' + generation_response)
        elif request_option == 'discuss':
            self.console.print('Please share your thoughts/questions with PentestGPT. (End with <shift + right-arrow>) ')
            self.log_conversation('pentestGPT', 'Please share your thoughts/questions with PentestGPT.')
            user_input = prompt_ask('Your input: ', multiline=True)
            self.log_conversation('user', user_input)
            with self.console.status('[bold green] PentestGPT Thinking...') as status:
                response = self.reasoning_handler(self.prompts.discussion + user_input)
            self.console.print('PentestGPT:\n', style='bold green')
            self.console.print(response + '\n', style='yellow')
            self.log_conversation('pentestGPT', response)
        elif request_option == 'google':
            self.console.print('Please enter your search query. PentestGPT will summarize the info from google. (End with <shift + right-arrow>) ', style='bold green')
            self.log_conversation('pentestGPT', 'Please enter your search query. PentestGPT will summarize the info from google.')
            user_input = prompt_ask('Your input: ', multiline=False)
            self.log_conversation('user', user_input)
            with self.console.status('[bold green] PentestGPT Thinking...') as status:
                result: dict = google_search(user_input, 5)
                response = 'Google search results:\n' + 'still under development.'
            self.console.print(response + '\n', style='yellow')
            self.log_conversation('pentestGPT', response)
            return response
        elif request_option == 'quit':
            response = False
            self.console.print('Thank you for using PentestGPT!', style='bold green')
            self.log_conversation('pentestGPT', 'Thank you for using PentestGPT!')
        else:
            self.console.print('Please key in the correct options.', style='bold red')
            self.log_conversation('pentestGPT', 'Please key in the correct options.')
            response = 'Please key in the correct options.'
        return response

    def save_session(self):
        if False:
            print('Hello World!')
        '\n        Save the current session for next round of usage.\n        The test information is saved in the directory `./test_history`\n        '
        self.console.print('Before you quit, you may want to save the current session.', style='bold green')
        save_name = prompt_ask('Please enter the name of the current session. (Default with current timestamp)\n> ', multiline=False)
        if save_name == '':
            save_name = str(time.time())
        with open(os.path.join(os.path.realpath(os.path.dirname(__file__)), os.pardir, os.pardir, self.save_dir, save_name), 'w') as f:
            session_ids = {'reasoning': self.test_reasoning_session_id, 'test_generation': self.test_generation_session_id, 'parsing': self.input_parsing_session_id, 'task_log': self.task_log}
            json.dump(session_ids, f)
        self.console.print(f'The current session is saved as {save_name}', style='bold green')
        return

    def _preload_session(self) -> dict:
        if False:
            i = 10
            return i + 15
        '\n        Preload the session from the save directory.\n\n        Returns:\n            dict: the session ids for the three sessions.\n            None if no previous session is found.\n        '
        if (continue_from_previous := confirm('Do you want to continue from previous session?')):
            filenames = os.listdir(os.path.join(os.path.realpath(os.path.dirname(__file__)), os.pardir, os.pardir, self.save_dir))
            if len(filenames) == 0:
                print('No previous session found. Please start a new session.')
                return None
            else:
                print('Please select the previous session by its index (integer):')
                for (i, filename) in enumerate(filenames):
                    print(f'{str(i)}. {filename}')
                try:
                    previous_testing_name = filenames[int(input('Please key in your option (integer): '))]
                    print(f'You selected: {previous_testing_name}')
                except ValueError as e:
                    print('You input an invalid option. Will start a new session.')
                    return None
        elif continue_from_previous is False:
            return None
        else:
            print('You input an invalid option. Will start a new session.')
            return None
        if previous_testing_name is not None:
            try:
                with open(os.path.join(os.path.realpath(os.path.dirname(__file__)), os.pardir, os.pardir, self.save_dir, previous_testing_name), 'r') as f:
                    return json.load(f)
            except Exception as e:
                print('Error when loading the previous session. The file name is not correct')
                print(e)
                previous_testing_name = None
                return None

    def main(self):
        if False:
            for i in range(10):
                print('nop')
        '\n        The main function of pentestGPT. The design is based on PentestGPT_design.md\n        '
        loaded_ids = self._preload_session()
        self.initialize(previous_session_ids=loaded_ids)
        while True:
            try:
                result = self.input_handler()
                self.console.print('-----------------------------------------', style='bold white')
                if not result:
                    break
            except Exception as e:
                self.log_conversation('exception', str(e))
                self.console.print(f'Exception: {str(e)}', style='bold red')
                (exc_type, exc_obj, exc_tb) = sys.exc_info()
                fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
                self.console.print('Exception details are below. You may submit an issue on github and paste the error trace', style='bold green')
                print(traceback.format_exc())
                break
        timestamp = time.time()
        log_name = f'pentestGPT_log_{str(timestamp)}.txt'
        log_path = os.path.join(self.log_dir, log_name)
        with open(log_path, 'w') as f:
            json.dump(self.history, f)
        self.save_session()
if __name__ == '__main__':
    pentestGPT = pentestGPT()
    pentestGPT.main()