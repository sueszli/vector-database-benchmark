[
    {
        "func_name": "__init__",
        "original": "def __init__(self, model_load_func: Callable[[str], Any], self_arg: Any, max_num_models_per_replica: int):\n    \"\"\"Initialize the model multiplexer.\n        Args:\n            model_load_func: the model load async function.\n            self_arg: self argument when model_load_func is class method.\n            max_num_models_per_replica: the maximum number of models to be loaded on the\n                current replica. If it is -1, there is no limit for the number of models\n                per replica.\n        \"\"\"\n    ServeUsageTag.MULTIPLEXED_API_USED.record('1')\n    self.models = OrderedDict()\n    self._func: Callable = model_load_func\n    self.self_arg: Any = self_arg\n    self.max_num_models_per_replica: int = max_num_models_per_replica\n    self.model_load_latency_ms = metrics.Histogram('serve_multiplexed_model_load_latency_ms', description='The time it takes to load a model.', boundaries=DEFAULT_LATENCY_BUCKET_MS)\n    self.model_unload_latency_ms = metrics.Histogram('serve_multiplexed_model_unload_latency_ms', description='The time it takes to unload a model.', boundaries=DEFAULT_LATENCY_BUCKET_MS)\n    self.num_models_gauge = metrics.Gauge('serve_num_multiplexed_models', description='The number of models loaded on the current replica.')\n    self.registered_model_gauge = metrics.Gauge('serve_registered_multiplexed_model_id', description='The model id registered on the current replica.', tag_keys=('model_id',))\n    self.get_model_requests_counter = metrics.Counter('serve_multiplexed_get_model_requests_counter', description='The counter for get model requests on the current replica.')\n    self.models_unload_counter = metrics.Counter('serve_multiplexed_models_unload_counter', description='The counter for unloaded models on the current replica.')\n    self.models_load_counter = metrics.Counter('serve_multiplexed_models_load_counter', description='The counter for loaded models on the current replica.')\n    context = _get_internal_replica_context()\n    if context is None:\n        raise RuntimeError('Fail to retrieve serve replica context, the model multiplexer ', 'can only be used within `Deployment`.')\n    self._app_name: str = context.app_name\n    self._deployment_name: str = context.deployment\n    self._replica_tag: str = context.replica_tag\n    self._push_multiplexed_replica_info: bool = False\n    self._model_cache_lock = asyncio.Lock()\n    self._model_load_tasks: Set[str] = set()\n    self.metrics_pusher = MetricsPusher()\n    self.metrics_pusher.register_task(self._push_model_ids_info, PUSH_MULTIPLEXED_MODEL_IDS_INTERVAL_S)\n    self.metrics_pusher.start()",
        "mutated": [
            "def __init__(self, model_load_func: Callable[[str], Any], self_arg: Any, max_num_models_per_replica: int):\n    if False:\n        i = 10\n    'Initialize the model multiplexer.\\n        Args:\\n            model_load_func: the model load async function.\\n            self_arg: self argument when model_load_func is class method.\\n            max_num_models_per_replica: the maximum number of models to be loaded on the\\n                current replica. If it is -1, there is no limit for the number of models\\n                per replica.\\n        '\n    ServeUsageTag.MULTIPLEXED_API_USED.record('1')\n    self.models = OrderedDict()\n    self._func: Callable = model_load_func\n    self.self_arg: Any = self_arg\n    self.max_num_models_per_replica: int = max_num_models_per_replica\n    self.model_load_latency_ms = metrics.Histogram('serve_multiplexed_model_load_latency_ms', description='The time it takes to load a model.', boundaries=DEFAULT_LATENCY_BUCKET_MS)\n    self.model_unload_latency_ms = metrics.Histogram('serve_multiplexed_model_unload_latency_ms', description='The time it takes to unload a model.', boundaries=DEFAULT_LATENCY_BUCKET_MS)\n    self.num_models_gauge = metrics.Gauge('serve_num_multiplexed_models', description='The number of models loaded on the current replica.')\n    self.registered_model_gauge = metrics.Gauge('serve_registered_multiplexed_model_id', description='The model id registered on the current replica.', tag_keys=('model_id',))\n    self.get_model_requests_counter = metrics.Counter('serve_multiplexed_get_model_requests_counter', description='The counter for get model requests on the current replica.')\n    self.models_unload_counter = metrics.Counter('serve_multiplexed_models_unload_counter', description='The counter for unloaded models on the current replica.')\n    self.models_load_counter = metrics.Counter('serve_multiplexed_models_load_counter', description='The counter for loaded models on the current replica.')\n    context = _get_internal_replica_context()\n    if context is None:\n        raise RuntimeError('Fail to retrieve serve replica context, the model multiplexer ', 'can only be used within `Deployment`.')\n    self._app_name: str = context.app_name\n    self._deployment_name: str = context.deployment\n    self._replica_tag: str = context.replica_tag\n    self._push_multiplexed_replica_info: bool = False\n    self._model_cache_lock = asyncio.Lock()\n    self._model_load_tasks: Set[str] = set()\n    self.metrics_pusher = MetricsPusher()\n    self.metrics_pusher.register_task(self._push_model_ids_info, PUSH_MULTIPLEXED_MODEL_IDS_INTERVAL_S)\n    self.metrics_pusher.start()",
            "def __init__(self, model_load_func: Callable[[str], Any], self_arg: Any, max_num_models_per_replica: int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialize the model multiplexer.\\n        Args:\\n            model_load_func: the model load async function.\\n            self_arg: self argument when model_load_func is class method.\\n            max_num_models_per_replica: the maximum number of models to be loaded on the\\n                current replica. If it is -1, there is no limit for the number of models\\n                per replica.\\n        '\n    ServeUsageTag.MULTIPLEXED_API_USED.record('1')\n    self.models = OrderedDict()\n    self._func: Callable = model_load_func\n    self.self_arg: Any = self_arg\n    self.max_num_models_per_replica: int = max_num_models_per_replica\n    self.model_load_latency_ms = metrics.Histogram('serve_multiplexed_model_load_latency_ms', description='The time it takes to load a model.', boundaries=DEFAULT_LATENCY_BUCKET_MS)\n    self.model_unload_latency_ms = metrics.Histogram('serve_multiplexed_model_unload_latency_ms', description='The time it takes to unload a model.', boundaries=DEFAULT_LATENCY_BUCKET_MS)\n    self.num_models_gauge = metrics.Gauge('serve_num_multiplexed_models', description='The number of models loaded on the current replica.')\n    self.registered_model_gauge = metrics.Gauge('serve_registered_multiplexed_model_id', description='The model id registered on the current replica.', tag_keys=('model_id',))\n    self.get_model_requests_counter = metrics.Counter('serve_multiplexed_get_model_requests_counter', description='The counter for get model requests on the current replica.')\n    self.models_unload_counter = metrics.Counter('serve_multiplexed_models_unload_counter', description='The counter for unloaded models on the current replica.')\n    self.models_load_counter = metrics.Counter('serve_multiplexed_models_load_counter', description='The counter for loaded models on the current replica.')\n    context = _get_internal_replica_context()\n    if context is None:\n        raise RuntimeError('Fail to retrieve serve replica context, the model multiplexer ', 'can only be used within `Deployment`.')\n    self._app_name: str = context.app_name\n    self._deployment_name: str = context.deployment\n    self._replica_tag: str = context.replica_tag\n    self._push_multiplexed_replica_info: bool = False\n    self._model_cache_lock = asyncio.Lock()\n    self._model_load_tasks: Set[str] = set()\n    self.metrics_pusher = MetricsPusher()\n    self.metrics_pusher.register_task(self._push_model_ids_info, PUSH_MULTIPLEXED_MODEL_IDS_INTERVAL_S)\n    self.metrics_pusher.start()",
            "def __init__(self, model_load_func: Callable[[str], Any], self_arg: Any, max_num_models_per_replica: int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialize the model multiplexer.\\n        Args:\\n            model_load_func: the model load async function.\\n            self_arg: self argument when model_load_func is class method.\\n            max_num_models_per_replica: the maximum number of models to be loaded on the\\n                current replica. If it is -1, there is no limit for the number of models\\n                per replica.\\n        '\n    ServeUsageTag.MULTIPLEXED_API_USED.record('1')\n    self.models = OrderedDict()\n    self._func: Callable = model_load_func\n    self.self_arg: Any = self_arg\n    self.max_num_models_per_replica: int = max_num_models_per_replica\n    self.model_load_latency_ms = metrics.Histogram('serve_multiplexed_model_load_latency_ms', description='The time it takes to load a model.', boundaries=DEFAULT_LATENCY_BUCKET_MS)\n    self.model_unload_latency_ms = metrics.Histogram('serve_multiplexed_model_unload_latency_ms', description='The time it takes to unload a model.', boundaries=DEFAULT_LATENCY_BUCKET_MS)\n    self.num_models_gauge = metrics.Gauge('serve_num_multiplexed_models', description='The number of models loaded on the current replica.')\n    self.registered_model_gauge = metrics.Gauge('serve_registered_multiplexed_model_id', description='The model id registered on the current replica.', tag_keys=('model_id',))\n    self.get_model_requests_counter = metrics.Counter('serve_multiplexed_get_model_requests_counter', description='The counter for get model requests on the current replica.')\n    self.models_unload_counter = metrics.Counter('serve_multiplexed_models_unload_counter', description='The counter for unloaded models on the current replica.')\n    self.models_load_counter = metrics.Counter('serve_multiplexed_models_load_counter', description='The counter for loaded models on the current replica.')\n    context = _get_internal_replica_context()\n    if context is None:\n        raise RuntimeError('Fail to retrieve serve replica context, the model multiplexer ', 'can only be used within `Deployment`.')\n    self._app_name: str = context.app_name\n    self._deployment_name: str = context.deployment\n    self._replica_tag: str = context.replica_tag\n    self._push_multiplexed_replica_info: bool = False\n    self._model_cache_lock = asyncio.Lock()\n    self._model_load_tasks: Set[str] = set()\n    self.metrics_pusher = MetricsPusher()\n    self.metrics_pusher.register_task(self._push_model_ids_info, PUSH_MULTIPLEXED_MODEL_IDS_INTERVAL_S)\n    self.metrics_pusher.start()",
            "def __init__(self, model_load_func: Callable[[str], Any], self_arg: Any, max_num_models_per_replica: int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialize the model multiplexer.\\n        Args:\\n            model_load_func: the model load async function.\\n            self_arg: self argument when model_load_func is class method.\\n            max_num_models_per_replica: the maximum number of models to be loaded on the\\n                current replica. If it is -1, there is no limit for the number of models\\n                per replica.\\n        '\n    ServeUsageTag.MULTIPLEXED_API_USED.record('1')\n    self.models = OrderedDict()\n    self._func: Callable = model_load_func\n    self.self_arg: Any = self_arg\n    self.max_num_models_per_replica: int = max_num_models_per_replica\n    self.model_load_latency_ms = metrics.Histogram('serve_multiplexed_model_load_latency_ms', description='The time it takes to load a model.', boundaries=DEFAULT_LATENCY_BUCKET_MS)\n    self.model_unload_latency_ms = metrics.Histogram('serve_multiplexed_model_unload_latency_ms', description='The time it takes to unload a model.', boundaries=DEFAULT_LATENCY_BUCKET_MS)\n    self.num_models_gauge = metrics.Gauge('serve_num_multiplexed_models', description='The number of models loaded on the current replica.')\n    self.registered_model_gauge = metrics.Gauge('serve_registered_multiplexed_model_id', description='The model id registered on the current replica.', tag_keys=('model_id',))\n    self.get_model_requests_counter = metrics.Counter('serve_multiplexed_get_model_requests_counter', description='The counter for get model requests on the current replica.')\n    self.models_unload_counter = metrics.Counter('serve_multiplexed_models_unload_counter', description='The counter for unloaded models on the current replica.')\n    self.models_load_counter = metrics.Counter('serve_multiplexed_models_load_counter', description='The counter for loaded models on the current replica.')\n    context = _get_internal_replica_context()\n    if context is None:\n        raise RuntimeError('Fail to retrieve serve replica context, the model multiplexer ', 'can only be used within `Deployment`.')\n    self._app_name: str = context.app_name\n    self._deployment_name: str = context.deployment\n    self._replica_tag: str = context.replica_tag\n    self._push_multiplexed_replica_info: bool = False\n    self._model_cache_lock = asyncio.Lock()\n    self._model_load_tasks: Set[str] = set()\n    self.metrics_pusher = MetricsPusher()\n    self.metrics_pusher.register_task(self._push_model_ids_info, PUSH_MULTIPLEXED_MODEL_IDS_INTERVAL_S)\n    self.metrics_pusher.start()",
            "def __init__(self, model_load_func: Callable[[str], Any], self_arg: Any, max_num_models_per_replica: int):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialize the model multiplexer.\\n        Args:\\n            model_load_func: the model load async function.\\n            self_arg: self argument when model_load_func is class method.\\n            max_num_models_per_replica: the maximum number of models to be loaded on the\\n                current replica. If it is -1, there is no limit for the number of models\\n                per replica.\\n        '\n    ServeUsageTag.MULTIPLEXED_API_USED.record('1')\n    self.models = OrderedDict()\n    self._func: Callable = model_load_func\n    self.self_arg: Any = self_arg\n    self.max_num_models_per_replica: int = max_num_models_per_replica\n    self.model_load_latency_ms = metrics.Histogram('serve_multiplexed_model_load_latency_ms', description='The time it takes to load a model.', boundaries=DEFAULT_LATENCY_BUCKET_MS)\n    self.model_unload_latency_ms = metrics.Histogram('serve_multiplexed_model_unload_latency_ms', description='The time it takes to unload a model.', boundaries=DEFAULT_LATENCY_BUCKET_MS)\n    self.num_models_gauge = metrics.Gauge('serve_num_multiplexed_models', description='The number of models loaded on the current replica.')\n    self.registered_model_gauge = metrics.Gauge('serve_registered_multiplexed_model_id', description='The model id registered on the current replica.', tag_keys=('model_id',))\n    self.get_model_requests_counter = metrics.Counter('serve_multiplexed_get_model_requests_counter', description='The counter for get model requests on the current replica.')\n    self.models_unload_counter = metrics.Counter('serve_multiplexed_models_unload_counter', description='The counter for unloaded models on the current replica.')\n    self.models_load_counter = metrics.Counter('serve_multiplexed_models_load_counter', description='The counter for loaded models on the current replica.')\n    context = _get_internal_replica_context()\n    if context is None:\n        raise RuntimeError('Fail to retrieve serve replica context, the model multiplexer ', 'can only be used within `Deployment`.')\n    self._app_name: str = context.app_name\n    self._deployment_name: str = context.deployment\n    self._replica_tag: str = context.replica_tag\n    self._push_multiplexed_replica_info: bool = False\n    self._model_cache_lock = asyncio.Lock()\n    self._model_load_tasks: Set[str] = set()\n    self.metrics_pusher = MetricsPusher()\n    self.metrics_pusher.register_task(self._push_model_ids_info, PUSH_MULTIPLEXED_MODEL_IDS_INTERVAL_S)\n    self.metrics_pusher.start()"
        ]
    },
    {
        "func_name": "_get_loading_and_loaded_model_ids",
        "original": "def _get_loading_and_loaded_model_ids(self) -> List[str]:\n    \"\"\"Get the model IDs of the loaded models & loading models in the replica.\n        This is to push the model id information early to the controller, so that\n        requests can be routed to the replica.\n        \"\"\"\n    models_list = set(self.models.keys())\n    models_list.update(self._model_load_tasks)\n    return list(models_list)",
        "mutated": [
            "def _get_loading_and_loaded_model_ids(self) -> List[str]:\n    if False:\n        i = 10\n    'Get the model IDs of the loaded models & loading models in the replica.\\n        This is to push the model id information early to the controller, so that\\n        requests can be routed to the replica.\\n        '\n    models_list = set(self.models.keys())\n    models_list.update(self._model_load_tasks)\n    return list(models_list)",
            "def _get_loading_and_loaded_model_ids(self) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get the model IDs of the loaded models & loading models in the replica.\\n        This is to push the model id information early to the controller, so that\\n        requests can be routed to the replica.\\n        '\n    models_list = set(self.models.keys())\n    models_list.update(self._model_load_tasks)\n    return list(models_list)",
            "def _get_loading_and_loaded_model_ids(self) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get the model IDs of the loaded models & loading models in the replica.\\n        This is to push the model id information early to the controller, so that\\n        requests can be routed to the replica.\\n        '\n    models_list = set(self.models.keys())\n    models_list.update(self._model_load_tasks)\n    return list(models_list)",
            "def _get_loading_and_loaded_model_ids(self) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get the model IDs of the loaded models & loading models in the replica.\\n        This is to push the model id information early to the controller, so that\\n        requests can be routed to the replica.\\n        '\n    models_list = set(self.models.keys())\n    models_list.update(self._model_load_tasks)\n    return list(models_list)",
            "def _get_loading_and_loaded_model_ids(self) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get the model IDs of the loaded models & loading models in the replica.\\n        This is to push the model id information early to the controller, so that\\n        requests can be routed to the replica.\\n        '\n    models_list = set(self.models.keys())\n    models_list.update(self._model_load_tasks)\n    return list(models_list)"
        ]
    },
    {
        "func_name": "_push_model_ids_info",
        "original": "def _push_model_ids_info(self):\n    \"\"\"Push the multiplexed replica info to the controller.\"\"\"\n    try:\n        self.num_models_gauge.set(len(self.models))\n        for model_id in self.models:\n            self.registered_model_gauge.set(1, tags={'model_id': model_id})\n        if self._push_multiplexed_replica_info:\n            _get_global_client().record_multiplexed_replica_info(MultiplexedReplicaInfo(DeploymentID(self._deployment_name, self._app_name), self._replica_tag, self._get_loading_and_loaded_model_ids()))\n            self._push_multiplexed_replica_info = False\n    except Exception as e:\n        logger.warning(f'Failed to push the multiplexed replica info to the controller. Error: {e}')",
        "mutated": [
            "def _push_model_ids_info(self):\n    if False:\n        i = 10\n    'Push the multiplexed replica info to the controller.'\n    try:\n        self.num_models_gauge.set(len(self.models))\n        for model_id in self.models:\n            self.registered_model_gauge.set(1, tags={'model_id': model_id})\n        if self._push_multiplexed_replica_info:\n            _get_global_client().record_multiplexed_replica_info(MultiplexedReplicaInfo(DeploymentID(self._deployment_name, self._app_name), self._replica_tag, self._get_loading_and_loaded_model_ids()))\n            self._push_multiplexed_replica_info = False\n    except Exception as e:\n        logger.warning(f'Failed to push the multiplexed replica info to the controller. Error: {e}')",
            "def _push_model_ids_info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Push the multiplexed replica info to the controller.'\n    try:\n        self.num_models_gauge.set(len(self.models))\n        for model_id in self.models:\n            self.registered_model_gauge.set(1, tags={'model_id': model_id})\n        if self._push_multiplexed_replica_info:\n            _get_global_client().record_multiplexed_replica_info(MultiplexedReplicaInfo(DeploymentID(self._deployment_name, self._app_name), self._replica_tag, self._get_loading_and_loaded_model_ids()))\n            self._push_multiplexed_replica_info = False\n    except Exception as e:\n        logger.warning(f'Failed to push the multiplexed replica info to the controller. Error: {e}')",
            "def _push_model_ids_info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Push the multiplexed replica info to the controller.'\n    try:\n        self.num_models_gauge.set(len(self.models))\n        for model_id in self.models:\n            self.registered_model_gauge.set(1, tags={'model_id': model_id})\n        if self._push_multiplexed_replica_info:\n            _get_global_client().record_multiplexed_replica_info(MultiplexedReplicaInfo(DeploymentID(self._deployment_name, self._app_name), self._replica_tag, self._get_loading_and_loaded_model_ids()))\n            self._push_multiplexed_replica_info = False\n    except Exception as e:\n        logger.warning(f'Failed to push the multiplexed replica info to the controller. Error: {e}')",
            "def _push_model_ids_info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Push the multiplexed replica info to the controller.'\n    try:\n        self.num_models_gauge.set(len(self.models))\n        for model_id in self.models:\n            self.registered_model_gauge.set(1, tags={'model_id': model_id})\n        if self._push_multiplexed_replica_info:\n            _get_global_client().record_multiplexed_replica_info(MultiplexedReplicaInfo(DeploymentID(self._deployment_name, self._app_name), self._replica_tag, self._get_loading_and_loaded_model_ids()))\n            self._push_multiplexed_replica_info = False\n    except Exception as e:\n        logger.warning(f'Failed to push the multiplexed replica info to the controller. Error: {e}')",
            "def _push_model_ids_info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Push the multiplexed replica info to the controller.'\n    try:\n        self.num_models_gauge.set(len(self.models))\n        for model_id in self.models:\n            self.registered_model_gauge.set(1, tags={'model_id': model_id})\n        if self._push_multiplexed_replica_info:\n            _get_global_client().record_multiplexed_replica_info(MultiplexedReplicaInfo(DeploymentID(self._deployment_name, self._app_name), self._replica_tag, self._get_loading_and_loaded_model_ids()))\n            self._push_multiplexed_replica_info = False\n    except Exception as e:\n        logger.warning(f'Failed to push the multiplexed replica info to the controller. Error: {e}')"
        ]
    }
]