[
    {
        "func_name": "__init__",
        "original": "def __init__(self, start, goal, obstacle_list, rand_area, max_iter=200, connect_circle_dist=50.0, robot_radius=0.0):\n    super().__init__(start, goal, obstacle_list, rand_area, max_iter=max_iter, connect_circle_dist=connect_circle_dist, robot_radius=robot_radius)\n    self.target_speed = 10.0 / 3.6\n    self.yaw_th = np.deg2rad(3.0)\n    self.xy_th = 0.5\n    self.invalid_travel_ratio = 5.0",
        "mutated": [
            "def __init__(self, start, goal, obstacle_list, rand_area, max_iter=200, connect_circle_dist=50.0, robot_radius=0.0):\n    if False:\n        i = 10\n    super().__init__(start, goal, obstacle_list, rand_area, max_iter=max_iter, connect_circle_dist=connect_circle_dist, robot_radius=robot_radius)\n    self.target_speed = 10.0 / 3.6\n    self.yaw_th = np.deg2rad(3.0)\n    self.xy_th = 0.5\n    self.invalid_travel_ratio = 5.0",
            "def __init__(self, start, goal, obstacle_list, rand_area, max_iter=200, connect_circle_dist=50.0, robot_radius=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__(start, goal, obstacle_list, rand_area, max_iter=max_iter, connect_circle_dist=connect_circle_dist, robot_radius=robot_radius)\n    self.target_speed = 10.0 / 3.6\n    self.yaw_th = np.deg2rad(3.0)\n    self.xy_th = 0.5\n    self.invalid_travel_ratio = 5.0",
            "def __init__(self, start, goal, obstacle_list, rand_area, max_iter=200, connect_circle_dist=50.0, robot_radius=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__(start, goal, obstacle_list, rand_area, max_iter=max_iter, connect_circle_dist=connect_circle_dist, robot_radius=robot_radius)\n    self.target_speed = 10.0 / 3.6\n    self.yaw_th = np.deg2rad(3.0)\n    self.xy_th = 0.5\n    self.invalid_travel_ratio = 5.0",
            "def __init__(self, start, goal, obstacle_list, rand_area, max_iter=200, connect_circle_dist=50.0, robot_radius=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__(start, goal, obstacle_list, rand_area, max_iter=max_iter, connect_circle_dist=connect_circle_dist, robot_radius=robot_radius)\n    self.target_speed = 10.0 / 3.6\n    self.yaw_th = np.deg2rad(3.0)\n    self.xy_th = 0.5\n    self.invalid_travel_ratio = 5.0",
            "def __init__(self, start, goal, obstacle_list, rand_area, max_iter=200, connect_circle_dist=50.0, robot_radius=0.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__(start, goal, obstacle_list, rand_area, max_iter=max_iter, connect_circle_dist=connect_circle_dist, robot_radius=robot_radius)\n    self.target_speed = 10.0 / 3.6\n    self.yaw_th = np.deg2rad(3.0)\n    self.xy_th = 0.5\n    self.invalid_travel_ratio = 5.0"
        ]
    },
    {
        "func_name": "planning",
        "original": "def planning(self, animation=True):\n    \"\"\"\n        do planning\n\n        animation: flag for animation on or off\n        \"\"\"\n    super().planning(animation=animation)\n    path_indexs = self.get_goal_indexes()\n    (flag, x, y, yaw, v, t, a, d) = self.search_best_feasible_path(path_indexs)\n    return (flag, x, y, yaw, v, t, a, d)",
        "mutated": [
            "def planning(self, animation=True):\n    if False:\n        i = 10\n    '\\n        do planning\\n\\n        animation: flag for animation on or off\\n        '\n    super().planning(animation=animation)\n    path_indexs = self.get_goal_indexes()\n    (flag, x, y, yaw, v, t, a, d) = self.search_best_feasible_path(path_indexs)\n    return (flag, x, y, yaw, v, t, a, d)",
            "def planning(self, animation=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        do planning\\n\\n        animation: flag for animation on or off\\n        '\n    super().planning(animation=animation)\n    path_indexs = self.get_goal_indexes()\n    (flag, x, y, yaw, v, t, a, d) = self.search_best_feasible_path(path_indexs)\n    return (flag, x, y, yaw, v, t, a, d)",
            "def planning(self, animation=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        do planning\\n\\n        animation: flag for animation on or off\\n        '\n    super().planning(animation=animation)\n    path_indexs = self.get_goal_indexes()\n    (flag, x, y, yaw, v, t, a, d) = self.search_best_feasible_path(path_indexs)\n    return (flag, x, y, yaw, v, t, a, d)",
            "def planning(self, animation=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        do planning\\n\\n        animation: flag for animation on or off\\n        '\n    super().planning(animation=animation)\n    path_indexs = self.get_goal_indexes()\n    (flag, x, y, yaw, v, t, a, d) = self.search_best_feasible_path(path_indexs)\n    return (flag, x, y, yaw, v, t, a, d)",
            "def planning(self, animation=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        do planning\\n\\n        animation: flag for animation on or off\\n        '\n    super().planning(animation=animation)\n    path_indexs = self.get_goal_indexes()\n    (flag, x, y, yaw, v, t, a, d) = self.search_best_feasible_path(path_indexs)\n    return (flag, x, y, yaw, v, t, a, d)"
        ]
    },
    {
        "func_name": "search_best_feasible_path",
        "original": "def search_best_feasible_path(self, path_indexs):\n    print('Start search feasible path')\n    best_time = float('inf')\n    (fx, fy, fyaw, fv, ft, fa, fd) = (None, None, None, None, None, None, None)\n    for ind in path_indexs:\n        path = self.generate_final_course(ind)\n        (flag, x, y, yaw, v, t, a, d) = self.check_tracking_path_is_feasible(path)\n        if flag and best_time >= t[-1]:\n            print('feasible path is found')\n            best_time = t[-1]\n            (fx, fy, fyaw, fv, ft, fa, fd) = (x, y, yaw, v, t, a, d)\n    print('best time is')\n    print(best_time)\n    if fx:\n        fx.append(self.end.x)\n        fy.append(self.end.y)\n        fyaw.append(self.end.yaw)\n        return (True, fx, fy, fyaw, fv, ft, fa, fd)\n    return (False, None, None, None, None, None, None, None)",
        "mutated": [
            "def search_best_feasible_path(self, path_indexs):\n    if False:\n        i = 10\n    print('Start search feasible path')\n    best_time = float('inf')\n    (fx, fy, fyaw, fv, ft, fa, fd) = (None, None, None, None, None, None, None)\n    for ind in path_indexs:\n        path = self.generate_final_course(ind)\n        (flag, x, y, yaw, v, t, a, d) = self.check_tracking_path_is_feasible(path)\n        if flag and best_time >= t[-1]:\n            print('feasible path is found')\n            best_time = t[-1]\n            (fx, fy, fyaw, fv, ft, fa, fd) = (x, y, yaw, v, t, a, d)\n    print('best time is')\n    print(best_time)\n    if fx:\n        fx.append(self.end.x)\n        fy.append(self.end.y)\n        fyaw.append(self.end.yaw)\n        return (True, fx, fy, fyaw, fv, ft, fa, fd)\n    return (False, None, None, None, None, None, None, None)",
            "def search_best_feasible_path(self, path_indexs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('Start search feasible path')\n    best_time = float('inf')\n    (fx, fy, fyaw, fv, ft, fa, fd) = (None, None, None, None, None, None, None)\n    for ind in path_indexs:\n        path = self.generate_final_course(ind)\n        (flag, x, y, yaw, v, t, a, d) = self.check_tracking_path_is_feasible(path)\n        if flag and best_time >= t[-1]:\n            print('feasible path is found')\n            best_time = t[-1]\n            (fx, fy, fyaw, fv, ft, fa, fd) = (x, y, yaw, v, t, a, d)\n    print('best time is')\n    print(best_time)\n    if fx:\n        fx.append(self.end.x)\n        fy.append(self.end.y)\n        fyaw.append(self.end.yaw)\n        return (True, fx, fy, fyaw, fv, ft, fa, fd)\n    return (False, None, None, None, None, None, None, None)",
            "def search_best_feasible_path(self, path_indexs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('Start search feasible path')\n    best_time = float('inf')\n    (fx, fy, fyaw, fv, ft, fa, fd) = (None, None, None, None, None, None, None)\n    for ind in path_indexs:\n        path = self.generate_final_course(ind)\n        (flag, x, y, yaw, v, t, a, d) = self.check_tracking_path_is_feasible(path)\n        if flag and best_time >= t[-1]:\n            print('feasible path is found')\n            best_time = t[-1]\n            (fx, fy, fyaw, fv, ft, fa, fd) = (x, y, yaw, v, t, a, d)\n    print('best time is')\n    print(best_time)\n    if fx:\n        fx.append(self.end.x)\n        fy.append(self.end.y)\n        fyaw.append(self.end.yaw)\n        return (True, fx, fy, fyaw, fv, ft, fa, fd)\n    return (False, None, None, None, None, None, None, None)",
            "def search_best_feasible_path(self, path_indexs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('Start search feasible path')\n    best_time = float('inf')\n    (fx, fy, fyaw, fv, ft, fa, fd) = (None, None, None, None, None, None, None)\n    for ind in path_indexs:\n        path = self.generate_final_course(ind)\n        (flag, x, y, yaw, v, t, a, d) = self.check_tracking_path_is_feasible(path)\n        if flag and best_time >= t[-1]:\n            print('feasible path is found')\n            best_time = t[-1]\n            (fx, fy, fyaw, fv, ft, fa, fd) = (x, y, yaw, v, t, a, d)\n    print('best time is')\n    print(best_time)\n    if fx:\n        fx.append(self.end.x)\n        fy.append(self.end.y)\n        fyaw.append(self.end.yaw)\n        return (True, fx, fy, fyaw, fv, ft, fa, fd)\n    return (False, None, None, None, None, None, None, None)",
            "def search_best_feasible_path(self, path_indexs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('Start search feasible path')\n    best_time = float('inf')\n    (fx, fy, fyaw, fv, ft, fa, fd) = (None, None, None, None, None, None, None)\n    for ind in path_indexs:\n        path = self.generate_final_course(ind)\n        (flag, x, y, yaw, v, t, a, d) = self.check_tracking_path_is_feasible(path)\n        if flag and best_time >= t[-1]:\n            print('feasible path is found')\n            best_time = t[-1]\n            (fx, fy, fyaw, fv, ft, fa, fd) = (x, y, yaw, v, t, a, d)\n    print('best time is')\n    print(best_time)\n    if fx:\n        fx.append(self.end.x)\n        fy.append(self.end.y)\n        fyaw.append(self.end.yaw)\n        return (True, fx, fy, fyaw, fv, ft, fa, fd)\n    return (False, None, None, None, None, None, None, None)"
        ]
    },
    {
        "func_name": "check_tracking_path_is_feasible",
        "original": "def check_tracking_path_is_feasible(self, path):\n    cx = np.array([state[0] for state in path])[::-1]\n    cy = np.array([state[1] for state in path])[::-1]\n    cyaw = np.array([state[2] for state in path])[::-1]\n    goal = [cx[-1], cy[-1], cyaw[-1]]\n    (cx, cy, cyaw) = pure_pursuit.extend_path(cx, cy, cyaw)\n    speed_profile = pure_pursuit.calc_speed_profile(cx, cy, cyaw, self.target_speed)\n    (t, x, y, yaw, v, a, d, find_goal) = pure_pursuit.closed_loop_prediction(cx, cy, cyaw, speed_profile, goal)\n    yaw = [reeds_shepp_path_planning.pi_2_pi(iyaw) for iyaw in yaw]\n    if not find_goal:\n        print('cannot reach goal')\n    if abs(yaw[-1] - goal[2]) >= self.yaw_th * 10.0:\n        print('final angle is bad')\n        find_goal = False\n    travel = unicycle_model.dt * sum(np.abs(v))\n    origin_travel = sum(np.hypot(np.diff(cx), np.diff(cy)))\n    if travel / origin_travel >= self.invalid_travel_ratio:\n        print('path is too long')\n        find_goal = False\n    tmp_node = self.Node(x, y, 0)\n    tmp_node.path_x = x\n    tmp_node.path_y = y\n    if not self.check_collision(tmp_node, self.obstacle_list, self.robot_radius):\n        print('This path is collision')\n        find_goal = False\n    return (find_goal, x, y, yaw, v, t, a, d)",
        "mutated": [
            "def check_tracking_path_is_feasible(self, path):\n    if False:\n        i = 10\n    cx = np.array([state[0] for state in path])[::-1]\n    cy = np.array([state[1] for state in path])[::-1]\n    cyaw = np.array([state[2] for state in path])[::-1]\n    goal = [cx[-1], cy[-1], cyaw[-1]]\n    (cx, cy, cyaw) = pure_pursuit.extend_path(cx, cy, cyaw)\n    speed_profile = pure_pursuit.calc_speed_profile(cx, cy, cyaw, self.target_speed)\n    (t, x, y, yaw, v, a, d, find_goal) = pure_pursuit.closed_loop_prediction(cx, cy, cyaw, speed_profile, goal)\n    yaw = [reeds_shepp_path_planning.pi_2_pi(iyaw) for iyaw in yaw]\n    if not find_goal:\n        print('cannot reach goal')\n    if abs(yaw[-1] - goal[2]) >= self.yaw_th * 10.0:\n        print('final angle is bad')\n        find_goal = False\n    travel = unicycle_model.dt * sum(np.abs(v))\n    origin_travel = sum(np.hypot(np.diff(cx), np.diff(cy)))\n    if travel / origin_travel >= self.invalid_travel_ratio:\n        print('path is too long')\n        find_goal = False\n    tmp_node = self.Node(x, y, 0)\n    tmp_node.path_x = x\n    tmp_node.path_y = y\n    if not self.check_collision(tmp_node, self.obstacle_list, self.robot_radius):\n        print('This path is collision')\n        find_goal = False\n    return (find_goal, x, y, yaw, v, t, a, d)",
            "def check_tracking_path_is_feasible(self, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cx = np.array([state[0] for state in path])[::-1]\n    cy = np.array([state[1] for state in path])[::-1]\n    cyaw = np.array([state[2] for state in path])[::-1]\n    goal = [cx[-1], cy[-1], cyaw[-1]]\n    (cx, cy, cyaw) = pure_pursuit.extend_path(cx, cy, cyaw)\n    speed_profile = pure_pursuit.calc_speed_profile(cx, cy, cyaw, self.target_speed)\n    (t, x, y, yaw, v, a, d, find_goal) = pure_pursuit.closed_loop_prediction(cx, cy, cyaw, speed_profile, goal)\n    yaw = [reeds_shepp_path_planning.pi_2_pi(iyaw) for iyaw in yaw]\n    if not find_goal:\n        print('cannot reach goal')\n    if abs(yaw[-1] - goal[2]) >= self.yaw_th * 10.0:\n        print('final angle is bad')\n        find_goal = False\n    travel = unicycle_model.dt * sum(np.abs(v))\n    origin_travel = sum(np.hypot(np.diff(cx), np.diff(cy)))\n    if travel / origin_travel >= self.invalid_travel_ratio:\n        print('path is too long')\n        find_goal = False\n    tmp_node = self.Node(x, y, 0)\n    tmp_node.path_x = x\n    tmp_node.path_y = y\n    if not self.check_collision(tmp_node, self.obstacle_list, self.robot_radius):\n        print('This path is collision')\n        find_goal = False\n    return (find_goal, x, y, yaw, v, t, a, d)",
            "def check_tracking_path_is_feasible(self, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cx = np.array([state[0] for state in path])[::-1]\n    cy = np.array([state[1] for state in path])[::-1]\n    cyaw = np.array([state[2] for state in path])[::-1]\n    goal = [cx[-1], cy[-1], cyaw[-1]]\n    (cx, cy, cyaw) = pure_pursuit.extend_path(cx, cy, cyaw)\n    speed_profile = pure_pursuit.calc_speed_profile(cx, cy, cyaw, self.target_speed)\n    (t, x, y, yaw, v, a, d, find_goal) = pure_pursuit.closed_loop_prediction(cx, cy, cyaw, speed_profile, goal)\n    yaw = [reeds_shepp_path_planning.pi_2_pi(iyaw) for iyaw in yaw]\n    if not find_goal:\n        print('cannot reach goal')\n    if abs(yaw[-1] - goal[2]) >= self.yaw_th * 10.0:\n        print('final angle is bad')\n        find_goal = False\n    travel = unicycle_model.dt * sum(np.abs(v))\n    origin_travel = sum(np.hypot(np.diff(cx), np.diff(cy)))\n    if travel / origin_travel >= self.invalid_travel_ratio:\n        print('path is too long')\n        find_goal = False\n    tmp_node = self.Node(x, y, 0)\n    tmp_node.path_x = x\n    tmp_node.path_y = y\n    if not self.check_collision(tmp_node, self.obstacle_list, self.robot_radius):\n        print('This path is collision')\n        find_goal = False\n    return (find_goal, x, y, yaw, v, t, a, d)",
            "def check_tracking_path_is_feasible(self, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cx = np.array([state[0] for state in path])[::-1]\n    cy = np.array([state[1] for state in path])[::-1]\n    cyaw = np.array([state[2] for state in path])[::-1]\n    goal = [cx[-1], cy[-1], cyaw[-1]]\n    (cx, cy, cyaw) = pure_pursuit.extend_path(cx, cy, cyaw)\n    speed_profile = pure_pursuit.calc_speed_profile(cx, cy, cyaw, self.target_speed)\n    (t, x, y, yaw, v, a, d, find_goal) = pure_pursuit.closed_loop_prediction(cx, cy, cyaw, speed_profile, goal)\n    yaw = [reeds_shepp_path_planning.pi_2_pi(iyaw) for iyaw in yaw]\n    if not find_goal:\n        print('cannot reach goal')\n    if abs(yaw[-1] - goal[2]) >= self.yaw_th * 10.0:\n        print('final angle is bad')\n        find_goal = False\n    travel = unicycle_model.dt * sum(np.abs(v))\n    origin_travel = sum(np.hypot(np.diff(cx), np.diff(cy)))\n    if travel / origin_travel >= self.invalid_travel_ratio:\n        print('path is too long')\n        find_goal = False\n    tmp_node = self.Node(x, y, 0)\n    tmp_node.path_x = x\n    tmp_node.path_y = y\n    if not self.check_collision(tmp_node, self.obstacle_list, self.robot_radius):\n        print('This path is collision')\n        find_goal = False\n    return (find_goal, x, y, yaw, v, t, a, d)",
            "def check_tracking_path_is_feasible(self, path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cx = np.array([state[0] for state in path])[::-1]\n    cy = np.array([state[1] for state in path])[::-1]\n    cyaw = np.array([state[2] for state in path])[::-1]\n    goal = [cx[-1], cy[-1], cyaw[-1]]\n    (cx, cy, cyaw) = pure_pursuit.extend_path(cx, cy, cyaw)\n    speed_profile = pure_pursuit.calc_speed_profile(cx, cy, cyaw, self.target_speed)\n    (t, x, y, yaw, v, a, d, find_goal) = pure_pursuit.closed_loop_prediction(cx, cy, cyaw, speed_profile, goal)\n    yaw = [reeds_shepp_path_planning.pi_2_pi(iyaw) for iyaw in yaw]\n    if not find_goal:\n        print('cannot reach goal')\n    if abs(yaw[-1] - goal[2]) >= self.yaw_th * 10.0:\n        print('final angle is bad')\n        find_goal = False\n    travel = unicycle_model.dt * sum(np.abs(v))\n    origin_travel = sum(np.hypot(np.diff(cx), np.diff(cy)))\n    if travel / origin_travel >= self.invalid_travel_ratio:\n        print('path is too long')\n        find_goal = False\n    tmp_node = self.Node(x, y, 0)\n    tmp_node.path_x = x\n    tmp_node.path_y = y\n    if not self.check_collision(tmp_node, self.obstacle_list, self.robot_radius):\n        print('This path is collision')\n        find_goal = False\n    return (find_goal, x, y, yaw, v, t, a, d)"
        ]
    },
    {
        "func_name": "get_goal_indexes",
        "original": "def get_goal_indexes(self):\n    goalinds = []\n    for (i, node) in enumerate(self.node_list):\n        if self.calc_dist_to_goal(node.x, node.y) <= self.xy_th:\n            goalinds.append(i)\n    print('OK XY TH num is')\n    print(len(goalinds))\n    fgoalinds = []\n    for i in goalinds:\n        if abs(self.node_list[i].yaw - self.end.yaw) <= self.yaw_th:\n            fgoalinds.append(i)\n    print('OK YAW TH num is')\n    print(len(fgoalinds))\n    return fgoalinds",
        "mutated": [
            "def get_goal_indexes(self):\n    if False:\n        i = 10\n    goalinds = []\n    for (i, node) in enumerate(self.node_list):\n        if self.calc_dist_to_goal(node.x, node.y) <= self.xy_th:\n            goalinds.append(i)\n    print('OK XY TH num is')\n    print(len(goalinds))\n    fgoalinds = []\n    for i in goalinds:\n        if abs(self.node_list[i].yaw - self.end.yaw) <= self.yaw_th:\n            fgoalinds.append(i)\n    print('OK YAW TH num is')\n    print(len(fgoalinds))\n    return fgoalinds",
            "def get_goal_indexes(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    goalinds = []\n    for (i, node) in enumerate(self.node_list):\n        if self.calc_dist_to_goal(node.x, node.y) <= self.xy_th:\n            goalinds.append(i)\n    print('OK XY TH num is')\n    print(len(goalinds))\n    fgoalinds = []\n    for i in goalinds:\n        if abs(self.node_list[i].yaw - self.end.yaw) <= self.yaw_th:\n            fgoalinds.append(i)\n    print('OK YAW TH num is')\n    print(len(fgoalinds))\n    return fgoalinds",
            "def get_goal_indexes(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    goalinds = []\n    for (i, node) in enumerate(self.node_list):\n        if self.calc_dist_to_goal(node.x, node.y) <= self.xy_th:\n            goalinds.append(i)\n    print('OK XY TH num is')\n    print(len(goalinds))\n    fgoalinds = []\n    for i in goalinds:\n        if abs(self.node_list[i].yaw - self.end.yaw) <= self.yaw_th:\n            fgoalinds.append(i)\n    print('OK YAW TH num is')\n    print(len(fgoalinds))\n    return fgoalinds",
            "def get_goal_indexes(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    goalinds = []\n    for (i, node) in enumerate(self.node_list):\n        if self.calc_dist_to_goal(node.x, node.y) <= self.xy_th:\n            goalinds.append(i)\n    print('OK XY TH num is')\n    print(len(goalinds))\n    fgoalinds = []\n    for i in goalinds:\n        if abs(self.node_list[i].yaw - self.end.yaw) <= self.yaw_th:\n            fgoalinds.append(i)\n    print('OK YAW TH num is')\n    print(len(fgoalinds))\n    return fgoalinds",
            "def get_goal_indexes(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    goalinds = []\n    for (i, node) in enumerate(self.node_list):\n        if self.calc_dist_to_goal(node.x, node.y) <= self.xy_th:\n            goalinds.append(i)\n    print('OK XY TH num is')\n    print(len(goalinds))\n    fgoalinds = []\n    for i in goalinds:\n        if abs(self.node_list[i].yaw - self.end.yaw) <= self.yaw_th:\n            fgoalinds.append(i)\n    print('OK YAW TH num is')\n    print(len(fgoalinds))\n    return fgoalinds"
        ]
    },
    {
        "func_name": "main",
        "original": "def main(gx=6.0, gy=7.0, gyaw=np.deg2rad(90.0), max_iter=100):\n    print('Start' + __file__)\n    obstacle_list = [(5, 5, 1), (4, 6, 1), (4, 8, 1), (4, 10, 1), (6, 5, 1), (7, 5, 1), (8, 6, 1), (8, 8, 1), (8, 10, 1)]\n    start = [0.0, 0.0, np.deg2rad(0.0)]\n    goal = [gx, gy, gyaw]\n    closed_loop_rrt_star = ClosedLoopRRTStar(start, goal, obstacle_list, [-2.0, 20.0], max_iter=max_iter)\n    (flag, x, y, yaw, v, t, a, d) = closed_loop_rrt_star.planning(animation=show_animation)\n    if not flag:\n        print('cannot find feasible path')\n    if show_animation:\n        closed_loop_rrt_star.draw_graph()\n        plt.plot(x, y, '-r')\n        plt.grid(True)\n        plt.pause(0.001)\n        plt.subplots(1)\n        plt.plot(t, [np.rad2deg(iyaw) for iyaw in yaw[:-1]], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('Yaw[deg]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, [iv * 3.6 for iv in v], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('velocity[km/h]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, a, '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('accel[m/ss]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, [np.rad2deg(td) for td in d], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('Steering angle[deg]')\n        plt.grid(True)\n        plt.show()",
        "mutated": [
            "def main(gx=6.0, gy=7.0, gyaw=np.deg2rad(90.0), max_iter=100):\n    if False:\n        i = 10\n    print('Start' + __file__)\n    obstacle_list = [(5, 5, 1), (4, 6, 1), (4, 8, 1), (4, 10, 1), (6, 5, 1), (7, 5, 1), (8, 6, 1), (8, 8, 1), (8, 10, 1)]\n    start = [0.0, 0.0, np.deg2rad(0.0)]\n    goal = [gx, gy, gyaw]\n    closed_loop_rrt_star = ClosedLoopRRTStar(start, goal, obstacle_list, [-2.0, 20.0], max_iter=max_iter)\n    (flag, x, y, yaw, v, t, a, d) = closed_loop_rrt_star.planning(animation=show_animation)\n    if not flag:\n        print('cannot find feasible path')\n    if show_animation:\n        closed_loop_rrt_star.draw_graph()\n        plt.plot(x, y, '-r')\n        plt.grid(True)\n        plt.pause(0.001)\n        plt.subplots(1)\n        plt.plot(t, [np.rad2deg(iyaw) for iyaw in yaw[:-1]], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('Yaw[deg]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, [iv * 3.6 for iv in v], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('velocity[km/h]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, a, '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('accel[m/ss]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, [np.rad2deg(td) for td in d], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('Steering angle[deg]')\n        plt.grid(True)\n        plt.show()",
            "def main(gx=6.0, gy=7.0, gyaw=np.deg2rad(90.0), max_iter=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('Start' + __file__)\n    obstacle_list = [(5, 5, 1), (4, 6, 1), (4, 8, 1), (4, 10, 1), (6, 5, 1), (7, 5, 1), (8, 6, 1), (8, 8, 1), (8, 10, 1)]\n    start = [0.0, 0.0, np.deg2rad(0.0)]\n    goal = [gx, gy, gyaw]\n    closed_loop_rrt_star = ClosedLoopRRTStar(start, goal, obstacle_list, [-2.0, 20.0], max_iter=max_iter)\n    (flag, x, y, yaw, v, t, a, d) = closed_loop_rrt_star.planning(animation=show_animation)\n    if not flag:\n        print('cannot find feasible path')\n    if show_animation:\n        closed_loop_rrt_star.draw_graph()\n        plt.plot(x, y, '-r')\n        plt.grid(True)\n        plt.pause(0.001)\n        plt.subplots(1)\n        plt.plot(t, [np.rad2deg(iyaw) for iyaw in yaw[:-1]], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('Yaw[deg]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, [iv * 3.6 for iv in v], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('velocity[km/h]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, a, '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('accel[m/ss]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, [np.rad2deg(td) for td in d], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('Steering angle[deg]')\n        plt.grid(True)\n        plt.show()",
            "def main(gx=6.0, gy=7.0, gyaw=np.deg2rad(90.0), max_iter=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('Start' + __file__)\n    obstacle_list = [(5, 5, 1), (4, 6, 1), (4, 8, 1), (4, 10, 1), (6, 5, 1), (7, 5, 1), (8, 6, 1), (8, 8, 1), (8, 10, 1)]\n    start = [0.0, 0.0, np.deg2rad(0.0)]\n    goal = [gx, gy, gyaw]\n    closed_loop_rrt_star = ClosedLoopRRTStar(start, goal, obstacle_list, [-2.0, 20.0], max_iter=max_iter)\n    (flag, x, y, yaw, v, t, a, d) = closed_loop_rrt_star.planning(animation=show_animation)\n    if not flag:\n        print('cannot find feasible path')\n    if show_animation:\n        closed_loop_rrt_star.draw_graph()\n        plt.plot(x, y, '-r')\n        plt.grid(True)\n        plt.pause(0.001)\n        plt.subplots(1)\n        plt.plot(t, [np.rad2deg(iyaw) for iyaw in yaw[:-1]], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('Yaw[deg]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, [iv * 3.6 for iv in v], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('velocity[km/h]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, a, '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('accel[m/ss]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, [np.rad2deg(td) for td in d], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('Steering angle[deg]')\n        plt.grid(True)\n        plt.show()",
            "def main(gx=6.0, gy=7.0, gyaw=np.deg2rad(90.0), max_iter=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('Start' + __file__)\n    obstacle_list = [(5, 5, 1), (4, 6, 1), (4, 8, 1), (4, 10, 1), (6, 5, 1), (7, 5, 1), (8, 6, 1), (8, 8, 1), (8, 10, 1)]\n    start = [0.0, 0.0, np.deg2rad(0.0)]\n    goal = [gx, gy, gyaw]\n    closed_loop_rrt_star = ClosedLoopRRTStar(start, goal, obstacle_list, [-2.0, 20.0], max_iter=max_iter)\n    (flag, x, y, yaw, v, t, a, d) = closed_loop_rrt_star.planning(animation=show_animation)\n    if not flag:\n        print('cannot find feasible path')\n    if show_animation:\n        closed_loop_rrt_star.draw_graph()\n        plt.plot(x, y, '-r')\n        plt.grid(True)\n        plt.pause(0.001)\n        plt.subplots(1)\n        plt.plot(t, [np.rad2deg(iyaw) for iyaw in yaw[:-1]], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('Yaw[deg]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, [iv * 3.6 for iv in v], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('velocity[km/h]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, a, '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('accel[m/ss]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, [np.rad2deg(td) for td in d], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('Steering angle[deg]')\n        plt.grid(True)\n        plt.show()",
            "def main(gx=6.0, gy=7.0, gyaw=np.deg2rad(90.0), max_iter=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('Start' + __file__)\n    obstacle_list = [(5, 5, 1), (4, 6, 1), (4, 8, 1), (4, 10, 1), (6, 5, 1), (7, 5, 1), (8, 6, 1), (8, 8, 1), (8, 10, 1)]\n    start = [0.0, 0.0, np.deg2rad(0.0)]\n    goal = [gx, gy, gyaw]\n    closed_loop_rrt_star = ClosedLoopRRTStar(start, goal, obstacle_list, [-2.0, 20.0], max_iter=max_iter)\n    (flag, x, y, yaw, v, t, a, d) = closed_loop_rrt_star.planning(animation=show_animation)\n    if not flag:\n        print('cannot find feasible path')\n    if show_animation:\n        closed_loop_rrt_star.draw_graph()\n        plt.plot(x, y, '-r')\n        plt.grid(True)\n        plt.pause(0.001)\n        plt.subplots(1)\n        plt.plot(t, [np.rad2deg(iyaw) for iyaw in yaw[:-1]], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('Yaw[deg]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, [iv * 3.6 for iv in v], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('velocity[km/h]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, a, '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('accel[m/ss]')\n        plt.grid(True)\n        plt.subplots(1)\n        plt.plot(t, [np.rad2deg(td) for td in d], '-r')\n        plt.xlabel('time[s]')\n        plt.ylabel('Steering angle[deg]')\n        plt.grid(True)\n        plt.show()"
        ]
    }
]