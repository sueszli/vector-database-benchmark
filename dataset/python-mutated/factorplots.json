[
    {
        "func_name": "interaction_plot",
        "original": "def interaction_plot(x, trace, response, func='mean', ax=None, plottype='b', xlabel=None, ylabel=None, colors=None, markers=None, linestyles=None, legendloc='best', legendtitle=None, **kwargs):\n    \"\"\"\n    Interaction plot for factor level statistics.\n\n    Note. If categorial factors are supplied levels will be internally\n    recoded to integers. This ensures matplotlib compatibility. Uses\n    a DataFrame to calculate an `aggregate` statistic for each level of the\n    factor or group given by `trace`.\n\n    Parameters\n    ----------\n    x : array_like\n        The `x` factor levels constitute the x-axis. If a `pandas.Series` is\n        given its name will be used in `xlabel` if `xlabel` is None.\n    trace : array_like\n        The `trace` factor levels will be drawn as lines in the plot.\n        If `trace` is a `pandas.Series` its name will be used as the\n        `legendtitle` if `legendtitle` is None.\n    response : array_like\n        The reponse or dependent variable. If a `pandas.Series` is given\n        its name will be used in `ylabel` if `ylabel` is None.\n    func : function\n        Anything accepted by `pandas.DataFrame.aggregate`. This is applied to\n        the response variable grouped by the trace levels.\n    ax : axes, optional\n        Matplotlib axes instance\n    plottype : str {'line', 'scatter', 'both'}, optional\n        The type of plot to return. Can be 'l', 's', or 'b'\n    xlabel : str, optional\n        Label to use for `x`. Default is 'X'. If `x` is a `pandas.Series` it\n        will use the series names.\n    ylabel : str, optional\n        Label to use for `response`. Default is 'func of response'. If\n        `response` is a `pandas.Series` it will use the series names.\n    colors : list, optional\n        If given, must have length == number of levels in trace.\n    markers : list, optional\n        If given, must have length == number of levels in trace\n    linestyles : list, optional\n        If given, must have length == number of levels in trace.\n    legendloc : {None, str, int}\n        Location passed to the legend command.\n    legendtitle : {None, str}\n        Title of the legend.\n    **kwargs\n        These will be passed to the plot command used either plot or scatter.\n        If you want to control the overall plotting options, use kwargs.\n\n    Returns\n    -------\n    Figure\n        The figure given by `ax.figure` or a new instance.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.random.seed(12345)\n    >>> weight = np.random.randint(1,4,size=60)\n    >>> duration = np.random.randint(1,3,size=60)\n    >>> days = np.log(np.random.randint(1,30, size=60))\n    >>> fig = interaction_plot(weight, duration, days,\n    ...             colors=['red','blue'], markers=['D','^'], ms=10)\n    >>> import matplotlib.pyplot as plt\n    >>> plt.show()\n\n    .. plot::\n\n       import numpy as np\n       from statsmodels.graphics.factorplots import interaction_plot\n       np.random.seed(12345)\n       weight = np.random.randint(1,4,size=60)\n       duration = np.random.randint(1,3,size=60)\n       days = np.log(np.random.randint(1,30, size=60))\n       fig = interaction_plot(weight, duration, days,\n                   colors=['red','blue'], markers=['D','^'], ms=10)\n       import matplotlib.pyplot as plt\n       #plt.show()\n    \"\"\"\n    from pandas import DataFrame\n    (fig, ax) = utils.create_mpl_ax(ax)\n    response_name = ylabel or getattr(response, 'name', 'response')\n    func_name = getattr(func, '__name__', str(func))\n    ylabel = '%s of %s' % (func_name, response_name)\n    xlabel = xlabel or getattr(x, 'name', 'X')\n    legendtitle = legendtitle or getattr(trace, 'name', 'Trace')\n    ax.set_ylabel(ylabel)\n    ax.set_xlabel(xlabel)\n    x_values = x_levels = None\n    if isinstance(x[0], str):\n        x_levels = [l for l in np.unique(x)]\n        x_values = lrange(len(x_levels))\n        x = _recode(x, dict(zip(x_levels, x_values)))\n    data = DataFrame(dict(x=x, trace=trace, response=response))\n    plot_data = data.groupby(['trace', 'x']).aggregate(func).reset_index()\n    n_trace = len(plot_data['trace'].unique())\n    linestyles = ['-'] * n_trace if linestyles is None else linestyles\n    markers = ['.'] * n_trace if markers is None else markers\n    colors = rainbow(n_trace) if colors is None else colors\n    if len(linestyles) != n_trace:\n        raise ValueError('Must be a linestyle for each trace level')\n    if len(markers) != n_trace:\n        raise ValueError('Must be a marker for each trace level')\n    if len(colors) != n_trace:\n        raise ValueError('Must be a color for each trace level')\n    if plottype == 'both' or plottype == 'b':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.plot(group['x'], group['response'], color=colors[i], marker=markers[i], label=label, linestyle=linestyles[i], **kwargs)\n    elif plottype == 'line' or plottype == 'l':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.plot(group['x'], group['response'], color=colors[i], label=label, linestyle=linestyles[i], **kwargs)\n    elif plottype == 'scatter' or plottype == 's':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.scatter(group['x'], group['response'], color=colors[i], label=label, marker=markers[i], **kwargs)\n    else:\n        raise ValueError('Plot type %s not understood' % plottype)\n    ax.legend(loc=legendloc, title=legendtitle)\n    ax.margins(0.1)\n    if all([x_levels, x_values]):\n        ax.set_xticks(x_values)\n        ax.set_xticklabels(x_levels)\n    return fig",
        "mutated": [
            "def interaction_plot(x, trace, response, func='mean', ax=None, plottype='b', xlabel=None, ylabel=None, colors=None, markers=None, linestyles=None, legendloc='best', legendtitle=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Interaction plot for factor level statistics.\\n\\n    Note. If categorial factors are supplied levels will be internally\\n    recoded to integers. This ensures matplotlib compatibility. Uses\\n    a DataFrame to calculate an `aggregate` statistic for each level of the\\n    factor or group given by `trace`.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The `x` factor levels constitute the x-axis. If a `pandas.Series` is\\n        given its name will be used in `xlabel` if `xlabel` is None.\\n    trace : array_like\\n        The `trace` factor levels will be drawn as lines in the plot.\\n        If `trace` is a `pandas.Series` its name will be used as the\\n        `legendtitle` if `legendtitle` is None.\\n    response : array_like\\n        The reponse or dependent variable. If a `pandas.Series` is given\\n        its name will be used in `ylabel` if `ylabel` is None.\\n    func : function\\n        Anything accepted by `pandas.DataFrame.aggregate`. This is applied to\\n        the response variable grouped by the trace levels.\\n    ax : axes, optional\\n        Matplotlib axes instance\\n    plottype : str {'line', 'scatter', 'both'}, optional\\n        The type of plot to return. Can be 'l', 's', or 'b'\\n    xlabel : str, optional\\n        Label to use for `x`. Default is 'X'. If `x` is a `pandas.Series` it\\n        will use the series names.\\n    ylabel : str, optional\\n        Label to use for `response`. Default is 'func of response'. If\\n        `response` is a `pandas.Series` it will use the series names.\\n    colors : list, optional\\n        If given, must have length == number of levels in trace.\\n    markers : list, optional\\n        If given, must have length == number of levels in trace\\n    linestyles : list, optional\\n        If given, must have length == number of levels in trace.\\n    legendloc : {None, str, int}\\n        Location passed to the legend command.\\n    legendtitle : {None, str}\\n        Title of the legend.\\n    **kwargs\\n        These will be passed to the plot command used either plot or scatter.\\n        If you want to control the overall plotting options, use kwargs.\\n\\n    Returns\\n    -------\\n    Figure\\n        The figure given by `ax.figure` or a new instance.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> np.random.seed(12345)\\n    >>> weight = np.random.randint(1,4,size=60)\\n    >>> duration = np.random.randint(1,3,size=60)\\n    >>> days = np.log(np.random.randint(1,30, size=60))\\n    >>> fig = interaction_plot(weight, duration, days,\\n    ...             colors=['red','blue'], markers=['D','^'], ms=10)\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.show()\\n\\n    .. plot::\\n\\n       import numpy as np\\n       from statsmodels.graphics.factorplots import interaction_plot\\n       np.random.seed(12345)\\n       weight = np.random.randint(1,4,size=60)\\n       duration = np.random.randint(1,3,size=60)\\n       days = np.log(np.random.randint(1,30, size=60))\\n       fig = interaction_plot(weight, duration, days,\\n                   colors=['red','blue'], markers=['D','^'], ms=10)\\n       import matplotlib.pyplot as plt\\n       #plt.show()\\n    \"\n    from pandas import DataFrame\n    (fig, ax) = utils.create_mpl_ax(ax)\n    response_name = ylabel or getattr(response, 'name', 'response')\n    func_name = getattr(func, '__name__', str(func))\n    ylabel = '%s of %s' % (func_name, response_name)\n    xlabel = xlabel or getattr(x, 'name', 'X')\n    legendtitle = legendtitle or getattr(trace, 'name', 'Trace')\n    ax.set_ylabel(ylabel)\n    ax.set_xlabel(xlabel)\n    x_values = x_levels = None\n    if isinstance(x[0], str):\n        x_levels = [l for l in np.unique(x)]\n        x_values = lrange(len(x_levels))\n        x = _recode(x, dict(zip(x_levels, x_values)))\n    data = DataFrame(dict(x=x, trace=trace, response=response))\n    plot_data = data.groupby(['trace', 'x']).aggregate(func).reset_index()\n    n_trace = len(plot_data['trace'].unique())\n    linestyles = ['-'] * n_trace if linestyles is None else linestyles\n    markers = ['.'] * n_trace if markers is None else markers\n    colors = rainbow(n_trace) if colors is None else colors\n    if len(linestyles) != n_trace:\n        raise ValueError('Must be a linestyle for each trace level')\n    if len(markers) != n_trace:\n        raise ValueError('Must be a marker for each trace level')\n    if len(colors) != n_trace:\n        raise ValueError('Must be a color for each trace level')\n    if plottype == 'both' or plottype == 'b':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.plot(group['x'], group['response'], color=colors[i], marker=markers[i], label=label, linestyle=linestyles[i], **kwargs)\n    elif plottype == 'line' or plottype == 'l':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.plot(group['x'], group['response'], color=colors[i], label=label, linestyle=linestyles[i], **kwargs)\n    elif plottype == 'scatter' or plottype == 's':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.scatter(group['x'], group['response'], color=colors[i], label=label, marker=markers[i], **kwargs)\n    else:\n        raise ValueError('Plot type %s not understood' % plottype)\n    ax.legend(loc=legendloc, title=legendtitle)\n    ax.margins(0.1)\n    if all([x_levels, x_values]):\n        ax.set_xticks(x_values)\n        ax.set_xticklabels(x_levels)\n    return fig",
            "def interaction_plot(x, trace, response, func='mean', ax=None, plottype='b', xlabel=None, ylabel=None, colors=None, markers=None, linestyles=None, legendloc='best', legendtitle=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Interaction plot for factor level statistics.\\n\\n    Note. If categorial factors are supplied levels will be internally\\n    recoded to integers. This ensures matplotlib compatibility. Uses\\n    a DataFrame to calculate an `aggregate` statistic for each level of the\\n    factor or group given by `trace`.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The `x` factor levels constitute the x-axis. If a `pandas.Series` is\\n        given its name will be used in `xlabel` if `xlabel` is None.\\n    trace : array_like\\n        The `trace` factor levels will be drawn as lines in the plot.\\n        If `trace` is a `pandas.Series` its name will be used as the\\n        `legendtitle` if `legendtitle` is None.\\n    response : array_like\\n        The reponse or dependent variable. If a `pandas.Series` is given\\n        its name will be used in `ylabel` if `ylabel` is None.\\n    func : function\\n        Anything accepted by `pandas.DataFrame.aggregate`. This is applied to\\n        the response variable grouped by the trace levels.\\n    ax : axes, optional\\n        Matplotlib axes instance\\n    plottype : str {'line', 'scatter', 'both'}, optional\\n        The type of plot to return. Can be 'l', 's', or 'b'\\n    xlabel : str, optional\\n        Label to use for `x`. Default is 'X'. If `x` is a `pandas.Series` it\\n        will use the series names.\\n    ylabel : str, optional\\n        Label to use for `response`. Default is 'func of response'. If\\n        `response` is a `pandas.Series` it will use the series names.\\n    colors : list, optional\\n        If given, must have length == number of levels in trace.\\n    markers : list, optional\\n        If given, must have length == number of levels in trace\\n    linestyles : list, optional\\n        If given, must have length == number of levels in trace.\\n    legendloc : {None, str, int}\\n        Location passed to the legend command.\\n    legendtitle : {None, str}\\n        Title of the legend.\\n    **kwargs\\n        These will be passed to the plot command used either plot or scatter.\\n        If you want to control the overall plotting options, use kwargs.\\n\\n    Returns\\n    -------\\n    Figure\\n        The figure given by `ax.figure` or a new instance.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> np.random.seed(12345)\\n    >>> weight = np.random.randint(1,4,size=60)\\n    >>> duration = np.random.randint(1,3,size=60)\\n    >>> days = np.log(np.random.randint(1,30, size=60))\\n    >>> fig = interaction_plot(weight, duration, days,\\n    ...             colors=['red','blue'], markers=['D','^'], ms=10)\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.show()\\n\\n    .. plot::\\n\\n       import numpy as np\\n       from statsmodels.graphics.factorplots import interaction_plot\\n       np.random.seed(12345)\\n       weight = np.random.randint(1,4,size=60)\\n       duration = np.random.randint(1,3,size=60)\\n       days = np.log(np.random.randint(1,30, size=60))\\n       fig = interaction_plot(weight, duration, days,\\n                   colors=['red','blue'], markers=['D','^'], ms=10)\\n       import matplotlib.pyplot as plt\\n       #plt.show()\\n    \"\n    from pandas import DataFrame\n    (fig, ax) = utils.create_mpl_ax(ax)\n    response_name = ylabel or getattr(response, 'name', 'response')\n    func_name = getattr(func, '__name__', str(func))\n    ylabel = '%s of %s' % (func_name, response_name)\n    xlabel = xlabel or getattr(x, 'name', 'X')\n    legendtitle = legendtitle or getattr(trace, 'name', 'Trace')\n    ax.set_ylabel(ylabel)\n    ax.set_xlabel(xlabel)\n    x_values = x_levels = None\n    if isinstance(x[0], str):\n        x_levels = [l for l in np.unique(x)]\n        x_values = lrange(len(x_levels))\n        x = _recode(x, dict(zip(x_levels, x_values)))\n    data = DataFrame(dict(x=x, trace=trace, response=response))\n    plot_data = data.groupby(['trace', 'x']).aggregate(func).reset_index()\n    n_trace = len(plot_data['trace'].unique())\n    linestyles = ['-'] * n_trace if linestyles is None else linestyles\n    markers = ['.'] * n_trace if markers is None else markers\n    colors = rainbow(n_trace) if colors is None else colors\n    if len(linestyles) != n_trace:\n        raise ValueError('Must be a linestyle for each trace level')\n    if len(markers) != n_trace:\n        raise ValueError('Must be a marker for each trace level')\n    if len(colors) != n_trace:\n        raise ValueError('Must be a color for each trace level')\n    if plottype == 'both' or plottype == 'b':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.plot(group['x'], group['response'], color=colors[i], marker=markers[i], label=label, linestyle=linestyles[i], **kwargs)\n    elif plottype == 'line' or plottype == 'l':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.plot(group['x'], group['response'], color=colors[i], label=label, linestyle=linestyles[i], **kwargs)\n    elif plottype == 'scatter' or plottype == 's':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.scatter(group['x'], group['response'], color=colors[i], label=label, marker=markers[i], **kwargs)\n    else:\n        raise ValueError('Plot type %s not understood' % plottype)\n    ax.legend(loc=legendloc, title=legendtitle)\n    ax.margins(0.1)\n    if all([x_levels, x_values]):\n        ax.set_xticks(x_values)\n        ax.set_xticklabels(x_levels)\n    return fig",
            "def interaction_plot(x, trace, response, func='mean', ax=None, plottype='b', xlabel=None, ylabel=None, colors=None, markers=None, linestyles=None, legendloc='best', legendtitle=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Interaction plot for factor level statistics.\\n\\n    Note. If categorial factors are supplied levels will be internally\\n    recoded to integers. This ensures matplotlib compatibility. Uses\\n    a DataFrame to calculate an `aggregate` statistic for each level of the\\n    factor or group given by `trace`.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The `x` factor levels constitute the x-axis. If a `pandas.Series` is\\n        given its name will be used in `xlabel` if `xlabel` is None.\\n    trace : array_like\\n        The `trace` factor levels will be drawn as lines in the plot.\\n        If `trace` is a `pandas.Series` its name will be used as the\\n        `legendtitle` if `legendtitle` is None.\\n    response : array_like\\n        The reponse or dependent variable. If a `pandas.Series` is given\\n        its name will be used in `ylabel` if `ylabel` is None.\\n    func : function\\n        Anything accepted by `pandas.DataFrame.aggregate`. This is applied to\\n        the response variable grouped by the trace levels.\\n    ax : axes, optional\\n        Matplotlib axes instance\\n    plottype : str {'line', 'scatter', 'both'}, optional\\n        The type of plot to return. Can be 'l', 's', or 'b'\\n    xlabel : str, optional\\n        Label to use for `x`. Default is 'X'. If `x` is a `pandas.Series` it\\n        will use the series names.\\n    ylabel : str, optional\\n        Label to use for `response`. Default is 'func of response'. If\\n        `response` is a `pandas.Series` it will use the series names.\\n    colors : list, optional\\n        If given, must have length == number of levels in trace.\\n    markers : list, optional\\n        If given, must have length == number of levels in trace\\n    linestyles : list, optional\\n        If given, must have length == number of levels in trace.\\n    legendloc : {None, str, int}\\n        Location passed to the legend command.\\n    legendtitle : {None, str}\\n        Title of the legend.\\n    **kwargs\\n        These will be passed to the plot command used either plot or scatter.\\n        If you want to control the overall plotting options, use kwargs.\\n\\n    Returns\\n    -------\\n    Figure\\n        The figure given by `ax.figure` or a new instance.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> np.random.seed(12345)\\n    >>> weight = np.random.randint(1,4,size=60)\\n    >>> duration = np.random.randint(1,3,size=60)\\n    >>> days = np.log(np.random.randint(1,30, size=60))\\n    >>> fig = interaction_plot(weight, duration, days,\\n    ...             colors=['red','blue'], markers=['D','^'], ms=10)\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.show()\\n\\n    .. plot::\\n\\n       import numpy as np\\n       from statsmodels.graphics.factorplots import interaction_plot\\n       np.random.seed(12345)\\n       weight = np.random.randint(1,4,size=60)\\n       duration = np.random.randint(1,3,size=60)\\n       days = np.log(np.random.randint(1,30, size=60))\\n       fig = interaction_plot(weight, duration, days,\\n                   colors=['red','blue'], markers=['D','^'], ms=10)\\n       import matplotlib.pyplot as plt\\n       #plt.show()\\n    \"\n    from pandas import DataFrame\n    (fig, ax) = utils.create_mpl_ax(ax)\n    response_name = ylabel or getattr(response, 'name', 'response')\n    func_name = getattr(func, '__name__', str(func))\n    ylabel = '%s of %s' % (func_name, response_name)\n    xlabel = xlabel or getattr(x, 'name', 'X')\n    legendtitle = legendtitle or getattr(trace, 'name', 'Trace')\n    ax.set_ylabel(ylabel)\n    ax.set_xlabel(xlabel)\n    x_values = x_levels = None\n    if isinstance(x[0], str):\n        x_levels = [l for l in np.unique(x)]\n        x_values = lrange(len(x_levels))\n        x = _recode(x, dict(zip(x_levels, x_values)))\n    data = DataFrame(dict(x=x, trace=trace, response=response))\n    plot_data = data.groupby(['trace', 'x']).aggregate(func).reset_index()\n    n_trace = len(plot_data['trace'].unique())\n    linestyles = ['-'] * n_trace if linestyles is None else linestyles\n    markers = ['.'] * n_trace if markers is None else markers\n    colors = rainbow(n_trace) if colors is None else colors\n    if len(linestyles) != n_trace:\n        raise ValueError('Must be a linestyle for each trace level')\n    if len(markers) != n_trace:\n        raise ValueError('Must be a marker for each trace level')\n    if len(colors) != n_trace:\n        raise ValueError('Must be a color for each trace level')\n    if plottype == 'both' or plottype == 'b':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.plot(group['x'], group['response'], color=colors[i], marker=markers[i], label=label, linestyle=linestyles[i], **kwargs)\n    elif plottype == 'line' or plottype == 'l':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.plot(group['x'], group['response'], color=colors[i], label=label, linestyle=linestyles[i], **kwargs)\n    elif plottype == 'scatter' or plottype == 's':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.scatter(group['x'], group['response'], color=colors[i], label=label, marker=markers[i], **kwargs)\n    else:\n        raise ValueError('Plot type %s not understood' % plottype)\n    ax.legend(loc=legendloc, title=legendtitle)\n    ax.margins(0.1)\n    if all([x_levels, x_values]):\n        ax.set_xticks(x_values)\n        ax.set_xticklabels(x_levels)\n    return fig",
            "def interaction_plot(x, trace, response, func='mean', ax=None, plottype='b', xlabel=None, ylabel=None, colors=None, markers=None, linestyles=None, legendloc='best', legendtitle=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Interaction plot for factor level statistics.\\n\\n    Note. If categorial factors are supplied levels will be internally\\n    recoded to integers. This ensures matplotlib compatibility. Uses\\n    a DataFrame to calculate an `aggregate` statistic for each level of the\\n    factor or group given by `trace`.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The `x` factor levels constitute the x-axis. If a `pandas.Series` is\\n        given its name will be used in `xlabel` if `xlabel` is None.\\n    trace : array_like\\n        The `trace` factor levels will be drawn as lines in the plot.\\n        If `trace` is a `pandas.Series` its name will be used as the\\n        `legendtitle` if `legendtitle` is None.\\n    response : array_like\\n        The reponse or dependent variable. If a `pandas.Series` is given\\n        its name will be used in `ylabel` if `ylabel` is None.\\n    func : function\\n        Anything accepted by `pandas.DataFrame.aggregate`. This is applied to\\n        the response variable grouped by the trace levels.\\n    ax : axes, optional\\n        Matplotlib axes instance\\n    plottype : str {'line', 'scatter', 'both'}, optional\\n        The type of plot to return. Can be 'l', 's', or 'b'\\n    xlabel : str, optional\\n        Label to use for `x`. Default is 'X'. If `x` is a `pandas.Series` it\\n        will use the series names.\\n    ylabel : str, optional\\n        Label to use for `response`. Default is 'func of response'. If\\n        `response` is a `pandas.Series` it will use the series names.\\n    colors : list, optional\\n        If given, must have length == number of levels in trace.\\n    markers : list, optional\\n        If given, must have length == number of levels in trace\\n    linestyles : list, optional\\n        If given, must have length == number of levels in trace.\\n    legendloc : {None, str, int}\\n        Location passed to the legend command.\\n    legendtitle : {None, str}\\n        Title of the legend.\\n    **kwargs\\n        These will be passed to the plot command used either plot or scatter.\\n        If you want to control the overall plotting options, use kwargs.\\n\\n    Returns\\n    -------\\n    Figure\\n        The figure given by `ax.figure` or a new instance.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> np.random.seed(12345)\\n    >>> weight = np.random.randint(1,4,size=60)\\n    >>> duration = np.random.randint(1,3,size=60)\\n    >>> days = np.log(np.random.randint(1,30, size=60))\\n    >>> fig = interaction_plot(weight, duration, days,\\n    ...             colors=['red','blue'], markers=['D','^'], ms=10)\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.show()\\n\\n    .. plot::\\n\\n       import numpy as np\\n       from statsmodels.graphics.factorplots import interaction_plot\\n       np.random.seed(12345)\\n       weight = np.random.randint(1,4,size=60)\\n       duration = np.random.randint(1,3,size=60)\\n       days = np.log(np.random.randint(1,30, size=60))\\n       fig = interaction_plot(weight, duration, days,\\n                   colors=['red','blue'], markers=['D','^'], ms=10)\\n       import matplotlib.pyplot as plt\\n       #plt.show()\\n    \"\n    from pandas import DataFrame\n    (fig, ax) = utils.create_mpl_ax(ax)\n    response_name = ylabel or getattr(response, 'name', 'response')\n    func_name = getattr(func, '__name__', str(func))\n    ylabel = '%s of %s' % (func_name, response_name)\n    xlabel = xlabel or getattr(x, 'name', 'X')\n    legendtitle = legendtitle or getattr(trace, 'name', 'Trace')\n    ax.set_ylabel(ylabel)\n    ax.set_xlabel(xlabel)\n    x_values = x_levels = None\n    if isinstance(x[0], str):\n        x_levels = [l for l in np.unique(x)]\n        x_values = lrange(len(x_levels))\n        x = _recode(x, dict(zip(x_levels, x_values)))\n    data = DataFrame(dict(x=x, trace=trace, response=response))\n    plot_data = data.groupby(['trace', 'x']).aggregate(func).reset_index()\n    n_trace = len(plot_data['trace'].unique())\n    linestyles = ['-'] * n_trace if linestyles is None else linestyles\n    markers = ['.'] * n_trace if markers is None else markers\n    colors = rainbow(n_trace) if colors is None else colors\n    if len(linestyles) != n_trace:\n        raise ValueError('Must be a linestyle for each trace level')\n    if len(markers) != n_trace:\n        raise ValueError('Must be a marker for each trace level')\n    if len(colors) != n_trace:\n        raise ValueError('Must be a color for each trace level')\n    if plottype == 'both' or plottype == 'b':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.plot(group['x'], group['response'], color=colors[i], marker=markers[i], label=label, linestyle=linestyles[i], **kwargs)\n    elif plottype == 'line' or plottype == 'l':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.plot(group['x'], group['response'], color=colors[i], label=label, linestyle=linestyles[i], **kwargs)\n    elif plottype == 'scatter' or plottype == 's':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.scatter(group['x'], group['response'], color=colors[i], label=label, marker=markers[i], **kwargs)\n    else:\n        raise ValueError('Plot type %s not understood' % plottype)\n    ax.legend(loc=legendloc, title=legendtitle)\n    ax.margins(0.1)\n    if all([x_levels, x_values]):\n        ax.set_xticks(x_values)\n        ax.set_xticklabels(x_levels)\n    return fig",
            "def interaction_plot(x, trace, response, func='mean', ax=None, plottype='b', xlabel=None, ylabel=None, colors=None, markers=None, linestyles=None, legendloc='best', legendtitle=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Interaction plot for factor level statistics.\\n\\n    Note. If categorial factors are supplied levels will be internally\\n    recoded to integers. This ensures matplotlib compatibility. Uses\\n    a DataFrame to calculate an `aggregate` statistic for each level of the\\n    factor or group given by `trace`.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The `x` factor levels constitute the x-axis. If a `pandas.Series` is\\n        given its name will be used in `xlabel` if `xlabel` is None.\\n    trace : array_like\\n        The `trace` factor levels will be drawn as lines in the plot.\\n        If `trace` is a `pandas.Series` its name will be used as the\\n        `legendtitle` if `legendtitle` is None.\\n    response : array_like\\n        The reponse or dependent variable. If a `pandas.Series` is given\\n        its name will be used in `ylabel` if `ylabel` is None.\\n    func : function\\n        Anything accepted by `pandas.DataFrame.aggregate`. This is applied to\\n        the response variable grouped by the trace levels.\\n    ax : axes, optional\\n        Matplotlib axes instance\\n    plottype : str {'line', 'scatter', 'both'}, optional\\n        The type of plot to return. Can be 'l', 's', or 'b'\\n    xlabel : str, optional\\n        Label to use for `x`. Default is 'X'. If `x` is a `pandas.Series` it\\n        will use the series names.\\n    ylabel : str, optional\\n        Label to use for `response`. Default is 'func of response'. If\\n        `response` is a `pandas.Series` it will use the series names.\\n    colors : list, optional\\n        If given, must have length == number of levels in trace.\\n    markers : list, optional\\n        If given, must have length == number of levels in trace\\n    linestyles : list, optional\\n        If given, must have length == number of levels in trace.\\n    legendloc : {None, str, int}\\n        Location passed to the legend command.\\n    legendtitle : {None, str}\\n        Title of the legend.\\n    **kwargs\\n        These will be passed to the plot command used either plot or scatter.\\n        If you want to control the overall plotting options, use kwargs.\\n\\n    Returns\\n    -------\\n    Figure\\n        The figure given by `ax.figure` or a new instance.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> np.random.seed(12345)\\n    >>> weight = np.random.randint(1,4,size=60)\\n    >>> duration = np.random.randint(1,3,size=60)\\n    >>> days = np.log(np.random.randint(1,30, size=60))\\n    >>> fig = interaction_plot(weight, duration, days,\\n    ...             colors=['red','blue'], markers=['D','^'], ms=10)\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.show()\\n\\n    .. plot::\\n\\n       import numpy as np\\n       from statsmodels.graphics.factorplots import interaction_plot\\n       np.random.seed(12345)\\n       weight = np.random.randint(1,4,size=60)\\n       duration = np.random.randint(1,3,size=60)\\n       days = np.log(np.random.randint(1,30, size=60))\\n       fig = interaction_plot(weight, duration, days,\\n                   colors=['red','blue'], markers=['D','^'], ms=10)\\n       import matplotlib.pyplot as plt\\n       #plt.show()\\n    \"\n    from pandas import DataFrame\n    (fig, ax) = utils.create_mpl_ax(ax)\n    response_name = ylabel or getattr(response, 'name', 'response')\n    func_name = getattr(func, '__name__', str(func))\n    ylabel = '%s of %s' % (func_name, response_name)\n    xlabel = xlabel or getattr(x, 'name', 'X')\n    legendtitle = legendtitle or getattr(trace, 'name', 'Trace')\n    ax.set_ylabel(ylabel)\n    ax.set_xlabel(xlabel)\n    x_values = x_levels = None\n    if isinstance(x[0], str):\n        x_levels = [l for l in np.unique(x)]\n        x_values = lrange(len(x_levels))\n        x = _recode(x, dict(zip(x_levels, x_values)))\n    data = DataFrame(dict(x=x, trace=trace, response=response))\n    plot_data = data.groupby(['trace', 'x']).aggregate(func).reset_index()\n    n_trace = len(plot_data['trace'].unique())\n    linestyles = ['-'] * n_trace if linestyles is None else linestyles\n    markers = ['.'] * n_trace if markers is None else markers\n    colors = rainbow(n_trace) if colors is None else colors\n    if len(linestyles) != n_trace:\n        raise ValueError('Must be a linestyle for each trace level')\n    if len(markers) != n_trace:\n        raise ValueError('Must be a marker for each trace level')\n    if len(colors) != n_trace:\n        raise ValueError('Must be a color for each trace level')\n    if plottype == 'both' or plottype == 'b':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.plot(group['x'], group['response'], color=colors[i], marker=markers[i], label=label, linestyle=linestyles[i], **kwargs)\n    elif plottype == 'line' or plottype == 'l':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.plot(group['x'], group['response'], color=colors[i], label=label, linestyle=linestyles[i], **kwargs)\n    elif plottype == 'scatter' or plottype == 's':\n        for (i, (values, group)) in enumerate(plot_data.groupby('trace')):\n            label = str(group['trace'].values[0])\n            ax.scatter(group['x'], group['response'], color=colors[i], label=label, marker=markers[i], **kwargs)\n    else:\n        raise ValueError('Plot type %s not understood' % plottype)\n    ax.legend(loc=legendloc, title=legendtitle)\n    ax.margins(0.1)\n    if all([x_levels, x_values]):\n        ax.set_xticks(x_values)\n        ax.set_xticklabels(x_levels)\n    return fig"
        ]
    },
    {
        "func_name": "_recode",
        "original": "def _recode(x, levels):\n    \"\"\" Recode categorial data to int factor.\n\n    Parameters\n    ----------\n    x : array_like\n        array like object supporting with numpy array methods of categorially\n        coded data.\n    levels : dict\n        mapping of labels to integer-codings\n\n    Returns\n    -------\n    out : instance numpy.ndarray\n    \"\"\"\n    from pandas import Series\n    name = None\n    index = None\n    if isinstance(x, Series):\n        name = x.name\n        index = x.index\n        x = x.values\n    if x.dtype.type not in [np.str_, np.object_]:\n        raise ValueError('This is not a categorial factor. Array of str type required.')\n    elif not isinstance(levels, dict):\n        raise ValueError('This is not a valid value for levels. Dict required.')\n    elif not (np.unique(x) == np.unique(list(levels.keys()))).all():\n        raise ValueError('The levels do not match the array values.')\n    else:\n        out = np.empty(x.shape[0], dtype=int)\n        for (level, coding) in levels.items():\n            out[x == level] = coding\n        if name:\n            out = Series(out, name=name, index=index)\n        return out",
        "mutated": [
            "def _recode(x, levels):\n    if False:\n        i = 10\n    ' Recode categorial data to int factor.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        array like object supporting with numpy array methods of categorially\\n        coded data.\\n    levels : dict\\n        mapping of labels to integer-codings\\n\\n    Returns\\n    -------\\n    out : instance numpy.ndarray\\n    '\n    from pandas import Series\n    name = None\n    index = None\n    if isinstance(x, Series):\n        name = x.name\n        index = x.index\n        x = x.values\n    if x.dtype.type not in [np.str_, np.object_]:\n        raise ValueError('This is not a categorial factor. Array of str type required.')\n    elif not isinstance(levels, dict):\n        raise ValueError('This is not a valid value for levels. Dict required.')\n    elif not (np.unique(x) == np.unique(list(levels.keys()))).all():\n        raise ValueError('The levels do not match the array values.')\n    else:\n        out = np.empty(x.shape[0], dtype=int)\n        for (level, coding) in levels.items():\n            out[x == level] = coding\n        if name:\n            out = Series(out, name=name, index=index)\n        return out",
            "def _recode(x, levels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Recode categorial data to int factor.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        array like object supporting with numpy array methods of categorially\\n        coded data.\\n    levels : dict\\n        mapping of labels to integer-codings\\n\\n    Returns\\n    -------\\n    out : instance numpy.ndarray\\n    '\n    from pandas import Series\n    name = None\n    index = None\n    if isinstance(x, Series):\n        name = x.name\n        index = x.index\n        x = x.values\n    if x.dtype.type not in [np.str_, np.object_]:\n        raise ValueError('This is not a categorial factor. Array of str type required.')\n    elif not isinstance(levels, dict):\n        raise ValueError('This is not a valid value for levels. Dict required.')\n    elif not (np.unique(x) == np.unique(list(levels.keys()))).all():\n        raise ValueError('The levels do not match the array values.')\n    else:\n        out = np.empty(x.shape[0], dtype=int)\n        for (level, coding) in levels.items():\n            out[x == level] = coding\n        if name:\n            out = Series(out, name=name, index=index)\n        return out",
            "def _recode(x, levels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Recode categorial data to int factor.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        array like object supporting with numpy array methods of categorially\\n        coded data.\\n    levels : dict\\n        mapping of labels to integer-codings\\n\\n    Returns\\n    -------\\n    out : instance numpy.ndarray\\n    '\n    from pandas import Series\n    name = None\n    index = None\n    if isinstance(x, Series):\n        name = x.name\n        index = x.index\n        x = x.values\n    if x.dtype.type not in [np.str_, np.object_]:\n        raise ValueError('This is not a categorial factor. Array of str type required.')\n    elif not isinstance(levels, dict):\n        raise ValueError('This is not a valid value for levels. Dict required.')\n    elif not (np.unique(x) == np.unique(list(levels.keys()))).all():\n        raise ValueError('The levels do not match the array values.')\n    else:\n        out = np.empty(x.shape[0], dtype=int)\n        for (level, coding) in levels.items():\n            out[x == level] = coding\n        if name:\n            out = Series(out, name=name, index=index)\n        return out",
            "def _recode(x, levels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Recode categorial data to int factor.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        array like object supporting with numpy array methods of categorially\\n        coded data.\\n    levels : dict\\n        mapping of labels to integer-codings\\n\\n    Returns\\n    -------\\n    out : instance numpy.ndarray\\n    '\n    from pandas import Series\n    name = None\n    index = None\n    if isinstance(x, Series):\n        name = x.name\n        index = x.index\n        x = x.values\n    if x.dtype.type not in [np.str_, np.object_]:\n        raise ValueError('This is not a categorial factor. Array of str type required.')\n    elif not isinstance(levels, dict):\n        raise ValueError('This is not a valid value for levels. Dict required.')\n    elif not (np.unique(x) == np.unique(list(levels.keys()))).all():\n        raise ValueError('The levels do not match the array values.')\n    else:\n        out = np.empty(x.shape[0], dtype=int)\n        for (level, coding) in levels.items():\n            out[x == level] = coding\n        if name:\n            out = Series(out, name=name, index=index)\n        return out",
            "def _recode(x, levels):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Recode categorial data to int factor.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        array like object supporting with numpy array methods of categorially\\n        coded data.\\n    levels : dict\\n        mapping of labels to integer-codings\\n\\n    Returns\\n    -------\\n    out : instance numpy.ndarray\\n    '\n    from pandas import Series\n    name = None\n    index = None\n    if isinstance(x, Series):\n        name = x.name\n        index = x.index\n        x = x.values\n    if x.dtype.type not in [np.str_, np.object_]:\n        raise ValueError('This is not a categorial factor. Array of str type required.')\n    elif not isinstance(levels, dict):\n        raise ValueError('This is not a valid value for levels. Dict required.')\n    elif not (np.unique(x) == np.unique(list(levels.keys()))).all():\n        raise ValueError('The levels do not match the array values.')\n    else:\n        out = np.empty(x.shape[0], dtype=int)\n        for (level, coding) in levels.items():\n            out[x == level] = coding\n        if name:\n            out = Series(out, name=name, index=index)\n        return out"
        ]
    }
]