[
    {
        "func_name": "current_flow_betweenness_centrality_subset",
        "original": "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_betweenness_centrality_subset(G, sources, targets, normalized=True, weight=None, dtype=float, solver='lu'):\n    \"\"\"Compute current-flow betweenness centrality for subsets of nodes.\n\n    Current-flow betweenness centrality uses an electrical current\n    model for information spreading in contrast to betweenness\n    centrality which uses shortest paths.\n\n    Current-flow betweenness centrality is also known as\n    random-walk betweenness centrality [2]_.\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph\n\n    sources: list of nodes\n      Nodes to use as sources for current\n\n    targets: list of nodes\n      Nodes to use as sinks for current\n\n    normalized : bool, optional (default=True)\n      If True the betweenness values are normalized by b=b/(n-1)(n-2) where\n      n is the number of nodes in G.\n\n    weight : string or None, optional (default=None)\n      Key for edge data used as the edge weight.\n      If None, then use 1 as each edge weight.\n      The weight reflects the capacity or the strength of the\n      edge.\n\n    dtype: data type (float)\n      Default data type for internal matrices.\n      Set to np.float32 for lower memory consumption.\n\n    solver: string (default='lu')\n       Type of linear solver to use for computing the flow matrix.\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\n       \"cg\" (uses least memory).\n\n    Returns\n    -------\n    nodes : dictionary\n       Dictionary of nodes with betweenness centrality as the value.\n\n    See Also\n    --------\n    approximate_current_flow_betweenness_centrality\n    betweenness_centrality\n    edge_betweenness_centrality\n    edge_current_flow_betweenness_centrality\n\n    Notes\n    -----\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\n    time [1]_, where $I(n-1)$ is the time needed to compute the\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\n    Laplacian matrix condition number.\n\n    The space required is $O(nw)$ where $w$ is the width of the sparse\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\n\n    If the edges have a 'weight' attribute they will be used as\n    weights in this algorithm.  Unspecified weights are set to 1.\n\n    References\n    ----------\n    .. [1] Centrality Measures Based on Current Flow.\n       Ulrik Brandes and Daniel Fleischer,\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS '05).\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\n       https://doi.org/10.1007/978-3-540-31856-9_44\n\n    .. [2] A measure of betweenness centrality based on random walks,\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\n    \"\"\"\n    import numpy as np\n    from networkx.utils import reverse_cuthill_mckee_ordering\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    mapping = dict(zip(ordering, range(n)))\n    H = nx.relabel_nodes(G, mapping)\n    betweenness = dict.fromkeys(H, 0.0)\n    for (row, (s, t)) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        for ss in sources:\n            i = mapping[ss]\n            for tt in targets:\n                j = mapping[tt]\n                betweenness[s] += 0.5 * np.abs(row[i] - row[j])\n                betweenness[t] += 0.5 * np.abs(row[i] - row[j])\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for v in H:\n        betweenness[v] = betweenness[v] / nb + 1.0 / (2 - n)\n    return {ordering[k]: v for (k, v) in betweenness.items()}",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_betweenness_centrality_subset(G, sources, targets, normalized=True, weight=None, dtype=float, solver='lu'):\n    if False:\n        i = 10\n    'Compute current-flow betweenness centrality for subsets of nodes.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    sources: list of nodes\\n      Nodes to use as sources for current\\n\\n    targets: list of nodes\\n      Nodes to use as sinks for current\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by b=b/(n-1)(n-2) where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype: data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver: string (default=\\'lu\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    approximate_current_flow_betweenness_centrality\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    edge_current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    import numpy as np\n    from networkx.utils import reverse_cuthill_mckee_ordering\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    mapping = dict(zip(ordering, range(n)))\n    H = nx.relabel_nodes(G, mapping)\n    betweenness = dict.fromkeys(H, 0.0)\n    for (row, (s, t)) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        for ss in sources:\n            i = mapping[ss]\n            for tt in targets:\n                j = mapping[tt]\n                betweenness[s] += 0.5 * np.abs(row[i] - row[j])\n                betweenness[t] += 0.5 * np.abs(row[i] - row[j])\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for v in H:\n        betweenness[v] = betweenness[v] / nb + 1.0 / (2 - n)\n    return {ordering[k]: v for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_betweenness_centrality_subset(G, sources, targets, normalized=True, weight=None, dtype=float, solver='lu'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute current-flow betweenness centrality for subsets of nodes.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    sources: list of nodes\\n      Nodes to use as sources for current\\n\\n    targets: list of nodes\\n      Nodes to use as sinks for current\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by b=b/(n-1)(n-2) where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype: data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver: string (default=\\'lu\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    approximate_current_flow_betweenness_centrality\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    edge_current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    import numpy as np\n    from networkx.utils import reverse_cuthill_mckee_ordering\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    mapping = dict(zip(ordering, range(n)))\n    H = nx.relabel_nodes(G, mapping)\n    betweenness = dict.fromkeys(H, 0.0)\n    for (row, (s, t)) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        for ss in sources:\n            i = mapping[ss]\n            for tt in targets:\n                j = mapping[tt]\n                betweenness[s] += 0.5 * np.abs(row[i] - row[j])\n                betweenness[t] += 0.5 * np.abs(row[i] - row[j])\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for v in H:\n        betweenness[v] = betweenness[v] / nb + 1.0 / (2 - n)\n    return {ordering[k]: v for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_betweenness_centrality_subset(G, sources, targets, normalized=True, weight=None, dtype=float, solver='lu'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute current-flow betweenness centrality for subsets of nodes.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    sources: list of nodes\\n      Nodes to use as sources for current\\n\\n    targets: list of nodes\\n      Nodes to use as sinks for current\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by b=b/(n-1)(n-2) where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype: data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver: string (default=\\'lu\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    approximate_current_flow_betweenness_centrality\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    edge_current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    import numpy as np\n    from networkx.utils import reverse_cuthill_mckee_ordering\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    mapping = dict(zip(ordering, range(n)))\n    H = nx.relabel_nodes(G, mapping)\n    betweenness = dict.fromkeys(H, 0.0)\n    for (row, (s, t)) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        for ss in sources:\n            i = mapping[ss]\n            for tt in targets:\n                j = mapping[tt]\n                betweenness[s] += 0.5 * np.abs(row[i] - row[j])\n                betweenness[t] += 0.5 * np.abs(row[i] - row[j])\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for v in H:\n        betweenness[v] = betweenness[v] / nb + 1.0 / (2 - n)\n    return {ordering[k]: v for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_betweenness_centrality_subset(G, sources, targets, normalized=True, weight=None, dtype=float, solver='lu'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute current-flow betweenness centrality for subsets of nodes.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    sources: list of nodes\\n      Nodes to use as sources for current\\n\\n    targets: list of nodes\\n      Nodes to use as sinks for current\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by b=b/(n-1)(n-2) where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype: data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver: string (default=\\'lu\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    approximate_current_flow_betweenness_centrality\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    edge_current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    import numpy as np\n    from networkx.utils import reverse_cuthill_mckee_ordering\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    mapping = dict(zip(ordering, range(n)))\n    H = nx.relabel_nodes(G, mapping)\n    betweenness = dict.fromkeys(H, 0.0)\n    for (row, (s, t)) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        for ss in sources:\n            i = mapping[ss]\n            for tt in targets:\n                j = mapping[tt]\n                betweenness[s] += 0.5 * np.abs(row[i] - row[j])\n                betweenness[t] += 0.5 * np.abs(row[i] - row[j])\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for v in H:\n        betweenness[v] = betweenness[v] / nb + 1.0 / (2 - n)\n    return {ordering[k]: v for (k, v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef current_flow_betweenness_centrality_subset(G, sources, targets, normalized=True, weight=None, dtype=float, solver='lu'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute current-flow betweenness centrality for subsets of nodes.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    sources: list of nodes\\n      Nodes to use as sources for current\\n\\n    targets: list of nodes\\n      Nodes to use as sinks for current\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by b=b/(n-1)(n-2) where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype: data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver: string (default=\\'lu\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dictionary\\n       Dictionary of nodes with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    approximate_current_flow_betweenness_centrality\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    edge_current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    import numpy as np\n    from networkx.utils import reverse_cuthill_mckee_ordering\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    mapping = dict(zip(ordering, range(n)))\n    H = nx.relabel_nodes(G, mapping)\n    betweenness = dict.fromkeys(H, 0.0)\n    for (row, (s, t)) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        for ss in sources:\n            i = mapping[ss]\n            for tt in targets:\n                j = mapping[tt]\n                betweenness[s] += 0.5 * np.abs(row[i] - row[j])\n                betweenness[t] += 0.5 * np.abs(row[i] - row[j])\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for v in H:\n        betweenness[v] = betweenness[v] / nb + 1.0 / (2 - n)\n    return {ordering[k]: v for (k, v) in betweenness.items()}"
        ]
    },
    {
        "func_name": "edge_current_flow_betweenness_centrality_subset",
        "original": "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef edge_current_flow_betweenness_centrality_subset(G, sources, targets, normalized=True, weight=None, dtype=float, solver='lu'):\n    \"\"\"Compute current-flow betweenness centrality for edges using subsets\n    of nodes.\n\n    Current-flow betweenness centrality uses an electrical current\n    model for information spreading in contrast to betweenness\n    centrality which uses shortest paths.\n\n    Current-flow betweenness centrality is also known as\n    random-walk betweenness centrality [2]_.\n\n    Parameters\n    ----------\n    G : graph\n      A NetworkX graph\n\n    sources: list of nodes\n      Nodes to use as sources for current\n\n    targets: list of nodes\n      Nodes to use as sinks for current\n\n    normalized : bool, optional (default=True)\n      If True the betweenness values are normalized by b=b/(n-1)(n-2) where\n      n is the number of nodes in G.\n\n    weight : string or None, optional (default=None)\n      Key for edge data used as the edge weight.\n      If None, then use 1 as each edge weight.\n      The weight reflects the capacity or the strength of the\n      edge.\n\n    dtype: data type (float)\n      Default data type for internal matrices.\n      Set to np.float32 for lower memory consumption.\n\n    solver: string (default='lu')\n       Type of linear solver to use for computing the flow matrix.\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\n       \"cg\" (uses least memory).\n\n    Returns\n    -------\n    nodes : dict\n       Dictionary of edge tuples with betweenness centrality as the value.\n\n    See Also\n    --------\n    betweenness_centrality\n    edge_betweenness_centrality\n    current_flow_betweenness_centrality\n\n    Notes\n    -----\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\n    time [1]_, where $I(n-1)$ is the time needed to compute the\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\n    Laplacian matrix condition number.\n\n    The space required is $O(nw)$ where $w$ is the width of the sparse\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\n\n    If the edges have a 'weight' attribute they will be used as\n    weights in this algorithm.  Unspecified weights are set to 1.\n\n    References\n    ----------\n    .. [1] Centrality Measures Based on Current Flow.\n       Ulrik Brandes and Daniel Fleischer,\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS '05).\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\n       https://doi.org/10.1007/978-3-540-31856-9_44\n\n    .. [2] A measure of betweenness centrality based on random walks,\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\n    \"\"\"\n    import numpy as np\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    mapping = dict(zip(ordering, range(n)))\n    H = nx.relabel_nodes(G, mapping)\n    edges = (tuple(sorted((u, v))) for (u, v) in H.edges())\n    betweenness = dict.fromkeys(edges, 0.0)\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for (row, e) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        for ss in sources:\n            i = mapping[ss]\n            for tt in targets:\n                j = mapping[tt]\n                betweenness[e] += 0.5 * np.abs(row[i] - row[j])\n        betweenness[e] /= nb\n    return {(ordering[s], ordering[t]): v for ((s, t), v) in betweenness.items()}",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef edge_current_flow_betweenness_centrality_subset(G, sources, targets, normalized=True, weight=None, dtype=float, solver='lu'):\n    if False:\n        i = 10\n    'Compute current-flow betweenness centrality for edges using subsets\\n    of nodes.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    sources: list of nodes\\n      Nodes to use as sources for current\\n\\n    targets: list of nodes\\n      Nodes to use as sinks for current\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by b=b/(n-1)(n-2) where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype: data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver: string (default=\\'lu\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dict\\n       Dictionary of edge tuples with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    import numpy as np\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    mapping = dict(zip(ordering, range(n)))\n    H = nx.relabel_nodes(G, mapping)\n    edges = (tuple(sorted((u, v))) for (u, v) in H.edges())\n    betweenness = dict.fromkeys(edges, 0.0)\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for (row, e) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        for ss in sources:\n            i = mapping[ss]\n            for tt in targets:\n                j = mapping[tt]\n                betweenness[e] += 0.5 * np.abs(row[i] - row[j])\n        betweenness[e] /= nb\n    return {(ordering[s], ordering[t]): v for ((s, t), v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef edge_current_flow_betweenness_centrality_subset(G, sources, targets, normalized=True, weight=None, dtype=float, solver='lu'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute current-flow betweenness centrality for edges using subsets\\n    of nodes.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    sources: list of nodes\\n      Nodes to use as sources for current\\n\\n    targets: list of nodes\\n      Nodes to use as sinks for current\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by b=b/(n-1)(n-2) where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype: data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver: string (default=\\'lu\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dict\\n       Dictionary of edge tuples with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    import numpy as np\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    mapping = dict(zip(ordering, range(n)))\n    H = nx.relabel_nodes(G, mapping)\n    edges = (tuple(sorted((u, v))) for (u, v) in H.edges())\n    betweenness = dict.fromkeys(edges, 0.0)\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for (row, e) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        for ss in sources:\n            i = mapping[ss]\n            for tt in targets:\n                j = mapping[tt]\n                betweenness[e] += 0.5 * np.abs(row[i] - row[j])\n        betweenness[e] /= nb\n    return {(ordering[s], ordering[t]): v for ((s, t), v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef edge_current_flow_betweenness_centrality_subset(G, sources, targets, normalized=True, weight=None, dtype=float, solver='lu'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute current-flow betweenness centrality for edges using subsets\\n    of nodes.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    sources: list of nodes\\n      Nodes to use as sources for current\\n\\n    targets: list of nodes\\n      Nodes to use as sinks for current\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by b=b/(n-1)(n-2) where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype: data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver: string (default=\\'lu\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dict\\n       Dictionary of edge tuples with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    import numpy as np\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    mapping = dict(zip(ordering, range(n)))\n    H = nx.relabel_nodes(G, mapping)\n    edges = (tuple(sorted((u, v))) for (u, v) in H.edges())\n    betweenness = dict.fromkeys(edges, 0.0)\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for (row, e) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        for ss in sources:\n            i = mapping[ss]\n            for tt in targets:\n                j = mapping[tt]\n                betweenness[e] += 0.5 * np.abs(row[i] - row[j])\n        betweenness[e] /= nb\n    return {(ordering[s], ordering[t]): v for ((s, t), v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef edge_current_flow_betweenness_centrality_subset(G, sources, targets, normalized=True, weight=None, dtype=float, solver='lu'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute current-flow betweenness centrality for edges using subsets\\n    of nodes.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    sources: list of nodes\\n      Nodes to use as sources for current\\n\\n    targets: list of nodes\\n      Nodes to use as sinks for current\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by b=b/(n-1)(n-2) where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype: data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver: string (default=\\'lu\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dict\\n       Dictionary of edge tuples with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    import numpy as np\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    mapping = dict(zip(ordering, range(n)))\n    H = nx.relabel_nodes(G, mapping)\n    edges = (tuple(sorted((u, v))) for (u, v) in H.edges())\n    betweenness = dict.fromkeys(edges, 0.0)\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for (row, e) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        for ss in sources:\n            i = mapping[ss]\n            for tt in targets:\n                j = mapping[tt]\n                betweenness[e] += 0.5 * np.abs(row[i] - row[j])\n        betweenness[e] /= nb\n    return {(ordering[s], ordering[t]): v for ((s, t), v) in betweenness.items()}",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs='weight')\ndef edge_current_flow_betweenness_centrality_subset(G, sources, targets, normalized=True, weight=None, dtype=float, solver='lu'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute current-flow betweenness centrality for edges using subsets\\n    of nodes.\\n\\n    Current-flow betweenness centrality uses an electrical current\\n    model for information spreading in contrast to betweenness\\n    centrality which uses shortest paths.\\n\\n    Current-flow betweenness centrality is also known as\\n    random-walk betweenness centrality [2]_.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n      A NetworkX graph\\n\\n    sources: list of nodes\\n      Nodes to use as sources for current\\n\\n    targets: list of nodes\\n      Nodes to use as sinks for current\\n\\n    normalized : bool, optional (default=True)\\n      If True the betweenness values are normalized by b=b/(n-1)(n-2) where\\n      n is the number of nodes in G.\\n\\n    weight : string or None, optional (default=None)\\n      Key for edge data used as the edge weight.\\n      If None, then use 1 as each edge weight.\\n      The weight reflects the capacity or the strength of the\\n      edge.\\n\\n    dtype: data type (float)\\n      Default data type for internal matrices.\\n      Set to np.float32 for lower memory consumption.\\n\\n    solver: string (default=\\'lu\\')\\n       Type of linear solver to use for computing the flow matrix.\\n       Options are \"full\" (uses most memory), \"lu\" (recommended), and\\n       \"cg\" (uses least memory).\\n\\n    Returns\\n    -------\\n    nodes : dict\\n       Dictionary of edge tuples with betweenness centrality as the value.\\n\\n    See Also\\n    --------\\n    betweenness_centrality\\n    edge_betweenness_centrality\\n    current_flow_betweenness_centrality\\n\\n    Notes\\n    -----\\n    Current-flow betweenness can be computed in $O(I(n-1)+mn \\\\log n)$\\n    time [1]_, where $I(n-1)$ is the time needed to compute the\\n    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using\\n    sparse methods you can achieve $O(nm{\\\\sqrt k})$ where $k$ is the\\n    Laplacian matrix condition number.\\n\\n    The space required is $O(nw)$ where $w$ is the width of the sparse\\n    Laplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\\n\\n    If the edges have a \\'weight\\' attribute they will be used as\\n    weights in this algorithm.  Unspecified weights are set to 1.\\n\\n    References\\n    ----------\\n    .. [1] Centrality Measures Based on Current Flow.\\n       Ulrik Brandes and Daniel Fleischer,\\n       Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \\'05).\\n       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\\n       https://doi.org/10.1007/978-3-540-31856-9_44\\n\\n    .. [2] A measure of betweenness centrality based on random walks,\\n       M. E. J. Newman, Social Networks 27, 39-54 (2005).\\n    '\n    import numpy as np\n    if not nx.is_connected(G):\n        raise nx.NetworkXError('Graph not connected.')\n    n = G.number_of_nodes()\n    ordering = list(reverse_cuthill_mckee_ordering(G))\n    mapping = dict(zip(ordering, range(n)))\n    H = nx.relabel_nodes(G, mapping)\n    edges = (tuple(sorted((u, v))) for (u, v) in H.edges())\n    betweenness = dict.fromkeys(edges, 0.0)\n    if normalized:\n        nb = (n - 1.0) * (n - 2.0)\n    else:\n        nb = 2.0\n    for (row, e) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):\n        for ss in sources:\n            i = mapping[ss]\n            for tt in targets:\n                j = mapping[tt]\n                betweenness[e] += 0.5 * np.abs(row[i] - row[j])\n        betweenness[e] /= nb\n    return {(ordering[s], ordering[t]): v for ((s, t), v) in betweenness.items()}"
        ]
    }
]