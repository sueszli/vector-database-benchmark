[
    {
        "func_name": "_make_index",
        "original": "def _make_index(prob, size):\n    \"\"\"\n    Returns a boolean index for given probabilities.\n\n    Notes\n    -----\n    prob = [.75,.25] means that there is a 75% chance of the first column\n    being True and a 25% chance of the second column being True. The\n    columns are mutually exclusive.\n    \"\"\"\n    rv = np.random.uniform(size=(size, 1))\n    cumprob = np.cumsum(prob)\n    return np.logical_and(np.r_[0, cumprob[:-1]] <= rv, rv < cumprob)",
        "mutated": [
            "def _make_index(prob, size):\n    if False:\n        i = 10\n    '\\n    Returns a boolean index for given probabilities.\\n\\n    Notes\\n    -----\\n    prob = [.75,.25] means that there is a 75% chance of the first column\\n    being True and a 25% chance of the second column being True. The\\n    columns are mutually exclusive.\\n    '\n    rv = np.random.uniform(size=(size, 1))\n    cumprob = np.cumsum(prob)\n    return np.logical_and(np.r_[0, cumprob[:-1]] <= rv, rv < cumprob)",
            "def _make_index(prob, size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns a boolean index for given probabilities.\\n\\n    Notes\\n    -----\\n    prob = [.75,.25] means that there is a 75% chance of the first column\\n    being True and a 25% chance of the second column being True. The\\n    columns are mutually exclusive.\\n    '\n    rv = np.random.uniform(size=(size, 1))\n    cumprob = np.cumsum(prob)\n    return np.logical_and(np.r_[0, cumprob[:-1]] <= rv, rv < cumprob)",
            "def _make_index(prob, size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns a boolean index for given probabilities.\\n\\n    Notes\\n    -----\\n    prob = [.75,.25] means that there is a 75% chance of the first column\\n    being True and a 25% chance of the second column being True. The\\n    columns are mutually exclusive.\\n    '\n    rv = np.random.uniform(size=(size, 1))\n    cumprob = np.cumsum(prob)\n    return np.logical_and(np.r_[0, cumprob[:-1]] <= rv, rv < cumprob)",
            "def _make_index(prob, size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns a boolean index for given probabilities.\\n\\n    Notes\\n    -----\\n    prob = [.75,.25] means that there is a 75% chance of the first column\\n    being True and a 25% chance of the second column being True. The\\n    columns are mutually exclusive.\\n    '\n    rv = np.random.uniform(size=(size, 1))\n    cumprob = np.cumsum(prob)\n    return np.logical_and(np.r_[0, cumprob[:-1]] <= rv, rv < cumprob)",
            "def _make_index(prob, size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns a boolean index for given probabilities.\\n\\n    Notes\\n    -----\\n    prob = [.75,.25] means that there is a 75% chance of the first column\\n    being True and a 25% chance of the second column being True. The\\n    columns are mutually exclusive.\\n    '\n    rv = np.random.uniform(size=(size, 1))\n    cumprob = np.cumsum(prob)\n    return np.logical_and(np.r_[0, cumprob[:-1]] <= rv, rv < cumprob)"
        ]
    },
    {
        "func_name": "mixture_rvs",
        "original": "def mixture_rvs(prob, size, dist, kwargs=None):\n    \"\"\"\n    Sample from a mixture of distributions.\n\n    Parameters\n    ----------\n    prob : array_like\n        Probability of sampling from each distribution in dist\n    size : int\n        The length of the returned sample.\n    dist : array_like\n        An iterable of distributions objects from scipy.stats.\n    kwargs : tuple of dicts, optional\n        A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\n        args to be passed to the respective distribution in dist.  If not\n        provided, the distribution defaults are used.\n\n    Examples\n    --------\n    Say we want 5000 random variables from mixture of normals with two\n    distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\n    first with probability .75 and the second with probability .25.\n\n    >>> from scipy import stats\n    >>> prob = [.75,.25]\n    >>> Y = mixture_rvs(prob, 5000, dist=[stats.norm, stats.norm],\n    ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\n    \"\"\"\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    idx = _make_index(prob, size)\n    sample = np.empty(size)\n    for i in range(len(prob)):\n        sample_idx = idx[..., i]\n        sample_size = sample_idx.sum()\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        sample[sample_idx] = dist[i].rvs(*args, **dict(loc=loc, scale=scale, size=sample_size))\n    return sample",
        "mutated": [
            "def mixture_rvs(prob, size, dist, kwargs=None):\n    if False:\n        i = 10\n    '\\n    Sample from a mixture of distributions.\\n\\n    Parameters\\n    ----------\\n    prob : array_like\\n        Probability of sampling from each distribution in dist\\n    size : int\\n        The length of the returned sample.\\n    dist : array_like\\n        An iterable of distributions objects from scipy.stats.\\n    kwargs : tuple of dicts, optional\\n        A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\\n        args to be passed to the respective distribution in dist.  If not\\n        provided, the distribution defaults are used.\\n\\n    Examples\\n    --------\\n    Say we want 5000 random variables from mixture of normals with two\\n    distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\\n    first with probability .75 and the second with probability .25.\\n\\n    >>> from scipy import stats\\n    >>> prob = [.75,.25]\\n    >>> Y = mixture_rvs(prob, 5000, dist=[stats.norm, stats.norm],\\n    ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\\n    '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    idx = _make_index(prob, size)\n    sample = np.empty(size)\n    for i in range(len(prob)):\n        sample_idx = idx[..., i]\n        sample_size = sample_idx.sum()\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        sample[sample_idx] = dist[i].rvs(*args, **dict(loc=loc, scale=scale, size=sample_size))\n    return sample",
            "def mixture_rvs(prob, size, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Sample from a mixture of distributions.\\n\\n    Parameters\\n    ----------\\n    prob : array_like\\n        Probability of sampling from each distribution in dist\\n    size : int\\n        The length of the returned sample.\\n    dist : array_like\\n        An iterable of distributions objects from scipy.stats.\\n    kwargs : tuple of dicts, optional\\n        A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\\n        args to be passed to the respective distribution in dist.  If not\\n        provided, the distribution defaults are used.\\n\\n    Examples\\n    --------\\n    Say we want 5000 random variables from mixture of normals with two\\n    distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\\n    first with probability .75 and the second with probability .25.\\n\\n    >>> from scipy import stats\\n    >>> prob = [.75,.25]\\n    >>> Y = mixture_rvs(prob, 5000, dist=[stats.norm, stats.norm],\\n    ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\\n    '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    idx = _make_index(prob, size)\n    sample = np.empty(size)\n    for i in range(len(prob)):\n        sample_idx = idx[..., i]\n        sample_size = sample_idx.sum()\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        sample[sample_idx] = dist[i].rvs(*args, **dict(loc=loc, scale=scale, size=sample_size))\n    return sample",
            "def mixture_rvs(prob, size, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Sample from a mixture of distributions.\\n\\n    Parameters\\n    ----------\\n    prob : array_like\\n        Probability of sampling from each distribution in dist\\n    size : int\\n        The length of the returned sample.\\n    dist : array_like\\n        An iterable of distributions objects from scipy.stats.\\n    kwargs : tuple of dicts, optional\\n        A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\\n        args to be passed to the respective distribution in dist.  If not\\n        provided, the distribution defaults are used.\\n\\n    Examples\\n    --------\\n    Say we want 5000 random variables from mixture of normals with two\\n    distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\\n    first with probability .75 and the second with probability .25.\\n\\n    >>> from scipy import stats\\n    >>> prob = [.75,.25]\\n    >>> Y = mixture_rvs(prob, 5000, dist=[stats.norm, stats.norm],\\n    ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\\n    '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    idx = _make_index(prob, size)\n    sample = np.empty(size)\n    for i in range(len(prob)):\n        sample_idx = idx[..., i]\n        sample_size = sample_idx.sum()\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        sample[sample_idx] = dist[i].rvs(*args, **dict(loc=loc, scale=scale, size=sample_size))\n    return sample",
            "def mixture_rvs(prob, size, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Sample from a mixture of distributions.\\n\\n    Parameters\\n    ----------\\n    prob : array_like\\n        Probability of sampling from each distribution in dist\\n    size : int\\n        The length of the returned sample.\\n    dist : array_like\\n        An iterable of distributions objects from scipy.stats.\\n    kwargs : tuple of dicts, optional\\n        A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\\n        args to be passed to the respective distribution in dist.  If not\\n        provided, the distribution defaults are used.\\n\\n    Examples\\n    --------\\n    Say we want 5000 random variables from mixture of normals with two\\n    distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\\n    first with probability .75 and the second with probability .25.\\n\\n    >>> from scipy import stats\\n    >>> prob = [.75,.25]\\n    >>> Y = mixture_rvs(prob, 5000, dist=[stats.norm, stats.norm],\\n    ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\\n    '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    idx = _make_index(prob, size)\n    sample = np.empty(size)\n    for i in range(len(prob)):\n        sample_idx = idx[..., i]\n        sample_size = sample_idx.sum()\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        sample[sample_idx] = dist[i].rvs(*args, **dict(loc=loc, scale=scale, size=sample_size))\n    return sample",
            "def mixture_rvs(prob, size, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Sample from a mixture of distributions.\\n\\n    Parameters\\n    ----------\\n    prob : array_like\\n        Probability of sampling from each distribution in dist\\n    size : int\\n        The length of the returned sample.\\n    dist : array_like\\n        An iterable of distributions objects from scipy.stats.\\n    kwargs : tuple of dicts, optional\\n        A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\\n        args to be passed to the respective distribution in dist.  If not\\n        provided, the distribution defaults are used.\\n\\n    Examples\\n    --------\\n    Say we want 5000 random variables from mixture of normals with two\\n    distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\\n    first with probability .75 and the second with probability .25.\\n\\n    >>> from scipy import stats\\n    >>> prob = [.75,.25]\\n    >>> Y = mixture_rvs(prob, 5000, dist=[stats.norm, stats.norm],\\n    ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\\n    '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    idx = _make_index(prob, size)\n    sample = np.empty(size)\n    for i in range(len(prob)):\n        sample_idx = idx[..., i]\n        sample_size = sample_idx.sum()\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        sample[sample_idx] = dist[i].rvs(*args, **dict(loc=loc, scale=scale, size=sample_size))\n    return sample"
        ]
    },
    {
        "func_name": "rvs",
        "original": "def rvs(self, prob, size, dist, kwargs=None):\n    return mixture_rvs(prob, size, dist, kwargs=kwargs)",
        "mutated": [
            "def rvs(self, prob, size, dist, kwargs=None):\n    if False:\n        i = 10\n    return mixture_rvs(prob, size, dist, kwargs=kwargs)",
            "def rvs(self, prob, size, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return mixture_rvs(prob, size, dist, kwargs=kwargs)",
            "def rvs(self, prob, size, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return mixture_rvs(prob, size, dist, kwargs=kwargs)",
            "def rvs(self, prob, size, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return mixture_rvs(prob, size, dist, kwargs=kwargs)",
            "def rvs(self, prob, size, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return mixture_rvs(prob, size, dist, kwargs=kwargs)"
        ]
    },
    {
        "func_name": "pdf",
        "original": "def pdf(self, x, prob, dist, kwargs=None):\n    \"\"\"\n        pdf a mixture of distributions.\n\n        Parameters\n        ----------\n        x : array_like\n            Array containing locations where the PDF should be evaluated\n        prob : array_like\n            Probability of sampling from each distribution in dist\n        dist : array_like\n            An iterable of distributions objects from scipy.stats.\n        kwargs : tuple of dicts, optional\n            A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\n            args to be passed to the respective distribution in dist.  If not\n            provided, the distribution defaults are used.\n\n        Examples\n        --------\n        Say we want 5000 random variables from mixture of normals with two\n        distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\n        first with probability .75 and the second with probability .25.\n\n        >>> import numpy as np\n        >>> from scipy import stats\n        >>> from statsmodels.distributions.mixture_rvs import MixtureDistribution\n        >>> x = np.arange(-4.0, 4.0, 0.01)\n        >>> prob = [.75,.25]\n        >>> mixture = MixtureDistribution()\n        >>> Y = mixture.pdf(x, prob, dist=[stats.norm, stats.norm],\n        ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\n        \"\"\"\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    for i in range(len(prob)):\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        if i == 0:\n            pdf_ = prob[i] * dist[i].pdf(x, *args, loc=loc, scale=scale)\n        else:\n            pdf_ += prob[i] * dist[i].pdf(x, *args, loc=loc, scale=scale)\n    return pdf_",
        "mutated": [
            "def pdf(self, x, prob, dist, kwargs=None):\n    if False:\n        i = 10\n    '\\n        pdf a mixture of distributions.\\n\\n        Parameters\\n        ----------\\n        x : array_like\\n            Array containing locations where the PDF should be evaluated\\n        prob : array_like\\n            Probability of sampling from each distribution in dist\\n        dist : array_like\\n            An iterable of distributions objects from scipy.stats.\\n        kwargs : tuple of dicts, optional\\n            A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\\n            args to be passed to the respective distribution in dist.  If not\\n            provided, the distribution defaults are used.\\n\\n        Examples\\n        --------\\n        Say we want 5000 random variables from mixture of normals with two\\n        distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\\n        first with probability .75 and the second with probability .25.\\n\\n        >>> import numpy as np\\n        >>> from scipy import stats\\n        >>> from statsmodels.distributions.mixture_rvs import MixtureDistribution\\n        >>> x = np.arange(-4.0, 4.0, 0.01)\\n        >>> prob = [.75,.25]\\n        >>> mixture = MixtureDistribution()\\n        >>> Y = mixture.pdf(x, prob, dist=[stats.norm, stats.norm],\\n        ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\\n        '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    for i in range(len(prob)):\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        if i == 0:\n            pdf_ = prob[i] * dist[i].pdf(x, *args, loc=loc, scale=scale)\n        else:\n            pdf_ += prob[i] * dist[i].pdf(x, *args, loc=loc, scale=scale)\n    return pdf_",
            "def pdf(self, x, prob, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        pdf a mixture of distributions.\\n\\n        Parameters\\n        ----------\\n        x : array_like\\n            Array containing locations where the PDF should be evaluated\\n        prob : array_like\\n            Probability of sampling from each distribution in dist\\n        dist : array_like\\n            An iterable of distributions objects from scipy.stats.\\n        kwargs : tuple of dicts, optional\\n            A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\\n            args to be passed to the respective distribution in dist.  If not\\n            provided, the distribution defaults are used.\\n\\n        Examples\\n        --------\\n        Say we want 5000 random variables from mixture of normals with two\\n        distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\\n        first with probability .75 and the second with probability .25.\\n\\n        >>> import numpy as np\\n        >>> from scipy import stats\\n        >>> from statsmodels.distributions.mixture_rvs import MixtureDistribution\\n        >>> x = np.arange(-4.0, 4.0, 0.01)\\n        >>> prob = [.75,.25]\\n        >>> mixture = MixtureDistribution()\\n        >>> Y = mixture.pdf(x, prob, dist=[stats.norm, stats.norm],\\n        ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\\n        '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    for i in range(len(prob)):\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        if i == 0:\n            pdf_ = prob[i] * dist[i].pdf(x, *args, loc=loc, scale=scale)\n        else:\n            pdf_ += prob[i] * dist[i].pdf(x, *args, loc=loc, scale=scale)\n    return pdf_",
            "def pdf(self, x, prob, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        pdf a mixture of distributions.\\n\\n        Parameters\\n        ----------\\n        x : array_like\\n            Array containing locations where the PDF should be evaluated\\n        prob : array_like\\n            Probability of sampling from each distribution in dist\\n        dist : array_like\\n            An iterable of distributions objects from scipy.stats.\\n        kwargs : tuple of dicts, optional\\n            A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\\n            args to be passed to the respective distribution in dist.  If not\\n            provided, the distribution defaults are used.\\n\\n        Examples\\n        --------\\n        Say we want 5000 random variables from mixture of normals with two\\n        distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\\n        first with probability .75 and the second with probability .25.\\n\\n        >>> import numpy as np\\n        >>> from scipy import stats\\n        >>> from statsmodels.distributions.mixture_rvs import MixtureDistribution\\n        >>> x = np.arange(-4.0, 4.0, 0.01)\\n        >>> prob = [.75,.25]\\n        >>> mixture = MixtureDistribution()\\n        >>> Y = mixture.pdf(x, prob, dist=[stats.norm, stats.norm],\\n        ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\\n        '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    for i in range(len(prob)):\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        if i == 0:\n            pdf_ = prob[i] * dist[i].pdf(x, *args, loc=loc, scale=scale)\n        else:\n            pdf_ += prob[i] * dist[i].pdf(x, *args, loc=loc, scale=scale)\n    return pdf_",
            "def pdf(self, x, prob, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        pdf a mixture of distributions.\\n\\n        Parameters\\n        ----------\\n        x : array_like\\n            Array containing locations where the PDF should be evaluated\\n        prob : array_like\\n            Probability of sampling from each distribution in dist\\n        dist : array_like\\n            An iterable of distributions objects from scipy.stats.\\n        kwargs : tuple of dicts, optional\\n            A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\\n            args to be passed to the respective distribution in dist.  If not\\n            provided, the distribution defaults are used.\\n\\n        Examples\\n        --------\\n        Say we want 5000 random variables from mixture of normals with two\\n        distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\\n        first with probability .75 and the second with probability .25.\\n\\n        >>> import numpy as np\\n        >>> from scipy import stats\\n        >>> from statsmodels.distributions.mixture_rvs import MixtureDistribution\\n        >>> x = np.arange(-4.0, 4.0, 0.01)\\n        >>> prob = [.75,.25]\\n        >>> mixture = MixtureDistribution()\\n        >>> Y = mixture.pdf(x, prob, dist=[stats.norm, stats.norm],\\n        ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\\n        '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    for i in range(len(prob)):\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        if i == 0:\n            pdf_ = prob[i] * dist[i].pdf(x, *args, loc=loc, scale=scale)\n        else:\n            pdf_ += prob[i] * dist[i].pdf(x, *args, loc=loc, scale=scale)\n    return pdf_",
            "def pdf(self, x, prob, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        pdf a mixture of distributions.\\n\\n        Parameters\\n        ----------\\n        x : array_like\\n            Array containing locations where the PDF should be evaluated\\n        prob : array_like\\n            Probability of sampling from each distribution in dist\\n        dist : array_like\\n            An iterable of distributions objects from scipy.stats.\\n        kwargs : tuple of dicts, optional\\n            A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\\n            args to be passed to the respective distribution in dist.  If not\\n            provided, the distribution defaults are used.\\n\\n        Examples\\n        --------\\n        Say we want 5000 random variables from mixture of normals with two\\n        distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\\n        first with probability .75 and the second with probability .25.\\n\\n        >>> import numpy as np\\n        >>> from scipy import stats\\n        >>> from statsmodels.distributions.mixture_rvs import MixtureDistribution\\n        >>> x = np.arange(-4.0, 4.0, 0.01)\\n        >>> prob = [.75,.25]\\n        >>> mixture = MixtureDistribution()\\n        >>> Y = mixture.pdf(x, prob, dist=[stats.norm, stats.norm],\\n        ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\\n        '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    for i in range(len(prob)):\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        if i == 0:\n            pdf_ = prob[i] * dist[i].pdf(x, *args, loc=loc, scale=scale)\n        else:\n            pdf_ += prob[i] * dist[i].pdf(x, *args, loc=loc, scale=scale)\n    return pdf_"
        ]
    },
    {
        "func_name": "cdf",
        "original": "def cdf(self, x, prob, dist, kwargs=None):\n    \"\"\"\n        cdf of a mixture of distributions.\n\n        Parameters\n        ----------\n        x : array_like\n            Array containing locations where the CDF should be evaluated\n        prob : array_like\n            Probability of sampling from each distribution in dist\n        size : int\n            The length of the returned sample.\n        dist : array_like\n            An iterable of distributions objects from scipy.stats.\n        kwargs : tuple of dicts, optional\n            A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\n            args to be passed to the respective distribution in dist.  If not\n            provided, the distribution defaults are used.\n\n        Examples\n        --------\n        Say we want 5000 random variables from mixture of normals with two\n        distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\n        first with probability .75 and the second with probability .25.\n\n        >>> import numpy as np\n        >>> from scipy import stats\n        >>> from statsmodels.distributions.mixture_rvs import MixtureDistribution\n        >>> x = np.arange(-4.0, 4.0, 0.01)\n        >>> prob = [.75,.25]\n        >>> mixture = MixtureDistribution()\n        >>> Y = mixture.pdf(x, prob, dist=[stats.norm, stats.norm],\n        ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\n        \"\"\"\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    for i in range(len(prob)):\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        if i == 0:\n            cdf_ = prob[i] * dist[i].cdf(x, *args, loc=loc, scale=scale)\n        else:\n            cdf_ += prob[i] * dist[i].cdf(x, *args, loc=loc, scale=scale)\n    return cdf_",
        "mutated": [
            "def cdf(self, x, prob, dist, kwargs=None):\n    if False:\n        i = 10\n    '\\n        cdf of a mixture of distributions.\\n\\n        Parameters\\n        ----------\\n        x : array_like\\n            Array containing locations where the CDF should be evaluated\\n        prob : array_like\\n            Probability of sampling from each distribution in dist\\n        size : int\\n            The length of the returned sample.\\n        dist : array_like\\n            An iterable of distributions objects from scipy.stats.\\n        kwargs : tuple of dicts, optional\\n            A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\\n            args to be passed to the respective distribution in dist.  If not\\n            provided, the distribution defaults are used.\\n\\n        Examples\\n        --------\\n        Say we want 5000 random variables from mixture of normals with two\\n        distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\\n        first with probability .75 and the second with probability .25.\\n\\n        >>> import numpy as np\\n        >>> from scipy import stats\\n        >>> from statsmodels.distributions.mixture_rvs import MixtureDistribution\\n        >>> x = np.arange(-4.0, 4.0, 0.01)\\n        >>> prob = [.75,.25]\\n        >>> mixture = MixtureDistribution()\\n        >>> Y = mixture.pdf(x, prob, dist=[stats.norm, stats.norm],\\n        ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\\n        '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    for i in range(len(prob)):\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        if i == 0:\n            cdf_ = prob[i] * dist[i].cdf(x, *args, loc=loc, scale=scale)\n        else:\n            cdf_ += prob[i] * dist[i].cdf(x, *args, loc=loc, scale=scale)\n    return cdf_",
            "def cdf(self, x, prob, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        cdf of a mixture of distributions.\\n\\n        Parameters\\n        ----------\\n        x : array_like\\n            Array containing locations where the CDF should be evaluated\\n        prob : array_like\\n            Probability of sampling from each distribution in dist\\n        size : int\\n            The length of the returned sample.\\n        dist : array_like\\n            An iterable of distributions objects from scipy.stats.\\n        kwargs : tuple of dicts, optional\\n            A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\\n            args to be passed to the respective distribution in dist.  If not\\n            provided, the distribution defaults are used.\\n\\n        Examples\\n        --------\\n        Say we want 5000 random variables from mixture of normals with two\\n        distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\\n        first with probability .75 and the second with probability .25.\\n\\n        >>> import numpy as np\\n        >>> from scipy import stats\\n        >>> from statsmodels.distributions.mixture_rvs import MixtureDistribution\\n        >>> x = np.arange(-4.0, 4.0, 0.01)\\n        >>> prob = [.75,.25]\\n        >>> mixture = MixtureDistribution()\\n        >>> Y = mixture.pdf(x, prob, dist=[stats.norm, stats.norm],\\n        ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\\n        '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    for i in range(len(prob)):\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        if i == 0:\n            cdf_ = prob[i] * dist[i].cdf(x, *args, loc=loc, scale=scale)\n        else:\n            cdf_ += prob[i] * dist[i].cdf(x, *args, loc=loc, scale=scale)\n    return cdf_",
            "def cdf(self, x, prob, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        cdf of a mixture of distributions.\\n\\n        Parameters\\n        ----------\\n        x : array_like\\n            Array containing locations where the CDF should be evaluated\\n        prob : array_like\\n            Probability of sampling from each distribution in dist\\n        size : int\\n            The length of the returned sample.\\n        dist : array_like\\n            An iterable of distributions objects from scipy.stats.\\n        kwargs : tuple of dicts, optional\\n            A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\\n            args to be passed to the respective distribution in dist.  If not\\n            provided, the distribution defaults are used.\\n\\n        Examples\\n        --------\\n        Say we want 5000 random variables from mixture of normals with two\\n        distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\\n        first with probability .75 and the second with probability .25.\\n\\n        >>> import numpy as np\\n        >>> from scipy import stats\\n        >>> from statsmodels.distributions.mixture_rvs import MixtureDistribution\\n        >>> x = np.arange(-4.0, 4.0, 0.01)\\n        >>> prob = [.75,.25]\\n        >>> mixture = MixtureDistribution()\\n        >>> Y = mixture.pdf(x, prob, dist=[stats.norm, stats.norm],\\n        ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\\n        '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    for i in range(len(prob)):\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        if i == 0:\n            cdf_ = prob[i] * dist[i].cdf(x, *args, loc=loc, scale=scale)\n        else:\n            cdf_ += prob[i] * dist[i].cdf(x, *args, loc=loc, scale=scale)\n    return cdf_",
            "def cdf(self, x, prob, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        cdf of a mixture of distributions.\\n\\n        Parameters\\n        ----------\\n        x : array_like\\n            Array containing locations where the CDF should be evaluated\\n        prob : array_like\\n            Probability of sampling from each distribution in dist\\n        size : int\\n            The length of the returned sample.\\n        dist : array_like\\n            An iterable of distributions objects from scipy.stats.\\n        kwargs : tuple of dicts, optional\\n            A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\\n            args to be passed to the respective distribution in dist.  If not\\n            provided, the distribution defaults are used.\\n\\n        Examples\\n        --------\\n        Say we want 5000 random variables from mixture of normals with two\\n        distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\\n        first with probability .75 and the second with probability .25.\\n\\n        >>> import numpy as np\\n        >>> from scipy import stats\\n        >>> from statsmodels.distributions.mixture_rvs import MixtureDistribution\\n        >>> x = np.arange(-4.0, 4.0, 0.01)\\n        >>> prob = [.75,.25]\\n        >>> mixture = MixtureDistribution()\\n        >>> Y = mixture.pdf(x, prob, dist=[stats.norm, stats.norm],\\n        ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\\n        '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    for i in range(len(prob)):\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        if i == 0:\n            cdf_ = prob[i] * dist[i].cdf(x, *args, loc=loc, scale=scale)\n        else:\n            cdf_ += prob[i] * dist[i].cdf(x, *args, loc=loc, scale=scale)\n    return cdf_",
            "def cdf(self, x, prob, dist, kwargs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        cdf of a mixture of distributions.\\n\\n        Parameters\\n        ----------\\n        x : array_like\\n            Array containing locations where the CDF should be evaluated\\n        prob : array_like\\n            Probability of sampling from each distribution in dist\\n        size : int\\n            The length of the returned sample.\\n        dist : array_like\\n            An iterable of distributions objects from scipy.stats.\\n        kwargs : tuple of dicts, optional\\n            A tuple of dicts.  Each dict in kwargs can have keys loc, scale, and\\n            args to be passed to the respective distribution in dist.  If not\\n            provided, the distribution defaults are used.\\n\\n        Examples\\n        --------\\n        Say we want 5000 random variables from mixture of normals with two\\n        distributions norm(-1,.5) and norm(1,.5) and we want to sample from the\\n        first with probability .75 and the second with probability .25.\\n\\n        >>> import numpy as np\\n        >>> from scipy import stats\\n        >>> from statsmodels.distributions.mixture_rvs import MixtureDistribution\\n        >>> x = np.arange(-4.0, 4.0, 0.01)\\n        >>> prob = [.75,.25]\\n        >>> mixture = MixtureDistribution()\\n        >>> Y = mixture.pdf(x, prob, dist=[stats.norm, stats.norm],\\n        ...                 kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.5)))\\n        '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    for i in range(len(prob)):\n        loc = kwargs[i].get('loc', 0)\n        scale = kwargs[i].get('scale', 1)\n        args = kwargs[i].get('args', ())\n        if i == 0:\n            cdf_ = prob[i] * dist[i].cdf(x, *args, loc=loc, scale=scale)\n        else:\n            cdf_ += prob[i] * dist[i].cdf(x, *args, loc=loc, scale=scale)\n    return cdf_"
        ]
    },
    {
        "func_name": "mv_mixture_rvs",
        "original": "def mv_mixture_rvs(prob, size, dist, nvars, **kwargs):\n    \"\"\"\n    Sample from a mixture of multivariate distributions.\n\n    Parameters\n    ----------\n    prob : array_like\n        Probability of sampling from each distribution in dist\n    size : int\n        The length of the returned sample.\n    dist : array_like\n        An iterable of distributions instances with callable method rvs.\n    nvargs : int\n        dimension of the multivariate distribution, could be inferred instead\n    kwargs : tuple of dicts, optional\n        ignored\n\n    Examples\n    --------\n    Say we want 2000 random variables from mixture of normals with two\n    multivariate normal distributions, and we want to sample from the\n    first with probability .4 and the second with probability .6.\n\n    import statsmodels.sandbox.distributions.mv_normal as mvd\n\n    cov3 = np.array([[ 1.  ,  0.5 ,  0.75],\n                       [ 0.5 ,  1.5 ,  0.6 ],\n                       [ 0.75,  0.6 ,  2.  ]])\n\n    mu = np.array([-1, 0.0, 2.0])\n    mu2 = np.array([4, 2.0, 2.0])\n    mvn3 = mvd.MVNormal(mu, cov3)\n    mvn32 = mvd.MVNormal(mu2, cov3/2., 4)\n    rvs = mix.mv_mixture_rvs([0.4, 0.6], 2000, [mvn3, mvn32], 3)\n    \"\"\"\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    idx = _make_index(prob, size)\n    sample = np.empty((size, nvars))\n    for i in range(len(prob)):\n        sample_idx = idx[..., i]\n        sample_size = sample_idx.sum()\n        sample[sample_idx] = dist[i].rvs(size=int(sample_size))\n    return sample",
        "mutated": [
            "def mv_mixture_rvs(prob, size, dist, nvars, **kwargs):\n    if False:\n        i = 10\n    '\\n    Sample from a mixture of multivariate distributions.\\n\\n    Parameters\\n    ----------\\n    prob : array_like\\n        Probability of sampling from each distribution in dist\\n    size : int\\n        The length of the returned sample.\\n    dist : array_like\\n        An iterable of distributions instances with callable method rvs.\\n    nvargs : int\\n        dimension of the multivariate distribution, could be inferred instead\\n    kwargs : tuple of dicts, optional\\n        ignored\\n\\n    Examples\\n    --------\\n    Say we want 2000 random variables from mixture of normals with two\\n    multivariate normal distributions, and we want to sample from the\\n    first with probability .4 and the second with probability .6.\\n\\n    import statsmodels.sandbox.distributions.mv_normal as mvd\\n\\n    cov3 = np.array([[ 1.  ,  0.5 ,  0.75],\\n                       [ 0.5 ,  1.5 ,  0.6 ],\\n                       [ 0.75,  0.6 ,  2.  ]])\\n\\n    mu = np.array([-1, 0.0, 2.0])\\n    mu2 = np.array([4, 2.0, 2.0])\\n    mvn3 = mvd.MVNormal(mu, cov3)\\n    mvn32 = mvd.MVNormal(mu2, cov3/2., 4)\\n    rvs = mix.mv_mixture_rvs([0.4, 0.6], 2000, [mvn3, mvn32], 3)\\n    '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    idx = _make_index(prob, size)\n    sample = np.empty((size, nvars))\n    for i in range(len(prob)):\n        sample_idx = idx[..., i]\n        sample_size = sample_idx.sum()\n        sample[sample_idx] = dist[i].rvs(size=int(sample_size))\n    return sample",
            "def mv_mixture_rvs(prob, size, dist, nvars, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Sample from a mixture of multivariate distributions.\\n\\n    Parameters\\n    ----------\\n    prob : array_like\\n        Probability of sampling from each distribution in dist\\n    size : int\\n        The length of the returned sample.\\n    dist : array_like\\n        An iterable of distributions instances with callable method rvs.\\n    nvargs : int\\n        dimension of the multivariate distribution, could be inferred instead\\n    kwargs : tuple of dicts, optional\\n        ignored\\n\\n    Examples\\n    --------\\n    Say we want 2000 random variables from mixture of normals with two\\n    multivariate normal distributions, and we want to sample from the\\n    first with probability .4 and the second with probability .6.\\n\\n    import statsmodels.sandbox.distributions.mv_normal as mvd\\n\\n    cov3 = np.array([[ 1.  ,  0.5 ,  0.75],\\n                       [ 0.5 ,  1.5 ,  0.6 ],\\n                       [ 0.75,  0.6 ,  2.  ]])\\n\\n    mu = np.array([-1, 0.0, 2.0])\\n    mu2 = np.array([4, 2.0, 2.0])\\n    mvn3 = mvd.MVNormal(mu, cov3)\\n    mvn32 = mvd.MVNormal(mu2, cov3/2., 4)\\n    rvs = mix.mv_mixture_rvs([0.4, 0.6], 2000, [mvn3, mvn32], 3)\\n    '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    idx = _make_index(prob, size)\n    sample = np.empty((size, nvars))\n    for i in range(len(prob)):\n        sample_idx = idx[..., i]\n        sample_size = sample_idx.sum()\n        sample[sample_idx] = dist[i].rvs(size=int(sample_size))\n    return sample",
            "def mv_mixture_rvs(prob, size, dist, nvars, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Sample from a mixture of multivariate distributions.\\n\\n    Parameters\\n    ----------\\n    prob : array_like\\n        Probability of sampling from each distribution in dist\\n    size : int\\n        The length of the returned sample.\\n    dist : array_like\\n        An iterable of distributions instances with callable method rvs.\\n    nvargs : int\\n        dimension of the multivariate distribution, could be inferred instead\\n    kwargs : tuple of dicts, optional\\n        ignored\\n\\n    Examples\\n    --------\\n    Say we want 2000 random variables from mixture of normals with two\\n    multivariate normal distributions, and we want to sample from the\\n    first with probability .4 and the second with probability .6.\\n\\n    import statsmodels.sandbox.distributions.mv_normal as mvd\\n\\n    cov3 = np.array([[ 1.  ,  0.5 ,  0.75],\\n                       [ 0.5 ,  1.5 ,  0.6 ],\\n                       [ 0.75,  0.6 ,  2.  ]])\\n\\n    mu = np.array([-1, 0.0, 2.0])\\n    mu2 = np.array([4, 2.0, 2.0])\\n    mvn3 = mvd.MVNormal(mu, cov3)\\n    mvn32 = mvd.MVNormal(mu2, cov3/2., 4)\\n    rvs = mix.mv_mixture_rvs([0.4, 0.6], 2000, [mvn3, mvn32], 3)\\n    '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    idx = _make_index(prob, size)\n    sample = np.empty((size, nvars))\n    for i in range(len(prob)):\n        sample_idx = idx[..., i]\n        sample_size = sample_idx.sum()\n        sample[sample_idx] = dist[i].rvs(size=int(sample_size))\n    return sample",
            "def mv_mixture_rvs(prob, size, dist, nvars, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Sample from a mixture of multivariate distributions.\\n\\n    Parameters\\n    ----------\\n    prob : array_like\\n        Probability of sampling from each distribution in dist\\n    size : int\\n        The length of the returned sample.\\n    dist : array_like\\n        An iterable of distributions instances with callable method rvs.\\n    nvargs : int\\n        dimension of the multivariate distribution, could be inferred instead\\n    kwargs : tuple of dicts, optional\\n        ignored\\n\\n    Examples\\n    --------\\n    Say we want 2000 random variables from mixture of normals with two\\n    multivariate normal distributions, and we want to sample from the\\n    first with probability .4 and the second with probability .6.\\n\\n    import statsmodels.sandbox.distributions.mv_normal as mvd\\n\\n    cov3 = np.array([[ 1.  ,  0.5 ,  0.75],\\n                       [ 0.5 ,  1.5 ,  0.6 ],\\n                       [ 0.75,  0.6 ,  2.  ]])\\n\\n    mu = np.array([-1, 0.0, 2.0])\\n    mu2 = np.array([4, 2.0, 2.0])\\n    mvn3 = mvd.MVNormal(mu, cov3)\\n    mvn32 = mvd.MVNormal(mu2, cov3/2., 4)\\n    rvs = mix.mv_mixture_rvs([0.4, 0.6], 2000, [mvn3, mvn32], 3)\\n    '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    idx = _make_index(prob, size)\n    sample = np.empty((size, nvars))\n    for i in range(len(prob)):\n        sample_idx = idx[..., i]\n        sample_size = sample_idx.sum()\n        sample[sample_idx] = dist[i].rvs(size=int(sample_size))\n    return sample",
            "def mv_mixture_rvs(prob, size, dist, nvars, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Sample from a mixture of multivariate distributions.\\n\\n    Parameters\\n    ----------\\n    prob : array_like\\n        Probability of sampling from each distribution in dist\\n    size : int\\n        The length of the returned sample.\\n    dist : array_like\\n        An iterable of distributions instances with callable method rvs.\\n    nvargs : int\\n        dimension of the multivariate distribution, could be inferred instead\\n    kwargs : tuple of dicts, optional\\n        ignored\\n\\n    Examples\\n    --------\\n    Say we want 2000 random variables from mixture of normals with two\\n    multivariate normal distributions, and we want to sample from the\\n    first with probability .4 and the second with probability .6.\\n\\n    import statsmodels.sandbox.distributions.mv_normal as mvd\\n\\n    cov3 = np.array([[ 1.  ,  0.5 ,  0.75],\\n                       [ 0.5 ,  1.5 ,  0.6 ],\\n                       [ 0.75,  0.6 ,  2.  ]])\\n\\n    mu = np.array([-1, 0.0, 2.0])\\n    mu2 = np.array([4, 2.0, 2.0])\\n    mvn3 = mvd.MVNormal(mu, cov3)\\n    mvn32 = mvd.MVNormal(mu2, cov3/2., 4)\\n    rvs = mix.mv_mixture_rvs([0.4, 0.6], 2000, [mvn3, mvn32], 3)\\n    '\n    if len(prob) != len(dist):\n        raise ValueError('You must provide as many probabilities as distributions')\n    if not np.allclose(np.sum(prob), 1):\n        raise ValueError('prob does not sum to 1')\n    if kwargs is None:\n        kwargs = ({},) * len(prob)\n    idx = _make_index(prob, size)\n    sample = np.empty((size, nvars))\n    for i in range(len(prob)):\n        sample_idx = idx[..., i]\n        sample_size = sample_idx.sum()\n        sample[sample_idx] = dist[i].rvs(size=int(sample_size))\n    return sample"
        ]
    }
]