[
    {
        "func_name": "run",
        "original": "def run(self, tmp=None, task_vars=None):\n    \"\"\" handler for unarchive operations \"\"\"\n    if task_vars is None:\n        task_vars = dict()\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    source = self._task.args.get('src', None)\n    dest = self._task.args.get('dest', None)\n    remote_src = boolean(self._task.args.get('remote_src', False), strict=False)\n    creates = self._task.args.get('creates', None)\n    decrypt = self._task.args.get('decrypt', True)\n    try:\n        if 'copy' in self._task.args:\n            if 'remote_src' in self._task.args:\n                raise AnsibleActionFail(\"parameters are mutually exclusive: ('copy', 'remote_src')\")\n            self._task.args['remote_src'] = remote_src = not boolean(self._task.args.pop('copy'), strict=False)\n        if source is None or dest is None:\n            raise AnsibleActionFail('src (or content) and dest are required')\n        if creates:\n            creates = self._remote_expand_user(creates)\n            if self._remote_file_exists(creates):\n                raise AnsibleActionSkip('skipped, since %s exists' % creates)\n        dest = self._remote_expand_user(dest)\n        source = os.path.expanduser(source)\n        if not remote_src:\n            try:\n                source = self._loader.get_real_file(self._find_needle('files', source), decrypt=decrypt)\n            except AnsibleError as e:\n                raise AnsibleActionFail(to_text(e))\n        try:\n            remote_stat = self._execute_remote_stat(dest, all_vars=task_vars, follow=True)\n        except AnsibleError as e:\n            raise AnsibleActionFail(to_text(e))\n        if not remote_stat['exists'] or not remote_stat['isdir']:\n            raise AnsibleActionFail(\"dest '%s' must be an existing dir\" % dest)\n        if not remote_src:\n            tmp_src = self._connection._shell.join_path(self._connection._shell.tmpdir, 'source')\n            self._transfer_file(source, tmp_src)\n        new_module_args = self._task.args.copy()\n        for key in ('decrypt',):\n            if key in new_module_args:\n                del new_module_args[key]\n        if not remote_src:\n            self._fixup_perms2((self._connection._shell.tmpdir, tmp_src))\n            new_module_args['src'] = tmp_src\n        result.update(self._execute_module(module_name='ansible.legacy.unarchive', module_args=new_module_args, task_vars=task_vars))\n    except AnsibleAction as e:\n        result.update(e.result)\n    finally:\n        self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result",
        "mutated": [
            "def run(self, tmp=None, task_vars=None):\n    if False:\n        i = 10\n    ' handler for unarchive operations '\n    if task_vars is None:\n        task_vars = dict()\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    source = self._task.args.get('src', None)\n    dest = self._task.args.get('dest', None)\n    remote_src = boolean(self._task.args.get('remote_src', False), strict=False)\n    creates = self._task.args.get('creates', None)\n    decrypt = self._task.args.get('decrypt', True)\n    try:\n        if 'copy' in self._task.args:\n            if 'remote_src' in self._task.args:\n                raise AnsibleActionFail(\"parameters are mutually exclusive: ('copy', 'remote_src')\")\n            self._task.args['remote_src'] = remote_src = not boolean(self._task.args.pop('copy'), strict=False)\n        if source is None or dest is None:\n            raise AnsibleActionFail('src (or content) and dest are required')\n        if creates:\n            creates = self._remote_expand_user(creates)\n            if self._remote_file_exists(creates):\n                raise AnsibleActionSkip('skipped, since %s exists' % creates)\n        dest = self._remote_expand_user(dest)\n        source = os.path.expanduser(source)\n        if not remote_src:\n            try:\n                source = self._loader.get_real_file(self._find_needle('files', source), decrypt=decrypt)\n            except AnsibleError as e:\n                raise AnsibleActionFail(to_text(e))\n        try:\n            remote_stat = self._execute_remote_stat(dest, all_vars=task_vars, follow=True)\n        except AnsibleError as e:\n            raise AnsibleActionFail(to_text(e))\n        if not remote_stat['exists'] or not remote_stat['isdir']:\n            raise AnsibleActionFail(\"dest '%s' must be an existing dir\" % dest)\n        if not remote_src:\n            tmp_src = self._connection._shell.join_path(self._connection._shell.tmpdir, 'source')\n            self._transfer_file(source, tmp_src)\n        new_module_args = self._task.args.copy()\n        for key in ('decrypt',):\n            if key in new_module_args:\n                del new_module_args[key]\n        if not remote_src:\n            self._fixup_perms2((self._connection._shell.tmpdir, tmp_src))\n            new_module_args['src'] = tmp_src\n        result.update(self._execute_module(module_name='ansible.legacy.unarchive', module_args=new_module_args, task_vars=task_vars))\n    except AnsibleAction as e:\n        result.update(e.result)\n    finally:\n        self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result",
            "def run(self, tmp=None, task_vars=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' handler for unarchive operations '\n    if task_vars is None:\n        task_vars = dict()\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    source = self._task.args.get('src', None)\n    dest = self._task.args.get('dest', None)\n    remote_src = boolean(self._task.args.get('remote_src', False), strict=False)\n    creates = self._task.args.get('creates', None)\n    decrypt = self._task.args.get('decrypt', True)\n    try:\n        if 'copy' in self._task.args:\n            if 'remote_src' in self._task.args:\n                raise AnsibleActionFail(\"parameters are mutually exclusive: ('copy', 'remote_src')\")\n            self._task.args['remote_src'] = remote_src = not boolean(self._task.args.pop('copy'), strict=False)\n        if source is None or dest is None:\n            raise AnsibleActionFail('src (or content) and dest are required')\n        if creates:\n            creates = self._remote_expand_user(creates)\n            if self._remote_file_exists(creates):\n                raise AnsibleActionSkip('skipped, since %s exists' % creates)\n        dest = self._remote_expand_user(dest)\n        source = os.path.expanduser(source)\n        if not remote_src:\n            try:\n                source = self._loader.get_real_file(self._find_needle('files', source), decrypt=decrypt)\n            except AnsibleError as e:\n                raise AnsibleActionFail(to_text(e))\n        try:\n            remote_stat = self._execute_remote_stat(dest, all_vars=task_vars, follow=True)\n        except AnsibleError as e:\n            raise AnsibleActionFail(to_text(e))\n        if not remote_stat['exists'] or not remote_stat['isdir']:\n            raise AnsibleActionFail(\"dest '%s' must be an existing dir\" % dest)\n        if not remote_src:\n            tmp_src = self._connection._shell.join_path(self._connection._shell.tmpdir, 'source')\n            self._transfer_file(source, tmp_src)\n        new_module_args = self._task.args.copy()\n        for key in ('decrypt',):\n            if key in new_module_args:\n                del new_module_args[key]\n        if not remote_src:\n            self._fixup_perms2((self._connection._shell.tmpdir, tmp_src))\n            new_module_args['src'] = tmp_src\n        result.update(self._execute_module(module_name='ansible.legacy.unarchive', module_args=new_module_args, task_vars=task_vars))\n    except AnsibleAction as e:\n        result.update(e.result)\n    finally:\n        self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result",
            "def run(self, tmp=None, task_vars=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' handler for unarchive operations '\n    if task_vars is None:\n        task_vars = dict()\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    source = self._task.args.get('src', None)\n    dest = self._task.args.get('dest', None)\n    remote_src = boolean(self._task.args.get('remote_src', False), strict=False)\n    creates = self._task.args.get('creates', None)\n    decrypt = self._task.args.get('decrypt', True)\n    try:\n        if 'copy' in self._task.args:\n            if 'remote_src' in self._task.args:\n                raise AnsibleActionFail(\"parameters are mutually exclusive: ('copy', 'remote_src')\")\n            self._task.args['remote_src'] = remote_src = not boolean(self._task.args.pop('copy'), strict=False)\n        if source is None or dest is None:\n            raise AnsibleActionFail('src (or content) and dest are required')\n        if creates:\n            creates = self._remote_expand_user(creates)\n            if self._remote_file_exists(creates):\n                raise AnsibleActionSkip('skipped, since %s exists' % creates)\n        dest = self._remote_expand_user(dest)\n        source = os.path.expanduser(source)\n        if not remote_src:\n            try:\n                source = self._loader.get_real_file(self._find_needle('files', source), decrypt=decrypt)\n            except AnsibleError as e:\n                raise AnsibleActionFail(to_text(e))\n        try:\n            remote_stat = self._execute_remote_stat(dest, all_vars=task_vars, follow=True)\n        except AnsibleError as e:\n            raise AnsibleActionFail(to_text(e))\n        if not remote_stat['exists'] or not remote_stat['isdir']:\n            raise AnsibleActionFail(\"dest '%s' must be an existing dir\" % dest)\n        if not remote_src:\n            tmp_src = self._connection._shell.join_path(self._connection._shell.tmpdir, 'source')\n            self._transfer_file(source, tmp_src)\n        new_module_args = self._task.args.copy()\n        for key in ('decrypt',):\n            if key in new_module_args:\n                del new_module_args[key]\n        if not remote_src:\n            self._fixup_perms2((self._connection._shell.tmpdir, tmp_src))\n            new_module_args['src'] = tmp_src\n        result.update(self._execute_module(module_name='ansible.legacy.unarchive', module_args=new_module_args, task_vars=task_vars))\n    except AnsibleAction as e:\n        result.update(e.result)\n    finally:\n        self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result",
            "def run(self, tmp=None, task_vars=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' handler for unarchive operations '\n    if task_vars is None:\n        task_vars = dict()\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    source = self._task.args.get('src', None)\n    dest = self._task.args.get('dest', None)\n    remote_src = boolean(self._task.args.get('remote_src', False), strict=False)\n    creates = self._task.args.get('creates', None)\n    decrypt = self._task.args.get('decrypt', True)\n    try:\n        if 'copy' in self._task.args:\n            if 'remote_src' in self._task.args:\n                raise AnsibleActionFail(\"parameters are mutually exclusive: ('copy', 'remote_src')\")\n            self._task.args['remote_src'] = remote_src = not boolean(self._task.args.pop('copy'), strict=False)\n        if source is None or dest is None:\n            raise AnsibleActionFail('src (or content) and dest are required')\n        if creates:\n            creates = self._remote_expand_user(creates)\n            if self._remote_file_exists(creates):\n                raise AnsibleActionSkip('skipped, since %s exists' % creates)\n        dest = self._remote_expand_user(dest)\n        source = os.path.expanduser(source)\n        if not remote_src:\n            try:\n                source = self._loader.get_real_file(self._find_needle('files', source), decrypt=decrypt)\n            except AnsibleError as e:\n                raise AnsibleActionFail(to_text(e))\n        try:\n            remote_stat = self._execute_remote_stat(dest, all_vars=task_vars, follow=True)\n        except AnsibleError as e:\n            raise AnsibleActionFail(to_text(e))\n        if not remote_stat['exists'] or not remote_stat['isdir']:\n            raise AnsibleActionFail(\"dest '%s' must be an existing dir\" % dest)\n        if not remote_src:\n            tmp_src = self._connection._shell.join_path(self._connection._shell.tmpdir, 'source')\n            self._transfer_file(source, tmp_src)\n        new_module_args = self._task.args.copy()\n        for key in ('decrypt',):\n            if key in new_module_args:\n                del new_module_args[key]\n        if not remote_src:\n            self._fixup_perms2((self._connection._shell.tmpdir, tmp_src))\n            new_module_args['src'] = tmp_src\n        result.update(self._execute_module(module_name='ansible.legacy.unarchive', module_args=new_module_args, task_vars=task_vars))\n    except AnsibleAction as e:\n        result.update(e.result)\n    finally:\n        self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result",
            "def run(self, tmp=None, task_vars=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' handler for unarchive operations '\n    if task_vars is None:\n        task_vars = dict()\n    result = super(ActionModule, self).run(tmp, task_vars)\n    del tmp\n    source = self._task.args.get('src', None)\n    dest = self._task.args.get('dest', None)\n    remote_src = boolean(self._task.args.get('remote_src', False), strict=False)\n    creates = self._task.args.get('creates', None)\n    decrypt = self._task.args.get('decrypt', True)\n    try:\n        if 'copy' in self._task.args:\n            if 'remote_src' in self._task.args:\n                raise AnsibleActionFail(\"parameters are mutually exclusive: ('copy', 'remote_src')\")\n            self._task.args['remote_src'] = remote_src = not boolean(self._task.args.pop('copy'), strict=False)\n        if source is None or dest is None:\n            raise AnsibleActionFail('src (or content) and dest are required')\n        if creates:\n            creates = self._remote_expand_user(creates)\n            if self._remote_file_exists(creates):\n                raise AnsibleActionSkip('skipped, since %s exists' % creates)\n        dest = self._remote_expand_user(dest)\n        source = os.path.expanduser(source)\n        if not remote_src:\n            try:\n                source = self._loader.get_real_file(self._find_needle('files', source), decrypt=decrypt)\n            except AnsibleError as e:\n                raise AnsibleActionFail(to_text(e))\n        try:\n            remote_stat = self._execute_remote_stat(dest, all_vars=task_vars, follow=True)\n        except AnsibleError as e:\n            raise AnsibleActionFail(to_text(e))\n        if not remote_stat['exists'] or not remote_stat['isdir']:\n            raise AnsibleActionFail(\"dest '%s' must be an existing dir\" % dest)\n        if not remote_src:\n            tmp_src = self._connection._shell.join_path(self._connection._shell.tmpdir, 'source')\n            self._transfer_file(source, tmp_src)\n        new_module_args = self._task.args.copy()\n        for key in ('decrypt',):\n            if key in new_module_args:\n                del new_module_args[key]\n        if not remote_src:\n            self._fixup_perms2((self._connection._shell.tmpdir, tmp_src))\n            new_module_args['src'] = tmp_src\n        result.update(self._execute_module(module_name='ansible.legacy.unarchive', module_args=new_module_args, task_vars=task_vars))\n    except AnsibleAction as e:\n        result.update(e.result)\n    finally:\n        self._remove_tmp_path(self._connection._shell.tmpdir)\n    return result"
        ]
    }
]