[
    {
        "func_name": "test_backtest_results",
        "original": "@pytest.mark.parametrize('data', TESTS)\ndef test_backtest_results(default_conf, fee, mocker, caplog, data: BTContainer) -> None:\n    \"\"\"\n    run functional tests\n    \"\"\"\n    default_conf['stoploss'] = data.stop_loss\n    default_conf['minimal_roi'] = data.roi\n    default_conf['timeframe'] = tests_timeframe\n    default_conf['trailing_stop'] = data.trailing_stop\n    default_conf['trailing_only_offset_is_reached'] = data.trailing_only_offset_is_reached\n    if data.timeout:\n        default_conf['unfilledtimeout'].update({'entry': data.timeout, 'exit': data.timeout})\n    if data.trailing_stop_positive is not None:\n        default_conf['trailing_stop_positive'] = data.trailing_stop_positive\n    default_conf['trailing_stop_positive_offset'] = data.trailing_stop_positive_offset\n    default_conf['use_exit_signal'] = data.use_exit_signal\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', return_value=0.0)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=100)\n    mocker.patch(f'{EXMS}.calculate_funding_fees', return_value=0)\n    patch_exchange(mocker)\n    frame = _build_backtest_dataframe(data.data)\n    backtesting = Backtesting(default_conf)\n    backtesting.trading_mode = TradingMode.MARGIN\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting._can_short = True\n    backtesting.required_startup = 0\n    backtesting.strategy.advise_entry = lambda a, m: frame\n    backtesting.strategy.advise_exit = lambda a, m: frame\n    if data.custom_entry_price:\n        backtesting.strategy.custom_entry_price = MagicMock(return_value=data.custom_entry_price)\n    if data.custom_exit_price:\n        backtesting.strategy.custom_exit_price = MagicMock(return_value=data.custom_exit_price)\n    backtesting.strategy.adjust_entry_price = MagicMock(return_value=data.adjust_entry_price)\n    backtesting.strategy.use_custom_stoploss = data.use_custom_stoploss\n    backtesting.strategy.leverage = lambda **kwargs: data.leverage\n    caplog.set_level(logging.DEBUG)\n    pair = 'UNITTEST/BTC'\n    data_processed = {pair: frame.copy()}\n    (min_date, max_date) = get_timerange({pair: frame})\n    result = backtesting.backtest(processed=data_processed, start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert len(results) == len(data.trades)\n    assert round(results['profit_ratio'].sum(), 3) == round(data.profit_perc, 3)\n    for (c, trade) in enumerate(data.trades):\n        res: BTrade = results.iloc[c]\n        assert res.exit_reason == trade.exit_reason.value\n        assert res.enter_tag == trade.enter_tag\n        assert res.open_date == _get_frame_time_from_offset(trade.open_tick)\n        assert res.close_date == _get_frame_time_from_offset(trade.close_tick)\n        assert res.is_short == trade.is_short\n    assert len(LocalTrade.trades) == len(data.trades)\n    assert len(LocalTrade.trades_open) == 0\n    backtesting.cleanup()\n    del backtesting",
        "mutated": [
            "@pytest.mark.parametrize('data', TESTS)\ndef test_backtest_results(default_conf, fee, mocker, caplog, data: BTContainer) -> None:\n    if False:\n        i = 10\n    '\\n    run functional tests\\n    '\n    default_conf['stoploss'] = data.stop_loss\n    default_conf['minimal_roi'] = data.roi\n    default_conf['timeframe'] = tests_timeframe\n    default_conf['trailing_stop'] = data.trailing_stop\n    default_conf['trailing_only_offset_is_reached'] = data.trailing_only_offset_is_reached\n    if data.timeout:\n        default_conf['unfilledtimeout'].update({'entry': data.timeout, 'exit': data.timeout})\n    if data.trailing_stop_positive is not None:\n        default_conf['trailing_stop_positive'] = data.trailing_stop_positive\n    default_conf['trailing_stop_positive_offset'] = data.trailing_stop_positive_offset\n    default_conf['use_exit_signal'] = data.use_exit_signal\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', return_value=0.0)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=100)\n    mocker.patch(f'{EXMS}.calculate_funding_fees', return_value=0)\n    patch_exchange(mocker)\n    frame = _build_backtest_dataframe(data.data)\n    backtesting = Backtesting(default_conf)\n    backtesting.trading_mode = TradingMode.MARGIN\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting._can_short = True\n    backtesting.required_startup = 0\n    backtesting.strategy.advise_entry = lambda a, m: frame\n    backtesting.strategy.advise_exit = lambda a, m: frame\n    if data.custom_entry_price:\n        backtesting.strategy.custom_entry_price = MagicMock(return_value=data.custom_entry_price)\n    if data.custom_exit_price:\n        backtesting.strategy.custom_exit_price = MagicMock(return_value=data.custom_exit_price)\n    backtesting.strategy.adjust_entry_price = MagicMock(return_value=data.adjust_entry_price)\n    backtesting.strategy.use_custom_stoploss = data.use_custom_stoploss\n    backtesting.strategy.leverage = lambda **kwargs: data.leverage\n    caplog.set_level(logging.DEBUG)\n    pair = 'UNITTEST/BTC'\n    data_processed = {pair: frame.copy()}\n    (min_date, max_date) = get_timerange({pair: frame})\n    result = backtesting.backtest(processed=data_processed, start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert len(results) == len(data.trades)\n    assert round(results['profit_ratio'].sum(), 3) == round(data.profit_perc, 3)\n    for (c, trade) in enumerate(data.trades):\n        res: BTrade = results.iloc[c]\n        assert res.exit_reason == trade.exit_reason.value\n        assert res.enter_tag == trade.enter_tag\n        assert res.open_date == _get_frame_time_from_offset(trade.open_tick)\n        assert res.close_date == _get_frame_time_from_offset(trade.close_tick)\n        assert res.is_short == trade.is_short\n    assert len(LocalTrade.trades) == len(data.trades)\n    assert len(LocalTrade.trades_open) == 0\n    backtesting.cleanup()\n    del backtesting",
            "@pytest.mark.parametrize('data', TESTS)\ndef test_backtest_results(default_conf, fee, mocker, caplog, data: BTContainer) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    run functional tests\\n    '\n    default_conf['stoploss'] = data.stop_loss\n    default_conf['minimal_roi'] = data.roi\n    default_conf['timeframe'] = tests_timeframe\n    default_conf['trailing_stop'] = data.trailing_stop\n    default_conf['trailing_only_offset_is_reached'] = data.trailing_only_offset_is_reached\n    if data.timeout:\n        default_conf['unfilledtimeout'].update({'entry': data.timeout, 'exit': data.timeout})\n    if data.trailing_stop_positive is not None:\n        default_conf['trailing_stop_positive'] = data.trailing_stop_positive\n    default_conf['trailing_stop_positive_offset'] = data.trailing_stop_positive_offset\n    default_conf['use_exit_signal'] = data.use_exit_signal\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', return_value=0.0)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=100)\n    mocker.patch(f'{EXMS}.calculate_funding_fees', return_value=0)\n    patch_exchange(mocker)\n    frame = _build_backtest_dataframe(data.data)\n    backtesting = Backtesting(default_conf)\n    backtesting.trading_mode = TradingMode.MARGIN\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting._can_short = True\n    backtesting.required_startup = 0\n    backtesting.strategy.advise_entry = lambda a, m: frame\n    backtesting.strategy.advise_exit = lambda a, m: frame\n    if data.custom_entry_price:\n        backtesting.strategy.custom_entry_price = MagicMock(return_value=data.custom_entry_price)\n    if data.custom_exit_price:\n        backtesting.strategy.custom_exit_price = MagicMock(return_value=data.custom_exit_price)\n    backtesting.strategy.adjust_entry_price = MagicMock(return_value=data.adjust_entry_price)\n    backtesting.strategy.use_custom_stoploss = data.use_custom_stoploss\n    backtesting.strategy.leverage = lambda **kwargs: data.leverage\n    caplog.set_level(logging.DEBUG)\n    pair = 'UNITTEST/BTC'\n    data_processed = {pair: frame.copy()}\n    (min_date, max_date) = get_timerange({pair: frame})\n    result = backtesting.backtest(processed=data_processed, start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert len(results) == len(data.trades)\n    assert round(results['profit_ratio'].sum(), 3) == round(data.profit_perc, 3)\n    for (c, trade) in enumerate(data.trades):\n        res: BTrade = results.iloc[c]\n        assert res.exit_reason == trade.exit_reason.value\n        assert res.enter_tag == trade.enter_tag\n        assert res.open_date == _get_frame_time_from_offset(trade.open_tick)\n        assert res.close_date == _get_frame_time_from_offset(trade.close_tick)\n        assert res.is_short == trade.is_short\n    assert len(LocalTrade.trades) == len(data.trades)\n    assert len(LocalTrade.trades_open) == 0\n    backtesting.cleanup()\n    del backtesting",
            "@pytest.mark.parametrize('data', TESTS)\ndef test_backtest_results(default_conf, fee, mocker, caplog, data: BTContainer) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    run functional tests\\n    '\n    default_conf['stoploss'] = data.stop_loss\n    default_conf['minimal_roi'] = data.roi\n    default_conf['timeframe'] = tests_timeframe\n    default_conf['trailing_stop'] = data.trailing_stop\n    default_conf['trailing_only_offset_is_reached'] = data.trailing_only_offset_is_reached\n    if data.timeout:\n        default_conf['unfilledtimeout'].update({'entry': data.timeout, 'exit': data.timeout})\n    if data.trailing_stop_positive is not None:\n        default_conf['trailing_stop_positive'] = data.trailing_stop_positive\n    default_conf['trailing_stop_positive_offset'] = data.trailing_stop_positive_offset\n    default_conf['use_exit_signal'] = data.use_exit_signal\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', return_value=0.0)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=100)\n    mocker.patch(f'{EXMS}.calculate_funding_fees', return_value=0)\n    patch_exchange(mocker)\n    frame = _build_backtest_dataframe(data.data)\n    backtesting = Backtesting(default_conf)\n    backtesting.trading_mode = TradingMode.MARGIN\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting._can_short = True\n    backtesting.required_startup = 0\n    backtesting.strategy.advise_entry = lambda a, m: frame\n    backtesting.strategy.advise_exit = lambda a, m: frame\n    if data.custom_entry_price:\n        backtesting.strategy.custom_entry_price = MagicMock(return_value=data.custom_entry_price)\n    if data.custom_exit_price:\n        backtesting.strategy.custom_exit_price = MagicMock(return_value=data.custom_exit_price)\n    backtesting.strategy.adjust_entry_price = MagicMock(return_value=data.adjust_entry_price)\n    backtesting.strategy.use_custom_stoploss = data.use_custom_stoploss\n    backtesting.strategy.leverage = lambda **kwargs: data.leverage\n    caplog.set_level(logging.DEBUG)\n    pair = 'UNITTEST/BTC'\n    data_processed = {pair: frame.copy()}\n    (min_date, max_date) = get_timerange({pair: frame})\n    result = backtesting.backtest(processed=data_processed, start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert len(results) == len(data.trades)\n    assert round(results['profit_ratio'].sum(), 3) == round(data.profit_perc, 3)\n    for (c, trade) in enumerate(data.trades):\n        res: BTrade = results.iloc[c]\n        assert res.exit_reason == trade.exit_reason.value\n        assert res.enter_tag == trade.enter_tag\n        assert res.open_date == _get_frame_time_from_offset(trade.open_tick)\n        assert res.close_date == _get_frame_time_from_offset(trade.close_tick)\n        assert res.is_short == trade.is_short\n    assert len(LocalTrade.trades) == len(data.trades)\n    assert len(LocalTrade.trades_open) == 0\n    backtesting.cleanup()\n    del backtesting",
            "@pytest.mark.parametrize('data', TESTS)\ndef test_backtest_results(default_conf, fee, mocker, caplog, data: BTContainer) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    run functional tests\\n    '\n    default_conf['stoploss'] = data.stop_loss\n    default_conf['minimal_roi'] = data.roi\n    default_conf['timeframe'] = tests_timeframe\n    default_conf['trailing_stop'] = data.trailing_stop\n    default_conf['trailing_only_offset_is_reached'] = data.trailing_only_offset_is_reached\n    if data.timeout:\n        default_conf['unfilledtimeout'].update({'entry': data.timeout, 'exit': data.timeout})\n    if data.trailing_stop_positive is not None:\n        default_conf['trailing_stop_positive'] = data.trailing_stop_positive\n    default_conf['trailing_stop_positive_offset'] = data.trailing_stop_positive_offset\n    default_conf['use_exit_signal'] = data.use_exit_signal\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', return_value=0.0)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=100)\n    mocker.patch(f'{EXMS}.calculate_funding_fees', return_value=0)\n    patch_exchange(mocker)\n    frame = _build_backtest_dataframe(data.data)\n    backtesting = Backtesting(default_conf)\n    backtesting.trading_mode = TradingMode.MARGIN\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting._can_short = True\n    backtesting.required_startup = 0\n    backtesting.strategy.advise_entry = lambda a, m: frame\n    backtesting.strategy.advise_exit = lambda a, m: frame\n    if data.custom_entry_price:\n        backtesting.strategy.custom_entry_price = MagicMock(return_value=data.custom_entry_price)\n    if data.custom_exit_price:\n        backtesting.strategy.custom_exit_price = MagicMock(return_value=data.custom_exit_price)\n    backtesting.strategy.adjust_entry_price = MagicMock(return_value=data.adjust_entry_price)\n    backtesting.strategy.use_custom_stoploss = data.use_custom_stoploss\n    backtesting.strategy.leverage = lambda **kwargs: data.leverage\n    caplog.set_level(logging.DEBUG)\n    pair = 'UNITTEST/BTC'\n    data_processed = {pair: frame.copy()}\n    (min_date, max_date) = get_timerange({pair: frame})\n    result = backtesting.backtest(processed=data_processed, start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert len(results) == len(data.trades)\n    assert round(results['profit_ratio'].sum(), 3) == round(data.profit_perc, 3)\n    for (c, trade) in enumerate(data.trades):\n        res: BTrade = results.iloc[c]\n        assert res.exit_reason == trade.exit_reason.value\n        assert res.enter_tag == trade.enter_tag\n        assert res.open_date == _get_frame_time_from_offset(trade.open_tick)\n        assert res.close_date == _get_frame_time_from_offset(trade.close_tick)\n        assert res.is_short == trade.is_short\n    assert len(LocalTrade.trades) == len(data.trades)\n    assert len(LocalTrade.trades_open) == 0\n    backtesting.cleanup()\n    del backtesting",
            "@pytest.mark.parametrize('data', TESTS)\ndef test_backtest_results(default_conf, fee, mocker, caplog, data: BTContainer) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    run functional tests\\n    '\n    default_conf['stoploss'] = data.stop_loss\n    default_conf['minimal_roi'] = data.roi\n    default_conf['timeframe'] = tests_timeframe\n    default_conf['trailing_stop'] = data.trailing_stop\n    default_conf['trailing_only_offset_is_reached'] = data.trailing_only_offset_is_reached\n    if data.timeout:\n        default_conf['unfilledtimeout'].update({'entry': data.timeout, 'exit': data.timeout})\n    if data.trailing_stop_positive is not None:\n        default_conf['trailing_stop_positive'] = data.trailing_stop_positive\n    default_conf['trailing_stop_positive_offset'] = data.trailing_stop_positive_offset\n    default_conf['use_exit_signal'] = data.use_exit_signal\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', return_value=0.0)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=100)\n    mocker.patch(f'{EXMS}.calculate_funding_fees', return_value=0)\n    patch_exchange(mocker)\n    frame = _build_backtest_dataframe(data.data)\n    backtesting = Backtesting(default_conf)\n    backtesting.trading_mode = TradingMode.MARGIN\n    backtesting._set_strategy(backtesting.strategylist[0])\n    backtesting._can_short = True\n    backtesting.required_startup = 0\n    backtesting.strategy.advise_entry = lambda a, m: frame\n    backtesting.strategy.advise_exit = lambda a, m: frame\n    if data.custom_entry_price:\n        backtesting.strategy.custom_entry_price = MagicMock(return_value=data.custom_entry_price)\n    if data.custom_exit_price:\n        backtesting.strategy.custom_exit_price = MagicMock(return_value=data.custom_exit_price)\n    backtesting.strategy.adjust_entry_price = MagicMock(return_value=data.adjust_entry_price)\n    backtesting.strategy.use_custom_stoploss = data.use_custom_stoploss\n    backtesting.strategy.leverage = lambda **kwargs: data.leverage\n    caplog.set_level(logging.DEBUG)\n    pair = 'UNITTEST/BTC'\n    data_processed = {pair: frame.copy()}\n    (min_date, max_date) = get_timerange({pair: frame})\n    result = backtesting.backtest(processed=data_processed, start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert len(results) == len(data.trades)\n    assert round(results['profit_ratio'].sum(), 3) == round(data.profit_perc, 3)\n    for (c, trade) in enumerate(data.trades):\n        res: BTrade = results.iloc[c]\n        assert res.exit_reason == trade.exit_reason.value\n        assert res.enter_tag == trade.enter_tag\n        assert res.open_date == _get_frame_time_from_offset(trade.open_tick)\n        assert res.close_date == _get_frame_time_from_offset(trade.close_tick)\n        assert res.is_short == trade.is_short\n    assert len(LocalTrade.trades) == len(data.trades)\n    assert len(LocalTrade.trades_open) == 0\n    backtesting.cleanup()\n    del backtesting"
        ]
    }
]