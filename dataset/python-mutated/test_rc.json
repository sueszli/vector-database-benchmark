[
    {
        "func_name": "test1",
        "original": "def test1(n, expect, noexec=False):\n    params = ['-sXXX=%d' % n]\n    if noexec:\n        params.append('-n')\n        params.append('-sNOEXEC=NOEXEC')\n    t.run_build_system(params)\n    t.expect_output_lines('*NOEXEC*', noexec)\n    obj_file = 'xxx_res.obj'\n    t.expect_output_lines('compile.resource.dummy *%s' % obj_file, expect)\n    if expect and (not noexec):\n        expect('bin/%s/debug/%s' % (toolsetName, obj_file))\n    t.expect_nothing_more()",
        "mutated": [
            "def test1(n, expect, noexec=False):\n    if False:\n        i = 10\n    params = ['-sXXX=%d' % n]\n    if noexec:\n        params.append('-n')\n        params.append('-sNOEXEC=NOEXEC')\n    t.run_build_system(params)\n    t.expect_output_lines('*NOEXEC*', noexec)\n    obj_file = 'xxx_res.obj'\n    t.expect_output_lines('compile.resource.dummy *%s' % obj_file, expect)\n    if expect and (not noexec):\n        expect('bin/%s/debug/%s' % (toolsetName, obj_file))\n    t.expect_nothing_more()",
            "def test1(n, expect, noexec=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    params = ['-sXXX=%d' % n]\n    if noexec:\n        params.append('-n')\n        params.append('-sNOEXEC=NOEXEC')\n    t.run_build_system(params)\n    t.expect_output_lines('*NOEXEC*', noexec)\n    obj_file = 'xxx_res.obj'\n    t.expect_output_lines('compile.resource.dummy *%s' % obj_file, expect)\n    if expect and (not noexec):\n        expect('bin/%s/debug/%s' % (toolsetName, obj_file))\n    t.expect_nothing_more()",
            "def test1(n, expect, noexec=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    params = ['-sXXX=%d' % n]\n    if noexec:\n        params.append('-n')\n        params.append('-sNOEXEC=NOEXEC')\n    t.run_build_system(params)\n    t.expect_output_lines('*NOEXEC*', noexec)\n    obj_file = 'xxx_res.obj'\n    t.expect_output_lines('compile.resource.dummy *%s' % obj_file, expect)\n    if expect and (not noexec):\n        expect('bin/%s/debug/%s' % (toolsetName, obj_file))\n    t.expect_nothing_more()",
            "def test1(n, expect, noexec=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    params = ['-sXXX=%d' % n]\n    if noexec:\n        params.append('-n')\n        params.append('-sNOEXEC=NOEXEC')\n    t.run_build_system(params)\n    t.expect_output_lines('*NOEXEC*', noexec)\n    obj_file = 'xxx_res.obj'\n    t.expect_output_lines('compile.resource.dummy *%s' % obj_file, expect)\n    if expect and (not noexec):\n        expect('bin/%s/debug/%s' % (toolsetName, obj_file))\n    t.expect_nothing_more()",
            "def test1(n, expect, noexec=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    params = ['-sXXX=%d' % n]\n    if noexec:\n        params.append('-n')\n        params.append('-sNOEXEC=NOEXEC')\n    t.run_build_system(params)\n    t.expect_output_lines('*NOEXEC*', noexec)\n    obj_file = 'xxx_res.obj'\n    t.expect_output_lines('compile.resource.dummy *%s' % obj_file, expect)\n    if expect and (not noexec):\n        expect('bin/%s/debug/%s' % (toolsetName, obj_file))\n    t.expect_nothing_more()"
        ]
    },
    {
        "func_name": "test",
        "original": "def test(n, expect):\n    test1(n, expect, noexec=True)\n    test1(n, expect)",
        "mutated": [
            "def test(n, expect):\n    if False:\n        i = 10\n    test1(n, expect, noexec=True)\n    test1(n, expect)",
            "def test(n, expect):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    test1(n, expect, noexec=True)\n    test1(n, expect)",
            "def test(n, expect):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    test1(n, expect, noexec=True)\n    test1(n, expect)",
            "def test(n, expect):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    test1(n, expect, noexec=True)\n    test1(n, expect)",
            "def test(n, expect):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    test1(n, expect, noexec=True)\n    test1(n, expect)"
        ]
    },
    {
        "func_name": "included_resource_newer_than_rc_script",
        "original": "def included_resource_newer_than_rc_script():\n    \"\"\"\n      When a .rc script file includes another resource file - the resource file\n    being newer than the .rc script file should not cause the .rc script file\n    to be considered old and force all of its dependents to rebuild.\n\n    \"\"\"\n    toolsetName = '__myDummyResourceCompilerToolset__'\n    t = BoostBuild.Tester(['-d4', '--debug-configuration', '--ignore-site-config', '--user-config=', 'toolset=%s' % toolsetName], pass_toolset=False, use_test_config=False, translate_suffixes=False)\n    t.write(toolsetName + '.jam', 'import feature ;\\nimport rc ;\\nimport type ;\\nlocal toolset-name = \"%s\" ;\\nfeature.extend toolset : $(toolset-name) ;\\nrule init ( ) { }\\nrc.configure dummy-rc-command : <toolset>$(toolset-name) : <rc-type>dummy ;\\nmodule rc\\n{\\n    rule compile.resource.dummy ( targets * : sources * : properties * )\\n    {\\n        import common ;\\n        .TOUCH on $(targets) = [ common.file-touch-command ] ;\\n    }\\n    actions compile.resource.dummy { $(.TOUCH) \"$(<)\" }\\n}\\n# Make OBJ files generated by our toolset use the \"obj\" suffix on all\\n# platforms. We need to do this explicitly for <target-os> windows & cygwin to\\n# override the default OBJ type configuration (otherwise we would get\\n# \\'ambiguous key\\' errors on those platforms).\\nlocal rule set-generated-obj-suffix ( target-os ? )\\n{\\n    type.set-generated-target-suffix OBJ : <toolset>$(toolset-name)\\n        <target-os>$(target-os) : obj ;\\n}\\nset-generated-obj-suffix ;\\nset-generated-obj-suffix windows ;\\nset-generated-obj-suffix cygwin ;\\n' % toolsetName)\n    t.write(toolsetName + '.py', '\\nfrom b2.build import feature, type as type_\\nfrom b2.manager import get_manager\\nfrom b2.tools import rc, common\\n\\nMANAGER = get_manager()\\nENGINE = MANAGER.engine()\\n\\ntoolset_name = \"{0}\"\\n\\nfeature.extend(\\'toolset\\', [toolset_name])\\n\\ndef init(*args):\\n    pass\\n\\nrc.configure([\\'dummy-rc-command\\'], [\\'<toolset>\\' + toolset_name], [\\'<rc-type>dummy\\'])\\n\\nENGINE.register_action(\\n    \\'rc.compile.resource.dummy\\',\\n    \\'\\'\\'\\n    %s \"$(<)\"\\n    \\'\\'\\' % common.file_creation_command()\\n)\\n\\ndef set_generated_obj_suffix(target_os=\\'\\'):\\n    requirements = [\\'<toolset>\\' + toolset_name]\\n    if target_os:\\n        requirements.append(\\'<target-os>\\' + target_os)\\n    type_.set_generated_target_suffix(\\'OBJ\\', requirements, \\'obj\\')\\n\\nset_generated_obj_suffix()\\nset_generated_obj_suffix(\\'windows\\')\\nset_generated_obj_suffix(\\'cygwin\\')\\n'.format(toolsetName))\n    t.write('jamroot.jam', 'ECHO \"{{{\" [ modules.peek : XXX ] [ modules.peek : NOEXEC ] \"}}}\" ;\\nobj xxx : xxx.rc ;\\n')\n    t.write('xxx.rc', '1 MESSAGETABLE \"xxx.bin\"\\n')\n    t.write('xxx.bin', 'foo')\n\n    def test1(n, expect, noexec=False):\n        params = ['-sXXX=%d' % n]\n        if noexec:\n            params.append('-n')\n            params.append('-sNOEXEC=NOEXEC')\n        t.run_build_system(params)\n        t.expect_output_lines('*NOEXEC*', noexec)\n        obj_file = 'xxx_res.obj'\n        t.expect_output_lines('compile.resource.dummy *%s' % obj_file, expect)\n        if expect and (not noexec):\n            expect('bin/%s/debug/%s' % (toolsetName, obj_file))\n        t.expect_nothing_more()\n\n    def test(n, expect):\n        test1(n, expect, noexec=True)\n        test1(n, expect)\n    test(1, t.expect_addition)\n    test(2, None)\n    t.touch('xxx.bin')\n    test(3, t.expect_touch)\n    test(4, None)\n    t.cleanup()",
        "mutated": [
            "def included_resource_newer_than_rc_script():\n    if False:\n        i = 10\n    '\\n      When a .rc script file includes another resource file - the resource file\\n    being newer than the .rc script file should not cause the .rc script file\\n    to be considered old and force all of its dependents to rebuild.\\n\\n    '\n    toolsetName = '__myDummyResourceCompilerToolset__'\n    t = BoostBuild.Tester(['-d4', '--debug-configuration', '--ignore-site-config', '--user-config=', 'toolset=%s' % toolsetName], pass_toolset=False, use_test_config=False, translate_suffixes=False)\n    t.write(toolsetName + '.jam', 'import feature ;\\nimport rc ;\\nimport type ;\\nlocal toolset-name = \"%s\" ;\\nfeature.extend toolset : $(toolset-name) ;\\nrule init ( ) { }\\nrc.configure dummy-rc-command : <toolset>$(toolset-name) : <rc-type>dummy ;\\nmodule rc\\n{\\n    rule compile.resource.dummy ( targets * : sources * : properties * )\\n    {\\n        import common ;\\n        .TOUCH on $(targets) = [ common.file-touch-command ] ;\\n    }\\n    actions compile.resource.dummy { $(.TOUCH) \"$(<)\" }\\n}\\n# Make OBJ files generated by our toolset use the \"obj\" suffix on all\\n# platforms. We need to do this explicitly for <target-os> windows & cygwin to\\n# override the default OBJ type configuration (otherwise we would get\\n# \\'ambiguous key\\' errors on those platforms).\\nlocal rule set-generated-obj-suffix ( target-os ? )\\n{\\n    type.set-generated-target-suffix OBJ : <toolset>$(toolset-name)\\n        <target-os>$(target-os) : obj ;\\n}\\nset-generated-obj-suffix ;\\nset-generated-obj-suffix windows ;\\nset-generated-obj-suffix cygwin ;\\n' % toolsetName)\n    t.write(toolsetName + '.py', '\\nfrom b2.build import feature, type as type_\\nfrom b2.manager import get_manager\\nfrom b2.tools import rc, common\\n\\nMANAGER = get_manager()\\nENGINE = MANAGER.engine()\\n\\ntoolset_name = \"{0}\"\\n\\nfeature.extend(\\'toolset\\', [toolset_name])\\n\\ndef init(*args):\\n    pass\\n\\nrc.configure([\\'dummy-rc-command\\'], [\\'<toolset>\\' + toolset_name], [\\'<rc-type>dummy\\'])\\n\\nENGINE.register_action(\\n    \\'rc.compile.resource.dummy\\',\\n    \\'\\'\\'\\n    %s \"$(<)\"\\n    \\'\\'\\' % common.file_creation_command()\\n)\\n\\ndef set_generated_obj_suffix(target_os=\\'\\'):\\n    requirements = [\\'<toolset>\\' + toolset_name]\\n    if target_os:\\n        requirements.append(\\'<target-os>\\' + target_os)\\n    type_.set_generated_target_suffix(\\'OBJ\\', requirements, \\'obj\\')\\n\\nset_generated_obj_suffix()\\nset_generated_obj_suffix(\\'windows\\')\\nset_generated_obj_suffix(\\'cygwin\\')\\n'.format(toolsetName))\n    t.write('jamroot.jam', 'ECHO \"{{{\" [ modules.peek : XXX ] [ modules.peek : NOEXEC ] \"}}}\" ;\\nobj xxx : xxx.rc ;\\n')\n    t.write('xxx.rc', '1 MESSAGETABLE \"xxx.bin\"\\n')\n    t.write('xxx.bin', 'foo')\n\n    def test1(n, expect, noexec=False):\n        params = ['-sXXX=%d' % n]\n        if noexec:\n            params.append('-n')\n            params.append('-sNOEXEC=NOEXEC')\n        t.run_build_system(params)\n        t.expect_output_lines('*NOEXEC*', noexec)\n        obj_file = 'xxx_res.obj'\n        t.expect_output_lines('compile.resource.dummy *%s' % obj_file, expect)\n        if expect and (not noexec):\n            expect('bin/%s/debug/%s' % (toolsetName, obj_file))\n        t.expect_nothing_more()\n\n    def test(n, expect):\n        test1(n, expect, noexec=True)\n        test1(n, expect)\n    test(1, t.expect_addition)\n    test(2, None)\n    t.touch('xxx.bin')\n    test(3, t.expect_touch)\n    test(4, None)\n    t.cleanup()",
            "def included_resource_newer_than_rc_script():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n      When a .rc script file includes another resource file - the resource file\\n    being newer than the .rc script file should not cause the .rc script file\\n    to be considered old and force all of its dependents to rebuild.\\n\\n    '\n    toolsetName = '__myDummyResourceCompilerToolset__'\n    t = BoostBuild.Tester(['-d4', '--debug-configuration', '--ignore-site-config', '--user-config=', 'toolset=%s' % toolsetName], pass_toolset=False, use_test_config=False, translate_suffixes=False)\n    t.write(toolsetName + '.jam', 'import feature ;\\nimport rc ;\\nimport type ;\\nlocal toolset-name = \"%s\" ;\\nfeature.extend toolset : $(toolset-name) ;\\nrule init ( ) { }\\nrc.configure dummy-rc-command : <toolset>$(toolset-name) : <rc-type>dummy ;\\nmodule rc\\n{\\n    rule compile.resource.dummy ( targets * : sources * : properties * )\\n    {\\n        import common ;\\n        .TOUCH on $(targets) = [ common.file-touch-command ] ;\\n    }\\n    actions compile.resource.dummy { $(.TOUCH) \"$(<)\" }\\n}\\n# Make OBJ files generated by our toolset use the \"obj\" suffix on all\\n# platforms. We need to do this explicitly for <target-os> windows & cygwin to\\n# override the default OBJ type configuration (otherwise we would get\\n# \\'ambiguous key\\' errors on those platforms).\\nlocal rule set-generated-obj-suffix ( target-os ? )\\n{\\n    type.set-generated-target-suffix OBJ : <toolset>$(toolset-name)\\n        <target-os>$(target-os) : obj ;\\n}\\nset-generated-obj-suffix ;\\nset-generated-obj-suffix windows ;\\nset-generated-obj-suffix cygwin ;\\n' % toolsetName)\n    t.write(toolsetName + '.py', '\\nfrom b2.build import feature, type as type_\\nfrom b2.manager import get_manager\\nfrom b2.tools import rc, common\\n\\nMANAGER = get_manager()\\nENGINE = MANAGER.engine()\\n\\ntoolset_name = \"{0}\"\\n\\nfeature.extend(\\'toolset\\', [toolset_name])\\n\\ndef init(*args):\\n    pass\\n\\nrc.configure([\\'dummy-rc-command\\'], [\\'<toolset>\\' + toolset_name], [\\'<rc-type>dummy\\'])\\n\\nENGINE.register_action(\\n    \\'rc.compile.resource.dummy\\',\\n    \\'\\'\\'\\n    %s \"$(<)\"\\n    \\'\\'\\' % common.file_creation_command()\\n)\\n\\ndef set_generated_obj_suffix(target_os=\\'\\'):\\n    requirements = [\\'<toolset>\\' + toolset_name]\\n    if target_os:\\n        requirements.append(\\'<target-os>\\' + target_os)\\n    type_.set_generated_target_suffix(\\'OBJ\\', requirements, \\'obj\\')\\n\\nset_generated_obj_suffix()\\nset_generated_obj_suffix(\\'windows\\')\\nset_generated_obj_suffix(\\'cygwin\\')\\n'.format(toolsetName))\n    t.write('jamroot.jam', 'ECHO \"{{{\" [ modules.peek : XXX ] [ modules.peek : NOEXEC ] \"}}}\" ;\\nobj xxx : xxx.rc ;\\n')\n    t.write('xxx.rc', '1 MESSAGETABLE \"xxx.bin\"\\n')\n    t.write('xxx.bin', 'foo')\n\n    def test1(n, expect, noexec=False):\n        params = ['-sXXX=%d' % n]\n        if noexec:\n            params.append('-n')\n            params.append('-sNOEXEC=NOEXEC')\n        t.run_build_system(params)\n        t.expect_output_lines('*NOEXEC*', noexec)\n        obj_file = 'xxx_res.obj'\n        t.expect_output_lines('compile.resource.dummy *%s' % obj_file, expect)\n        if expect and (not noexec):\n            expect('bin/%s/debug/%s' % (toolsetName, obj_file))\n        t.expect_nothing_more()\n\n    def test(n, expect):\n        test1(n, expect, noexec=True)\n        test1(n, expect)\n    test(1, t.expect_addition)\n    test(2, None)\n    t.touch('xxx.bin')\n    test(3, t.expect_touch)\n    test(4, None)\n    t.cleanup()",
            "def included_resource_newer_than_rc_script():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n      When a .rc script file includes another resource file - the resource file\\n    being newer than the .rc script file should not cause the .rc script file\\n    to be considered old and force all of its dependents to rebuild.\\n\\n    '\n    toolsetName = '__myDummyResourceCompilerToolset__'\n    t = BoostBuild.Tester(['-d4', '--debug-configuration', '--ignore-site-config', '--user-config=', 'toolset=%s' % toolsetName], pass_toolset=False, use_test_config=False, translate_suffixes=False)\n    t.write(toolsetName + '.jam', 'import feature ;\\nimport rc ;\\nimport type ;\\nlocal toolset-name = \"%s\" ;\\nfeature.extend toolset : $(toolset-name) ;\\nrule init ( ) { }\\nrc.configure dummy-rc-command : <toolset>$(toolset-name) : <rc-type>dummy ;\\nmodule rc\\n{\\n    rule compile.resource.dummy ( targets * : sources * : properties * )\\n    {\\n        import common ;\\n        .TOUCH on $(targets) = [ common.file-touch-command ] ;\\n    }\\n    actions compile.resource.dummy { $(.TOUCH) \"$(<)\" }\\n}\\n# Make OBJ files generated by our toolset use the \"obj\" suffix on all\\n# platforms. We need to do this explicitly for <target-os> windows & cygwin to\\n# override the default OBJ type configuration (otherwise we would get\\n# \\'ambiguous key\\' errors on those platforms).\\nlocal rule set-generated-obj-suffix ( target-os ? )\\n{\\n    type.set-generated-target-suffix OBJ : <toolset>$(toolset-name)\\n        <target-os>$(target-os) : obj ;\\n}\\nset-generated-obj-suffix ;\\nset-generated-obj-suffix windows ;\\nset-generated-obj-suffix cygwin ;\\n' % toolsetName)\n    t.write(toolsetName + '.py', '\\nfrom b2.build import feature, type as type_\\nfrom b2.manager import get_manager\\nfrom b2.tools import rc, common\\n\\nMANAGER = get_manager()\\nENGINE = MANAGER.engine()\\n\\ntoolset_name = \"{0}\"\\n\\nfeature.extend(\\'toolset\\', [toolset_name])\\n\\ndef init(*args):\\n    pass\\n\\nrc.configure([\\'dummy-rc-command\\'], [\\'<toolset>\\' + toolset_name], [\\'<rc-type>dummy\\'])\\n\\nENGINE.register_action(\\n    \\'rc.compile.resource.dummy\\',\\n    \\'\\'\\'\\n    %s \"$(<)\"\\n    \\'\\'\\' % common.file_creation_command()\\n)\\n\\ndef set_generated_obj_suffix(target_os=\\'\\'):\\n    requirements = [\\'<toolset>\\' + toolset_name]\\n    if target_os:\\n        requirements.append(\\'<target-os>\\' + target_os)\\n    type_.set_generated_target_suffix(\\'OBJ\\', requirements, \\'obj\\')\\n\\nset_generated_obj_suffix()\\nset_generated_obj_suffix(\\'windows\\')\\nset_generated_obj_suffix(\\'cygwin\\')\\n'.format(toolsetName))\n    t.write('jamroot.jam', 'ECHO \"{{{\" [ modules.peek : XXX ] [ modules.peek : NOEXEC ] \"}}}\" ;\\nobj xxx : xxx.rc ;\\n')\n    t.write('xxx.rc', '1 MESSAGETABLE \"xxx.bin\"\\n')\n    t.write('xxx.bin', 'foo')\n\n    def test1(n, expect, noexec=False):\n        params = ['-sXXX=%d' % n]\n        if noexec:\n            params.append('-n')\n            params.append('-sNOEXEC=NOEXEC')\n        t.run_build_system(params)\n        t.expect_output_lines('*NOEXEC*', noexec)\n        obj_file = 'xxx_res.obj'\n        t.expect_output_lines('compile.resource.dummy *%s' % obj_file, expect)\n        if expect and (not noexec):\n            expect('bin/%s/debug/%s' % (toolsetName, obj_file))\n        t.expect_nothing_more()\n\n    def test(n, expect):\n        test1(n, expect, noexec=True)\n        test1(n, expect)\n    test(1, t.expect_addition)\n    test(2, None)\n    t.touch('xxx.bin')\n    test(3, t.expect_touch)\n    test(4, None)\n    t.cleanup()",
            "def included_resource_newer_than_rc_script():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n      When a .rc script file includes another resource file - the resource file\\n    being newer than the .rc script file should not cause the .rc script file\\n    to be considered old and force all of its dependents to rebuild.\\n\\n    '\n    toolsetName = '__myDummyResourceCompilerToolset__'\n    t = BoostBuild.Tester(['-d4', '--debug-configuration', '--ignore-site-config', '--user-config=', 'toolset=%s' % toolsetName], pass_toolset=False, use_test_config=False, translate_suffixes=False)\n    t.write(toolsetName + '.jam', 'import feature ;\\nimport rc ;\\nimport type ;\\nlocal toolset-name = \"%s\" ;\\nfeature.extend toolset : $(toolset-name) ;\\nrule init ( ) { }\\nrc.configure dummy-rc-command : <toolset>$(toolset-name) : <rc-type>dummy ;\\nmodule rc\\n{\\n    rule compile.resource.dummy ( targets * : sources * : properties * )\\n    {\\n        import common ;\\n        .TOUCH on $(targets) = [ common.file-touch-command ] ;\\n    }\\n    actions compile.resource.dummy { $(.TOUCH) \"$(<)\" }\\n}\\n# Make OBJ files generated by our toolset use the \"obj\" suffix on all\\n# platforms. We need to do this explicitly for <target-os> windows & cygwin to\\n# override the default OBJ type configuration (otherwise we would get\\n# \\'ambiguous key\\' errors on those platforms).\\nlocal rule set-generated-obj-suffix ( target-os ? )\\n{\\n    type.set-generated-target-suffix OBJ : <toolset>$(toolset-name)\\n        <target-os>$(target-os) : obj ;\\n}\\nset-generated-obj-suffix ;\\nset-generated-obj-suffix windows ;\\nset-generated-obj-suffix cygwin ;\\n' % toolsetName)\n    t.write(toolsetName + '.py', '\\nfrom b2.build import feature, type as type_\\nfrom b2.manager import get_manager\\nfrom b2.tools import rc, common\\n\\nMANAGER = get_manager()\\nENGINE = MANAGER.engine()\\n\\ntoolset_name = \"{0}\"\\n\\nfeature.extend(\\'toolset\\', [toolset_name])\\n\\ndef init(*args):\\n    pass\\n\\nrc.configure([\\'dummy-rc-command\\'], [\\'<toolset>\\' + toolset_name], [\\'<rc-type>dummy\\'])\\n\\nENGINE.register_action(\\n    \\'rc.compile.resource.dummy\\',\\n    \\'\\'\\'\\n    %s \"$(<)\"\\n    \\'\\'\\' % common.file_creation_command()\\n)\\n\\ndef set_generated_obj_suffix(target_os=\\'\\'):\\n    requirements = [\\'<toolset>\\' + toolset_name]\\n    if target_os:\\n        requirements.append(\\'<target-os>\\' + target_os)\\n    type_.set_generated_target_suffix(\\'OBJ\\', requirements, \\'obj\\')\\n\\nset_generated_obj_suffix()\\nset_generated_obj_suffix(\\'windows\\')\\nset_generated_obj_suffix(\\'cygwin\\')\\n'.format(toolsetName))\n    t.write('jamroot.jam', 'ECHO \"{{{\" [ modules.peek : XXX ] [ modules.peek : NOEXEC ] \"}}}\" ;\\nobj xxx : xxx.rc ;\\n')\n    t.write('xxx.rc', '1 MESSAGETABLE \"xxx.bin\"\\n')\n    t.write('xxx.bin', 'foo')\n\n    def test1(n, expect, noexec=False):\n        params = ['-sXXX=%d' % n]\n        if noexec:\n            params.append('-n')\n            params.append('-sNOEXEC=NOEXEC')\n        t.run_build_system(params)\n        t.expect_output_lines('*NOEXEC*', noexec)\n        obj_file = 'xxx_res.obj'\n        t.expect_output_lines('compile.resource.dummy *%s' % obj_file, expect)\n        if expect and (not noexec):\n            expect('bin/%s/debug/%s' % (toolsetName, obj_file))\n        t.expect_nothing_more()\n\n    def test(n, expect):\n        test1(n, expect, noexec=True)\n        test1(n, expect)\n    test(1, t.expect_addition)\n    test(2, None)\n    t.touch('xxx.bin')\n    test(3, t.expect_touch)\n    test(4, None)\n    t.cleanup()",
            "def included_resource_newer_than_rc_script():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n      When a .rc script file includes another resource file - the resource file\\n    being newer than the .rc script file should not cause the .rc script file\\n    to be considered old and force all of its dependents to rebuild.\\n\\n    '\n    toolsetName = '__myDummyResourceCompilerToolset__'\n    t = BoostBuild.Tester(['-d4', '--debug-configuration', '--ignore-site-config', '--user-config=', 'toolset=%s' % toolsetName], pass_toolset=False, use_test_config=False, translate_suffixes=False)\n    t.write(toolsetName + '.jam', 'import feature ;\\nimport rc ;\\nimport type ;\\nlocal toolset-name = \"%s\" ;\\nfeature.extend toolset : $(toolset-name) ;\\nrule init ( ) { }\\nrc.configure dummy-rc-command : <toolset>$(toolset-name) : <rc-type>dummy ;\\nmodule rc\\n{\\n    rule compile.resource.dummy ( targets * : sources * : properties * )\\n    {\\n        import common ;\\n        .TOUCH on $(targets) = [ common.file-touch-command ] ;\\n    }\\n    actions compile.resource.dummy { $(.TOUCH) \"$(<)\" }\\n}\\n# Make OBJ files generated by our toolset use the \"obj\" suffix on all\\n# platforms. We need to do this explicitly for <target-os> windows & cygwin to\\n# override the default OBJ type configuration (otherwise we would get\\n# \\'ambiguous key\\' errors on those platforms).\\nlocal rule set-generated-obj-suffix ( target-os ? )\\n{\\n    type.set-generated-target-suffix OBJ : <toolset>$(toolset-name)\\n        <target-os>$(target-os) : obj ;\\n}\\nset-generated-obj-suffix ;\\nset-generated-obj-suffix windows ;\\nset-generated-obj-suffix cygwin ;\\n' % toolsetName)\n    t.write(toolsetName + '.py', '\\nfrom b2.build import feature, type as type_\\nfrom b2.manager import get_manager\\nfrom b2.tools import rc, common\\n\\nMANAGER = get_manager()\\nENGINE = MANAGER.engine()\\n\\ntoolset_name = \"{0}\"\\n\\nfeature.extend(\\'toolset\\', [toolset_name])\\n\\ndef init(*args):\\n    pass\\n\\nrc.configure([\\'dummy-rc-command\\'], [\\'<toolset>\\' + toolset_name], [\\'<rc-type>dummy\\'])\\n\\nENGINE.register_action(\\n    \\'rc.compile.resource.dummy\\',\\n    \\'\\'\\'\\n    %s \"$(<)\"\\n    \\'\\'\\' % common.file_creation_command()\\n)\\n\\ndef set_generated_obj_suffix(target_os=\\'\\'):\\n    requirements = [\\'<toolset>\\' + toolset_name]\\n    if target_os:\\n        requirements.append(\\'<target-os>\\' + target_os)\\n    type_.set_generated_target_suffix(\\'OBJ\\', requirements, \\'obj\\')\\n\\nset_generated_obj_suffix()\\nset_generated_obj_suffix(\\'windows\\')\\nset_generated_obj_suffix(\\'cygwin\\')\\n'.format(toolsetName))\n    t.write('jamroot.jam', 'ECHO \"{{{\" [ modules.peek : XXX ] [ modules.peek : NOEXEC ] \"}}}\" ;\\nobj xxx : xxx.rc ;\\n')\n    t.write('xxx.rc', '1 MESSAGETABLE \"xxx.bin\"\\n')\n    t.write('xxx.bin', 'foo')\n\n    def test1(n, expect, noexec=False):\n        params = ['-sXXX=%d' % n]\n        if noexec:\n            params.append('-n')\n            params.append('-sNOEXEC=NOEXEC')\n        t.run_build_system(params)\n        t.expect_output_lines('*NOEXEC*', noexec)\n        obj_file = 'xxx_res.obj'\n        t.expect_output_lines('compile.resource.dummy *%s' % obj_file, expect)\n        if expect and (not noexec):\n            expect('bin/%s/debug/%s' % (toolsetName, obj_file))\n        t.expect_nothing_more()\n\n    def test(n, expect):\n        test1(n, expect, noexec=True)\n        test1(n, expect)\n    test(1, t.expect_addition)\n    test(2, None)\n    t.touch('xxx.bin')\n    test(3, t.expect_touch)\n    test(4, None)\n    t.cleanup()"
        ]
    }
]