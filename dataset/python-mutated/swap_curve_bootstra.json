[
    {
        "func_name": "default_interpolator",
        "original": "def default_interpolator(xi, x, y):\n    return linear.interpolate(xi, x, y, dtype=dtype)",
        "mutated": [
            "def default_interpolator(xi, x, y):\n    if False:\n        i = 10\n    return linear.interpolate(xi, x, y, dtype=dtype)",
            "def default_interpolator(xi, x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return linear.interpolate(xi, x, y, dtype=dtype)",
            "def default_interpolator(xi, x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return linear.interpolate(xi, x, y, dtype=dtype)",
            "def default_interpolator(xi, x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return linear.interpolate(xi, x, y, dtype=dtype)",
            "def default_interpolator(xi, x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return linear.interpolate(xi, x, y, dtype=dtype)"
        ]
    },
    {
        "func_name": "swap_curve_bootstrap",
        "original": "def swap_curve_bootstrap(float_leg_start_times: List[types.RealTensor], float_leg_end_times: List[types.RealTensor], fixed_leg_start_times: List[types.RealTensor], fixed_leg_end_times: List[types.RealTensor], fixed_leg_cashflows: List[types.RealTensor], present_values: List[types.RealTensor], present_values_settlement_times: List[types.RealTensor]=None, float_leg_daycount_fractions: List[types.RealTensor]=None, fixed_leg_daycount_fractions: List[types.RealTensor]=None, float_leg_discount_rates: List[types.RealTensor]=None, float_leg_discount_times: List[types.RealTensor]=None, fixed_leg_discount_rates: List[types.RealTensor]=None, fixed_leg_discount_times: List[types.RealTensor]=None, curve_interpolator: Callable[..., types.RealTensor]=None, initial_curve_rates: types.RealTensor=None, curve_tolerance: types.RealTensor=1e-08, maximum_iterations: types.IntTensor=50, dtype: tf.DType=None, name: str=None) -> scc.SwapCurveBuilderResult:\n    \"\"\"Constructs the zero swap curve using bootstrap method.\n\n  A zero swap curve is a function of time which gives the interest rate that\n  can be used to project forward rates at arbitrary `t` for the valuation of\n  interest rate securities (e.g. FRAs, Interest rate futures, Swaps etc.).\n\n  Suppose we have a set of `N` Interest Rate Swaps (IRS) `S_i` with increasing\n  expiries whose market prices are known.\n  Suppose also that the `i`th IRS issues cashflows at times `T_{ij}` where\n  `1 <= j <= n_i` and `n_i` is the number of cashflows (including expiry)\n  for the `i`th swap.\n  Denote by `T_i` the time of final payment for the `i`th swap\n  (hence `T_i = T_{i,n_i}`). This function estimates a set of rates `r(T_i)`\n  such that when these rates are interpolated (using the user specified\n  interpolation method) to all other cashflow times, the computed value of the\n  swaps matches the market value of the swaps (within some tolerance).\n\n  The algorithm implemented here uses the bootstrap method to iteratively\n  construct the swap curve [1].\n\n  #### Example:\n\n  The following example illustrates the usage by building an implied swap curve\n  from four vanilla (fixed to float) LIBOR swaps.\n\n  ```python\n\n  dtype = np.float64\n\n  # Next we will set up LIBOR reset and payment times for four spot starting\n  # swaps with maturities 1Y, 2Y, 3Y, 4Y. The LIBOR rate spans 6M.\n\n  float_leg_start_times = [\n            np.array([0., 0.5], dtype=dtype),\n            np.array([0., 0.5, 1., 1.5], dtype=dtype),\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5], dtype=dtype),\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5], dtype=dtype)\n        ]\n\n  float_leg_end_times = [\n            np.array([0.5, 1.0], dtype=dtype),\n            np.array([0.5, 1., 1.5, 2.0], dtype=dtype),\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\n        ]\n\n  # Next we will set up start and end times for semi-annual fixed coupons.\n\n  fixed_leg_start_times = [\n            np.array([0., 0.5], dtype=dtype),\n            np.array([0., 0.5, 1., 1.5], dtype=dtype),\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5], dtype=dtype),\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5], dtype=dtype)\n        ]\n\n  fixed_leg_end_times = [\n            np.array([0.5, 1.0], dtype=dtype),\n            np.array([0.5, 1., 1.5, 2.0], dtype=dtype),\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\n        ]\n\n  # Next setup a trivial daycount for floating and fixed legs.\n\n  float_leg_daycount = [\n            np.array([0.5, 0.5], dtype=dtype),\n            np.array([0.5, 0.5, 0.5, 0.5], dtype=dtype),\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype),\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype)\n        ]\n\n  fixed_leg_daycount = [\n            np.array([0.5, 0.5], dtype=dtype),\n            np.array([0.5, 0.5, 0.5, 0.5], dtype=dtype),\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype),\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype)\n        ]\n\n  fixed_leg_cashflows = [\n        # 1 year swap with 2.855% semi-annual fixed payments.\n        np.array([-0.02855, -0.02855], dtype=dtype),\n        # 2 year swap with 3.097% semi-annual fixed payments.\n        np.array([-0.03097, -0.03097, -0.03097, -0.03097], dtype=dtype),\n        # 3 year swap with 3.1% semi-annual fixed payments.\n        np.array([-0.031, -0.031, -0.031, -0.031, -0.031, -0.031], dtype=dtype),\n        # 4 year swap with 3.2% semi-annual fixed payments.\n        np.array([-0.032, -0.032, -0.032, -0.032, -0.032, -0.032, -0.032,\n        -0.032], dtype=dtype)\n    ]\n\n  # The present values of the above IRS.\n    pvs = np.array([0., 0., 0., 0.], dtype=dtype)\n\n  # Initial state of the curve.\n  initial_curve_rates = np.array([0.01, 0.01, 0.01, 0.01], dtype=dtype)\n\n  results = swap_curve_bootstrap(float_leg_start_times, float_leg_end_times,\n                                 float_leg_daycount, fixed_leg_start_times,\n                                 fixed_leg_end_times, fixed_leg_cashflows,\n                                 fixed_leg_daycount, pvs, dtype=dtype,\n                                 initial_curve_rates=initial_curve_rates)\n\n  #### References:\n\n  [1]: Patrick Hagan & Graeme West. Interpolation Methods for Curve\n    Construction. Applied Mathematical Finance. Vol 13, No. 2, pp 89-129.\n    June 2006.\n    https://www.researchgate.net/publication/24071726_Interpolation_Methods_for_Curve_Construction\n\n  Args:\n    float_leg_start_times: List of `Tensor`s. Each `Tensor` must be of rank 1\n      and of the same real dtype. They may be of different sizes. Each `Tensor`\n      represents the beginning of the accrual period for the forward rate which\n      determines the floating payment. Each element in the list belong to a\n      unique swap to be used to build the curve.\n    float_leg_end_times: List of `Tensor`s. Each `Tensor` must be of rank 1 and\n      and the same shape and of the same real dtype as the corresponding element\n      in `float_leg_start_times`. Each `Tensor` represents the end of the\n      accrual period for the forward rate which determines the floating payment.\n    fixed_leg_start_times: List of `Tensor`s. Each `Tensor` must be of rank 1\n      and of the same real dtype. They may be of different sizes. Each `Tensor`\n      represents the beginning of the accrual period fixed coupon.\n    fixed_leg_end_times: List of `Tensor`s. Each `Tensor` must be of the same\n      shape and type as `fixed_leg_start_times`. Each `Tensor` represents the\n      end of the accrual period for the fixed coupon.\n    fixed_leg_cashflows: List of `Tensor`s. The list must be of the same length\n      as the `fixed_leg_start_times`. Each `Tensor` must be of rank 1 and of the\n      same dtype as the `Tensor`s in `fixed_leg_start_times`. The input contains\n      fixed cashflows at each coupon payment time including notional (if any).\n      The sign should be negative (positive) to indicate net outgoing (incoming)\n      cashflow.\n    present_values: List containing scalar `Tensor`s of the same dtype as\n      elements of `fixed_leg_cashflows`. The length of the list must be the same\n      as the length of `fixed_leg_cashflows`. The input contains the market\n      price of the underlying instruments.\n    present_values_settlement_times: List containing scalar `Tensor`s of the\n      same dtype as elements of `present_values`. The length of the list must be\n      the same as the length of `present_values`. The settlement times for the\n      present values is the time from now when the instrument is traded to the\n      time that the purchase price is actually delivered. If not supplied, then\n      it is assumed that the settlement times are zero for every bond.\n      Default value: `None`, which is equivalent to zero settlement times.\n    float_leg_daycount_fractions: Optional list of `Tensor`s. Each `Tensor` must\n      be of the same shape and type as `float_leg_start_times`. They may be of\n      different sizes. Each `Tensor` represents the daycount fraction of the\n      forward rate which determines the floating payment.\n      Default value: `None`, If omitted the daycount fractions are computed as\n      the difference between float_leg_end_times and float_leg_start_times.\n    fixed_leg_daycount_fractions: Optional list of `Tensor`s. Each `Tensor` must\n      be of the same shape and type as `fixed_leg_start_times`. Each `Tensor`\n      represents the daycount fraction applicable for the fixed payment.\n      Default value: `None`, If omitted the daycount fractions are computed as\n      the difference between fixed_leg_end_times and fixed_leg_start_times.\n    float_leg_discount_rates: Optional `Tensor` of the same dtype as\n      `initial_discount_rates`. This input contains the continuously compounded\n      discount rates the will be used to discount the floating cashflows. This\n      allows the swap curve to constructed using an independent discount curve\n      (e.g. OIS curve).\n      Default value: `None`, in which case the cashflows are discounted using\n      the curve that is being constructed.\n    float_leg_discount_times: Optional `Tensor` of the same dtype and shape as\n      `float_leg_discount_rates`. This input contains the times corresponding to\n      the rates specified via the `float_leg_discount_rates`.\n    fixed_leg_discount_rates: Optional `Tensor` of the same dtype as\n      `initial_discount_rates`. This input contains the continuously compounded\n      discount rates the will be used to discount the fixed cashflows. This\n      allows the swap curve to constructed using an independent discount curve\n      (e.g. OIS curve).\n      Default value: `None`, in which case the cashflows are discounted using\n      the curve that is being constructed.\n    fixed_leg_discount_times: Optional `Tensor` of the same dtype and shape as\n      `fixed_leg_discount_rates`. This input contains the times corresponding to\n      the rates specified via the `fixed_leg_discount_rates`.\n    curve_interpolator: Optional Python callable used to interpolate the zero\n      swap rates at cashflow times. It should have the following interface:\n      yi = curve_interpolator(xi, x, y)\n      `x`, `y`, 'xi', 'yi' are all `Tensors` of real dtype. `x` and `y` are the\n      sample points and values (respectively) of the function to be\n      interpolated. `xi` are the points at which the interpolation is\n      desired and `yi` are the corresponding interpolated values returned by the\n      function.\n      Default value: `None`, which maps to linear interpolation.\n    initial_curve_rates: Optional `Tensor` of the same dtype and shape as\n      `present_values`. The starting guess for the discount rates used to\n      initialize the iterative procedure.\n      Default value: `None`. If not supplied, the yields to maturity for the\n        bonds is used as the initial value.\n    curve_tolerance: Optional positive scalar `Tensor` of same dtype as\n      elements of `bond_cashflows`. The absolute tolerance for terminating the\n      iterations used to fit the rate curve. The iterations are stopped when the\n      estimated discounts at the expiry times of the bond_cashflows change by a\n      amount smaller than `discount_tolerance` in an iteration.\n      Default value: 1e-8.\n    maximum_iterations: Optional positive integer `Tensor`. The maximum number\n      of iterations permitted when fitting the curve.\n      Default value: 50.\n    dtype: `tf.Dtype`. If supplied the dtype for the (elements of)\n      `float_leg_start_times`, and `fixed_leg_start_times`.\n      Default value: None which maps to the default dtype inferred by\n      TensorFlow.\n    name: Python str. The name to give to the ops created by this function.\n      Default value: `None` which maps to 'swap_curve'.\n\n  Returns:\n    curve_builder_result: An instance of `SwapCurveBuilderResult` containing the\n      following attributes.\n      times: Rank 1 real `Tensor`. Times for the computed rates. These\n        are chosen to be the expiry times of the supplied instruments.\n      rates: Rank 1 `Tensor` of the same dtype as `times`.\n        The inferred zero rates.\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\n        The inferred discount factors.\n      initial_rates: Rank 1 `Tensor` of the same dtype as `times`. The\n        initial guess for the rates.\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\n        The procedure is said to have converged when the maximum absolute\n        difference in the discount factors from one iteration to the next falls\n        below the `discount_tolerance`.\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\n        may fail either because a NaN value was encountered for the discount\n        rates or the discount factors.\n      iterations: Scalar int32 `Tensor`. Number of iterations performed.\n\n  Raises:\n    ValueError: If the initial state of the curve is not\n    supplied to the function.\n\n  \"\"\"\n    name = name or 'swap_curve_bootstrap'\n    with tf.name_scope(name):\n        if curve_interpolator is None:\n\n            def default_interpolator(xi, x, y):\n                return linear.interpolate(xi, x, y, dtype=dtype)\n            curve_interpolator = default_interpolator\n        if present_values_settlement_times is None:\n            pv_settle_times = [tf.zeros_like(pv) for pv in present_values]\n        else:\n            pv_settle_times = present_values_settlement_times\n        if float_leg_daycount_fractions is None:\n            float_leg_daycount_fractions = [y - x for (x, y) in zip(float_leg_start_times, float_leg_end_times)]\n        if fixed_leg_daycount_fractions is None:\n            fixed_leg_daycount_fractions = [y - x for (x, y) in zip(fixed_leg_start_times, fixed_leg_end_times)]\n        float_leg_start_times = _convert_to_tensors(dtype, float_leg_start_times, 'float_leg_start_times')\n        float_leg_end_times = _convert_to_tensors(dtype, float_leg_end_times, 'float_leg_end_times')\n        float_leg_daycount_fractions = _convert_to_tensors(dtype, float_leg_daycount_fractions, 'float_leg_daycount_fractions')\n        fixed_leg_start_times = _convert_to_tensors(dtype, fixed_leg_start_times, 'fixed_leg_start_times')\n        fixed_leg_end_times = _convert_to_tensors(dtype, fixed_leg_end_times, 'fixed_leg_end_times')\n        fixed_leg_daycount_fractions = _convert_to_tensors(dtype, fixed_leg_daycount_fractions, 'fixed_leg_daycount_fractions')\n        fixed_leg_cashflows = _convert_to_tensors(dtype, fixed_leg_cashflows, 'fixed_leg_cashflows')\n        present_values = _convert_to_tensors(dtype, present_values, 'present_values')\n        pv_settle_times = _convert_to_tensors(dtype, pv_settle_times, 'pv_settle_times')\n        self_discounting_float_leg = False\n        self_discounting_fixed_leg = False\n        if float_leg_discount_rates is None and fixed_leg_discount_rates is None:\n            self_discounting_float_leg = True\n            self_discounting_fixed_leg = True\n            float_leg_discount_rates = [0.0]\n            float_leg_discount_times = [0.0]\n            fixed_leg_discount_rates = [0.0]\n            fixed_leg_discount_times = [0.0]\n        elif fixed_leg_discount_rates is None:\n            fixed_leg_discount_rates = float_leg_discount_rates\n            fixed_leg_discount_times = float_leg_discount_times\n        elif float_leg_discount_rates is None:\n            self_discounting_float_leg = True\n            float_leg_discount_rates = [0.0]\n            float_leg_discount_times = [0.0]\n        float_leg_discount_rates = _convert_to_tensors(dtype, float_leg_discount_rates, 'float_disc_rates')\n        float_leg_discount_times = _convert_to_tensors(dtype, float_leg_discount_times, 'float_disc_times')\n        fixed_leg_discount_rates = _convert_to_tensors(dtype, fixed_leg_discount_rates, 'fixed_disc_rates')\n        fixed_leg_discount_times = _convert_to_tensors(dtype, fixed_leg_discount_times, 'fixed_disc_times')\n        if initial_curve_rates is not None:\n            initial_rates = tf.convert_to_tensor(initial_curve_rates, dtype=dtype, name='initial_rates')\n        else:\n            raise ValueError('Initial state of the curve is not specified.')\n        return _build_swap_curve(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions, float_leg_discount_rates, float_leg_discount_times, fixed_leg_discount_rates, fixed_leg_discount_times, self_discounting_float_leg, self_discounting_fixed_leg, present_values, pv_settle_times, curve_interpolator, initial_rates, curve_tolerance, maximum_iterations, dtype)",
        "mutated": [
            "def swap_curve_bootstrap(float_leg_start_times: List[types.RealTensor], float_leg_end_times: List[types.RealTensor], fixed_leg_start_times: List[types.RealTensor], fixed_leg_end_times: List[types.RealTensor], fixed_leg_cashflows: List[types.RealTensor], present_values: List[types.RealTensor], present_values_settlement_times: List[types.RealTensor]=None, float_leg_daycount_fractions: List[types.RealTensor]=None, fixed_leg_daycount_fractions: List[types.RealTensor]=None, float_leg_discount_rates: List[types.RealTensor]=None, float_leg_discount_times: List[types.RealTensor]=None, fixed_leg_discount_rates: List[types.RealTensor]=None, fixed_leg_discount_times: List[types.RealTensor]=None, curve_interpolator: Callable[..., types.RealTensor]=None, initial_curve_rates: types.RealTensor=None, curve_tolerance: types.RealTensor=1e-08, maximum_iterations: types.IntTensor=50, dtype: tf.DType=None, name: str=None) -> scc.SwapCurveBuilderResult:\n    if False:\n        i = 10\n    \"Constructs the zero swap curve using bootstrap method.\\n\\n  A zero swap curve is a function of time which gives the interest rate that\\n  can be used to project forward rates at arbitrary `t` for the valuation of\\n  interest rate securities (e.g. FRAs, Interest rate futures, Swaps etc.).\\n\\n  Suppose we have a set of `N` Interest Rate Swaps (IRS) `S_i` with increasing\\n  expiries whose market prices are known.\\n  Suppose also that the `i`th IRS issues cashflows at times `T_{ij}` where\\n  `1 <= j <= n_i` and `n_i` is the number of cashflows (including expiry)\\n  for the `i`th swap.\\n  Denote by `T_i` the time of final payment for the `i`th swap\\n  (hence `T_i = T_{i,n_i}`). This function estimates a set of rates `r(T_i)`\\n  such that when these rates are interpolated (using the user specified\\n  interpolation method) to all other cashflow times, the computed value of the\\n  swaps matches the market value of the swaps (within some tolerance).\\n\\n  The algorithm implemented here uses the bootstrap method to iteratively\\n  construct the swap curve [1].\\n\\n  #### Example:\\n\\n  The following example illustrates the usage by building an implied swap curve\\n  from four vanilla (fixed to float) LIBOR swaps.\\n\\n  ```python\\n\\n  dtype = np.float64\\n\\n  # Next we will set up LIBOR reset and payment times for four spot starting\\n  # swaps with maturities 1Y, 2Y, 3Y, 4Y. The LIBOR rate spans 6M.\\n\\n  float_leg_start_times = [\\n            np.array([0., 0.5], dtype=dtype),\\n            np.array([0., 0.5, 1., 1.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5], dtype=dtype)\\n        ]\\n\\n  float_leg_end_times = [\\n            np.array([0.5, 1.0], dtype=dtype),\\n            np.array([0.5, 1., 1.5, 2.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\\n        ]\\n\\n  # Next we will set up start and end times for semi-annual fixed coupons.\\n\\n  fixed_leg_start_times = [\\n            np.array([0., 0.5], dtype=dtype),\\n            np.array([0., 0.5, 1., 1.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5], dtype=dtype)\\n        ]\\n\\n  fixed_leg_end_times = [\\n            np.array([0.5, 1.0], dtype=dtype),\\n            np.array([0.5, 1., 1.5, 2.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\\n        ]\\n\\n  # Next setup a trivial daycount for floating and fixed legs.\\n\\n  float_leg_daycount = [\\n            np.array([0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype)\\n        ]\\n\\n  fixed_leg_daycount = [\\n            np.array([0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype)\\n        ]\\n\\n  fixed_leg_cashflows = [\\n        # 1 year swap with 2.855% semi-annual fixed payments.\\n        np.array([-0.02855, -0.02855], dtype=dtype),\\n        # 2 year swap with 3.097% semi-annual fixed payments.\\n        np.array([-0.03097, -0.03097, -0.03097, -0.03097], dtype=dtype),\\n        # 3 year swap with 3.1% semi-annual fixed payments.\\n        np.array([-0.031, -0.031, -0.031, -0.031, -0.031, -0.031], dtype=dtype),\\n        # 4 year swap with 3.2% semi-annual fixed payments.\\n        np.array([-0.032, -0.032, -0.032, -0.032, -0.032, -0.032, -0.032,\\n        -0.032], dtype=dtype)\\n    ]\\n\\n  # The present values of the above IRS.\\n    pvs = np.array([0., 0., 0., 0.], dtype=dtype)\\n\\n  # Initial state of the curve.\\n  initial_curve_rates = np.array([0.01, 0.01, 0.01, 0.01], dtype=dtype)\\n\\n  results = swap_curve_bootstrap(float_leg_start_times, float_leg_end_times,\\n                                 float_leg_daycount, fixed_leg_start_times,\\n                                 fixed_leg_end_times, fixed_leg_cashflows,\\n                                 fixed_leg_daycount, pvs, dtype=dtype,\\n                                 initial_curve_rates=initial_curve_rates)\\n\\n  #### References:\\n\\n  [1]: Patrick Hagan & Graeme West. Interpolation Methods for Curve\\n    Construction. Applied Mathematical Finance. Vol 13, No. 2, pp 89-129.\\n    June 2006.\\n    https://www.researchgate.net/publication/24071726_Interpolation_Methods_for_Curve_Construction\\n\\n  Args:\\n    float_leg_start_times: List of `Tensor`s. Each `Tensor` must be of rank 1\\n      and of the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the beginning of the accrual period for the forward rate which\\n      determines the floating payment. Each element in the list belong to a\\n      unique swap to be used to build the curve.\\n    float_leg_end_times: List of `Tensor`s. Each `Tensor` must be of rank 1 and\\n      and the same shape and of the same real dtype as the corresponding element\\n      in `float_leg_start_times`. Each `Tensor` represents the end of the\\n      accrual period for the forward rate which determines the floating payment.\\n    fixed_leg_start_times: List of `Tensor`s. Each `Tensor` must be of rank 1\\n      and of the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the beginning of the accrual period fixed coupon.\\n    fixed_leg_end_times: List of `Tensor`s. Each `Tensor` must be of the same\\n      shape and type as `fixed_leg_start_times`. Each `Tensor` represents the\\n      end of the accrual period for the fixed coupon.\\n    fixed_leg_cashflows: List of `Tensor`s. The list must be of the same length\\n      as the `fixed_leg_start_times`. Each `Tensor` must be of rank 1 and of the\\n      same dtype as the `Tensor`s in `fixed_leg_start_times`. The input contains\\n      fixed cashflows at each coupon payment time including notional (if any).\\n      The sign should be negative (positive) to indicate net outgoing (incoming)\\n      cashflow.\\n    present_values: List containing scalar `Tensor`s of the same dtype as\\n      elements of `fixed_leg_cashflows`. The length of the list must be the same\\n      as the length of `fixed_leg_cashflows`. The input contains the market\\n      price of the underlying instruments.\\n    present_values_settlement_times: List containing scalar `Tensor`s of the\\n      same dtype as elements of `present_values`. The length of the list must be\\n      the same as the length of `present_values`. The settlement times for the\\n      present values is the time from now when the instrument is traded to the\\n      time that the purchase price is actually delivered. If not supplied, then\\n      it is assumed that the settlement times are zero for every bond.\\n      Default value: `None`, which is equivalent to zero settlement times.\\n    float_leg_daycount_fractions: Optional list of `Tensor`s. Each `Tensor` must\\n      be of the same shape and type as `float_leg_start_times`. They may be of\\n      different sizes. Each `Tensor` represents the daycount fraction of the\\n      forward rate which determines the floating payment.\\n      Default value: `None`, If omitted the daycount fractions are computed as\\n      the difference between float_leg_end_times and float_leg_start_times.\\n    fixed_leg_daycount_fractions: Optional list of `Tensor`s. Each `Tensor` must\\n      be of the same shape and type as `fixed_leg_start_times`. Each `Tensor`\\n      represents the daycount fraction applicable for the fixed payment.\\n      Default value: `None`, If omitted the daycount fractions are computed as\\n      the difference between fixed_leg_end_times and fixed_leg_start_times.\\n    float_leg_discount_rates: Optional `Tensor` of the same dtype as\\n      `initial_discount_rates`. This input contains the continuously compounded\\n      discount rates the will be used to discount the floating cashflows. This\\n      allows the swap curve to constructed using an independent discount curve\\n      (e.g. OIS curve).\\n      Default value: `None`, in which case the cashflows are discounted using\\n      the curve that is being constructed.\\n    float_leg_discount_times: Optional `Tensor` of the same dtype and shape as\\n      `float_leg_discount_rates`. This input contains the times corresponding to\\n      the rates specified via the `float_leg_discount_rates`.\\n    fixed_leg_discount_rates: Optional `Tensor` of the same dtype as\\n      `initial_discount_rates`. This input contains the continuously compounded\\n      discount rates the will be used to discount the fixed cashflows. This\\n      allows the swap curve to constructed using an independent discount curve\\n      (e.g. OIS curve).\\n      Default value: `None`, in which case the cashflows are discounted using\\n      the curve that is being constructed.\\n    fixed_leg_discount_times: Optional `Tensor` of the same dtype and shape as\\n      `fixed_leg_discount_rates`. This input contains the times corresponding to\\n      the rates specified via the `fixed_leg_discount_rates`.\\n    curve_interpolator: Optional Python callable used to interpolate the zero\\n      swap rates at cashflow times. It should have the following interface:\\n      yi = curve_interpolator(xi, x, y)\\n      `x`, `y`, 'xi', 'yi' are all `Tensors` of real dtype. `x` and `y` are the\\n      sample points and values (respectively) of the function to be\\n      interpolated. `xi` are the points at which the interpolation is\\n      desired and `yi` are the corresponding interpolated values returned by the\\n      function.\\n      Default value: `None`, which maps to linear interpolation.\\n    initial_curve_rates: Optional `Tensor` of the same dtype and shape as\\n      `present_values`. The starting guess for the discount rates used to\\n      initialize the iterative procedure.\\n      Default value: `None`. If not supplied, the yields to maturity for the\\n        bonds is used as the initial value.\\n    curve_tolerance: Optional positive scalar `Tensor` of same dtype as\\n      elements of `bond_cashflows`. The absolute tolerance for terminating the\\n      iterations used to fit the rate curve. The iterations are stopped when the\\n      estimated discounts at the expiry times of the bond_cashflows change by a\\n      amount smaller than `discount_tolerance` in an iteration.\\n      Default value: 1e-8.\\n    maximum_iterations: Optional positive integer `Tensor`. The maximum number\\n      of iterations permitted when fitting the curve.\\n      Default value: 50.\\n    dtype: `tf.Dtype`. If supplied the dtype for the (elements of)\\n      `float_leg_start_times`, and `fixed_leg_start_times`.\\n      Default value: None which maps to the default dtype inferred by\\n      TensorFlow.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: `None` which maps to 'swap_curve'.\\n\\n  Returns:\\n    curve_builder_result: An instance of `SwapCurveBuilderResult` containing the\\n      following attributes.\\n      times: Rank 1 real `Tensor`. Times for the computed rates. These\\n        are chosen to be the expiry times of the supplied instruments.\\n      rates: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred zero rates.\\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount factors.\\n      initial_rates: Rank 1 `Tensor` of the same dtype as `times`. The\\n        initial guess for the rates.\\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\\n        The procedure is said to have converged when the maximum absolute\\n        difference in the discount factors from one iteration to the next falls\\n        below the `discount_tolerance`.\\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\\n        may fail either because a NaN value was encountered for the discount\\n        rates or the discount factors.\\n      iterations: Scalar int32 `Tensor`. Number of iterations performed.\\n\\n  Raises:\\n    ValueError: If the initial state of the curve is not\\n    supplied to the function.\\n\\n  \"\n    name = name or 'swap_curve_bootstrap'\n    with tf.name_scope(name):\n        if curve_interpolator is None:\n\n            def default_interpolator(xi, x, y):\n                return linear.interpolate(xi, x, y, dtype=dtype)\n            curve_interpolator = default_interpolator\n        if present_values_settlement_times is None:\n            pv_settle_times = [tf.zeros_like(pv) for pv in present_values]\n        else:\n            pv_settle_times = present_values_settlement_times\n        if float_leg_daycount_fractions is None:\n            float_leg_daycount_fractions = [y - x for (x, y) in zip(float_leg_start_times, float_leg_end_times)]\n        if fixed_leg_daycount_fractions is None:\n            fixed_leg_daycount_fractions = [y - x for (x, y) in zip(fixed_leg_start_times, fixed_leg_end_times)]\n        float_leg_start_times = _convert_to_tensors(dtype, float_leg_start_times, 'float_leg_start_times')\n        float_leg_end_times = _convert_to_tensors(dtype, float_leg_end_times, 'float_leg_end_times')\n        float_leg_daycount_fractions = _convert_to_tensors(dtype, float_leg_daycount_fractions, 'float_leg_daycount_fractions')\n        fixed_leg_start_times = _convert_to_tensors(dtype, fixed_leg_start_times, 'fixed_leg_start_times')\n        fixed_leg_end_times = _convert_to_tensors(dtype, fixed_leg_end_times, 'fixed_leg_end_times')\n        fixed_leg_daycount_fractions = _convert_to_tensors(dtype, fixed_leg_daycount_fractions, 'fixed_leg_daycount_fractions')\n        fixed_leg_cashflows = _convert_to_tensors(dtype, fixed_leg_cashflows, 'fixed_leg_cashflows')\n        present_values = _convert_to_tensors(dtype, present_values, 'present_values')\n        pv_settle_times = _convert_to_tensors(dtype, pv_settle_times, 'pv_settle_times')\n        self_discounting_float_leg = False\n        self_discounting_fixed_leg = False\n        if float_leg_discount_rates is None and fixed_leg_discount_rates is None:\n            self_discounting_float_leg = True\n            self_discounting_fixed_leg = True\n            float_leg_discount_rates = [0.0]\n            float_leg_discount_times = [0.0]\n            fixed_leg_discount_rates = [0.0]\n            fixed_leg_discount_times = [0.0]\n        elif fixed_leg_discount_rates is None:\n            fixed_leg_discount_rates = float_leg_discount_rates\n            fixed_leg_discount_times = float_leg_discount_times\n        elif float_leg_discount_rates is None:\n            self_discounting_float_leg = True\n            float_leg_discount_rates = [0.0]\n            float_leg_discount_times = [0.0]\n        float_leg_discount_rates = _convert_to_tensors(dtype, float_leg_discount_rates, 'float_disc_rates')\n        float_leg_discount_times = _convert_to_tensors(dtype, float_leg_discount_times, 'float_disc_times')\n        fixed_leg_discount_rates = _convert_to_tensors(dtype, fixed_leg_discount_rates, 'fixed_disc_rates')\n        fixed_leg_discount_times = _convert_to_tensors(dtype, fixed_leg_discount_times, 'fixed_disc_times')\n        if initial_curve_rates is not None:\n            initial_rates = tf.convert_to_tensor(initial_curve_rates, dtype=dtype, name='initial_rates')\n        else:\n            raise ValueError('Initial state of the curve is not specified.')\n        return _build_swap_curve(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions, float_leg_discount_rates, float_leg_discount_times, fixed_leg_discount_rates, fixed_leg_discount_times, self_discounting_float_leg, self_discounting_fixed_leg, present_values, pv_settle_times, curve_interpolator, initial_rates, curve_tolerance, maximum_iterations, dtype)",
            "def swap_curve_bootstrap(float_leg_start_times: List[types.RealTensor], float_leg_end_times: List[types.RealTensor], fixed_leg_start_times: List[types.RealTensor], fixed_leg_end_times: List[types.RealTensor], fixed_leg_cashflows: List[types.RealTensor], present_values: List[types.RealTensor], present_values_settlement_times: List[types.RealTensor]=None, float_leg_daycount_fractions: List[types.RealTensor]=None, fixed_leg_daycount_fractions: List[types.RealTensor]=None, float_leg_discount_rates: List[types.RealTensor]=None, float_leg_discount_times: List[types.RealTensor]=None, fixed_leg_discount_rates: List[types.RealTensor]=None, fixed_leg_discount_times: List[types.RealTensor]=None, curve_interpolator: Callable[..., types.RealTensor]=None, initial_curve_rates: types.RealTensor=None, curve_tolerance: types.RealTensor=1e-08, maximum_iterations: types.IntTensor=50, dtype: tf.DType=None, name: str=None) -> scc.SwapCurveBuilderResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Constructs the zero swap curve using bootstrap method.\\n\\n  A zero swap curve is a function of time which gives the interest rate that\\n  can be used to project forward rates at arbitrary `t` for the valuation of\\n  interest rate securities (e.g. FRAs, Interest rate futures, Swaps etc.).\\n\\n  Suppose we have a set of `N` Interest Rate Swaps (IRS) `S_i` with increasing\\n  expiries whose market prices are known.\\n  Suppose also that the `i`th IRS issues cashflows at times `T_{ij}` where\\n  `1 <= j <= n_i` and `n_i` is the number of cashflows (including expiry)\\n  for the `i`th swap.\\n  Denote by `T_i` the time of final payment for the `i`th swap\\n  (hence `T_i = T_{i,n_i}`). This function estimates a set of rates `r(T_i)`\\n  such that when these rates are interpolated (using the user specified\\n  interpolation method) to all other cashflow times, the computed value of the\\n  swaps matches the market value of the swaps (within some tolerance).\\n\\n  The algorithm implemented here uses the bootstrap method to iteratively\\n  construct the swap curve [1].\\n\\n  #### Example:\\n\\n  The following example illustrates the usage by building an implied swap curve\\n  from four vanilla (fixed to float) LIBOR swaps.\\n\\n  ```python\\n\\n  dtype = np.float64\\n\\n  # Next we will set up LIBOR reset and payment times for four spot starting\\n  # swaps with maturities 1Y, 2Y, 3Y, 4Y. The LIBOR rate spans 6M.\\n\\n  float_leg_start_times = [\\n            np.array([0., 0.5], dtype=dtype),\\n            np.array([0., 0.5, 1., 1.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5], dtype=dtype)\\n        ]\\n\\n  float_leg_end_times = [\\n            np.array([0.5, 1.0], dtype=dtype),\\n            np.array([0.5, 1., 1.5, 2.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\\n        ]\\n\\n  # Next we will set up start and end times for semi-annual fixed coupons.\\n\\n  fixed_leg_start_times = [\\n            np.array([0., 0.5], dtype=dtype),\\n            np.array([0., 0.5, 1., 1.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5], dtype=dtype)\\n        ]\\n\\n  fixed_leg_end_times = [\\n            np.array([0.5, 1.0], dtype=dtype),\\n            np.array([0.5, 1., 1.5, 2.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\\n        ]\\n\\n  # Next setup a trivial daycount for floating and fixed legs.\\n\\n  float_leg_daycount = [\\n            np.array([0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype)\\n        ]\\n\\n  fixed_leg_daycount = [\\n            np.array([0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype)\\n        ]\\n\\n  fixed_leg_cashflows = [\\n        # 1 year swap with 2.855% semi-annual fixed payments.\\n        np.array([-0.02855, -0.02855], dtype=dtype),\\n        # 2 year swap with 3.097% semi-annual fixed payments.\\n        np.array([-0.03097, -0.03097, -0.03097, -0.03097], dtype=dtype),\\n        # 3 year swap with 3.1% semi-annual fixed payments.\\n        np.array([-0.031, -0.031, -0.031, -0.031, -0.031, -0.031], dtype=dtype),\\n        # 4 year swap with 3.2% semi-annual fixed payments.\\n        np.array([-0.032, -0.032, -0.032, -0.032, -0.032, -0.032, -0.032,\\n        -0.032], dtype=dtype)\\n    ]\\n\\n  # The present values of the above IRS.\\n    pvs = np.array([0., 0., 0., 0.], dtype=dtype)\\n\\n  # Initial state of the curve.\\n  initial_curve_rates = np.array([0.01, 0.01, 0.01, 0.01], dtype=dtype)\\n\\n  results = swap_curve_bootstrap(float_leg_start_times, float_leg_end_times,\\n                                 float_leg_daycount, fixed_leg_start_times,\\n                                 fixed_leg_end_times, fixed_leg_cashflows,\\n                                 fixed_leg_daycount, pvs, dtype=dtype,\\n                                 initial_curve_rates=initial_curve_rates)\\n\\n  #### References:\\n\\n  [1]: Patrick Hagan & Graeme West. Interpolation Methods for Curve\\n    Construction. Applied Mathematical Finance. Vol 13, No. 2, pp 89-129.\\n    June 2006.\\n    https://www.researchgate.net/publication/24071726_Interpolation_Methods_for_Curve_Construction\\n\\n  Args:\\n    float_leg_start_times: List of `Tensor`s. Each `Tensor` must be of rank 1\\n      and of the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the beginning of the accrual period for the forward rate which\\n      determines the floating payment. Each element in the list belong to a\\n      unique swap to be used to build the curve.\\n    float_leg_end_times: List of `Tensor`s. Each `Tensor` must be of rank 1 and\\n      and the same shape and of the same real dtype as the corresponding element\\n      in `float_leg_start_times`. Each `Tensor` represents the end of the\\n      accrual period for the forward rate which determines the floating payment.\\n    fixed_leg_start_times: List of `Tensor`s. Each `Tensor` must be of rank 1\\n      and of the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the beginning of the accrual period fixed coupon.\\n    fixed_leg_end_times: List of `Tensor`s. Each `Tensor` must be of the same\\n      shape and type as `fixed_leg_start_times`. Each `Tensor` represents the\\n      end of the accrual period for the fixed coupon.\\n    fixed_leg_cashflows: List of `Tensor`s. The list must be of the same length\\n      as the `fixed_leg_start_times`. Each `Tensor` must be of rank 1 and of the\\n      same dtype as the `Tensor`s in `fixed_leg_start_times`. The input contains\\n      fixed cashflows at each coupon payment time including notional (if any).\\n      The sign should be negative (positive) to indicate net outgoing (incoming)\\n      cashflow.\\n    present_values: List containing scalar `Tensor`s of the same dtype as\\n      elements of `fixed_leg_cashflows`. The length of the list must be the same\\n      as the length of `fixed_leg_cashflows`. The input contains the market\\n      price of the underlying instruments.\\n    present_values_settlement_times: List containing scalar `Tensor`s of the\\n      same dtype as elements of `present_values`. The length of the list must be\\n      the same as the length of `present_values`. The settlement times for the\\n      present values is the time from now when the instrument is traded to the\\n      time that the purchase price is actually delivered. If not supplied, then\\n      it is assumed that the settlement times are zero for every bond.\\n      Default value: `None`, which is equivalent to zero settlement times.\\n    float_leg_daycount_fractions: Optional list of `Tensor`s. Each `Tensor` must\\n      be of the same shape and type as `float_leg_start_times`. They may be of\\n      different sizes. Each `Tensor` represents the daycount fraction of the\\n      forward rate which determines the floating payment.\\n      Default value: `None`, If omitted the daycount fractions are computed as\\n      the difference between float_leg_end_times and float_leg_start_times.\\n    fixed_leg_daycount_fractions: Optional list of `Tensor`s. Each `Tensor` must\\n      be of the same shape and type as `fixed_leg_start_times`. Each `Tensor`\\n      represents the daycount fraction applicable for the fixed payment.\\n      Default value: `None`, If omitted the daycount fractions are computed as\\n      the difference between fixed_leg_end_times and fixed_leg_start_times.\\n    float_leg_discount_rates: Optional `Tensor` of the same dtype as\\n      `initial_discount_rates`. This input contains the continuously compounded\\n      discount rates the will be used to discount the floating cashflows. This\\n      allows the swap curve to constructed using an independent discount curve\\n      (e.g. OIS curve).\\n      Default value: `None`, in which case the cashflows are discounted using\\n      the curve that is being constructed.\\n    float_leg_discount_times: Optional `Tensor` of the same dtype and shape as\\n      `float_leg_discount_rates`. This input contains the times corresponding to\\n      the rates specified via the `float_leg_discount_rates`.\\n    fixed_leg_discount_rates: Optional `Tensor` of the same dtype as\\n      `initial_discount_rates`. This input contains the continuously compounded\\n      discount rates the will be used to discount the fixed cashflows. This\\n      allows the swap curve to constructed using an independent discount curve\\n      (e.g. OIS curve).\\n      Default value: `None`, in which case the cashflows are discounted using\\n      the curve that is being constructed.\\n    fixed_leg_discount_times: Optional `Tensor` of the same dtype and shape as\\n      `fixed_leg_discount_rates`. This input contains the times corresponding to\\n      the rates specified via the `fixed_leg_discount_rates`.\\n    curve_interpolator: Optional Python callable used to interpolate the zero\\n      swap rates at cashflow times. It should have the following interface:\\n      yi = curve_interpolator(xi, x, y)\\n      `x`, `y`, 'xi', 'yi' are all `Tensors` of real dtype. `x` and `y` are the\\n      sample points and values (respectively) of the function to be\\n      interpolated. `xi` are the points at which the interpolation is\\n      desired and `yi` are the corresponding interpolated values returned by the\\n      function.\\n      Default value: `None`, which maps to linear interpolation.\\n    initial_curve_rates: Optional `Tensor` of the same dtype and shape as\\n      `present_values`. The starting guess for the discount rates used to\\n      initialize the iterative procedure.\\n      Default value: `None`. If not supplied, the yields to maturity for the\\n        bonds is used as the initial value.\\n    curve_tolerance: Optional positive scalar `Tensor` of same dtype as\\n      elements of `bond_cashflows`. The absolute tolerance for terminating the\\n      iterations used to fit the rate curve. The iterations are stopped when the\\n      estimated discounts at the expiry times of the bond_cashflows change by a\\n      amount smaller than `discount_tolerance` in an iteration.\\n      Default value: 1e-8.\\n    maximum_iterations: Optional positive integer `Tensor`. The maximum number\\n      of iterations permitted when fitting the curve.\\n      Default value: 50.\\n    dtype: `tf.Dtype`. If supplied the dtype for the (elements of)\\n      `float_leg_start_times`, and `fixed_leg_start_times`.\\n      Default value: None which maps to the default dtype inferred by\\n      TensorFlow.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: `None` which maps to 'swap_curve'.\\n\\n  Returns:\\n    curve_builder_result: An instance of `SwapCurveBuilderResult` containing the\\n      following attributes.\\n      times: Rank 1 real `Tensor`. Times for the computed rates. These\\n        are chosen to be the expiry times of the supplied instruments.\\n      rates: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred zero rates.\\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount factors.\\n      initial_rates: Rank 1 `Tensor` of the same dtype as `times`. The\\n        initial guess for the rates.\\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\\n        The procedure is said to have converged when the maximum absolute\\n        difference in the discount factors from one iteration to the next falls\\n        below the `discount_tolerance`.\\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\\n        may fail either because a NaN value was encountered for the discount\\n        rates or the discount factors.\\n      iterations: Scalar int32 `Tensor`. Number of iterations performed.\\n\\n  Raises:\\n    ValueError: If the initial state of the curve is not\\n    supplied to the function.\\n\\n  \"\n    name = name or 'swap_curve_bootstrap'\n    with tf.name_scope(name):\n        if curve_interpolator is None:\n\n            def default_interpolator(xi, x, y):\n                return linear.interpolate(xi, x, y, dtype=dtype)\n            curve_interpolator = default_interpolator\n        if present_values_settlement_times is None:\n            pv_settle_times = [tf.zeros_like(pv) for pv in present_values]\n        else:\n            pv_settle_times = present_values_settlement_times\n        if float_leg_daycount_fractions is None:\n            float_leg_daycount_fractions = [y - x for (x, y) in zip(float_leg_start_times, float_leg_end_times)]\n        if fixed_leg_daycount_fractions is None:\n            fixed_leg_daycount_fractions = [y - x for (x, y) in zip(fixed_leg_start_times, fixed_leg_end_times)]\n        float_leg_start_times = _convert_to_tensors(dtype, float_leg_start_times, 'float_leg_start_times')\n        float_leg_end_times = _convert_to_tensors(dtype, float_leg_end_times, 'float_leg_end_times')\n        float_leg_daycount_fractions = _convert_to_tensors(dtype, float_leg_daycount_fractions, 'float_leg_daycount_fractions')\n        fixed_leg_start_times = _convert_to_tensors(dtype, fixed_leg_start_times, 'fixed_leg_start_times')\n        fixed_leg_end_times = _convert_to_tensors(dtype, fixed_leg_end_times, 'fixed_leg_end_times')\n        fixed_leg_daycount_fractions = _convert_to_tensors(dtype, fixed_leg_daycount_fractions, 'fixed_leg_daycount_fractions')\n        fixed_leg_cashflows = _convert_to_tensors(dtype, fixed_leg_cashflows, 'fixed_leg_cashflows')\n        present_values = _convert_to_tensors(dtype, present_values, 'present_values')\n        pv_settle_times = _convert_to_tensors(dtype, pv_settle_times, 'pv_settle_times')\n        self_discounting_float_leg = False\n        self_discounting_fixed_leg = False\n        if float_leg_discount_rates is None and fixed_leg_discount_rates is None:\n            self_discounting_float_leg = True\n            self_discounting_fixed_leg = True\n            float_leg_discount_rates = [0.0]\n            float_leg_discount_times = [0.0]\n            fixed_leg_discount_rates = [0.0]\n            fixed_leg_discount_times = [0.0]\n        elif fixed_leg_discount_rates is None:\n            fixed_leg_discount_rates = float_leg_discount_rates\n            fixed_leg_discount_times = float_leg_discount_times\n        elif float_leg_discount_rates is None:\n            self_discounting_float_leg = True\n            float_leg_discount_rates = [0.0]\n            float_leg_discount_times = [0.0]\n        float_leg_discount_rates = _convert_to_tensors(dtype, float_leg_discount_rates, 'float_disc_rates')\n        float_leg_discount_times = _convert_to_tensors(dtype, float_leg_discount_times, 'float_disc_times')\n        fixed_leg_discount_rates = _convert_to_tensors(dtype, fixed_leg_discount_rates, 'fixed_disc_rates')\n        fixed_leg_discount_times = _convert_to_tensors(dtype, fixed_leg_discount_times, 'fixed_disc_times')\n        if initial_curve_rates is not None:\n            initial_rates = tf.convert_to_tensor(initial_curve_rates, dtype=dtype, name='initial_rates')\n        else:\n            raise ValueError('Initial state of the curve is not specified.')\n        return _build_swap_curve(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions, float_leg_discount_rates, float_leg_discount_times, fixed_leg_discount_rates, fixed_leg_discount_times, self_discounting_float_leg, self_discounting_fixed_leg, present_values, pv_settle_times, curve_interpolator, initial_rates, curve_tolerance, maximum_iterations, dtype)",
            "def swap_curve_bootstrap(float_leg_start_times: List[types.RealTensor], float_leg_end_times: List[types.RealTensor], fixed_leg_start_times: List[types.RealTensor], fixed_leg_end_times: List[types.RealTensor], fixed_leg_cashflows: List[types.RealTensor], present_values: List[types.RealTensor], present_values_settlement_times: List[types.RealTensor]=None, float_leg_daycount_fractions: List[types.RealTensor]=None, fixed_leg_daycount_fractions: List[types.RealTensor]=None, float_leg_discount_rates: List[types.RealTensor]=None, float_leg_discount_times: List[types.RealTensor]=None, fixed_leg_discount_rates: List[types.RealTensor]=None, fixed_leg_discount_times: List[types.RealTensor]=None, curve_interpolator: Callable[..., types.RealTensor]=None, initial_curve_rates: types.RealTensor=None, curve_tolerance: types.RealTensor=1e-08, maximum_iterations: types.IntTensor=50, dtype: tf.DType=None, name: str=None) -> scc.SwapCurveBuilderResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Constructs the zero swap curve using bootstrap method.\\n\\n  A zero swap curve is a function of time which gives the interest rate that\\n  can be used to project forward rates at arbitrary `t` for the valuation of\\n  interest rate securities (e.g. FRAs, Interest rate futures, Swaps etc.).\\n\\n  Suppose we have a set of `N` Interest Rate Swaps (IRS) `S_i` with increasing\\n  expiries whose market prices are known.\\n  Suppose also that the `i`th IRS issues cashflows at times `T_{ij}` where\\n  `1 <= j <= n_i` and `n_i` is the number of cashflows (including expiry)\\n  for the `i`th swap.\\n  Denote by `T_i` the time of final payment for the `i`th swap\\n  (hence `T_i = T_{i,n_i}`). This function estimates a set of rates `r(T_i)`\\n  such that when these rates are interpolated (using the user specified\\n  interpolation method) to all other cashflow times, the computed value of the\\n  swaps matches the market value of the swaps (within some tolerance).\\n\\n  The algorithm implemented here uses the bootstrap method to iteratively\\n  construct the swap curve [1].\\n\\n  #### Example:\\n\\n  The following example illustrates the usage by building an implied swap curve\\n  from four vanilla (fixed to float) LIBOR swaps.\\n\\n  ```python\\n\\n  dtype = np.float64\\n\\n  # Next we will set up LIBOR reset and payment times for four spot starting\\n  # swaps with maturities 1Y, 2Y, 3Y, 4Y. The LIBOR rate spans 6M.\\n\\n  float_leg_start_times = [\\n            np.array([0., 0.5], dtype=dtype),\\n            np.array([0., 0.5, 1., 1.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5], dtype=dtype)\\n        ]\\n\\n  float_leg_end_times = [\\n            np.array([0.5, 1.0], dtype=dtype),\\n            np.array([0.5, 1., 1.5, 2.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\\n        ]\\n\\n  # Next we will set up start and end times for semi-annual fixed coupons.\\n\\n  fixed_leg_start_times = [\\n            np.array([0., 0.5], dtype=dtype),\\n            np.array([0., 0.5, 1., 1.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5], dtype=dtype)\\n        ]\\n\\n  fixed_leg_end_times = [\\n            np.array([0.5, 1.0], dtype=dtype),\\n            np.array([0.5, 1., 1.5, 2.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\\n        ]\\n\\n  # Next setup a trivial daycount for floating and fixed legs.\\n\\n  float_leg_daycount = [\\n            np.array([0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype)\\n        ]\\n\\n  fixed_leg_daycount = [\\n            np.array([0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype)\\n        ]\\n\\n  fixed_leg_cashflows = [\\n        # 1 year swap with 2.855% semi-annual fixed payments.\\n        np.array([-0.02855, -0.02855], dtype=dtype),\\n        # 2 year swap with 3.097% semi-annual fixed payments.\\n        np.array([-0.03097, -0.03097, -0.03097, -0.03097], dtype=dtype),\\n        # 3 year swap with 3.1% semi-annual fixed payments.\\n        np.array([-0.031, -0.031, -0.031, -0.031, -0.031, -0.031], dtype=dtype),\\n        # 4 year swap with 3.2% semi-annual fixed payments.\\n        np.array([-0.032, -0.032, -0.032, -0.032, -0.032, -0.032, -0.032,\\n        -0.032], dtype=dtype)\\n    ]\\n\\n  # The present values of the above IRS.\\n    pvs = np.array([0., 0., 0., 0.], dtype=dtype)\\n\\n  # Initial state of the curve.\\n  initial_curve_rates = np.array([0.01, 0.01, 0.01, 0.01], dtype=dtype)\\n\\n  results = swap_curve_bootstrap(float_leg_start_times, float_leg_end_times,\\n                                 float_leg_daycount, fixed_leg_start_times,\\n                                 fixed_leg_end_times, fixed_leg_cashflows,\\n                                 fixed_leg_daycount, pvs, dtype=dtype,\\n                                 initial_curve_rates=initial_curve_rates)\\n\\n  #### References:\\n\\n  [1]: Patrick Hagan & Graeme West. Interpolation Methods for Curve\\n    Construction. Applied Mathematical Finance. Vol 13, No. 2, pp 89-129.\\n    June 2006.\\n    https://www.researchgate.net/publication/24071726_Interpolation_Methods_for_Curve_Construction\\n\\n  Args:\\n    float_leg_start_times: List of `Tensor`s. Each `Tensor` must be of rank 1\\n      and of the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the beginning of the accrual period for the forward rate which\\n      determines the floating payment. Each element in the list belong to a\\n      unique swap to be used to build the curve.\\n    float_leg_end_times: List of `Tensor`s. Each `Tensor` must be of rank 1 and\\n      and the same shape and of the same real dtype as the corresponding element\\n      in `float_leg_start_times`. Each `Tensor` represents the end of the\\n      accrual period for the forward rate which determines the floating payment.\\n    fixed_leg_start_times: List of `Tensor`s. Each `Tensor` must be of rank 1\\n      and of the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the beginning of the accrual period fixed coupon.\\n    fixed_leg_end_times: List of `Tensor`s. Each `Tensor` must be of the same\\n      shape and type as `fixed_leg_start_times`. Each `Tensor` represents the\\n      end of the accrual period for the fixed coupon.\\n    fixed_leg_cashflows: List of `Tensor`s. The list must be of the same length\\n      as the `fixed_leg_start_times`. Each `Tensor` must be of rank 1 and of the\\n      same dtype as the `Tensor`s in `fixed_leg_start_times`. The input contains\\n      fixed cashflows at each coupon payment time including notional (if any).\\n      The sign should be negative (positive) to indicate net outgoing (incoming)\\n      cashflow.\\n    present_values: List containing scalar `Tensor`s of the same dtype as\\n      elements of `fixed_leg_cashflows`. The length of the list must be the same\\n      as the length of `fixed_leg_cashflows`. The input contains the market\\n      price of the underlying instruments.\\n    present_values_settlement_times: List containing scalar `Tensor`s of the\\n      same dtype as elements of `present_values`. The length of the list must be\\n      the same as the length of `present_values`. The settlement times for the\\n      present values is the time from now when the instrument is traded to the\\n      time that the purchase price is actually delivered. If not supplied, then\\n      it is assumed that the settlement times are zero for every bond.\\n      Default value: `None`, which is equivalent to zero settlement times.\\n    float_leg_daycount_fractions: Optional list of `Tensor`s. Each `Tensor` must\\n      be of the same shape and type as `float_leg_start_times`. They may be of\\n      different sizes. Each `Tensor` represents the daycount fraction of the\\n      forward rate which determines the floating payment.\\n      Default value: `None`, If omitted the daycount fractions are computed as\\n      the difference between float_leg_end_times and float_leg_start_times.\\n    fixed_leg_daycount_fractions: Optional list of `Tensor`s. Each `Tensor` must\\n      be of the same shape and type as `fixed_leg_start_times`. Each `Tensor`\\n      represents the daycount fraction applicable for the fixed payment.\\n      Default value: `None`, If omitted the daycount fractions are computed as\\n      the difference between fixed_leg_end_times and fixed_leg_start_times.\\n    float_leg_discount_rates: Optional `Tensor` of the same dtype as\\n      `initial_discount_rates`. This input contains the continuously compounded\\n      discount rates the will be used to discount the floating cashflows. This\\n      allows the swap curve to constructed using an independent discount curve\\n      (e.g. OIS curve).\\n      Default value: `None`, in which case the cashflows are discounted using\\n      the curve that is being constructed.\\n    float_leg_discount_times: Optional `Tensor` of the same dtype and shape as\\n      `float_leg_discount_rates`. This input contains the times corresponding to\\n      the rates specified via the `float_leg_discount_rates`.\\n    fixed_leg_discount_rates: Optional `Tensor` of the same dtype as\\n      `initial_discount_rates`. This input contains the continuously compounded\\n      discount rates the will be used to discount the fixed cashflows. This\\n      allows the swap curve to constructed using an independent discount curve\\n      (e.g. OIS curve).\\n      Default value: `None`, in which case the cashflows are discounted using\\n      the curve that is being constructed.\\n    fixed_leg_discount_times: Optional `Tensor` of the same dtype and shape as\\n      `fixed_leg_discount_rates`. This input contains the times corresponding to\\n      the rates specified via the `fixed_leg_discount_rates`.\\n    curve_interpolator: Optional Python callable used to interpolate the zero\\n      swap rates at cashflow times. It should have the following interface:\\n      yi = curve_interpolator(xi, x, y)\\n      `x`, `y`, 'xi', 'yi' are all `Tensors` of real dtype. `x` and `y` are the\\n      sample points and values (respectively) of the function to be\\n      interpolated. `xi` are the points at which the interpolation is\\n      desired and `yi` are the corresponding interpolated values returned by the\\n      function.\\n      Default value: `None`, which maps to linear interpolation.\\n    initial_curve_rates: Optional `Tensor` of the same dtype and shape as\\n      `present_values`. The starting guess for the discount rates used to\\n      initialize the iterative procedure.\\n      Default value: `None`. If not supplied, the yields to maturity for the\\n        bonds is used as the initial value.\\n    curve_tolerance: Optional positive scalar `Tensor` of same dtype as\\n      elements of `bond_cashflows`. The absolute tolerance for terminating the\\n      iterations used to fit the rate curve. The iterations are stopped when the\\n      estimated discounts at the expiry times of the bond_cashflows change by a\\n      amount smaller than `discount_tolerance` in an iteration.\\n      Default value: 1e-8.\\n    maximum_iterations: Optional positive integer `Tensor`. The maximum number\\n      of iterations permitted when fitting the curve.\\n      Default value: 50.\\n    dtype: `tf.Dtype`. If supplied the dtype for the (elements of)\\n      `float_leg_start_times`, and `fixed_leg_start_times`.\\n      Default value: None which maps to the default dtype inferred by\\n      TensorFlow.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: `None` which maps to 'swap_curve'.\\n\\n  Returns:\\n    curve_builder_result: An instance of `SwapCurveBuilderResult` containing the\\n      following attributes.\\n      times: Rank 1 real `Tensor`. Times for the computed rates. These\\n        are chosen to be the expiry times of the supplied instruments.\\n      rates: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred zero rates.\\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount factors.\\n      initial_rates: Rank 1 `Tensor` of the same dtype as `times`. The\\n        initial guess for the rates.\\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\\n        The procedure is said to have converged when the maximum absolute\\n        difference in the discount factors from one iteration to the next falls\\n        below the `discount_tolerance`.\\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\\n        may fail either because a NaN value was encountered for the discount\\n        rates or the discount factors.\\n      iterations: Scalar int32 `Tensor`. Number of iterations performed.\\n\\n  Raises:\\n    ValueError: If the initial state of the curve is not\\n    supplied to the function.\\n\\n  \"\n    name = name or 'swap_curve_bootstrap'\n    with tf.name_scope(name):\n        if curve_interpolator is None:\n\n            def default_interpolator(xi, x, y):\n                return linear.interpolate(xi, x, y, dtype=dtype)\n            curve_interpolator = default_interpolator\n        if present_values_settlement_times is None:\n            pv_settle_times = [tf.zeros_like(pv) for pv in present_values]\n        else:\n            pv_settle_times = present_values_settlement_times\n        if float_leg_daycount_fractions is None:\n            float_leg_daycount_fractions = [y - x for (x, y) in zip(float_leg_start_times, float_leg_end_times)]\n        if fixed_leg_daycount_fractions is None:\n            fixed_leg_daycount_fractions = [y - x for (x, y) in zip(fixed_leg_start_times, fixed_leg_end_times)]\n        float_leg_start_times = _convert_to_tensors(dtype, float_leg_start_times, 'float_leg_start_times')\n        float_leg_end_times = _convert_to_tensors(dtype, float_leg_end_times, 'float_leg_end_times')\n        float_leg_daycount_fractions = _convert_to_tensors(dtype, float_leg_daycount_fractions, 'float_leg_daycount_fractions')\n        fixed_leg_start_times = _convert_to_tensors(dtype, fixed_leg_start_times, 'fixed_leg_start_times')\n        fixed_leg_end_times = _convert_to_tensors(dtype, fixed_leg_end_times, 'fixed_leg_end_times')\n        fixed_leg_daycount_fractions = _convert_to_tensors(dtype, fixed_leg_daycount_fractions, 'fixed_leg_daycount_fractions')\n        fixed_leg_cashflows = _convert_to_tensors(dtype, fixed_leg_cashflows, 'fixed_leg_cashflows')\n        present_values = _convert_to_tensors(dtype, present_values, 'present_values')\n        pv_settle_times = _convert_to_tensors(dtype, pv_settle_times, 'pv_settle_times')\n        self_discounting_float_leg = False\n        self_discounting_fixed_leg = False\n        if float_leg_discount_rates is None and fixed_leg_discount_rates is None:\n            self_discounting_float_leg = True\n            self_discounting_fixed_leg = True\n            float_leg_discount_rates = [0.0]\n            float_leg_discount_times = [0.0]\n            fixed_leg_discount_rates = [0.0]\n            fixed_leg_discount_times = [0.0]\n        elif fixed_leg_discount_rates is None:\n            fixed_leg_discount_rates = float_leg_discount_rates\n            fixed_leg_discount_times = float_leg_discount_times\n        elif float_leg_discount_rates is None:\n            self_discounting_float_leg = True\n            float_leg_discount_rates = [0.0]\n            float_leg_discount_times = [0.0]\n        float_leg_discount_rates = _convert_to_tensors(dtype, float_leg_discount_rates, 'float_disc_rates')\n        float_leg_discount_times = _convert_to_tensors(dtype, float_leg_discount_times, 'float_disc_times')\n        fixed_leg_discount_rates = _convert_to_tensors(dtype, fixed_leg_discount_rates, 'fixed_disc_rates')\n        fixed_leg_discount_times = _convert_to_tensors(dtype, fixed_leg_discount_times, 'fixed_disc_times')\n        if initial_curve_rates is not None:\n            initial_rates = tf.convert_to_tensor(initial_curve_rates, dtype=dtype, name='initial_rates')\n        else:\n            raise ValueError('Initial state of the curve is not specified.')\n        return _build_swap_curve(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions, float_leg_discount_rates, float_leg_discount_times, fixed_leg_discount_rates, fixed_leg_discount_times, self_discounting_float_leg, self_discounting_fixed_leg, present_values, pv_settle_times, curve_interpolator, initial_rates, curve_tolerance, maximum_iterations, dtype)",
            "def swap_curve_bootstrap(float_leg_start_times: List[types.RealTensor], float_leg_end_times: List[types.RealTensor], fixed_leg_start_times: List[types.RealTensor], fixed_leg_end_times: List[types.RealTensor], fixed_leg_cashflows: List[types.RealTensor], present_values: List[types.RealTensor], present_values_settlement_times: List[types.RealTensor]=None, float_leg_daycount_fractions: List[types.RealTensor]=None, fixed_leg_daycount_fractions: List[types.RealTensor]=None, float_leg_discount_rates: List[types.RealTensor]=None, float_leg_discount_times: List[types.RealTensor]=None, fixed_leg_discount_rates: List[types.RealTensor]=None, fixed_leg_discount_times: List[types.RealTensor]=None, curve_interpolator: Callable[..., types.RealTensor]=None, initial_curve_rates: types.RealTensor=None, curve_tolerance: types.RealTensor=1e-08, maximum_iterations: types.IntTensor=50, dtype: tf.DType=None, name: str=None) -> scc.SwapCurveBuilderResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Constructs the zero swap curve using bootstrap method.\\n\\n  A zero swap curve is a function of time which gives the interest rate that\\n  can be used to project forward rates at arbitrary `t` for the valuation of\\n  interest rate securities (e.g. FRAs, Interest rate futures, Swaps etc.).\\n\\n  Suppose we have a set of `N` Interest Rate Swaps (IRS) `S_i` with increasing\\n  expiries whose market prices are known.\\n  Suppose also that the `i`th IRS issues cashflows at times `T_{ij}` where\\n  `1 <= j <= n_i` and `n_i` is the number of cashflows (including expiry)\\n  for the `i`th swap.\\n  Denote by `T_i` the time of final payment for the `i`th swap\\n  (hence `T_i = T_{i,n_i}`). This function estimates a set of rates `r(T_i)`\\n  such that when these rates are interpolated (using the user specified\\n  interpolation method) to all other cashflow times, the computed value of the\\n  swaps matches the market value of the swaps (within some tolerance).\\n\\n  The algorithm implemented here uses the bootstrap method to iteratively\\n  construct the swap curve [1].\\n\\n  #### Example:\\n\\n  The following example illustrates the usage by building an implied swap curve\\n  from four vanilla (fixed to float) LIBOR swaps.\\n\\n  ```python\\n\\n  dtype = np.float64\\n\\n  # Next we will set up LIBOR reset and payment times for four spot starting\\n  # swaps with maturities 1Y, 2Y, 3Y, 4Y. The LIBOR rate spans 6M.\\n\\n  float_leg_start_times = [\\n            np.array([0., 0.5], dtype=dtype),\\n            np.array([0., 0.5, 1., 1.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5], dtype=dtype)\\n        ]\\n\\n  float_leg_end_times = [\\n            np.array([0.5, 1.0], dtype=dtype),\\n            np.array([0.5, 1., 1.5, 2.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\\n        ]\\n\\n  # Next we will set up start and end times for semi-annual fixed coupons.\\n\\n  fixed_leg_start_times = [\\n            np.array([0., 0.5], dtype=dtype),\\n            np.array([0., 0.5, 1., 1.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5], dtype=dtype)\\n        ]\\n\\n  fixed_leg_end_times = [\\n            np.array([0.5, 1.0], dtype=dtype),\\n            np.array([0.5, 1., 1.5, 2.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\\n        ]\\n\\n  # Next setup a trivial daycount for floating and fixed legs.\\n\\n  float_leg_daycount = [\\n            np.array([0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype)\\n        ]\\n\\n  fixed_leg_daycount = [\\n            np.array([0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype)\\n        ]\\n\\n  fixed_leg_cashflows = [\\n        # 1 year swap with 2.855% semi-annual fixed payments.\\n        np.array([-0.02855, -0.02855], dtype=dtype),\\n        # 2 year swap with 3.097% semi-annual fixed payments.\\n        np.array([-0.03097, -0.03097, -0.03097, -0.03097], dtype=dtype),\\n        # 3 year swap with 3.1% semi-annual fixed payments.\\n        np.array([-0.031, -0.031, -0.031, -0.031, -0.031, -0.031], dtype=dtype),\\n        # 4 year swap with 3.2% semi-annual fixed payments.\\n        np.array([-0.032, -0.032, -0.032, -0.032, -0.032, -0.032, -0.032,\\n        -0.032], dtype=dtype)\\n    ]\\n\\n  # The present values of the above IRS.\\n    pvs = np.array([0., 0., 0., 0.], dtype=dtype)\\n\\n  # Initial state of the curve.\\n  initial_curve_rates = np.array([0.01, 0.01, 0.01, 0.01], dtype=dtype)\\n\\n  results = swap_curve_bootstrap(float_leg_start_times, float_leg_end_times,\\n                                 float_leg_daycount, fixed_leg_start_times,\\n                                 fixed_leg_end_times, fixed_leg_cashflows,\\n                                 fixed_leg_daycount, pvs, dtype=dtype,\\n                                 initial_curve_rates=initial_curve_rates)\\n\\n  #### References:\\n\\n  [1]: Patrick Hagan & Graeme West. Interpolation Methods for Curve\\n    Construction. Applied Mathematical Finance. Vol 13, No. 2, pp 89-129.\\n    June 2006.\\n    https://www.researchgate.net/publication/24071726_Interpolation_Methods_for_Curve_Construction\\n\\n  Args:\\n    float_leg_start_times: List of `Tensor`s. Each `Tensor` must be of rank 1\\n      and of the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the beginning of the accrual period for the forward rate which\\n      determines the floating payment. Each element in the list belong to a\\n      unique swap to be used to build the curve.\\n    float_leg_end_times: List of `Tensor`s. Each `Tensor` must be of rank 1 and\\n      and the same shape and of the same real dtype as the corresponding element\\n      in `float_leg_start_times`. Each `Tensor` represents the end of the\\n      accrual period for the forward rate which determines the floating payment.\\n    fixed_leg_start_times: List of `Tensor`s. Each `Tensor` must be of rank 1\\n      and of the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the beginning of the accrual period fixed coupon.\\n    fixed_leg_end_times: List of `Tensor`s. Each `Tensor` must be of the same\\n      shape and type as `fixed_leg_start_times`. Each `Tensor` represents the\\n      end of the accrual period for the fixed coupon.\\n    fixed_leg_cashflows: List of `Tensor`s. The list must be of the same length\\n      as the `fixed_leg_start_times`. Each `Tensor` must be of rank 1 and of the\\n      same dtype as the `Tensor`s in `fixed_leg_start_times`. The input contains\\n      fixed cashflows at each coupon payment time including notional (if any).\\n      The sign should be negative (positive) to indicate net outgoing (incoming)\\n      cashflow.\\n    present_values: List containing scalar `Tensor`s of the same dtype as\\n      elements of `fixed_leg_cashflows`. The length of the list must be the same\\n      as the length of `fixed_leg_cashflows`. The input contains the market\\n      price of the underlying instruments.\\n    present_values_settlement_times: List containing scalar `Tensor`s of the\\n      same dtype as elements of `present_values`. The length of the list must be\\n      the same as the length of `present_values`. The settlement times for the\\n      present values is the time from now when the instrument is traded to the\\n      time that the purchase price is actually delivered. If not supplied, then\\n      it is assumed that the settlement times are zero for every bond.\\n      Default value: `None`, which is equivalent to zero settlement times.\\n    float_leg_daycount_fractions: Optional list of `Tensor`s. Each `Tensor` must\\n      be of the same shape and type as `float_leg_start_times`. They may be of\\n      different sizes. Each `Tensor` represents the daycount fraction of the\\n      forward rate which determines the floating payment.\\n      Default value: `None`, If omitted the daycount fractions are computed as\\n      the difference between float_leg_end_times and float_leg_start_times.\\n    fixed_leg_daycount_fractions: Optional list of `Tensor`s. Each `Tensor` must\\n      be of the same shape and type as `fixed_leg_start_times`. Each `Tensor`\\n      represents the daycount fraction applicable for the fixed payment.\\n      Default value: `None`, If omitted the daycount fractions are computed as\\n      the difference between fixed_leg_end_times and fixed_leg_start_times.\\n    float_leg_discount_rates: Optional `Tensor` of the same dtype as\\n      `initial_discount_rates`. This input contains the continuously compounded\\n      discount rates the will be used to discount the floating cashflows. This\\n      allows the swap curve to constructed using an independent discount curve\\n      (e.g. OIS curve).\\n      Default value: `None`, in which case the cashflows are discounted using\\n      the curve that is being constructed.\\n    float_leg_discount_times: Optional `Tensor` of the same dtype and shape as\\n      `float_leg_discount_rates`. This input contains the times corresponding to\\n      the rates specified via the `float_leg_discount_rates`.\\n    fixed_leg_discount_rates: Optional `Tensor` of the same dtype as\\n      `initial_discount_rates`. This input contains the continuously compounded\\n      discount rates the will be used to discount the fixed cashflows. This\\n      allows the swap curve to constructed using an independent discount curve\\n      (e.g. OIS curve).\\n      Default value: `None`, in which case the cashflows are discounted using\\n      the curve that is being constructed.\\n    fixed_leg_discount_times: Optional `Tensor` of the same dtype and shape as\\n      `fixed_leg_discount_rates`. This input contains the times corresponding to\\n      the rates specified via the `fixed_leg_discount_rates`.\\n    curve_interpolator: Optional Python callable used to interpolate the zero\\n      swap rates at cashflow times. It should have the following interface:\\n      yi = curve_interpolator(xi, x, y)\\n      `x`, `y`, 'xi', 'yi' are all `Tensors` of real dtype. `x` and `y` are the\\n      sample points and values (respectively) of the function to be\\n      interpolated. `xi` are the points at which the interpolation is\\n      desired and `yi` are the corresponding interpolated values returned by the\\n      function.\\n      Default value: `None`, which maps to linear interpolation.\\n    initial_curve_rates: Optional `Tensor` of the same dtype and shape as\\n      `present_values`. The starting guess for the discount rates used to\\n      initialize the iterative procedure.\\n      Default value: `None`. If not supplied, the yields to maturity for the\\n        bonds is used as the initial value.\\n    curve_tolerance: Optional positive scalar `Tensor` of same dtype as\\n      elements of `bond_cashflows`. The absolute tolerance for terminating the\\n      iterations used to fit the rate curve. The iterations are stopped when the\\n      estimated discounts at the expiry times of the bond_cashflows change by a\\n      amount smaller than `discount_tolerance` in an iteration.\\n      Default value: 1e-8.\\n    maximum_iterations: Optional positive integer `Tensor`. The maximum number\\n      of iterations permitted when fitting the curve.\\n      Default value: 50.\\n    dtype: `tf.Dtype`. If supplied the dtype for the (elements of)\\n      `float_leg_start_times`, and `fixed_leg_start_times`.\\n      Default value: None which maps to the default dtype inferred by\\n      TensorFlow.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: `None` which maps to 'swap_curve'.\\n\\n  Returns:\\n    curve_builder_result: An instance of `SwapCurveBuilderResult` containing the\\n      following attributes.\\n      times: Rank 1 real `Tensor`. Times for the computed rates. These\\n        are chosen to be the expiry times of the supplied instruments.\\n      rates: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred zero rates.\\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount factors.\\n      initial_rates: Rank 1 `Tensor` of the same dtype as `times`. The\\n        initial guess for the rates.\\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\\n        The procedure is said to have converged when the maximum absolute\\n        difference in the discount factors from one iteration to the next falls\\n        below the `discount_tolerance`.\\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\\n        may fail either because a NaN value was encountered for the discount\\n        rates or the discount factors.\\n      iterations: Scalar int32 `Tensor`. Number of iterations performed.\\n\\n  Raises:\\n    ValueError: If the initial state of the curve is not\\n    supplied to the function.\\n\\n  \"\n    name = name or 'swap_curve_bootstrap'\n    with tf.name_scope(name):\n        if curve_interpolator is None:\n\n            def default_interpolator(xi, x, y):\n                return linear.interpolate(xi, x, y, dtype=dtype)\n            curve_interpolator = default_interpolator\n        if present_values_settlement_times is None:\n            pv_settle_times = [tf.zeros_like(pv) for pv in present_values]\n        else:\n            pv_settle_times = present_values_settlement_times\n        if float_leg_daycount_fractions is None:\n            float_leg_daycount_fractions = [y - x for (x, y) in zip(float_leg_start_times, float_leg_end_times)]\n        if fixed_leg_daycount_fractions is None:\n            fixed_leg_daycount_fractions = [y - x for (x, y) in zip(fixed_leg_start_times, fixed_leg_end_times)]\n        float_leg_start_times = _convert_to_tensors(dtype, float_leg_start_times, 'float_leg_start_times')\n        float_leg_end_times = _convert_to_tensors(dtype, float_leg_end_times, 'float_leg_end_times')\n        float_leg_daycount_fractions = _convert_to_tensors(dtype, float_leg_daycount_fractions, 'float_leg_daycount_fractions')\n        fixed_leg_start_times = _convert_to_tensors(dtype, fixed_leg_start_times, 'fixed_leg_start_times')\n        fixed_leg_end_times = _convert_to_tensors(dtype, fixed_leg_end_times, 'fixed_leg_end_times')\n        fixed_leg_daycount_fractions = _convert_to_tensors(dtype, fixed_leg_daycount_fractions, 'fixed_leg_daycount_fractions')\n        fixed_leg_cashflows = _convert_to_tensors(dtype, fixed_leg_cashflows, 'fixed_leg_cashflows')\n        present_values = _convert_to_tensors(dtype, present_values, 'present_values')\n        pv_settle_times = _convert_to_tensors(dtype, pv_settle_times, 'pv_settle_times')\n        self_discounting_float_leg = False\n        self_discounting_fixed_leg = False\n        if float_leg_discount_rates is None and fixed_leg_discount_rates is None:\n            self_discounting_float_leg = True\n            self_discounting_fixed_leg = True\n            float_leg_discount_rates = [0.0]\n            float_leg_discount_times = [0.0]\n            fixed_leg_discount_rates = [0.0]\n            fixed_leg_discount_times = [0.0]\n        elif fixed_leg_discount_rates is None:\n            fixed_leg_discount_rates = float_leg_discount_rates\n            fixed_leg_discount_times = float_leg_discount_times\n        elif float_leg_discount_rates is None:\n            self_discounting_float_leg = True\n            float_leg_discount_rates = [0.0]\n            float_leg_discount_times = [0.0]\n        float_leg_discount_rates = _convert_to_tensors(dtype, float_leg_discount_rates, 'float_disc_rates')\n        float_leg_discount_times = _convert_to_tensors(dtype, float_leg_discount_times, 'float_disc_times')\n        fixed_leg_discount_rates = _convert_to_tensors(dtype, fixed_leg_discount_rates, 'fixed_disc_rates')\n        fixed_leg_discount_times = _convert_to_tensors(dtype, fixed_leg_discount_times, 'fixed_disc_times')\n        if initial_curve_rates is not None:\n            initial_rates = tf.convert_to_tensor(initial_curve_rates, dtype=dtype, name='initial_rates')\n        else:\n            raise ValueError('Initial state of the curve is not specified.')\n        return _build_swap_curve(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions, float_leg_discount_rates, float_leg_discount_times, fixed_leg_discount_rates, fixed_leg_discount_times, self_discounting_float_leg, self_discounting_fixed_leg, present_values, pv_settle_times, curve_interpolator, initial_rates, curve_tolerance, maximum_iterations, dtype)",
            "def swap_curve_bootstrap(float_leg_start_times: List[types.RealTensor], float_leg_end_times: List[types.RealTensor], fixed_leg_start_times: List[types.RealTensor], fixed_leg_end_times: List[types.RealTensor], fixed_leg_cashflows: List[types.RealTensor], present_values: List[types.RealTensor], present_values_settlement_times: List[types.RealTensor]=None, float_leg_daycount_fractions: List[types.RealTensor]=None, fixed_leg_daycount_fractions: List[types.RealTensor]=None, float_leg_discount_rates: List[types.RealTensor]=None, float_leg_discount_times: List[types.RealTensor]=None, fixed_leg_discount_rates: List[types.RealTensor]=None, fixed_leg_discount_times: List[types.RealTensor]=None, curve_interpolator: Callable[..., types.RealTensor]=None, initial_curve_rates: types.RealTensor=None, curve_tolerance: types.RealTensor=1e-08, maximum_iterations: types.IntTensor=50, dtype: tf.DType=None, name: str=None) -> scc.SwapCurveBuilderResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Constructs the zero swap curve using bootstrap method.\\n\\n  A zero swap curve is a function of time which gives the interest rate that\\n  can be used to project forward rates at arbitrary `t` for the valuation of\\n  interest rate securities (e.g. FRAs, Interest rate futures, Swaps etc.).\\n\\n  Suppose we have a set of `N` Interest Rate Swaps (IRS) `S_i` with increasing\\n  expiries whose market prices are known.\\n  Suppose also that the `i`th IRS issues cashflows at times `T_{ij}` where\\n  `1 <= j <= n_i` and `n_i` is the number of cashflows (including expiry)\\n  for the `i`th swap.\\n  Denote by `T_i` the time of final payment for the `i`th swap\\n  (hence `T_i = T_{i,n_i}`). This function estimates a set of rates `r(T_i)`\\n  such that when these rates are interpolated (using the user specified\\n  interpolation method) to all other cashflow times, the computed value of the\\n  swaps matches the market value of the swaps (within some tolerance).\\n\\n  The algorithm implemented here uses the bootstrap method to iteratively\\n  construct the swap curve [1].\\n\\n  #### Example:\\n\\n  The following example illustrates the usage by building an implied swap curve\\n  from four vanilla (fixed to float) LIBOR swaps.\\n\\n  ```python\\n\\n  dtype = np.float64\\n\\n  # Next we will set up LIBOR reset and payment times for four spot starting\\n  # swaps with maturities 1Y, 2Y, 3Y, 4Y. The LIBOR rate spans 6M.\\n\\n  float_leg_start_times = [\\n            np.array([0., 0.5], dtype=dtype),\\n            np.array([0., 0.5, 1., 1.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5], dtype=dtype)\\n        ]\\n\\n  float_leg_end_times = [\\n            np.array([0.5, 1.0], dtype=dtype),\\n            np.array([0.5, 1., 1.5, 2.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\\n        ]\\n\\n  # Next we will set up start and end times for semi-annual fixed coupons.\\n\\n  fixed_leg_start_times = [\\n            np.array([0., 0.5], dtype=dtype),\\n            np.array([0., 0.5, 1., 1.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5], dtype=dtype),\\n            np.array([0., 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5], dtype=dtype)\\n        ]\\n\\n  fixed_leg_end_times = [\\n            np.array([0.5, 1.0], dtype=dtype),\\n            np.array([0.5, 1., 1.5, 2.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\\n            np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\\n        ]\\n\\n  # Next setup a trivial daycount for floating and fixed legs.\\n\\n  float_leg_daycount = [\\n            np.array([0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype)\\n        ]\\n\\n  fixed_leg_daycount = [\\n            np.array([0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype),\\n            np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], dtype=dtype)\\n        ]\\n\\n  fixed_leg_cashflows = [\\n        # 1 year swap with 2.855% semi-annual fixed payments.\\n        np.array([-0.02855, -0.02855], dtype=dtype),\\n        # 2 year swap with 3.097% semi-annual fixed payments.\\n        np.array([-0.03097, -0.03097, -0.03097, -0.03097], dtype=dtype),\\n        # 3 year swap with 3.1% semi-annual fixed payments.\\n        np.array([-0.031, -0.031, -0.031, -0.031, -0.031, -0.031], dtype=dtype),\\n        # 4 year swap with 3.2% semi-annual fixed payments.\\n        np.array([-0.032, -0.032, -0.032, -0.032, -0.032, -0.032, -0.032,\\n        -0.032], dtype=dtype)\\n    ]\\n\\n  # The present values of the above IRS.\\n    pvs = np.array([0., 0., 0., 0.], dtype=dtype)\\n\\n  # Initial state of the curve.\\n  initial_curve_rates = np.array([0.01, 0.01, 0.01, 0.01], dtype=dtype)\\n\\n  results = swap_curve_bootstrap(float_leg_start_times, float_leg_end_times,\\n                                 float_leg_daycount, fixed_leg_start_times,\\n                                 fixed_leg_end_times, fixed_leg_cashflows,\\n                                 fixed_leg_daycount, pvs, dtype=dtype,\\n                                 initial_curve_rates=initial_curve_rates)\\n\\n  #### References:\\n\\n  [1]: Patrick Hagan & Graeme West. Interpolation Methods for Curve\\n    Construction. Applied Mathematical Finance. Vol 13, No. 2, pp 89-129.\\n    June 2006.\\n    https://www.researchgate.net/publication/24071726_Interpolation_Methods_for_Curve_Construction\\n\\n  Args:\\n    float_leg_start_times: List of `Tensor`s. Each `Tensor` must be of rank 1\\n      and of the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the beginning of the accrual period for the forward rate which\\n      determines the floating payment. Each element in the list belong to a\\n      unique swap to be used to build the curve.\\n    float_leg_end_times: List of `Tensor`s. Each `Tensor` must be of rank 1 and\\n      and the same shape and of the same real dtype as the corresponding element\\n      in `float_leg_start_times`. Each `Tensor` represents the end of the\\n      accrual period for the forward rate which determines the floating payment.\\n    fixed_leg_start_times: List of `Tensor`s. Each `Tensor` must be of rank 1\\n      and of the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the beginning of the accrual period fixed coupon.\\n    fixed_leg_end_times: List of `Tensor`s. Each `Tensor` must be of the same\\n      shape and type as `fixed_leg_start_times`. Each `Tensor` represents the\\n      end of the accrual period for the fixed coupon.\\n    fixed_leg_cashflows: List of `Tensor`s. The list must be of the same length\\n      as the `fixed_leg_start_times`. Each `Tensor` must be of rank 1 and of the\\n      same dtype as the `Tensor`s in `fixed_leg_start_times`. The input contains\\n      fixed cashflows at each coupon payment time including notional (if any).\\n      The sign should be negative (positive) to indicate net outgoing (incoming)\\n      cashflow.\\n    present_values: List containing scalar `Tensor`s of the same dtype as\\n      elements of `fixed_leg_cashflows`. The length of the list must be the same\\n      as the length of `fixed_leg_cashflows`. The input contains the market\\n      price of the underlying instruments.\\n    present_values_settlement_times: List containing scalar `Tensor`s of the\\n      same dtype as elements of `present_values`. The length of the list must be\\n      the same as the length of `present_values`. The settlement times for the\\n      present values is the time from now when the instrument is traded to the\\n      time that the purchase price is actually delivered. If not supplied, then\\n      it is assumed that the settlement times are zero for every bond.\\n      Default value: `None`, which is equivalent to zero settlement times.\\n    float_leg_daycount_fractions: Optional list of `Tensor`s. Each `Tensor` must\\n      be of the same shape and type as `float_leg_start_times`. They may be of\\n      different sizes. Each `Tensor` represents the daycount fraction of the\\n      forward rate which determines the floating payment.\\n      Default value: `None`, If omitted the daycount fractions are computed as\\n      the difference between float_leg_end_times and float_leg_start_times.\\n    fixed_leg_daycount_fractions: Optional list of `Tensor`s. Each `Tensor` must\\n      be of the same shape and type as `fixed_leg_start_times`. Each `Tensor`\\n      represents the daycount fraction applicable for the fixed payment.\\n      Default value: `None`, If omitted the daycount fractions are computed as\\n      the difference between fixed_leg_end_times and fixed_leg_start_times.\\n    float_leg_discount_rates: Optional `Tensor` of the same dtype as\\n      `initial_discount_rates`. This input contains the continuously compounded\\n      discount rates the will be used to discount the floating cashflows. This\\n      allows the swap curve to constructed using an independent discount curve\\n      (e.g. OIS curve).\\n      Default value: `None`, in which case the cashflows are discounted using\\n      the curve that is being constructed.\\n    float_leg_discount_times: Optional `Tensor` of the same dtype and shape as\\n      `float_leg_discount_rates`. This input contains the times corresponding to\\n      the rates specified via the `float_leg_discount_rates`.\\n    fixed_leg_discount_rates: Optional `Tensor` of the same dtype as\\n      `initial_discount_rates`. This input contains the continuously compounded\\n      discount rates the will be used to discount the fixed cashflows. This\\n      allows the swap curve to constructed using an independent discount curve\\n      (e.g. OIS curve).\\n      Default value: `None`, in which case the cashflows are discounted using\\n      the curve that is being constructed.\\n    fixed_leg_discount_times: Optional `Tensor` of the same dtype and shape as\\n      `fixed_leg_discount_rates`. This input contains the times corresponding to\\n      the rates specified via the `fixed_leg_discount_rates`.\\n    curve_interpolator: Optional Python callable used to interpolate the zero\\n      swap rates at cashflow times. It should have the following interface:\\n      yi = curve_interpolator(xi, x, y)\\n      `x`, `y`, 'xi', 'yi' are all `Tensors` of real dtype. `x` and `y` are the\\n      sample points and values (respectively) of the function to be\\n      interpolated. `xi` are the points at which the interpolation is\\n      desired and `yi` are the corresponding interpolated values returned by the\\n      function.\\n      Default value: `None`, which maps to linear interpolation.\\n    initial_curve_rates: Optional `Tensor` of the same dtype and shape as\\n      `present_values`. The starting guess for the discount rates used to\\n      initialize the iterative procedure.\\n      Default value: `None`. If not supplied, the yields to maturity for the\\n        bonds is used as the initial value.\\n    curve_tolerance: Optional positive scalar `Tensor` of same dtype as\\n      elements of `bond_cashflows`. The absolute tolerance for terminating the\\n      iterations used to fit the rate curve. The iterations are stopped when the\\n      estimated discounts at the expiry times of the bond_cashflows change by a\\n      amount smaller than `discount_tolerance` in an iteration.\\n      Default value: 1e-8.\\n    maximum_iterations: Optional positive integer `Tensor`. The maximum number\\n      of iterations permitted when fitting the curve.\\n      Default value: 50.\\n    dtype: `tf.Dtype`. If supplied the dtype for the (elements of)\\n      `float_leg_start_times`, and `fixed_leg_start_times`.\\n      Default value: None which maps to the default dtype inferred by\\n      TensorFlow.\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: `None` which maps to 'swap_curve'.\\n\\n  Returns:\\n    curve_builder_result: An instance of `SwapCurveBuilderResult` containing the\\n      following attributes.\\n      times: Rank 1 real `Tensor`. Times for the computed rates. These\\n        are chosen to be the expiry times of the supplied instruments.\\n      rates: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred zero rates.\\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount factors.\\n      initial_rates: Rank 1 `Tensor` of the same dtype as `times`. The\\n        initial guess for the rates.\\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\\n        The procedure is said to have converged when the maximum absolute\\n        difference in the discount factors from one iteration to the next falls\\n        below the `discount_tolerance`.\\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\\n        may fail either because a NaN value was encountered for the discount\\n        rates or the discount factors.\\n      iterations: Scalar int32 `Tensor`. Number of iterations performed.\\n\\n  Raises:\\n    ValueError: If the initial state of the curve is not\\n    supplied to the function.\\n\\n  \"\n    name = name or 'swap_curve_bootstrap'\n    with tf.name_scope(name):\n        if curve_interpolator is None:\n\n            def default_interpolator(xi, x, y):\n                return linear.interpolate(xi, x, y, dtype=dtype)\n            curve_interpolator = default_interpolator\n        if present_values_settlement_times is None:\n            pv_settle_times = [tf.zeros_like(pv) for pv in present_values]\n        else:\n            pv_settle_times = present_values_settlement_times\n        if float_leg_daycount_fractions is None:\n            float_leg_daycount_fractions = [y - x for (x, y) in zip(float_leg_start_times, float_leg_end_times)]\n        if fixed_leg_daycount_fractions is None:\n            fixed_leg_daycount_fractions = [y - x for (x, y) in zip(fixed_leg_start_times, fixed_leg_end_times)]\n        float_leg_start_times = _convert_to_tensors(dtype, float_leg_start_times, 'float_leg_start_times')\n        float_leg_end_times = _convert_to_tensors(dtype, float_leg_end_times, 'float_leg_end_times')\n        float_leg_daycount_fractions = _convert_to_tensors(dtype, float_leg_daycount_fractions, 'float_leg_daycount_fractions')\n        fixed_leg_start_times = _convert_to_tensors(dtype, fixed_leg_start_times, 'fixed_leg_start_times')\n        fixed_leg_end_times = _convert_to_tensors(dtype, fixed_leg_end_times, 'fixed_leg_end_times')\n        fixed_leg_daycount_fractions = _convert_to_tensors(dtype, fixed_leg_daycount_fractions, 'fixed_leg_daycount_fractions')\n        fixed_leg_cashflows = _convert_to_tensors(dtype, fixed_leg_cashflows, 'fixed_leg_cashflows')\n        present_values = _convert_to_tensors(dtype, present_values, 'present_values')\n        pv_settle_times = _convert_to_tensors(dtype, pv_settle_times, 'pv_settle_times')\n        self_discounting_float_leg = False\n        self_discounting_fixed_leg = False\n        if float_leg_discount_rates is None and fixed_leg_discount_rates is None:\n            self_discounting_float_leg = True\n            self_discounting_fixed_leg = True\n            float_leg_discount_rates = [0.0]\n            float_leg_discount_times = [0.0]\n            fixed_leg_discount_rates = [0.0]\n            fixed_leg_discount_times = [0.0]\n        elif fixed_leg_discount_rates is None:\n            fixed_leg_discount_rates = float_leg_discount_rates\n            fixed_leg_discount_times = float_leg_discount_times\n        elif float_leg_discount_rates is None:\n            self_discounting_float_leg = True\n            float_leg_discount_rates = [0.0]\n            float_leg_discount_times = [0.0]\n        float_leg_discount_rates = _convert_to_tensors(dtype, float_leg_discount_rates, 'float_disc_rates')\n        float_leg_discount_times = _convert_to_tensors(dtype, float_leg_discount_times, 'float_disc_times')\n        fixed_leg_discount_rates = _convert_to_tensors(dtype, fixed_leg_discount_rates, 'fixed_disc_rates')\n        fixed_leg_discount_times = _convert_to_tensors(dtype, fixed_leg_discount_times, 'fixed_disc_times')\n        if initial_curve_rates is not None:\n            initial_rates = tf.convert_to_tensor(initial_curve_rates, dtype=dtype, name='initial_rates')\n        else:\n            raise ValueError('Initial state of the curve is not specified.')\n        return _build_swap_curve(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions, float_leg_discount_rates, float_leg_discount_times, fixed_leg_discount_rates, fixed_leg_discount_times, self_discounting_float_leg, self_discounting_fixed_leg, present_values, pv_settle_times, curve_interpolator, initial_rates, curve_tolerance, maximum_iterations, dtype)"
        ]
    },
    {
        "func_name": "_one_step",
        "original": "def _one_step(converged, failed, iteration, discount_factor):\n    \"\"\"One step of the bootstrap iteration.\"\"\"\n    x = -tf.math.log(discount_factor) / expiry_times\n    rates_start = curve_interpolator(float_leg_calc_times_start, expiry_times, x)\n    rates_end = curve_interpolator(float_leg_calc_times_end, expiry_times, x)\n    rates_start_last = curve_interpolator(last_float_leg_start_time, expiry_times, x)\n    float_cashflows = tf.math.exp(float_leg_calc_times_end * rates_end) / tf.math.exp(float_leg_calc_times_start * rates_start) - 1.0\n    if self_discounting_float_leg:\n        float_discount_rates = rates_end\n    else:\n        float_discount_rates = curve_interpolator(float_leg_calc_times_end, float_leg_discount_times, float_leg_discount_rates)\n        last_float_discount_rate = curve_interpolator(last_float_leg_end_time, float_leg_discount_times, float_leg_discount_rates)\n        last_float_discount_factor = tf.math.exp(-last_float_discount_rate * last_float_leg_end_time)\n    if self_discounting_fixed_leg:\n        fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, expiry_times, x)\n    else:\n        fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, fixed_leg_discount_times, fixed_leg_discount_rates)\n        last_fixed_discount_rate = curve_interpolator(last_fixed_leg_end_time, fixed_leg_discount_times, fixed_leg_discount_rates)\n        last_fixed_discount_factor = tf.math.exp(-last_fixed_leg_end_time * last_fixed_discount_rate)\n        last_fixed_leg_cashflow_pv = last_fixed_leg_daycount * last_fixed_leg_cashflows * last_fixed_discount_factor\n    calc_discounts_float_leg = tf.math.exp(-float_discount_rates * float_leg_calc_times_end)\n    calc_discounts_fixed_leg = tf.math.exp(-fixed_discount_rates * fixed_leg_calc_times)\n    float_pv = tf.math.segment_sum(float_cashflows * calc_discounts_float_leg, calc_groups_float)\n    fixed_pv = tf.math.segment_sum(calc_fixed_leg_daycount * calc_fixed_leg_cashflows * calc_discounts_fixed_leg, calc_groups_fixed)\n    if self_discounting_float_leg and self_discounting_fixed_leg:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        scale = last_fixed_leg_cashflows * last_fixed_leg_daycount - 1.0\n        next_discount = (present_values - float_pv - fixed_pv - p_n_minus_1) / scale\n    elif self_discounting_float_leg:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        next_discount = float_pv + (fixed_pv + last_fixed_leg_cashflow_pv) - present_values + p_n_minus_1\n    else:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        scale = present_values - float_pv - (fixed_pv + last_fixed_leg_cashflow_pv) + last_float_discount_factor\n        next_discount = p_n_minus_1 * last_float_discount_factor / scale\n    discount_diff = tf.math.abs(next_discount - discount_factor)\n    converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < curve_tolerance)\n    return (converged, failed, iteration + 1, next_discount)",
        "mutated": [
            "def _one_step(converged, failed, iteration, discount_factor):\n    if False:\n        i = 10\n    'One step of the bootstrap iteration.'\n    x = -tf.math.log(discount_factor) / expiry_times\n    rates_start = curve_interpolator(float_leg_calc_times_start, expiry_times, x)\n    rates_end = curve_interpolator(float_leg_calc_times_end, expiry_times, x)\n    rates_start_last = curve_interpolator(last_float_leg_start_time, expiry_times, x)\n    float_cashflows = tf.math.exp(float_leg_calc_times_end * rates_end) / tf.math.exp(float_leg_calc_times_start * rates_start) - 1.0\n    if self_discounting_float_leg:\n        float_discount_rates = rates_end\n    else:\n        float_discount_rates = curve_interpolator(float_leg_calc_times_end, float_leg_discount_times, float_leg_discount_rates)\n        last_float_discount_rate = curve_interpolator(last_float_leg_end_time, float_leg_discount_times, float_leg_discount_rates)\n        last_float_discount_factor = tf.math.exp(-last_float_discount_rate * last_float_leg_end_time)\n    if self_discounting_fixed_leg:\n        fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, expiry_times, x)\n    else:\n        fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, fixed_leg_discount_times, fixed_leg_discount_rates)\n        last_fixed_discount_rate = curve_interpolator(last_fixed_leg_end_time, fixed_leg_discount_times, fixed_leg_discount_rates)\n        last_fixed_discount_factor = tf.math.exp(-last_fixed_leg_end_time * last_fixed_discount_rate)\n        last_fixed_leg_cashflow_pv = last_fixed_leg_daycount * last_fixed_leg_cashflows * last_fixed_discount_factor\n    calc_discounts_float_leg = tf.math.exp(-float_discount_rates * float_leg_calc_times_end)\n    calc_discounts_fixed_leg = tf.math.exp(-fixed_discount_rates * fixed_leg_calc_times)\n    float_pv = tf.math.segment_sum(float_cashflows * calc_discounts_float_leg, calc_groups_float)\n    fixed_pv = tf.math.segment_sum(calc_fixed_leg_daycount * calc_fixed_leg_cashflows * calc_discounts_fixed_leg, calc_groups_fixed)\n    if self_discounting_float_leg and self_discounting_fixed_leg:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        scale = last_fixed_leg_cashflows * last_fixed_leg_daycount - 1.0\n        next_discount = (present_values - float_pv - fixed_pv - p_n_minus_1) / scale\n    elif self_discounting_float_leg:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        next_discount = float_pv + (fixed_pv + last_fixed_leg_cashflow_pv) - present_values + p_n_minus_1\n    else:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        scale = present_values - float_pv - (fixed_pv + last_fixed_leg_cashflow_pv) + last_float_discount_factor\n        next_discount = p_n_minus_1 * last_float_discount_factor / scale\n    discount_diff = tf.math.abs(next_discount - discount_factor)\n    converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < curve_tolerance)\n    return (converged, failed, iteration + 1, next_discount)",
            "def _one_step(converged, failed, iteration, discount_factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'One step of the bootstrap iteration.'\n    x = -tf.math.log(discount_factor) / expiry_times\n    rates_start = curve_interpolator(float_leg_calc_times_start, expiry_times, x)\n    rates_end = curve_interpolator(float_leg_calc_times_end, expiry_times, x)\n    rates_start_last = curve_interpolator(last_float_leg_start_time, expiry_times, x)\n    float_cashflows = tf.math.exp(float_leg_calc_times_end * rates_end) / tf.math.exp(float_leg_calc_times_start * rates_start) - 1.0\n    if self_discounting_float_leg:\n        float_discount_rates = rates_end\n    else:\n        float_discount_rates = curve_interpolator(float_leg_calc_times_end, float_leg_discount_times, float_leg_discount_rates)\n        last_float_discount_rate = curve_interpolator(last_float_leg_end_time, float_leg_discount_times, float_leg_discount_rates)\n        last_float_discount_factor = tf.math.exp(-last_float_discount_rate * last_float_leg_end_time)\n    if self_discounting_fixed_leg:\n        fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, expiry_times, x)\n    else:\n        fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, fixed_leg_discount_times, fixed_leg_discount_rates)\n        last_fixed_discount_rate = curve_interpolator(last_fixed_leg_end_time, fixed_leg_discount_times, fixed_leg_discount_rates)\n        last_fixed_discount_factor = tf.math.exp(-last_fixed_leg_end_time * last_fixed_discount_rate)\n        last_fixed_leg_cashflow_pv = last_fixed_leg_daycount * last_fixed_leg_cashflows * last_fixed_discount_factor\n    calc_discounts_float_leg = tf.math.exp(-float_discount_rates * float_leg_calc_times_end)\n    calc_discounts_fixed_leg = tf.math.exp(-fixed_discount_rates * fixed_leg_calc_times)\n    float_pv = tf.math.segment_sum(float_cashflows * calc_discounts_float_leg, calc_groups_float)\n    fixed_pv = tf.math.segment_sum(calc_fixed_leg_daycount * calc_fixed_leg_cashflows * calc_discounts_fixed_leg, calc_groups_fixed)\n    if self_discounting_float_leg and self_discounting_fixed_leg:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        scale = last_fixed_leg_cashflows * last_fixed_leg_daycount - 1.0\n        next_discount = (present_values - float_pv - fixed_pv - p_n_minus_1) / scale\n    elif self_discounting_float_leg:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        next_discount = float_pv + (fixed_pv + last_fixed_leg_cashflow_pv) - present_values + p_n_minus_1\n    else:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        scale = present_values - float_pv - (fixed_pv + last_fixed_leg_cashflow_pv) + last_float_discount_factor\n        next_discount = p_n_minus_1 * last_float_discount_factor / scale\n    discount_diff = tf.math.abs(next_discount - discount_factor)\n    converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < curve_tolerance)\n    return (converged, failed, iteration + 1, next_discount)",
            "def _one_step(converged, failed, iteration, discount_factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'One step of the bootstrap iteration.'\n    x = -tf.math.log(discount_factor) / expiry_times\n    rates_start = curve_interpolator(float_leg_calc_times_start, expiry_times, x)\n    rates_end = curve_interpolator(float_leg_calc_times_end, expiry_times, x)\n    rates_start_last = curve_interpolator(last_float_leg_start_time, expiry_times, x)\n    float_cashflows = tf.math.exp(float_leg_calc_times_end * rates_end) / tf.math.exp(float_leg_calc_times_start * rates_start) - 1.0\n    if self_discounting_float_leg:\n        float_discount_rates = rates_end\n    else:\n        float_discount_rates = curve_interpolator(float_leg_calc_times_end, float_leg_discount_times, float_leg_discount_rates)\n        last_float_discount_rate = curve_interpolator(last_float_leg_end_time, float_leg_discount_times, float_leg_discount_rates)\n        last_float_discount_factor = tf.math.exp(-last_float_discount_rate * last_float_leg_end_time)\n    if self_discounting_fixed_leg:\n        fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, expiry_times, x)\n    else:\n        fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, fixed_leg_discount_times, fixed_leg_discount_rates)\n        last_fixed_discount_rate = curve_interpolator(last_fixed_leg_end_time, fixed_leg_discount_times, fixed_leg_discount_rates)\n        last_fixed_discount_factor = tf.math.exp(-last_fixed_leg_end_time * last_fixed_discount_rate)\n        last_fixed_leg_cashflow_pv = last_fixed_leg_daycount * last_fixed_leg_cashflows * last_fixed_discount_factor\n    calc_discounts_float_leg = tf.math.exp(-float_discount_rates * float_leg_calc_times_end)\n    calc_discounts_fixed_leg = tf.math.exp(-fixed_discount_rates * fixed_leg_calc_times)\n    float_pv = tf.math.segment_sum(float_cashflows * calc_discounts_float_leg, calc_groups_float)\n    fixed_pv = tf.math.segment_sum(calc_fixed_leg_daycount * calc_fixed_leg_cashflows * calc_discounts_fixed_leg, calc_groups_fixed)\n    if self_discounting_float_leg and self_discounting_fixed_leg:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        scale = last_fixed_leg_cashflows * last_fixed_leg_daycount - 1.0\n        next_discount = (present_values - float_pv - fixed_pv - p_n_minus_1) / scale\n    elif self_discounting_float_leg:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        next_discount = float_pv + (fixed_pv + last_fixed_leg_cashflow_pv) - present_values + p_n_minus_1\n    else:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        scale = present_values - float_pv - (fixed_pv + last_fixed_leg_cashflow_pv) + last_float_discount_factor\n        next_discount = p_n_minus_1 * last_float_discount_factor / scale\n    discount_diff = tf.math.abs(next_discount - discount_factor)\n    converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < curve_tolerance)\n    return (converged, failed, iteration + 1, next_discount)",
            "def _one_step(converged, failed, iteration, discount_factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'One step of the bootstrap iteration.'\n    x = -tf.math.log(discount_factor) / expiry_times\n    rates_start = curve_interpolator(float_leg_calc_times_start, expiry_times, x)\n    rates_end = curve_interpolator(float_leg_calc_times_end, expiry_times, x)\n    rates_start_last = curve_interpolator(last_float_leg_start_time, expiry_times, x)\n    float_cashflows = tf.math.exp(float_leg_calc_times_end * rates_end) / tf.math.exp(float_leg_calc_times_start * rates_start) - 1.0\n    if self_discounting_float_leg:\n        float_discount_rates = rates_end\n    else:\n        float_discount_rates = curve_interpolator(float_leg_calc_times_end, float_leg_discount_times, float_leg_discount_rates)\n        last_float_discount_rate = curve_interpolator(last_float_leg_end_time, float_leg_discount_times, float_leg_discount_rates)\n        last_float_discount_factor = tf.math.exp(-last_float_discount_rate * last_float_leg_end_time)\n    if self_discounting_fixed_leg:\n        fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, expiry_times, x)\n    else:\n        fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, fixed_leg_discount_times, fixed_leg_discount_rates)\n        last_fixed_discount_rate = curve_interpolator(last_fixed_leg_end_time, fixed_leg_discount_times, fixed_leg_discount_rates)\n        last_fixed_discount_factor = tf.math.exp(-last_fixed_leg_end_time * last_fixed_discount_rate)\n        last_fixed_leg_cashflow_pv = last_fixed_leg_daycount * last_fixed_leg_cashflows * last_fixed_discount_factor\n    calc_discounts_float_leg = tf.math.exp(-float_discount_rates * float_leg_calc_times_end)\n    calc_discounts_fixed_leg = tf.math.exp(-fixed_discount_rates * fixed_leg_calc_times)\n    float_pv = tf.math.segment_sum(float_cashflows * calc_discounts_float_leg, calc_groups_float)\n    fixed_pv = tf.math.segment_sum(calc_fixed_leg_daycount * calc_fixed_leg_cashflows * calc_discounts_fixed_leg, calc_groups_fixed)\n    if self_discounting_float_leg and self_discounting_fixed_leg:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        scale = last_fixed_leg_cashflows * last_fixed_leg_daycount - 1.0\n        next_discount = (present_values - float_pv - fixed_pv - p_n_minus_1) / scale\n    elif self_discounting_float_leg:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        next_discount = float_pv + (fixed_pv + last_fixed_leg_cashflow_pv) - present_values + p_n_minus_1\n    else:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        scale = present_values - float_pv - (fixed_pv + last_fixed_leg_cashflow_pv) + last_float_discount_factor\n        next_discount = p_n_minus_1 * last_float_discount_factor / scale\n    discount_diff = tf.math.abs(next_discount - discount_factor)\n    converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < curve_tolerance)\n    return (converged, failed, iteration + 1, next_discount)",
            "def _one_step(converged, failed, iteration, discount_factor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'One step of the bootstrap iteration.'\n    x = -tf.math.log(discount_factor) / expiry_times\n    rates_start = curve_interpolator(float_leg_calc_times_start, expiry_times, x)\n    rates_end = curve_interpolator(float_leg_calc_times_end, expiry_times, x)\n    rates_start_last = curve_interpolator(last_float_leg_start_time, expiry_times, x)\n    float_cashflows = tf.math.exp(float_leg_calc_times_end * rates_end) / tf.math.exp(float_leg_calc_times_start * rates_start) - 1.0\n    if self_discounting_float_leg:\n        float_discount_rates = rates_end\n    else:\n        float_discount_rates = curve_interpolator(float_leg_calc_times_end, float_leg_discount_times, float_leg_discount_rates)\n        last_float_discount_rate = curve_interpolator(last_float_leg_end_time, float_leg_discount_times, float_leg_discount_rates)\n        last_float_discount_factor = tf.math.exp(-last_float_discount_rate * last_float_leg_end_time)\n    if self_discounting_fixed_leg:\n        fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, expiry_times, x)\n    else:\n        fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, fixed_leg_discount_times, fixed_leg_discount_rates)\n        last_fixed_discount_rate = curve_interpolator(last_fixed_leg_end_time, fixed_leg_discount_times, fixed_leg_discount_rates)\n        last_fixed_discount_factor = tf.math.exp(-last_fixed_leg_end_time * last_fixed_discount_rate)\n        last_fixed_leg_cashflow_pv = last_fixed_leg_daycount * last_fixed_leg_cashflows * last_fixed_discount_factor\n    calc_discounts_float_leg = tf.math.exp(-float_discount_rates * float_leg_calc_times_end)\n    calc_discounts_fixed_leg = tf.math.exp(-fixed_discount_rates * fixed_leg_calc_times)\n    float_pv = tf.math.segment_sum(float_cashflows * calc_discounts_float_leg, calc_groups_float)\n    fixed_pv = tf.math.segment_sum(calc_fixed_leg_daycount * calc_fixed_leg_cashflows * calc_discounts_fixed_leg, calc_groups_fixed)\n    if self_discounting_float_leg and self_discounting_fixed_leg:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        scale = last_fixed_leg_cashflows * last_fixed_leg_daycount - 1.0\n        next_discount = (present_values - float_pv - fixed_pv - p_n_minus_1) / scale\n    elif self_discounting_float_leg:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        next_discount = float_pv + (fixed_pv + last_fixed_leg_cashflow_pv) - present_values + p_n_minus_1\n    else:\n        p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n        scale = present_values - float_pv - (fixed_pv + last_fixed_leg_cashflow_pv) + last_float_discount_factor\n        next_discount = p_n_minus_1 * last_float_discount_factor / scale\n    discount_diff = tf.math.abs(next_discount - discount_factor)\n    converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < curve_tolerance)\n    return (converged, failed, iteration + 1, next_discount)"
        ]
    },
    {
        "func_name": "cond",
        "original": "def cond(converged, failed, iteration, x):\n    del iteration, x\n    return ~tf.math.logical_or(converged, failed)",
        "mutated": [
            "def cond(converged, failed, iteration, x):\n    if False:\n        i = 10\n    del iteration, x\n    return ~tf.math.logical_or(converged, failed)",
            "def cond(converged, failed, iteration, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    del iteration, x\n    return ~tf.math.logical_or(converged, failed)",
            "def cond(converged, failed, iteration, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    del iteration, x\n    return ~tf.math.logical_or(converged, failed)",
            "def cond(converged, failed, iteration, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    del iteration, x\n    return ~tf.math.logical_or(converged, failed)",
            "def cond(converged, failed, iteration, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    del iteration, x\n    return ~tf.math.logical_or(converged, failed)"
        ]
    },
    {
        "func_name": "_build_swap_curve",
        "original": "def _build_swap_curve(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions, float_leg_discount_rates, float_leg_discount_times, fixed_leg_discount_rates, fixed_leg_discount_times, self_discounting_float_leg, self_discounting_fixed_leg, present_values, pv_settlement_times, curve_interpolator, initial_rates, curve_tolerance, maximum_iterations, dtype):\n    \"\"\"Build the zero swap curve using the bootstrap method.\"\"\"\n    del fixed_leg_start_times, pv_settlement_times\n    curve_tensors = _create_curve_building_tensors(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions)\n    float_leg_calc_times_start = curve_tensors.float_leg_times_start\n    float_leg_calc_times_end = curve_tensors.float_leg_times_end\n    calc_fixed_leg_cashflows = curve_tensors.fixed_leg_cashflows\n    calc_fixed_leg_daycount = curve_tensors.fixed_leg_daycount\n    fixed_leg_calc_times = curve_tensors.fixed_leg_calc_times\n    calc_groups_float = curve_tensors.calc_groups_float\n    calc_groups_fixed = curve_tensors.calc_groups_fixed\n    last_float_leg_start_time = curve_tensors.last_float_leg_start_time\n    last_float_leg_end_time = curve_tensors.last_float_leg_end_time\n    last_fixed_leg_end_time = curve_tensors.last_fixed_leg_calc_time\n    last_fixed_leg_daycount = curve_tensors.last_fixed_leg_daycount\n    last_fixed_leg_cashflows = curve_tensors.last_fixed_leg_cashflows\n    expiry_times = curve_tensors.expiry_times\n\n    def _one_step(converged, failed, iteration, discount_factor):\n        \"\"\"One step of the bootstrap iteration.\"\"\"\n        x = -tf.math.log(discount_factor) / expiry_times\n        rates_start = curve_interpolator(float_leg_calc_times_start, expiry_times, x)\n        rates_end = curve_interpolator(float_leg_calc_times_end, expiry_times, x)\n        rates_start_last = curve_interpolator(last_float_leg_start_time, expiry_times, x)\n        float_cashflows = tf.math.exp(float_leg_calc_times_end * rates_end) / tf.math.exp(float_leg_calc_times_start * rates_start) - 1.0\n        if self_discounting_float_leg:\n            float_discount_rates = rates_end\n        else:\n            float_discount_rates = curve_interpolator(float_leg_calc_times_end, float_leg_discount_times, float_leg_discount_rates)\n            last_float_discount_rate = curve_interpolator(last_float_leg_end_time, float_leg_discount_times, float_leg_discount_rates)\n            last_float_discount_factor = tf.math.exp(-last_float_discount_rate * last_float_leg_end_time)\n        if self_discounting_fixed_leg:\n            fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, expiry_times, x)\n        else:\n            fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, fixed_leg_discount_times, fixed_leg_discount_rates)\n            last_fixed_discount_rate = curve_interpolator(last_fixed_leg_end_time, fixed_leg_discount_times, fixed_leg_discount_rates)\n            last_fixed_discount_factor = tf.math.exp(-last_fixed_leg_end_time * last_fixed_discount_rate)\n            last_fixed_leg_cashflow_pv = last_fixed_leg_daycount * last_fixed_leg_cashflows * last_fixed_discount_factor\n        calc_discounts_float_leg = tf.math.exp(-float_discount_rates * float_leg_calc_times_end)\n        calc_discounts_fixed_leg = tf.math.exp(-fixed_discount_rates * fixed_leg_calc_times)\n        float_pv = tf.math.segment_sum(float_cashflows * calc_discounts_float_leg, calc_groups_float)\n        fixed_pv = tf.math.segment_sum(calc_fixed_leg_daycount * calc_fixed_leg_cashflows * calc_discounts_fixed_leg, calc_groups_fixed)\n        if self_discounting_float_leg and self_discounting_fixed_leg:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            scale = last_fixed_leg_cashflows * last_fixed_leg_daycount - 1.0\n            next_discount = (present_values - float_pv - fixed_pv - p_n_minus_1) / scale\n        elif self_discounting_float_leg:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            next_discount = float_pv + (fixed_pv + last_fixed_leg_cashflow_pv) - present_values + p_n_minus_1\n        else:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            scale = present_values - float_pv - (fixed_pv + last_fixed_leg_cashflow_pv) + last_float_discount_factor\n            next_discount = p_n_minus_1 * last_float_discount_factor / scale\n        discount_diff = tf.math.abs(next_discount - discount_factor)\n        converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < curve_tolerance)\n        return (converged, failed, iteration + 1, next_discount)\n\n    def cond(converged, failed, iteration, x):\n        del iteration, x\n        return ~tf.math.logical_or(converged, failed)\n    initial_vals = (False, False, 0, tf.math.exp(-initial_rates * expiry_times))\n    bootstrap_result = tf.compat.v2.while_loop(cond, _one_step, initial_vals, maximum_iterations=maximum_iterations)\n    discount_factors = bootstrap_result[-1]\n    discount_rates = -tf.math.log(discount_factors) / expiry_times\n    results = scc.SwapCurveBuilderResult(times=expiry_times, rates=discount_rates, discount_factors=discount_factors, initial_rates=initial_rates, converged=bootstrap_result[0], failed=bootstrap_result[1], iterations=bootstrap_result[2], objective_value=tf.constant(0, dtype=dtype))\n    return results",
        "mutated": [
            "def _build_swap_curve(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions, float_leg_discount_rates, float_leg_discount_times, fixed_leg_discount_rates, fixed_leg_discount_times, self_discounting_float_leg, self_discounting_fixed_leg, present_values, pv_settlement_times, curve_interpolator, initial_rates, curve_tolerance, maximum_iterations, dtype):\n    if False:\n        i = 10\n    'Build the zero swap curve using the bootstrap method.'\n    del fixed_leg_start_times, pv_settlement_times\n    curve_tensors = _create_curve_building_tensors(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions)\n    float_leg_calc_times_start = curve_tensors.float_leg_times_start\n    float_leg_calc_times_end = curve_tensors.float_leg_times_end\n    calc_fixed_leg_cashflows = curve_tensors.fixed_leg_cashflows\n    calc_fixed_leg_daycount = curve_tensors.fixed_leg_daycount\n    fixed_leg_calc_times = curve_tensors.fixed_leg_calc_times\n    calc_groups_float = curve_tensors.calc_groups_float\n    calc_groups_fixed = curve_tensors.calc_groups_fixed\n    last_float_leg_start_time = curve_tensors.last_float_leg_start_time\n    last_float_leg_end_time = curve_tensors.last_float_leg_end_time\n    last_fixed_leg_end_time = curve_tensors.last_fixed_leg_calc_time\n    last_fixed_leg_daycount = curve_tensors.last_fixed_leg_daycount\n    last_fixed_leg_cashflows = curve_tensors.last_fixed_leg_cashflows\n    expiry_times = curve_tensors.expiry_times\n\n    def _one_step(converged, failed, iteration, discount_factor):\n        \"\"\"One step of the bootstrap iteration.\"\"\"\n        x = -tf.math.log(discount_factor) / expiry_times\n        rates_start = curve_interpolator(float_leg_calc_times_start, expiry_times, x)\n        rates_end = curve_interpolator(float_leg_calc_times_end, expiry_times, x)\n        rates_start_last = curve_interpolator(last_float_leg_start_time, expiry_times, x)\n        float_cashflows = tf.math.exp(float_leg_calc_times_end * rates_end) / tf.math.exp(float_leg_calc_times_start * rates_start) - 1.0\n        if self_discounting_float_leg:\n            float_discount_rates = rates_end\n        else:\n            float_discount_rates = curve_interpolator(float_leg_calc_times_end, float_leg_discount_times, float_leg_discount_rates)\n            last_float_discount_rate = curve_interpolator(last_float_leg_end_time, float_leg_discount_times, float_leg_discount_rates)\n            last_float_discount_factor = tf.math.exp(-last_float_discount_rate * last_float_leg_end_time)\n        if self_discounting_fixed_leg:\n            fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, expiry_times, x)\n        else:\n            fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, fixed_leg_discount_times, fixed_leg_discount_rates)\n            last_fixed_discount_rate = curve_interpolator(last_fixed_leg_end_time, fixed_leg_discount_times, fixed_leg_discount_rates)\n            last_fixed_discount_factor = tf.math.exp(-last_fixed_leg_end_time * last_fixed_discount_rate)\n            last_fixed_leg_cashflow_pv = last_fixed_leg_daycount * last_fixed_leg_cashflows * last_fixed_discount_factor\n        calc_discounts_float_leg = tf.math.exp(-float_discount_rates * float_leg_calc_times_end)\n        calc_discounts_fixed_leg = tf.math.exp(-fixed_discount_rates * fixed_leg_calc_times)\n        float_pv = tf.math.segment_sum(float_cashflows * calc_discounts_float_leg, calc_groups_float)\n        fixed_pv = tf.math.segment_sum(calc_fixed_leg_daycount * calc_fixed_leg_cashflows * calc_discounts_fixed_leg, calc_groups_fixed)\n        if self_discounting_float_leg and self_discounting_fixed_leg:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            scale = last_fixed_leg_cashflows * last_fixed_leg_daycount - 1.0\n            next_discount = (present_values - float_pv - fixed_pv - p_n_minus_1) / scale\n        elif self_discounting_float_leg:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            next_discount = float_pv + (fixed_pv + last_fixed_leg_cashflow_pv) - present_values + p_n_minus_1\n        else:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            scale = present_values - float_pv - (fixed_pv + last_fixed_leg_cashflow_pv) + last_float_discount_factor\n            next_discount = p_n_minus_1 * last_float_discount_factor / scale\n        discount_diff = tf.math.abs(next_discount - discount_factor)\n        converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < curve_tolerance)\n        return (converged, failed, iteration + 1, next_discount)\n\n    def cond(converged, failed, iteration, x):\n        del iteration, x\n        return ~tf.math.logical_or(converged, failed)\n    initial_vals = (False, False, 0, tf.math.exp(-initial_rates * expiry_times))\n    bootstrap_result = tf.compat.v2.while_loop(cond, _one_step, initial_vals, maximum_iterations=maximum_iterations)\n    discount_factors = bootstrap_result[-1]\n    discount_rates = -tf.math.log(discount_factors) / expiry_times\n    results = scc.SwapCurveBuilderResult(times=expiry_times, rates=discount_rates, discount_factors=discount_factors, initial_rates=initial_rates, converged=bootstrap_result[0], failed=bootstrap_result[1], iterations=bootstrap_result[2], objective_value=tf.constant(0, dtype=dtype))\n    return results",
            "def _build_swap_curve(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions, float_leg_discount_rates, float_leg_discount_times, fixed_leg_discount_rates, fixed_leg_discount_times, self_discounting_float_leg, self_discounting_fixed_leg, present_values, pv_settlement_times, curve_interpolator, initial_rates, curve_tolerance, maximum_iterations, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Build the zero swap curve using the bootstrap method.'\n    del fixed_leg_start_times, pv_settlement_times\n    curve_tensors = _create_curve_building_tensors(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions)\n    float_leg_calc_times_start = curve_tensors.float_leg_times_start\n    float_leg_calc_times_end = curve_tensors.float_leg_times_end\n    calc_fixed_leg_cashflows = curve_tensors.fixed_leg_cashflows\n    calc_fixed_leg_daycount = curve_tensors.fixed_leg_daycount\n    fixed_leg_calc_times = curve_tensors.fixed_leg_calc_times\n    calc_groups_float = curve_tensors.calc_groups_float\n    calc_groups_fixed = curve_tensors.calc_groups_fixed\n    last_float_leg_start_time = curve_tensors.last_float_leg_start_time\n    last_float_leg_end_time = curve_tensors.last_float_leg_end_time\n    last_fixed_leg_end_time = curve_tensors.last_fixed_leg_calc_time\n    last_fixed_leg_daycount = curve_tensors.last_fixed_leg_daycount\n    last_fixed_leg_cashflows = curve_tensors.last_fixed_leg_cashflows\n    expiry_times = curve_tensors.expiry_times\n\n    def _one_step(converged, failed, iteration, discount_factor):\n        \"\"\"One step of the bootstrap iteration.\"\"\"\n        x = -tf.math.log(discount_factor) / expiry_times\n        rates_start = curve_interpolator(float_leg_calc_times_start, expiry_times, x)\n        rates_end = curve_interpolator(float_leg_calc_times_end, expiry_times, x)\n        rates_start_last = curve_interpolator(last_float_leg_start_time, expiry_times, x)\n        float_cashflows = tf.math.exp(float_leg_calc_times_end * rates_end) / tf.math.exp(float_leg_calc_times_start * rates_start) - 1.0\n        if self_discounting_float_leg:\n            float_discount_rates = rates_end\n        else:\n            float_discount_rates = curve_interpolator(float_leg_calc_times_end, float_leg_discount_times, float_leg_discount_rates)\n            last_float_discount_rate = curve_interpolator(last_float_leg_end_time, float_leg_discount_times, float_leg_discount_rates)\n            last_float_discount_factor = tf.math.exp(-last_float_discount_rate * last_float_leg_end_time)\n        if self_discounting_fixed_leg:\n            fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, expiry_times, x)\n        else:\n            fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, fixed_leg_discount_times, fixed_leg_discount_rates)\n            last_fixed_discount_rate = curve_interpolator(last_fixed_leg_end_time, fixed_leg_discount_times, fixed_leg_discount_rates)\n            last_fixed_discount_factor = tf.math.exp(-last_fixed_leg_end_time * last_fixed_discount_rate)\n            last_fixed_leg_cashflow_pv = last_fixed_leg_daycount * last_fixed_leg_cashflows * last_fixed_discount_factor\n        calc_discounts_float_leg = tf.math.exp(-float_discount_rates * float_leg_calc_times_end)\n        calc_discounts_fixed_leg = tf.math.exp(-fixed_discount_rates * fixed_leg_calc_times)\n        float_pv = tf.math.segment_sum(float_cashflows * calc_discounts_float_leg, calc_groups_float)\n        fixed_pv = tf.math.segment_sum(calc_fixed_leg_daycount * calc_fixed_leg_cashflows * calc_discounts_fixed_leg, calc_groups_fixed)\n        if self_discounting_float_leg and self_discounting_fixed_leg:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            scale = last_fixed_leg_cashflows * last_fixed_leg_daycount - 1.0\n            next_discount = (present_values - float_pv - fixed_pv - p_n_minus_1) / scale\n        elif self_discounting_float_leg:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            next_discount = float_pv + (fixed_pv + last_fixed_leg_cashflow_pv) - present_values + p_n_minus_1\n        else:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            scale = present_values - float_pv - (fixed_pv + last_fixed_leg_cashflow_pv) + last_float_discount_factor\n            next_discount = p_n_minus_1 * last_float_discount_factor / scale\n        discount_diff = tf.math.abs(next_discount - discount_factor)\n        converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < curve_tolerance)\n        return (converged, failed, iteration + 1, next_discount)\n\n    def cond(converged, failed, iteration, x):\n        del iteration, x\n        return ~tf.math.logical_or(converged, failed)\n    initial_vals = (False, False, 0, tf.math.exp(-initial_rates * expiry_times))\n    bootstrap_result = tf.compat.v2.while_loop(cond, _one_step, initial_vals, maximum_iterations=maximum_iterations)\n    discount_factors = bootstrap_result[-1]\n    discount_rates = -tf.math.log(discount_factors) / expiry_times\n    results = scc.SwapCurveBuilderResult(times=expiry_times, rates=discount_rates, discount_factors=discount_factors, initial_rates=initial_rates, converged=bootstrap_result[0], failed=bootstrap_result[1], iterations=bootstrap_result[2], objective_value=tf.constant(0, dtype=dtype))\n    return results",
            "def _build_swap_curve(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions, float_leg_discount_rates, float_leg_discount_times, fixed_leg_discount_rates, fixed_leg_discount_times, self_discounting_float_leg, self_discounting_fixed_leg, present_values, pv_settlement_times, curve_interpolator, initial_rates, curve_tolerance, maximum_iterations, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Build the zero swap curve using the bootstrap method.'\n    del fixed_leg_start_times, pv_settlement_times\n    curve_tensors = _create_curve_building_tensors(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions)\n    float_leg_calc_times_start = curve_tensors.float_leg_times_start\n    float_leg_calc_times_end = curve_tensors.float_leg_times_end\n    calc_fixed_leg_cashflows = curve_tensors.fixed_leg_cashflows\n    calc_fixed_leg_daycount = curve_tensors.fixed_leg_daycount\n    fixed_leg_calc_times = curve_tensors.fixed_leg_calc_times\n    calc_groups_float = curve_tensors.calc_groups_float\n    calc_groups_fixed = curve_tensors.calc_groups_fixed\n    last_float_leg_start_time = curve_tensors.last_float_leg_start_time\n    last_float_leg_end_time = curve_tensors.last_float_leg_end_time\n    last_fixed_leg_end_time = curve_tensors.last_fixed_leg_calc_time\n    last_fixed_leg_daycount = curve_tensors.last_fixed_leg_daycount\n    last_fixed_leg_cashflows = curve_tensors.last_fixed_leg_cashflows\n    expiry_times = curve_tensors.expiry_times\n\n    def _one_step(converged, failed, iteration, discount_factor):\n        \"\"\"One step of the bootstrap iteration.\"\"\"\n        x = -tf.math.log(discount_factor) / expiry_times\n        rates_start = curve_interpolator(float_leg_calc_times_start, expiry_times, x)\n        rates_end = curve_interpolator(float_leg_calc_times_end, expiry_times, x)\n        rates_start_last = curve_interpolator(last_float_leg_start_time, expiry_times, x)\n        float_cashflows = tf.math.exp(float_leg_calc_times_end * rates_end) / tf.math.exp(float_leg_calc_times_start * rates_start) - 1.0\n        if self_discounting_float_leg:\n            float_discount_rates = rates_end\n        else:\n            float_discount_rates = curve_interpolator(float_leg_calc_times_end, float_leg_discount_times, float_leg_discount_rates)\n            last_float_discount_rate = curve_interpolator(last_float_leg_end_time, float_leg_discount_times, float_leg_discount_rates)\n            last_float_discount_factor = tf.math.exp(-last_float_discount_rate * last_float_leg_end_time)\n        if self_discounting_fixed_leg:\n            fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, expiry_times, x)\n        else:\n            fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, fixed_leg_discount_times, fixed_leg_discount_rates)\n            last_fixed_discount_rate = curve_interpolator(last_fixed_leg_end_time, fixed_leg_discount_times, fixed_leg_discount_rates)\n            last_fixed_discount_factor = tf.math.exp(-last_fixed_leg_end_time * last_fixed_discount_rate)\n            last_fixed_leg_cashflow_pv = last_fixed_leg_daycount * last_fixed_leg_cashflows * last_fixed_discount_factor\n        calc_discounts_float_leg = tf.math.exp(-float_discount_rates * float_leg_calc_times_end)\n        calc_discounts_fixed_leg = tf.math.exp(-fixed_discount_rates * fixed_leg_calc_times)\n        float_pv = tf.math.segment_sum(float_cashflows * calc_discounts_float_leg, calc_groups_float)\n        fixed_pv = tf.math.segment_sum(calc_fixed_leg_daycount * calc_fixed_leg_cashflows * calc_discounts_fixed_leg, calc_groups_fixed)\n        if self_discounting_float_leg and self_discounting_fixed_leg:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            scale = last_fixed_leg_cashflows * last_fixed_leg_daycount - 1.0\n            next_discount = (present_values - float_pv - fixed_pv - p_n_minus_1) / scale\n        elif self_discounting_float_leg:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            next_discount = float_pv + (fixed_pv + last_fixed_leg_cashflow_pv) - present_values + p_n_minus_1\n        else:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            scale = present_values - float_pv - (fixed_pv + last_fixed_leg_cashflow_pv) + last_float_discount_factor\n            next_discount = p_n_minus_1 * last_float_discount_factor / scale\n        discount_diff = tf.math.abs(next_discount - discount_factor)\n        converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < curve_tolerance)\n        return (converged, failed, iteration + 1, next_discount)\n\n    def cond(converged, failed, iteration, x):\n        del iteration, x\n        return ~tf.math.logical_or(converged, failed)\n    initial_vals = (False, False, 0, tf.math.exp(-initial_rates * expiry_times))\n    bootstrap_result = tf.compat.v2.while_loop(cond, _one_step, initial_vals, maximum_iterations=maximum_iterations)\n    discount_factors = bootstrap_result[-1]\n    discount_rates = -tf.math.log(discount_factors) / expiry_times\n    results = scc.SwapCurveBuilderResult(times=expiry_times, rates=discount_rates, discount_factors=discount_factors, initial_rates=initial_rates, converged=bootstrap_result[0], failed=bootstrap_result[1], iterations=bootstrap_result[2], objective_value=tf.constant(0, dtype=dtype))\n    return results",
            "def _build_swap_curve(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions, float_leg_discount_rates, float_leg_discount_times, fixed_leg_discount_rates, fixed_leg_discount_times, self_discounting_float_leg, self_discounting_fixed_leg, present_values, pv_settlement_times, curve_interpolator, initial_rates, curve_tolerance, maximum_iterations, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Build the zero swap curve using the bootstrap method.'\n    del fixed_leg_start_times, pv_settlement_times\n    curve_tensors = _create_curve_building_tensors(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions)\n    float_leg_calc_times_start = curve_tensors.float_leg_times_start\n    float_leg_calc_times_end = curve_tensors.float_leg_times_end\n    calc_fixed_leg_cashflows = curve_tensors.fixed_leg_cashflows\n    calc_fixed_leg_daycount = curve_tensors.fixed_leg_daycount\n    fixed_leg_calc_times = curve_tensors.fixed_leg_calc_times\n    calc_groups_float = curve_tensors.calc_groups_float\n    calc_groups_fixed = curve_tensors.calc_groups_fixed\n    last_float_leg_start_time = curve_tensors.last_float_leg_start_time\n    last_float_leg_end_time = curve_tensors.last_float_leg_end_time\n    last_fixed_leg_end_time = curve_tensors.last_fixed_leg_calc_time\n    last_fixed_leg_daycount = curve_tensors.last_fixed_leg_daycount\n    last_fixed_leg_cashflows = curve_tensors.last_fixed_leg_cashflows\n    expiry_times = curve_tensors.expiry_times\n\n    def _one_step(converged, failed, iteration, discount_factor):\n        \"\"\"One step of the bootstrap iteration.\"\"\"\n        x = -tf.math.log(discount_factor) / expiry_times\n        rates_start = curve_interpolator(float_leg_calc_times_start, expiry_times, x)\n        rates_end = curve_interpolator(float_leg_calc_times_end, expiry_times, x)\n        rates_start_last = curve_interpolator(last_float_leg_start_time, expiry_times, x)\n        float_cashflows = tf.math.exp(float_leg_calc_times_end * rates_end) / tf.math.exp(float_leg_calc_times_start * rates_start) - 1.0\n        if self_discounting_float_leg:\n            float_discount_rates = rates_end\n        else:\n            float_discount_rates = curve_interpolator(float_leg_calc_times_end, float_leg_discount_times, float_leg_discount_rates)\n            last_float_discount_rate = curve_interpolator(last_float_leg_end_time, float_leg_discount_times, float_leg_discount_rates)\n            last_float_discount_factor = tf.math.exp(-last_float_discount_rate * last_float_leg_end_time)\n        if self_discounting_fixed_leg:\n            fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, expiry_times, x)\n        else:\n            fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, fixed_leg_discount_times, fixed_leg_discount_rates)\n            last_fixed_discount_rate = curve_interpolator(last_fixed_leg_end_time, fixed_leg_discount_times, fixed_leg_discount_rates)\n            last_fixed_discount_factor = tf.math.exp(-last_fixed_leg_end_time * last_fixed_discount_rate)\n            last_fixed_leg_cashflow_pv = last_fixed_leg_daycount * last_fixed_leg_cashflows * last_fixed_discount_factor\n        calc_discounts_float_leg = tf.math.exp(-float_discount_rates * float_leg_calc_times_end)\n        calc_discounts_fixed_leg = tf.math.exp(-fixed_discount_rates * fixed_leg_calc_times)\n        float_pv = tf.math.segment_sum(float_cashflows * calc_discounts_float_leg, calc_groups_float)\n        fixed_pv = tf.math.segment_sum(calc_fixed_leg_daycount * calc_fixed_leg_cashflows * calc_discounts_fixed_leg, calc_groups_fixed)\n        if self_discounting_float_leg and self_discounting_fixed_leg:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            scale = last_fixed_leg_cashflows * last_fixed_leg_daycount - 1.0\n            next_discount = (present_values - float_pv - fixed_pv - p_n_minus_1) / scale\n        elif self_discounting_float_leg:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            next_discount = float_pv + (fixed_pv + last_fixed_leg_cashflow_pv) - present_values + p_n_minus_1\n        else:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            scale = present_values - float_pv - (fixed_pv + last_fixed_leg_cashflow_pv) + last_float_discount_factor\n            next_discount = p_n_minus_1 * last_float_discount_factor / scale\n        discount_diff = tf.math.abs(next_discount - discount_factor)\n        converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < curve_tolerance)\n        return (converged, failed, iteration + 1, next_discount)\n\n    def cond(converged, failed, iteration, x):\n        del iteration, x\n        return ~tf.math.logical_or(converged, failed)\n    initial_vals = (False, False, 0, tf.math.exp(-initial_rates * expiry_times))\n    bootstrap_result = tf.compat.v2.while_loop(cond, _one_step, initial_vals, maximum_iterations=maximum_iterations)\n    discount_factors = bootstrap_result[-1]\n    discount_rates = -tf.math.log(discount_factors) / expiry_times\n    results = scc.SwapCurveBuilderResult(times=expiry_times, rates=discount_rates, discount_factors=discount_factors, initial_rates=initial_rates, converged=bootstrap_result[0], failed=bootstrap_result[1], iterations=bootstrap_result[2], objective_value=tf.constant(0, dtype=dtype))\n    return results",
            "def _build_swap_curve(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions, float_leg_discount_rates, float_leg_discount_times, fixed_leg_discount_rates, fixed_leg_discount_times, self_discounting_float_leg, self_discounting_fixed_leg, present_values, pv_settlement_times, curve_interpolator, initial_rates, curve_tolerance, maximum_iterations, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Build the zero swap curve using the bootstrap method.'\n    del fixed_leg_start_times, pv_settlement_times\n    curve_tensors = _create_curve_building_tensors(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions)\n    float_leg_calc_times_start = curve_tensors.float_leg_times_start\n    float_leg_calc_times_end = curve_tensors.float_leg_times_end\n    calc_fixed_leg_cashflows = curve_tensors.fixed_leg_cashflows\n    calc_fixed_leg_daycount = curve_tensors.fixed_leg_daycount\n    fixed_leg_calc_times = curve_tensors.fixed_leg_calc_times\n    calc_groups_float = curve_tensors.calc_groups_float\n    calc_groups_fixed = curve_tensors.calc_groups_fixed\n    last_float_leg_start_time = curve_tensors.last_float_leg_start_time\n    last_float_leg_end_time = curve_tensors.last_float_leg_end_time\n    last_fixed_leg_end_time = curve_tensors.last_fixed_leg_calc_time\n    last_fixed_leg_daycount = curve_tensors.last_fixed_leg_daycount\n    last_fixed_leg_cashflows = curve_tensors.last_fixed_leg_cashflows\n    expiry_times = curve_tensors.expiry_times\n\n    def _one_step(converged, failed, iteration, discount_factor):\n        \"\"\"One step of the bootstrap iteration.\"\"\"\n        x = -tf.math.log(discount_factor) / expiry_times\n        rates_start = curve_interpolator(float_leg_calc_times_start, expiry_times, x)\n        rates_end = curve_interpolator(float_leg_calc_times_end, expiry_times, x)\n        rates_start_last = curve_interpolator(last_float_leg_start_time, expiry_times, x)\n        float_cashflows = tf.math.exp(float_leg_calc_times_end * rates_end) / tf.math.exp(float_leg_calc_times_start * rates_start) - 1.0\n        if self_discounting_float_leg:\n            float_discount_rates = rates_end\n        else:\n            float_discount_rates = curve_interpolator(float_leg_calc_times_end, float_leg_discount_times, float_leg_discount_rates)\n            last_float_discount_rate = curve_interpolator(last_float_leg_end_time, float_leg_discount_times, float_leg_discount_rates)\n            last_float_discount_factor = tf.math.exp(-last_float_discount_rate * last_float_leg_end_time)\n        if self_discounting_fixed_leg:\n            fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, expiry_times, x)\n        else:\n            fixed_discount_rates = curve_interpolator(fixed_leg_calc_times, fixed_leg_discount_times, fixed_leg_discount_rates)\n            last_fixed_discount_rate = curve_interpolator(last_fixed_leg_end_time, fixed_leg_discount_times, fixed_leg_discount_rates)\n            last_fixed_discount_factor = tf.math.exp(-last_fixed_leg_end_time * last_fixed_discount_rate)\n            last_fixed_leg_cashflow_pv = last_fixed_leg_daycount * last_fixed_leg_cashflows * last_fixed_discount_factor\n        calc_discounts_float_leg = tf.math.exp(-float_discount_rates * float_leg_calc_times_end)\n        calc_discounts_fixed_leg = tf.math.exp(-fixed_discount_rates * fixed_leg_calc_times)\n        float_pv = tf.math.segment_sum(float_cashflows * calc_discounts_float_leg, calc_groups_float)\n        fixed_pv = tf.math.segment_sum(calc_fixed_leg_daycount * calc_fixed_leg_cashflows * calc_discounts_fixed_leg, calc_groups_fixed)\n        if self_discounting_float_leg and self_discounting_fixed_leg:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            scale = last_fixed_leg_cashflows * last_fixed_leg_daycount - 1.0\n            next_discount = (present_values - float_pv - fixed_pv - p_n_minus_1) / scale\n        elif self_discounting_float_leg:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            next_discount = float_pv + (fixed_pv + last_fixed_leg_cashflow_pv) - present_values + p_n_minus_1\n        else:\n            p_n_minus_1 = tf.math.exp(-rates_start_last * last_float_leg_start_time)\n            scale = present_values - float_pv - (fixed_pv + last_fixed_leg_cashflow_pv) + last_float_discount_factor\n            next_discount = p_n_minus_1 * last_float_discount_factor / scale\n        discount_diff = tf.math.abs(next_discount - discount_factor)\n        converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < curve_tolerance)\n        return (converged, failed, iteration + 1, next_discount)\n\n    def cond(converged, failed, iteration, x):\n        del iteration, x\n        return ~tf.math.logical_or(converged, failed)\n    initial_vals = (False, False, 0, tf.math.exp(-initial_rates * expiry_times))\n    bootstrap_result = tf.compat.v2.while_loop(cond, _one_step, initial_vals, maximum_iterations=maximum_iterations)\n    discount_factors = bootstrap_result[-1]\n    discount_rates = -tf.math.log(discount_factors) / expiry_times\n    results = scc.SwapCurveBuilderResult(times=expiry_times, rates=discount_rates, discount_factors=discount_factors, initial_rates=initial_rates, converged=bootstrap_result[0], failed=bootstrap_result[1], iterations=bootstrap_result[2], objective_value=tf.constant(0, dtype=dtype))\n    return results"
        ]
    },
    {
        "func_name": "_convert_to_tensors",
        "original": "def _convert_to_tensors(dtype, input_array, name):\n    \"\"\"Converts the supplied list to a tensor.\"\"\"\n    output_tensor = [tf.convert_to_tensor(x, dtype=dtype, name=name + '_{}'.format(i)) for (i, x) in enumerate(input_array)]\n    return output_tensor",
        "mutated": [
            "def _convert_to_tensors(dtype, input_array, name):\n    if False:\n        i = 10\n    'Converts the supplied list to a tensor.'\n    output_tensor = [tf.convert_to_tensor(x, dtype=dtype, name=name + '_{}'.format(i)) for (i, x) in enumerate(input_array)]\n    return output_tensor",
            "def _convert_to_tensors(dtype, input_array, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Converts the supplied list to a tensor.'\n    output_tensor = [tf.convert_to_tensor(x, dtype=dtype, name=name + '_{}'.format(i)) for (i, x) in enumerate(input_array)]\n    return output_tensor",
            "def _convert_to_tensors(dtype, input_array, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Converts the supplied list to a tensor.'\n    output_tensor = [tf.convert_to_tensor(x, dtype=dtype, name=name + '_{}'.format(i)) for (i, x) in enumerate(input_array)]\n    return output_tensor",
            "def _convert_to_tensors(dtype, input_array, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Converts the supplied list to a tensor.'\n    output_tensor = [tf.convert_to_tensor(x, dtype=dtype, name=name + '_{}'.format(i)) for (i, x) in enumerate(input_array)]\n    return output_tensor",
            "def _convert_to_tensors(dtype, input_array, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Converts the supplied list to a tensor.'\n    output_tensor = [tf.convert_to_tensor(x, dtype=dtype, name=name + '_{}'.format(i)) for (i, x) in enumerate(input_array)]\n    return output_tensor"
        ]
    },
    {
        "func_name": "_create_curve_building_tensors",
        "original": "def _create_curve_building_tensors(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions):\n    \"\"\"Helper function to create tensors needed for curve construction.\"\"\"\n    calc_float_leg_daycount = []\n    float_leg_calc_times_start = []\n    float_leg_calc_times_end = []\n    calc_fixed_leg_cashflows = []\n    calc_fixed_leg_daycount = []\n    fixed_leg_calc_times = []\n    calc_groups_float = []\n    calc_groups_fixed = []\n    last_float_leg_start_time = []\n    last_float_leg_end_time = []\n    last_float_leg_daycount = []\n    last_fixed_leg_end_time = []\n    last_fixed_leg_daycount = []\n    last_fixed_leg_cashflows = []\n    expiry_times = []\n    num_instruments = len(float_leg_start_times)\n    for i in range(num_instruments):\n        calc_float_leg_daycount.append(float_leg_daycount_fractions[i][:-1])\n        float_leg_calc_times_start.append(float_leg_start_times[i][:-1])\n        float_leg_calc_times_end.append(float_leg_end_times[i][:-1])\n        calc_fixed_leg_cashflows.append(fixed_leg_cashflows[i][:-1])\n        calc_fixed_leg_daycount.append(fixed_leg_daycount_fractions[i][:-1])\n        fixed_leg_calc_times.append(fixed_leg_end_times[i][:-1])\n        last_float_leg_start_time.append(float_leg_start_times[i][-1])\n        last_float_leg_end_time.append(float_leg_end_times[i][-1])\n        last_float_leg_daycount.append(float_leg_daycount_fractions[i][-1])\n        last_fixed_leg_end_time.append(fixed_leg_end_times[i][-1])\n        last_fixed_leg_daycount.append(fixed_leg_daycount_fractions[i][-1])\n        last_fixed_leg_cashflows.append(fixed_leg_cashflows[i][-1])\n        expiry_times.append(tf.math.maximum(float_leg_end_times[i][-1], fixed_leg_end_times[i][-1]))\n        calc_groups_float.append(tf.fill(tf.shape(float_leg_start_times[i][:-1]), i))\n        calc_groups_fixed.append(tf.fill(tf.shape(fixed_leg_end_times[i][:-1]), i))\n    output = CurveFittingVars(float_leg_daycount=tf.concat(calc_float_leg_daycount, axis=0), float_leg_times_start=tf.concat(float_leg_calc_times_start, axis=0), float_leg_times_end=tf.concat(float_leg_calc_times_end, axis=0), fixed_leg_cashflows=tf.concat(calc_fixed_leg_cashflows, axis=0), fixed_leg_daycount=tf.concat(calc_fixed_leg_daycount, axis=0), fixed_leg_calc_times=tf.concat(fixed_leg_calc_times, axis=0), settle_times_fixed=None, settle_times_float=None, expiry_times=tf.stack(expiry_times, axis=0), calc_groups_float=tf.concat(calc_groups_float, axis=0), calc_groups_fixed=tf.concat(calc_groups_fixed, axis=0), last_float_leg_start_time=tf.stack(last_float_leg_start_time, axis=0), last_float_leg_end_time=tf.stack(last_float_leg_end_time, axis=0), last_float_leg_daycount=tf.stack(last_float_leg_daycount, axis=0), last_fixed_leg_calc_time=tf.stack(last_fixed_leg_end_time, axis=0), last_fixed_leg_daycount=tf.stack(last_fixed_leg_daycount, axis=0), last_fixed_leg_cashflows=tf.stack(last_fixed_leg_cashflows, axis=0))\n    return output",
        "mutated": [
            "def _create_curve_building_tensors(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions):\n    if False:\n        i = 10\n    'Helper function to create tensors needed for curve construction.'\n    calc_float_leg_daycount = []\n    float_leg_calc_times_start = []\n    float_leg_calc_times_end = []\n    calc_fixed_leg_cashflows = []\n    calc_fixed_leg_daycount = []\n    fixed_leg_calc_times = []\n    calc_groups_float = []\n    calc_groups_fixed = []\n    last_float_leg_start_time = []\n    last_float_leg_end_time = []\n    last_float_leg_daycount = []\n    last_fixed_leg_end_time = []\n    last_fixed_leg_daycount = []\n    last_fixed_leg_cashflows = []\n    expiry_times = []\n    num_instruments = len(float_leg_start_times)\n    for i in range(num_instruments):\n        calc_float_leg_daycount.append(float_leg_daycount_fractions[i][:-1])\n        float_leg_calc_times_start.append(float_leg_start_times[i][:-1])\n        float_leg_calc_times_end.append(float_leg_end_times[i][:-1])\n        calc_fixed_leg_cashflows.append(fixed_leg_cashflows[i][:-1])\n        calc_fixed_leg_daycount.append(fixed_leg_daycount_fractions[i][:-1])\n        fixed_leg_calc_times.append(fixed_leg_end_times[i][:-1])\n        last_float_leg_start_time.append(float_leg_start_times[i][-1])\n        last_float_leg_end_time.append(float_leg_end_times[i][-1])\n        last_float_leg_daycount.append(float_leg_daycount_fractions[i][-1])\n        last_fixed_leg_end_time.append(fixed_leg_end_times[i][-1])\n        last_fixed_leg_daycount.append(fixed_leg_daycount_fractions[i][-1])\n        last_fixed_leg_cashflows.append(fixed_leg_cashflows[i][-1])\n        expiry_times.append(tf.math.maximum(float_leg_end_times[i][-1], fixed_leg_end_times[i][-1]))\n        calc_groups_float.append(tf.fill(tf.shape(float_leg_start_times[i][:-1]), i))\n        calc_groups_fixed.append(tf.fill(tf.shape(fixed_leg_end_times[i][:-1]), i))\n    output = CurveFittingVars(float_leg_daycount=tf.concat(calc_float_leg_daycount, axis=0), float_leg_times_start=tf.concat(float_leg_calc_times_start, axis=0), float_leg_times_end=tf.concat(float_leg_calc_times_end, axis=0), fixed_leg_cashflows=tf.concat(calc_fixed_leg_cashflows, axis=0), fixed_leg_daycount=tf.concat(calc_fixed_leg_daycount, axis=0), fixed_leg_calc_times=tf.concat(fixed_leg_calc_times, axis=0), settle_times_fixed=None, settle_times_float=None, expiry_times=tf.stack(expiry_times, axis=0), calc_groups_float=tf.concat(calc_groups_float, axis=0), calc_groups_fixed=tf.concat(calc_groups_fixed, axis=0), last_float_leg_start_time=tf.stack(last_float_leg_start_time, axis=0), last_float_leg_end_time=tf.stack(last_float_leg_end_time, axis=0), last_float_leg_daycount=tf.stack(last_float_leg_daycount, axis=0), last_fixed_leg_calc_time=tf.stack(last_fixed_leg_end_time, axis=0), last_fixed_leg_daycount=tf.stack(last_fixed_leg_daycount, axis=0), last_fixed_leg_cashflows=tf.stack(last_fixed_leg_cashflows, axis=0))\n    return output",
            "def _create_curve_building_tensors(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Helper function to create tensors needed for curve construction.'\n    calc_float_leg_daycount = []\n    float_leg_calc_times_start = []\n    float_leg_calc_times_end = []\n    calc_fixed_leg_cashflows = []\n    calc_fixed_leg_daycount = []\n    fixed_leg_calc_times = []\n    calc_groups_float = []\n    calc_groups_fixed = []\n    last_float_leg_start_time = []\n    last_float_leg_end_time = []\n    last_float_leg_daycount = []\n    last_fixed_leg_end_time = []\n    last_fixed_leg_daycount = []\n    last_fixed_leg_cashflows = []\n    expiry_times = []\n    num_instruments = len(float_leg_start_times)\n    for i in range(num_instruments):\n        calc_float_leg_daycount.append(float_leg_daycount_fractions[i][:-1])\n        float_leg_calc_times_start.append(float_leg_start_times[i][:-1])\n        float_leg_calc_times_end.append(float_leg_end_times[i][:-1])\n        calc_fixed_leg_cashflows.append(fixed_leg_cashflows[i][:-1])\n        calc_fixed_leg_daycount.append(fixed_leg_daycount_fractions[i][:-1])\n        fixed_leg_calc_times.append(fixed_leg_end_times[i][:-1])\n        last_float_leg_start_time.append(float_leg_start_times[i][-1])\n        last_float_leg_end_time.append(float_leg_end_times[i][-1])\n        last_float_leg_daycount.append(float_leg_daycount_fractions[i][-1])\n        last_fixed_leg_end_time.append(fixed_leg_end_times[i][-1])\n        last_fixed_leg_daycount.append(fixed_leg_daycount_fractions[i][-1])\n        last_fixed_leg_cashflows.append(fixed_leg_cashflows[i][-1])\n        expiry_times.append(tf.math.maximum(float_leg_end_times[i][-1], fixed_leg_end_times[i][-1]))\n        calc_groups_float.append(tf.fill(tf.shape(float_leg_start_times[i][:-1]), i))\n        calc_groups_fixed.append(tf.fill(tf.shape(fixed_leg_end_times[i][:-1]), i))\n    output = CurveFittingVars(float_leg_daycount=tf.concat(calc_float_leg_daycount, axis=0), float_leg_times_start=tf.concat(float_leg_calc_times_start, axis=0), float_leg_times_end=tf.concat(float_leg_calc_times_end, axis=0), fixed_leg_cashflows=tf.concat(calc_fixed_leg_cashflows, axis=0), fixed_leg_daycount=tf.concat(calc_fixed_leg_daycount, axis=0), fixed_leg_calc_times=tf.concat(fixed_leg_calc_times, axis=0), settle_times_fixed=None, settle_times_float=None, expiry_times=tf.stack(expiry_times, axis=0), calc_groups_float=tf.concat(calc_groups_float, axis=0), calc_groups_fixed=tf.concat(calc_groups_fixed, axis=0), last_float_leg_start_time=tf.stack(last_float_leg_start_time, axis=0), last_float_leg_end_time=tf.stack(last_float_leg_end_time, axis=0), last_float_leg_daycount=tf.stack(last_float_leg_daycount, axis=0), last_fixed_leg_calc_time=tf.stack(last_fixed_leg_end_time, axis=0), last_fixed_leg_daycount=tf.stack(last_fixed_leg_daycount, axis=0), last_fixed_leg_cashflows=tf.stack(last_fixed_leg_cashflows, axis=0))\n    return output",
            "def _create_curve_building_tensors(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Helper function to create tensors needed for curve construction.'\n    calc_float_leg_daycount = []\n    float_leg_calc_times_start = []\n    float_leg_calc_times_end = []\n    calc_fixed_leg_cashflows = []\n    calc_fixed_leg_daycount = []\n    fixed_leg_calc_times = []\n    calc_groups_float = []\n    calc_groups_fixed = []\n    last_float_leg_start_time = []\n    last_float_leg_end_time = []\n    last_float_leg_daycount = []\n    last_fixed_leg_end_time = []\n    last_fixed_leg_daycount = []\n    last_fixed_leg_cashflows = []\n    expiry_times = []\n    num_instruments = len(float_leg_start_times)\n    for i in range(num_instruments):\n        calc_float_leg_daycount.append(float_leg_daycount_fractions[i][:-1])\n        float_leg_calc_times_start.append(float_leg_start_times[i][:-1])\n        float_leg_calc_times_end.append(float_leg_end_times[i][:-1])\n        calc_fixed_leg_cashflows.append(fixed_leg_cashflows[i][:-1])\n        calc_fixed_leg_daycount.append(fixed_leg_daycount_fractions[i][:-1])\n        fixed_leg_calc_times.append(fixed_leg_end_times[i][:-1])\n        last_float_leg_start_time.append(float_leg_start_times[i][-1])\n        last_float_leg_end_time.append(float_leg_end_times[i][-1])\n        last_float_leg_daycount.append(float_leg_daycount_fractions[i][-1])\n        last_fixed_leg_end_time.append(fixed_leg_end_times[i][-1])\n        last_fixed_leg_daycount.append(fixed_leg_daycount_fractions[i][-1])\n        last_fixed_leg_cashflows.append(fixed_leg_cashflows[i][-1])\n        expiry_times.append(tf.math.maximum(float_leg_end_times[i][-1], fixed_leg_end_times[i][-1]))\n        calc_groups_float.append(tf.fill(tf.shape(float_leg_start_times[i][:-1]), i))\n        calc_groups_fixed.append(tf.fill(tf.shape(fixed_leg_end_times[i][:-1]), i))\n    output = CurveFittingVars(float_leg_daycount=tf.concat(calc_float_leg_daycount, axis=0), float_leg_times_start=tf.concat(float_leg_calc_times_start, axis=0), float_leg_times_end=tf.concat(float_leg_calc_times_end, axis=0), fixed_leg_cashflows=tf.concat(calc_fixed_leg_cashflows, axis=0), fixed_leg_daycount=tf.concat(calc_fixed_leg_daycount, axis=0), fixed_leg_calc_times=tf.concat(fixed_leg_calc_times, axis=0), settle_times_fixed=None, settle_times_float=None, expiry_times=tf.stack(expiry_times, axis=0), calc_groups_float=tf.concat(calc_groups_float, axis=0), calc_groups_fixed=tf.concat(calc_groups_fixed, axis=0), last_float_leg_start_time=tf.stack(last_float_leg_start_time, axis=0), last_float_leg_end_time=tf.stack(last_float_leg_end_time, axis=0), last_float_leg_daycount=tf.stack(last_float_leg_daycount, axis=0), last_fixed_leg_calc_time=tf.stack(last_fixed_leg_end_time, axis=0), last_fixed_leg_daycount=tf.stack(last_fixed_leg_daycount, axis=0), last_fixed_leg_cashflows=tf.stack(last_fixed_leg_cashflows, axis=0))\n    return output",
            "def _create_curve_building_tensors(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Helper function to create tensors needed for curve construction.'\n    calc_float_leg_daycount = []\n    float_leg_calc_times_start = []\n    float_leg_calc_times_end = []\n    calc_fixed_leg_cashflows = []\n    calc_fixed_leg_daycount = []\n    fixed_leg_calc_times = []\n    calc_groups_float = []\n    calc_groups_fixed = []\n    last_float_leg_start_time = []\n    last_float_leg_end_time = []\n    last_float_leg_daycount = []\n    last_fixed_leg_end_time = []\n    last_fixed_leg_daycount = []\n    last_fixed_leg_cashflows = []\n    expiry_times = []\n    num_instruments = len(float_leg_start_times)\n    for i in range(num_instruments):\n        calc_float_leg_daycount.append(float_leg_daycount_fractions[i][:-1])\n        float_leg_calc_times_start.append(float_leg_start_times[i][:-1])\n        float_leg_calc_times_end.append(float_leg_end_times[i][:-1])\n        calc_fixed_leg_cashflows.append(fixed_leg_cashflows[i][:-1])\n        calc_fixed_leg_daycount.append(fixed_leg_daycount_fractions[i][:-1])\n        fixed_leg_calc_times.append(fixed_leg_end_times[i][:-1])\n        last_float_leg_start_time.append(float_leg_start_times[i][-1])\n        last_float_leg_end_time.append(float_leg_end_times[i][-1])\n        last_float_leg_daycount.append(float_leg_daycount_fractions[i][-1])\n        last_fixed_leg_end_time.append(fixed_leg_end_times[i][-1])\n        last_fixed_leg_daycount.append(fixed_leg_daycount_fractions[i][-1])\n        last_fixed_leg_cashflows.append(fixed_leg_cashflows[i][-1])\n        expiry_times.append(tf.math.maximum(float_leg_end_times[i][-1], fixed_leg_end_times[i][-1]))\n        calc_groups_float.append(tf.fill(tf.shape(float_leg_start_times[i][:-1]), i))\n        calc_groups_fixed.append(tf.fill(tf.shape(fixed_leg_end_times[i][:-1]), i))\n    output = CurveFittingVars(float_leg_daycount=tf.concat(calc_float_leg_daycount, axis=0), float_leg_times_start=tf.concat(float_leg_calc_times_start, axis=0), float_leg_times_end=tf.concat(float_leg_calc_times_end, axis=0), fixed_leg_cashflows=tf.concat(calc_fixed_leg_cashflows, axis=0), fixed_leg_daycount=tf.concat(calc_fixed_leg_daycount, axis=0), fixed_leg_calc_times=tf.concat(fixed_leg_calc_times, axis=0), settle_times_fixed=None, settle_times_float=None, expiry_times=tf.stack(expiry_times, axis=0), calc_groups_float=tf.concat(calc_groups_float, axis=0), calc_groups_fixed=tf.concat(calc_groups_fixed, axis=0), last_float_leg_start_time=tf.stack(last_float_leg_start_time, axis=0), last_float_leg_end_time=tf.stack(last_float_leg_end_time, axis=0), last_float_leg_daycount=tf.stack(last_float_leg_daycount, axis=0), last_fixed_leg_calc_time=tf.stack(last_fixed_leg_end_time, axis=0), last_fixed_leg_daycount=tf.stack(last_fixed_leg_daycount, axis=0), last_fixed_leg_cashflows=tf.stack(last_fixed_leg_cashflows, axis=0))\n    return output",
            "def _create_curve_building_tensors(float_leg_start_times, float_leg_end_times, float_leg_daycount_fractions, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_daycount_fractions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Helper function to create tensors needed for curve construction.'\n    calc_float_leg_daycount = []\n    float_leg_calc_times_start = []\n    float_leg_calc_times_end = []\n    calc_fixed_leg_cashflows = []\n    calc_fixed_leg_daycount = []\n    fixed_leg_calc_times = []\n    calc_groups_float = []\n    calc_groups_fixed = []\n    last_float_leg_start_time = []\n    last_float_leg_end_time = []\n    last_float_leg_daycount = []\n    last_fixed_leg_end_time = []\n    last_fixed_leg_daycount = []\n    last_fixed_leg_cashflows = []\n    expiry_times = []\n    num_instruments = len(float_leg_start_times)\n    for i in range(num_instruments):\n        calc_float_leg_daycount.append(float_leg_daycount_fractions[i][:-1])\n        float_leg_calc_times_start.append(float_leg_start_times[i][:-1])\n        float_leg_calc_times_end.append(float_leg_end_times[i][:-1])\n        calc_fixed_leg_cashflows.append(fixed_leg_cashflows[i][:-1])\n        calc_fixed_leg_daycount.append(fixed_leg_daycount_fractions[i][:-1])\n        fixed_leg_calc_times.append(fixed_leg_end_times[i][:-1])\n        last_float_leg_start_time.append(float_leg_start_times[i][-1])\n        last_float_leg_end_time.append(float_leg_end_times[i][-1])\n        last_float_leg_daycount.append(float_leg_daycount_fractions[i][-1])\n        last_fixed_leg_end_time.append(fixed_leg_end_times[i][-1])\n        last_fixed_leg_daycount.append(fixed_leg_daycount_fractions[i][-1])\n        last_fixed_leg_cashflows.append(fixed_leg_cashflows[i][-1])\n        expiry_times.append(tf.math.maximum(float_leg_end_times[i][-1], fixed_leg_end_times[i][-1]))\n        calc_groups_float.append(tf.fill(tf.shape(float_leg_start_times[i][:-1]), i))\n        calc_groups_fixed.append(tf.fill(tf.shape(fixed_leg_end_times[i][:-1]), i))\n    output = CurveFittingVars(float_leg_daycount=tf.concat(calc_float_leg_daycount, axis=0), float_leg_times_start=tf.concat(float_leg_calc_times_start, axis=0), float_leg_times_end=tf.concat(float_leg_calc_times_end, axis=0), fixed_leg_cashflows=tf.concat(calc_fixed_leg_cashflows, axis=0), fixed_leg_daycount=tf.concat(calc_fixed_leg_daycount, axis=0), fixed_leg_calc_times=tf.concat(fixed_leg_calc_times, axis=0), settle_times_fixed=None, settle_times_float=None, expiry_times=tf.stack(expiry_times, axis=0), calc_groups_float=tf.concat(calc_groups_float, axis=0), calc_groups_fixed=tf.concat(calc_groups_fixed, axis=0), last_float_leg_start_time=tf.stack(last_float_leg_start_time, axis=0), last_float_leg_end_time=tf.stack(last_float_leg_end_time, axis=0), last_float_leg_daycount=tf.stack(last_float_leg_daycount, axis=0), last_fixed_leg_calc_time=tf.stack(last_fixed_leg_end_time, axis=0), last_fixed_leg_daycount=tf.stack(last_fixed_leg_daycount, axis=0), last_fixed_leg_cashflows=tf.stack(last_fixed_leg_cashflows, axis=0))\n    return output"
        ]
    }
]