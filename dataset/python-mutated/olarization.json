[
    {
        "func_name": "jones_vector",
        "original": "def jones_vector(psi, chi):\n    \"\"\"A Jones vector corresponding to a polarization ellipse with `psi` tilt,\n    and `chi` circularity.\n\n    Parameters\n    ==========\n\n    psi : numeric type or SymPy Symbol\n        The tilt of the polarization relative to the `x` axis.\n\n    chi : numeric type or SymPy Symbol\n        The angle adjacent to the mayor axis of the polarization ellipse.\n\n\n    Returns\n    =======\n\n    Matrix :\n        A Jones vector.\n\n    Examples\n    ========\n\n    The axes on the Poincar\u00e9 sphere.\n\n    >>> from sympy import pprint, symbols, pi\n    >>> from sympy.physics.optics.polarization import jones_vector\n    >>> psi, chi = symbols(\"psi, chi\", real=True)\n\n    A general Jones vector.\n\n    >>> pprint(jones_vector(psi, chi), use_unicode=True)\n    \u23a1-\u2148\u22c5sin(\u03c7)\u22c5sin(\u03c8) + cos(\u03c7)\u22c5cos(\u03c8)\u23a4\n    \u23a2                                \u23a5\n    \u23a3\u2148\u22c5sin(\u03c7)\u22c5cos(\u03c8) + sin(\u03c8)\u22c5cos(\u03c7) \u23a6\n\n    Horizontal polarization.\n\n    >>> pprint(jones_vector(0, 0), use_unicode=True)\n    \u23a11\u23a4\n    \u23a2 \u23a5\n    \u23a30\u23a6\n\n    Vertical polarization.\n\n    >>> pprint(jones_vector(pi/2, 0), use_unicode=True)\n    \u23a10\u23a4\n    \u23a2 \u23a5\n    \u23a31\u23a6\n\n    Diagonal polarization.\n\n    >>> pprint(jones_vector(pi/4, 0), use_unicode=True)\n    \u23a1\u221a2\u23a4\n    \u23a2\u2500\u2500\u23a5\n    \u23a22 \u23a5\n    \u23a2  \u23a5\n    \u23a2\u221a2\u23a5\n    \u23a2\u2500\u2500\u23a5\n    \u23a32 \u23a6\n\n    Anti-diagonal polarization.\n\n    >>> pprint(jones_vector(-pi/4, 0), use_unicode=True)\n    \u23a1 \u221a2 \u23a4\n    \u23a2 \u2500\u2500 \u23a5\n    \u23a2 2  \u23a5\n    \u23a2    \u23a5\n    \u23a2-\u221a2 \u23a5\n    \u23a2\u2500\u2500\u2500\u2500\u23a5\n    \u23a3 2  \u23a6\n\n    Right-hand circular polarization.\n\n    >>> pprint(jones_vector(0, pi/4), use_unicode=True)\n    \u23a1 \u221a2 \u23a4\n    \u23a2 \u2500\u2500 \u23a5\n    \u23a2 2  \u23a5\n    \u23a2    \u23a5\n    \u23a2\u221a2\u22c5\u2148\u23a5\n    \u23a2\u2500\u2500\u2500\u2500\u23a5\n    \u23a3 2  \u23a6\n\n    Left-hand circular polarization.\n\n    >>> pprint(jones_vector(0, -pi/4), use_unicode=True)\n    \u23a1  \u221a2  \u23a4\n    \u23a2  \u2500\u2500  \u23a5\n    \u23a2  2   \u23a5\n    \u23a2      \u23a5\n    \u23a2-\u221a2\u22c5\u2148 \u23a5\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u23a5\n    \u23a3  2   \u23a6\n\n    \"\"\"\n    return Matrix([-I * sin(chi) * sin(psi) + cos(chi) * cos(psi), I * sin(chi) * cos(psi) + sin(psi) * cos(chi)])",
        "mutated": [
            "def jones_vector(psi, chi):\n    if False:\n        i = 10\n    'A Jones vector corresponding to a polarization ellipse with `psi` tilt,\\n    and `chi` circularity.\\n\\n    Parameters\\n    ==========\\n\\n    psi : numeric type or SymPy Symbol\\n        The tilt of the polarization relative to the `x` axis.\\n\\n    chi : numeric type or SymPy Symbol\\n        The angle adjacent to the mayor axis of the polarization ellipse.\\n\\n\\n    Returns\\n    =======\\n\\n    Matrix :\\n        A Jones vector.\\n\\n    Examples\\n    ========\\n\\n    The axes on the Poincar\u00e9 sphere.\\n\\n    >>> from sympy import pprint, symbols, pi\\n    >>> from sympy.physics.optics.polarization import jones_vector\\n    >>> psi, chi = symbols(\"psi, chi\", real=True)\\n\\n    A general Jones vector.\\n\\n    >>> pprint(jones_vector(psi, chi), use_unicode=True)\\n    \u23a1-\u2148\u22c5sin(\u03c7)\u22c5sin(\u03c8) + cos(\u03c7)\u22c5cos(\u03c8)\u23a4\\n    \u23a2                                \u23a5\\n    \u23a3\u2148\u22c5sin(\u03c7)\u22c5cos(\u03c8) + sin(\u03c8)\u22c5cos(\u03c7) \u23a6\\n\\n    Horizontal polarization.\\n\\n    >>> pprint(jones_vector(0, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    Vertical polarization.\\n\\n    >>> pprint(jones_vector(pi/2, 0), use_unicode=True)\\n    \u23a10\u23a4\\n    \u23a2 \u23a5\\n    \u23a31\u23a6\\n\\n    Diagonal polarization.\\n\\n    >>> pprint(jones_vector(pi/4, 0), use_unicode=True)\\n    \u23a1\u221a2\u23a4\\n    \u23a2\u2500\u2500\u23a5\\n    \u23a22 \u23a5\\n    \u23a2  \u23a5\\n    \u23a2\u221a2\u23a5\\n    \u23a2\u2500\u2500\u23a5\\n    \u23a32 \u23a6\\n\\n    Anti-diagonal polarization.\\n\\n    >>> pprint(jones_vector(-pi/4, 0), use_unicode=True)\\n    \u23a1 \u221a2 \u23a4\\n    \u23a2 \u2500\u2500 \u23a5\\n    \u23a2 2  \u23a5\\n    \u23a2    \u23a5\\n    \u23a2-\u221a2 \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u23a5\\n    \u23a3 2  \u23a6\\n\\n    Right-hand circular polarization.\\n\\n    >>> pprint(jones_vector(0, pi/4), use_unicode=True)\\n    \u23a1 \u221a2 \u23a4\\n    \u23a2 \u2500\u2500 \u23a5\\n    \u23a2 2  \u23a5\\n    \u23a2    \u23a5\\n    \u23a2\u221a2\u22c5\u2148\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u23a5\\n    \u23a3 2  \u23a6\\n\\n    Left-hand circular polarization.\\n\\n    >>> pprint(jones_vector(0, -pi/4), use_unicode=True)\\n    \u23a1  \u221a2  \u23a4\\n    \u23a2  \u2500\u2500  \u23a5\\n    \u23a2  2   \u23a5\\n    \u23a2      \u23a5\\n    \u23a2-\u221a2\u22c5\u2148 \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u23a5\\n    \u23a3  2   \u23a6\\n\\n    '\n    return Matrix([-I * sin(chi) * sin(psi) + cos(chi) * cos(psi), I * sin(chi) * cos(psi) + sin(psi) * cos(chi)])",
            "def jones_vector(psi, chi):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A Jones vector corresponding to a polarization ellipse with `psi` tilt,\\n    and `chi` circularity.\\n\\n    Parameters\\n    ==========\\n\\n    psi : numeric type or SymPy Symbol\\n        The tilt of the polarization relative to the `x` axis.\\n\\n    chi : numeric type or SymPy Symbol\\n        The angle adjacent to the mayor axis of the polarization ellipse.\\n\\n\\n    Returns\\n    =======\\n\\n    Matrix :\\n        A Jones vector.\\n\\n    Examples\\n    ========\\n\\n    The axes on the Poincar\u00e9 sphere.\\n\\n    >>> from sympy import pprint, symbols, pi\\n    >>> from sympy.physics.optics.polarization import jones_vector\\n    >>> psi, chi = symbols(\"psi, chi\", real=True)\\n\\n    A general Jones vector.\\n\\n    >>> pprint(jones_vector(psi, chi), use_unicode=True)\\n    \u23a1-\u2148\u22c5sin(\u03c7)\u22c5sin(\u03c8) + cos(\u03c7)\u22c5cos(\u03c8)\u23a4\\n    \u23a2                                \u23a5\\n    \u23a3\u2148\u22c5sin(\u03c7)\u22c5cos(\u03c8) + sin(\u03c8)\u22c5cos(\u03c7) \u23a6\\n\\n    Horizontal polarization.\\n\\n    >>> pprint(jones_vector(0, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    Vertical polarization.\\n\\n    >>> pprint(jones_vector(pi/2, 0), use_unicode=True)\\n    \u23a10\u23a4\\n    \u23a2 \u23a5\\n    \u23a31\u23a6\\n\\n    Diagonal polarization.\\n\\n    >>> pprint(jones_vector(pi/4, 0), use_unicode=True)\\n    \u23a1\u221a2\u23a4\\n    \u23a2\u2500\u2500\u23a5\\n    \u23a22 \u23a5\\n    \u23a2  \u23a5\\n    \u23a2\u221a2\u23a5\\n    \u23a2\u2500\u2500\u23a5\\n    \u23a32 \u23a6\\n\\n    Anti-diagonal polarization.\\n\\n    >>> pprint(jones_vector(-pi/4, 0), use_unicode=True)\\n    \u23a1 \u221a2 \u23a4\\n    \u23a2 \u2500\u2500 \u23a5\\n    \u23a2 2  \u23a5\\n    \u23a2    \u23a5\\n    \u23a2-\u221a2 \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u23a5\\n    \u23a3 2  \u23a6\\n\\n    Right-hand circular polarization.\\n\\n    >>> pprint(jones_vector(0, pi/4), use_unicode=True)\\n    \u23a1 \u221a2 \u23a4\\n    \u23a2 \u2500\u2500 \u23a5\\n    \u23a2 2  \u23a5\\n    \u23a2    \u23a5\\n    \u23a2\u221a2\u22c5\u2148\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u23a5\\n    \u23a3 2  \u23a6\\n\\n    Left-hand circular polarization.\\n\\n    >>> pprint(jones_vector(0, -pi/4), use_unicode=True)\\n    \u23a1  \u221a2  \u23a4\\n    \u23a2  \u2500\u2500  \u23a5\\n    \u23a2  2   \u23a5\\n    \u23a2      \u23a5\\n    \u23a2-\u221a2\u22c5\u2148 \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u23a5\\n    \u23a3  2   \u23a6\\n\\n    '\n    return Matrix([-I * sin(chi) * sin(psi) + cos(chi) * cos(psi), I * sin(chi) * cos(psi) + sin(psi) * cos(chi)])",
            "def jones_vector(psi, chi):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A Jones vector corresponding to a polarization ellipse with `psi` tilt,\\n    and `chi` circularity.\\n\\n    Parameters\\n    ==========\\n\\n    psi : numeric type or SymPy Symbol\\n        The tilt of the polarization relative to the `x` axis.\\n\\n    chi : numeric type or SymPy Symbol\\n        The angle adjacent to the mayor axis of the polarization ellipse.\\n\\n\\n    Returns\\n    =======\\n\\n    Matrix :\\n        A Jones vector.\\n\\n    Examples\\n    ========\\n\\n    The axes on the Poincar\u00e9 sphere.\\n\\n    >>> from sympy import pprint, symbols, pi\\n    >>> from sympy.physics.optics.polarization import jones_vector\\n    >>> psi, chi = symbols(\"psi, chi\", real=True)\\n\\n    A general Jones vector.\\n\\n    >>> pprint(jones_vector(psi, chi), use_unicode=True)\\n    \u23a1-\u2148\u22c5sin(\u03c7)\u22c5sin(\u03c8) + cos(\u03c7)\u22c5cos(\u03c8)\u23a4\\n    \u23a2                                \u23a5\\n    \u23a3\u2148\u22c5sin(\u03c7)\u22c5cos(\u03c8) + sin(\u03c8)\u22c5cos(\u03c7) \u23a6\\n\\n    Horizontal polarization.\\n\\n    >>> pprint(jones_vector(0, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    Vertical polarization.\\n\\n    >>> pprint(jones_vector(pi/2, 0), use_unicode=True)\\n    \u23a10\u23a4\\n    \u23a2 \u23a5\\n    \u23a31\u23a6\\n\\n    Diagonal polarization.\\n\\n    >>> pprint(jones_vector(pi/4, 0), use_unicode=True)\\n    \u23a1\u221a2\u23a4\\n    \u23a2\u2500\u2500\u23a5\\n    \u23a22 \u23a5\\n    \u23a2  \u23a5\\n    \u23a2\u221a2\u23a5\\n    \u23a2\u2500\u2500\u23a5\\n    \u23a32 \u23a6\\n\\n    Anti-diagonal polarization.\\n\\n    >>> pprint(jones_vector(-pi/4, 0), use_unicode=True)\\n    \u23a1 \u221a2 \u23a4\\n    \u23a2 \u2500\u2500 \u23a5\\n    \u23a2 2  \u23a5\\n    \u23a2    \u23a5\\n    \u23a2-\u221a2 \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u23a5\\n    \u23a3 2  \u23a6\\n\\n    Right-hand circular polarization.\\n\\n    >>> pprint(jones_vector(0, pi/4), use_unicode=True)\\n    \u23a1 \u221a2 \u23a4\\n    \u23a2 \u2500\u2500 \u23a5\\n    \u23a2 2  \u23a5\\n    \u23a2    \u23a5\\n    \u23a2\u221a2\u22c5\u2148\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u23a5\\n    \u23a3 2  \u23a6\\n\\n    Left-hand circular polarization.\\n\\n    >>> pprint(jones_vector(0, -pi/4), use_unicode=True)\\n    \u23a1  \u221a2  \u23a4\\n    \u23a2  \u2500\u2500  \u23a5\\n    \u23a2  2   \u23a5\\n    \u23a2      \u23a5\\n    \u23a2-\u221a2\u22c5\u2148 \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u23a5\\n    \u23a3  2   \u23a6\\n\\n    '\n    return Matrix([-I * sin(chi) * sin(psi) + cos(chi) * cos(psi), I * sin(chi) * cos(psi) + sin(psi) * cos(chi)])",
            "def jones_vector(psi, chi):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A Jones vector corresponding to a polarization ellipse with `psi` tilt,\\n    and `chi` circularity.\\n\\n    Parameters\\n    ==========\\n\\n    psi : numeric type or SymPy Symbol\\n        The tilt of the polarization relative to the `x` axis.\\n\\n    chi : numeric type or SymPy Symbol\\n        The angle adjacent to the mayor axis of the polarization ellipse.\\n\\n\\n    Returns\\n    =======\\n\\n    Matrix :\\n        A Jones vector.\\n\\n    Examples\\n    ========\\n\\n    The axes on the Poincar\u00e9 sphere.\\n\\n    >>> from sympy import pprint, symbols, pi\\n    >>> from sympy.physics.optics.polarization import jones_vector\\n    >>> psi, chi = symbols(\"psi, chi\", real=True)\\n\\n    A general Jones vector.\\n\\n    >>> pprint(jones_vector(psi, chi), use_unicode=True)\\n    \u23a1-\u2148\u22c5sin(\u03c7)\u22c5sin(\u03c8) + cos(\u03c7)\u22c5cos(\u03c8)\u23a4\\n    \u23a2                                \u23a5\\n    \u23a3\u2148\u22c5sin(\u03c7)\u22c5cos(\u03c8) + sin(\u03c8)\u22c5cos(\u03c7) \u23a6\\n\\n    Horizontal polarization.\\n\\n    >>> pprint(jones_vector(0, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    Vertical polarization.\\n\\n    >>> pprint(jones_vector(pi/2, 0), use_unicode=True)\\n    \u23a10\u23a4\\n    \u23a2 \u23a5\\n    \u23a31\u23a6\\n\\n    Diagonal polarization.\\n\\n    >>> pprint(jones_vector(pi/4, 0), use_unicode=True)\\n    \u23a1\u221a2\u23a4\\n    \u23a2\u2500\u2500\u23a5\\n    \u23a22 \u23a5\\n    \u23a2  \u23a5\\n    \u23a2\u221a2\u23a5\\n    \u23a2\u2500\u2500\u23a5\\n    \u23a32 \u23a6\\n\\n    Anti-diagonal polarization.\\n\\n    >>> pprint(jones_vector(-pi/4, 0), use_unicode=True)\\n    \u23a1 \u221a2 \u23a4\\n    \u23a2 \u2500\u2500 \u23a5\\n    \u23a2 2  \u23a5\\n    \u23a2    \u23a5\\n    \u23a2-\u221a2 \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u23a5\\n    \u23a3 2  \u23a6\\n\\n    Right-hand circular polarization.\\n\\n    >>> pprint(jones_vector(0, pi/4), use_unicode=True)\\n    \u23a1 \u221a2 \u23a4\\n    \u23a2 \u2500\u2500 \u23a5\\n    \u23a2 2  \u23a5\\n    \u23a2    \u23a5\\n    \u23a2\u221a2\u22c5\u2148\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u23a5\\n    \u23a3 2  \u23a6\\n\\n    Left-hand circular polarization.\\n\\n    >>> pprint(jones_vector(0, -pi/4), use_unicode=True)\\n    \u23a1  \u221a2  \u23a4\\n    \u23a2  \u2500\u2500  \u23a5\\n    \u23a2  2   \u23a5\\n    \u23a2      \u23a5\\n    \u23a2-\u221a2\u22c5\u2148 \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u23a5\\n    \u23a3  2   \u23a6\\n\\n    '\n    return Matrix([-I * sin(chi) * sin(psi) + cos(chi) * cos(psi), I * sin(chi) * cos(psi) + sin(psi) * cos(chi)])",
            "def jones_vector(psi, chi):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A Jones vector corresponding to a polarization ellipse with `psi` tilt,\\n    and `chi` circularity.\\n\\n    Parameters\\n    ==========\\n\\n    psi : numeric type or SymPy Symbol\\n        The tilt of the polarization relative to the `x` axis.\\n\\n    chi : numeric type or SymPy Symbol\\n        The angle adjacent to the mayor axis of the polarization ellipse.\\n\\n\\n    Returns\\n    =======\\n\\n    Matrix :\\n        A Jones vector.\\n\\n    Examples\\n    ========\\n\\n    The axes on the Poincar\u00e9 sphere.\\n\\n    >>> from sympy import pprint, symbols, pi\\n    >>> from sympy.physics.optics.polarization import jones_vector\\n    >>> psi, chi = symbols(\"psi, chi\", real=True)\\n\\n    A general Jones vector.\\n\\n    >>> pprint(jones_vector(psi, chi), use_unicode=True)\\n    \u23a1-\u2148\u22c5sin(\u03c7)\u22c5sin(\u03c8) + cos(\u03c7)\u22c5cos(\u03c8)\u23a4\\n    \u23a2                                \u23a5\\n    \u23a3\u2148\u22c5sin(\u03c7)\u22c5cos(\u03c8) + sin(\u03c8)\u22c5cos(\u03c7) \u23a6\\n\\n    Horizontal polarization.\\n\\n    >>> pprint(jones_vector(0, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    Vertical polarization.\\n\\n    >>> pprint(jones_vector(pi/2, 0), use_unicode=True)\\n    \u23a10\u23a4\\n    \u23a2 \u23a5\\n    \u23a31\u23a6\\n\\n    Diagonal polarization.\\n\\n    >>> pprint(jones_vector(pi/4, 0), use_unicode=True)\\n    \u23a1\u221a2\u23a4\\n    \u23a2\u2500\u2500\u23a5\\n    \u23a22 \u23a5\\n    \u23a2  \u23a5\\n    \u23a2\u221a2\u23a5\\n    \u23a2\u2500\u2500\u23a5\\n    \u23a32 \u23a6\\n\\n    Anti-diagonal polarization.\\n\\n    >>> pprint(jones_vector(-pi/4, 0), use_unicode=True)\\n    \u23a1 \u221a2 \u23a4\\n    \u23a2 \u2500\u2500 \u23a5\\n    \u23a2 2  \u23a5\\n    \u23a2    \u23a5\\n    \u23a2-\u221a2 \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u23a5\\n    \u23a3 2  \u23a6\\n\\n    Right-hand circular polarization.\\n\\n    >>> pprint(jones_vector(0, pi/4), use_unicode=True)\\n    \u23a1 \u221a2 \u23a4\\n    \u23a2 \u2500\u2500 \u23a5\\n    \u23a2 2  \u23a5\\n    \u23a2    \u23a5\\n    \u23a2\u221a2\u22c5\u2148\u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u23a5\\n    \u23a3 2  \u23a6\\n\\n    Left-hand circular polarization.\\n\\n    >>> pprint(jones_vector(0, -pi/4), use_unicode=True)\\n    \u23a1  \u221a2  \u23a4\\n    \u23a2  \u2500\u2500  \u23a5\\n    \u23a2  2   \u23a5\\n    \u23a2      \u23a5\\n    \u23a2-\u221a2\u22c5\u2148 \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u23a5\\n    \u23a3  2   \u23a6\\n\\n    '\n    return Matrix([-I * sin(chi) * sin(psi) + cos(chi) * cos(psi), I * sin(chi) * cos(psi) + sin(psi) * cos(chi)])"
        ]
    },
    {
        "func_name": "stokes_vector",
        "original": "def stokes_vector(psi, chi, p=1, I=1):\n    \"\"\"A Stokes vector corresponding to a polarization ellipse with ``psi``\n    tilt, and ``chi`` circularity.\n\n    Parameters\n    ==========\n\n    psi : numeric type or SymPy Symbol\n        The tilt of the polarization relative to the ``x`` axis.\n    chi : numeric type or SymPy Symbol\n        The angle adjacent to the mayor axis of the polarization ellipse.\n    p : numeric type or SymPy Symbol\n        The degree of polarization.\n    I : numeric type or SymPy Symbol\n        The intensity of the field.\n\n\n    Returns\n    =======\n\n    Matrix :\n        A Stokes vector.\n\n    Examples\n    ========\n\n    The axes on the Poincar\u00e9 sphere.\n\n    >>> from sympy import pprint, symbols, pi\n    >>> from sympy.physics.optics.polarization import stokes_vector\n    >>> psi, chi, p, I = symbols(\"psi, chi, p, I\", real=True)\n    >>> pprint(stokes_vector(psi, chi, p, I), use_unicode=True)\n    \u23a1          I          \u23a4\n    \u23a2                     \u23a5\n    \u23a2I\u22c5p\u22c5cos(2\u22c5\u03c7)\u22c5cos(2\u22c5\u03c8)\u23a5\n    \u23a2                     \u23a5\n    \u23a2I\u22c5p\u22c5sin(2\u22c5\u03c8)\u22c5cos(2\u22c5\u03c7)\u23a5\n    \u23a2                     \u23a5\n    \u23a3    I\u22c5p\u22c5sin(2\u22c5\u03c7)     \u23a6\n\n\n    Horizontal polarization\n\n    >>> pprint(stokes_vector(0, 0), use_unicode=True)\n    \u23a11\u23a4\n    \u23a2 \u23a5\n    \u23a21\u23a5\n    \u23a2 \u23a5\n    \u23a20\u23a5\n    \u23a2 \u23a5\n    \u23a30\u23a6\n\n    Vertical polarization\n\n    >>> pprint(stokes_vector(pi/2, 0), use_unicode=True)\n    \u23a11 \u23a4\n    \u23a2  \u23a5\n    \u23a2-1\u23a5\n    \u23a2  \u23a5\n    \u23a20 \u23a5\n    \u23a2  \u23a5\n    \u23a30 \u23a6\n\n    Diagonal polarization\n\n    >>> pprint(stokes_vector(pi/4, 0), use_unicode=True)\n    \u23a11\u23a4\n    \u23a2 \u23a5\n    \u23a20\u23a5\n    \u23a2 \u23a5\n    \u23a21\u23a5\n    \u23a2 \u23a5\n    \u23a30\u23a6\n\n    Anti-diagonal polarization\n\n    >>> pprint(stokes_vector(-pi/4, 0), use_unicode=True)\n    \u23a11 \u23a4\n    \u23a2  \u23a5\n    \u23a20 \u23a5\n    \u23a2  \u23a5\n    \u23a2-1\u23a5\n    \u23a2  \u23a5\n    \u23a30 \u23a6\n\n    Right-hand circular polarization\n\n    >>> pprint(stokes_vector(0, pi/4), use_unicode=True)\n    \u23a11\u23a4\n    \u23a2 \u23a5\n    \u23a20\u23a5\n    \u23a2 \u23a5\n    \u23a20\u23a5\n    \u23a2 \u23a5\n    \u23a31\u23a6\n\n    Left-hand circular polarization\n\n    >>> pprint(stokes_vector(0, -pi/4), use_unicode=True)\n    \u23a11 \u23a4\n    \u23a2  \u23a5\n    \u23a20 \u23a5\n    \u23a2  \u23a5\n    \u23a20 \u23a5\n    \u23a2  \u23a5\n    \u23a3-1\u23a6\n\n    Unpolarized light\n\n    >>> pprint(stokes_vector(0, 0, 0), use_unicode=True)\n    \u23a11\u23a4\n    \u23a2 \u23a5\n    \u23a20\u23a5\n    \u23a2 \u23a5\n    \u23a20\u23a5\n    \u23a2 \u23a5\n    \u23a30\u23a6\n\n    \"\"\"\n    S0 = I\n    S1 = I * p * cos(2 * psi) * cos(2 * chi)\n    S2 = I * p * sin(2 * psi) * cos(2 * chi)\n    S3 = I * p * sin(2 * chi)\n    return Matrix([S0, S1, S2, S3])",
        "mutated": [
            "def stokes_vector(psi, chi, p=1, I=1):\n    if False:\n        i = 10\n    'A Stokes vector corresponding to a polarization ellipse with ``psi``\\n    tilt, and ``chi`` circularity.\\n\\n    Parameters\\n    ==========\\n\\n    psi : numeric type or SymPy Symbol\\n        The tilt of the polarization relative to the ``x`` axis.\\n    chi : numeric type or SymPy Symbol\\n        The angle adjacent to the mayor axis of the polarization ellipse.\\n    p : numeric type or SymPy Symbol\\n        The degree of polarization.\\n    I : numeric type or SymPy Symbol\\n        The intensity of the field.\\n\\n\\n    Returns\\n    =======\\n\\n    Matrix :\\n        A Stokes vector.\\n\\n    Examples\\n    ========\\n\\n    The axes on the Poincar\u00e9 sphere.\\n\\n    >>> from sympy import pprint, symbols, pi\\n    >>> from sympy.physics.optics.polarization import stokes_vector\\n    >>> psi, chi, p, I = symbols(\"psi, chi, p, I\", real=True)\\n    >>> pprint(stokes_vector(psi, chi, p, I), use_unicode=True)\\n    \u23a1          I          \u23a4\\n    \u23a2                     \u23a5\\n    \u23a2I\u22c5p\u22c5cos(2\u22c5\u03c7)\u22c5cos(2\u22c5\u03c8)\u23a5\\n    \u23a2                     \u23a5\\n    \u23a2I\u22c5p\u22c5sin(2\u22c5\u03c8)\u22c5cos(2\u22c5\u03c7)\u23a5\\n    \u23a2                     \u23a5\\n    \u23a3    I\u22c5p\u22c5sin(2\u22c5\u03c7)     \u23a6\\n\\n\\n    Horizontal polarization\\n\\n    >>> pprint(stokes_vector(0, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a21\u23a5\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    Vertical polarization\\n\\n    >>> pprint(stokes_vector(pi/2, 0), use_unicode=True)\\n    \u23a11 \u23a4\\n    \u23a2  \u23a5\\n    \u23a2-1\u23a5\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a30 \u23a6\\n\\n    Diagonal polarization\\n\\n    >>> pprint(stokes_vector(pi/4, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a21\u23a5\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    Anti-diagonal polarization\\n\\n    >>> pprint(stokes_vector(-pi/4, 0), use_unicode=True)\\n    \u23a11 \u23a4\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a2-1\u23a5\\n    \u23a2  \u23a5\\n    \u23a30 \u23a6\\n\\n    Right-hand circular polarization\\n\\n    >>> pprint(stokes_vector(0, pi/4), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a31\u23a6\\n\\n    Left-hand circular polarization\\n\\n    >>> pprint(stokes_vector(0, -pi/4), use_unicode=True)\\n    \u23a11 \u23a4\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a3-1\u23a6\\n\\n    Unpolarized light\\n\\n    >>> pprint(stokes_vector(0, 0, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    '\n    S0 = I\n    S1 = I * p * cos(2 * psi) * cos(2 * chi)\n    S2 = I * p * sin(2 * psi) * cos(2 * chi)\n    S3 = I * p * sin(2 * chi)\n    return Matrix([S0, S1, S2, S3])",
            "def stokes_vector(psi, chi, p=1, I=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A Stokes vector corresponding to a polarization ellipse with ``psi``\\n    tilt, and ``chi`` circularity.\\n\\n    Parameters\\n    ==========\\n\\n    psi : numeric type or SymPy Symbol\\n        The tilt of the polarization relative to the ``x`` axis.\\n    chi : numeric type or SymPy Symbol\\n        The angle adjacent to the mayor axis of the polarization ellipse.\\n    p : numeric type or SymPy Symbol\\n        The degree of polarization.\\n    I : numeric type or SymPy Symbol\\n        The intensity of the field.\\n\\n\\n    Returns\\n    =======\\n\\n    Matrix :\\n        A Stokes vector.\\n\\n    Examples\\n    ========\\n\\n    The axes on the Poincar\u00e9 sphere.\\n\\n    >>> from sympy import pprint, symbols, pi\\n    >>> from sympy.physics.optics.polarization import stokes_vector\\n    >>> psi, chi, p, I = symbols(\"psi, chi, p, I\", real=True)\\n    >>> pprint(stokes_vector(psi, chi, p, I), use_unicode=True)\\n    \u23a1          I          \u23a4\\n    \u23a2                     \u23a5\\n    \u23a2I\u22c5p\u22c5cos(2\u22c5\u03c7)\u22c5cos(2\u22c5\u03c8)\u23a5\\n    \u23a2                     \u23a5\\n    \u23a2I\u22c5p\u22c5sin(2\u22c5\u03c8)\u22c5cos(2\u22c5\u03c7)\u23a5\\n    \u23a2                     \u23a5\\n    \u23a3    I\u22c5p\u22c5sin(2\u22c5\u03c7)     \u23a6\\n\\n\\n    Horizontal polarization\\n\\n    >>> pprint(stokes_vector(0, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a21\u23a5\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    Vertical polarization\\n\\n    >>> pprint(stokes_vector(pi/2, 0), use_unicode=True)\\n    \u23a11 \u23a4\\n    \u23a2  \u23a5\\n    \u23a2-1\u23a5\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a30 \u23a6\\n\\n    Diagonal polarization\\n\\n    >>> pprint(stokes_vector(pi/4, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a21\u23a5\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    Anti-diagonal polarization\\n\\n    >>> pprint(stokes_vector(-pi/4, 0), use_unicode=True)\\n    \u23a11 \u23a4\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a2-1\u23a5\\n    \u23a2  \u23a5\\n    \u23a30 \u23a6\\n\\n    Right-hand circular polarization\\n\\n    >>> pprint(stokes_vector(0, pi/4), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a31\u23a6\\n\\n    Left-hand circular polarization\\n\\n    >>> pprint(stokes_vector(0, -pi/4), use_unicode=True)\\n    \u23a11 \u23a4\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a3-1\u23a6\\n\\n    Unpolarized light\\n\\n    >>> pprint(stokes_vector(0, 0, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    '\n    S0 = I\n    S1 = I * p * cos(2 * psi) * cos(2 * chi)\n    S2 = I * p * sin(2 * psi) * cos(2 * chi)\n    S3 = I * p * sin(2 * chi)\n    return Matrix([S0, S1, S2, S3])",
            "def stokes_vector(psi, chi, p=1, I=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A Stokes vector corresponding to a polarization ellipse with ``psi``\\n    tilt, and ``chi`` circularity.\\n\\n    Parameters\\n    ==========\\n\\n    psi : numeric type or SymPy Symbol\\n        The tilt of the polarization relative to the ``x`` axis.\\n    chi : numeric type or SymPy Symbol\\n        The angle adjacent to the mayor axis of the polarization ellipse.\\n    p : numeric type or SymPy Symbol\\n        The degree of polarization.\\n    I : numeric type or SymPy Symbol\\n        The intensity of the field.\\n\\n\\n    Returns\\n    =======\\n\\n    Matrix :\\n        A Stokes vector.\\n\\n    Examples\\n    ========\\n\\n    The axes on the Poincar\u00e9 sphere.\\n\\n    >>> from sympy import pprint, symbols, pi\\n    >>> from sympy.physics.optics.polarization import stokes_vector\\n    >>> psi, chi, p, I = symbols(\"psi, chi, p, I\", real=True)\\n    >>> pprint(stokes_vector(psi, chi, p, I), use_unicode=True)\\n    \u23a1          I          \u23a4\\n    \u23a2                     \u23a5\\n    \u23a2I\u22c5p\u22c5cos(2\u22c5\u03c7)\u22c5cos(2\u22c5\u03c8)\u23a5\\n    \u23a2                     \u23a5\\n    \u23a2I\u22c5p\u22c5sin(2\u22c5\u03c8)\u22c5cos(2\u22c5\u03c7)\u23a5\\n    \u23a2                     \u23a5\\n    \u23a3    I\u22c5p\u22c5sin(2\u22c5\u03c7)     \u23a6\\n\\n\\n    Horizontal polarization\\n\\n    >>> pprint(stokes_vector(0, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a21\u23a5\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    Vertical polarization\\n\\n    >>> pprint(stokes_vector(pi/2, 0), use_unicode=True)\\n    \u23a11 \u23a4\\n    \u23a2  \u23a5\\n    \u23a2-1\u23a5\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a30 \u23a6\\n\\n    Diagonal polarization\\n\\n    >>> pprint(stokes_vector(pi/4, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a21\u23a5\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    Anti-diagonal polarization\\n\\n    >>> pprint(stokes_vector(-pi/4, 0), use_unicode=True)\\n    \u23a11 \u23a4\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a2-1\u23a5\\n    \u23a2  \u23a5\\n    \u23a30 \u23a6\\n\\n    Right-hand circular polarization\\n\\n    >>> pprint(stokes_vector(0, pi/4), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a31\u23a6\\n\\n    Left-hand circular polarization\\n\\n    >>> pprint(stokes_vector(0, -pi/4), use_unicode=True)\\n    \u23a11 \u23a4\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a3-1\u23a6\\n\\n    Unpolarized light\\n\\n    >>> pprint(stokes_vector(0, 0, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    '\n    S0 = I\n    S1 = I * p * cos(2 * psi) * cos(2 * chi)\n    S2 = I * p * sin(2 * psi) * cos(2 * chi)\n    S3 = I * p * sin(2 * chi)\n    return Matrix([S0, S1, S2, S3])",
            "def stokes_vector(psi, chi, p=1, I=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A Stokes vector corresponding to a polarization ellipse with ``psi``\\n    tilt, and ``chi`` circularity.\\n\\n    Parameters\\n    ==========\\n\\n    psi : numeric type or SymPy Symbol\\n        The tilt of the polarization relative to the ``x`` axis.\\n    chi : numeric type or SymPy Symbol\\n        The angle adjacent to the mayor axis of the polarization ellipse.\\n    p : numeric type or SymPy Symbol\\n        The degree of polarization.\\n    I : numeric type or SymPy Symbol\\n        The intensity of the field.\\n\\n\\n    Returns\\n    =======\\n\\n    Matrix :\\n        A Stokes vector.\\n\\n    Examples\\n    ========\\n\\n    The axes on the Poincar\u00e9 sphere.\\n\\n    >>> from sympy import pprint, symbols, pi\\n    >>> from sympy.physics.optics.polarization import stokes_vector\\n    >>> psi, chi, p, I = symbols(\"psi, chi, p, I\", real=True)\\n    >>> pprint(stokes_vector(psi, chi, p, I), use_unicode=True)\\n    \u23a1          I          \u23a4\\n    \u23a2                     \u23a5\\n    \u23a2I\u22c5p\u22c5cos(2\u22c5\u03c7)\u22c5cos(2\u22c5\u03c8)\u23a5\\n    \u23a2                     \u23a5\\n    \u23a2I\u22c5p\u22c5sin(2\u22c5\u03c8)\u22c5cos(2\u22c5\u03c7)\u23a5\\n    \u23a2                     \u23a5\\n    \u23a3    I\u22c5p\u22c5sin(2\u22c5\u03c7)     \u23a6\\n\\n\\n    Horizontal polarization\\n\\n    >>> pprint(stokes_vector(0, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a21\u23a5\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    Vertical polarization\\n\\n    >>> pprint(stokes_vector(pi/2, 0), use_unicode=True)\\n    \u23a11 \u23a4\\n    \u23a2  \u23a5\\n    \u23a2-1\u23a5\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a30 \u23a6\\n\\n    Diagonal polarization\\n\\n    >>> pprint(stokes_vector(pi/4, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a21\u23a5\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    Anti-diagonal polarization\\n\\n    >>> pprint(stokes_vector(-pi/4, 0), use_unicode=True)\\n    \u23a11 \u23a4\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a2-1\u23a5\\n    \u23a2  \u23a5\\n    \u23a30 \u23a6\\n\\n    Right-hand circular polarization\\n\\n    >>> pprint(stokes_vector(0, pi/4), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a31\u23a6\\n\\n    Left-hand circular polarization\\n\\n    >>> pprint(stokes_vector(0, -pi/4), use_unicode=True)\\n    \u23a11 \u23a4\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a3-1\u23a6\\n\\n    Unpolarized light\\n\\n    >>> pprint(stokes_vector(0, 0, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    '\n    S0 = I\n    S1 = I * p * cos(2 * psi) * cos(2 * chi)\n    S2 = I * p * sin(2 * psi) * cos(2 * chi)\n    S3 = I * p * sin(2 * chi)\n    return Matrix([S0, S1, S2, S3])",
            "def stokes_vector(psi, chi, p=1, I=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A Stokes vector corresponding to a polarization ellipse with ``psi``\\n    tilt, and ``chi`` circularity.\\n\\n    Parameters\\n    ==========\\n\\n    psi : numeric type or SymPy Symbol\\n        The tilt of the polarization relative to the ``x`` axis.\\n    chi : numeric type or SymPy Symbol\\n        The angle adjacent to the mayor axis of the polarization ellipse.\\n    p : numeric type or SymPy Symbol\\n        The degree of polarization.\\n    I : numeric type or SymPy Symbol\\n        The intensity of the field.\\n\\n\\n    Returns\\n    =======\\n\\n    Matrix :\\n        A Stokes vector.\\n\\n    Examples\\n    ========\\n\\n    The axes on the Poincar\u00e9 sphere.\\n\\n    >>> from sympy import pprint, symbols, pi\\n    >>> from sympy.physics.optics.polarization import stokes_vector\\n    >>> psi, chi, p, I = symbols(\"psi, chi, p, I\", real=True)\\n    >>> pprint(stokes_vector(psi, chi, p, I), use_unicode=True)\\n    \u23a1          I          \u23a4\\n    \u23a2                     \u23a5\\n    \u23a2I\u22c5p\u22c5cos(2\u22c5\u03c7)\u22c5cos(2\u22c5\u03c8)\u23a5\\n    \u23a2                     \u23a5\\n    \u23a2I\u22c5p\u22c5sin(2\u22c5\u03c8)\u22c5cos(2\u22c5\u03c7)\u23a5\\n    \u23a2                     \u23a5\\n    \u23a3    I\u22c5p\u22c5sin(2\u22c5\u03c7)     \u23a6\\n\\n\\n    Horizontal polarization\\n\\n    >>> pprint(stokes_vector(0, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a21\u23a5\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    Vertical polarization\\n\\n    >>> pprint(stokes_vector(pi/2, 0), use_unicode=True)\\n    \u23a11 \u23a4\\n    \u23a2  \u23a5\\n    \u23a2-1\u23a5\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a30 \u23a6\\n\\n    Diagonal polarization\\n\\n    >>> pprint(stokes_vector(pi/4, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a21\u23a5\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    Anti-diagonal polarization\\n\\n    >>> pprint(stokes_vector(-pi/4, 0), use_unicode=True)\\n    \u23a11 \u23a4\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a2-1\u23a5\\n    \u23a2  \u23a5\\n    \u23a30 \u23a6\\n\\n    Right-hand circular polarization\\n\\n    >>> pprint(stokes_vector(0, pi/4), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a31\u23a6\\n\\n    Left-hand circular polarization\\n\\n    >>> pprint(stokes_vector(0, -pi/4), use_unicode=True)\\n    \u23a11 \u23a4\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a20 \u23a5\\n    \u23a2  \u23a5\\n    \u23a3-1\u23a6\\n\\n    Unpolarized light\\n\\n    >>> pprint(stokes_vector(0, 0, 0), use_unicode=True)\\n    \u23a11\u23a4\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a20\u23a5\\n    \u23a2 \u23a5\\n    \u23a30\u23a6\\n\\n    '\n    S0 = I\n    S1 = I * p * cos(2 * psi) * cos(2 * chi)\n    S2 = I * p * sin(2 * psi) * cos(2 * chi)\n    S3 = I * p * sin(2 * chi)\n    return Matrix([S0, S1, S2, S3])"
        ]
    },
    {
        "func_name": "jones_2_stokes",
        "original": "def jones_2_stokes(e):\n    \"\"\"Return the Stokes vector for a Jones vector ``e``.\n\n    Parameters\n    ==========\n\n    e : SymPy Matrix\n        A Jones vector.\n\n    Returns\n    =======\n\n    SymPy Matrix\n        A Jones vector.\n\n    Examples\n    ========\n\n    The axes on the Poincar\u00e9 sphere.\n\n    >>> from sympy import pprint, pi\n    >>> from sympy.physics.optics.polarization import jones_vector\n    >>> from sympy.physics.optics.polarization import jones_2_stokes\n    >>> H = jones_vector(0, 0)\n    >>> V = jones_vector(pi/2, 0)\n    >>> D = jones_vector(pi/4, 0)\n    >>> A = jones_vector(-pi/4, 0)\n    >>> R = jones_vector(0, pi/4)\n    >>> L = jones_vector(0, -pi/4)\n    >>> pprint([jones_2_stokes(e) for e in [H, V, D, A, R, L]],\n    ...         use_unicode=True)\n    \u23a1\u23a11\u23a4  \u23a11 \u23a4  \u23a11\u23a4  \u23a11 \u23a4  \u23a11\u23a4  \u23a11 \u23a4\u23a4\n    \u23a2\u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5\u23a5\n    \u23a2\u23a21\u23a5  \u23a2-1\u23a5  \u23a20\u23a5  \u23a20 \u23a5  \u23a20\u23a5  \u23a20 \u23a5\u23a5\n    \u23a2\u23a2 \u23a5, \u23a2  \u23a5, \u23a2 \u23a5, \u23a2  \u23a5, \u23a2 \u23a5, \u23a2  \u23a5\u23a5\n    \u23a2\u23a20\u23a5  \u23a20 \u23a5  \u23a21\u23a5  \u23a2-1\u23a5  \u23a20\u23a5  \u23a20 \u23a5\u23a5\n    \u23a2\u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5\u23a5\n    \u23a3\u23a30\u23a6  \u23a30 \u23a6  \u23a30\u23a6  \u23a30 \u23a6  \u23a31\u23a6  \u23a3-1\u23a6\u23a6\n\n    \"\"\"\n    (ex, ey) = e\n    return Matrix([Abs(ex) ** 2 + Abs(ey) ** 2, Abs(ex) ** 2 - Abs(ey) ** 2, 2 * re(ex * ey.conjugate()), -2 * im(ex * ey.conjugate())])",
        "mutated": [
            "def jones_2_stokes(e):\n    if False:\n        i = 10\n    'Return the Stokes vector for a Jones vector ``e``.\\n\\n    Parameters\\n    ==========\\n\\n    e : SymPy Matrix\\n        A Jones vector.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones vector.\\n\\n    Examples\\n    ========\\n\\n    The axes on the Poincar\u00e9 sphere.\\n\\n    >>> from sympy import pprint, pi\\n    >>> from sympy.physics.optics.polarization import jones_vector\\n    >>> from sympy.physics.optics.polarization import jones_2_stokes\\n    >>> H = jones_vector(0, 0)\\n    >>> V = jones_vector(pi/2, 0)\\n    >>> D = jones_vector(pi/4, 0)\\n    >>> A = jones_vector(-pi/4, 0)\\n    >>> R = jones_vector(0, pi/4)\\n    >>> L = jones_vector(0, -pi/4)\\n    >>> pprint([jones_2_stokes(e) for e in [H, V, D, A, R, L]],\\n    ...         use_unicode=True)\\n    \u23a1\u23a11\u23a4  \u23a11 \u23a4  \u23a11\u23a4  \u23a11 \u23a4  \u23a11\u23a4  \u23a11 \u23a4\u23a4\\n    \u23a2\u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5\u23a5\\n    \u23a2\u23a21\u23a5  \u23a2-1\u23a5  \u23a20\u23a5  \u23a20 \u23a5  \u23a20\u23a5  \u23a20 \u23a5\u23a5\\n    \u23a2\u23a2 \u23a5, \u23a2  \u23a5, \u23a2 \u23a5, \u23a2  \u23a5, \u23a2 \u23a5, \u23a2  \u23a5\u23a5\\n    \u23a2\u23a20\u23a5  \u23a20 \u23a5  \u23a21\u23a5  \u23a2-1\u23a5  \u23a20\u23a5  \u23a20 \u23a5\u23a5\\n    \u23a2\u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5\u23a5\\n    \u23a3\u23a30\u23a6  \u23a30 \u23a6  \u23a30\u23a6  \u23a30 \u23a6  \u23a31\u23a6  \u23a3-1\u23a6\u23a6\\n\\n    '\n    (ex, ey) = e\n    return Matrix([Abs(ex) ** 2 + Abs(ey) ** 2, Abs(ex) ** 2 - Abs(ey) ** 2, 2 * re(ex * ey.conjugate()), -2 * im(ex * ey.conjugate())])",
            "def jones_2_stokes(e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the Stokes vector for a Jones vector ``e``.\\n\\n    Parameters\\n    ==========\\n\\n    e : SymPy Matrix\\n        A Jones vector.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones vector.\\n\\n    Examples\\n    ========\\n\\n    The axes on the Poincar\u00e9 sphere.\\n\\n    >>> from sympy import pprint, pi\\n    >>> from sympy.physics.optics.polarization import jones_vector\\n    >>> from sympy.physics.optics.polarization import jones_2_stokes\\n    >>> H = jones_vector(0, 0)\\n    >>> V = jones_vector(pi/2, 0)\\n    >>> D = jones_vector(pi/4, 0)\\n    >>> A = jones_vector(-pi/4, 0)\\n    >>> R = jones_vector(0, pi/4)\\n    >>> L = jones_vector(0, -pi/4)\\n    >>> pprint([jones_2_stokes(e) for e in [H, V, D, A, R, L]],\\n    ...         use_unicode=True)\\n    \u23a1\u23a11\u23a4  \u23a11 \u23a4  \u23a11\u23a4  \u23a11 \u23a4  \u23a11\u23a4  \u23a11 \u23a4\u23a4\\n    \u23a2\u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5\u23a5\\n    \u23a2\u23a21\u23a5  \u23a2-1\u23a5  \u23a20\u23a5  \u23a20 \u23a5  \u23a20\u23a5  \u23a20 \u23a5\u23a5\\n    \u23a2\u23a2 \u23a5, \u23a2  \u23a5, \u23a2 \u23a5, \u23a2  \u23a5, \u23a2 \u23a5, \u23a2  \u23a5\u23a5\\n    \u23a2\u23a20\u23a5  \u23a20 \u23a5  \u23a21\u23a5  \u23a2-1\u23a5  \u23a20\u23a5  \u23a20 \u23a5\u23a5\\n    \u23a2\u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5\u23a5\\n    \u23a3\u23a30\u23a6  \u23a30 \u23a6  \u23a30\u23a6  \u23a30 \u23a6  \u23a31\u23a6  \u23a3-1\u23a6\u23a6\\n\\n    '\n    (ex, ey) = e\n    return Matrix([Abs(ex) ** 2 + Abs(ey) ** 2, Abs(ex) ** 2 - Abs(ey) ** 2, 2 * re(ex * ey.conjugate()), -2 * im(ex * ey.conjugate())])",
            "def jones_2_stokes(e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the Stokes vector for a Jones vector ``e``.\\n\\n    Parameters\\n    ==========\\n\\n    e : SymPy Matrix\\n        A Jones vector.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones vector.\\n\\n    Examples\\n    ========\\n\\n    The axes on the Poincar\u00e9 sphere.\\n\\n    >>> from sympy import pprint, pi\\n    >>> from sympy.physics.optics.polarization import jones_vector\\n    >>> from sympy.physics.optics.polarization import jones_2_stokes\\n    >>> H = jones_vector(0, 0)\\n    >>> V = jones_vector(pi/2, 0)\\n    >>> D = jones_vector(pi/4, 0)\\n    >>> A = jones_vector(-pi/4, 0)\\n    >>> R = jones_vector(0, pi/4)\\n    >>> L = jones_vector(0, -pi/4)\\n    >>> pprint([jones_2_stokes(e) for e in [H, V, D, A, R, L]],\\n    ...         use_unicode=True)\\n    \u23a1\u23a11\u23a4  \u23a11 \u23a4  \u23a11\u23a4  \u23a11 \u23a4  \u23a11\u23a4  \u23a11 \u23a4\u23a4\\n    \u23a2\u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5\u23a5\\n    \u23a2\u23a21\u23a5  \u23a2-1\u23a5  \u23a20\u23a5  \u23a20 \u23a5  \u23a20\u23a5  \u23a20 \u23a5\u23a5\\n    \u23a2\u23a2 \u23a5, \u23a2  \u23a5, \u23a2 \u23a5, \u23a2  \u23a5, \u23a2 \u23a5, \u23a2  \u23a5\u23a5\\n    \u23a2\u23a20\u23a5  \u23a20 \u23a5  \u23a21\u23a5  \u23a2-1\u23a5  \u23a20\u23a5  \u23a20 \u23a5\u23a5\\n    \u23a2\u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5\u23a5\\n    \u23a3\u23a30\u23a6  \u23a30 \u23a6  \u23a30\u23a6  \u23a30 \u23a6  \u23a31\u23a6  \u23a3-1\u23a6\u23a6\\n\\n    '\n    (ex, ey) = e\n    return Matrix([Abs(ex) ** 2 + Abs(ey) ** 2, Abs(ex) ** 2 - Abs(ey) ** 2, 2 * re(ex * ey.conjugate()), -2 * im(ex * ey.conjugate())])",
            "def jones_2_stokes(e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the Stokes vector for a Jones vector ``e``.\\n\\n    Parameters\\n    ==========\\n\\n    e : SymPy Matrix\\n        A Jones vector.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones vector.\\n\\n    Examples\\n    ========\\n\\n    The axes on the Poincar\u00e9 sphere.\\n\\n    >>> from sympy import pprint, pi\\n    >>> from sympy.physics.optics.polarization import jones_vector\\n    >>> from sympy.physics.optics.polarization import jones_2_stokes\\n    >>> H = jones_vector(0, 0)\\n    >>> V = jones_vector(pi/2, 0)\\n    >>> D = jones_vector(pi/4, 0)\\n    >>> A = jones_vector(-pi/4, 0)\\n    >>> R = jones_vector(0, pi/4)\\n    >>> L = jones_vector(0, -pi/4)\\n    >>> pprint([jones_2_stokes(e) for e in [H, V, D, A, R, L]],\\n    ...         use_unicode=True)\\n    \u23a1\u23a11\u23a4  \u23a11 \u23a4  \u23a11\u23a4  \u23a11 \u23a4  \u23a11\u23a4  \u23a11 \u23a4\u23a4\\n    \u23a2\u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5\u23a5\\n    \u23a2\u23a21\u23a5  \u23a2-1\u23a5  \u23a20\u23a5  \u23a20 \u23a5  \u23a20\u23a5  \u23a20 \u23a5\u23a5\\n    \u23a2\u23a2 \u23a5, \u23a2  \u23a5, \u23a2 \u23a5, \u23a2  \u23a5, \u23a2 \u23a5, \u23a2  \u23a5\u23a5\\n    \u23a2\u23a20\u23a5  \u23a20 \u23a5  \u23a21\u23a5  \u23a2-1\u23a5  \u23a20\u23a5  \u23a20 \u23a5\u23a5\\n    \u23a2\u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5\u23a5\\n    \u23a3\u23a30\u23a6  \u23a30 \u23a6  \u23a30\u23a6  \u23a30 \u23a6  \u23a31\u23a6  \u23a3-1\u23a6\u23a6\\n\\n    '\n    (ex, ey) = e\n    return Matrix([Abs(ex) ** 2 + Abs(ey) ** 2, Abs(ex) ** 2 - Abs(ey) ** 2, 2 * re(ex * ey.conjugate()), -2 * im(ex * ey.conjugate())])",
            "def jones_2_stokes(e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the Stokes vector for a Jones vector ``e``.\\n\\n    Parameters\\n    ==========\\n\\n    e : SymPy Matrix\\n        A Jones vector.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones vector.\\n\\n    Examples\\n    ========\\n\\n    The axes on the Poincar\u00e9 sphere.\\n\\n    >>> from sympy import pprint, pi\\n    >>> from sympy.physics.optics.polarization import jones_vector\\n    >>> from sympy.physics.optics.polarization import jones_2_stokes\\n    >>> H = jones_vector(0, 0)\\n    >>> V = jones_vector(pi/2, 0)\\n    >>> D = jones_vector(pi/4, 0)\\n    >>> A = jones_vector(-pi/4, 0)\\n    >>> R = jones_vector(0, pi/4)\\n    >>> L = jones_vector(0, -pi/4)\\n    >>> pprint([jones_2_stokes(e) for e in [H, V, D, A, R, L]],\\n    ...         use_unicode=True)\\n    \u23a1\u23a11\u23a4  \u23a11 \u23a4  \u23a11\u23a4  \u23a11 \u23a4  \u23a11\u23a4  \u23a11 \u23a4\u23a4\\n    \u23a2\u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5\u23a5\\n    \u23a2\u23a21\u23a5  \u23a2-1\u23a5  \u23a20\u23a5  \u23a20 \u23a5  \u23a20\u23a5  \u23a20 \u23a5\u23a5\\n    \u23a2\u23a2 \u23a5, \u23a2  \u23a5, \u23a2 \u23a5, \u23a2  \u23a5, \u23a2 \u23a5, \u23a2  \u23a5\u23a5\\n    \u23a2\u23a20\u23a5  \u23a20 \u23a5  \u23a21\u23a5  \u23a2-1\u23a5  \u23a20\u23a5  \u23a20 \u23a5\u23a5\\n    \u23a2\u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5\u23a5\\n    \u23a3\u23a30\u23a6  \u23a30 \u23a6  \u23a30\u23a6  \u23a30 \u23a6  \u23a31\u23a6  \u23a3-1\u23a6\u23a6\\n\\n    '\n    (ex, ey) = e\n    return Matrix([Abs(ex) ** 2 + Abs(ey) ** 2, Abs(ex) ** 2 - Abs(ey) ** 2, 2 * re(ex * ey.conjugate()), -2 * im(ex * ey.conjugate())])"
        ]
    },
    {
        "func_name": "linear_polarizer",
        "original": "def linear_polarizer(theta=0):\n    \"\"\"A linear polarizer Jones matrix with transmission axis at\n    an angle ``theta``.\n\n    Parameters\n    ==========\n\n    theta : numeric type or SymPy Symbol\n        The angle of the transmission axis relative to the horizontal plane.\n\n    Returns\n    =======\n\n    SymPy Matrix\n        A Jones matrix representing the polarizer.\n\n    Examples\n    ========\n\n    A generic polarizer.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import linear_polarizer\n    >>> theta = symbols(\"theta\", real=True)\n    >>> J = linear_polarizer(theta)\n    >>> pprint(J, use_unicode=True)\n    \u23a1      2                     \u23a4\n    \u23a2   cos (\u03b8)     sin(\u03b8)\u22c5cos(\u03b8)\u23a5\n    \u23a2                            \u23a5\n    \u23a2                     2      \u23a5\n    \u23a3sin(\u03b8)\u22c5cos(\u03b8)     sin (\u03b8)   \u23a6\n\n\n    \"\"\"\n    M = Matrix([[cos(theta) ** 2, sin(theta) * cos(theta)], [sin(theta) * cos(theta), sin(theta) ** 2]])\n    return M",
        "mutated": [
            "def linear_polarizer(theta=0):\n    if False:\n        i = 10\n    'A linear polarizer Jones matrix with transmission axis at\\n    an angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the transmission axis relative to the horizontal plane.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the polarizer.\\n\\n    Examples\\n    ========\\n\\n    A generic polarizer.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import linear_polarizer\\n    >>> theta = symbols(\"theta\", real=True)\\n    >>> J = linear_polarizer(theta)\\n    >>> pprint(J, use_unicode=True)\\n    \u23a1      2                     \u23a4\\n    \u23a2   cos (\u03b8)     sin(\u03b8)\u22c5cos(\u03b8)\u23a5\\n    \u23a2                            \u23a5\\n    \u23a2                     2      \u23a5\\n    \u23a3sin(\u03b8)\u22c5cos(\u03b8)     sin (\u03b8)   \u23a6\\n\\n\\n    '\n    M = Matrix([[cos(theta) ** 2, sin(theta) * cos(theta)], [sin(theta) * cos(theta), sin(theta) ** 2]])\n    return M",
            "def linear_polarizer(theta=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A linear polarizer Jones matrix with transmission axis at\\n    an angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the transmission axis relative to the horizontal plane.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the polarizer.\\n\\n    Examples\\n    ========\\n\\n    A generic polarizer.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import linear_polarizer\\n    >>> theta = symbols(\"theta\", real=True)\\n    >>> J = linear_polarizer(theta)\\n    >>> pprint(J, use_unicode=True)\\n    \u23a1      2                     \u23a4\\n    \u23a2   cos (\u03b8)     sin(\u03b8)\u22c5cos(\u03b8)\u23a5\\n    \u23a2                            \u23a5\\n    \u23a2                     2      \u23a5\\n    \u23a3sin(\u03b8)\u22c5cos(\u03b8)     sin (\u03b8)   \u23a6\\n\\n\\n    '\n    M = Matrix([[cos(theta) ** 2, sin(theta) * cos(theta)], [sin(theta) * cos(theta), sin(theta) ** 2]])\n    return M",
            "def linear_polarizer(theta=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A linear polarizer Jones matrix with transmission axis at\\n    an angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the transmission axis relative to the horizontal plane.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the polarizer.\\n\\n    Examples\\n    ========\\n\\n    A generic polarizer.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import linear_polarizer\\n    >>> theta = symbols(\"theta\", real=True)\\n    >>> J = linear_polarizer(theta)\\n    >>> pprint(J, use_unicode=True)\\n    \u23a1      2                     \u23a4\\n    \u23a2   cos (\u03b8)     sin(\u03b8)\u22c5cos(\u03b8)\u23a5\\n    \u23a2                            \u23a5\\n    \u23a2                     2      \u23a5\\n    \u23a3sin(\u03b8)\u22c5cos(\u03b8)     sin (\u03b8)   \u23a6\\n\\n\\n    '\n    M = Matrix([[cos(theta) ** 2, sin(theta) * cos(theta)], [sin(theta) * cos(theta), sin(theta) ** 2]])\n    return M",
            "def linear_polarizer(theta=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A linear polarizer Jones matrix with transmission axis at\\n    an angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the transmission axis relative to the horizontal plane.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the polarizer.\\n\\n    Examples\\n    ========\\n\\n    A generic polarizer.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import linear_polarizer\\n    >>> theta = symbols(\"theta\", real=True)\\n    >>> J = linear_polarizer(theta)\\n    >>> pprint(J, use_unicode=True)\\n    \u23a1      2                     \u23a4\\n    \u23a2   cos (\u03b8)     sin(\u03b8)\u22c5cos(\u03b8)\u23a5\\n    \u23a2                            \u23a5\\n    \u23a2                     2      \u23a5\\n    \u23a3sin(\u03b8)\u22c5cos(\u03b8)     sin (\u03b8)   \u23a6\\n\\n\\n    '\n    M = Matrix([[cos(theta) ** 2, sin(theta) * cos(theta)], [sin(theta) * cos(theta), sin(theta) ** 2]])\n    return M",
            "def linear_polarizer(theta=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A linear polarizer Jones matrix with transmission axis at\\n    an angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the transmission axis relative to the horizontal plane.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the polarizer.\\n\\n    Examples\\n    ========\\n\\n    A generic polarizer.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import linear_polarizer\\n    >>> theta = symbols(\"theta\", real=True)\\n    >>> J = linear_polarizer(theta)\\n    >>> pprint(J, use_unicode=True)\\n    \u23a1      2                     \u23a4\\n    \u23a2   cos (\u03b8)     sin(\u03b8)\u22c5cos(\u03b8)\u23a5\\n    \u23a2                            \u23a5\\n    \u23a2                     2      \u23a5\\n    \u23a3sin(\u03b8)\u22c5cos(\u03b8)     sin (\u03b8)   \u23a6\\n\\n\\n    '\n    M = Matrix([[cos(theta) ** 2, sin(theta) * cos(theta)], [sin(theta) * cos(theta), sin(theta) ** 2]])\n    return M"
        ]
    },
    {
        "func_name": "phase_retarder",
        "original": "def phase_retarder(theta=0, delta=0):\n    \"\"\"A phase retarder Jones matrix with retardance ``delta`` at angle ``theta``.\n\n    Parameters\n    ==========\n\n    theta : numeric type or SymPy Symbol\n        The angle of the fast axis relative to the horizontal plane.\n    delta : numeric type or SymPy Symbol\n        The phase difference between the fast and slow axes of the\n        transmitted light.\n\n    Returns\n    =======\n\n    SymPy Matrix :\n        A Jones matrix representing the retarder.\n\n    Examples\n    ========\n\n    A generic retarder.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import phase_retarder\n    >>> theta, delta = symbols(\"theta, delta\", real=True)\n    >>> R = phase_retarder(theta, delta)\n    >>> pprint(R, use_unicode=True)\n    \u23a1                          -\u2148\u22c5\u03b4               -\u2148\u22c5\u03b4               \u23a4\n    \u23a2                          \u2500\u2500\u2500\u2500\u2500              \u2500\u2500\u2500\u2500\u2500              \u23a5\n    \u23a2\u239b \u2148\u22c5\u03b4    2         2   \u239e    2    \u239b     \u2148\u22c5\u03b4\u239e    2                \u23a5\n    \u23a2\u239d\u212f   \u22c5sin (\u03b8) + cos (\u03b8)\u23a0\u22c5\u212f       \u239d1 - \u212f   \u23a0\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)\u23a5\n    \u23a2                                                                \u23a5\n    \u23a2            -\u2148\u22c5\u03b4                                           -\u2148\u22c5\u03b4 \u23a5\n    \u23a2            \u2500\u2500\u2500\u2500\u2500                                          \u2500\u2500\u2500\u2500\u2500\u23a5\n    \u23a2\u239b     \u2148\u22c5\u03b4\u239e    2                  \u239b \u2148\u22c5\u03b4    2         2   \u239e    2  \u23a5\n    \u23a3\u239d1 - \u212f   \u23a0\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u239d\u212f   \u22c5cos (\u03b8) + sin (\u03b8)\u23a0\u22c5\u212f     \u23a6\n\n    \"\"\"\n    R = Matrix([[cos(theta) ** 2 + exp(I * delta) * sin(theta) ** 2, (1 - exp(I * delta)) * cos(theta) * sin(theta)], [(1 - exp(I * delta)) * cos(theta) * sin(theta), sin(theta) ** 2 + exp(I * delta) * cos(theta) ** 2]])\n    return R * exp(-I * delta / 2)",
        "mutated": [
            "def phase_retarder(theta=0, delta=0):\n    if False:\n        i = 10\n    'A phase retarder Jones matrix with retardance ``delta`` at angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the fast axis relative to the horizontal plane.\\n    delta : numeric type or SymPy Symbol\\n        The phase difference between the fast and slow axes of the\\n        transmitted light.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix :\\n        A Jones matrix representing the retarder.\\n\\n    Examples\\n    ========\\n\\n    A generic retarder.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import phase_retarder\\n    >>> theta, delta = symbols(\"theta, delta\", real=True)\\n    >>> R = phase_retarder(theta, delta)\\n    >>> pprint(R, use_unicode=True)\\n    \u23a1                          -\u2148\u22c5\u03b4               -\u2148\u22c5\u03b4               \u23a4\\n    \u23a2                          \u2500\u2500\u2500\u2500\u2500              \u2500\u2500\u2500\u2500\u2500              \u23a5\\n    \u23a2\u239b \u2148\u22c5\u03b4    2         2   \u239e    2    \u239b     \u2148\u22c5\u03b4\u239e    2                \u23a5\\n    \u23a2\u239d\u212f   \u22c5sin (\u03b8) + cos (\u03b8)\u23a0\u22c5\u212f       \u239d1 - \u212f   \u23a0\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)\u23a5\\n    \u23a2                                                                \u23a5\\n    \u23a2            -\u2148\u22c5\u03b4                                           -\u2148\u22c5\u03b4 \u23a5\\n    \u23a2            \u2500\u2500\u2500\u2500\u2500                                          \u2500\u2500\u2500\u2500\u2500\u23a5\\n    \u23a2\u239b     \u2148\u22c5\u03b4\u239e    2                  \u239b \u2148\u22c5\u03b4    2         2   \u239e    2  \u23a5\\n    \u23a3\u239d1 - \u212f   \u23a0\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u239d\u212f   \u22c5cos (\u03b8) + sin (\u03b8)\u23a0\u22c5\u212f     \u23a6\\n\\n    '\n    R = Matrix([[cos(theta) ** 2 + exp(I * delta) * sin(theta) ** 2, (1 - exp(I * delta)) * cos(theta) * sin(theta)], [(1 - exp(I * delta)) * cos(theta) * sin(theta), sin(theta) ** 2 + exp(I * delta) * cos(theta) ** 2]])\n    return R * exp(-I * delta / 2)",
            "def phase_retarder(theta=0, delta=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A phase retarder Jones matrix with retardance ``delta`` at angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the fast axis relative to the horizontal plane.\\n    delta : numeric type or SymPy Symbol\\n        The phase difference between the fast and slow axes of the\\n        transmitted light.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix :\\n        A Jones matrix representing the retarder.\\n\\n    Examples\\n    ========\\n\\n    A generic retarder.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import phase_retarder\\n    >>> theta, delta = symbols(\"theta, delta\", real=True)\\n    >>> R = phase_retarder(theta, delta)\\n    >>> pprint(R, use_unicode=True)\\n    \u23a1                          -\u2148\u22c5\u03b4               -\u2148\u22c5\u03b4               \u23a4\\n    \u23a2                          \u2500\u2500\u2500\u2500\u2500              \u2500\u2500\u2500\u2500\u2500              \u23a5\\n    \u23a2\u239b \u2148\u22c5\u03b4    2         2   \u239e    2    \u239b     \u2148\u22c5\u03b4\u239e    2                \u23a5\\n    \u23a2\u239d\u212f   \u22c5sin (\u03b8) + cos (\u03b8)\u23a0\u22c5\u212f       \u239d1 - \u212f   \u23a0\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)\u23a5\\n    \u23a2                                                                \u23a5\\n    \u23a2            -\u2148\u22c5\u03b4                                           -\u2148\u22c5\u03b4 \u23a5\\n    \u23a2            \u2500\u2500\u2500\u2500\u2500                                          \u2500\u2500\u2500\u2500\u2500\u23a5\\n    \u23a2\u239b     \u2148\u22c5\u03b4\u239e    2                  \u239b \u2148\u22c5\u03b4    2         2   \u239e    2  \u23a5\\n    \u23a3\u239d1 - \u212f   \u23a0\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u239d\u212f   \u22c5cos (\u03b8) + sin (\u03b8)\u23a0\u22c5\u212f     \u23a6\\n\\n    '\n    R = Matrix([[cos(theta) ** 2 + exp(I * delta) * sin(theta) ** 2, (1 - exp(I * delta)) * cos(theta) * sin(theta)], [(1 - exp(I * delta)) * cos(theta) * sin(theta), sin(theta) ** 2 + exp(I * delta) * cos(theta) ** 2]])\n    return R * exp(-I * delta / 2)",
            "def phase_retarder(theta=0, delta=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A phase retarder Jones matrix with retardance ``delta`` at angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the fast axis relative to the horizontal plane.\\n    delta : numeric type or SymPy Symbol\\n        The phase difference between the fast and slow axes of the\\n        transmitted light.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix :\\n        A Jones matrix representing the retarder.\\n\\n    Examples\\n    ========\\n\\n    A generic retarder.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import phase_retarder\\n    >>> theta, delta = symbols(\"theta, delta\", real=True)\\n    >>> R = phase_retarder(theta, delta)\\n    >>> pprint(R, use_unicode=True)\\n    \u23a1                          -\u2148\u22c5\u03b4               -\u2148\u22c5\u03b4               \u23a4\\n    \u23a2                          \u2500\u2500\u2500\u2500\u2500              \u2500\u2500\u2500\u2500\u2500              \u23a5\\n    \u23a2\u239b \u2148\u22c5\u03b4    2         2   \u239e    2    \u239b     \u2148\u22c5\u03b4\u239e    2                \u23a5\\n    \u23a2\u239d\u212f   \u22c5sin (\u03b8) + cos (\u03b8)\u23a0\u22c5\u212f       \u239d1 - \u212f   \u23a0\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)\u23a5\\n    \u23a2                                                                \u23a5\\n    \u23a2            -\u2148\u22c5\u03b4                                           -\u2148\u22c5\u03b4 \u23a5\\n    \u23a2            \u2500\u2500\u2500\u2500\u2500                                          \u2500\u2500\u2500\u2500\u2500\u23a5\\n    \u23a2\u239b     \u2148\u22c5\u03b4\u239e    2                  \u239b \u2148\u22c5\u03b4    2         2   \u239e    2  \u23a5\\n    \u23a3\u239d1 - \u212f   \u23a0\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u239d\u212f   \u22c5cos (\u03b8) + sin (\u03b8)\u23a0\u22c5\u212f     \u23a6\\n\\n    '\n    R = Matrix([[cos(theta) ** 2 + exp(I * delta) * sin(theta) ** 2, (1 - exp(I * delta)) * cos(theta) * sin(theta)], [(1 - exp(I * delta)) * cos(theta) * sin(theta), sin(theta) ** 2 + exp(I * delta) * cos(theta) ** 2]])\n    return R * exp(-I * delta / 2)",
            "def phase_retarder(theta=0, delta=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A phase retarder Jones matrix with retardance ``delta`` at angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the fast axis relative to the horizontal plane.\\n    delta : numeric type or SymPy Symbol\\n        The phase difference between the fast and slow axes of the\\n        transmitted light.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix :\\n        A Jones matrix representing the retarder.\\n\\n    Examples\\n    ========\\n\\n    A generic retarder.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import phase_retarder\\n    >>> theta, delta = symbols(\"theta, delta\", real=True)\\n    >>> R = phase_retarder(theta, delta)\\n    >>> pprint(R, use_unicode=True)\\n    \u23a1                          -\u2148\u22c5\u03b4               -\u2148\u22c5\u03b4               \u23a4\\n    \u23a2                          \u2500\u2500\u2500\u2500\u2500              \u2500\u2500\u2500\u2500\u2500              \u23a5\\n    \u23a2\u239b \u2148\u22c5\u03b4    2         2   \u239e    2    \u239b     \u2148\u22c5\u03b4\u239e    2                \u23a5\\n    \u23a2\u239d\u212f   \u22c5sin (\u03b8) + cos (\u03b8)\u23a0\u22c5\u212f       \u239d1 - \u212f   \u23a0\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)\u23a5\\n    \u23a2                                                                \u23a5\\n    \u23a2            -\u2148\u22c5\u03b4                                           -\u2148\u22c5\u03b4 \u23a5\\n    \u23a2            \u2500\u2500\u2500\u2500\u2500                                          \u2500\u2500\u2500\u2500\u2500\u23a5\\n    \u23a2\u239b     \u2148\u22c5\u03b4\u239e    2                  \u239b \u2148\u22c5\u03b4    2         2   \u239e    2  \u23a5\\n    \u23a3\u239d1 - \u212f   \u23a0\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u239d\u212f   \u22c5cos (\u03b8) + sin (\u03b8)\u23a0\u22c5\u212f     \u23a6\\n\\n    '\n    R = Matrix([[cos(theta) ** 2 + exp(I * delta) * sin(theta) ** 2, (1 - exp(I * delta)) * cos(theta) * sin(theta)], [(1 - exp(I * delta)) * cos(theta) * sin(theta), sin(theta) ** 2 + exp(I * delta) * cos(theta) ** 2]])\n    return R * exp(-I * delta / 2)",
            "def phase_retarder(theta=0, delta=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A phase retarder Jones matrix with retardance ``delta`` at angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the fast axis relative to the horizontal plane.\\n    delta : numeric type or SymPy Symbol\\n        The phase difference between the fast and slow axes of the\\n        transmitted light.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix :\\n        A Jones matrix representing the retarder.\\n\\n    Examples\\n    ========\\n\\n    A generic retarder.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import phase_retarder\\n    >>> theta, delta = symbols(\"theta, delta\", real=True)\\n    >>> R = phase_retarder(theta, delta)\\n    >>> pprint(R, use_unicode=True)\\n    \u23a1                          -\u2148\u22c5\u03b4               -\u2148\u22c5\u03b4               \u23a4\\n    \u23a2                          \u2500\u2500\u2500\u2500\u2500              \u2500\u2500\u2500\u2500\u2500              \u23a5\\n    \u23a2\u239b \u2148\u22c5\u03b4    2         2   \u239e    2    \u239b     \u2148\u22c5\u03b4\u239e    2                \u23a5\\n    \u23a2\u239d\u212f   \u22c5sin (\u03b8) + cos (\u03b8)\u23a0\u22c5\u212f       \u239d1 - \u212f   \u23a0\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)\u23a5\\n    \u23a2                                                                \u23a5\\n    \u23a2            -\u2148\u22c5\u03b4                                           -\u2148\u22c5\u03b4 \u23a5\\n    \u23a2            \u2500\u2500\u2500\u2500\u2500                                          \u2500\u2500\u2500\u2500\u2500\u23a5\\n    \u23a2\u239b     \u2148\u22c5\u03b4\u239e    2                  \u239b \u2148\u22c5\u03b4    2         2   \u239e    2  \u23a5\\n    \u23a3\u239d1 - \u212f   \u23a0\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u239d\u212f   \u22c5cos (\u03b8) + sin (\u03b8)\u23a0\u22c5\u212f     \u23a6\\n\\n    '\n    R = Matrix([[cos(theta) ** 2 + exp(I * delta) * sin(theta) ** 2, (1 - exp(I * delta)) * cos(theta) * sin(theta)], [(1 - exp(I * delta)) * cos(theta) * sin(theta), sin(theta) ** 2 + exp(I * delta) * cos(theta) ** 2]])\n    return R * exp(-I * delta / 2)"
        ]
    },
    {
        "func_name": "half_wave_retarder",
        "original": "def half_wave_retarder(theta):\n    \"\"\"A half-wave retarder Jones matrix at angle ``theta``.\n\n    Parameters\n    ==========\n\n    theta : numeric type or SymPy Symbol\n        The angle of the fast axis relative to the horizontal plane.\n\n    Returns\n    =======\n\n    SymPy Matrix\n        A Jones matrix representing the retarder.\n\n    Examples\n    ========\n\n    A generic half-wave plate.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import half_wave_retarder\n    >>> theta= symbols(\"theta\", real=True)\n    >>> HWP = half_wave_retarder(theta)\n    >>> pprint(HWP, use_unicode=True)\n    \u23a1   \u239b     2         2   \u239e                        \u23a4\n    \u23a2-\u2148\u22c5\u239d- sin (\u03b8) + cos (\u03b8)\u23a0    -2\u22c5\u2148\u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u23a5\n    \u23a2                                                \u23a5\n    \u23a2                             \u239b   2         2   \u239e\u23a5\n    \u23a3   -2\u22c5\u2148\u22c5sin(\u03b8)\u22c5cos(\u03b8)     -\u2148\u22c5\u239dsin (\u03b8) - cos (\u03b8)\u23a0\u23a6\n\n    \"\"\"\n    return phase_retarder(theta, pi)",
        "mutated": [
            "def half_wave_retarder(theta):\n    if False:\n        i = 10\n    'A half-wave retarder Jones matrix at angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the fast axis relative to the horizontal plane.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the retarder.\\n\\n    Examples\\n    ========\\n\\n    A generic half-wave plate.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import half_wave_retarder\\n    >>> theta= symbols(\"theta\", real=True)\\n    >>> HWP = half_wave_retarder(theta)\\n    >>> pprint(HWP, use_unicode=True)\\n    \u23a1   \u239b     2         2   \u239e                        \u23a4\\n    \u23a2-\u2148\u22c5\u239d- sin (\u03b8) + cos (\u03b8)\u23a0    -2\u22c5\u2148\u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u23a5\\n    \u23a2                                                \u23a5\\n    \u23a2                             \u239b   2         2   \u239e\u23a5\\n    \u23a3   -2\u22c5\u2148\u22c5sin(\u03b8)\u22c5cos(\u03b8)     -\u2148\u22c5\u239dsin (\u03b8) - cos (\u03b8)\u23a0\u23a6\\n\\n    '\n    return phase_retarder(theta, pi)",
            "def half_wave_retarder(theta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A half-wave retarder Jones matrix at angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the fast axis relative to the horizontal plane.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the retarder.\\n\\n    Examples\\n    ========\\n\\n    A generic half-wave plate.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import half_wave_retarder\\n    >>> theta= symbols(\"theta\", real=True)\\n    >>> HWP = half_wave_retarder(theta)\\n    >>> pprint(HWP, use_unicode=True)\\n    \u23a1   \u239b     2         2   \u239e                        \u23a4\\n    \u23a2-\u2148\u22c5\u239d- sin (\u03b8) + cos (\u03b8)\u23a0    -2\u22c5\u2148\u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u23a5\\n    \u23a2                                                \u23a5\\n    \u23a2                             \u239b   2         2   \u239e\u23a5\\n    \u23a3   -2\u22c5\u2148\u22c5sin(\u03b8)\u22c5cos(\u03b8)     -\u2148\u22c5\u239dsin (\u03b8) - cos (\u03b8)\u23a0\u23a6\\n\\n    '\n    return phase_retarder(theta, pi)",
            "def half_wave_retarder(theta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A half-wave retarder Jones matrix at angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the fast axis relative to the horizontal plane.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the retarder.\\n\\n    Examples\\n    ========\\n\\n    A generic half-wave plate.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import half_wave_retarder\\n    >>> theta= symbols(\"theta\", real=True)\\n    >>> HWP = half_wave_retarder(theta)\\n    >>> pprint(HWP, use_unicode=True)\\n    \u23a1   \u239b     2         2   \u239e                        \u23a4\\n    \u23a2-\u2148\u22c5\u239d- sin (\u03b8) + cos (\u03b8)\u23a0    -2\u22c5\u2148\u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u23a5\\n    \u23a2                                                \u23a5\\n    \u23a2                             \u239b   2         2   \u239e\u23a5\\n    \u23a3   -2\u22c5\u2148\u22c5sin(\u03b8)\u22c5cos(\u03b8)     -\u2148\u22c5\u239dsin (\u03b8) - cos (\u03b8)\u23a0\u23a6\\n\\n    '\n    return phase_retarder(theta, pi)",
            "def half_wave_retarder(theta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A half-wave retarder Jones matrix at angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the fast axis relative to the horizontal plane.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the retarder.\\n\\n    Examples\\n    ========\\n\\n    A generic half-wave plate.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import half_wave_retarder\\n    >>> theta= symbols(\"theta\", real=True)\\n    >>> HWP = half_wave_retarder(theta)\\n    >>> pprint(HWP, use_unicode=True)\\n    \u23a1   \u239b     2         2   \u239e                        \u23a4\\n    \u23a2-\u2148\u22c5\u239d- sin (\u03b8) + cos (\u03b8)\u23a0    -2\u22c5\u2148\u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u23a5\\n    \u23a2                                                \u23a5\\n    \u23a2                             \u239b   2         2   \u239e\u23a5\\n    \u23a3   -2\u22c5\u2148\u22c5sin(\u03b8)\u22c5cos(\u03b8)     -\u2148\u22c5\u239dsin (\u03b8) - cos (\u03b8)\u23a0\u23a6\\n\\n    '\n    return phase_retarder(theta, pi)",
            "def half_wave_retarder(theta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A half-wave retarder Jones matrix at angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the fast axis relative to the horizontal plane.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the retarder.\\n\\n    Examples\\n    ========\\n\\n    A generic half-wave plate.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import half_wave_retarder\\n    >>> theta= symbols(\"theta\", real=True)\\n    >>> HWP = half_wave_retarder(theta)\\n    >>> pprint(HWP, use_unicode=True)\\n    \u23a1   \u239b     2         2   \u239e                        \u23a4\\n    \u23a2-\u2148\u22c5\u239d- sin (\u03b8) + cos (\u03b8)\u23a0    -2\u22c5\u2148\u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u23a5\\n    \u23a2                                                \u23a5\\n    \u23a2                             \u239b   2         2   \u239e\u23a5\\n    \u23a3   -2\u22c5\u2148\u22c5sin(\u03b8)\u22c5cos(\u03b8)     -\u2148\u22c5\u239dsin (\u03b8) - cos (\u03b8)\u23a0\u23a6\\n\\n    '\n    return phase_retarder(theta, pi)"
        ]
    },
    {
        "func_name": "quarter_wave_retarder",
        "original": "def quarter_wave_retarder(theta):\n    \"\"\"A quarter-wave retarder Jones matrix at angle ``theta``.\n\n    Parameters\n    ==========\n\n    theta : numeric type or SymPy Symbol\n        The angle of the fast axis relative to the horizontal plane.\n\n    Returns\n    =======\n\n    SymPy Matrix\n        A Jones matrix representing the retarder.\n\n    Examples\n    ========\n\n    A generic quarter-wave plate.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import quarter_wave_retarder\n    >>> theta= symbols(\"theta\", real=True)\n    >>> QWP = quarter_wave_retarder(theta)\n    >>> pprint(QWP, use_unicode=True)\n    \u23a1                       -\u2148\u22c5\u03c0            -\u2148\u22c5\u03c0               \u23a4\n    \u23a2                       \u2500\u2500\u2500\u2500\u2500           \u2500\u2500\u2500\u2500\u2500              \u23a5\n    \u23a2\u239b     2         2   \u239e    4               4                \u23a5\n    \u23a2\u239d\u2148\u22c5sin (\u03b8) + cos (\u03b8)\u23a0\u22c5\u212f       (1 - \u2148)\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)\u23a5\n    \u23a2                                                          \u23a5\n    \u23a2         -\u2148\u22c5\u03c0                                        -\u2148\u22c5\u03c0 \u23a5\n    \u23a2         \u2500\u2500\u2500\u2500\u2500                                       \u2500\u2500\u2500\u2500\u2500\u23a5\n    \u23a2           4                  \u239b   2           2   \u239e    4  \u23a5\n    \u23a3(1 - \u2148)\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u239dsin (\u03b8) + \u2148\u22c5cos (\u03b8)\u23a0\u22c5\u212f     \u23a6\n\n    \"\"\"\n    return phase_retarder(theta, pi / 2)",
        "mutated": [
            "def quarter_wave_retarder(theta):\n    if False:\n        i = 10\n    'A quarter-wave retarder Jones matrix at angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the fast axis relative to the horizontal plane.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the retarder.\\n\\n    Examples\\n    ========\\n\\n    A generic quarter-wave plate.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import quarter_wave_retarder\\n    >>> theta= symbols(\"theta\", real=True)\\n    >>> QWP = quarter_wave_retarder(theta)\\n    >>> pprint(QWP, use_unicode=True)\\n    \u23a1                       -\u2148\u22c5\u03c0            -\u2148\u22c5\u03c0               \u23a4\\n    \u23a2                       \u2500\u2500\u2500\u2500\u2500           \u2500\u2500\u2500\u2500\u2500              \u23a5\\n    \u23a2\u239b     2         2   \u239e    4               4                \u23a5\\n    \u23a2\u239d\u2148\u22c5sin (\u03b8) + cos (\u03b8)\u23a0\u22c5\u212f       (1 - \u2148)\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)\u23a5\\n    \u23a2                                                          \u23a5\\n    \u23a2         -\u2148\u22c5\u03c0                                        -\u2148\u22c5\u03c0 \u23a5\\n    \u23a2         \u2500\u2500\u2500\u2500\u2500                                       \u2500\u2500\u2500\u2500\u2500\u23a5\\n    \u23a2           4                  \u239b   2           2   \u239e    4  \u23a5\\n    \u23a3(1 - \u2148)\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u239dsin (\u03b8) + \u2148\u22c5cos (\u03b8)\u23a0\u22c5\u212f     \u23a6\\n\\n    '\n    return phase_retarder(theta, pi / 2)",
            "def quarter_wave_retarder(theta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A quarter-wave retarder Jones matrix at angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the fast axis relative to the horizontal plane.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the retarder.\\n\\n    Examples\\n    ========\\n\\n    A generic quarter-wave plate.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import quarter_wave_retarder\\n    >>> theta= symbols(\"theta\", real=True)\\n    >>> QWP = quarter_wave_retarder(theta)\\n    >>> pprint(QWP, use_unicode=True)\\n    \u23a1                       -\u2148\u22c5\u03c0            -\u2148\u22c5\u03c0               \u23a4\\n    \u23a2                       \u2500\u2500\u2500\u2500\u2500           \u2500\u2500\u2500\u2500\u2500              \u23a5\\n    \u23a2\u239b     2         2   \u239e    4               4                \u23a5\\n    \u23a2\u239d\u2148\u22c5sin (\u03b8) + cos (\u03b8)\u23a0\u22c5\u212f       (1 - \u2148)\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)\u23a5\\n    \u23a2                                                          \u23a5\\n    \u23a2         -\u2148\u22c5\u03c0                                        -\u2148\u22c5\u03c0 \u23a5\\n    \u23a2         \u2500\u2500\u2500\u2500\u2500                                       \u2500\u2500\u2500\u2500\u2500\u23a5\\n    \u23a2           4                  \u239b   2           2   \u239e    4  \u23a5\\n    \u23a3(1 - \u2148)\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u239dsin (\u03b8) + \u2148\u22c5cos (\u03b8)\u23a0\u22c5\u212f     \u23a6\\n\\n    '\n    return phase_retarder(theta, pi / 2)",
            "def quarter_wave_retarder(theta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A quarter-wave retarder Jones matrix at angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the fast axis relative to the horizontal plane.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the retarder.\\n\\n    Examples\\n    ========\\n\\n    A generic quarter-wave plate.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import quarter_wave_retarder\\n    >>> theta= symbols(\"theta\", real=True)\\n    >>> QWP = quarter_wave_retarder(theta)\\n    >>> pprint(QWP, use_unicode=True)\\n    \u23a1                       -\u2148\u22c5\u03c0            -\u2148\u22c5\u03c0               \u23a4\\n    \u23a2                       \u2500\u2500\u2500\u2500\u2500           \u2500\u2500\u2500\u2500\u2500              \u23a5\\n    \u23a2\u239b     2         2   \u239e    4               4                \u23a5\\n    \u23a2\u239d\u2148\u22c5sin (\u03b8) + cos (\u03b8)\u23a0\u22c5\u212f       (1 - \u2148)\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)\u23a5\\n    \u23a2                                                          \u23a5\\n    \u23a2         -\u2148\u22c5\u03c0                                        -\u2148\u22c5\u03c0 \u23a5\\n    \u23a2         \u2500\u2500\u2500\u2500\u2500                                       \u2500\u2500\u2500\u2500\u2500\u23a5\\n    \u23a2           4                  \u239b   2           2   \u239e    4  \u23a5\\n    \u23a3(1 - \u2148)\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u239dsin (\u03b8) + \u2148\u22c5cos (\u03b8)\u23a0\u22c5\u212f     \u23a6\\n\\n    '\n    return phase_retarder(theta, pi / 2)",
            "def quarter_wave_retarder(theta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A quarter-wave retarder Jones matrix at angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the fast axis relative to the horizontal plane.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the retarder.\\n\\n    Examples\\n    ========\\n\\n    A generic quarter-wave plate.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import quarter_wave_retarder\\n    >>> theta= symbols(\"theta\", real=True)\\n    >>> QWP = quarter_wave_retarder(theta)\\n    >>> pprint(QWP, use_unicode=True)\\n    \u23a1                       -\u2148\u22c5\u03c0            -\u2148\u22c5\u03c0               \u23a4\\n    \u23a2                       \u2500\u2500\u2500\u2500\u2500           \u2500\u2500\u2500\u2500\u2500              \u23a5\\n    \u23a2\u239b     2         2   \u239e    4               4                \u23a5\\n    \u23a2\u239d\u2148\u22c5sin (\u03b8) + cos (\u03b8)\u23a0\u22c5\u212f       (1 - \u2148)\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)\u23a5\\n    \u23a2                                                          \u23a5\\n    \u23a2         -\u2148\u22c5\u03c0                                        -\u2148\u22c5\u03c0 \u23a5\\n    \u23a2         \u2500\u2500\u2500\u2500\u2500                                       \u2500\u2500\u2500\u2500\u2500\u23a5\\n    \u23a2           4                  \u239b   2           2   \u239e    4  \u23a5\\n    \u23a3(1 - \u2148)\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u239dsin (\u03b8) + \u2148\u22c5cos (\u03b8)\u23a0\u22c5\u212f     \u23a6\\n\\n    '\n    return phase_retarder(theta, pi / 2)",
            "def quarter_wave_retarder(theta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A quarter-wave retarder Jones matrix at angle ``theta``.\\n\\n    Parameters\\n    ==========\\n\\n    theta : numeric type or SymPy Symbol\\n        The angle of the fast axis relative to the horizontal plane.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the retarder.\\n\\n    Examples\\n    ========\\n\\n    A generic quarter-wave plate.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import quarter_wave_retarder\\n    >>> theta= symbols(\"theta\", real=True)\\n    >>> QWP = quarter_wave_retarder(theta)\\n    >>> pprint(QWP, use_unicode=True)\\n    \u23a1                       -\u2148\u22c5\u03c0            -\u2148\u22c5\u03c0               \u23a4\\n    \u23a2                       \u2500\u2500\u2500\u2500\u2500           \u2500\u2500\u2500\u2500\u2500              \u23a5\\n    \u23a2\u239b     2         2   \u239e    4               4                \u23a5\\n    \u23a2\u239d\u2148\u22c5sin (\u03b8) + cos (\u03b8)\u23a0\u22c5\u212f       (1 - \u2148)\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)\u23a5\\n    \u23a2                                                          \u23a5\\n    \u23a2         -\u2148\u22c5\u03c0                                        -\u2148\u22c5\u03c0 \u23a5\\n    \u23a2         \u2500\u2500\u2500\u2500\u2500                                       \u2500\u2500\u2500\u2500\u2500\u23a5\\n    \u23a2           4                  \u239b   2           2   \u239e    4  \u23a5\\n    \u23a3(1 - \u2148)\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u239dsin (\u03b8) + \u2148\u22c5cos (\u03b8)\u23a0\u22c5\u212f     \u23a6\\n\\n    '\n    return phase_retarder(theta, pi / 2)"
        ]
    },
    {
        "func_name": "transmissive_filter",
        "original": "def transmissive_filter(T):\n    \"\"\"An attenuator Jones matrix with transmittance ``T``.\n\n    Parameters\n    ==========\n\n    T : numeric type or SymPy Symbol\n        The transmittance of the attenuator.\n\n    Returns\n    =======\n\n    SymPy Matrix\n        A Jones matrix representing the filter.\n\n    Examples\n    ========\n\n    A generic filter.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import transmissive_filter\n    >>> T = symbols(\"T\", real=True)\n    >>> NDF = transmissive_filter(T)\n    >>> pprint(NDF, use_unicode=True)\n    \u23a1\u221aT  0 \u23a4\n    \u23a2      \u23a5\n    \u23a30   \u221aT\u23a6\n\n    \"\"\"\n    return Matrix([[sqrt(T), 0], [0, sqrt(T)]])",
        "mutated": [
            "def transmissive_filter(T):\n    if False:\n        i = 10\n    'An attenuator Jones matrix with transmittance ``T``.\\n\\n    Parameters\\n    ==========\\n\\n    T : numeric type or SymPy Symbol\\n        The transmittance of the attenuator.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the filter.\\n\\n    Examples\\n    ========\\n\\n    A generic filter.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import transmissive_filter\\n    >>> T = symbols(\"T\", real=True)\\n    >>> NDF = transmissive_filter(T)\\n    >>> pprint(NDF, use_unicode=True)\\n    \u23a1\u221aT  0 \u23a4\\n    \u23a2      \u23a5\\n    \u23a30   \u221aT\u23a6\\n\\n    '\n    return Matrix([[sqrt(T), 0], [0, sqrt(T)]])",
            "def transmissive_filter(T):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'An attenuator Jones matrix with transmittance ``T``.\\n\\n    Parameters\\n    ==========\\n\\n    T : numeric type or SymPy Symbol\\n        The transmittance of the attenuator.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the filter.\\n\\n    Examples\\n    ========\\n\\n    A generic filter.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import transmissive_filter\\n    >>> T = symbols(\"T\", real=True)\\n    >>> NDF = transmissive_filter(T)\\n    >>> pprint(NDF, use_unicode=True)\\n    \u23a1\u221aT  0 \u23a4\\n    \u23a2      \u23a5\\n    \u23a30   \u221aT\u23a6\\n\\n    '\n    return Matrix([[sqrt(T), 0], [0, sqrt(T)]])",
            "def transmissive_filter(T):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'An attenuator Jones matrix with transmittance ``T``.\\n\\n    Parameters\\n    ==========\\n\\n    T : numeric type or SymPy Symbol\\n        The transmittance of the attenuator.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the filter.\\n\\n    Examples\\n    ========\\n\\n    A generic filter.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import transmissive_filter\\n    >>> T = symbols(\"T\", real=True)\\n    >>> NDF = transmissive_filter(T)\\n    >>> pprint(NDF, use_unicode=True)\\n    \u23a1\u221aT  0 \u23a4\\n    \u23a2      \u23a5\\n    \u23a30   \u221aT\u23a6\\n\\n    '\n    return Matrix([[sqrt(T), 0], [0, sqrt(T)]])",
            "def transmissive_filter(T):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'An attenuator Jones matrix with transmittance ``T``.\\n\\n    Parameters\\n    ==========\\n\\n    T : numeric type or SymPy Symbol\\n        The transmittance of the attenuator.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the filter.\\n\\n    Examples\\n    ========\\n\\n    A generic filter.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import transmissive_filter\\n    >>> T = symbols(\"T\", real=True)\\n    >>> NDF = transmissive_filter(T)\\n    >>> pprint(NDF, use_unicode=True)\\n    \u23a1\u221aT  0 \u23a4\\n    \u23a2      \u23a5\\n    \u23a30   \u221aT\u23a6\\n\\n    '\n    return Matrix([[sqrt(T), 0], [0, sqrt(T)]])",
            "def transmissive_filter(T):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'An attenuator Jones matrix with transmittance ``T``.\\n\\n    Parameters\\n    ==========\\n\\n    T : numeric type or SymPy Symbol\\n        The transmittance of the attenuator.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the filter.\\n\\n    Examples\\n    ========\\n\\n    A generic filter.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import transmissive_filter\\n    >>> T = symbols(\"T\", real=True)\\n    >>> NDF = transmissive_filter(T)\\n    >>> pprint(NDF, use_unicode=True)\\n    \u23a1\u221aT  0 \u23a4\\n    \u23a2      \u23a5\\n    \u23a30   \u221aT\u23a6\\n\\n    '\n    return Matrix([[sqrt(T), 0], [0, sqrt(T)]])"
        ]
    },
    {
        "func_name": "reflective_filter",
        "original": "def reflective_filter(R):\n    \"\"\"A reflective filter Jones matrix with reflectance ``R``.\n\n    Parameters\n    ==========\n\n    R : numeric type or SymPy Symbol\n        The reflectance of the filter.\n\n    Returns\n    =======\n\n    SymPy Matrix\n        A Jones matrix representing the filter.\n\n    Examples\n    ========\n\n    A generic filter.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import reflective_filter\n    >>> R = symbols(\"R\", real=True)\n    >>> pprint(reflective_filter(R), use_unicode=True)\n    \u23a1\u221aR   0 \u23a4\n    \u23a2       \u23a5\n    \u23a30   -\u221aR\u23a6\n\n    \"\"\"\n    return Matrix([[sqrt(R), 0], [0, -sqrt(R)]])",
        "mutated": [
            "def reflective_filter(R):\n    if False:\n        i = 10\n    'A reflective filter Jones matrix with reflectance ``R``.\\n\\n    Parameters\\n    ==========\\n\\n    R : numeric type or SymPy Symbol\\n        The reflectance of the filter.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the filter.\\n\\n    Examples\\n    ========\\n\\n    A generic filter.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import reflective_filter\\n    >>> R = symbols(\"R\", real=True)\\n    >>> pprint(reflective_filter(R), use_unicode=True)\\n    \u23a1\u221aR   0 \u23a4\\n    \u23a2       \u23a5\\n    \u23a30   -\u221aR\u23a6\\n\\n    '\n    return Matrix([[sqrt(R), 0], [0, -sqrt(R)]])",
            "def reflective_filter(R):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A reflective filter Jones matrix with reflectance ``R``.\\n\\n    Parameters\\n    ==========\\n\\n    R : numeric type or SymPy Symbol\\n        The reflectance of the filter.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the filter.\\n\\n    Examples\\n    ========\\n\\n    A generic filter.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import reflective_filter\\n    >>> R = symbols(\"R\", real=True)\\n    >>> pprint(reflective_filter(R), use_unicode=True)\\n    \u23a1\u221aR   0 \u23a4\\n    \u23a2       \u23a5\\n    \u23a30   -\u221aR\u23a6\\n\\n    '\n    return Matrix([[sqrt(R), 0], [0, -sqrt(R)]])",
            "def reflective_filter(R):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A reflective filter Jones matrix with reflectance ``R``.\\n\\n    Parameters\\n    ==========\\n\\n    R : numeric type or SymPy Symbol\\n        The reflectance of the filter.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the filter.\\n\\n    Examples\\n    ========\\n\\n    A generic filter.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import reflective_filter\\n    >>> R = symbols(\"R\", real=True)\\n    >>> pprint(reflective_filter(R), use_unicode=True)\\n    \u23a1\u221aR   0 \u23a4\\n    \u23a2       \u23a5\\n    \u23a30   -\u221aR\u23a6\\n\\n    '\n    return Matrix([[sqrt(R), 0], [0, -sqrt(R)]])",
            "def reflective_filter(R):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A reflective filter Jones matrix with reflectance ``R``.\\n\\n    Parameters\\n    ==========\\n\\n    R : numeric type or SymPy Symbol\\n        The reflectance of the filter.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the filter.\\n\\n    Examples\\n    ========\\n\\n    A generic filter.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import reflective_filter\\n    >>> R = symbols(\"R\", real=True)\\n    >>> pprint(reflective_filter(R), use_unicode=True)\\n    \u23a1\u221aR   0 \u23a4\\n    \u23a2       \u23a5\\n    \u23a30   -\u221aR\u23a6\\n\\n    '\n    return Matrix([[sqrt(R), 0], [0, -sqrt(R)]])",
            "def reflective_filter(R):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A reflective filter Jones matrix with reflectance ``R``.\\n\\n    Parameters\\n    ==========\\n\\n    R : numeric type or SymPy Symbol\\n        The reflectance of the filter.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A Jones matrix representing the filter.\\n\\n    Examples\\n    ========\\n\\n    A generic filter.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import reflective_filter\\n    >>> R = symbols(\"R\", real=True)\\n    >>> pprint(reflective_filter(R), use_unicode=True)\\n    \u23a1\u221aR   0 \u23a4\\n    \u23a2       \u23a5\\n    \u23a30   -\u221aR\u23a6\\n\\n    '\n    return Matrix([[sqrt(R), 0], [0, -sqrt(R)]])"
        ]
    },
    {
        "func_name": "mueller_matrix",
        "original": "def mueller_matrix(J):\n    \"\"\"The Mueller matrix corresponding to Jones matrix `J`.\n\n    Parameters\n    ==========\n\n    J : SymPy Matrix\n        A Jones matrix.\n\n    Returns\n    =======\n\n    SymPy Matrix\n        The corresponding Mueller matrix.\n\n    Examples\n    ========\n\n    Generic optical components.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import (mueller_matrix,\n    ...     linear_polarizer, half_wave_retarder, quarter_wave_retarder)\n    >>> theta = symbols(\"theta\", real=True)\n\n    A linear_polarizer\n\n    >>> pprint(mueller_matrix(linear_polarizer(theta)), use_unicode=True)\n    \u23a1            cos(2\u22c5\u03b8)      sin(2\u22c5\u03b8)     \u23a4\n    \u23a2  1/2       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    0\u23a5\n    \u23a2               2             2         \u23a5\n    \u23a2                                       \u23a5\n    \u23a2cos(2\u22c5\u03b8)  cos(4\u22c5\u03b8)   1    sin(4\u22c5\u03b8)     \u23a5\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 + \u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    0\u23a5\n    \u23a2   2         4       4       4         \u23a5\n    \u23a2                                       \u23a5\n    \u23a2sin(2\u22c5\u03b8)    sin(4\u22c5\u03b8)    1   cos(4\u22c5\u03b8)   \u23a5\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500 - \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  0\u23a5\n    \u23a2   2           4        4      4       \u23a5\n    \u23a2                                       \u23a5\n    \u23a3   0           0             0        0\u23a6\n\n    A half-wave plate\n\n    >>> pprint(mueller_matrix(half_wave_retarder(theta)), use_unicode=True)\n    \u23a11              0                           0               0 \u23a4\n    \u23a2                                                             \u23a5\n    \u23a2        4           2                                        \u23a5\n    \u23a20  8\u22c5sin (\u03b8) - 8\u22c5sin (\u03b8) + 1           sin(4\u22c5\u03b8)            0 \u23a5\n    \u23a2                                                             \u23a5\n    \u23a2                                     4           2           \u23a5\n    \u23a20          sin(4\u22c5\u03b8)           - 8\u22c5sin (\u03b8) + 8\u22c5sin (\u03b8) - 1  0 \u23a5\n    \u23a2                                                             \u23a5\n    \u23a30              0                           0               -1\u23a6\n\n    A quarter-wave plate\n\n    >>> pprint(mueller_matrix(quarter_wave_retarder(theta)), use_unicode=True)\n    \u23a11       0             0            0    \u23a4\n    \u23a2                                        \u23a5\n    \u23a2   cos(4\u22c5\u03b8)   1    sin(4\u22c5\u03b8)             \u23a5\n    \u23a20  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 + \u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    -sin(2\u22c5\u03b8)\u23a5\n    \u23a2      2       2       2                 \u23a5\n    \u23a2                                        \u23a5\n    \u23a2     sin(4\u22c5\u03b8)    1   cos(4\u22c5\u03b8)           \u23a5\n    \u23a20    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500 - \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  cos(2\u22c5\u03b8) \u23a5\n    \u23a2        2        2      2               \u23a5\n    \u23a2                                        \u23a5\n    \u23a30    sin(2\u22c5\u03b8)     -cos(2\u22c5\u03b8)        0    \u23a6\n\n    \"\"\"\n    A = Matrix([[1, 0, 0, 1], [1, 0, 0, -1], [0, 1, 1, 0], [0, -I, I, 0]])\n    return simplify(A * TensorProduct(J, J.conjugate()) * A.inv())",
        "mutated": [
            "def mueller_matrix(J):\n    if False:\n        i = 10\n    'The Mueller matrix corresponding to Jones matrix `J`.\\n\\n    Parameters\\n    ==========\\n\\n    J : SymPy Matrix\\n        A Jones matrix.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        The corresponding Mueller matrix.\\n\\n    Examples\\n    ========\\n\\n    Generic optical components.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import (mueller_matrix,\\n    ...     linear_polarizer, half_wave_retarder, quarter_wave_retarder)\\n    >>> theta = symbols(\"theta\", real=True)\\n\\n    A linear_polarizer\\n\\n    >>> pprint(mueller_matrix(linear_polarizer(theta)), use_unicode=True)\\n    \u23a1            cos(2\u22c5\u03b8)      sin(2\u22c5\u03b8)     \u23a4\\n    \u23a2  1/2       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    0\u23a5\\n    \u23a2               2             2         \u23a5\\n    \u23a2                                       \u23a5\\n    \u23a2cos(2\u22c5\u03b8)  cos(4\u22c5\u03b8)   1    sin(4\u22c5\u03b8)     \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 + \u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    0\u23a5\\n    \u23a2   2         4       4       4         \u23a5\\n    \u23a2                                       \u23a5\\n    \u23a2sin(2\u22c5\u03b8)    sin(4\u22c5\u03b8)    1   cos(4\u22c5\u03b8)   \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500 - \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  0\u23a5\\n    \u23a2   2           4        4      4       \u23a5\\n    \u23a2                                       \u23a5\\n    \u23a3   0           0             0        0\u23a6\\n\\n    A half-wave plate\\n\\n    >>> pprint(mueller_matrix(half_wave_retarder(theta)), use_unicode=True)\\n    \u23a11              0                           0               0 \u23a4\\n    \u23a2                                                             \u23a5\\n    \u23a2        4           2                                        \u23a5\\n    \u23a20  8\u22c5sin (\u03b8) - 8\u22c5sin (\u03b8) + 1           sin(4\u22c5\u03b8)            0 \u23a5\\n    \u23a2                                                             \u23a5\\n    \u23a2                                     4           2           \u23a5\\n    \u23a20          sin(4\u22c5\u03b8)           - 8\u22c5sin (\u03b8) + 8\u22c5sin (\u03b8) - 1  0 \u23a5\\n    \u23a2                                                             \u23a5\\n    \u23a30              0                           0               -1\u23a6\\n\\n    A quarter-wave plate\\n\\n    >>> pprint(mueller_matrix(quarter_wave_retarder(theta)), use_unicode=True)\\n    \u23a11       0             0            0    \u23a4\\n    \u23a2                                        \u23a5\\n    \u23a2   cos(4\u22c5\u03b8)   1    sin(4\u22c5\u03b8)             \u23a5\\n    \u23a20  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 + \u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    -sin(2\u22c5\u03b8)\u23a5\\n    \u23a2      2       2       2                 \u23a5\\n    \u23a2                                        \u23a5\\n    \u23a2     sin(4\u22c5\u03b8)    1   cos(4\u22c5\u03b8)           \u23a5\\n    \u23a20    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500 - \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  cos(2\u22c5\u03b8) \u23a5\\n    \u23a2        2        2      2               \u23a5\\n    \u23a2                                        \u23a5\\n    \u23a30    sin(2\u22c5\u03b8)     -cos(2\u22c5\u03b8)        0    \u23a6\\n\\n    '\n    A = Matrix([[1, 0, 0, 1], [1, 0, 0, -1], [0, 1, 1, 0], [0, -I, I, 0]])\n    return simplify(A * TensorProduct(J, J.conjugate()) * A.inv())",
            "def mueller_matrix(J):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'The Mueller matrix corresponding to Jones matrix `J`.\\n\\n    Parameters\\n    ==========\\n\\n    J : SymPy Matrix\\n        A Jones matrix.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        The corresponding Mueller matrix.\\n\\n    Examples\\n    ========\\n\\n    Generic optical components.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import (mueller_matrix,\\n    ...     linear_polarizer, half_wave_retarder, quarter_wave_retarder)\\n    >>> theta = symbols(\"theta\", real=True)\\n\\n    A linear_polarizer\\n\\n    >>> pprint(mueller_matrix(linear_polarizer(theta)), use_unicode=True)\\n    \u23a1            cos(2\u22c5\u03b8)      sin(2\u22c5\u03b8)     \u23a4\\n    \u23a2  1/2       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    0\u23a5\\n    \u23a2               2             2         \u23a5\\n    \u23a2                                       \u23a5\\n    \u23a2cos(2\u22c5\u03b8)  cos(4\u22c5\u03b8)   1    sin(4\u22c5\u03b8)     \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 + \u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    0\u23a5\\n    \u23a2   2         4       4       4         \u23a5\\n    \u23a2                                       \u23a5\\n    \u23a2sin(2\u22c5\u03b8)    sin(4\u22c5\u03b8)    1   cos(4\u22c5\u03b8)   \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500 - \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  0\u23a5\\n    \u23a2   2           4        4      4       \u23a5\\n    \u23a2                                       \u23a5\\n    \u23a3   0           0             0        0\u23a6\\n\\n    A half-wave plate\\n\\n    >>> pprint(mueller_matrix(half_wave_retarder(theta)), use_unicode=True)\\n    \u23a11              0                           0               0 \u23a4\\n    \u23a2                                                             \u23a5\\n    \u23a2        4           2                                        \u23a5\\n    \u23a20  8\u22c5sin (\u03b8) - 8\u22c5sin (\u03b8) + 1           sin(4\u22c5\u03b8)            0 \u23a5\\n    \u23a2                                                             \u23a5\\n    \u23a2                                     4           2           \u23a5\\n    \u23a20          sin(4\u22c5\u03b8)           - 8\u22c5sin (\u03b8) + 8\u22c5sin (\u03b8) - 1  0 \u23a5\\n    \u23a2                                                             \u23a5\\n    \u23a30              0                           0               -1\u23a6\\n\\n    A quarter-wave plate\\n\\n    >>> pprint(mueller_matrix(quarter_wave_retarder(theta)), use_unicode=True)\\n    \u23a11       0             0            0    \u23a4\\n    \u23a2                                        \u23a5\\n    \u23a2   cos(4\u22c5\u03b8)   1    sin(4\u22c5\u03b8)             \u23a5\\n    \u23a20  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 + \u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    -sin(2\u22c5\u03b8)\u23a5\\n    \u23a2      2       2       2                 \u23a5\\n    \u23a2                                        \u23a5\\n    \u23a2     sin(4\u22c5\u03b8)    1   cos(4\u22c5\u03b8)           \u23a5\\n    \u23a20    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500 - \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  cos(2\u22c5\u03b8) \u23a5\\n    \u23a2        2        2      2               \u23a5\\n    \u23a2                                        \u23a5\\n    \u23a30    sin(2\u22c5\u03b8)     -cos(2\u22c5\u03b8)        0    \u23a6\\n\\n    '\n    A = Matrix([[1, 0, 0, 1], [1, 0, 0, -1], [0, 1, 1, 0], [0, -I, I, 0]])\n    return simplify(A * TensorProduct(J, J.conjugate()) * A.inv())",
            "def mueller_matrix(J):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'The Mueller matrix corresponding to Jones matrix `J`.\\n\\n    Parameters\\n    ==========\\n\\n    J : SymPy Matrix\\n        A Jones matrix.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        The corresponding Mueller matrix.\\n\\n    Examples\\n    ========\\n\\n    Generic optical components.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import (mueller_matrix,\\n    ...     linear_polarizer, half_wave_retarder, quarter_wave_retarder)\\n    >>> theta = symbols(\"theta\", real=True)\\n\\n    A linear_polarizer\\n\\n    >>> pprint(mueller_matrix(linear_polarizer(theta)), use_unicode=True)\\n    \u23a1            cos(2\u22c5\u03b8)      sin(2\u22c5\u03b8)     \u23a4\\n    \u23a2  1/2       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    0\u23a5\\n    \u23a2               2             2         \u23a5\\n    \u23a2                                       \u23a5\\n    \u23a2cos(2\u22c5\u03b8)  cos(4\u22c5\u03b8)   1    sin(4\u22c5\u03b8)     \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 + \u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    0\u23a5\\n    \u23a2   2         4       4       4         \u23a5\\n    \u23a2                                       \u23a5\\n    \u23a2sin(2\u22c5\u03b8)    sin(4\u22c5\u03b8)    1   cos(4\u22c5\u03b8)   \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500 - \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  0\u23a5\\n    \u23a2   2           4        4      4       \u23a5\\n    \u23a2                                       \u23a5\\n    \u23a3   0           0             0        0\u23a6\\n\\n    A half-wave plate\\n\\n    >>> pprint(mueller_matrix(half_wave_retarder(theta)), use_unicode=True)\\n    \u23a11              0                           0               0 \u23a4\\n    \u23a2                                                             \u23a5\\n    \u23a2        4           2                                        \u23a5\\n    \u23a20  8\u22c5sin (\u03b8) - 8\u22c5sin (\u03b8) + 1           sin(4\u22c5\u03b8)            0 \u23a5\\n    \u23a2                                                             \u23a5\\n    \u23a2                                     4           2           \u23a5\\n    \u23a20          sin(4\u22c5\u03b8)           - 8\u22c5sin (\u03b8) + 8\u22c5sin (\u03b8) - 1  0 \u23a5\\n    \u23a2                                                             \u23a5\\n    \u23a30              0                           0               -1\u23a6\\n\\n    A quarter-wave plate\\n\\n    >>> pprint(mueller_matrix(quarter_wave_retarder(theta)), use_unicode=True)\\n    \u23a11       0             0            0    \u23a4\\n    \u23a2                                        \u23a5\\n    \u23a2   cos(4\u22c5\u03b8)   1    sin(4\u22c5\u03b8)             \u23a5\\n    \u23a20  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 + \u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    -sin(2\u22c5\u03b8)\u23a5\\n    \u23a2      2       2       2                 \u23a5\\n    \u23a2                                        \u23a5\\n    \u23a2     sin(4\u22c5\u03b8)    1   cos(4\u22c5\u03b8)           \u23a5\\n    \u23a20    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500 - \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  cos(2\u22c5\u03b8) \u23a5\\n    \u23a2        2        2      2               \u23a5\\n    \u23a2                                        \u23a5\\n    \u23a30    sin(2\u22c5\u03b8)     -cos(2\u22c5\u03b8)        0    \u23a6\\n\\n    '\n    A = Matrix([[1, 0, 0, 1], [1, 0, 0, -1], [0, 1, 1, 0], [0, -I, I, 0]])\n    return simplify(A * TensorProduct(J, J.conjugate()) * A.inv())",
            "def mueller_matrix(J):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'The Mueller matrix corresponding to Jones matrix `J`.\\n\\n    Parameters\\n    ==========\\n\\n    J : SymPy Matrix\\n        A Jones matrix.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        The corresponding Mueller matrix.\\n\\n    Examples\\n    ========\\n\\n    Generic optical components.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import (mueller_matrix,\\n    ...     linear_polarizer, half_wave_retarder, quarter_wave_retarder)\\n    >>> theta = symbols(\"theta\", real=True)\\n\\n    A linear_polarizer\\n\\n    >>> pprint(mueller_matrix(linear_polarizer(theta)), use_unicode=True)\\n    \u23a1            cos(2\u22c5\u03b8)      sin(2\u22c5\u03b8)     \u23a4\\n    \u23a2  1/2       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    0\u23a5\\n    \u23a2               2             2         \u23a5\\n    \u23a2                                       \u23a5\\n    \u23a2cos(2\u22c5\u03b8)  cos(4\u22c5\u03b8)   1    sin(4\u22c5\u03b8)     \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 + \u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    0\u23a5\\n    \u23a2   2         4       4       4         \u23a5\\n    \u23a2                                       \u23a5\\n    \u23a2sin(2\u22c5\u03b8)    sin(4\u22c5\u03b8)    1   cos(4\u22c5\u03b8)   \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500 - \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  0\u23a5\\n    \u23a2   2           4        4      4       \u23a5\\n    \u23a2                                       \u23a5\\n    \u23a3   0           0             0        0\u23a6\\n\\n    A half-wave plate\\n\\n    >>> pprint(mueller_matrix(half_wave_retarder(theta)), use_unicode=True)\\n    \u23a11              0                           0               0 \u23a4\\n    \u23a2                                                             \u23a5\\n    \u23a2        4           2                                        \u23a5\\n    \u23a20  8\u22c5sin (\u03b8) - 8\u22c5sin (\u03b8) + 1           sin(4\u22c5\u03b8)            0 \u23a5\\n    \u23a2                                                             \u23a5\\n    \u23a2                                     4           2           \u23a5\\n    \u23a20          sin(4\u22c5\u03b8)           - 8\u22c5sin (\u03b8) + 8\u22c5sin (\u03b8) - 1  0 \u23a5\\n    \u23a2                                                             \u23a5\\n    \u23a30              0                           0               -1\u23a6\\n\\n    A quarter-wave plate\\n\\n    >>> pprint(mueller_matrix(quarter_wave_retarder(theta)), use_unicode=True)\\n    \u23a11       0             0            0    \u23a4\\n    \u23a2                                        \u23a5\\n    \u23a2   cos(4\u22c5\u03b8)   1    sin(4\u22c5\u03b8)             \u23a5\\n    \u23a20  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 + \u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    -sin(2\u22c5\u03b8)\u23a5\\n    \u23a2      2       2       2                 \u23a5\\n    \u23a2                                        \u23a5\\n    \u23a2     sin(4\u22c5\u03b8)    1   cos(4\u22c5\u03b8)           \u23a5\\n    \u23a20    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500 - \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  cos(2\u22c5\u03b8) \u23a5\\n    \u23a2        2        2      2               \u23a5\\n    \u23a2                                        \u23a5\\n    \u23a30    sin(2\u22c5\u03b8)     -cos(2\u22c5\u03b8)        0    \u23a6\\n\\n    '\n    A = Matrix([[1, 0, 0, 1], [1, 0, 0, -1], [0, 1, 1, 0], [0, -I, I, 0]])\n    return simplify(A * TensorProduct(J, J.conjugate()) * A.inv())",
            "def mueller_matrix(J):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'The Mueller matrix corresponding to Jones matrix `J`.\\n\\n    Parameters\\n    ==========\\n\\n    J : SymPy Matrix\\n        A Jones matrix.\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        The corresponding Mueller matrix.\\n\\n    Examples\\n    ========\\n\\n    Generic optical components.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import (mueller_matrix,\\n    ...     linear_polarizer, half_wave_retarder, quarter_wave_retarder)\\n    >>> theta = symbols(\"theta\", real=True)\\n\\n    A linear_polarizer\\n\\n    >>> pprint(mueller_matrix(linear_polarizer(theta)), use_unicode=True)\\n    \u23a1            cos(2\u22c5\u03b8)      sin(2\u22c5\u03b8)     \u23a4\\n    \u23a2  1/2       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    0\u23a5\\n    \u23a2               2             2         \u23a5\\n    \u23a2                                       \u23a5\\n    \u23a2cos(2\u22c5\u03b8)  cos(4\u22c5\u03b8)   1    sin(4\u22c5\u03b8)     \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 + \u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    0\u23a5\\n    \u23a2   2         4       4       4         \u23a5\\n    \u23a2                                       \u23a5\\n    \u23a2sin(2\u22c5\u03b8)    sin(4\u22c5\u03b8)    1   cos(4\u22c5\u03b8)   \u23a5\\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500 - \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  0\u23a5\\n    \u23a2   2           4        4      4       \u23a5\\n    \u23a2                                       \u23a5\\n    \u23a3   0           0             0        0\u23a6\\n\\n    A half-wave plate\\n\\n    >>> pprint(mueller_matrix(half_wave_retarder(theta)), use_unicode=True)\\n    \u23a11              0                           0               0 \u23a4\\n    \u23a2                                                             \u23a5\\n    \u23a2        4           2                                        \u23a5\\n    \u23a20  8\u22c5sin (\u03b8) - 8\u22c5sin (\u03b8) + 1           sin(4\u22c5\u03b8)            0 \u23a5\\n    \u23a2                                                             \u23a5\\n    \u23a2                                     4           2           \u23a5\\n    \u23a20          sin(4\u22c5\u03b8)           - 8\u22c5sin (\u03b8) + 8\u22c5sin (\u03b8) - 1  0 \u23a5\\n    \u23a2                                                             \u23a5\\n    \u23a30              0                           0               -1\u23a6\\n\\n    A quarter-wave plate\\n\\n    >>> pprint(mueller_matrix(quarter_wave_retarder(theta)), use_unicode=True)\\n    \u23a11       0             0            0    \u23a4\\n    \u23a2                                        \u23a5\\n    \u23a2   cos(4\u22c5\u03b8)   1    sin(4\u22c5\u03b8)             \u23a5\\n    \u23a20  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 + \u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    -sin(2\u22c5\u03b8)\u23a5\\n    \u23a2      2       2       2                 \u23a5\\n    \u23a2                                        \u23a5\\n    \u23a2     sin(4\u22c5\u03b8)    1   cos(4\u22c5\u03b8)           \u23a5\\n    \u23a20    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500 - \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  cos(2\u22c5\u03b8) \u23a5\\n    \u23a2        2        2      2               \u23a5\\n    \u23a2                                        \u23a5\\n    \u23a30    sin(2\u22c5\u03b8)     -cos(2\u22c5\u03b8)        0    \u23a6\\n\\n    '\n    A = Matrix([[1, 0, 0, 1], [1, 0, 0, -1], [0, 1, 1, 0], [0, -I, I, 0]])\n    return simplify(A * TensorProduct(J, J.conjugate()) * A.inv())"
        ]
    },
    {
        "func_name": "polarizing_beam_splitter",
        "original": "def polarizing_beam_splitter(Tp=1, Rs=1, Ts=0, Rp=0, phia=0, phib=0):\n    \"\"\"A polarizing beam splitter Jones matrix at angle `theta`.\n\n    Parameters\n    ==========\n\n    J : SymPy Matrix\n        A Jones matrix.\n    Tp : numeric type or SymPy Symbol\n        The transmissivity of the P-polarized component.\n    Rs : numeric type or SymPy Symbol\n        The reflectivity of the S-polarized component.\n    Ts : numeric type or SymPy Symbol\n        The transmissivity of the S-polarized component.\n    Rp : numeric type or SymPy Symbol\n        The reflectivity of the P-polarized component.\n    phia : numeric type or SymPy Symbol\n        The phase difference between transmitted and reflected component for\n        output mode a.\n    phib : numeric type or SymPy Symbol\n        The phase difference between transmitted and reflected component for\n        output mode b.\n\n\n    Returns\n    =======\n\n    SymPy Matrix\n        A 4x4 matrix representing the PBS. This matrix acts on a 4x1 vector\n        whose first two entries are the Jones vector on one of the PBS ports,\n        and the last two entries the Jones vector on the other port.\n\n    Examples\n    ========\n\n    Generic polarizing beam-splitter.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import polarizing_beam_splitter\n    >>> Ts, Rs, Tp, Rp = symbols(r\"Ts, Rs, Tp, Rp\", positive=True)\n    >>> phia, phib = symbols(\"phi_a, phi_b\", real=True)\n    >>> PBS = polarizing_beam_splitter(Tp, Rs, Ts, Rp, phia, phib)\n    >>> pprint(PBS, use_unicode=False)\n    [   ____                           ____                    ]\n    [ \\\\/ Tp            0           I*\\\\/ Rp           0         ]\n    [                                                          ]\n    [                  ____                       ____  I*phi_a]\n    [   0            \\\\/ Ts            0      -I*\\\\/ Rs *e       ]\n    [                                                          ]\n    [    ____                         ____                     ]\n    [I*\\\\/ Rp           0            \\\\/ Tp            0         ]\n    [                                                          ]\n    [               ____  I*phi_b                    ____      ]\n    [   0      -I*\\\\/ Rs *e            0            \\\\/ Ts       ]\n\n    \"\"\"\n    PBS = Matrix([[sqrt(Tp), 0, I * sqrt(Rp), 0], [0, sqrt(Ts), 0, -I * sqrt(Rs) * exp(I * phia)], [I * sqrt(Rp), 0, sqrt(Tp), 0], [0, -I * sqrt(Rs) * exp(I * phib), 0, sqrt(Ts)]])\n    return PBS",
        "mutated": [
            "def polarizing_beam_splitter(Tp=1, Rs=1, Ts=0, Rp=0, phia=0, phib=0):\n    if False:\n        i = 10\n    'A polarizing beam splitter Jones matrix at angle `theta`.\\n\\n    Parameters\\n    ==========\\n\\n    J : SymPy Matrix\\n        A Jones matrix.\\n    Tp : numeric type or SymPy Symbol\\n        The transmissivity of the P-polarized component.\\n    Rs : numeric type or SymPy Symbol\\n        The reflectivity of the S-polarized component.\\n    Ts : numeric type or SymPy Symbol\\n        The transmissivity of the S-polarized component.\\n    Rp : numeric type or SymPy Symbol\\n        The reflectivity of the P-polarized component.\\n    phia : numeric type or SymPy Symbol\\n        The phase difference between transmitted and reflected component for\\n        output mode a.\\n    phib : numeric type or SymPy Symbol\\n        The phase difference between transmitted and reflected component for\\n        output mode b.\\n\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A 4x4 matrix representing the PBS. This matrix acts on a 4x1 vector\\n        whose first two entries are the Jones vector on one of the PBS ports,\\n        and the last two entries the Jones vector on the other port.\\n\\n    Examples\\n    ========\\n\\n    Generic polarizing beam-splitter.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import polarizing_beam_splitter\\n    >>> Ts, Rs, Tp, Rp = symbols(r\"Ts, Rs, Tp, Rp\", positive=True)\\n    >>> phia, phib = symbols(\"phi_a, phi_b\", real=True)\\n    >>> PBS = polarizing_beam_splitter(Tp, Rs, Ts, Rp, phia, phib)\\n    >>> pprint(PBS, use_unicode=False)\\n    [   ____                           ____                    ]\\n    [ \\\\/ Tp            0           I*\\\\/ Rp           0         ]\\n    [                                                          ]\\n    [                  ____                       ____  I*phi_a]\\n    [   0            \\\\/ Ts            0      -I*\\\\/ Rs *e       ]\\n    [                                                          ]\\n    [    ____                         ____                     ]\\n    [I*\\\\/ Rp           0            \\\\/ Tp            0         ]\\n    [                                                          ]\\n    [               ____  I*phi_b                    ____      ]\\n    [   0      -I*\\\\/ Rs *e            0            \\\\/ Ts       ]\\n\\n    '\n    PBS = Matrix([[sqrt(Tp), 0, I * sqrt(Rp), 0], [0, sqrt(Ts), 0, -I * sqrt(Rs) * exp(I * phia)], [I * sqrt(Rp), 0, sqrt(Tp), 0], [0, -I * sqrt(Rs) * exp(I * phib), 0, sqrt(Ts)]])\n    return PBS",
            "def polarizing_beam_splitter(Tp=1, Rs=1, Ts=0, Rp=0, phia=0, phib=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'A polarizing beam splitter Jones matrix at angle `theta`.\\n\\n    Parameters\\n    ==========\\n\\n    J : SymPy Matrix\\n        A Jones matrix.\\n    Tp : numeric type or SymPy Symbol\\n        The transmissivity of the P-polarized component.\\n    Rs : numeric type or SymPy Symbol\\n        The reflectivity of the S-polarized component.\\n    Ts : numeric type or SymPy Symbol\\n        The transmissivity of the S-polarized component.\\n    Rp : numeric type or SymPy Symbol\\n        The reflectivity of the P-polarized component.\\n    phia : numeric type or SymPy Symbol\\n        The phase difference between transmitted and reflected component for\\n        output mode a.\\n    phib : numeric type or SymPy Symbol\\n        The phase difference between transmitted and reflected component for\\n        output mode b.\\n\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A 4x4 matrix representing the PBS. This matrix acts on a 4x1 vector\\n        whose first two entries are the Jones vector on one of the PBS ports,\\n        and the last two entries the Jones vector on the other port.\\n\\n    Examples\\n    ========\\n\\n    Generic polarizing beam-splitter.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import polarizing_beam_splitter\\n    >>> Ts, Rs, Tp, Rp = symbols(r\"Ts, Rs, Tp, Rp\", positive=True)\\n    >>> phia, phib = symbols(\"phi_a, phi_b\", real=True)\\n    >>> PBS = polarizing_beam_splitter(Tp, Rs, Ts, Rp, phia, phib)\\n    >>> pprint(PBS, use_unicode=False)\\n    [   ____                           ____                    ]\\n    [ \\\\/ Tp            0           I*\\\\/ Rp           0         ]\\n    [                                                          ]\\n    [                  ____                       ____  I*phi_a]\\n    [   0            \\\\/ Ts            0      -I*\\\\/ Rs *e       ]\\n    [                                                          ]\\n    [    ____                         ____                     ]\\n    [I*\\\\/ Rp           0            \\\\/ Tp            0         ]\\n    [                                                          ]\\n    [               ____  I*phi_b                    ____      ]\\n    [   0      -I*\\\\/ Rs *e            0            \\\\/ Ts       ]\\n\\n    '\n    PBS = Matrix([[sqrt(Tp), 0, I * sqrt(Rp), 0], [0, sqrt(Ts), 0, -I * sqrt(Rs) * exp(I * phia)], [I * sqrt(Rp), 0, sqrt(Tp), 0], [0, -I * sqrt(Rs) * exp(I * phib), 0, sqrt(Ts)]])\n    return PBS",
            "def polarizing_beam_splitter(Tp=1, Rs=1, Ts=0, Rp=0, phia=0, phib=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'A polarizing beam splitter Jones matrix at angle `theta`.\\n\\n    Parameters\\n    ==========\\n\\n    J : SymPy Matrix\\n        A Jones matrix.\\n    Tp : numeric type or SymPy Symbol\\n        The transmissivity of the P-polarized component.\\n    Rs : numeric type or SymPy Symbol\\n        The reflectivity of the S-polarized component.\\n    Ts : numeric type or SymPy Symbol\\n        The transmissivity of the S-polarized component.\\n    Rp : numeric type or SymPy Symbol\\n        The reflectivity of the P-polarized component.\\n    phia : numeric type or SymPy Symbol\\n        The phase difference between transmitted and reflected component for\\n        output mode a.\\n    phib : numeric type or SymPy Symbol\\n        The phase difference between transmitted and reflected component for\\n        output mode b.\\n\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A 4x4 matrix representing the PBS. This matrix acts on a 4x1 vector\\n        whose first two entries are the Jones vector on one of the PBS ports,\\n        and the last two entries the Jones vector on the other port.\\n\\n    Examples\\n    ========\\n\\n    Generic polarizing beam-splitter.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import polarizing_beam_splitter\\n    >>> Ts, Rs, Tp, Rp = symbols(r\"Ts, Rs, Tp, Rp\", positive=True)\\n    >>> phia, phib = symbols(\"phi_a, phi_b\", real=True)\\n    >>> PBS = polarizing_beam_splitter(Tp, Rs, Ts, Rp, phia, phib)\\n    >>> pprint(PBS, use_unicode=False)\\n    [   ____                           ____                    ]\\n    [ \\\\/ Tp            0           I*\\\\/ Rp           0         ]\\n    [                                                          ]\\n    [                  ____                       ____  I*phi_a]\\n    [   0            \\\\/ Ts            0      -I*\\\\/ Rs *e       ]\\n    [                                                          ]\\n    [    ____                         ____                     ]\\n    [I*\\\\/ Rp           0            \\\\/ Tp            0         ]\\n    [                                                          ]\\n    [               ____  I*phi_b                    ____      ]\\n    [   0      -I*\\\\/ Rs *e            0            \\\\/ Ts       ]\\n\\n    '\n    PBS = Matrix([[sqrt(Tp), 0, I * sqrt(Rp), 0], [0, sqrt(Ts), 0, -I * sqrt(Rs) * exp(I * phia)], [I * sqrt(Rp), 0, sqrt(Tp), 0], [0, -I * sqrt(Rs) * exp(I * phib), 0, sqrt(Ts)]])\n    return PBS",
            "def polarizing_beam_splitter(Tp=1, Rs=1, Ts=0, Rp=0, phia=0, phib=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'A polarizing beam splitter Jones matrix at angle `theta`.\\n\\n    Parameters\\n    ==========\\n\\n    J : SymPy Matrix\\n        A Jones matrix.\\n    Tp : numeric type or SymPy Symbol\\n        The transmissivity of the P-polarized component.\\n    Rs : numeric type or SymPy Symbol\\n        The reflectivity of the S-polarized component.\\n    Ts : numeric type or SymPy Symbol\\n        The transmissivity of the S-polarized component.\\n    Rp : numeric type or SymPy Symbol\\n        The reflectivity of the P-polarized component.\\n    phia : numeric type or SymPy Symbol\\n        The phase difference between transmitted and reflected component for\\n        output mode a.\\n    phib : numeric type or SymPy Symbol\\n        The phase difference between transmitted and reflected component for\\n        output mode b.\\n\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A 4x4 matrix representing the PBS. This matrix acts on a 4x1 vector\\n        whose first two entries are the Jones vector on one of the PBS ports,\\n        and the last two entries the Jones vector on the other port.\\n\\n    Examples\\n    ========\\n\\n    Generic polarizing beam-splitter.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import polarizing_beam_splitter\\n    >>> Ts, Rs, Tp, Rp = symbols(r\"Ts, Rs, Tp, Rp\", positive=True)\\n    >>> phia, phib = symbols(\"phi_a, phi_b\", real=True)\\n    >>> PBS = polarizing_beam_splitter(Tp, Rs, Ts, Rp, phia, phib)\\n    >>> pprint(PBS, use_unicode=False)\\n    [   ____                           ____                    ]\\n    [ \\\\/ Tp            0           I*\\\\/ Rp           0         ]\\n    [                                                          ]\\n    [                  ____                       ____  I*phi_a]\\n    [   0            \\\\/ Ts            0      -I*\\\\/ Rs *e       ]\\n    [                                                          ]\\n    [    ____                         ____                     ]\\n    [I*\\\\/ Rp           0            \\\\/ Tp            0         ]\\n    [                                                          ]\\n    [               ____  I*phi_b                    ____      ]\\n    [   0      -I*\\\\/ Rs *e            0            \\\\/ Ts       ]\\n\\n    '\n    PBS = Matrix([[sqrt(Tp), 0, I * sqrt(Rp), 0], [0, sqrt(Ts), 0, -I * sqrt(Rs) * exp(I * phia)], [I * sqrt(Rp), 0, sqrt(Tp), 0], [0, -I * sqrt(Rs) * exp(I * phib), 0, sqrt(Ts)]])\n    return PBS",
            "def polarizing_beam_splitter(Tp=1, Rs=1, Ts=0, Rp=0, phia=0, phib=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'A polarizing beam splitter Jones matrix at angle `theta`.\\n\\n    Parameters\\n    ==========\\n\\n    J : SymPy Matrix\\n        A Jones matrix.\\n    Tp : numeric type or SymPy Symbol\\n        The transmissivity of the P-polarized component.\\n    Rs : numeric type or SymPy Symbol\\n        The reflectivity of the S-polarized component.\\n    Ts : numeric type or SymPy Symbol\\n        The transmissivity of the S-polarized component.\\n    Rp : numeric type or SymPy Symbol\\n        The reflectivity of the P-polarized component.\\n    phia : numeric type or SymPy Symbol\\n        The phase difference between transmitted and reflected component for\\n        output mode a.\\n    phib : numeric type or SymPy Symbol\\n        The phase difference between transmitted and reflected component for\\n        output mode b.\\n\\n\\n    Returns\\n    =======\\n\\n    SymPy Matrix\\n        A 4x4 matrix representing the PBS. This matrix acts on a 4x1 vector\\n        whose first two entries are the Jones vector on one of the PBS ports,\\n        and the last two entries the Jones vector on the other port.\\n\\n    Examples\\n    ========\\n\\n    Generic polarizing beam-splitter.\\n\\n    >>> from sympy import pprint, symbols\\n    >>> from sympy.physics.optics.polarization import polarizing_beam_splitter\\n    >>> Ts, Rs, Tp, Rp = symbols(r\"Ts, Rs, Tp, Rp\", positive=True)\\n    >>> phia, phib = symbols(\"phi_a, phi_b\", real=True)\\n    >>> PBS = polarizing_beam_splitter(Tp, Rs, Ts, Rp, phia, phib)\\n    >>> pprint(PBS, use_unicode=False)\\n    [   ____                           ____                    ]\\n    [ \\\\/ Tp            0           I*\\\\/ Rp           0         ]\\n    [                                                          ]\\n    [                  ____                       ____  I*phi_a]\\n    [   0            \\\\/ Ts            0      -I*\\\\/ Rs *e       ]\\n    [                                                          ]\\n    [    ____                         ____                     ]\\n    [I*\\\\/ Rp           0            \\\\/ Tp            0         ]\\n    [                                                          ]\\n    [               ____  I*phi_b                    ____      ]\\n    [   0      -I*\\\\/ Rs *e            0            \\\\/ Ts       ]\\n\\n    '\n    PBS = Matrix([[sqrt(Tp), 0, I * sqrt(Rp), 0], [0, sqrt(Ts), 0, -I * sqrt(Rs) * exp(I * phia)], [I * sqrt(Rp), 0, sqrt(Tp), 0], [0, -I * sqrt(Rs) * exp(I * phib), 0, sqrt(Ts)]])\n    return PBS"
        ]
    }
]