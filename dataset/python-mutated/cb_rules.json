[
    {
        "func_name": "buildcallbacks",
        "original": "def buildcallbacks(m):\n    cb_map[m['name']] = []\n    for bi in m['body']:\n        if bi['block'] == 'interface':\n            for b in bi['body']:\n                if b:\n                    buildcallback(b, m['name'])\n                else:\n                    errmess('warning: empty body for %s\\n' % m['name'])",
        "mutated": [
            "def buildcallbacks(m):\n    if False:\n        i = 10\n    cb_map[m['name']] = []\n    for bi in m['body']:\n        if bi['block'] == 'interface':\n            for b in bi['body']:\n                if b:\n                    buildcallback(b, m['name'])\n                else:\n                    errmess('warning: empty body for %s\\n' % m['name'])",
            "def buildcallbacks(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cb_map[m['name']] = []\n    for bi in m['body']:\n        if bi['block'] == 'interface':\n            for b in bi['body']:\n                if b:\n                    buildcallback(b, m['name'])\n                else:\n                    errmess('warning: empty body for %s\\n' % m['name'])",
            "def buildcallbacks(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cb_map[m['name']] = []\n    for bi in m['body']:\n        if bi['block'] == 'interface':\n            for b in bi['body']:\n                if b:\n                    buildcallback(b, m['name'])\n                else:\n                    errmess('warning: empty body for %s\\n' % m['name'])",
            "def buildcallbacks(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cb_map[m['name']] = []\n    for bi in m['body']:\n        if bi['block'] == 'interface':\n            for b in bi['body']:\n                if b:\n                    buildcallback(b, m['name'])\n                else:\n                    errmess('warning: empty body for %s\\n' % m['name'])",
            "def buildcallbacks(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cb_map[m['name']] = []\n    for bi in m['body']:\n        if bi['block'] == 'interface':\n            for b in bi['body']:\n                if b:\n                    buildcallback(b, m['name'])\n                else:\n                    errmess('warning: empty body for %s\\n' % m['name'])"
        ]
    },
    {
        "func_name": "buildcallback",
        "original": "def buildcallback(rout, um):\n    from . import capi_maps\n    outmess('    Constructing call-back function \"cb_%s_in_%s\"\\n' % (rout['name'], um))\n    (args, depargs) = getargs(rout)\n    capi_maps.depargs = depargs\n    var = rout['vars']\n    vrd = capi_maps.cb_routsign2map(rout, um)\n    rd = dictappend({}, vrd)\n    cb_map[um].append([rout['name'], rd['name']])\n    for r in cb_rout_rules:\n        if '_check' in r and r['_check'](rout) or '_check' not in r:\n            ar = applyrules(r, vrd, rout)\n            rd = dictappend(rd, ar)\n    savevrd = {}\n    for (i, a) in enumerate(args):\n        vrd = capi_maps.cb_sign2map(a, var[a], index=i)\n        savevrd[a] = vrd\n        for r in cb_arg_rules:\n            if '_depend' in r:\n                continue\n            if '_optional' in r and isoptional(var[a]):\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    for a in args:\n        vrd = savevrd[a]\n        for r in cb_arg_rules:\n            if '_depend' in r:\n                continue\n            if '_optional' not in r or ('_optional' in r and isrequired(var[a])):\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    for a in depargs:\n        vrd = savevrd[a]\n        for r in cb_arg_rules:\n            if '_depend' not in r:\n                continue\n            if '_optional' in r:\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    if 'args' in rd and 'optargs' in rd:\n        if isinstance(rd['optargs'], list):\n            rd['optargs'] = rd['optargs'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n            rd['optargs_nm'] = rd['optargs_nm'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n            rd['optargs_td'] = rd['optargs_td'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n    if isinstance(rd['docreturn'], list):\n        rd['docreturn'] = stripcomma(replace('#docreturn#', {'docreturn': rd['docreturn']}))\n    optargs = stripcomma(replace('#docsignopt#', {'docsignopt': rd['docsignopt']}))\n    if optargs == '':\n        rd['docsignature'] = stripcomma(replace('#docsign#', {'docsign': rd['docsign']}))\n    else:\n        rd['docsignature'] = replace('#docsign#[#docsignopt#]', {'docsign': rd['docsign'], 'docsignopt': optargs})\n    rd['latexdocsignature'] = rd['docsignature'].replace('_', '\\\\_')\n    rd['latexdocsignature'] = rd['latexdocsignature'].replace(',', ', ')\n    rd['docstrsigns'] = []\n    rd['latexdocstrsigns'] = []\n    for k in ['docstrreq', 'docstropt', 'docstrout', 'docstrcbs']:\n        if k in rd and isinstance(rd[k], list):\n            rd['docstrsigns'] = rd['docstrsigns'] + rd[k]\n        k = 'latex' + k\n        if k in rd and isinstance(rd[k], list):\n            rd['latexdocstrsigns'] = rd['latexdocstrsigns'] + rd[k][0:1] + ['\\\\begin{description}'] + rd[k][1:] + ['\\\\end{description}']\n    if 'args' not in rd:\n        rd['args'] = ''\n        rd['args_td'] = ''\n        rd['args_nm'] = ''\n    if not (rd.get('args') or rd.get('optargs') or rd.get('strarglens')):\n        rd['noargs'] = 'void'\n    ar = applyrules(cb_routine_rules, rd)\n    cfuncs.callbacks[rd['name']] = ar['body']\n    if isinstance(ar['need'], str):\n        ar['need'] = [ar['need']]\n    if 'need' in rd:\n        for t in cfuncs.typedefs.keys():\n            if t in rd['need']:\n                ar['need'].append(t)\n    cfuncs.typedefs_generated[rd['name'] + '_typedef'] = ar['cbtypedefs']\n    ar['need'].append(rd['name'] + '_typedef')\n    cfuncs.needs[rd['name']] = ar['need']\n    capi_maps.lcb2_map[rd['name']] = {'maxnofargs': ar['maxnofargs'], 'nofoptargs': ar['nofoptargs'], 'docstr': ar['docstr'], 'latexdocstr': ar['latexdocstr'], 'argname': rd['argname']}\n    outmess('      %s\\n' % ar['docstrshort'])\n    return",
        "mutated": [
            "def buildcallback(rout, um):\n    if False:\n        i = 10\n    from . import capi_maps\n    outmess('    Constructing call-back function \"cb_%s_in_%s\"\\n' % (rout['name'], um))\n    (args, depargs) = getargs(rout)\n    capi_maps.depargs = depargs\n    var = rout['vars']\n    vrd = capi_maps.cb_routsign2map(rout, um)\n    rd = dictappend({}, vrd)\n    cb_map[um].append([rout['name'], rd['name']])\n    for r in cb_rout_rules:\n        if '_check' in r and r['_check'](rout) or '_check' not in r:\n            ar = applyrules(r, vrd, rout)\n            rd = dictappend(rd, ar)\n    savevrd = {}\n    for (i, a) in enumerate(args):\n        vrd = capi_maps.cb_sign2map(a, var[a], index=i)\n        savevrd[a] = vrd\n        for r in cb_arg_rules:\n            if '_depend' in r:\n                continue\n            if '_optional' in r and isoptional(var[a]):\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    for a in args:\n        vrd = savevrd[a]\n        for r in cb_arg_rules:\n            if '_depend' in r:\n                continue\n            if '_optional' not in r or ('_optional' in r and isrequired(var[a])):\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    for a in depargs:\n        vrd = savevrd[a]\n        for r in cb_arg_rules:\n            if '_depend' not in r:\n                continue\n            if '_optional' in r:\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    if 'args' in rd and 'optargs' in rd:\n        if isinstance(rd['optargs'], list):\n            rd['optargs'] = rd['optargs'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n            rd['optargs_nm'] = rd['optargs_nm'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n            rd['optargs_td'] = rd['optargs_td'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n    if isinstance(rd['docreturn'], list):\n        rd['docreturn'] = stripcomma(replace('#docreturn#', {'docreturn': rd['docreturn']}))\n    optargs = stripcomma(replace('#docsignopt#', {'docsignopt': rd['docsignopt']}))\n    if optargs == '':\n        rd['docsignature'] = stripcomma(replace('#docsign#', {'docsign': rd['docsign']}))\n    else:\n        rd['docsignature'] = replace('#docsign#[#docsignopt#]', {'docsign': rd['docsign'], 'docsignopt': optargs})\n    rd['latexdocsignature'] = rd['docsignature'].replace('_', '\\\\_')\n    rd['latexdocsignature'] = rd['latexdocsignature'].replace(',', ', ')\n    rd['docstrsigns'] = []\n    rd['latexdocstrsigns'] = []\n    for k in ['docstrreq', 'docstropt', 'docstrout', 'docstrcbs']:\n        if k in rd and isinstance(rd[k], list):\n            rd['docstrsigns'] = rd['docstrsigns'] + rd[k]\n        k = 'latex' + k\n        if k in rd and isinstance(rd[k], list):\n            rd['latexdocstrsigns'] = rd['latexdocstrsigns'] + rd[k][0:1] + ['\\\\begin{description}'] + rd[k][1:] + ['\\\\end{description}']\n    if 'args' not in rd:\n        rd['args'] = ''\n        rd['args_td'] = ''\n        rd['args_nm'] = ''\n    if not (rd.get('args') or rd.get('optargs') or rd.get('strarglens')):\n        rd['noargs'] = 'void'\n    ar = applyrules(cb_routine_rules, rd)\n    cfuncs.callbacks[rd['name']] = ar['body']\n    if isinstance(ar['need'], str):\n        ar['need'] = [ar['need']]\n    if 'need' in rd:\n        for t in cfuncs.typedefs.keys():\n            if t in rd['need']:\n                ar['need'].append(t)\n    cfuncs.typedefs_generated[rd['name'] + '_typedef'] = ar['cbtypedefs']\n    ar['need'].append(rd['name'] + '_typedef')\n    cfuncs.needs[rd['name']] = ar['need']\n    capi_maps.lcb2_map[rd['name']] = {'maxnofargs': ar['maxnofargs'], 'nofoptargs': ar['nofoptargs'], 'docstr': ar['docstr'], 'latexdocstr': ar['latexdocstr'], 'argname': rd['argname']}\n    outmess('      %s\\n' % ar['docstrshort'])\n    return",
            "def buildcallback(rout, um):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from . import capi_maps\n    outmess('    Constructing call-back function \"cb_%s_in_%s\"\\n' % (rout['name'], um))\n    (args, depargs) = getargs(rout)\n    capi_maps.depargs = depargs\n    var = rout['vars']\n    vrd = capi_maps.cb_routsign2map(rout, um)\n    rd = dictappend({}, vrd)\n    cb_map[um].append([rout['name'], rd['name']])\n    for r in cb_rout_rules:\n        if '_check' in r and r['_check'](rout) or '_check' not in r:\n            ar = applyrules(r, vrd, rout)\n            rd = dictappend(rd, ar)\n    savevrd = {}\n    for (i, a) in enumerate(args):\n        vrd = capi_maps.cb_sign2map(a, var[a], index=i)\n        savevrd[a] = vrd\n        for r in cb_arg_rules:\n            if '_depend' in r:\n                continue\n            if '_optional' in r and isoptional(var[a]):\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    for a in args:\n        vrd = savevrd[a]\n        for r in cb_arg_rules:\n            if '_depend' in r:\n                continue\n            if '_optional' not in r or ('_optional' in r and isrequired(var[a])):\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    for a in depargs:\n        vrd = savevrd[a]\n        for r in cb_arg_rules:\n            if '_depend' not in r:\n                continue\n            if '_optional' in r:\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    if 'args' in rd and 'optargs' in rd:\n        if isinstance(rd['optargs'], list):\n            rd['optargs'] = rd['optargs'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n            rd['optargs_nm'] = rd['optargs_nm'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n            rd['optargs_td'] = rd['optargs_td'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n    if isinstance(rd['docreturn'], list):\n        rd['docreturn'] = stripcomma(replace('#docreturn#', {'docreturn': rd['docreturn']}))\n    optargs = stripcomma(replace('#docsignopt#', {'docsignopt': rd['docsignopt']}))\n    if optargs == '':\n        rd['docsignature'] = stripcomma(replace('#docsign#', {'docsign': rd['docsign']}))\n    else:\n        rd['docsignature'] = replace('#docsign#[#docsignopt#]', {'docsign': rd['docsign'], 'docsignopt': optargs})\n    rd['latexdocsignature'] = rd['docsignature'].replace('_', '\\\\_')\n    rd['latexdocsignature'] = rd['latexdocsignature'].replace(',', ', ')\n    rd['docstrsigns'] = []\n    rd['latexdocstrsigns'] = []\n    for k in ['docstrreq', 'docstropt', 'docstrout', 'docstrcbs']:\n        if k in rd and isinstance(rd[k], list):\n            rd['docstrsigns'] = rd['docstrsigns'] + rd[k]\n        k = 'latex' + k\n        if k in rd and isinstance(rd[k], list):\n            rd['latexdocstrsigns'] = rd['latexdocstrsigns'] + rd[k][0:1] + ['\\\\begin{description}'] + rd[k][1:] + ['\\\\end{description}']\n    if 'args' not in rd:\n        rd['args'] = ''\n        rd['args_td'] = ''\n        rd['args_nm'] = ''\n    if not (rd.get('args') or rd.get('optargs') or rd.get('strarglens')):\n        rd['noargs'] = 'void'\n    ar = applyrules(cb_routine_rules, rd)\n    cfuncs.callbacks[rd['name']] = ar['body']\n    if isinstance(ar['need'], str):\n        ar['need'] = [ar['need']]\n    if 'need' in rd:\n        for t in cfuncs.typedefs.keys():\n            if t in rd['need']:\n                ar['need'].append(t)\n    cfuncs.typedefs_generated[rd['name'] + '_typedef'] = ar['cbtypedefs']\n    ar['need'].append(rd['name'] + '_typedef')\n    cfuncs.needs[rd['name']] = ar['need']\n    capi_maps.lcb2_map[rd['name']] = {'maxnofargs': ar['maxnofargs'], 'nofoptargs': ar['nofoptargs'], 'docstr': ar['docstr'], 'latexdocstr': ar['latexdocstr'], 'argname': rd['argname']}\n    outmess('      %s\\n' % ar['docstrshort'])\n    return",
            "def buildcallback(rout, um):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from . import capi_maps\n    outmess('    Constructing call-back function \"cb_%s_in_%s\"\\n' % (rout['name'], um))\n    (args, depargs) = getargs(rout)\n    capi_maps.depargs = depargs\n    var = rout['vars']\n    vrd = capi_maps.cb_routsign2map(rout, um)\n    rd = dictappend({}, vrd)\n    cb_map[um].append([rout['name'], rd['name']])\n    for r in cb_rout_rules:\n        if '_check' in r and r['_check'](rout) or '_check' not in r:\n            ar = applyrules(r, vrd, rout)\n            rd = dictappend(rd, ar)\n    savevrd = {}\n    for (i, a) in enumerate(args):\n        vrd = capi_maps.cb_sign2map(a, var[a], index=i)\n        savevrd[a] = vrd\n        for r in cb_arg_rules:\n            if '_depend' in r:\n                continue\n            if '_optional' in r and isoptional(var[a]):\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    for a in args:\n        vrd = savevrd[a]\n        for r in cb_arg_rules:\n            if '_depend' in r:\n                continue\n            if '_optional' not in r or ('_optional' in r and isrequired(var[a])):\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    for a in depargs:\n        vrd = savevrd[a]\n        for r in cb_arg_rules:\n            if '_depend' not in r:\n                continue\n            if '_optional' in r:\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    if 'args' in rd and 'optargs' in rd:\n        if isinstance(rd['optargs'], list):\n            rd['optargs'] = rd['optargs'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n            rd['optargs_nm'] = rd['optargs_nm'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n            rd['optargs_td'] = rd['optargs_td'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n    if isinstance(rd['docreturn'], list):\n        rd['docreturn'] = stripcomma(replace('#docreturn#', {'docreturn': rd['docreturn']}))\n    optargs = stripcomma(replace('#docsignopt#', {'docsignopt': rd['docsignopt']}))\n    if optargs == '':\n        rd['docsignature'] = stripcomma(replace('#docsign#', {'docsign': rd['docsign']}))\n    else:\n        rd['docsignature'] = replace('#docsign#[#docsignopt#]', {'docsign': rd['docsign'], 'docsignopt': optargs})\n    rd['latexdocsignature'] = rd['docsignature'].replace('_', '\\\\_')\n    rd['latexdocsignature'] = rd['latexdocsignature'].replace(',', ', ')\n    rd['docstrsigns'] = []\n    rd['latexdocstrsigns'] = []\n    for k in ['docstrreq', 'docstropt', 'docstrout', 'docstrcbs']:\n        if k in rd and isinstance(rd[k], list):\n            rd['docstrsigns'] = rd['docstrsigns'] + rd[k]\n        k = 'latex' + k\n        if k in rd and isinstance(rd[k], list):\n            rd['latexdocstrsigns'] = rd['latexdocstrsigns'] + rd[k][0:1] + ['\\\\begin{description}'] + rd[k][1:] + ['\\\\end{description}']\n    if 'args' not in rd:\n        rd['args'] = ''\n        rd['args_td'] = ''\n        rd['args_nm'] = ''\n    if not (rd.get('args') or rd.get('optargs') or rd.get('strarglens')):\n        rd['noargs'] = 'void'\n    ar = applyrules(cb_routine_rules, rd)\n    cfuncs.callbacks[rd['name']] = ar['body']\n    if isinstance(ar['need'], str):\n        ar['need'] = [ar['need']]\n    if 'need' in rd:\n        for t in cfuncs.typedefs.keys():\n            if t in rd['need']:\n                ar['need'].append(t)\n    cfuncs.typedefs_generated[rd['name'] + '_typedef'] = ar['cbtypedefs']\n    ar['need'].append(rd['name'] + '_typedef')\n    cfuncs.needs[rd['name']] = ar['need']\n    capi_maps.lcb2_map[rd['name']] = {'maxnofargs': ar['maxnofargs'], 'nofoptargs': ar['nofoptargs'], 'docstr': ar['docstr'], 'latexdocstr': ar['latexdocstr'], 'argname': rd['argname']}\n    outmess('      %s\\n' % ar['docstrshort'])\n    return",
            "def buildcallback(rout, um):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from . import capi_maps\n    outmess('    Constructing call-back function \"cb_%s_in_%s\"\\n' % (rout['name'], um))\n    (args, depargs) = getargs(rout)\n    capi_maps.depargs = depargs\n    var = rout['vars']\n    vrd = capi_maps.cb_routsign2map(rout, um)\n    rd = dictappend({}, vrd)\n    cb_map[um].append([rout['name'], rd['name']])\n    for r in cb_rout_rules:\n        if '_check' in r and r['_check'](rout) or '_check' not in r:\n            ar = applyrules(r, vrd, rout)\n            rd = dictappend(rd, ar)\n    savevrd = {}\n    for (i, a) in enumerate(args):\n        vrd = capi_maps.cb_sign2map(a, var[a], index=i)\n        savevrd[a] = vrd\n        for r in cb_arg_rules:\n            if '_depend' in r:\n                continue\n            if '_optional' in r and isoptional(var[a]):\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    for a in args:\n        vrd = savevrd[a]\n        for r in cb_arg_rules:\n            if '_depend' in r:\n                continue\n            if '_optional' not in r or ('_optional' in r and isrequired(var[a])):\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    for a in depargs:\n        vrd = savevrd[a]\n        for r in cb_arg_rules:\n            if '_depend' not in r:\n                continue\n            if '_optional' in r:\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    if 'args' in rd and 'optargs' in rd:\n        if isinstance(rd['optargs'], list):\n            rd['optargs'] = rd['optargs'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n            rd['optargs_nm'] = rd['optargs_nm'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n            rd['optargs_td'] = rd['optargs_td'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n    if isinstance(rd['docreturn'], list):\n        rd['docreturn'] = stripcomma(replace('#docreturn#', {'docreturn': rd['docreturn']}))\n    optargs = stripcomma(replace('#docsignopt#', {'docsignopt': rd['docsignopt']}))\n    if optargs == '':\n        rd['docsignature'] = stripcomma(replace('#docsign#', {'docsign': rd['docsign']}))\n    else:\n        rd['docsignature'] = replace('#docsign#[#docsignopt#]', {'docsign': rd['docsign'], 'docsignopt': optargs})\n    rd['latexdocsignature'] = rd['docsignature'].replace('_', '\\\\_')\n    rd['latexdocsignature'] = rd['latexdocsignature'].replace(',', ', ')\n    rd['docstrsigns'] = []\n    rd['latexdocstrsigns'] = []\n    for k in ['docstrreq', 'docstropt', 'docstrout', 'docstrcbs']:\n        if k in rd and isinstance(rd[k], list):\n            rd['docstrsigns'] = rd['docstrsigns'] + rd[k]\n        k = 'latex' + k\n        if k in rd and isinstance(rd[k], list):\n            rd['latexdocstrsigns'] = rd['latexdocstrsigns'] + rd[k][0:1] + ['\\\\begin{description}'] + rd[k][1:] + ['\\\\end{description}']\n    if 'args' not in rd:\n        rd['args'] = ''\n        rd['args_td'] = ''\n        rd['args_nm'] = ''\n    if not (rd.get('args') or rd.get('optargs') or rd.get('strarglens')):\n        rd['noargs'] = 'void'\n    ar = applyrules(cb_routine_rules, rd)\n    cfuncs.callbacks[rd['name']] = ar['body']\n    if isinstance(ar['need'], str):\n        ar['need'] = [ar['need']]\n    if 'need' in rd:\n        for t in cfuncs.typedefs.keys():\n            if t in rd['need']:\n                ar['need'].append(t)\n    cfuncs.typedefs_generated[rd['name'] + '_typedef'] = ar['cbtypedefs']\n    ar['need'].append(rd['name'] + '_typedef')\n    cfuncs.needs[rd['name']] = ar['need']\n    capi_maps.lcb2_map[rd['name']] = {'maxnofargs': ar['maxnofargs'], 'nofoptargs': ar['nofoptargs'], 'docstr': ar['docstr'], 'latexdocstr': ar['latexdocstr'], 'argname': rd['argname']}\n    outmess('      %s\\n' % ar['docstrshort'])\n    return",
            "def buildcallback(rout, um):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from . import capi_maps\n    outmess('    Constructing call-back function \"cb_%s_in_%s\"\\n' % (rout['name'], um))\n    (args, depargs) = getargs(rout)\n    capi_maps.depargs = depargs\n    var = rout['vars']\n    vrd = capi_maps.cb_routsign2map(rout, um)\n    rd = dictappend({}, vrd)\n    cb_map[um].append([rout['name'], rd['name']])\n    for r in cb_rout_rules:\n        if '_check' in r and r['_check'](rout) or '_check' not in r:\n            ar = applyrules(r, vrd, rout)\n            rd = dictappend(rd, ar)\n    savevrd = {}\n    for (i, a) in enumerate(args):\n        vrd = capi_maps.cb_sign2map(a, var[a], index=i)\n        savevrd[a] = vrd\n        for r in cb_arg_rules:\n            if '_depend' in r:\n                continue\n            if '_optional' in r and isoptional(var[a]):\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    for a in args:\n        vrd = savevrd[a]\n        for r in cb_arg_rules:\n            if '_depend' in r:\n                continue\n            if '_optional' not in r or ('_optional' in r and isrequired(var[a])):\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    for a in depargs:\n        vrd = savevrd[a]\n        for r in cb_arg_rules:\n            if '_depend' not in r:\n                continue\n            if '_optional' in r:\n                continue\n            if '_check' in r and r['_check'](var[a]) or '_check' not in r:\n                ar = applyrules(r, vrd, var[a])\n                rd = dictappend(rd, ar)\n                if '_break' in r:\n                    break\n    if 'args' in rd and 'optargs' in rd:\n        if isinstance(rd['optargs'], list):\n            rd['optargs'] = rd['optargs'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n            rd['optargs_nm'] = rd['optargs_nm'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n            rd['optargs_td'] = rd['optargs_td'] + ['\\n#ifndef F2PY_CB_RETURNCOMPLEX\\n,\\n#endif\\n']\n    if isinstance(rd['docreturn'], list):\n        rd['docreturn'] = stripcomma(replace('#docreturn#', {'docreturn': rd['docreturn']}))\n    optargs = stripcomma(replace('#docsignopt#', {'docsignopt': rd['docsignopt']}))\n    if optargs == '':\n        rd['docsignature'] = stripcomma(replace('#docsign#', {'docsign': rd['docsign']}))\n    else:\n        rd['docsignature'] = replace('#docsign#[#docsignopt#]', {'docsign': rd['docsign'], 'docsignopt': optargs})\n    rd['latexdocsignature'] = rd['docsignature'].replace('_', '\\\\_')\n    rd['latexdocsignature'] = rd['latexdocsignature'].replace(',', ', ')\n    rd['docstrsigns'] = []\n    rd['latexdocstrsigns'] = []\n    for k in ['docstrreq', 'docstropt', 'docstrout', 'docstrcbs']:\n        if k in rd and isinstance(rd[k], list):\n            rd['docstrsigns'] = rd['docstrsigns'] + rd[k]\n        k = 'latex' + k\n        if k in rd and isinstance(rd[k], list):\n            rd['latexdocstrsigns'] = rd['latexdocstrsigns'] + rd[k][0:1] + ['\\\\begin{description}'] + rd[k][1:] + ['\\\\end{description}']\n    if 'args' not in rd:\n        rd['args'] = ''\n        rd['args_td'] = ''\n        rd['args_nm'] = ''\n    if not (rd.get('args') or rd.get('optargs') or rd.get('strarglens')):\n        rd['noargs'] = 'void'\n    ar = applyrules(cb_routine_rules, rd)\n    cfuncs.callbacks[rd['name']] = ar['body']\n    if isinstance(ar['need'], str):\n        ar['need'] = [ar['need']]\n    if 'need' in rd:\n        for t in cfuncs.typedefs.keys():\n            if t in rd['need']:\n                ar['need'].append(t)\n    cfuncs.typedefs_generated[rd['name'] + '_typedef'] = ar['cbtypedefs']\n    ar['need'].append(rd['name'] + '_typedef')\n    cfuncs.needs[rd['name']] = ar['need']\n    capi_maps.lcb2_map[rd['name']] = {'maxnofargs': ar['maxnofargs'], 'nofoptargs': ar['nofoptargs'], 'docstr': ar['docstr'], 'latexdocstr': ar['latexdocstr'], 'argname': rd['argname']}\n    outmess('      %s\\n' % ar['docstrshort'])\n    return"
        ]
    }
]