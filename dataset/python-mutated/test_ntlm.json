[
    {
        "func_name": "setUp",
        "original": "def setUp(self):\n    ntlm.TEST_CASE = True\n    self.user = 'User'\n    self.domain = 'Domain'\n    self.password = 'Password'\n    self.serverName = 'Server'\n    self.workstationName = 'COMPUTER'\n    self.randomSessionKey = b('U' * 16)\n    self.time = b('\\x00' * 8)\n    self.clientChallenge = b('\u00aa' * 8)\n    self.serverChallenge = b('\\x01#Eg\\x89\u00ab\u00cd\u00ef')\n    self.flags = ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH | ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_128 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    self.seqNum = 0\n    self.nonce = b('\\x00' * 16)\n    self.plaintext = 'Plaintext'.encode('utf-16le')\n    print('Flags')\n    hexdump(struct.pack('<L', self.flags))",
        "mutated": [
            "def setUp(self):\n    if False:\n        i = 10\n    ntlm.TEST_CASE = True\n    self.user = 'User'\n    self.domain = 'Domain'\n    self.password = 'Password'\n    self.serverName = 'Server'\n    self.workstationName = 'COMPUTER'\n    self.randomSessionKey = b('U' * 16)\n    self.time = b('\\x00' * 8)\n    self.clientChallenge = b('\u00aa' * 8)\n    self.serverChallenge = b('\\x01#Eg\\x89\u00ab\u00cd\u00ef')\n    self.flags = ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH | ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_128 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    self.seqNum = 0\n    self.nonce = b('\\x00' * 16)\n    self.plaintext = 'Plaintext'.encode('utf-16le')\n    print('Flags')\n    hexdump(struct.pack('<L', self.flags))",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ntlm.TEST_CASE = True\n    self.user = 'User'\n    self.domain = 'Domain'\n    self.password = 'Password'\n    self.serverName = 'Server'\n    self.workstationName = 'COMPUTER'\n    self.randomSessionKey = b('U' * 16)\n    self.time = b('\\x00' * 8)\n    self.clientChallenge = b('\u00aa' * 8)\n    self.serverChallenge = b('\\x01#Eg\\x89\u00ab\u00cd\u00ef')\n    self.flags = ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH | ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_128 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    self.seqNum = 0\n    self.nonce = b('\\x00' * 16)\n    self.plaintext = 'Plaintext'.encode('utf-16le')\n    print('Flags')\n    hexdump(struct.pack('<L', self.flags))",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ntlm.TEST_CASE = True\n    self.user = 'User'\n    self.domain = 'Domain'\n    self.password = 'Password'\n    self.serverName = 'Server'\n    self.workstationName = 'COMPUTER'\n    self.randomSessionKey = b('U' * 16)\n    self.time = b('\\x00' * 8)\n    self.clientChallenge = b('\u00aa' * 8)\n    self.serverChallenge = b('\\x01#Eg\\x89\u00ab\u00cd\u00ef')\n    self.flags = ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH | ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_128 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    self.seqNum = 0\n    self.nonce = b('\\x00' * 16)\n    self.plaintext = 'Plaintext'.encode('utf-16le')\n    print('Flags')\n    hexdump(struct.pack('<L', self.flags))",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ntlm.TEST_CASE = True\n    self.user = 'User'\n    self.domain = 'Domain'\n    self.password = 'Password'\n    self.serverName = 'Server'\n    self.workstationName = 'COMPUTER'\n    self.randomSessionKey = b('U' * 16)\n    self.time = b('\\x00' * 8)\n    self.clientChallenge = b('\u00aa' * 8)\n    self.serverChallenge = b('\\x01#Eg\\x89\u00ab\u00cd\u00ef')\n    self.flags = ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH | ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_128 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    self.seqNum = 0\n    self.nonce = b('\\x00' * 16)\n    self.plaintext = 'Plaintext'.encode('utf-16le')\n    print('Flags')\n    hexdump(struct.pack('<L', self.flags))",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ntlm.TEST_CASE = True\n    self.user = 'User'\n    self.domain = 'Domain'\n    self.password = 'Password'\n    self.serverName = 'Server'\n    self.workstationName = 'COMPUTER'\n    self.randomSessionKey = b('U' * 16)\n    self.time = b('\\x00' * 8)\n    self.clientChallenge = b('\u00aa' * 8)\n    self.serverChallenge = b('\\x01#Eg\\x89\u00ab\u00cd\u00ef')\n    self.flags = ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH | ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_128 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    self.seqNum = 0\n    self.nonce = b('\\x00' * 16)\n    self.plaintext = 'Plaintext'.encode('utf-16le')\n    print('Flags')\n    hexdump(struct.pack('<L', self.flags))"
        ]
    },
    {
        "func_name": "test_ntlmv1",
        "original": "def test_ntlmv1(self):\n    print('####### 4.2.2 NTLMv1 Authentication')\n    ntlm.USE_NTLMv2 = False\n    print('4.2.2.1 LMOWFv1()')\n    res = ntlm.LMOWFv1(self.password)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\xe5,\\xacgA\\x9a\\x9a\"J;\\x10\\x8f?\\xa6\\xcbm'))\n    print('\\n')\n    print('4.2.2.1.2 NTOWFv1()')\n    res = ntlm.NTOWFv1(self.password)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\xa4\\xf4\\x9c@e\\x10\\xbd\\xca\\xb6\\x82N\\xe7\\xc3\\x0f\\xd8R'))\n    print('\\n')\n    print('4.2.2.1.3 Session Base Key and Key Exchange Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\xd8rb\\xb0\\xcd\\xe4\\xb1\\xcbt\\x99\\xbe\\xcc\\xcd\\xf1\\x07\\x84'))\n    print('\\n')\n    print('4.2.2.2.1 NTLMv1 Response')\n    hexdump(ntResponse)\n    self.assertEqual(ntResponse, bytearray(b\"g\\xc40\\x11\\xf3\\x02\\x98\\xa2\\xad5\\xec\\xe6O\\x163\\x1cD\\xbd\\xbe\\xd9'\\x84\\x1f\\x94\"))\n    print('\\n')\n    print('4.2.2.2.2 LMv1 Response')\n    hexdump(lmResponse)\n    self.assertEqual(lmResponse, bytearray(b'\\x98\\xde\\xf7\\xb8\\x7f\\x88\\xaa]\\xaf\\xe2\\xdfw\\x96\\x88\\xa1r\\xde\\xf1\\x1c}\\\\\\xcd\\xef\\x13'))\n    print('\\n')\n    print('4.2.2.2.2 LMv1 Response with NTLMSSP_NEGOTIATE_LM_KEY set')\n    flags2 = self.flags\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(flags2), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(lmResponse)\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key ')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    keyExchangeKey = ntlm.KXKEY(self.flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    self.assertEqual(encryptedSessionKey, bytearray(b'Q\\x88\"\\xb1\\xb3\\xf3P\\xc8\\x95\\x86\\x82\\xec\\xbb><\\xb7'))\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key (NTLMSSP_NON_NT_KEY)')\n    flags2 = self.flags | ntlm.NTLMSSP_REQUEST_NON_NT_SESSION_KEY\n    keyExchangeKey = ntlm.KXKEY(flags2, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key (NTLMSSP_LM_KEY)')\n    flags2 = self.flags | ntlm.NTLMSSP_NEGOTIATE_LM_KEY\n    keyExchangeKey = ntlm.KXKEY(flags2, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    print('\\n')\n    print('4.2.2.3 AUTHENTICATE MESSAGE')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    keyExchangeKey = ntlm.KXKEY(self.flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags2\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    ntlmChallengeResponse['session_key'] = encryptedSessionKey\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00\\x18\\x00\\x18\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x10\\x00\\x10\\x00\\xac\\x00\\x00\\x00\\xb3\\x82\\x02\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\x98\\xde\\xf7\\xb8\\x7f\\x88\\xaa]\\xaf\\xe2\\xdfw\\x96\\x88\\xa1r\\xde\\xf1\\x1c}\\\\\\xcd\\xef\\x13g\\xc40\\x11\\xf3\\x02\\x98\\xa2\\xad5\\xec\\xe6O\\x163\\x1cD\\xbd\\xbe\\xd9\\'\\x84\\x1f\\x94Q\\x88\"\\xb1\\xb3\\xf3P\\xc8\\x95\\x86\\x82\\xec\\xbb><\\xb7'))\n    print('\\n')\n    print('4.2.2.4 GSS_WrapEx')\n    print('Output of SEAL()')\n    from Cryptodome.Cipher import ARC4\n    cipher = ARC4.new(self.randomSessionKey)\n    handle = cipher.encrypt\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    (sealedMsg, signature) = ntlm.SEAL(self.flags, self.nonce, self.nonce, self.plaintext, self.plaintext, self.seqNum, handle)\n    hexdump(sealedMsg)\n    self.assertEqual(sealedMsg, bytearray(b'V\\xfe\\x04\\xd8a\\xf91\\x9a\\xf0\\xd7#\\x8a.;ME\\x7f\\xb8'))\n    print('\\n')\n    hexdump(signature.getData())\n    self.assertEqual(signature.getData(), bytearray(b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\xdc\\xd1\\xdf.E\\x9d6'))\n    print('\\n')\n    print('####### 4.2.3 NTLMv1 with Client Challenge')\n    flags = ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    print('Flags')\n    hexdump(struct.pack('<L', flags))\n    print('\\n')\n    print('4.2.3.1.1 NTOWFv1(password)')\n    hexdump(ntlm.NTOWFv1(self.password))\n    print('\\n')\n    print('4.2.3.1.2 Session Base Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\xd8rb\\xb0\\xcd\\xe4\\xb1\\xcbt\\x99\\xbe\\xcc\\xcd\\xf1\\x07\\x84'))\n    print('\\n')\n    print('4.2.3.1.3 Key Exchange Key')\n    keyExchangeKey = ntlm.KXKEY(flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    hexdump(keyExchangeKey)\n    print('\\n')\n    print('4.2.3.2.1 LMv1 Response')\n    hexdump(lmResponse)\n    print('\\n')\n    print('4.2.3.2.2 NTLMv1 Response')\n    hexdump(ntResponse)\n    print('\\n')\n    print('AUTHENTICATE MESSAGE')\n    ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags2\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00\\x18\\x00\\x18\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xac\\x00\\x00\\x00\\xb3\\x82\\x02\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00u7\\xf8\\x03\\xae6q(\\xcaE\\x82\\x04\\xbd\\xe7\\xca\\xf8\\x1e\\x97\\xed&\\x83&r2'))\n    print('\\n')\n    print('4.2.3.4 GSS_WrapEx')\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    print('Output of SEAL()')\n    exportedSessionKey = keyExchangeKey\n    clientSigningKey = ntlm.SIGNKEY(flags, exportedSessionKey)\n    clientSealingKey = ntlm.SEALKEY(flags, exportedSessionKey)\n    from Cryptodome.Cipher import ARC4\n    cipher = ARC4.new(clientSigningKey)\n    cipher2 = ARC4.new(clientSealingKey)\n    client_sealing_h = cipher2.encrypt\n    print('SEALKEY()')\n    hexdump(clientSealingKey)\n    print('\\n')\n    print('SIGNKEY()')\n    hexdump(clientSigningKey)\n    print('\\n')\n    print('Sealed Data')\n    (sealedMsg, signature) = ntlm.SEAL(flags, clientSealingKey, clientSigningKey, self.plaintext, self.plaintext, self.seqNum, client_sealing_h)\n    hexdump(sealedMsg)\n    print('\\n')\n    print('Signature')\n    hexdump(signature.getData())\n    print('\\n')",
        "mutated": [
            "def test_ntlmv1(self):\n    if False:\n        i = 10\n    print('####### 4.2.2 NTLMv1 Authentication')\n    ntlm.USE_NTLMv2 = False\n    print('4.2.2.1 LMOWFv1()')\n    res = ntlm.LMOWFv1(self.password)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\xe5,\\xacgA\\x9a\\x9a\"J;\\x10\\x8f?\\xa6\\xcbm'))\n    print('\\n')\n    print('4.2.2.1.2 NTOWFv1()')\n    res = ntlm.NTOWFv1(self.password)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\xa4\\xf4\\x9c@e\\x10\\xbd\\xca\\xb6\\x82N\\xe7\\xc3\\x0f\\xd8R'))\n    print('\\n')\n    print('4.2.2.1.3 Session Base Key and Key Exchange Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\xd8rb\\xb0\\xcd\\xe4\\xb1\\xcbt\\x99\\xbe\\xcc\\xcd\\xf1\\x07\\x84'))\n    print('\\n')\n    print('4.2.2.2.1 NTLMv1 Response')\n    hexdump(ntResponse)\n    self.assertEqual(ntResponse, bytearray(b\"g\\xc40\\x11\\xf3\\x02\\x98\\xa2\\xad5\\xec\\xe6O\\x163\\x1cD\\xbd\\xbe\\xd9'\\x84\\x1f\\x94\"))\n    print('\\n')\n    print('4.2.2.2.2 LMv1 Response')\n    hexdump(lmResponse)\n    self.assertEqual(lmResponse, bytearray(b'\\x98\\xde\\xf7\\xb8\\x7f\\x88\\xaa]\\xaf\\xe2\\xdfw\\x96\\x88\\xa1r\\xde\\xf1\\x1c}\\\\\\xcd\\xef\\x13'))\n    print('\\n')\n    print('4.2.2.2.2 LMv1 Response with NTLMSSP_NEGOTIATE_LM_KEY set')\n    flags2 = self.flags\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(flags2), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(lmResponse)\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key ')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    keyExchangeKey = ntlm.KXKEY(self.flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    self.assertEqual(encryptedSessionKey, bytearray(b'Q\\x88\"\\xb1\\xb3\\xf3P\\xc8\\x95\\x86\\x82\\xec\\xbb><\\xb7'))\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key (NTLMSSP_NON_NT_KEY)')\n    flags2 = self.flags | ntlm.NTLMSSP_REQUEST_NON_NT_SESSION_KEY\n    keyExchangeKey = ntlm.KXKEY(flags2, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key (NTLMSSP_LM_KEY)')\n    flags2 = self.flags | ntlm.NTLMSSP_NEGOTIATE_LM_KEY\n    keyExchangeKey = ntlm.KXKEY(flags2, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    print('\\n')\n    print('4.2.2.3 AUTHENTICATE MESSAGE')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    keyExchangeKey = ntlm.KXKEY(self.flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags2\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    ntlmChallengeResponse['session_key'] = encryptedSessionKey\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00\\x18\\x00\\x18\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x10\\x00\\x10\\x00\\xac\\x00\\x00\\x00\\xb3\\x82\\x02\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\x98\\xde\\xf7\\xb8\\x7f\\x88\\xaa]\\xaf\\xe2\\xdfw\\x96\\x88\\xa1r\\xde\\xf1\\x1c}\\\\\\xcd\\xef\\x13g\\xc40\\x11\\xf3\\x02\\x98\\xa2\\xad5\\xec\\xe6O\\x163\\x1cD\\xbd\\xbe\\xd9\\'\\x84\\x1f\\x94Q\\x88\"\\xb1\\xb3\\xf3P\\xc8\\x95\\x86\\x82\\xec\\xbb><\\xb7'))\n    print('\\n')\n    print('4.2.2.4 GSS_WrapEx')\n    print('Output of SEAL()')\n    from Cryptodome.Cipher import ARC4\n    cipher = ARC4.new(self.randomSessionKey)\n    handle = cipher.encrypt\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    (sealedMsg, signature) = ntlm.SEAL(self.flags, self.nonce, self.nonce, self.plaintext, self.plaintext, self.seqNum, handle)\n    hexdump(sealedMsg)\n    self.assertEqual(sealedMsg, bytearray(b'V\\xfe\\x04\\xd8a\\xf91\\x9a\\xf0\\xd7#\\x8a.;ME\\x7f\\xb8'))\n    print('\\n')\n    hexdump(signature.getData())\n    self.assertEqual(signature.getData(), bytearray(b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\xdc\\xd1\\xdf.E\\x9d6'))\n    print('\\n')\n    print('####### 4.2.3 NTLMv1 with Client Challenge')\n    flags = ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    print('Flags')\n    hexdump(struct.pack('<L', flags))\n    print('\\n')\n    print('4.2.3.1.1 NTOWFv1(password)')\n    hexdump(ntlm.NTOWFv1(self.password))\n    print('\\n')\n    print('4.2.3.1.2 Session Base Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\xd8rb\\xb0\\xcd\\xe4\\xb1\\xcbt\\x99\\xbe\\xcc\\xcd\\xf1\\x07\\x84'))\n    print('\\n')\n    print('4.2.3.1.3 Key Exchange Key')\n    keyExchangeKey = ntlm.KXKEY(flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    hexdump(keyExchangeKey)\n    print('\\n')\n    print('4.2.3.2.1 LMv1 Response')\n    hexdump(lmResponse)\n    print('\\n')\n    print('4.2.3.2.2 NTLMv1 Response')\n    hexdump(ntResponse)\n    print('\\n')\n    print('AUTHENTICATE MESSAGE')\n    ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags2\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00\\x18\\x00\\x18\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xac\\x00\\x00\\x00\\xb3\\x82\\x02\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00u7\\xf8\\x03\\xae6q(\\xcaE\\x82\\x04\\xbd\\xe7\\xca\\xf8\\x1e\\x97\\xed&\\x83&r2'))\n    print('\\n')\n    print('4.2.3.4 GSS_WrapEx')\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    print('Output of SEAL()')\n    exportedSessionKey = keyExchangeKey\n    clientSigningKey = ntlm.SIGNKEY(flags, exportedSessionKey)\n    clientSealingKey = ntlm.SEALKEY(flags, exportedSessionKey)\n    from Cryptodome.Cipher import ARC4\n    cipher = ARC4.new(clientSigningKey)\n    cipher2 = ARC4.new(clientSealingKey)\n    client_sealing_h = cipher2.encrypt\n    print('SEALKEY()')\n    hexdump(clientSealingKey)\n    print('\\n')\n    print('SIGNKEY()')\n    hexdump(clientSigningKey)\n    print('\\n')\n    print('Sealed Data')\n    (sealedMsg, signature) = ntlm.SEAL(flags, clientSealingKey, clientSigningKey, self.plaintext, self.plaintext, self.seqNum, client_sealing_h)\n    hexdump(sealedMsg)\n    print('\\n')\n    print('Signature')\n    hexdump(signature.getData())\n    print('\\n')",
            "def test_ntlmv1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('####### 4.2.2 NTLMv1 Authentication')\n    ntlm.USE_NTLMv2 = False\n    print('4.2.2.1 LMOWFv1()')\n    res = ntlm.LMOWFv1(self.password)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\xe5,\\xacgA\\x9a\\x9a\"J;\\x10\\x8f?\\xa6\\xcbm'))\n    print('\\n')\n    print('4.2.2.1.2 NTOWFv1()')\n    res = ntlm.NTOWFv1(self.password)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\xa4\\xf4\\x9c@e\\x10\\xbd\\xca\\xb6\\x82N\\xe7\\xc3\\x0f\\xd8R'))\n    print('\\n')\n    print('4.2.2.1.3 Session Base Key and Key Exchange Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\xd8rb\\xb0\\xcd\\xe4\\xb1\\xcbt\\x99\\xbe\\xcc\\xcd\\xf1\\x07\\x84'))\n    print('\\n')\n    print('4.2.2.2.1 NTLMv1 Response')\n    hexdump(ntResponse)\n    self.assertEqual(ntResponse, bytearray(b\"g\\xc40\\x11\\xf3\\x02\\x98\\xa2\\xad5\\xec\\xe6O\\x163\\x1cD\\xbd\\xbe\\xd9'\\x84\\x1f\\x94\"))\n    print('\\n')\n    print('4.2.2.2.2 LMv1 Response')\n    hexdump(lmResponse)\n    self.assertEqual(lmResponse, bytearray(b'\\x98\\xde\\xf7\\xb8\\x7f\\x88\\xaa]\\xaf\\xe2\\xdfw\\x96\\x88\\xa1r\\xde\\xf1\\x1c}\\\\\\xcd\\xef\\x13'))\n    print('\\n')\n    print('4.2.2.2.2 LMv1 Response with NTLMSSP_NEGOTIATE_LM_KEY set')\n    flags2 = self.flags\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(flags2), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(lmResponse)\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key ')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    keyExchangeKey = ntlm.KXKEY(self.flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    self.assertEqual(encryptedSessionKey, bytearray(b'Q\\x88\"\\xb1\\xb3\\xf3P\\xc8\\x95\\x86\\x82\\xec\\xbb><\\xb7'))\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key (NTLMSSP_NON_NT_KEY)')\n    flags2 = self.flags | ntlm.NTLMSSP_REQUEST_NON_NT_SESSION_KEY\n    keyExchangeKey = ntlm.KXKEY(flags2, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key (NTLMSSP_LM_KEY)')\n    flags2 = self.flags | ntlm.NTLMSSP_NEGOTIATE_LM_KEY\n    keyExchangeKey = ntlm.KXKEY(flags2, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    print('\\n')\n    print('4.2.2.3 AUTHENTICATE MESSAGE')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    keyExchangeKey = ntlm.KXKEY(self.flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags2\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    ntlmChallengeResponse['session_key'] = encryptedSessionKey\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00\\x18\\x00\\x18\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x10\\x00\\x10\\x00\\xac\\x00\\x00\\x00\\xb3\\x82\\x02\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\x98\\xde\\xf7\\xb8\\x7f\\x88\\xaa]\\xaf\\xe2\\xdfw\\x96\\x88\\xa1r\\xde\\xf1\\x1c}\\\\\\xcd\\xef\\x13g\\xc40\\x11\\xf3\\x02\\x98\\xa2\\xad5\\xec\\xe6O\\x163\\x1cD\\xbd\\xbe\\xd9\\'\\x84\\x1f\\x94Q\\x88\"\\xb1\\xb3\\xf3P\\xc8\\x95\\x86\\x82\\xec\\xbb><\\xb7'))\n    print('\\n')\n    print('4.2.2.4 GSS_WrapEx')\n    print('Output of SEAL()')\n    from Cryptodome.Cipher import ARC4\n    cipher = ARC4.new(self.randomSessionKey)\n    handle = cipher.encrypt\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    (sealedMsg, signature) = ntlm.SEAL(self.flags, self.nonce, self.nonce, self.plaintext, self.plaintext, self.seqNum, handle)\n    hexdump(sealedMsg)\n    self.assertEqual(sealedMsg, bytearray(b'V\\xfe\\x04\\xd8a\\xf91\\x9a\\xf0\\xd7#\\x8a.;ME\\x7f\\xb8'))\n    print('\\n')\n    hexdump(signature.getData())\n    self.assertEqual(signature.getData(), bytearray(b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\xdc\\xd1\\xdf.E\\x9d6'))\n    print('\\n')\n    print('####### 4.2.3 NTLMv1 with Client Challenge')\n    flags = ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    print('Flags')\n    hexdump(struct.pack('<L', flags))\n    print('\\n')\n    print('4.2.3.1.1 NTOWFv1(password)')\n    hexdump(ntlm.NTOWFv1(self.password))\n    print('\\n')\n    print('4.2.3.1.2 Session Base Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\xd8rb\\xb0\\xcd\\xe4\\xb1\\xcbt\\x99\\xbe\\xcc\\xcd\\xf1\\x07\\x84'))\n    print('\\n')\n    print('4.2.3.1.3 Key Exchange Key')\n    keyExchangeKey = ntlm.KXKEY(flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    hexdump(keyExchangeKey)\n    print('\\n')\n    print('4.2.3.2.1 LMv1 Response')\n    hexdump(lmResponse)\n    print('\\n')\n    print('4.2.3.2.2 NTLMv1 Response')\n    hexdump(ntResponse)\n    print('\\n')\n    print('AUTHENTICATE MESSAGE')\n    ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags2\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00\\x18\\x00\\x18\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xac\\x00\\x00\\x00\\xb3\\x82\\x02\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00u7\\xf8\\x03\\xae6q(\\xcaE\\x82\\x04\\xbd\\xe7\\xca\\xf8\\x1e\\x97\\xed&\\x83&r2'))\n    print('\\n')\n    print('4.2.3.4 GSS_WrapEx')\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    print('Output of SEAL()')\n    exportedSessionKey = keyExchangeKey\n    clientSigningKey = ntlm.SIGNKEY(flags, exportedSessionKey)\n    clientSealingKey = ntlm.SEALKEY(flags, exportedSessionKey)\n    from Cryptodome.Cipher import ARC4\n    cipher = ARC4.new(clientSigningKey)\n    cipher2 = ARC4.new(clientSealingKey)\n    client_sealing_h = cipher2.encrypt\n    print('SEALKEY()')\n    hexdump(clientSealingKey)\n    print('\\n')\n    print('SIGNKEY()')\n    hexdump(clientSigningKey)\n    print('\\n')\n    print('Sealed Data')\n    (sealedMsg, signature) = ntlm.SEAL(flags, clientSealingKey, clientSigningKey, self.plaintext, self.plaintext, self.seqNum, client_sealing_h)\n    hexdump(sealedMsg)\n    print('\\n')\n    print('Signature')\n    hexdump(signature.getData())\n    print('\\n')",
            "def test_ntlmv1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('####### 4.2.2 NTLMv1 Authentication')\n    ntlm.USE_NTLMv2 = False\n    print('4.2.2.1 LMOWFv1()')\n    res = ntlm.LMOWFv1(self.password)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\xe5,\\xacgA\\x9a\\x9a\"J;\\x10\\x8f?\\xa6\\xcbm'))\n    print('\\n')\n    print('4.2.2.1.2 NTOWFv1()')\n    res = ntlm.NTOWFv1(self.password)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\xa4\\xf4\\x9c@e\\x10\\xbd\\xca\\xb6\\x82N\\xe7\\xc3\\x0f\\xd8R'))\n    print('\\n')\n    print('4.2.2.1.3 Session Base Key and Key Exchange Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\xd8rb\\xb0\\xcd\\xe4\\xb1\\xcbt\\x99\\xbe\\xcc\\xcd\\xf1\\x07\\x84'))\n    print('\\n')\n    print('4.2.2.2.1 NTLMv1 Response')\n    hexdump(ntResponse)\n    self.assertEqual(ntResponse, bytearray(b\"g\\xc40\\x11\\xf3\\x02\\x98\\xa2\\xad5\\xec\\xe6O\\x163\\x1cD\\xbd\\xbe\\xd9'\\x84\\x1f\\x94\"))\n    print('\\n')\n    print('4.2.2.2.2 LMv1 Response')\n    hexdump(lmResponse)\n    self.assertEqual(lmResponse, bytearray(b'\\x98\\xde\\xf7\\xb8\\x7f\\x88\\xaa]\\xaf\\xe2\\xdfw\\x96\\x88\\xa1r\\xde\\xf1\\x1c}\\\\\\xcd\\xef\\x13'))\n    print('\\n')\n    print('4.2.2.2.2 LMv1 Response with NTLMSSP_NEGOTIATE_LM_KEY set')\n    flags2 = self.flags\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(flags2), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(lmResponse)\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key ')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    keyExchangeKey = ntlm.KXKEY(self.flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    self.assertEqual(encryptedSessionKey, bytearray(b'Q\\x88\"\\xb1\\xb3\\xf3P\\xc8\\x95\\x86\\x82\\xec\\xbb><\\xb7'))\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key (NTLMSSP_NON_NT_KEY)')\n    flags2 = self.flags | ntlm.NTLMSSP_REQUEST_NON_NT_SESSION_KEY\n    keyExchangeKey = ntlm.KXKEY(flags2, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key (NTLMSSP_LM_KEY)')\n    flags2 = self.flags | ntlm.NTLMSSP_NEGOTIATE_LM_KEY\n    keyExchangeKey = ntlm.KXKEY(flags2, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    print('\\n')\n    print('4.2.2.3 AUTHENTICATE MESSAGE')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    keyExchangeKey = ntlm.KXKEY(self.flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags2\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    ntlmChallengeResponse['session_key'] = encryptedSessionKey\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00\\x18\\x00\\x18\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x10\\x00\\x10\\x00\\xac\\x00\\x00\\x00\\xb3\\x82\\x02\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\x98\\xde\\xf7\\xb8\\x7f\\x88\\xaa]\\xaf\\xe2\\xdfw\\x96\\x88\\xa1r\\xde\\xf1\\x1c}\\\\\\xcd\\xef\\x13g\\xc40\\x11\\xf3\\x02\\x98\\xa2\\xad5\\xec\\xe6O\\x163\\x1cD\\xbd\\xbe\\xd9\\'\\x84\\x1f\\x94Q\\x88\"\\xb1\\xb3\\xf3P\\xc8\\x95\\x86\\x82\\xec\\xbb><\\xb7'))\n    print('\\n')\n    print('4.2.2.4 GSS_WrapEx')\n    print('Output of SEAL()')\n    from Cryptodome.Cipher import ARC4\n    cipher = ARC4.new(self.randomSessionKey)\n    handle = cipher.encrypt\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    (sealedMsg, signature) = ntlm.SEAL(self.flags, self.nonce, self.nonce, self.plaintext, self.plaintext, self.seqNum, handle)\n    hexdump(sealedMsg)\n    self.assertEqual(sealedMsg, bytearray(b'V\\xfe\\x04\\xd8a\\xf91\\x9a\\xf0\\xd7#\\x8a.;ME\\x7f\\xb8'))\n    print('\\n')\n    hexdump(signature.getData())\n    self.assertEqual(signature.getData(), bytearray(b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\xdc\\xd1\\xdf.E\\x9d6'))\n    print('\\n')\n    print('####### 4.2.3 NTLMv1 with Client Challenge')\n    flags = ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    print('Flags')\n    hexdump(struct.pack('<L', flags))\n    print('\\n')\n    print('4.2.3.1.1 NTOWFv1(password)')\n    hexdump(ntlm.NTOWFv1(self.password))\n    print('\\n')\n    print('4.2.3.1.2 Session Base Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\xd8rb\\xb0\\xcd\\xe4\\xb1\\xcbt\\x99\\xbe\\xcc\\xcd\\xf1\\x07\\x84'))\n    print('\\n')\n    print('4.2.3.1.3 Key Exchange Key')\n    keyExchangeKey = ntlm.KXKEY(flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    hexdump(keyExchangeKey)\n    print('\\n')\n    print('4.2.3.2.1 LMv1 Response')\n    hexdump(lmResponse)\n    print('\\n')\n    print('4.2.3.2.2 NTLMv1 Response')\n    hexdump(ntResponse)\n    print('\\n')\n    print('AUTHENTICATE MESSAGE')\n    ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags2\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00\\x18\\x00\\x18\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xac\\x00\\x00\\x00\\xb3\\x82\\x02\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00u7\\xf8\\x03\\xae6q(\\xcaE\\x82\\x04\\xbd\\xe7\\xca\\xf8\\x1e\\x97\\xed&\\x83&r2'))\n    print('\\n')\n    print('4.2.3.4 GSS_WrapEx')\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    print('Output of SEAL()')\n    exportedSessionKey = keyExchangeKey\n    clientSigningKey = ntlm.SIGNKEY(flags, exportedSessionKey)\n    clientSealingKey = ntlm.SEALKEY(flags, exportedSessionKey)\n    from Cryptodome.Cipher import ARC4\n    cipher = ARC4.new(clientSigningKey)\n    cipher2 = ARC4.new(clientSealingKey)\n    client_sealing_h = cipher2.encrypt\n    print('SEALKEY()')\n    hexdump(clientSealingKey)\n    print('\\n')\n    print('SIGNKEY()')\n    hexdump(clientSigningKey)\n    print('\\n')\n    print('Sealed Data')\n    (sealedMsg, signature) = ntlm.SEAL(flags, clientSealingKey, clientSigningKey, self.plaintext, self.plaintext, self.seqNum, client_sealing_h)\n    hexdump(sealedMsg)\n    print('\\n')\n    print('Signature')\n    hexdump(signature.getData())\n    print('\\n')",
            "def test_ntlmv1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('####### 4.2.2 NTLMv1 Authentication')\n    ntlm.USE_NTLMv2 = False\n    print('4.2.2.1 LMOWFv1()')\n    res = ntlm.LMOWFv1(self.password)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\xe5,\\xacgA\\x9a\\x9a\"J;\\x10\\x8f?\\xa6\\xcbm'))\n    print('\\n')\n    print('4.2.2.1.2 NTOWFv1()')\n    res = ntlm.NTOWFv1(self.password)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\xa4\\xf4\\x9c@e\\x10\\xbd\\xca\\xb6\\x82N\\xe7\\xc3\\x0f\\xd8R'))\n    print('\\n')\n    print('4.2.2.1.3 Session Base Key and Key Exchange Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\xd8rb\\xb0\\xcd\\xe4\\xb1\\xcbt\\x99\\xbe\\xcc\\xcd\\xf1\\x07\\x84'))\n    print('\\n')\n    print('4.2.2.2.1 NTLMv1 Response')\n    hexdump(ntResponse)\n    self.assertEqual(ntResponse, bytearray(b\"g\\xc40\\x11\\xf3\\x02\\x98\\xa2\\xad5\\xec\\xe6O\\x163\\x1cD\\xbd\\xbe\\xd9'\\x84\\x1f\\x94\"))\n    print('\\n')\n    print('4.2.2.2.2 LMv1 Response')\n    hexdump(lmResponse)\n    self.assertEqual(lmResponse, bytearray(b'\\x98\\xde\\xf7\\xb8\\x7f\\x88\\xaa]\\xaf\\xe2\\xdfw\\x96\\x88\\xa1r\\xde\\xf1\\x1c}\\\\\\xcd\\xef\\x13'))\n    print('\\n')\n    print('4.2.2.2.2 LMv1 Response with NTLMSSP_NEGOTIATE_LM_KEY set')\n    flags2 = self.flags\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(flags2), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(lmResponse)\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key ')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    keyExchangeKey = ntlm.KXKEY(self.flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    self.assertEqual(encryptedSessionKey, bytearray(b'Q\\x88\"\\xb1\\xb3\\xf3P\\xc8\\x95\\x86\\x82\\xec\\xbb><\\xb7'))\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key (NTLMSSP_NON_NT_KEY)')\n    flags2 = self.flags | ntlm.NTLMSSP_REQUEST_NON_NT_SESSION_KEY\n    keyExchangeKey = ntlm.KXKEY(flags2, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key (NTLMSSP_LM_KEY)')\n    flags2 = self.flags | ntlm.NTLMSSP_NEGOTIATE_LM_KEY\n    keyExchangeKey = ntlm.KXKEY(flags2, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    print('\\n')\n    print('4.2.2.3 AUTHENTICATE MESSAGE')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    keyExchangeKey = ntlm.KXKEY(self.flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags2\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    ntlmChallengeResponse['session_key'] = encryptedSessionKey\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00\\x18\\x00\\x18\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x10\\x00\\x10\\x00\\xac\\x00\\x00\\x00\\xb3\\x82\\x02\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\x98\\xde\\xf7\\xb8\\x7f\\x88\\xaa]\\xaf\\xe2\\xdfw\\x96\\x88\\xa1r\\xde\\xf1\\x1c}\\\\\\xcd\\xef\\x13g\\xc40\\x11\\xf3\\x02\\x98\\xa2\\xad5\\xec\\xe6O\\x163\\x1cD\\xbd\\xbe\\xd9\\'\\x84\\x1f\\x94Q\\x88\"\\xb1\\xb3\\xf3P\\xc8\\x95\\x86\\x82\\xec\\xbb><\\xb7'))\n    print('\\n')\n    print('4.2.2.4 GSS_WrapEx')\n    print('Output of SEAL()')\n    from Cryptodome.Cipher import ARC4\n    cipher = ARC4.new(self.randomSessionKey)\n    handle = cipher.encrypt\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    (sealedMsg, signature) = ntlm.SEAL(self.flags, self.nonce, self.nonce, self.plaintext, self.plaintext, self.seqNum, handle)\n    hexdump(sealedMsg)\n    self.assertEqual(sealedMsg, bytearray(b'V\\xfe\\x04\\xd8a\\xf91\\x9a\\xf0\\xd7#\\x8a.;ME\\x7f\\xb8'))\n    print('\\n')\n    hexdump(signature.getData())\n    self.assertEqual(signature.getData(), bytearray(b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\xdc\\xd1\\xdf.E\\x9d6'))\n    print('\\n')\n    print('####### 4.2.3 NTLMv1 with Client Challenge')\n    flags = ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    print('Flags')\n    hexdump(struct.pack('<L', flags))\n    print('\\n')\n    print('4.2.3.1.1 NTOWFv1(password)')\n    hexdump(ntlm.NTOWFv1(self.password))\n    print('\\n')\n    print('4.2.3.1.2 Session Base Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\xd8rb\\xb0\\xcd\\xe4\\xb1\\xcbt\\x99\\xbe\\xcc\\xcd\\xf1\\x07\\x84'))\n    print('\\n')\n    print('4.2.3.1.3 Key Exchange Key')\n    keyExchangeKey = ntlm.KXKEY(flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    hexdump(keyExchangeKey)\n    print('\\n')\n    print('4.2.3.2.1 LMv1 Response')\n    hexdump(lmResponse)\n    print('\\n')\n    print('4.2.3.2.2 NTLMv1 Response')\n    hexdump(ntResponse)\n    print('\\n')\n    print('AUTHENTICATE MESSAGE')\n    ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags2\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00\\x18\\x00\\x18\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xac\\x00\\x00\\x00\\xb3\\x82\\x02\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00u7\\xf8\\x03\\xae6q(\\xcaE\\x82\\x04\\xbd\\xe7\\xca\\xf8\\x1e\\x97\\xed&\\x83&r2'))\n    print('\\n')\n    print('4.2.3.4 GSS_WrapEx')\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    print('Output of SEAL()')\n    exportedSessionKey = keyExchangeKey\n    clientSigningKey = ntlm.SIGNKEY(flags, exportedSessionKey)\n    clientSealingKey = ntlm.SEALKEY(flags, exportedSessionKey)\n    from Cryptodome.Cipher import ARC4\n    cipher = ARC4.new(clientSigningKey)\n    cipher2 = ARC4.new(clientSealingKey)\n    client_sealing_h = cipher2.encrypt\n    print('SEALKEY()')\n    hexdump(clientSealingKey)\n    print('\\n')\n    print('SIGNKEY()')\n    hexdump(clientSigningKey)\n    print('\\n')\n    print('Sealed Data')\n    (sealedMsg, signature) = ntlm.SEAL(flags, clientSealingKey, clientSigningKey, self.plaintext, self.plaintext, self.seqNum, client_sealing_h)\n    hexdump(sealedMsg)\n    print('\\n')\n    print('Signature')\n    hexdump(signature.getData())\n    print('\\n')",
            "def test_ntlmv1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('####### 4.2.2 NTLMv1 Authentication')\n    ntlm.USE_NTLMv2 = False\n    print('4.2.2.1 LMOWFv1()')\n    res = ntlm.LMOWFv1(self.password)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\xe5,\\xacgA\\x9a\\x9a\"J;\\x10\\x8f?\\xa6\\xcbm'))\n    print('\\n')\n    print('4.2.2.1.2 NTOWFv1()')\n    res = ntlm.NTOWFv1(self.password)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\xa4\\xf4\\x9c@e\\x10\\xbd\\xca\\xb6\\x82N\\xe7\\xc3\\x0f\\xd8R'))\n    print('\\n')\n    print('4.2.2.1.3 Session Base Key and Key Exchange Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\xd8rb\\xb0\\xcd\\xe4\\xb1\\xcbt\\x99\\xbe\\xcc\\xcd\\xf1\\x07\\x84'))\n    print('\\n')\n    print('4.2.2.2.1 NTLMv1 Response')\n    hexdump(ntResponse)\n    self.assertEqual(ntResponse, bytearray(b\"g\\xc40\\x11\\xf3\\x02\\x98\\xa2\\xad5\\xec\\xe6O\\x163\\x1cD\\xbd\\xbe\\xd9'\\x84\\x1f\\x94\"))\n    print('\\n')\n    print('4.2.2.2.2 LMv1 Response')\n    hexdump(lmResponse)\n    self.assertEqual(lmResponse, bytearray(b'\\x98\\xde\\xf7\\xb8\\x7f\\x88\\xaa]\\xaf\\xe2\\xdfw\\x96\\x88\\xa1r\\xde\\xf1\\x1c}\\\\\\xcd\\xef\\x13'))\n    print('\\n')\n    print('4.2.2.2.2 LMv1 Response with NTLMSSP_NEGOTIATE_LM_KEY set')\n    flags2 = self.flags\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(flags2), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(lmResponse)\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key ')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    keyExchangeKey = ntlm.KXKEY(self.flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    self.assertEqual(encryptedSessionKey, bytearray(b'Q\\x88\"\\xb1\\xb3\\xf3P\\xc8\\x95\\x86\\x82\\xec\\xbb><\\xb7'))\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key (NTLMSSP_NON_NT_KEY)')\n    flags2 = self.flags | ntlm.NTLMSSP_REQUEST_NON_NT_SESSION_KEY\n    keyExchangeKey = ntlm.KXKEY(flags2, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    print('\\n')\n    print('4.2.2.2.3 Encrypted Session Key (NTLMSSP_LM_KEY)')\n    flags2 = self.flags | ntlm.NTLMSSP_NEGOTIATE_LM_KEY\n    keyExchangeKey = ntlm.KXKEY(flags2, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    print('\\n')\n    print('4.2.2.3 AUTHENTICATE MESSAGE')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(self.flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    keyExchangeKey = ntlm.KXKEY(self.flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags2\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    ntlmChallengeResponse['session_key'] = encryptedSessionKey\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00\\x18\\x00\\x18\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x10\\x00\\x10\\x00\\xac\\x00\\x00\\x00\\xb3\\x82\\x02\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\x98\\xde\\xf7\\xb8\\x7f\\x88\\xaa]\\xaf\\xe2\\xdfw\\x96\\x88\\xa1r\\xde\\xf1\\x1c}\\\\\\xcd\\xef\\x13g\\xc40\\x11\\xf3\\x02\\x98\\xa2\\xad5\\xec\\xe6O\\x163\\x1cD\\xbd\\xbe\\xd9\\'\\x84\\x1f\\x94Q\\x88\"\\xb1\\xb3\\xf3P\\xc8\\x95\\x86\\x82\\xec\\xbb><\\xb7'))\n    print('\\n')\n    print('4.2.2.4 GSS_WrapEx')\n    print('Output of SEAL()')\n    from Cryptodome.Cipher import ARC4\n    cipher = ARC4.new(self.randomSessionKey)\n    handle = cipher.encrypt\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    (sealedMsg, signature) = ntlm.SEAL(self.flags, self.nonce, self.nonce, self.plaintext, self.plaintext, self.seqNum, handle)\n    hexdump(sealedMsg)\n    self.assertEqual(sealedMsg, bytearray(b'V\\xfe\\x04\\xd8a\\xf91\\x9a\\xf0\\xd7#\\x8a.;ME\\x7f\\xb8'))\n    print('\\n')\n    hexdump(signature.getData())\n    self.assertEqual(signature.getData(), bytearray(b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\xdc\\xd1\\xdf.E\\x9d6'))\n    print('\\n')\n    print('####### 4.2.3 NTLMv1 with Client Challenge')\n    flags = ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    print('Flags')\n    hexdump(struct.pack('<L', flags))\n    print('\\n')\n    print('4.2.3.1.1 NTOWFv1(password)')\n    hexdump(ntlm.NTOWFv1(self.password))\n    print('\\n')\n    print('4.2.3.1.2 Session Base Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv1(int(flags), self.serverChallenge, self.clientChallenge, self.serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\xd8rb\\xb0\\xcd\\xe4\\xb1\\xcbt\\x99\\xbe\\xcc\\xcd\\xf1\\x07\\x84'))\n    print('\\n')\n    print('4.2.3.1.3 Key Exchange Key')\n    keyExchangeKey = ntlm.KXKEY(flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    hexdump(keyExchangeKey)\n    print('\\n')\n    print('4.2.3.2.1 LMv1 Response')\n    hexdump(lmResponse)\n    print('\\n')\n    print('4.2.3.2.2 NTLMv1 Response')\n    hexdump(ntResponse)\n    print('\\n')\n    print('AUTHENTICATE MESSAGE')\n    ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags2\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00\\x18\\x00\\x18\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xac\\x00\\x00\\x00\\xb3\\x82\\x02\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00u7\\xf8\\x03\\xae6q(\\xcaE\\x82\\x04\\xbd\\xe7\\xca\\xf8\\x1e\\x97\\xed&\\x83&r2'))\n    print('\\n')\n    print('4.2.3.4 GSS_WrapEx')\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    print('Output of SEAL()')\n    exportedSessionKey = keyExchangeKey\n    clientSigningKey = ntlm.SIGNKEY(flags, exportedSessionKey)\n    clientSealingKey = ntlm.SEALKEY(flags, exportedSessionKey)\n    from Cryptodome.Cipher import ARC4\n    cipher = ARC4.new(clientSigningKey)\n    cipher2 = ARC4.new(clientSealingKey)\n    client_sealing_h = cipher2.encrypt\n    print('SEALKEY()')\n    hexdump(clientSealingKey)\n    print('\\n')\n    print('SIGNKEY()')\n    hexdump(clientSigningKey)\n    print('\\n')\n    print('Sealed Data')\n    (sealedMsg, signature) = ntlm.SEAL(flags, clientSealingKey, clientSigningKey, self.plaintext, self.plaintext, self.seqNum, client_sealing_h)\n    hexdump(sealedMsg)\n    print('\\n')\n    print('Signature')\n    hexdump(signature.getData())\n    print('\\n')"
        ]
    },
    {
        "func_name": "test_ntlmv2",
        "original": "def test_ntlmv2(self):\n    print('####### 4.2.4 NTLMv2 Authentication')\n    ntlm.USE_NTLMv2 = True\n    serverName = b('\\x02\\x00\\x0c\\x00D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00\\x01\\x00\\x0c\\x00S\\x00e\\x00r\\x00v\\x00e\\x00r\\x00\\x00\\x00\\x00\\x00')\n    flags = ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH | ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_128 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    print('Flags')\n    hexdump(struct.pack('<L', flags))\n    print('\\n')\n    print('4.2.4.1.1 NTOWFv2 and LMOWFv2')\n    res = ntlm.NTOWFv2(self.user, self.password, self.domain)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\x0c\\x86\\x8a@;\\xfdz\\x93\\xa3\\x00\\x1e\\xf2.\\xf0.?'))\n    print('\\n')\n    print('\\n')\n    print('4.2.4.1.2 Session Base Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv2(flags, self.serverChallenge, self.clientChallenge, serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\x8d\\xe4\\x0c\\xca\\xdb\\xc1J\\x82\\xf1\\\\\\xb0\\xad\\r\\xe9\\\\\\xa3'))\n    print('\\n')\n    print('4.2.4.2.1 LMv2 Response')\n    hexdump(lmResponse)\n    self.assertEqual(lmResponse, bytearray(b'\\x86\\xc3P\\x97\\xac\\x9c\\xec\\x10%TvJW\\xcc\\xcc\\x19\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa'))\n    print('\\n')\n    print('4.2.4.2.2 NTLMv2 Response')\n    hexdump(ntResponse[:16])\n    self.assertEqual(ntResponse[:16], bytearray(b'h\\xcd\\n\\xb8Q\\xe5\\x1c\\x96\\xaa\\xbc\\x92{\\xeb\\xefj\\x1c'))\n    print('\\n')\n    print('4.2.4.2.3 Encrypted Session Key')\n    keyExchangeKey = ntlm.KXKEY(flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    self.assertEqual(encryptedSessionKey, bytearray(b'\\xc5\\xda\\xd2TO\\xc9y\\x90\\x94\\xce\\x1c\\xe9\\x0b\\xc9\\xd0>'))\n    print('\\n')\n    print('AUTHENTICATE MESSAGE')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    ntlmChallengeResponse['session_key'] = encryptedSessionKey\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00T\\x00T\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x10\\x00\\x10\\x00\\xe8\\x00\\x00\\x003\\x82\\x8a\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\x86\\xc3P\\x97\\xac\\x9c\\xec\\x10%TvJW\\xcc\\xcc\\x19\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaah\\xcd\\n\\xb8Q\\xe5\\x1c\\x96\\xaa\\xbc\\x92{\\xeb\\xefj\\x1c\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x00\\x00\\x00\\x00\\x02\\x00\\x0c\\x00D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00\\x01\\x00\\x0c\\x00S\\x00e\\x00r\\x00v\\x00e\\x00r\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc5\\xda\\xd2TO\\xc9y\\x90\\x94\\xce\\x1c\\xe9\\x0b\\xc9\\xd0>'))\n    print('\\n')\n    print('4.2.4.4 GSS_WrapEx')\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    print('Output of SEAL()')\n    exportedSessionKey = self.randomSessionKey\n    clientSigningKey = ntlm.SIGNKEY(flags, exportedSessionKey)\n    clientSealingKey = ntlm.SEALKEY(flags, exportedSessionKey)\n    from Cryptodome.Cipher import ARC4\n    cipher2 = ARC4.new(clientSealingKey)\n    client_sealing_h = cipher2.encrypt\n    print('SEALKEY()')\n    hexdump(clientSealingKey)\n    self.assertEqual(clientSealingKey, bytearray(b'Y\\xf6\\x00\\x97<\\xc4\\x96\\n%H\\n|\\x19nLX'))\n    print('\\n')\n    print('SIGNKEY()')\n    hexdump(clientSigningKey)\n    self.assertEqual(clientSigningKey, bytearray(b'G\\x88\\xdc\\x86\\x1bG\\x82\\xf3]C\\xfd\\x98\\xfe\\x1a-9'))\n    print('\\n')\n    print('Sealed Data')\n    (sealedMsg, signature) = ntlm.SEAL(flags, clientSealingKey, clientSigningKey, self.plaintext, self.plaintext, self.seqNum, client_sealing_h)\n    hexdump(sealedMsg)\n    self.assertEqual(sealedMsg, bytearray(b'T\\xe5\\x01e\\xbf\\x196\\xdc\\x99` \\xc1\\x81\\x1b\\x0f\\x06\\xfb_'))\n    print('\\n')\n    print('Signature')\n    hexdump(signature.getData())\n    self.assertEqual(signature.getData(), bytearray(b'\\x01\\x00\\x00\\x00\\x00\\xc1a\\xa1\\x1e@\\x03\\x9f\\x00\\x00\\x00\\x00'))\n    print('\\n')",
        "mutated": [
            "def test_ntlmv2(self):\n    if False:\n        i = 10\n    print('####### 4.2.4 NTLMv2 Authentication')\n    ntlm.USE_NTLMv2 = True\n    serverName = b('\\x02\\x00\\x0c\\x00D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00\\x01\\x00\\x0c\\x00S\\x00e\\x00r\\x00v\\x00e\\x00r\\x00\\x00\\x00\\x00\\x00')\n    flags = ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH | ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_128 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    print('Flags')\n    hexdump(struct.pack('<L', flags))\n    print('\\n')\n    print('4.2.4.1.1 NTOWFv2 and LMOWFv2')\n    res = ntlm.NTOWFv2(self.user, self.password, self.domain)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\x0c\\x86\\x8a@;\\xfdz\\x93\\xa3\\x00\\x1e\\xf2.\\xf0.?'))\n    print('\\n')\n    print('\\n')\n    print('4.2.4.1.2 Session Base Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv2(flags, self.serverChallenge, self.clientChallenge, serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\x8d\\xe4\\x0c\\xca\\xdb\\xc1J\\x82\\xf1\\\\\\xb0\\xad\\r\\xe9\\\\\\xa3'))\n    print('\\n')\n    print('4.2.4.2.1 LMv2 Response')\n    hexdump(lmResponse)\n    self.assertEqual(lmResponse, bytearray(b'\\x86\\xc3P\\x97\\xac\\x9c\\xec\\x10%TvJW\\xcc\\xcc\\x19\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa'))\n    print('\\n')\n    print('4.2.4.2.2 NTLMv2 Response')\n    hexdump(ntResponse[:16])\n    self.assertEqual(ntResponse[:16], bytearray(b'h\\xcd\\n\\xb8Q\\xe5\\x1c\\x96\\xaa\\xbc\\x92{\\xeb\\xefj\\x1c'))\n    print('\\n')\n    print('4.2.4.2.3 Encrypted Session Key')\n    keyExchangeKey = ntlm.KXKEY(flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    self.assertEqual(encryptedSessionKey, bytearray(b'\\xc5\\xda\\xd2TO\\xc9y\\x90\\x94\\xce\\x1c\\xe9\\x0b\\xc9\\xd0>'))\n    print('\\n')\n    print('AUTHENTICATE MESSAGE')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    ntlmChallengeResponse['session_key'] = encryptedSessionKey\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00T\\x00T\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x10\\x00\\x10\\x00\\xe8\\x00\\x00\\x003\\x82\\x8a\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\x86\\xc3P\\x97\\xac\\x9c\\xec\\x10%TvJW\\xcc\\xcc\\x19\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaah\\xcd\\n\\xb8Q\\xe5\\x1c\\x96\\xaa\\xbc\\x92{\\xeb\\xefj\\x1c\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x00\\x00\\x00\\x00\\x02\\x00\\x0c\\x00D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00\\x01\\x00\\x0c\\x00S\\x00e\\x00r\\x00v\\x00e\\x00r\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc5\\xda\\xd2TO\\xc9y\\x90\\x94\\xce\\x1c\\xe9\\x0b\\xc9\\xd0>'))\n    print('\\n')\n    print('4.2.4.4 GSS_WrapEx')\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    print('Output of SEAL()')\n    exportedSessionKey = self.randomSessionKey\n    clientSigningKey = ntlm.SIGNKEY(flags, exportedSessionKey)\n    clientSealingKey = ntlm.SEALKEY(flags, exportedSessionKey)\n    from Cryptodome.Cipher import ARC4\n    cipher2 = ARC4.new(clientSealingKey)\n    client_sealing_h = cipher2.encrypt\n    print('SEALKEY()')\n    hexdump(clientSealingKey)\n    self.assertEqual(clientSealingKey, bytearray(b'Y\\xf6\\x00\\x97<\\xc4\\x96\\n%H\\n|\\x19nLX'))\n    print('\\n')\n    print('SIGNKEY()')\n    hexdump(clientSigningKey)\n    self.assertEqual(clientSigningKey, bytearray(b'G\\x88\\xdc\\x86\\x1bG\\x82\\xf3]C\\xfd\\x98\\xfe\\x1a-9'))\n    print('\\n')\n    print('Sealed Data')\n    (sealedMsg, signature) = ntlm.SEAL(flags, clientSealingKey, clientSigningKey, self.plaintext, self.plaintext, self.seqNum, client_sealing_h)\n    hexdump(sealedMsg)\n    self.assertEqual(sealedMsg, bytearray(b'T\\xe5\\x01e\\xbf\\x196\\xdc\\x99` \\xc1\\x81\\x1b\\x0f\\x06\\xfb_'))\n    print('\\n')\n    print('Signature')\n    hexdump(signature.getData())\n    self.assertEqual(signature.getData(), bytearray(b'\\x01\\x00\\x00\\x00\\x00\\xc1a\\xa1\\x1e@\\x03\\x9f\\x00\\x00\\x00\\x00'))\n    print('\\n')",
            "def test_ntlmv2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('####### 4.2.4 NTLMv2 Authentication')\n    ntlm.USE_NTLMv2 = True\n    serverName = b('\\x02\\x00\\x0c\\x00D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00\\x01\\x00\\x0c\\x00S\\x00e\\x00r\\x00v\\x00e\\x00r\\x00\\x00\\x00\\x00\\x00')\n    flags = ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH | ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_128 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    print('Flags')\n    hexdump(struct.pack('<L', flags))\n    print('\\n')\n    print('4.2.4.1.1 NTOWFv2 and LMOWFv2')\n    res = ntlm.NTOWFv2(self.user, self.password, self.domain)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\x0c\\x86\\x8a@;\\xfdz\\x93\\xa3\\x00\\x1e\\xf2.\\xf0.?'))\n    print('\\n')\n    print('\\n')\n    print('4.2.4.1.2 Session Base Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv2(flags, self.serverChallenge, self.clientChallenge, serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\x8d\\xe4\\x0c\\xca\\xdb\\xc1J\\x82\\xf1\\\\\\xb0\\xad\\r\\xe9\\\\\\xa3'))\n    print('\\n')\n    print('4.2.4.2.1 LMv2 Response')\n    hexdump(lmResponse)\n    self.assertEqual(lmResponse, bytearray(b'\\x86\\xc3P\\x97\\xac\\x9c\\xec\\x10%TvJW\\xcc\\xcc\\x19\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa'))\n    print('\\n')\n    print('4.2.4.2.2 NTLMv2 Response')\n    hexdump(ntResponse[:16])\n    self.assertEqual(ntResponse[:16], bytearray(b'h\\xcd\\n\\xb8Q\\xe5\\x1c\\x96\\xaa\\xbc\\x92{\\xeb\\xefj\\x1c'))\n    print('\\n')\n    print('4.2.4.2.3 Encrypted Session Key')\n    keyExchangeKey = ntlm.KXKEY(flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    self.assertEqual(encryptedSessionKey, bytearray(b'\\xc5\\xda\\xd2TO\\xc9y\\x90\\x94\\xce\\x1c\\xe9\\x0b\\xc9\\xd0>'))\n    print('\\n')\n    print('AUTHENTICATE MESSAGE')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    ntlmChallengeResponse['session_key'] = encryptedSessionKey\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00T\\x00T\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x10\\x00\\x10\\x00\\xe8\\x00\\x00\\x003\\x82\\x8a\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\x86\\xc3P\\x97\\xac\\x9c\\xec\\x10%TvJW\\xcc\\xcc\\x19\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaah\\xcd\\n\\xb8Q\\xe5\\x1c\\x96\\xaa\\xbc\\x92{\\xeb\\xefj\\x1c\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x00\\x00\\x00\\x00\\x02\\x00\\x0c\\x00D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00\\x01\\x00\\x0c\\x00S\\x00e\\x00r\\x00v\\x00e\\x00r\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc5\\xda\\xd2TO\\xc9y\\x90\\x94\\xce\\x1c\\xe9\\x0b\\xc9\\xd0>'))\n    print('\\n')\n    print('4.2.4.4 GSS_WrapEx')\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    print('Output of SEAL()')\n    exportedSessionKey = self.randomSessionKey\n    clientSigningKey = ntlm.SIGNKEY(flags, exportedSessionKey)\n    clientSealingKey = ntlm.SEALKEY(flags, exportedSessionKey)\n    from Cryptodome.Cipher import ARC4\n    cipher2 = ARC4.new(clientSealingKey)\n    client_sealing_h = cipher2.encrypt\n    print('SEALKEY()')\n    hexdump(clientSealingKey)\n    self.assertEqual(clientSealingKey, bytearray(b'Y\\xf6\\x00\\x97<\\xc4\\x96\\n%H\\n|\\x19nLX'))\n    print('\\n')\n    print('SIGNKEY()')\n    hexdump(clientSigningKey)\n    self.assertEqual(clientSigningKey, bytearray(b'G\\x88\\xdc\\x86\\x1bG\\x82\\xf3]C\\xfd\\x98\\xfe\\x1a-9'))\n    print('\\n')\n    print('Sealed Data')\n    (sealedMsg, signature) = ntlm.SEAL(flags, clientSealingKey, clientSigningKey, self.plaintext, self.plaintext, self.seqNum, client_sealing_h)\n    hexdump(sealedMsg)\n    self.assertEqual(sealedMsg, bytearray(b'T\\xe5\\x01e\\xbf\\x196\\xdc\\x99` \\xc1\\x81\\x1b\\x0f\\x06\\xfb_'))\n    print('\\n')\n    print('Signature')\n    hexdump(signature.getData())\n    self.assertEqual(signature.getData(), bytearray(b'\\x01\\x00\\x00\\x00\\x00\\xc1a\\xa1\\x1e@\\x03\\x9f\\x00\\x00\\x00\\x00'))\n    print('\\n')",
            "def test_ntlmv2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('####### 4.2.4 NTLMv2 Authentication')\n    ntlm.USE_NTLMv2 = True\n    serverName = b('\\x02\\x00\\x0c\\x00D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00\\x01\\x00\\x0c\\x00S\\x00e\\x00r\\x00v\\x00e\\x00r\\x00\\x00\\x00\\x00\\x00')\n    flags = ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH | ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_128 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    print('Flags')\n    hexdump(struct.pack('<L', flags))\n    print('\\n')\n    print('4.2.4.1.1 NTOWFv2 and LMOWFv2')\n    res = ntlm.NTOWFv2(self.user, self.password, self.domain)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\x0c\\x86\\x8a@;\\xfdz\\x93\\xa3\\x00\\x1e\\xf2.\\xf0.?'))\n    print('\\n')\n    print('\\n')\n    print('4.2.4.1.2 Session Base Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv2(flags, self.serverChallenge, self.clientChallenge, serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\x8d\\xe4\\x0c\\xca\\xdb\\xc1J\\x82\\xf1\\\\\\xb0\\xad\\r\\xe9\\\\\\xa3'))\n    print('\\n')\n    print('4.2.4.2.1 LMv2 Response')\n    hexdump(lmResponse)\n    self.assertEqual(lmResponse, bytearray(b'\\x86\\xc3P\\x97\\xac\\x9c\\xec\\x10%TvJW\\xcc\\xcc\\x19\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa'))\n    print('\\n')\n    print('4.2.4.2.2 NTLMv2 Response')\n    hexdump(ntResponse[:16])\n    self.assertEqual(ntResponse[:16], bytearray(b'h\\xcd\\n\\xb8Q\\xe5\\x1c\\x96\\xaa\\xbc\\x92{\\xeb\\xefj\\x1c'))\n    print('\\n')\n    print('4.2.4.2.3 Encrypted Session Key')\n    keyExchangeKey = ntlm.KXKEY(flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    self.assertEqual(encryptedSessionKey, bytearray(b'\\xc5\\xda\\xd2TO\\xc9y\\x90\\x94\\xce\\x1c\\xe9\\x0b\\xc9\\xd0>'))\n    print('\\n')\n    print('AUTHENTICATE MESSAGE')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    ntlmChallengeResponse['session_key'] = encryptedSessionKey\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00T\\x00T\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x10\\x00\\x10\\x00\\xe8\\x00\\x00\\x003\\x82\\x8a\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\x86\\xc3P\\x97\\xac\\x9c\\xec\\x10%TvJW\\xcc\\xcc\\x19\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaah\\xcd\\n\\xb8Q\\xe5\\x1c\\x96\\xaa\\xbc\\x92{\\xeb\\xefj\\x1c\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x00\\x00\\x00\\x00\\x02\\x00\\x0c\\x00D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00\\x01\\x00\\x0c\\x00S\\x00e\\x00r\\x00v\\x00e\\x00r\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc5\\xda\\xd2TO\\xc9y\\x90\\x94\\xce\\x1c\\xe9\\x0b\\xc9\\xd0>'))\n    print('\\n')\n    print('4.2.4.4 GSS_WrapEx')\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    print('Output of SEAL()')\n    exportedSessionKey = self.randomSessionKey\n    clientSigningKey = ntlm.SIGNKEY(flags, exportedSessionKey)\n    clientSealingKey = ntlm.SEALKEY(flags, exportedSessionKey)\n    from Cryptodome.Cipher import ARC4\n    cipher2 = ARC4.new(clientSealingKey)\n    client_sealing_h = cipher2.encrypt\n    print('SEALKEY()')\n    hexdump(clientSealingKey)\n    self.assertEqual(clientSealingKey, bytearray(b'Y\\xf6\\x00\\x97<\\xc4\\x96\\n%H\\n|\\x19nLX'))\n    print('\\n')\n    print('SIGNKEY()')\n    hexdump(clientSigningKey)\n    self.assertEqual(clientSigningKey, bytearray(b'G\\x88\\xdc\\x86\\x1bG\\x82\\xf3]C\\xfd\\x98\\xfe\\x1a-9'))\n    print('\\n')\n    print('Sealed Data')\n    (sealedMsg, signature) = ntlm.SEAL(flags, clientSealingKey, clientSigningKey, self.plaintext, self.plaintext, self.seqNum, client_sealing_h)\n    hexdump(sealedMsg)\n    self.assertEqual(sealedMsg, bytearray(b'T\\xe5\\x01e\\xbf\\x196\\xdc\\x99` \\xc1\\x81\\x1b\\x0f\\x06\\xfb_'))\n    print('\\n')\n    print('Signature')\n    hexdump(signature.getData())\n    self.assertEqual(signature.getData(), bytearray(b'\\x01\\x00\\x00\\x00\\x00\\xc1a\\xa1\\x1e@\\x03\\x9f\\x00\\x00\\x00\\x00'))\n    print('\\n')",
            "def test_ntlmv2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('####### 4.2.4 NTLMv2 Authentication')\n    ntlm.USE_NTLMv2 = True\n    serverName = b('\\x02\\x00\\x0c\\x00D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00\\x01\\x00\\x0c\\x00S\\x00e\\x00r\\x00v\\x00e\\x00r\\x00\\x00\\x00\\x00\\x00')\n    flags = ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH | ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_128 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    print('Flags')\n    hexdump(struct.pack('<L', flags))\n    print('\\n')\n    print('4.2.4.1.1 NTOWFv2 and LMOWFv2')\n    res = ntlm.NTOWFv2(self.user, self.password, self.domain)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\x0c\\x86\\x8a@;\\xfdz\\x93\\xa3\\x00\\x1e\\xf2.\\xf0.?'))\n    print('\\n')\n    print('\\n')\n    print('4.2.4.1.2 Session Base Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv2(flags, self.serverChallenge, self.clientChallenge, serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\x8d\\xe4\\x0c\\xca\\xdb\\xc1J\\x82\\xf1\\\\\\xb0\\xad\\r\\xe9\\\\\\xa3'))\n    print('\\n')\n    print('4.2.4.2.1 LMv2 Response')\n    hexdump(lmResponse)\n    self.assertEqual(lmResponse, bytearray(b'\\x86\\xc3P\\x97\\xac\\x9c\\xec\\x10%TvJW\\xcc\\xcc\\x19\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa'))\n    print('\\n')\n    print('4.2.4.2.2 NTLMv2 Response')\n    hexdump(ntResponse[:16])\n    self.assertEqual(ntResponse[:16], bytearray(b'h\\xcd\\n\\xb8Q\\xe5\\x1c\\x96\\xaa\\xbc\\x92{\\xeb\\xefj\\x1c'))\n    print('\\n')\n    print('4.2.4.2.3 Encrypted Session Key')\n    keyExchangeKey = ntlm.KXKEY(flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    self.assertEqual(encryptedSessionKey, bytearray(b'\\xc5\\xda\\xd2TO\\xc9y\\x90\\x94\\xce\\x1c\\xe9\\x0b\\xc9\\xd0>'))\n    print('\\n')\n    print('AUTHENTICATE MESSAGE')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    ntlmChallengeResponse['session_key'] = encryptedSessionKey\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00T\\x00T\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x10\\x00\\x10\\x00\\xe8\\x00\\x00\\x003\\x82\\x8a\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\x86\\xc3P\\x97\\xac\\x9c\\xec\\x10%TvJW\\xcc\\xcc\\x19\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaah\\xcd\\n\\xb8Q\\xe5\\x1c\\x96\\xaa\\xbc\\x92{\\xeb\\xefj\\x1c\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x00\\x00\\x00\\x00\\x02\\x00\\x0c\\x00D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00\\x01\\x00\\x0c\\x00S\\x00e\\x00r\\x00v\\x00e\\x00r\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc5\\xda\\xd2TO\\xc9y\\x90\\x94\\xce\\x1c\\xe9\\x0b\\xc9\\xd0>'))\n    print('\\n')\n    print('4.2.4.4 GSS_WrapEx')\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    print('Output of SEAL()')\n    exportedSessionKey = self.randomSessionKey\n    clientSigningKey = ntlm.SIGNKEY(flags, exportedSessionKey)\n    clientSealingKey = ntlm.SEALKEY(flags, exportedSessionKey)\n    from Cryptodome.Cipher import ARC4\n    cipher2 = ARC4.new(clientSealingKey)\n    client_sealing_h = cipher2.encrypt\n    print('SEALKEY()')\n    hexdump(clientSealingKey)\n    self.assertEqual(clientSealingKey, bytearray(b'Y\\xf6\\x00\\x97<\\xc4\\x96\\n%H\\n|\\x19nLX'))\n    print('\\n')\n    print('SIGNKEY()')\n    hexdump(clientSigningKey)\n    self.assertEqual(clientSigningKey, bytearray(b'G\\x88\\xdc\\x86\\x1bG\\x82\\xf3]C\\xfd\\x98\\xfe\\x1a-9'))\n    print('\\n')\n    print('Sealed Data')\n    (sealedMsg, signature) = ntlm.SEAL(flags, clientSealingKey, clientSigningKey, self.plaintext, self.plaintext, self.seqNum, client_sealing_h)\n    hexdump(sealedMsg)\n    self.assertEqual(sealedMsg, bytearray(b'T\\xe5\\x01e\\xbf\\x196\\xdc\\x99` \\xc1\\x81\\x1b\\x0f\\x06\\xfb_'))\n    print('\\n')\n    print('Signature')\n    hexdump(signature.getData())\n    self.assertEqual(signature.getData(), bytearray(b'\\x01\\x00\\x00\\x00\\x00\\xc1a\\xa1\\x1e@\\x03\\x9f\\x00\\x00\\x00\\x00'))\n    print('\\n')",
            "def test_ntlmv2(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('####### 4.2.4 NTLMv2 Authentication')\n    ntlm.USE_NTLMv2 = True\n    serverName = b('\\x02\\x00\\x0c\\x00D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00\\x01\\x00\\x0c\\x00S\\x00e\\x00r\\x00v\\x00e\\x00r\\x00\\x00\\x00\\x00\\x00')\n    flags = ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH | ntlm.NTLMSSP_NEGOTIATE_56 | ntlm.NTLMSSP_NEGOTIATE_128 | ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_NEGOTIATE_SEAL | ntlm.NTLMSSP_NEGOTIATE_SIGN | ntlm.NTLM_NEGOTIATE_OEM | ntlm.NTLMSSP_NEGOTIATE_UNICODE\n    print('Flags')\n    hexdump(struct.pack('<L', flags))\n    print('\\n')\n    print('4.2.4.1.1 NTOWFv2 and LMOWFv2')\n    res = ntlm.NTOWFv2(self.user, self.password, self.domain)\n    hexdump(res)\n    self.assertEqual(res, bytearray(b'\\x0c\\x86\\x8a@;\\xfdz\\x93\\xa3\\x00\\x1e\\xf2.\\xf0.?'))\n    print('\\n')\n    print('\\n')\n    print('4.2.4.1.2 Session Base Key')\n    (ntResponse, lmResponse, sessionBaseKey) = ntlm.computeResponseNTLMv2(flags, self.serverChallenge, self.clientChallenge, serverName, self.domain, self.user, self.password, '', '')\n    hexdump(sessionBaseKey)\n    self.assertEqual(sessionBaseKey, bytearray(b'\\x8d\\xe4\\x0c\\xca\\xdb\\xc1J\\x82\\xf1\\\\\\xb0\\xad\\r\\xe9\\\\\\xa3'))\n    print('\\n')\n    print('4.2.4.2.1 LMv2 Response')\n    hexdump(lmResponse)\n    self.assertEqual(lmResponse, bytearray(b'\\x86\\xc3P\\x97\\xac\\x9c\\xec\\x10%TvJW\\xcc\\xcc\\x19\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa'))\n    print('\\n')\n    print('4.2.4.2.2 NTLMv2 Response')\n    hexdump(ntResponse[:16])\n    self.assertEqual(ntResponse[:16], bytearray(b'h\\xcd\\n\\xb8Q\\xe5\\x1c\\x96\\xaa\\xbc\\x92{\\xeb\\xefj\\x1c'))\n    print('\\n')\n    print('4.2.4.2.3 Encrypted Session Key')\n    keyExchangeKey = ntlm.KXKEY(flags, sessionBaseKey, lmResponse, self.serverChallenge, self.password, '', '')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    hexdump(encryptedSessionKey)\n    self.assertEqual(encryptedSessionKey, bytearray(b'\\xc5\\xda\\xd2TO\\xc9y\\x90\\x94\\xce\\x1c\\xe9\\x0b\\xc9\\xd0>'))\n    print('\\n')\n    print('AUTHENTICATE MESSAGE')\n    encryptedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, self.randomSessionKey)\n    ntlmChallengeResponse = ntlm.NTLMAuthChallengeResponse(self.user, self.password, self.serverChallenge)\n    ntlmChallengeResponse['flags'] = flags\n    ntlmChallengeResponse['host_name'] = self.workstationName.encode('utf-16le')\n    ntlmChallengeResponse['domain_name'] = self.domain.encode('utf-16le')\n    ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    ntlmChallengeResponse['session_key'] = encryptedSessionKey\n    hexdump(ntlmChallengeResponse.getData())\n    self.assertEqual(ntlmChallengeResponse.getData(), bytearray(b'NTLMSSP\\x00\\x03\\x00\\x00\\x00\\x18\\x00\\x18\\x00|\\x00\\x00\\x00T\\x00T\\x00\\x94\\x00\\x00\\x00\\x0c\\x00\\x0c\\x00X\\x00\\x00\\x00\\x08\\x00\\x08\\x00d\\x00\\x00\\x00\\x10\\x00\\x10\\x00l\\x00\\x00\\x00\\x10\\x00\\x10\\x00\\xe8\\x00\\x00\\x003\\x82\\x8a\\xe2D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00U\\x00s\\x00e\\x00r\\x00C\\x00O\\x00M\\x00P\\x00U\\x00T\\x00E\\x00R\\x00\\x86\\xc3P\\x97\\xac\\x9c\\xec\\x10%TvJW\\xcc\\xcc\\x19\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaah\\xcd\\n\\xb8Q\\xe5\\x1c\\x96\\xaa\\xbc\\x92{\\xeb\\xefj\\x1c\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x00\\x00\\x00\\x00\\x02\\x00\\x0c\\x00D\\x00o\\x00m\\x00a\\x00i\\x00n\\x00\\x01\\x00\\x0c\\x00S\\x00e\\x00r\\x00v\\x00e\\x00r\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc5\\xda\\xd2TO\\xc9y\\x90\\x94\\xce\\x1c\\xe9\\x0b\\xc9\\xd0>'))\n    print('\\n')\n    print('4.2.4.4 GSS_WrapEx')\n    print('Plaintext')\n    hexdump(self.plaintext)\n    print('\\n')\n    print('Output of SEAL()')\n    exportedSessionKey = self.randomSessionKey\n    clientSigningKey = ntlm.SIGNKEY(flags, exportedSessionKey)\n    clientSealingKey = ntlm.SEALKEY(flags, exportedSessionKey)\n    from Cryptodome.Cipher import ARC4\n    cipher2 = ARC4.new(clientSealingKey)\n    client_sealing_h = cipher2.encrypt\n    print('SEALKEY()')\n    hexdump(clientSealingKey)\n    self.assertEqual(clientSealingKey, bytearray(b'Y\\xf6\\x00\\x97<\\xc4\\x96\\n%H\\n|\\x19nLX'))\n    print('\\n')\n    print('SIGNKEY()')\n    hexdump(clientSigningKey)\n    self.assertEqual(clientSigningKey, bytearray(b'G\\x88\\xdc\\x86\\x1bG\\x82\\xf3]C\\xfd\\x98\\xfe\\x1a-9'))\n    print('\\n')\n    print('Sealed Data')\n    (sealedMsg, signature) = ntlm.SEAL(flags, clientSealingKey, clientSigningKey, self.plaintext, self.plaintext, self.seqNum, client_sealing_h)\n    hexdump(sealedMsg)\n    self.assertEqual(sealedMsg, bytearray(b'T\\xe5\\x01e\\xbf\\x196\\xdc\\x99` \\xc1\\x81\\x1b\\x0f\\x06\\xfb_'))\n    print('\\n')\n    print('Signature')\n    hexdump(signature.getData())\n    self.assertEqual(signature.getData(), bytearray(b'\\x01\\x00\\x00\\x00\\x00\\xc1a\\xa1\\x1e@\\x03\\x9f\\x00\\x00\\x00\\x00'))\n    print('\\n')"
        ]
    },
    {
        "func_name": "__pack_and_parse",
        "original": "def __pack_and_parse(self, message, expected):\n    data = message.getData()\n    hexdump(data)\n    self.assertEqual(data, expected)\n    parsed = ntlm.NTLMAuthNegotiate()\n    parsed.fromString(data)\n    return parsed",
        "mutated": [
            "def __pack_and_parse(self, message, expected):\n    if False:\n        i = 10\n    data = message.getData()\n    hexdump(data)\n    self.assertEqual(data, expected)\n    parsed = ntlm.NTLMAuthNegotiate()\n    parsed.fromString(data)\n    return parsed",
            "def __pack_and_parse(self, message, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    data = message.getData()\n    hexdump(data)\n    self.assertEqual(data, expected)\n    parsed = ntlm.NTLMAuthNegotiate()\n    parsed.fromString(data)\n    return parsed",
            "def __pack_and_parse(self, message, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    data = message.getData()\n    hexdump(data)\n    self.assertEqual(data, expected)\n    parsed = ntlm.NTLMAuthNegotiate()\n    parsed.fromString(data)\n    return parsed",
            "def __pack_and_parse(self, message, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    data = message.getData()\n    hexdump(data)\n    self.assertEqual(data, expected)\n    parsed = ntlm.NTLMAuthNegotiate()\n    parsed.fromString(data)\n    return parsed",
            "def __pack_and_parse(self, message, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    data = message.getData()\n    hexdump(data)\n    self.assertEqual(data, expected)\n    parsed = ntlm.NTLMAuthNegotiate()\n    parsed.fromString(data)\n    return parsed"
        ]
    },
    {
        "func_name": "test_refactor_negotiate_message",
        "original": "def test_refactor_negotiate_message(self):\n    print('#### Pack and parse, without version')\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgParsed = self.__pack_and_parse(negoMsgToPack, bytearray(b'NTLMSSP\\x00\\x01\\x00\\x00\\x001\\x02\\x00`\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'))\n    self.assertEqual(negoMsgParsed['flags'] & ntlm.NTLMSSP_NEGOTIATE_VERSION, 0)\n    self.assertEqual(negoMsgParsed['os_version'], '')\n    print('#### Pack and parse, with version')\n    (major, minor, build) = (10, 0, 19041)\n    version = ntlm.VERSION()\n    (version['ProductMajorVersion'], version['ProductMinorVersion'], version['ProductBuild']) = (major, minor, build)\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgToPack['os_version'] = version\n    negoMsgParsed = self.__pack_and_parse(negoMsgToPack, bytearray(b'NTLMSSP\\x00\\x01\\x00\\x00\\x001\\x02\\x00b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\n\\x00aJ\\x00\\x00\\x00\\x0f'))\n    self.assertEqual(negoMsgParsed['flags'] & ntlm.NTLMSSP_NEGOTIATE_VERSION, ntlm.NTLMSSP_NEGOTIATE_VERSION)\n    self.assertEqual(negoMsgParsed['os_version']['ProductMajorVersion'], major)\n    self.assertEqual(negoMsgParsed['os_version']['ProductMinorVersion'], minor)\n    self.assertEqual(negoMsgParsed['os_version']['ProductBuild'], build)\n    print('#### Try to set the NTLMSSP_NEGOTIATE_VERSION flag without specifying os_version')\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgToPack['flags'] |= ntlm.NTLMSSP_NEGOTIATE_VERSION\n    self.assertRaises(Exception, negoMsgToPack.getData)",
        "mutated": [
            "def test_refactor_negotiate_message(self):\n    if False:\n        i = 10\n    print('#### Pack and parse, without version')\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgParsed = self.__pack_and_parse(negoMsgToPack, bytearray(b'NTLMSSP\\x00\\x01\\x00\\x00\\x001\\x02\\x00`\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'))\n    self.assertEqual(negoMsgParsed['flags'] & ntlm.NTLMSSP_NEGOTIATE_VERSION, 0)\n    self.assertEqual(negoMsgParsed['os_version'], '')\n    print('#### Pack and parse, with version')\n    (major, minor, build) = (10, 0, 19041)\n    version = ntlm.VERSION()\n    (version['ProductMajorVersion'], version['ProductMinorVersion'], version['ProductBuild']) = (major, minor, build)\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgToPack['os_version'] = version\n    negoMsgParsed = self.__pack_and_parse(negoMsgToPack, bytearray(b'NTLMSSP\\x00\\x01\\x00\\x00\\x001\\x02\\x00b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\n\\x00aJ\\x00\\x00\\x00\\x0f'))\n    self.assertEqual(negoMsgParsed['flags'] & ntlm.NTLMSSP_NEGOTIATE_VERSION, ntlm.NTLMSSP_NEGOTIATE_VERSION)\n    self.assertEqual(negoMsgParsed['os_version']['ProductMajorVersion'], major)\n    self.assertEqual(negoMsgParsed['os_version']['ProductMinorVersion'], minor)\n    self.assertEqual(negoMsgParsed['os_version']['ProductBuild'], build)\n    print('#### Try to set the NTLMSSP_NEGOTIATE_VERSION flag without specifying os_version')\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgToPack['flags'] |= ntlm.NTLMSSP_NEGOTIATE_VERSION\n    self.assertRaises(Exception, negoMsgToPack.getData)",
            "def test_refactor_negotiate_message(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('#### Pack and parse, without version')\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgParsed = self.__pack_and_parse(negoMsgToPack, bytearray(b'NTLMSSP\\x00\\x01\\x00\\x00\\x001\\x02\\x00`\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'))\n    self.assertEqual(negoMsgParsed['flags'] & ntlm.NTLMSSP_NEGOTIATE_VERSION, 0)\n    self.assertEqual(negoMsgParsed['os_version'], '')\n    print('#### Pack and parse, with version')\n    (major, minor, build) = (10, 0, 19041)\n    version = ntlm.VERSION()\n    (version['ProductMajorVersion'], version['ProductMinorVersion'], version['ProductBuild']) = (major, minor, build)\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgToPack['os_version'] = version\n    negoMsgParsed = self.__pack_and_parse(negoMsgToPack, bytearray(b'NTLMSSP\\x00\\x01\\x00\\x00\\x001\\x02\\x00b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\n\\x00aJ\\x00\\x00\\x00\\x0f'))\n    self.assertEqual(negoMsgParsed['flags'] & ntlm.NTLMSSP_NEGOTIATE_VERSION, ntlm.NTLMSSP_NEGOTIATE_VERSION)\n    self.assertEqual(negoMsgParsed['os_version']['ProductMajorVersion'], major)\n    self.assertEqual(negoMsgParsed['os_version']['ProductMinorVersion'], minor)\n    self.assertEqual(negoMsgParsed['os_version']['ProductBuild'], build)\n    print('#### Try to set the NTLMSSP_NEGOTIATE_VERSION flag without specifying os_version')\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgToPack['flags'] |= ntlm.NTLMSSP_NEGOTIATE_VERSION\n    self.assertRaises(Exception, negoMsgToPack.getData)",
            "def test_refactor_negotiate_message(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('#### Pack and parse, without version')\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgParsed = self.__pack_and_parse(negoMsgToPack, bytearray(b'NTLMSSP\\x00\\x01\\x00\\x00\\x001\\x02\\x00`\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'))\n    self.assertEqual(negoMsgParsed['flags'] & ntlm.NTLMSSP_NEGOTIATE_VERSION, 0)\n    self.assertEqual(negoMsgParsed['os_version'], '')\n    print('#### Pack and parse, with version')\n    (major, minor, build) = (10, 0, 19041)\n    version = ntlm.VERSION()\n    (version['ProductMajorVersion'], version['ProductMinorVersion'], version['ProductBuild']) = (major, minor, build)\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgToPack['os_version'] = version\n    negoMsgParsed = self.__pack_and_parse(negoMsgToPack, bytearray(b'NTLMSSP\\x00\\x01\\x00\\x00\\x001\\x02\\x00b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\n\\x00aJ\\x00\\x00\\x00\\x0f'))\n    self.assertEqual(negoMsgParsed['flags'] & ntlm.NTLMSSP_NEGOTIATE_VERSION, ntlm.NTLMSSP_NEGOTIATE_VERSION)\n    self.assertEqual(negoMsgParsed['os_version']['ProductMajorVersion'], major)\n    self.assertEqual(negoMsgParsed['os_version']['ProductMinorVersion'], minor)\n    self.assertEqual(negoMsgParsed['os_version']['ProductBuild'], build)\n    print('#### Try to set the NTLMSSP_NEGOTIATE_VERSION flag without specifying os_version')\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgToPack['flags'] |= ntlm.NTLMSSP_NEGOTIATE_VERSION\n    self.assertRaises(Exception, negoMsgToPack.getData)",
            "def test_refactor_negotiate_message(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('#### Pack and parse, without version')\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgParsed = self.__pack_and_parse(negoMsgToPack, bytearray(b'NTLMSSP\\x00\\x01\\x00\\x00\\x001\\x02\\x00`\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'))\n    self.assertEqual(negoMsgParsed['flags'] & ntlm.NTLMSSP_NEGOTIATE_VERSION, 0)\n    self.assertEqual(negoMsgParsed['os_version'], '')\n    print('#### Pack and parse, with version')\n    (major, minor, build) = (10, 0, 19041)\n    version = ntlm.VERSION()\n    (version['ProductMajorVersion'], version['ProductMinorVersion'], version['ProductBuild']) = (major, minor, build)\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgToPack['os_version'] = version\n    negoMsgParsed = self.__pack_and_parse(negoMsgToPack, bytearray(b'NTLMSSP\\x00\\x01\\x00\\x00\\x001\\x02\\x00b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\n\\x00aJ\\x00\\x00\\x00\\x0f'))\n    self.assertEqual(negoMsgParsed['flags'] & ntlm.NTLMSSP_NEGOTIATE_VERSION, ntlm.NTLMSSP_NEGOTIATE_VERSION)\n    self.assertEqual(negoMsgParsed['os_version']['ProductMajorVersion'], major)\n    self.assertEqual(negoMsgParsed['os_version']['ProductMinorVersion'], minor)\n    self.assertEqual(negoMsgParsed['os_version']['ProductBuild'], build)\n    print('#### Try to set the NTLMSSP_NEGOTIATE_VERSION flag without specifying os_version')\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgToPack['flags'] |= ntlm.NTLMSSP_NEGOTIATE_VERSION\n    self.assertRaises(Exception, negoMsgToPack.getData)",
            "def test_refactor_negotiate_message(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('#### Pack and parse, without version')\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgParsed = self.__pack_and_parse(negoMsgToPack, bytearray(b'NTLMSSP\\x00\\x01\\x00\\x00\\x001\\x02\\x00`\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'))\n    self.assertEqual(negoMsgParsed['flags'] & ntlm.NTLMSSP_NEGOTIATE_VERSION, 0)\n    self.assertEqual(negoMsgParsed['os_version'], '')\n    print('#### Pack and parse, with version')\n    (major, minor, build) = (10, 0, 19041)\n    version = ntlm.VERSION()\n    (version['ProductMajorVersion'], version['ProductMinorVersion'], version['ProductBuild']) = (major, minor, build)\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgToPack['os_version'] = version\n    negoMsgParsed = self.__pack_and_parse(negoMsgToPack, bytearray(b'NTLMSSP\\x00\\x01\\x00\\x00\\x001\\x02\\x00b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\n\\x00aJ\\x00\\x00\\x00\\x0f'))\n    self.assertEqual(negoMsgParsed['flags'] & ntlm.NTLMSSP_NEGOTIATE_VERSION, ntlm.NTLMSSP_NEGOTIATE_VERSION)\n    self.assertEqual(negoMsgParsed['os_version']['ProductMajorVersion'], major)\n    self.assertEqual(negoMsgParsed['os_version']['ProductMinorVersion'], minor)\n    self.assertEqual(negoMsgParsed['os_version']['ProductBuild'], build)\n    print('#### Try to set the NTLMSSP_NEGOTIATE_VERSION flag without specifying os_version')\n    negoMsgToPack = ntlm.NTLMAuthNegotiate()\n    negoMsgToPack['flags'] |= ntlm.NTLMSSP_NEGOTIATE_VERSION\n    self.assertRaises(Exception, negoMsgToPack.getData)"
        ]
    }
]