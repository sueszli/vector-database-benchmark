[
    {
        "func_name": "get_latest_prices",
        "original": "def get_latest_prices(prices):\n    \"\"\"\n    A helper tool which retrieves the most recent asset prices from a dataframe of\n    asset prices, required in order to generate a discrete allocation.\n\n    :param prices: historical asset prices\n    :type prices: pd.DataFrame\n    :raises TypeError: if prices are not in a dataframe\n    :return: the most recent price of each asset\n    :rtype: pd.Series\n    \"\"\"\n    if not isinstance(prices, pd.DataFrame):\n        raise TypeError('prices not in a dataframe')\n    return prices.ffill().iloc[-1]",
        "mutated": [
            "def get_latest_prices(prices):\n    if False:\n        i = 10\n    '\\n    A helper tool which retrieves the most recent asset prices from a dataframe of\\n    asset prices, required in order to generate a discrete allocation.\\n\\n    :param prices: historical asset prices\\n    :type prices: pd.DataFrame\\n    :raises TypeError: if prices are not in a dataframe\\n    :return: the most recent price of each asset\\n    :rtype: pd.Series\\n    '\n    if not isinstance(prices, pd.DataFrame):\n        raise TypeError('prices not in a dataframe')\n    return prices.ffill().iloc[-1]",
            "def get_latest_prices(prices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    A helper tool which retrieves the most recent asset prices from a dataframe of\\n    asset prices, required in order to generate a discrete allocation.\\n\\n    :param prices: historical asset prices\\n    :type prices: pd.DataFrame\\n    :raises TypeError: if prices are not in a dataframe\\n    :return: the most recent price of each asset\\n    :rtype: pd.Series\\n    '\n    if not isinstance(prices, pd.DataFrame):\n        raise TypeError('prices not in a dataframe')\n    return prices.ffill().iloc[-1]",
            "def get_latest_prices(prices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    A helper tool which retrieves the most recent asset prices from a dataframe of\\n    asset prices, required in order to generate a discrete allocation.\\n\\n    :param prices: historical asset prices\\n    :type prices: pd.DataFrame\\n    :raises TypeError: if prices are not in a dataframe\\n    :return: the most recent price of each asset\\n    :rtype: pd.Series\\n    '\n    if not isinstance(prices, pd.DataFrame):\n        raise TypeError('prices not in a dataframe')\n    return prices.ffill().iloc[-1]",
            "def get_latest_prices(prices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    A helper tool which retrieves the most recent asset prices from a dataframe of\\n    asset prices, required in order to generate a discrete allocation.\\n\\n    :param prices: historical asset prices\\n    :type prices: pd.DataFrame\\n    :raises TypeError: if prices are not in a dataframe\\n    :return: the most recent price of each asset\\n    :rtype: pd.Series\\n    '\n    if not isinstance(prices, pd.DataFrame):\n        raise TypeError('prices not in a dataframe')\n    return prices.ffill().iloc[-1]",
            "def get_latest_prices(prices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    A helper tool which retrieves the most recent asset prices from a dataframe of\\n    asset prices, required in order to generate a discrete allocation.\\n\\n    :param prices: historical asset prices\\n    :type prices: pd.DataFrame\\n    :raises TypeError: if prices are not in a dataframe\\n    :return: the most recent price of each asset\\n    :rtype: pd.Series\\n    '\n    if not isinstance(prices, pd.DataFrame):\n        raise TypeError('prices not in a dataframe')\n    return prices.ffill().iloc[-1]"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, weights, latest_prices, total_portfolio_value=10000, short_ratio=None):\n    \"\"\"\n        :param weights: continuous weights generated from the ``efficient_frontier`` module\n        :type weights: dict\n        :param latest_prices: the most recent price for each asset\n        :type latest_prices: pd.Series\n        :param total_portfolio_value: the desired total value of the portfolio, defaults to 10000\n        :type total_portfolio_value: int/float, optional\n        :param short_ratio: the short ratio, e.g 0.3 corresponds to 130/30. If None,\n                            defaults to the input weights.\n        :type short_ratio: float, defaults to None.\n        :raises TypeError: if ``weights`` is not a dict\n        :raises TypeError: if ``latest_prices`` isn't a series\n        :raises ValueError: if ``short_ratio < 0``\n        \"\"\"\n    if not isinstance(weights, dict):\n        raise TypeError('weights should be a dictionary of {ticker: weight}')\n    if any((np.isnan(val) for val in weights.values())):\n        raise ValueError('weights should have no NaNs')\n    if not isinstance(latest_prices, pd.Series) or any(np.isnan(latest_prices)):\n        raise TypeError('latest_prices should be a pd.Series with no NaNs')\n    if total_portfolio_value <= 0:\n        raise ValueError('total_portfolio_value must be greater than zero')\n    if short_ratio is not None and short_ratio < 0:\n        raise ValueError('short_ratio must be non-negative')\n    self.weights = list(weights.items())\n    self.latest_prices = latest_prices\n    self.total_portfolio_value = total_portfolio_value\n    if short_ratio is None:\n        self.short_ratio = sum((-x[1] for x in self.weights if x[1] < 0))\n    else:\n        self.short_ratio = short_ratio",
        "mutated": [
            "def __init__(self, weights, latest_prices, total_portfolio_value=10000, short_ratio=None):\n    if False:\n        i = 10\n    \"\\n        :param weights: continuous weights generated from the ``efficient_frontier`` module\\n        :type weights: dict\\n        :param latest_prices: the most recent price for each asset\\n        :type latest_prices: pd.Series\\n        :param total_portfolio_value: the desired total value of the portfolio, defaults to 10000\\n        :type total_portfolio_value: int/float, optional\\n        :param short_ratio: the short ratio, e.g 0.3 corresponds to 130/30. If None,\\n                            defaults to the input weights.\\n        :type short_ratio: float, defaults to None.\\n        :raises TypeError: if ``weights`` is not a dict\\n        :raises TypeError: if ``latest_prices`` isn't a series\\n        :raises ValueError: if ``short_ratio < 0``\\n        \"\n    if not isinstance(weights, dict):\n        raise TypeError('weights should be a dictionary of {ticker: weight}')\n    if any((np.isnan(val) for val in weights.values())):\n        raise ValueError('weights should have no NaNs')\n    if not isinstance(latest_prices, pd.Series) or any(np.isnan(latest_prices)):\n        raise TypeError('latest_prices should be a pd.Series with no NaNs')\n    if total_portfolio_value <= 0:\n        raise ValueError('total_portfolio_value must be greater than zero')\n    if short_ratio is not None and short_ratio < 0:\n        raise ValueError('short_ratio must be non-negative')\n    self.weights = list(weights.items())\n    self.latest_prices = latest_prices\n    self.total_portfolio_value = total_portfolio_value\n    if short_ratio is None:\n        self.short_ratio = sum((-x[1] for x in self.weights if x[1] < 0))\n    else:\n        self.short_ratio = short_ratio",
            "def __init__(self, weights, latest_prices, total_portfolio_value=10000, short_ratio=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        :param weights: continuous weights generated from the ``efficient_frontier`` module\\n        :type weights: dict\\n        :param latest_prices: the most recent price for each asset\\n        :type latest_prices: pd.Series\\n        :param total_portfolio_value: the desired total value of the portfolio, defaults to 10000\\n        :type total_portfolio_value: int/float, optional\\n        :param short_ratio: the short ratio, e.g 0.3 corresponds to 130/30. If None,\\n                            defaults to the input weights.\\n        :type short_ratio: float, defaults to None.\\n        :raises TypeError: if ``weights`` is not a dict\\n        :raises TypeError: if ``latest_prices`` isn't a series\\n        :raises ValueError: if ``short_ratio < 0``\\n        \"\n    if not isinstance(weights, dict):\n        raise TypeError('weights should be a dictionary of {ticker: weight}')\n    if any((np.isnan(val) for val in weights.values())):\n        raise ValueError('weights should have no NaNs')\n    if not isinstance(latest_prices, pd.Series) or any(np.isnan(latest_prices)):\n        raise TypeError('latest_prices should be a pd.Series with no NaNs')\n    if total_portfolio_value <= 0:\n        raise ValueError('total_portfolio_value must be greater than zero')\n    if short_ratio is not None and short_ratio < 0:\n        raise ValueError('short_ratio must be non-negative')\n    self.weights = list(weights.items())\n    self.latest_prices = latest_prices\n    self.total_portfolio_value = total_portfolio_value\n    if short_ratio is None:\n        self.short_ratio = sum((-x[1] for x in self.weights if x[1] < 0))\n    else:\n        self.short_ratio = short_ratio",
            "def __init__(self, weights, latest_prices, total_portfolio_value=10000, short_ratio=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        :param weights: continuous weights generated from the ``efficient_frontier`` module\\n        :type weights: dict\\n        :param latest_prices: the most recent price for each asset\\n        :type latest_prices: pd.Series\\n        :param total_portfolio_value: the desired total value of the portfolio, defaults to 10000\\n        :type total_portfolio_value: int/float, optional\\n        :param short_ratio: the short ratio, e.g 0.3 corresponds to 130/30. If None,\\n                            defaults to the input weights.\\n        :type short_ratio: float, defaults to None.\\n        :raises TypeError: if ``weights`` is not a dict\\n        :raises TypeError: if ``latest_prices`` isn't a series\\n        :raises ValueError: if ``short_ratio < 0``\\n        \"\n    if not isinstance(weights, dict):\n        raise TypeError('weights should be a dictionary of {ticker: weight}')\n    if any((np.isnan(val) for val in weights.values())):\n        raise ValueError('weights should have no NaNs')\n    if not isinstance(latest_prices, pd.Series) or any(np.isnan(latest_prices)):\n        raise TypeError('latest_prices should be a pd.Series with no NaNs')\n    if total_portfolio_value <= 0:\n        raise ValueError('total_portfolio_value must be greater than zero')\n    if short_ratio is not None and short_ratio < 0:\n        raise ValueError('short_ratio must be non-negative')\n    self.weights = list(weights.items())\n    self.latest_prices = latest_prices\n    self.total_portfolio_value = total_portfolio_value\n    if short_ratio is None:\n        self.short_ratio = sum((-x[1] for x in self.weights if x[1] < 0))\n    else:\n        self.short_ratio = short_ratio",
            "def __init__(self, weights, latest_prices, total_portfolio_value=10000, short_ratio=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        :param weights: continuous weights generated from the ``efficient_frontier`` module\\n        :type weights: dict\\n        :param latest_prices: the most recent price for each asset\\n        :type latest_prices: pd.Series\\n        :param total_portfolio_value: the desired total value of the portfolio, defaults to 10000\\n        :type total_portfolio_value: int/float, optional\\n        :param short_ratio: the short ratio, e.g 0.3 corresponds to 130/30. If None,\\n                            defaults to the input weights.\\n        :type short_ratio: float, defaults to None.\\n        :raises TypeError: if ``weights`` is not a dict\\n        :raises TypeError: if ``latest_prices`` isn't a series\\n        :raises ValueError: if ``short_ratio < 0``\\n        \"\n    if not isinstance(weights, dict):\n        raise TypeError('weights should be a dictionary of {ticker: weight}')\n    if any((np.isnan(val) for val in weights.values())):\n        raise ValueError('weights should have no NaNs')\n    if not isinstance(latest_prices, pd.Series) or any(np.isnan(latest_prices)):\n        raise TypeError('latest_prices should be a pd.Series with no NaNs')\n    if total_portfolio_value <= 0:\n        raise ValueError('total_portfolio_value must be greater than zero')\n    if short_ratio is not None and short_ratio < 0:\n        raise ValueError('short_ratio must be non-negative')\n    self.weights = list(weights.items())\n    self.latest_prices = latest_prices\n    self.total_portfolio_value = total_portfolio_value\n    if short_ratio is None:\n        self.short_ratio = sum((-x[1] for x in self.weights if x[1] < 0))\n    else:\n        self.short_ratio = short_ratio",
            "def __init__(self, weights, latest_prices, total_portfolio_value=10000, short_ratio=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        :param weights: continuous weights generated from the ``efficient_frontier`` module\\n        :type weights: dict\\n        :param latest_prices: the most recent price for each asset\\n        :type latest_prices: pd.Series\\n        :param total_portfolio_value: the desired total value of the portfolio, defaults to 10000\\n        :type total_portfolio_value: int/float, optional\\n        :param short_ratio: the short ratio, e.g 0.3 corresponds to 130/30. If None,\\n                            defaults to the input weights.\\n        :type short_ratio: float, defaults to None.\\n        :raises TypeError: if ``weights`` is not a dict\\n        :raises TypeError: if ``latest_prices`` isn't a series\\n        :raises ValueError: if ``short_ratio < 0``\\n        \"\n    if not isinstance(weights, dict):\n        raise TypeError('weights should be a dictionary of {ticker: weight}')\n    if any((np.isnan(val) for val in weights.values())):\n        raise ValueError('weights should have no NaNs')\n    if not isinstance(latest_prices, pd.Series) or any(np.isnan(latest_prices)):\n        raise TypeError('latest_prices should be a pd.Series with no NaNs')\n    if total_portfolio_value <= 0:\n        raise ValueError('total_portfolio_value must be greater than zero')\n    if short_ratio is not None and short_ratio < 0:\n        raise ValueError('short_ratio must be non-negative')\n    self.weights = list(weights.items())\n    self.latest_prices = latest_prices\n    self.total_portfolio_value = total_portfolio_value\n    if short_ratio is None:\n        self.short_ratio = sum((-x[1] for x in self.weights if x[1] < 0))\n    else:\n        self.short_ratio = short_ratio"
        ]
    },
    {
        "func_name": "_remove_zero_positions",
        "original": "@staticmethod\ndef _remove_zero_positions(allocation):\n    \"\"\"\n        Utility function to remove zero positions (i.e with no shares being bought)\n\n        :type allocation: dict\n        \"\"\"\n    return {k: v for (k, v) in allocation.items() if v != 0}",
        "mutated": [
            "@staticmethod\ndef _remove_zero_positions(allocation):\n    if False:\n        i = 10\n    '\\n        Utility function to remove zero positions (i.e with no shares being bought)\\n\\n        :type allocation: dict\\n        '\n    return {k: v for (k, v) in allocation.items() if v != 0}",
            "@staticmethod\ndef _remove_zero_positions(allocation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Utility function to remove zero positions (i.e with no shares being bought)\\n\\n        :type allocation: dict\\n        '\n    return {k: v for (k, v) in allocation.items() if v != 0}",
            "@staticmethod\ndef _remove_zero_positions(allocation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Utility function to remove zero positions (i.e with no shares being bought)\\n\\n        :type allocation: dict\\n        '\n    return {k: v for (k, v) in allocation.items() if v != 0}",
            "@staticmethod\ndef _remove_zero_positions(allocation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Utility function to remove zero positions (i.e with no shares being bought)\\n\\n        :type allocation: dict\\n        '\n    return {k: v for (k, v) in allocation.items() if v != 0}",
            "@staticmethod\ndef _remove_zero_positions(allocation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Utility function to remove zero positions (i.e with no shares being bought)\\n\\n        :type allocation: dict\\n        '\n    return {k: v for (k, v) in allocation.items() if v != 0}"
        ]
    },
    {
        "func_name": "_allocation_rmse_error",
        "original": "def _allocation_rmse_error(self, verbose=True):\n    \"\"\"\n        Utility function to calculate and print RMSE error between discretised\n        weights and continuous weights. RMSE was used instead of MAE because we\n        want to penalise large variations.\n\n        :param verbose: print weight discrepancies?\n        :type verbose: bool\n        :return: rmse error\n        :rtype: float\n        \"\"\"\n    portfolio_val = 0\n    for (ticker, num) in self.allocation.items():\n        portfolio_val += num * self.latest_prices[ticker]\n    sse = 0\n    for (ticker, weight) in self.weights:\n        if ticker in self.allocation:\n            allocation_weight = self.allocation[ticker] * self.latest_prices[ticker] / portfolio_val\n        else:\n            allocation_weight = 0\n        sse += (weight - allocation_weight) ** 2\n        if verbose:\n            print('{}: allocated {:.3f}, desired {:.3f}'.format(ticker, allocation_weight, weight))\n    rmse = np.sqrt(sse / len(self.weights))\n    print('Allocation has RMSE: {:.3f}'.format(rmse))\n    return rmse",
        "mutated": [
            "def _allocation_rmse_error(self, verbose=True):\n    if False:\n        i = 10\n    '\\n        Utility function to calculate and print RMSE error between discretised\\n        weights and continuous weights. RMSE was used instead of MAE because we\\n        want to penalise large variations.\\n\\n        :param verbose: print weight discrepancies?\\n        :type verbose: bool\\n        :return: rmse error\\n        :rtype: float\\n        '\n    portfolio_val = 0\n    for (ticker, num) in self.allocation.items():\n        portfolio_val += num * self.latest_prices[ticker]\n    sse = 0\n    for (ticker, weight) in self.weights:\n        if ticker in self.allocation:\n            allocation_weight = self.allocation[ticker] * self.latest_prices[ticker] / portfolio_val\n        else:\n            allocation_weight = 0\n        sse += (weight - allocation_weight) ** 2\n        if verbose:\n            print('{}: allocated {:.3f}, desired {:.3f}'.format(ticker, allocation_weight, weight))\n    rmse = np.sqrt(sse / len(self.weights))\n    print('Allocation has RMSE: {:.3f}'.format(rmse))\n    return rmse",
            "def _allocation_rmse_error(self, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Utility function to calculate and print RMSE error between discretised\\n        weights and continuous weights. RMSE was used instead of MAE because we\\n        want to penalise large variations.\\n\\n        :param verbose: print weight discrepancies?\\n        :type verbose: bool\\n        :return: rmse error\\n        :rtype: float\\n        '\n    portfolio_val = 0\n    for (ticker, num) in self.allocation.items():\n        portfolio_val += num * self.latest_prices[ticker]\n    sse = 0\n    for (ticker, weight) in self.weights:\n        if ticker in self.allocation:\n            allocation_weight = self.allocation[ticker] * self.latest_prices[ticker] / portfolio_val\n        else:\n            allocation_weight = 0\n        sse += (weight - allocation_weight) ** 2\n        if verbose:\n            print('{}: allocated {:.3f}, desired {:.3f}'.format(ticker, allocation_weight, weight))\n    rmse = np.sqrt(sse / len(self.weights))\n    print('Allocation has RMSE: {:.3f}'.format(rmse))\n    return rmse",
            "def _allocation_rmse_error(self, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Utility function to calculate and print RMSE error between discretised\\n        weights and continuous weights. RMSE was used instead of MAE because we\\n        want to penalise large variations.\\n\\n        :param verbose: print weight discrepancies?\\n        :type verbose: bool\\n        :return: rmse error\\n        :rtype: float\\n        '\n    portfolio_val = 0\n    for (ticker, num) in self.allocation.items():\n        portfolio_val += num * self.latest_prices[ticker]\n    sse = 0\n    for (ticker, weight) in self.weights:\n        if ticker in self.allocation:\n            allocation_weight = self.allocation[ticker] * self.latest_prices[ticker] / portfolio_val\n        else:\n            allocation_weight = 0\n        sse += (weight - allocation_weight) ** 2\n        if verbose:\n            print('{}: allocated {:.3f}, desired {:.3f}'.format(ticker, allocation_weight, weight))\n    rmse = np.sqrt(sse / len(self.weights))\n    print('Allocation has RMSE: {:.3f}'.format(rmse))\n    return rmse",
            "def _allocation_rmse_error(self, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Utility function to calculate and print RMSE error between discretised\\n        weights and continuous weights. RMSE was used instead of MAE because we\\n        want to penalise large variations.\\n\\n        :param verbose: print weight discrepancies?\\n        :type verbose: bool\\n        :return: rmse error\\n        :rtype: float\\n        '\n    portfolio_val = 0\n    for (ticker, num) in self.allocation.items():\n        portfolio_val += num * self.latest_prices[ticker]\n    sse = 0\n    for (ticker, weight) in self.weights:\n        if ticker in self.allocation:\n            allocation_weight = self.allocation[ticker] * self.latest_prices[ticker] / portfolio_val\n        else:\n            allocation_weight = 0\n        sse += (weight - allocation_weight) ** 2\n        if verbose:\n            print('{}: allocated {:.3f}, desired {:.3f}'.format(ticker, allocation_weight, weight))\n    rmse = np.sqrt(sse / len(self.weights))\n    print('Allocation has RMSE: {:.3f}'.format(rmse))\n    return rmse",
            "def _allocation_rmse_error(self, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Utility function to calculate and print RMSE error between discretised\\n        weights and continuous weights. RMSE was used instead of MAE because we\\n        want to penalise large variations.\\n\\n        :param verbose: print weight discrepancies?\\n        :type verbose: bool\\n        :return: rmse error\\n        :rtype: float\\n        '\n    portfolio_val = 0\n    for (ticker, num) in self.allocation.items():\n        portfolio_val += num * self.latest_prices[ticker]\n    sse = 0\n    for (ticker, weight) in self.weights:\n        if ticker in self.allocation:\n            allocation_weight = self.allocation[ticker] * self.latest_prices[ticker] / portfolio_val\n        else:\n            allocation_weight = 0\n        sse += (weight - allocation_weight) ** 2\n        if verbose:\n            print('{}: allocated {:.3f}, desired {:.3f}'.format(ticker, allocation_weight, weight))\n    rmse = np.sqrt(sse / len(self.weights))\n    print('Allocation has RMSE: {:.3f}'.format(rmse))\n    return rmse"
        ]
    },
    {
        "func_name": "greedy_portfolio",
        "original": "def greedy_portfolio(self, reinvest=False, verbose=False):\n    \"\"\"\n        Convert continuous weights into a discrete portfolio allocation\n        using a greedy iterative approach.\n\n        :param reinvest: whether or not to reinvest cash gained from shorting\n        :type reinvest: bool, defaults to False\n        :param verbose: print error analysis?\n        :type verbose: bool, defaults to False\n        :return: the number of shares of each ticker that should be purchased,\n                 along with the amount of funds leftover.\n        :rtype: (dict, float)\n        \"\"\"\n    self.weights.sort(key=lambda x: x[1], reverse=True)\n    if self.weights[-1][1] < 0:\n        longs = {t: w for (t, w) in self.weights if w >= 0}\n        shorts = {t: -w for (t, w) in self.weights if w < 0}\n        long_total_weight = sum(longs.values())\n        short_total_weight = sum(shorts.values())\n        longs = {t: w / long_total_weight for (t, w) in longs.items()}\n        shorts = {t: w / short_total_weight for (t, w) in shorts.items()}\n        short_val = self.total_portfolio_value * self.short_ratio\n        long_val = self.total_portfolio_value\n        if reinvest:\n            long_val += short_val\n        if verbose:\n            print('\\nAllocating long sub-portfolio...')\n        da1 = DiscreteAllocation(longs, self.latest_prices[longs.keys()], total_portfolio_value=long_val)\n        (long_alloc, long_leftover) = da1.greedy_portfolio()\n        if verbose:\n            print('\\nAllocating short sub-portfolio...')\n        da2 = DiscreteAllocation(shorts, self.latest_prices[shorts.keys()], total_portfolio_value=short_val)\n        (short_alloc, short_leftover) = da2.greedy_portfolio()\n        short_alloc = {t: -w for (t, w) in short_alloc.items()}\n        self.allocation = long_alloc.copy()\n        self.allocation.update(short_alloc)\n        self.allocation = self._remove_zero_positions(self.allocation)\n        return (self.allocation, long_leftover + short_leftover)\n    available_funds = self.total_portfolio_value\n    shares_bought = []\n    buy_prices = []\n    for (ticker, weight) in self.weights:\n        price = self.latest_prices[ticker]\n        n_shares = int(weight * self.total_portfolio_value / price)\n        cost = n_shares * price\n        assert cost <= available_funds, 'Unexpectedly insufficient funds.'\n        available_funds -= cost\n        shares_bought.append(n_shares)\n        buy_prices.append(price)\n    while available_funds > 0:\n        current_weights = np.array(buy_prices) * np.array(shares_bought)\n        current_weights /= current_weights.sum()\n        ideal_weights = np.array([i[1] for i in self.weights])\n        deficit = ideal_weights - current_weights\n        idx = np.argmax(deficit)\n        (ticker, weight) = self.weights[idx]\n        price = self.latest_prices[ticker]\n        counter = 0\n        while price > available_funds:\n            deficit[idx] = 0\n            idx = np.argmax(deficit)\n            if deficit[idx] < 0 or counter == 10:\n                break\n            (ticker, weight) = self.weights[idx]\n            price = self.latest_prices[ticker]\n            counter += 1\n        if deficit[idx] <= 0 or counter == 10:\n            break\n        shares_bought[idx] += 1\n        available_funds -= price\n    self.allocation = self._remove_zero_positions(collections.OrderedDict(zip([i[0] for i in self.weights], shares_bought)))\n    if verbose:\n        print('Funds remaining: {:.2f}'.format(available_funds))\n        self._allocation_rmse_error(verbose)\n    return (self.allocation, available_funds)",
        "mutated": [
            "def greedy_portfolio(self, reinvest=False, verbose=False):\n    if False:\n        i = 10\n    '\\n        Convert continuous weights into a discrete portfolio allocation\\n        using a greedy iterative approach.\\n\\n        :param reinvest: whether or not to reinvest cash gained from shorting\\n        :type reinvest: bool, defaults to False\\n        :param verbose: print error analysis?\\n        :type verbose: bool, defaults to False\\n        :return: the number of shares of each ticker that should be purchased,\\n                 along with the amount of funds leftover.\\n        :rtype: (dict, float)\\n        '\n    self.weights.sort(key=lambda x: x[1], reverse=True)\n    if self.weights[-1][1] < 0:\n        longs = {t: w for (t, w) in self.weights if w >= 0}\n        shorts = {t: -w for (t, w) in self.weights if w < 0}\n        long_total_weight = sum(longs.values())\n        short_total_weight = sum(shorts.values())\n        longs = {t: w / long_total_weight for (t, w) in longs.items()}\n        shorts = {t: w / short_total_weight for (t, w) in shorts.items()}\n        short_val = self.total_portfolio_value * self.short_ratio\n        long_val = self.total_portfolio_value\n        if reinvest:\n            long_val += short_val\n        if verbose:\n            print('\\nAllocating long sub-portfolio...')\n        da1 = DiscreteAllocation(longs, self.latest_prices[longs.keys()], total_portfolio_value=long_val)\n        (long_alloc, long_leftover) = da1.greedy_portfolio()\n        if verbose:\n            print('\\nAllocating short sub-portfolio...')\n        da2 = DiscreteAllocation(shorts, self.latest_prices[shorts.keys()], total_portfolio_value=short_val)\n        (short_alloc, short_leftover) = da2.greedy_portfolio()\n        short_alloc = {t: -w for (t, w) in short_alloc.items()}\n        self.allocation = long_alloc.copy()\n        self.allocation.update(short_alloc)\n        self.allocation = self._remove_zero_positions(self.allocation)\n        return (self.allocation, long_leftover + short_leftover)\n    available_funds = self.total_portfolio_value\n    shares_bought = []\n    buy_prices = []\n    for (ticker, weight) in self.weights:\n        price = self.latest_prices[ticker]\n        n_shares = int(weight * self.total_portfolio_value / price)\n        cost = n_shares * price\n        assert cost <= available_funds, 'Unexpectedly insufficient funds.'\n        available_funds -= cost\n        shares_bought.append(n_shares)\n        buy_prices.append(price)\n    while available_funds > 0:\n        current_weights = np.array(buy_prices) * np.array(shares_bought)\n        current_weights /= current_weights.sum()\n        ideal_weights = np.array([i[1] for i in self.weights])\n        deficit = ideal_weights - current_weights\n        idx = np.argmax(deficit)\n        (ticker, weight) = self.weights[idx]\n        price = self.latest_prices[ticker]\n        counter = 0\n        while price > available_funds:\n            deficit[idx] = 0\n            idx = np.argmax(deficit)\n            if deficit[idx] < 0 or counter == 10:\n                break\n            (ticker, weight) = self.weights[idx]\n            price = self.latest_prices[ticker]\n            counter += 1\n        if deficit[idx] <= 0 or counter == 10:\n            break\n        shares_bought[idx] += 1\n        available_funds -= price\n    self.allocation = self._remove_zero_positions(collections.OrderedDict(zip([i[0] for i in self.weights], shares_bought)))\n    if verbose:\n        print('Funds remaining: {:.2f}'.format(available_funds))\n        self._allocation_rmse_error(verbose)\n    return (self.allocation, available_funds)",
            "def greedy_portfolio(self, reinvest=False, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Convert continuous weights into a discrete portfolio allocation\\n        using a greedy iterative approach.\\n\\n        :param reinvest: whether or not to reinvest cash gained from shorting\\n        :type reinvest: bool, defaults to False\\n        :param verbose: print error analysis?\\n        :type verbose: bool, defaults to False\\n        :return: the number of shares of each ticker that should be purchased,\\n                 along with the amount of funds leftover.\\n        :rtype: (dict, float)\\n        '\n    self.weights.sort(key=lambda x: x[1], reverse=True)\n    if self.weights[-1][1] < 0:\n        longs = {t: w for (t, w) in self.weights if w >= 0}\n        shorts = {t: -w for (t, w) in self.weights if w < 0}\n        long_total_weight = sum(longs.values())\n        short_total_weight = sum(shorts.values())\n        longs = {t: w / long_total_weight for (t, w) in longs.items()}\n        shorts = {t: w / short_total_weight for (t, w) in shorts.items()}\n        short_val = self.total_portfolio_value * self.short_ratio\n        long_val = self.total_portfolio_value\n        if reinvest:\n            long_val += short_val\n        if verbose:\n            print('\\nAllocating long sub-portfolio...')\n        da1 = DiscreteAllocation(longs, self.latest_prices[longs.keys()], total_portfolio_value=long_val)\n        (long_alloc, long_leftover) = da1.greedy_portfolio()\n        if verbose:\n            print('\\nAllocating short sub-portfolio...')\n        da2 = DiscreteAllocation(shorts, self.latest_prices[shorts.keys()], total_portfolio_value=short_val)\n        (short_alloc, short_leftover) = da2.greedy_portfolio()\n        short_alloc = {t: -w for (t, w) in short_alloc.items()}\n        self.allocation = long_alloc.copy()\n        self.allocation.update(short_alloc)\n        self.allocation = self._remove_zero_positions(self.allocation)\n        return (self.allocation, long_leftover + short_leftover)\n    available_funds = self.total_portfolio_value\n    shares_bought = []\n    buy_prices = []\n    for (ticker, weight) in self.weights:\n        price = self.latest_prices[ticker]\n        n_shares = int(weight * self.total_portfolio_value / price)\n        cost = n_shares * price\n        assert cost <= available_funds, 'Unexpectedly insufficient funds.'\n        available_funds -= cost\n        shares_bought.append(n_shares)\n        buy_prices.append(price)\n    while available_funds > 0:\n        current_weights = np.array(buy_prices) * np.array(shares_bought)\n        current_weights /= current_weights.sum()\n        ideal_weights = np.array([i[1] for i in self.weights])\n        deficit = ideal_weights - current_weights\n        idx = np.argmax(deficit)\n        (ticker, weight) = self.weights[idx]\n        price = self.latest_prices[ticker]\n        counter = 0\n        while price > available_funds:\n            deficit[idx] = 0\n            idx = np.argmax(deficit)\n            if deficit[idx] < 0 or counter == 10:\n                break\n            (ticker, weight) = self.weights[idx]\n            price = self.latest_prices[ticker]\n            counter += 1\n        if deficit[idx] <= 0 or counter == 10:\n            break\n        shares_bought[idx] += 1\n        available_funds -= price\n    self.allocation = self._remove_zero_positions(collections.OrderedDict(zip([i[0] for i in self.weights], shares_bought)))\n    if verbose:\n        print('Funds remaining: {:.2f}'.format(available_funds))\n        self._allocation_rmse_error(verbose)\n    return (self.allocation, available_funds)",
            "def greedy_portfolio(self, reinvest=False, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Convert continuous weights into a discrete portfolio allocation\\n        using a greedy iterative approach.\\n\\n        :param reinvest: whether or not to reinvest cash gained from shorting\\n        :type reinvest: bool, defaults to False\\n        :param verbose: print error analysis?\\n        :type verbose: bool, defaults to False\\n        :return: the number of shares of each ticker that should be purchased,\\n                 along with the amount of funds leftover.\\n        :rtype: (dict, float)\\n        '\n    self.weights.sort(key=lambda x: x[1], reverse=True)\n    if self.weights[-1][1] < 0:\n        longs = {t: w for (t, w) in self.weights if w >= 0}\n        shorts = {t: -w for (t, w) in self.weights if w < 0}\n        long_total_weight = sum(longs.values())\n        short_total_weight = sum(shorts.values())\n        longs = {t: w / long_total_weight for (t, w) in longs.items()}\n        shorts = {t: w / short_total_weight for (t, w) in shorts.items()}\n        short_val = self.total_portfolio_value * self.short_ratio\n        long_val = self.total_portfolio_value\n        if reinvest:\n            long_val += short_val\n        if verbose:\n            print('\\nAllocating long sub-portfolio...')\n        da1 = DiscreteAllocation(longs, self.latest_prices[longs.keys()], total_portfolio_value=long_val)\n        (long_alloc, long_leftover) = da1.greedy_portfolio()\n        if verbose:\n            print('\\nAllocating short sub-portfolio...')\n        da2 = DiscreteAllocation(shorts, self.latest_prices[shorts.keys()], total_portfolio_value=short_val)\n        (short_alloc, short_leftover) = da2.greedy_portfolio()\n        short_alloc = {t: -w for (t, w) in short_alloc.items()}\n        self.allocation = long_alloc.copy()\n        self.allocation.update(short_alloc)\n        self.allocation = self._remove_zero_positions(self.allocation)\n        return (self.allocation, long_leftover + short_leftover)\n    available_funds = self.total_portfolio_value\n    shares_bought = []\n    buy_prices = []\n    for (ticker, weight) in self.weights:\n        price = self.latest_prices[ticker]\n        n_shares = int(weight * self.total_portfolio_value / price)\n        cost = n_shares * price\n        assert cost <= available_funds, 'Unexpectedly insufficient funds.'\n        available_funds -= cost\n        shares_bought.append(n_shares)\n        buy_prices.append(price)\n    while available_funds > 0:\n        current_weights = np.array(buy_prices) * np.array(shares_bought)\n        current_weights /= current_weights.sum()\n        ideal_weights = np.array([i[1] for i in self.weights])\n        deficit = ideal_weights - current_weights\n        idx = np.argmax(deficit)\n        (ticker, weight) = self.weights[idx]\n        price = self.latest_prices[ticker]\n        counter = 0\n        while price > available_funds:\n            deficit[idx] = 0\n            idx = np.argmax(deficit)\n            if deficit[idx] < 0 or counter == 10:\n                break\n            (ticker, weight) = self.weights[idx]\n            price = self.latest_prices[ticker]\n            counter += 1\n        if deficit[idx] <= 0 or counter == 10:\n            break\n        shares_bought[idx] += 1\n        available_funds -= price\n    self.allocation = self._remove_zero_positions(collections.OrderedDict(zip([i[0] for i in self.weights], shares_bought)))\n    if verbose:\n        print('Funds remaining: {:.2f}'.format(available_funds))\n        self._allocation_rmse_error(verbose)\n    return (self.allocation, available_funds)",
            "def greedy_portfolio(self, reinvest=False, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Convert continuous weights into a discrete portfolio allocation\\n        using a greedy iterative approach.\\n\\n        :param reinvest: whether or not to reinvest cash gained from shorting\\n        :type reinvest: bool, defaults to False\\n        :param verbose: print error analysis?\\n        :type verbose: bool, defaults to False\\n        :return: the number of shares of each ticker that should be purchased,\\n                 along with the amount of funds leftover.\\n        :rtype: (dict, float)\\n        '\n    self.weights.sort(key=lambda x: x[1], reverse=True)\n    if self.weights[-1][1] < 0:\n        longs = {t: w for (t, w) in self.weights if w >= 0}\n        shorts = {t: -w for (t, w) in self.weights if w < 0}\n        long_total_weight = sum(longs.values())\n        short_total_weight = sum(shorts.values())\n        longs = {t: w / long_total_weight for (t, w) in longs.items()}\n        shorts = {t: w / short_total_weight for (t, w) in shorts.items()}\n        short_val = self.total_portfolio_value * self.short_ratio\n        long_val = self.total_portfolio_value\n        if reinvest:\n            long_val += short_val\n        if verbose:\n            print('\\nAllocating long sub-portfolio...')\n        da1 = DiscreteAllocation(longs, self.latest_prices[longs.keys()], total_portfolio_value=long_val)\n        (long_alloc, long_leftover) = da1.greedy_portfolio()\n        if verbose:\n            print('\\nAllocating short sub-portfolio...')\n        da2 = DiscreteAllocation(shorts, self.latest_prices[shorts.keys()], total_portfolio_value=short_val)\n        (short_alloc, short_leftover) = da2.greedy_portfolio()\n        short_alloc = {t: -w for (t, w) in short_alloc.items()}\n        self.allocation = long_alloc.copy()\n        self.allocation.update(short_alloc)\n        self.allocation = self._remove_zero_positions(self.allocation)\n        return (self.allocation, long_leftover + short_leftover)\n    available_funds = self.total_portfolio_value\n    shares_bought = []\n    buy_prices = []\n    for (ticker, weight) in self.weights:\n        price = self.latest_prices[ticker]\n        n_shares = int(weight * self.total_portfolio_value / price)\n        cost = n_shares * price\n        assert cost <= available_funds, 'Unexpectedly insufficient funds.'\n        available_funds -= cost\n        shares_bought.append(n_shares)\n        buy_prices.append(price)\n    while available_funds > 0:\n        current_weights = np.array(buy_prices) * np.array(shares_bought)\n        current_weights /= current_weights.sum()\n        ideal_weights = np.array([i[1] for i in self.weights])\n        deficit = ideal_weights - current_weights\n        idx = np.argmax(deficit)\n        (ticker, weight) = self.weights[idx]\n        price = self.latest_prices[ticker]\n        counter = 0\n        while price > available_funds:\n            deficit[idx] = 0\n            idx = np.argmax(deficit)\n            if deficit[idx] < 0 or counter == 10:\n                break\n            (ticker, weight) = self.weights[idx]\n            price = self.latest_prices[ticker]\n            counter += 1\n        if deficit[idx] <= 0 or counter == 10:\n            break\n        shares_bought[idx] += 1\n        available_funds -= price\n    self.allocation = self._remove_zero_positions(collections.OrderedDict(zip([i[0] for i in self.weights], shares_bought)))\n    if verbose:\n        print('Funds remaining: {:.2f}'.format(available_funds))\n        self._allocation_rmse_error(verbose)\n    return (self.allocation, available_funds)",
            "def greedy_portfolio(self, reinvest=False, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Convert continuous weights into a discrete portfolio allocation\\n        using a greedy iterative approach.\\n\\n        :param reinvest: whether or not to reinvest cash gained from shorting\\n        :type reinvest: bool, defaults to False\\n        :param verbose: print error analysis?\\n        :type verbose: bool, defaults to False\\n        :return: the number of shares of each ticker that should be purchased,\\n                 along with the amount of funds leftover.\\n        :rtype: (dict, float)\\n        '\n    self.weights.sort(key=lambda x: x[1], reverse=True)\n    if self.weights[-1][1] < 0:\n        longs = {t: w for (t, w) in self.weights if w >= 0}\n        shorts = {t: -w for (t, w) in self.weights if w < 0}\n        long_total_weight = sum(longs.values())\n        short_total_weight = sum(shorts.values())\n        longs = {t: w / long_total_weight for (t, w) in longs.items()}\n        shorts = {t: w / short_total_weight for (t, w) in shorts.items()}\n        short_val = self.total_portfolio_value * self.short_ratio\n        long_val = self.total_portfolio_value\n        if reinvest:\n            long_val += short_val\n        if verbose:\n            print('\\nAllocating long sub-portfolio...')\n        da1 = DiscreteAllocation(longs, self.latest_prices[longs.keys()], total_portfolio_value=long_val)\n        (long_alloc, long_leftover) = da1.greedy_portfolio()\n        if verbose:\n            print('\\nAllocating short sub-portfolio...')\n        da2 = DiscreteAllocation(shorts, self.latest_prices[shorts.keys()], total_portfolio_value=short_val)\n        (short_alloc, short_leftover) = da2.greedy_portfolio()\n        short_alloc = {t: -w for (t, w) in short_alloc.items()}\n        self.allocation = long_alloc.copy()\n        self.allocation.update(short_alloc)\n        self.allocation = self._remove_zero_positions(self.allocation)\n        return (self.allocation, long_leftover + short_leftover)\n    available_funds = self.total_portfolio_value\n    shares_bought = []\n    buy_prices = []\n    for (ticker, weight) in self.weights:\n        price = self.latest_prices[ticker]\n        n_shares = int(weight * self.total_portfolio_value / price)\n        cost = n_shares * price\n        assert cost <= available_funds, 'Unexpectedly insufficient funds.'\n        available_funds -= cost\n        shares_bought.append(n_shares)\n        buy_prices.append(price)\n    while available_funds > 0:\n        current_weights = np.array(buy_prices) * np.array(shares_bought)\n        current_weights /= current_weights.sum()\n        ideal_weights = np.array([i[1] for i in self.weights])\n        deficit = ideal_weights - current_weights\n        idx = np.argmax(deficit)\n        (ticker, weight) = self.weights[idx]\n        price = self.latest_prices[ticker]\n        counter = 0\n        while price > available_funds:\n            deficit[idx] = 0\n            idx = np.argmax(deficit)\n            if deficit[idx] < 0 or counter == 10:\n                break\n            (ticker, weight) = self.weights[idx]\n            price = self.latest_prices[ticker]\n            counter += 1\n        if deficit[idx] <= 0 or counter == 10:\n            break\n        shares_bought[idx] += 1\n        available_funds -= price\n    self.allocation = self._remove_zero_positions(collections.OrderedDict(zip([i[0] for i in self.weights], shares_bought)))\n    if verbose:\n        print('Funds remaining: {:.2f}'.format(available_funds))\n        self._allocation_rmse_error(verbose)\n    return (self.allocation, available_funds)"
        ]
    },
    {
        "func_name": "lp_portfolio",
        "original": "def lp_portfolio(self, reinvest=False, verbose=False, solver='ECOS_BB'):\n    \"\"\"\n        Convert continuous weights into a discrete portfolio allocation\n        using integer programming.\n\n        :param reinvest: whether or not to reinvest cash gained from shorting\n        :type reinvest: bool, defaults to False\n        :param verbose: print error analysis?\n        :type verbose: bool\n        :param solver: the CVXPY solver to use (must support mixed-integer programs)\n        :type solver: str, defaults to \"ECOS_BB\"\n        :return: the number of shares of each ticker that should be purchased, along with the amount\n                of funds leftover.\n        :rtype: (dict, float)\n        \"\"\"\n    if any([w < 0 for (_, w) in self.weights]):\n        longs = {t: w for (t, w) in self.weights if w >= 0}\n        shorts = {t: -w for (t, w) in self.weights if w < 0}\n        long_total_weight = sum(longs.values())\n        short_total_weight = sum(shorts.values())\n        longs = {t: w / long_total_weight for (t, w) in longs.items()}\n        shorts = {t: w / short_total_weight for (t, w) in shorts.items()}\n        short_val = self.total_portfolio_value * self.short_ratio\n        long_val = self.total_portfolio_value\n        if reinvest:\n            long_val += short_val\n        if verbose:\n            print('\\nAllocating long sub-portfolio:')\n        da1 = DiscreteAllocation(longs, self.latest_prices[longs.keys()], total_portfolio_value=long_val)\n        (long_alloc, long_leftover) = da1.lp_portfolio(solver=solver)\n        if verbose:\n            print('\\nAllocating short sub-portfolio:')\n        da2 = DiscreteAllocation(shorts, self.latest_prices[shorts.keys()], total_portfolio_value=short_val)\n        (short_alloc, short_leftover) = da2.lp_portfolio(solver=solver)\n        short_alloc = {t: -w for (t, w) in short_alloc.items()}\n        self.allocation = long_alloc.copy()\n        self.allocation.update(short_alloc)\n        self.allocation = self._remove_zero_positions(self.allocation)\n        return (self.allocation, long_leftover + short_leftover)\n    p = self.latest_prices.values\n    n = len(p)\n    w = np.fromiter([i[1] for i in self.weights], dtype=float)\n    x = cp.Variable(n, integer=True)\n    r = self.total_portfolio_value - p.T @ x\n    eta = w * self.total_portfolio_value - cp.multiply(x, p)\n    u = cp.Variable(n)\n    constraints = [eta <= u, eta >= -u, x >= 0, r >= 0]\n    objective = cp.sum(u) + r\n    opt = cp.Problem(cp.Minimize(objective), constraints)\n    opt.solve(solver=solver)\n    if opt.status not in {'optimal', 'optimal_inaccurate'}:\n        raise exceptions.OptimizationError('Please try greedy_portfolio')\n    vals = np.rint(x.value).astype(int)\n    self.allocation = self._remove_zero_positions(collections.OrderedDict(zip([i[0] for i in self.weights], vals)))\n    if verbose:\n        print('Funds remaining: {:.2f}'.format(r.value))\n        self._allocation_rmse_error()\n    return (self.allocation, r.value)",
        "mutated": [
            "def lp_portfolio(self, reinvest=False, verbose=False, solver='ECOS_BB'):\n    if False:\n        i = 10\n    '\\n        Convert continuous weights into a discrete portfolio allocation\\n        using integer programming.\\n\\n        :param reinvest: whether or not to reinvest cash gained from shorting\\n        :type reinvest: bool, defaults to False\\n        :param verbose: print error analysis?\\n        :type verbose: bool\\n        :param solver: the CVXPY solver to use (must support mixed-integer programs)\\n        :type solver: str, defaults to \"ECOS_BB\"\\n        :return: the number of shares of each ticker that should be purchased, along with the amount\\n                of funds leftover.\\n        :rtype: (dict, float)\\n        '\n    if any([w < 0 for (_, w) in self.weights]):\n        longs = {t: w for (t, w) in self.weights if w >= 0}\n        shorts = {t: -w for (t, w) in self.weights if w < 0}\n        long_total_weight = sum(longs.values())\n        short_total_weight = sum(shorts.values())\n        longs = {t: w / long_total_weight for (t, w) in longs.items()}\n        shorts = {t: w / short_total_weight for (t, w) in shorts.items()}\n        short_val = self.total_portfolio_value * self.short_ratio\n        long_val = self.total_portfolio_value\n        if reinvest:\n            long_val += short_val\n        if verbose:\n            print('\\nAllocating long sub-portfolio:')\n        da1 = DiscreteAllocation(longs, self.latest_prices[longs.keys()], total_portfolio_value=long_val)\n        (long_alloc, long_leftover) = da1.lp_portfolio(solver=solver)\n        if verbose:\n            print('\\nAllocating short sub-portfolio:')\n        da2 = DiscreteAllocation(shorts, self.latest_prices[shorts.keys()], total_portfolio_value=short_val)\n        (short_alloc, short_leftover) = da2.lp_portfolio(solver=solver)\n        short_alloc = {t: -w for (t, w) in short_alloc.items()}\n        self.allocation = long_alloc.copy()\n        self.allocation.update(short_alloc)\n        self.allocation = self._remove_zero_positions(self.allocation)\n        return (self.allocation, long_leftover + short_leftover)\n    p = self.latest_prices.values\n    n = len(p)\n    w = np.fromiter([i[1] for i in self.weights], dtype=float)\n    x = cp.Variable(n, integer=True)\n    r = self.total_portfolio_value - p.T @ x\n    eta = w * self.total_portfolio_value - cp.multiply(x, p)\n    u = cp.Variable(n)\n    constraints = [eta <= u, eta >= -u, x >= 0, r >= 0]\n    objective = cp.sum(u) + r\n    opt = cp.Problem(cp.Minimize(objective), constraints)\n    opt.solve(solver=solver)\n    if opt.status not in {'optimal', 'optimal_inaccurate'}:\n        raise exceptions.OptimizationError('Please try greedy_portfolio')\n    vals = np.rint(x.value).astype(int)\n    self.allocation = self._remove_zero_positions(collections.OrderedDict(zip([i[0] for i in self.weights], vals)))\n    if verbose:\n        print('Funds remaining: {:.2f}'.format(r.value))\n        self._allocation_rmse_error()\n    return (self.allocation, r.value)",
            "def lp_portfolio(self, reinvest=False, verbose=False, solver='ECOS_BB'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Convert continuous weights into a discrete portfolio allocation\\n        using integer programming.\\n\\n        :param reinvest: whether or not to reinvest cash gained from shorting\\n        :type reinvest: bool, defaults to False\\n        :param verbose: print error analysis?\\n        :type verbose: bool\\n        :param solver: the CVXPY solver to use (must support mixed-integer programs)\\n        :type solver: str, defaults to \"ECOS_BB\"\\n        :return: the number of shares of each ticker that should be purchased, along with the amount\\n                of funds leftover.\\n        :rtype: (dict, float)\\n        '\n    if any([w < 0 for (_, w) in self.weights]):\n        longs = {t: w for (t, w) in self.weights if w >= 0}\n        shorts = {t: -w for (t, w) in self.weights if w < 0}\n        long_total_weight = sum(longs.values())\n        short_total_weight = sum(shorts.values())\n        longs = {t: w / long_total_weight for (t, w) in longs.items()}\n        shorts = {t: w / short_total_weight for (t, w) in shorts.items()}\n        short_val = self.total_portfolio_value * self.short_ratio\n        long_val = self.total_portfolio_value\n        if reinvest:\n            long_val += short_val\n        if verbose:\n            print('\\nAllocating long sub-portfolio:')\n        da1 = DiscreteAllocation(longs, self.latest_prices[longs.keys()], total_portfolio_value=long_val)\n        (long_alloc, long_leftover) = da1.lp_portfolio(solver=solver)\n        if verbose:\n            print('\\nAllocating short sub-portfolio:')\n        da2 = DiscreteAllocation(shorts, self.latest_prices[shorts.keys()], total_portfolio_value=short_val)\n        (short_alloc, short_leftover) = da2.lp_portfolio(solver=solver)\n        short_alloc = {t: -w for (t, w) in short_alloc.items()}\n        self.allocation = long_alloc.copy()\n        self.allocation.update(short_alloc)\n        self.allocation = self._remove_zero_positions(self.allocation)\n        return (self.allocation, long_leftover + short_leftover)\n    p = self.latest_prices.values\n    n = len(p)\n    w = np.fromiter([i[1] for i in self.weights], dtype=float)\n    x = cp.Variable(n, integer=True)\n    r = self.total_portfolio_value - p.T @ x\n    eta = w * self.total_portfolio_value - cp.multiply(x, p)\n    u = cp.Variable(n)\n    constraints = [eta <= u, eta >= -u, x >= 0, r >= 0]\n    objective = cp.sum(u) + r\n    opt = cp.Problem(cp.Minimize(objective), constraints)\n    opt.solve(solver=solver)\n    if opt.status not in {'optimal', 'optimal_inaccurate'}:\n        raise exceptions.OptimizationError('Please try greedy_portfolio')\n    vals = np.rint(x.value).astype(int)\n    self.allocation = self._remove_zero_positions(collections.OrderedDict(zip([i[0] for i in self.weights], vals)))\n    if verbose:\n        print('Funds remaining: {:.2f}'.format(r.value))\n        self._allocation_rmse_error()\n    return (self.allocation, r.value)",
            "def lp_portfolio(self, reinvest=False, verbose=False, solver='ECOS_BB'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Convert continuous weights into a discrete portfolio allocation\\n        using integer programming.\\n\\n        :param reinvest: whether or not to reinvest cash gained from shorting\\n        :type reinvest: bool, defaults to False\\n        :param verbose: print error analysis?\\n        :type verbose: bool\\n        :param solver: the CVXPY solver to use (must support mixed-integer programs)\\n        :type solver: str, defaults to \"ECOS_BB\"\\n        :return: the number of shares of each ticker that should be purchased, along with the amount\\n                of funds leftover.\\n        :rtype: (dict, float)\\n        '\n    if any([w < 0 for (_, w) in self.weights]):\n        longs = {t: w for (t, w) in self.weights if w >= 0}\n        shorts = {t: -w for (t, w) in self.weights if w < 0}\n        long_total_weight = sum(longs.values())\n        short_total_weight = sum(shorts.values())\n        longs = {t: w / long_total_weight for (t, w) in longs.items()}\n        shorts = {t: w / short_total_weight for (t, w) in shorts.items()}\n        short_val = self.total_portfolio_value * self.short_ratio\n        long_val = self.total_portfolio_value\n        if reinvest:\n            long_val += short_val\n        if verbose:\n            print('\\nAllocating long sub-portfolio:')\n        da1 = DiscreteAllocation(longs, self.latest_prices[longs.keys()], total_portfolio_value=long_val)\n        (long_alloc, long_leftover) = da1.lp_portfolio(solver=solver)\n        if verbose:\n            print('\\nAllocating short sub-portfolio:')\n        da2 = DiscreteAllocation(shorts, self.latest_prices[shorts.keys()], total_portfolio_value=short_val)\n        (short_alloc, short_leftover) = da2.lp_portfolio(solver=solver)\n        short_alloc = {t: -w for (t, w) in short_alloc.items()}\n        self.allocation = long_alloc.copy()\n        self.allocation.update(short_alloc)\n        self.allocation = self._remove_zero_positions(self.allocation)\n        return (self.allocation, long_leftover + short_leftover)\n    p = self.latest_prices.values\n    n = len(p)\n    w = np.fromiter([i[1] for i in self.weights], dtype=float)\n    x = cp.Variable(n, integer=True)\n    r = self.total_portfolio_value - p.T @ x\n    eta = w * self.total_portfolio_value - cp.multiply(x, p)\n    u = cp.Variable(n)\n    constraints = [eta <= u, eta >= -u, x >= 0, r >= 0]\n    objective = cp.sum(u) + r\n    opt = cp.Problem(cp.Minimize(objective), constraints)\n    opt.solve(solver=solver)\n    if opt.status not in {'optimal', 'optimal_inaccurate'}:\n        raise exceptions.OptimizationError('Please try greedy_portfolio')\n    vals = np.rint(x.value).astype(int)\n    self.allocation = self._remove_zero_positions(collections.OrderedDict(zip([i[0] for i in self.weights], vals)))\n    if verbose:\n        print('Funds remaining: {:.2f}'.format(r.value))\n        self._allocation_rmse_error()\n    return (self.allocation, r.value)",
            "def lp_portfolio(self, reinvest=False, verbose=False, solver='ECOS_BB'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Convert continuous weights into a discrete portfolio allocation\\n        using integer programming.\\n\\n        :param reinvest: whether or not to reinvest cash gained from shorting\\n        :type reinvest: bool, defaults to False\\n        :param verbose: print error analysis?\\n        :type verbose: bool\\n        :param solver: the CVXPY solver to use (must support mixed-integer programs)\\n        :type solver: str, defaults to \"ECOS_BB\"\\n        :return: the number of shares of each ticker that should be purchased, along with the amount\\n                of funds leftover.\\n        :rtype: (dict, float)\\n        '\n    if any([w < 0 for (_, w) in self.weights]):\n        longs = {t: w for (t, w) in self.weights if w >= 0}\n        shorts = {t: -w for (t, w) in self.weights if w < 0}\n        long_total_weight = sum(longs.values())\n        short_total_weight = sum(shorts.values())\n        longs = {t: w / long_total_weight for (t, w) in longs.items()}\n        shorts = {t: w / short_total_weight for (t, w) in shorts.items()}\n        short_val = self.total_portfolio_value * self.short_ratio\n        long_val = self.total_portfolio_value\n        if reinvest:\n            long_val += short_val\n        if verbose:\n            print('\\nAllocating long sub-portfolio:')\n        da1 = DiscreteAllocation(longs, self.latest_prices[longs.keys()], total_portfolio_value=long_val)\n        (long_alloc, long_leftover) = da1.lp_portfolio(solver=solver)\n        if verbose:\n            print('\\nAllocating short sub-portfolio:')\n        da2 = DiscreteAllocation(shorts, self.latest_prices[shorts.keys()], total_portfolio_value=short_val)\n        (short_alloc, short_leftover) = da2.lp_portfolio(solver=solver)\n        short_alloc = {t: -w for (t, w) in short_alloc.items()}\n        self.allocation = long_alloc.copy()\n        self.allocation.update(short_alloc)\n        self.allocation = self._remove_zero_positions(self.allocation)\n        return (self.allocation, long_leftover + short_leftover)\n    p = self.latest_prices.values\n    n = len(p)\n    w = np.fromiter([i[1] for i in self.weights], dtype=float)\n    x = cp.Variable(n, integer=True)\n    r = self.total_portfolio_value - p.T @ x\n    eta = w * self.total_portfolio_value - cp.multiply(x, p)\n    u = cp.Variable(n)\n    constraints = [eta <= u, eta >= -u, x >= 0, r >= 0]\n    objective = cp.sum(u) + r\n    opt = cp.Problem(cp.Minimize(objective), constraints)\n    opt.solve(solver=solver)\n    if opt.status not in {'optimal', 'optimal_inaccurate'}:\n        raise exceptions.OptimizationError('Please try greedy_portfolio')\n    vals = np.rint(x.value).astype(int)\n    self.allocation = self._remove_zero_positions(collections.OrderedDict(zip([i[0] for i in self.weights], vals)))\n    if verbose:\n        print('Funds remaining: {:.2f}'.format(r.value))\n        self._allocation_rmse_error()\n    return (self.allocation, r.value)",
            "def lp_portfolio(self, reinvest=False, verbose=False, solver='ECOS_BB'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Convert continuous weights into a discrete portfolio allocation\\n        using integer programming.\\n\\n        :param reinvest: whether or not to reinvest cash gained from shorting\\n        :type reinvest: bool, defaults to False\\n        :param verbose: print error analysis?\\n        :type verbose: bool\\n        :param solver: the CVXPY solver to use (must support mixed-integer programs)\\n        :type solver: str, defaults to \"ECOS_BB\"\\n        :return: the number of shares of each ticker that should be purchased, along with the amount\\n                of funds leftover.\\n        :rtype: (dict, float)\\n        '\n    if any([w < 0 for (_, w) in self.weights]):\n        longs = {t: w for (t, w) in self.weights if w >= 0}\n        shorts = {t: -w for (t, w) in self.weights if w < 0}\n        long_total_weight = sum(longs.values())\n        short_total_weight = sum(shorts.values())\n        longs = {t: w / long_total_weight for (t, w) in longs.items()}\n        shorts = {t: w / short_total_weight for (t, w) in shorts.items()}\n        short_val = self.total_portfolio_value * self.short_ratio\n        long_val = self.total_portfolio_value\n        if reinvest:\n            long_val += short_val\n        if verbose:\n            print('\\nAllocating long sub-portfolio:')\n        da1 = DiscreteAllocation(longs, self.latest_prices[longs.keys()], total_portfolio_value=long_val)\n        (long_alloc, long_leftover) = da1.lp_portfolio(solver=solver)\n        if verbose:\n            print('\\nAllocating short sub-portfolio:')\n        da2 = DiscreteAllocation(shorts, self.latest_prices[shorts.keys()], total_portfolio_value=short_val)\n        (short_alloc, short_leftover) = da2.lp_portfolio(solver=solver)\n        short_alloc = {t: -w for (t, w) in short_alloc.items()}\n        self.allocation = long_alloc.copy()\n        self.allocation.update(short_alloc)\n        self.allocation = self._remove_zero_positions(self.allocation)\n        return (self.allocation, long_leftover + short_leftover)\n    p = self.latest_prices.values\n    n = len(p)\n    w = np.fromiter([i[1] for i in self.weights], dtype=float)\n    x = cp.Variable(n, integer=True)\n    r = self.total_portfolio_value - p.T @ x\n    eta = w * self.total_portfolio_value - cp.multiply(x, p)\n    u = cp.Variable(n)\n    constraints = [eta <= u, eta >= -u, x >= 0, r >= 0]\n    objective = cp.sum(u) + r\n    opt = cp.Problem(cp.Minimize(objective), constraints)\n    opt.solve(solver=solver)\n    if opt.status not in {'optimal', 'optimal_inaccurate'}:\n        raise exceptions.OptimizationError('Please try greedy_portfolio')\n    vals = np.rint(x.value).astype(int)\n    self.allocation = self._remove_zero_positions(collections.OrderedDict(zip([i[0] for i in self.weights], vals)))\n    if verbose:\n        print('Funds remaining: {:.2f}'.format(r.value))\n        self._allocation_rmse_error()\n    return (self.allocation, r.value)"
        ]
    }
]