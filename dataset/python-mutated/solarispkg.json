[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    Set the virtual pkg module if the os is Solaris\n    \"\"\"\n    if __grains__['os_family'] == 'Solaris' and float(__grains__['kernelrelease']) <= 5.1:\n        return __virtualname__\n    return (False, 'The solarispkg execution module failed to load: only available on Solaris <= 10.')",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    Set the virtual pkg module if the os is Solaris\\n    '\n    if __grains__['os_family'] == 'Solaris' and float(__grains__['kernelrelease']) <= 5.1:\n        return __virtualname__\n    return (False, 'The solarispkg execution module failed to load: only available on Solaris <= 10.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Set the virtual pkg module if the os is Solaris\\n    '\n    if __grains__['os_family'] == 'Solaris' and float(__grains__['kernelrelease']) <= 5.1:\n        return __virtualname__\n    return (False, 'The solarispkg execution module failed to load: only available on Solaris <= 10.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Set the virtual pkg module if the os is Solaris\\n    '\n    if __grains__['os_family'] == 'Solaris' and float(__grains__['kernelrelease']) <= 5.1:\n        return __virtualname__\n    return (False, 'The solarispkg execution module failed to load: only available on Solaris <= 10.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Set the virtual pkg module if the os is Solaris\\n    '\n    if __grains__['os_family'] == 'Solaris' and float(__grains__['kernelrelease']) <= 5.1:\n        return __virtualname__\n    return (False, 'The solarispkg execution module failed to load: only available on Solaris <= 10.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Set the virtual pkg module if the os is Solaris\\n    '\n    if __grains__['os_family'] == 'Solaris' and float(__grains__['kernelrelease']) <= 5.1:\n        return __virtualname__\n    return (False, 'The solarispkg execution module failed to load: only available on Solaris <= 10.')"
        ]
    },
    {
        "func_name": "_write_line",
        "original": "def _write_line(fp_, line):\n    fp_.write(salt.utils.stringutils.to_str(line))",
        "mutated": [
            "def _write_line(fp_, line):\n    if False:\n        i = 10\n    fp_.write(salt.utils.stringutils.to_str(line))",
            "def _write_line(fp_, line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    fp_.write(salt.utils.stringutils.to_str(line))",
            "def _write_line(fp_, line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    fp_.write(salt.utils.stringutils.to_str(line))",
            "def _write_line(fp_, line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    fp_.write(salt.utils.stringutils.to_str(line))",
            "def _write_line(fp_, line):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    fp_.write(salt.utils.stringutils.to_str(line))"
        ]
    },
    {
        "func_name": "_write_adminfile",
        "original": "def _write_adminfile(kwargs):\n    \"\"\"\n    Create a temporary adminfile based on the keyword arguments passed to\n    pkg.install.\n    \"\"\"\n    email = kwargs.get('email', '')\n    instance = kwargs.get('instance', 'quit')\n    partial = kwargs.get('partial', 'nocheck')\n    runlevel = kwargs.get('runlevel', 'nocheck')\n    idepend = kwargs.get('idepend', 'nocheck')\n    rdepend = kwargs.get('rdepend', 'nocheck')\n    space = kwargs.get('space', 'nocheck')\n    setuid = kwargs.get('setuid', 'nocheck')\n    conflict = kwargs.get('conflict', 'nocheck')\n    action = kwargs.get('action', 'nocheck')\n    basedir = kwargs.get('basedir', 'default')\n    adminfile = salt.utils.files.mkstemp(prefix='salt-')\n\n    def _write_line(fp_, line):\n        fp_.write(salt.utils.stringutils.to_str(line))\n    with salt.utils.files.fopen(adminfile, 'w') as fp_:\n        _write_line(fp_, 'email={}\\n'.format(email))\n        _write_line(fp_, 'instance={}\\n'.format(instance))\n        _write_line(fp_, 'partial={}\\n'.format(partial))\n        _write_line(fp_, 'runlevel={}\\n'.format(runlevel))\n        _write_line(fp_, 'idepend={}\\n'.format(idepend))\n        _write_line(fp_, 'rdepend={}\\n'.format(rdepend))\n        _write_line(fp_, 'space={}\\n'.format(space))\n        _write_line(fp_, 'setuid={}\\n'.format(setuid))\n        _write_line(fp_, 'conflict={}\\n'.format(conflict))\n        _write_line(fp_, 'action={}\\n'.format(action))\n        _write_line(fp_, 'basedir={}\\n'.format(basedir))\n    return adminfile",
        "mutated": [
            "def _write_adminfile(kwargs):\n    if False:\n        i = 10\n    '\\n    Create a temporary adminfile based on the keyword arguments passed to\\n    pkg.install.\\n    '\n    email = kwargs.get('email', '')\n    instance = kwargs.get('instance', 'quit')\n    partial = kwargs.get('partial', 'nocheck')\n    runlevel = kwargs.get('runlevel', 'nocheck')\n    idepend = kwargs.get('idepend', 'nocheck')\n    rdepend = kwargs.get('rdepend', 'nocheck')\n    space = kwargs.get('space', 'nocheck')\n    setuid = kwargs.get('setuid', 'nocheck')\n    conflict = kwargs.get('conflict', 'nocheck')\n    action = kwargs.get('action', 'nocheck')\n    basedir = kwargs.get('basedir', 'default')\n    adminfile = salt.utils.files.mkstemp(prefix='salt-')\n\n    def _write_line(fp_, line):\n        fp_.write(salt.utils.stringutils.to_str(line))\n    with salt.utils.files.fopen(adminfile, 'w') as fp_:\n        _write_line(fp_, 'email={}\\n'.format(email))\n        _write_line(fp_, 'instance={}\\n'.format(instance))\n        _write_line(fp_, 'partial={}\\n'.format(partial))\n        _write_line(fp_, 'runlevel={}\\n'.format(runlevel))\n        _write_line(fp_, 'idepend={}\\n'.format(idepend))\n        _write_line(fp_, 'rdepend={}\\n'.format(rdepend))\n        _write_line(fp_, 'space={}\\n'.format(space))\n        _write_line(fp_, 'setuid={}\\n'.format(setuid))\n        _write_line(fp_, 'conflict={}\\n'.format(conflict))\n        _write_line(fp_, 'action={}\\n'.format(action))\n        _write_line(fp_, 'basedir={}\\n'.format(basedir))\n    return adminfile",
            "def _write_adminfile(kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create a temporary adminfile based on the keyword arguments passed to\\n    pkg.install.\\n    '\n    email = kwargs.get('email', '')\n    instance = kwargs.get('instance', 'quit')\n    partial = kwargs.get('partial', 'nocheck')\n    runlevel = kwargs.get('runlevel', 'nocheck')\n    idepend = kwargs.get('idepend', 'nocheck')\n    rdepend = kwargs.get('rdepend', 'nocheck')\n    space = kwargs.get('space', 'nocheck')\n    setuid = kwargs.get('setuid', 'nocheck')\n    conflict = kwargs.get('conflict', 'nocheck')\n    action = kwargs.get('action', 'nocheck')\n    basedir = kwargs.get('basedir', 'default')\n    adminfile = salt.utils.files.mkstemp(prefix='salt-')\n\n    def _write_line(fp_, line):\n        fp_.write(salt.utils.stringutils.to_str(line))\n    with salt.utils.files.fopen(adminfile, 'w') as fp_:\n        _write_line(fp_, 'email={}\\n'.format(email))\n        _write_line(fp_, 'instance={}\\n'.format(instance))\n        _write_line(fp_, 'partial={}\\n'.format(partial))\n        _write_line(fp_, 'runlevel={}\\n'.format(runlevel))\n        _write_line(fp_, 'idepend={}\\n'.format(idepend))\n        _write_line(fp_, 'rdepend={}\\n'.format(rdepend))\n        _write_line(fp_, 'space={}\\n'.format(space))\n        _write_line(fp_, 'setuid={}\\n'.format(setuid))\n        _write_line(fp_, 'conflict={}\\n'.format(conflict))\n        _write_line(fp_, 'action={}\\n'.format(action))\n        _write_line(fp_, 'basedir={}\\n'.format(basedir))\n    return adminfile",
            "def _write_adminfile(kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create a temporary adminfile based on the keyword arguments passed to\\n    pkg.install.\\n    '\n    email = kwargs.get('email', '')\n    instance = kwargs.get('instance', 'quit')\n    partial = kwargs.get('partial', 'nocheck')\n    runlevel = kwargs.get('runlevel', 'nocheck')\n    idepend = kwargs.get('idepend', 'nocheck')\n    rdepend = kwargs.get('rdepend', 'nocheck')\n    space = kwargs.get('space', 'nocheck')\n    setuid = kwargs.get('setuid', 'nocheck')\n    conflict = kwargs.get('conflict', 'nocheck')\n    action = kwargs.get('action', 'nocheck')\n    basedir = kwargs.get('basedir', 'default')\n    adminfile = salt.utils.files.mkstemp(prefix='salt-')\n\n    def _write_line(fp_, line):\n        fp_.write(salt.utils.stringutils.to_str(line))\n    with salt.utils.files.fopen(adminfile, 'w') as fp_:\n        _write_line(fp_, 'email={}\\n'.format(email))\n        _write_line(fp_, 'instance={}\\n'.format(instance))\n        _write_line(fp_, 'partial={}\\n'.format(partial))\n        _write_line(fp_, 'runlevel={}\\n'.format(runlevel))\n        _write_line(fp_, 'idepend={}\\n'.format(idepend))\n        _write_line(fp_, 'rdepend={}\\n'.format(rdepend))\n        _write_line(fp_, 'space={}\\n'.format(space))\n        _write_line(fp_, 'setuid={}\\n'.format(setuid))\n        _write_line(fp_, 'conflict={}\\n'.format(conflict))\n        _write_line(fp_, 'action={}\\n'.format(action))\n        _write_line(fp_, 'basedir={}\\n'.format(basedir))\n    return adminfile",
            "def _write_adminfile(kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create a temporary adminfile based on the keyword arguments passed to\\n    pkg.install.\\n    '\n    email = kwargs.get('email', '')\n    instance = kwargs.get('instance', 'quit')\n    partial = kwargs.get('partial', 'nocheck')\n    runlevel = kwargs.get('runlevel', 'nocheck')\n    idepend = kwargs.get('idepend', 'nocheck')\n    rdepend = kwargs.get('rdepend', 'nocheck')\n    space = kwargs.get('space', 'nocheck')\n    setuid = kwargs.get('setuid', 'nocheck')\n    conflict = kwargs.get('conflict', 'nocheck')\n    action = kwargs.get('action', 'nocheck')\n    basedir = kwargs.get('basedir', 'default')\n    adminfile = salt.utils.files.mkstemp(prefix='salt-')\n\n    def _write_line(fp_, line):\n        fp_.write(salt.utils.stringutils.to_str(line))\n    with salt.utils.files.fopen(adminfile, 'w') as fp_:\n        _write_line(fp_, 'email={}\\n'.format(email))\n        _write_line(fp_, 'instance={}\\n'.format(instance))\n        _write_line(fp_, 'partial={}\\n'.format(partial))\n        _write_line(fp_, 'runlevel={}\\n'.format(runlevel))\n        _write_line(fp_, 'idepend={}\\n'.format(idepend))\n        _write_line(fp_, 'rdepend={}\\n'.format(rdepend))\n        _write_line(fp_, 'space={}\\n'.format(space))\n        _write_line(fp_, 'setuid={}\\n'.format(setuid))\n        _write_line(fp_, 'conflict={}\\n'.format(conflict))\n        _write_line(fp_, 'action={}\\n'.format(action))\n        _write_line(fp_, 'basedir={}\\n'.format(basedir))\n    return adminfile",
            "def _write_adminfile(kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create a temporary adminfile based on the keyword arguments passed to\\n    pkg.install.\\n    '\n    email = kwargs.get('email', '')\n    instance = kwargs.get('instance', 'quit')\n    partial = kwargs.get('partial', 'nocheck')\n    runlevel = kwargs.get('runlevel', 'nocheck')\n    idepend = kwargs.get('idepend', 'nocheck')\n    rdepend = kwargs.get('rdepend', 'nocheck')\n    space = kwargs.get('space', 'nocheck')\n    setuid = kwargs.get('setuid', 'nocheck')\n    conflict = kwargs.get('conflict', 'nocheck')\n    action = kwargs.get('action', 'nocheck')\n    basedir = kwargs.get('basedir', 'default')\n    adminfile = salt.utils.files.mkstemp(prefix='salt-')\n\n    def _write_line(fp_, line):\n        fp_.write(salt.utils.stringutils.to_str(line))\n    with salt.utils.files.fopen(adminfile, 'w') as fp_:\n        _write_line(fp_, 'email={}\\n'.format(email))\n        _write_line(fp_, 'instance={}\\n'.format(instance))\n        _write_line(fp_, 'partial={}\\n'.format(partial))\n        _write_line(fp_, 'runlevel={}\\n'.format(runlevel))\n        _write_line(fp_, 'idepend={}\\n'.format(idepend))\n        _write_line(fp_, 'rdepend={}\\n'.format(rdepend))\n        _write_line(fp_, 'space={}\\n'.format(space))\n        _write_line(fp_, 'setuid={}\\n'.format(setuid))\n        _write_line(fp_, 'conflict={}\\n'.format(conflict))\n        _write_line(fp_, 'action={}\\n'.format(action))\n        _write_line(fp_, 'basedir={}\\n'.format(basedir))\n    return adminfile"
        ]
    },
    {
        "func_name": "_list_pkgs_from_context",
        "original": "def _list_pkgs_from_context(versions_as_list):\n    \"\"\"\n    Use pkg list from __context__\n    \"\"\"\n    if versions_as_list:\n        return __context__['pkg.list_pkgs']\n    else:\n        ret = copy.deepcopy(__context__['pkg.list_pkgs'])\n        __salt__['pkg_resource.stringify'](ret)\n        return ret",
        "mutated": [
            "def _list_pkgs_from_context(versions_as_list):\n    if False:\n        i = 10\n    '\\n    Use pkg list from __context__\\n    '\n    if versions_as_list:\n        return __context__['pkg.list_pkgs']\n    else:\n        ret = copy.deepcopy(__context__['pkg.list_pkgs'])\n        __salt__['pkg_resource.stringify'](ret)\n        return ret",
            "def _list_pkgs_from_context(versions_as_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Use pkg list from __context__\\n    '\n    if versions_as_list:\n        return __context__['pkg.list_pkgs']\n    else:\n        ret = copy.deepcopy(__context__['pkg.list_pkgs'])\n        __salt__['pkg_resource.stringify'](ret)\n        return ret",
            "def _list_pkgs_from_context(versions_as_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Use pkg list from __context__\\n    '\n    if versions_as_list:\n        return __context__['pkg.list_pkgs']\n    else:\n        ret = copy.deepcopy(__context__['pkg.list_pkgs'])\n        __salt__['pkg_resource.stringify'](ret)\n        return ret",
            "def _list_pkgs_from_context(versions_as_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Use pkg list from __context__\\n    '\n    if versions_as_list:\n        return __context__['pkg.list_pkgs']\n    else:\n        ret = copy.deepcopy(__context__['pkg.list_pkgs'])\n        __salt__['pkg_resource.stringify'](ret)\n        return ret",
            "def _list_pkgs_from_context(versions_as_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Use pkg list from __context__\\n    '\n    if versions_as_list:\n        return __context__['pkg.list_pkgs']\n    else:\n        ret = copy.deepcopy(__context__['pkg.list_pkgs'])\n        __salt__['pkg_resource.stringify'](ret)\n        return ret"
        ]
    },
    {
        "func_name": "list_pkgs",
        "original": "def list_pkgs(versions_as_list=False, **kwargs):\n    \"\"\"\n    List the packages currently installed as a dict:\n\n    .. code-block:: python\n\n        {'<package_name>': '<version>'}\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.list_pkgs\n    \"\"\"\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    if 'pkg.list_pkgs' in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list)\n    ret = {}\n    cmd = '/usr/bin/pkginfo -x'\n    lines = __salt__['cmd.run'](cmd, output_loglevel='trace', python_shell=False).splitlines()\n    for (index, line) in enumerate(lines):\n        if index % 2 == 0:\n            name = line.split()[0].strip()\n        if index % 2 == 1:\n            version_num = line.split()[1].strip()\n            __salt__['pkg_resource.add_pkg'](ret, name, version_num)\n    __salt__['pkg_resource.sort_pkglist'](ret)\n    __context__['pkg.list_pkgs'] = copy.deepcopy(ret)\n    if not versions_as_list:\n        __salt__['pkg_resource.stringify'](ret)\n    return ret",
        "mutated": [
            "def list_pkgs(versions_as_list=False, **kwargs):\n    if False:\n        i = 10\n    \"\\n    List the packages currently installed as a dict:\\n\\n    .. code-block:: python\\n\\n        {'<package_name>': '<version>'}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_pkgs\\n    \"\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    if 'pkg.list_pkgs' in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list)\n    ret = {}\n    cmd = '/usr/bin/pkginfo -x'\n    lines = __salt__['cmd.run'](cmd, output_loglevel='trace', python_shell=False).splitlines()\n    for (index, line) in enumerate(lines):\n        if index % 2 == 0:\n            name = line.split()[0].strip()\n        if index % 2 == 1:\n            version_num = line.split()[1].strip()\n            __salt__['pkg_resource.add_pkg'](ret, name, version_num)\n    __salt__['pkg_resource.sort_pkglist'](ret)\n    __context__['pkg.list_pkgs'] = copy.deepcopy(ret)\n    if not versions_as_list:\n        __salt__['pkg_resource.stringify'](ret)\n    return ret",
            "def list_pkgs(versions_as_list=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    List the packages currently installed as a dict:\\n\\n    .. code-block:: python\\n\\n        {'<package_name>': '<version>'}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_pkgs\\n    \"\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    if 'pkg.list_pkgs' in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list)\n    ret = {}\n    cmd = '/usr/bin/pkginfo -x'\n    lines = __salt__['cmd.run'](cmd, output_loglevel='trace', python_shell=False).splitlines()\n    for (index, line) in enumerate(lines):\n        if index % 2 == 0:\n            name = line.split()[0].strip()\n        if index % 2 == 1:\n            version_num = line.split()[1].strip()\n            __salt__['pkg_resource.add_pkg'](ret, name, version_num)\n    __salt__['pkg_resource.sort_pkglist'](ret)\n    __context__['pkg.list_pkgs'] = copy.deepcopy(ret)\n    if not versions_as_list:\n        __salt__['pkg_resource.stringify'](ret)\n    return ret",
            "def list_pkgs(versions_as_list=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    List the packages currently installed as a dict:\\n\\n    .. code-block:: python\\n\\n        {'<package_name>': '<version>'}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_pkgs\\n    \"\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    if 'pkg.list_pkgs' in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list)\n    ret = {}\n    cmd = '/usr/bin/pkginfo -x'\n    lines = __salt__['cmd.run'](cmd, output_loglevel='trace', python_shell=False).splitlines()\n    for (index, line) in enumerate(lines):\n        if index % 2 == 0:\n            name = line.split()[0].strip()\n        if index % 2 == 1:\n            version_num = line.split()[1].strip()\n            __salt__['pkg_resource.add_pkg'](ret, name, version_num)\n    __salt__['pkg_resource.sort_pkglist'](ret)\n    __context__['pkg.list_pkgs'] = copy.deepcopy(ret)\n    if not versions_as_list:\n        __salt__['pkg_resource.stringify'](ret)\n    return ret",
            "def list_pkgs(versions_as_list=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    List the packages currently installed as a dict:\\n\\n    .. code-block:: python\\n\\n        {'<package_name>': '<version>'}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_pkgs\\n    \"\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    if 'pkg.list_pkgs' in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list)\n    ret = {}\n    cmd = '/usr/bin/pkginfo -x'\n    lines = __salt__['cmd.run'](cmd, output_loglevel='trace', python_shell=False).splitlines()\n    for (index, line) in enumerate(lines):\n        if index % 2 == 0:\n            name = line.split()[0].strip()\n        if index % 2 == 1:\n            version_num = line.split()[1].strip()\n            __salt__['pkg_resource.add_pkg'](ret, name, version_num)\n    __salt__['pkg_resource.sort_pkglist'](ret)\n    __context__['pkg.list_pkgs'] = copy.deepcopy(ret)\n    if not versions_as_list:\n        __salt__['pkg_resource.stringify'](ret)\n    return ret",
            "def list_pkgs(versions_as_list=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    List the packages currently installed as a dict:\\n\\n    .. code-block:: python\\n\\n        {'<package_name>': '<version>'}\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.list_pkgs\\n    \"\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    if any([salt.utils.data.is_true(kwargs.get(x)) for x in ('removed', 'purge_desired')]):\n        return {}\n    if 'pkg.list_pkgs' in __context__ and kwargs.get('use_context', True):\n        return _list_pkgs_from_context(versions_as_list)\n    ret = {}\n    cmd = '/usr/bin/pkginfo -x'\n    lines = __salt__['cmd.run'](cmd, output_loglevel='trace', python_shell=False).splitlines()\n    for (index, line) in enumerate(lines):\n        if index % 2 == 0:\n            name = line.split()[0].strip()\n        if index % 2 == 1:\n            version_num = line.split()[1].strip()\n            __salt__['pkg_resource.add_pkg'](ret, name, version_num)\n    __salt__['pkg_resource.sort_pkglist'](ret)\n    __context__['pkg.list_pkgs'] = copy.deepcopy(ret)\n    if not versions_as_list:\n        __salt__['pkg_resource.stringify'](ret)\n    return ret"
        ]
    },
    {
        "func_name": "latest_version",
        "original": "def latest_version(*names, **kwargs):\n    \"\"\"\n    Return the latest version of the named package available for upgrade or\n    installation. If more than one package name is specified, a dict of\n    name/version pairs is returned.\n\n    If the latest version of a given package is already installed, an empty\n    string will be returned for that package.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.latest_version <package name>\n        salt '*' pkg.latest_version <package1> <package2> <package3> ...\n\n    NOTE: As package repositories are not presently supported for Solaris\n    pkgadd, this function will always return an empty string for a given\n    package.\n    \"\"\"\n    kwargs.pop('refresh', True)\n    ret = {}\n    if not names:\n        return ''\n    for name in names:\n        ret[name] = ''\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret",
        "mutated": [
            "def latest_version(*names, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Return the latest version of the named package available for upgrade or\\n    installation. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    If the latest version of a given package is already installed, an empty\\n    string will be returned for that package.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.latest_version <package name>\\n        salt '*' pkg.latest_version <package1> <package2> <package3> ...\\n\\n    NOTE: As package repositories are not presently supported for Solaris\\n    pkgadd, this function will always return an empty string for a given\\n    package.\\n    \"\n    kwargs.pop('refresh', True)\n    ret = {}\n    if not names:\n        return ''\n    for name in names:\n        ret[name] = ''\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret",
            "def latest_version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Return the latest version of the named package available for upgrade or\\n    installation. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    If the latest version of a given package is already installed, an empty\\n    string will be returned for that package.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.latest_version <package name>\\n        salt '*' pkg.latest_version <package1> <package2> <package3> ...\\n\\n    NOTE: As package repositories are not presently supported for Solaris\\n    pkgadd, this function will always return an empty string for a given\\n    package.\\n    \"\n    kwargs.pop('refresh', True)\n    ret = {}\n    if not names:\n        return ''\n    for name in names:\n        ret[name] = ''\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret",
            "def latest_version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Return the latest version of the named package available for upgrade or\\n    installation. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    If the latest version of a given package is already installed, an empty\\n    string will be returned for that package.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.latest_version <package name>\\n        salt '*' pkg.latest_version <package1> <package2> <package3> ...\\n\\n    NOTE: As package repositories are not presently supported for Solaris\\n    pkgadd, this function will always return an empty string for a given\\n    package.\\n    \"\n    kwargs.pop('refresh', True)\n    ret = {}\n    if not names:\n        return ''\n    for name in names:\n        ret[name] = ''\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret",
            "def latest_version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Return the latest version of the named package available for upgrade or\\n    installation. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    If the latest version of a given package is already installed, an empty\\n    string will be returned for that package.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.latest_version <package name>\\n        salt '*' pkg.latest_version <package1> <package2> <package3> ...\\n\\n    NOTE: As package repositories are not presently supported for Solaris\\n    pkgadd, this function will always return an empty string for a given\\n    package.\\n    \"\n    kwargs.pop('refresh', True)\n    ret = {}\n    if not names:\n        return ''\n    for name in names:\n        ret[name] = ''\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret",
            "def latest_version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Return the latest version of the named package available for upgrade or\\n    installation. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    If the latest version of a given package is already installed, an empty\\n    string will be returned for that package.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.latest_version <package name>\\n        salt '*' pkg.latest_version <package1> <package2> <package3> ...\\n\\n    NOTE: As package repositories are not presently supported for Solaris\\n    pkgadd, this function will always return an empty string for a given\\n    package.\\n    \"\n    kwargs.pop('refresh', True)\n    ret = {}\n    if not names:\n        return ''\n    for name in names:\n        ret[name] = ''\n    if len(names) == 1:\n        return ret[names[0]]\n    return ret"
        ]
    },
    {
        "func_name": "upgrade_available",
        "original": "def upgrade_available(name, **kwargs):\n    \"\"\"\n    Check whether or not an upgrade is available for a given package\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.upgrade_available <package name>\n    \"\"\"\n    return latest_version(name) != ''",
        "mutated": [
            "def upgrade_available(name, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Check whether or not an upgrade is available for a given package\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade_available <package name>\\n    \"\n    return latest_version(name) != ''",
            "def upgrade_available(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Check whether or not an upgrade is available for a given package\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade_available <package name>\\n    \"\n    return latest_version(name) != ''",
            "def upgrade_available(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Check whether or not an upgrade is available for a given package\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade_available <package name>\\n    \"\n    return latest_version(name) != ''",
            "def upgrade_available(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Check whether or not an upgrade is available for a given package\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade_available <package name>\\n    \"\n    return latest_version(name) != ''",
            "def upgrade_available(name, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Check whether or not an upgrade is available for a given package\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.upgrade_available <package name>\\n    \"\n    return latest_version(name) != ''"
        ]
    },
    {
        "func_name": "version",
        "original": "def version(*names, **kwargs):\n    \"\"\"\n    Returns a string representing the package version or an empty string if not\n    installed. If more than one package name is specified, a dict of\n    name/version pairs is returned.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.version <package name>\n        salt '*' pkg.version <package1> <package2> <package3> ...\n    \"\"\"\n    return __salt__['pkg_resource.version'](*names, **kwargs)",
        "mutated": [
            "def version(*names, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Returns a string representing the package version or an empty string if not\\n    installed. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version <package name>\\n        salt '*' pkg.version <package1> <package2> <package3> ...\\n    \"\n    return __salt__['pkg_resource.version'](*names, **kwargs)",
            "def version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Returns a string representing the package version or an empty string if not\\n    installed. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version <package name>\\n        salt '*' pkg.version <package1> <package2> <package3> ...\\n    \"\n    return __salt__['pkg_resource.version'](*names, **kwargs)",
            "def version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Returns a string representing the package version or an empty string if not\\n    installed. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version <package name>\\n        salt '*' pkg.version <package1> <package2> <package3> ...\\n    \"\n    return __salt__['pkg_resource.version'](*names, **kwargs)",
            "def version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Returns a string representing the package version or an empty string if not\\n    installed. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version <package name>\\n        salt '*' pkg.version <package1> <package2> <package3> ...\\n    \"\n    return __salt__['pkg_resource.version'](*names, **kwargs)",
            "def version(*names, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Returns a string representing the package version or an empty string if not\\n    installed. If more than one package name is specified, a dict of\\n    name/version pairs is returned.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' pkg.version <package name>\\n        salt '*' pkg.version <package1> <package2> <package3> ...\\n    \"\n    return __salt__['pkg_resource.version'](*names, **kwargs)"
        ]
    },
    {
        "func_name": "install",
        "original": "def install(name=None, sources=None, saltenv='base', **kwargs):\n    \"\"\"\n    Install the passed package. Can install packages from the following\n    sources:\n\n    * Locally (package already exists on the minion\n    * HTTP/HTTPS server\n    * FTP server\n    * Salt master\n\n    Returns a dict containing the new package names and versions:\n\n    .. code-block:: python\n\n        {'<package>': {'old': '<old-version>',\n                       'new': '<new-version>'}}\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        # Installing a data stream pkg that already exists on the minion\n\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"/dir/on/minion/<pkg filename>\"}]'\n        salt '*' pkg.install sources='[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]'\n\n        # Installing a data stream pkg that exists on the salt master\n\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]'\n        salt '*' pkg.install sources='[{\"SMClgcc346\": \"salt://pkgs/gcc-3.4.6-sol10-sparc-local.pkg\"}]'\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Installing a data stream pkg that exists on a HTTP server\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"http://packages.server.com/<pkg filename>\"}]'\n        salt '*' pkg.install sources='[{\"SMClgcc346\": \"http://packages.server.com/gcc-3.4.6-sol10-sparc-local.pkg\"}]'\n\n    If working with solaris zones and you want to install a package only in the\n    global zone you can pass 'current_zone_only=True' to salt to have the\n    package only installed in the global zone. (Behind the scenes this is\n    passing '-G' to the pkgadd command.) Solaris default when installing a\n    package in the global zone is to install it in all zones. This overrides\n    that and installs the package only in the global.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Installing a data stream package only in the global zone:\n        salt 'global_zone' pkg.install sources='[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]' current_zone_only=True\n\n    By default salt automatically provides an adminfile, to automate package\n    installation, with these options set::\n\n        email=\n        instance=quit\n        partial=nocheck\n        runlevel=nocheck\n        idepend=nocheck\n        rdepend=nocheck\n        space=nocheck\n        setuid=nocheck\n        conflict=nocheck\n        action=nocheck\n        basedir=default\n\n    You can override any of these options in two ways. First you can optionally\n    pass any of the options as a kwarg to the module/state to override the\n    default value or you can optionally pass the 'admin_source' option\n    providing your own adminfile to the minions.\n\n    Note: You can find all of the possible options to provide to the adminfile\n    by reading the admin man page:\n\n    .. code-block:: bash\n\n        man -s 4 admin\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Overriding the 'instance' adminfile option when calling the module directly\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]' instance=\"overwrite\"\n\n    SLS Example:\n\n    .. code-block:: yaml\n\n        # Overriding the 'instance' adminfile option when used in a state\n\n        SMClgcc346:\n          pkg.installed:\n            - sources:\n              - SMClgcc346: salt://srv/salt/pkgs/gcc-3.4.6-sol10-sparc-local.pkg\n            - instance: overwrite\n\n    .. note::\n        The ID declaration is ignored, as the package name is read from the\n        ``sources`` parameter.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Providing your own adminfile when calling the module directly\n\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]' admin_source='salt://pkgs/<adminfile filename>'\n\n        # Providing your own adminfile when using states\n\n        <pkg name>:\n          pkg.installed:\n            - sources:\n              - <pkg name>: salt://pkgs/<pkg filename>\n            - admin_source: salt://pkgs/<adminfile filename>\n\n    .. note::\n        The ID declaration is ignored, as the package name is read from the\n        ``sources`` parameter.\n    \"\"\"\n    if salt.utils.data.is_true(kwargs.get('refresh')):\n        log.warning(\"'refresh' argument not implemented for solarispkg module\")\n    pkgs = kwargs.pop('pkgs', None)\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    if not sources:\n        log.error('\"sources\" param required for solaris pkg_add installs')\n        return {}\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            adminfile = _write_adminfile(kwargs)\n        old = list_pkgs()\n        cmd_prefix = ['/usr/sbin/pkgadd', '-n', '-a', adminfile]\n        if kwargs.get('current_zone_only') in (True, 'True'):\n            cmd_prefix.append('-G ')\n        errors = []\n        for pkg in pkg_params:\n            cmd = cmd_prefix + ['-d', pkg, 'all']\n            out = __salt__['cmd.run_all'](cmd, output_loglevel='trace', python_shell=False)\n            if out['retcode'] != 0 and out['stderr']:\n                errors.append(out['stderr'])\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n        if errors:\n            raise CommandExecutionError('Problem encountered installing package(s)', info={'errors': errors, 'changes': ret})\n    finally:\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n    return ret",
        "mutated": [
            "def install(name=None, sources=None, saltenv='base', **kwargs):\n    if False:\n        i = 10\n    '\\n    Install the passed package. Can install packages from the following\\n    sources:\\n\\n    * Locally (package already exists on the minion\\n    * HTTP/HTTPS server\\n    * FTP server\\n    * Salt master\\n\\n    Returns a dict containing the new package names and versions:\\n\\n    .. code-block:: python\\n\\n        {\\'<package>\\': {\\'old\\': \\'<old-version>\\',\\n                       \\'new\\': \\'<new-version>\\'}}\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        # Installing a data stream pkg that already exists on the minion\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"/dir/on/minion/<pkg filename>\"}]\\'\\n        salt \\'*\\' pkg.install sources=\\'[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\'\\n\\n        # Installing a data stream pkg that exists on the salt master\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\'\\n        salt \\'*\\' pkg.install sources=\\'[{\"SMClgcc346\": \"salt://pkgs/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\'\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Installing a data stream pkg that exists on a HTTP server\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"http://packages.server.com/<pkg filename>\"}]\\'\\n        salt \\'*\\' pkg.install sources=\\'[{\"SMClgcc346\": \"http://packages.server.com/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\'\\n\\n    If working with solaris zones and you want to install a package only in the\\n    global zone you can pass \\'current_zone_only=True\\' to salt to have the\\n    package only installed in the global zone. (Behind the scenes this is\\n    passing \\'-G\\' to the pkgadd command.) Solaris default when installing a\\n    package in the global zone is to install it in all zones. This overrides\\n    that and installs the package only in the global.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Installing a data stream package only in the global zone:\\n        salt \\'global_zone\\' pkg.install sources=\\'[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\' current_zone_only=True\\n\\n    By default salt automatically provides an adminfile, to automate package\\n    installation, with these options set::\\n\\n        email=\\n        instance=quit\\n        partial=nocheck\\n        runlevel=nocheck\\n        idepend=nocheck\\n        rdepend=nocheck\\n        space=nocheck\\n        setuid=nocheck\\n        conflict=nocheck\\n        action=nocheck\\n        basedir=default\\n\\n    You can override any of these options in two ways. First you can optionally\\n    pass any of the options as a kwarg to the module/state to override the\\n    default value or you can optionally pass the \\'admin_source\\' option\\n    providing your own adminfile to the minions.\\n\\n    Note: You can find all of the possible options to provide to the adminfile\\n    by reading the admin man page:\\n\\n    .. code-block:: bash\\n\\n        man -s 4 admin\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Overriding the \\'instance\\' adminfile option when calling the module directly\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\' instance=\"overwrite\"\\n\\n    SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        # Overriding the \\'instance\\' adminfile option when used in a state\\n\\n        SMClgcc346:\\n          pkg.installed:\\n            - sources:\\n              - SMClgcc346: salt://srv/salt/pkgs/gcc-3.4.6-sol10-sparc-local.pkg\\n            - instance: overwrite\\n\\n    .. note::\\n        The ID declaration is ignored, as the package name is read from the\\n        ``sources`` parameter.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Providing your own adminfile when calling the module directly\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\' admin_source=\\'salt://pkgs/<adminfile filename>\\'\\n\\n        # Providing your own adminfile when using states\\n\\n        <pkg name>:\\n          pkg.installed:\\n            - sources:\\n              - <pkg name>: salt://pkgs/<pkg filename>\\n            - admin_source: salt://pkgs/<adminfile filename>\\n\\n    .. note::\\n        The ID declaration is ignored, as the package name is read from the\\n        ``sources`` parameter.\\n    '\n    if salt.utils.data.is_true(kwargs.get('refresh')):\n        log.warning(\"'refresh' argument not implemented for solarispkg module\")\n    pkgs = kwargs.pop('pkgs', None)\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    if not sources:\n        log.error('\"sources\" param required for solaris pkg_add installs')\n        return {}\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            adminfile = _write_adminfile(kwargs)\n        old = list_pkgs()\n        cmd_prefix = ['/usr/sbin/pkgadd', '-n', '-a', adminfile]\n        if kwargs.get('current_zone_only') in (True, 'True'):\n            cmd_prefix.append('-G ')\n        errors = []\n        for pkg in pkg_params:\n            cmd = cmd_prefix + ['-d', pkg, 'all']\n            out = __salt__['cmd.run_all'](cmd, output_loglevel='trace', python_shell=False)\n            if out['retcode'] != 0 and out['stderr']:\n                errors.append(out['stderr'])\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n        if errors:\n            raise CommandExecutionError('Problem encountered installing package(s)', info={'errors': errors, 'changes': ret})\n    finally:\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n    return ret",
            "def install(name=None, sources=None, saltenv='base', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Install the passed package. Can install packages from the following\\n    sources:\\n\\n    * Locally (package already exists on the minion\\n    * HTTP/HTTPS server\\n    * FTP server\\n    * Salt master\\n\\n    Returns a dict containing the new package names and versions:\\n\\n    .. code-block:: python\\n\\n        {\\'<package>\\': {\\'old\\': \\'<old-version>\\',\\n                       \\'new\\': \\'<new-version>\\'}}\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        # Installing a data stream pkg that already exists on the minion\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"/dir/on/minion/<pkg filename>\"}]\\'\\n        salt \\'*\\' pkg.install sources=\\'[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\'\\n\\n        # Installing a data stream pkg that exists on the salt master\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\'\\n        salt \\'*\\' pkg.install sources=\\'[{\"SMClgcc346\": \"salt://pkgs/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\'\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Installing a data stream pkg that exists on a HTTP server\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"http://packages.server.com/<pkg filename>\"}]\\'\\n        salt \\'*\\' pkg.install sources=\\'[{\"SMClgcc346\": \"http://packages.server.com/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\'\\n\\n    If working with solaris zones and you want to install a package only in the\\n    global zone you can pass \\'current_zone_only=True\\' to salt to have the\\n    package only installed in the global zone. (Behind the scenes this is\\n    passing \\'-G\\' to the pkgadd command.) Solaris default when installing a\\n    package in the global zone is to install it in all zones. This overrides\\n    that and installs the package only in the global.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Installing a data stream package only in the global zone:\\n        salt \\'global_zone\\' pkg.install sources=\\'[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\' current_zone_only=True\\n\\n    By default salt automatically provides an adminfile, to automate package\\n    installation, with these options set::\\n\\n        email=\\n        instance=quit\\n        partial=nocheck\\n        runlevel=nocheck\\n        idepend=nocheck\\n        rdepend=nocheck\\n        space=nocheck\\n        setuid=nocheck\\n        conflict=nocheck\\n        action=nocheck\\n        basedir=default\\n\\n    You can override any of these options in two ways. First you can optionally\\n    pass any of the options as a kwarg to the module/state to override the\\n    default value or you can optionally pass the \\'admin_source\\' option\\n    providing your own adminfile to the minions.\\n\\n    Note: You can find all of the possible options to provide to the adminfile\\n    by reading the admin man page:\\n\\n    .. code-block:: bash\\n\\n        man -s 4 admin\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Overriding the \\'instance\\' adminfile option when calling the module directly\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\' instance=\"overwrite\"\\n\\n    SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        # Overriding the \\'instance\\' adminfile option when used in a state\\n\\n        SMClgcc346:\\n          pkg.installed:\\n            - sources:\\n              - SMClgcc346: salt://srv/salt/pkgs/gcc-3.4.6-sol10-sparc-local.pkg\\n            - instance: overwrite\\n\\n    .. note::\\n        The ID declaration is ignored, as the package name is read from the\\n        ``sources`` parameter.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Providing your own adminfile when calling the module directly\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\' admin_source=\\'salt://pkgs/<adminfile filename>\\'\\n\\n        # Providing your own adminfile when using states\\n\\n        <pkg name>:\\n          pkg.installed:\\n            - sources:\\n              - <pkg name>: salt://pkgs/<pkg filename>\\n            - admin_source: salt://pkgs/<adminfile filename>\\n\\n    .. note::\\n        The ID declaration is ignored, as the package name is read from the\\n        ``sources`` parameter.\\n    '\n    if salt.utils.data.is_true(kwargs.get('refresh')):\n        log.warning(\"'refresh' argument not implemented for solarispkg module\")\n    pkgs = kwargs.pop('pkgs', None)\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    if not sources:\n        log.error('\"sources\" param required for solaris pkg_add installs')\n        return {}\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            adminfile = _write_adminfile(kwargs)\n        old = list_pkgs()\n        cmd_prefix = ['/usr/sbin/pkgadd', '-n', '-a', adminfile]\n        if kwargs.get('current_zone_only') in (True, 'True'):\n            cmd_prefix.append('-G ')\n        errors = []\n        for pkg in pkg_params:\n            cmd = cmd_prefix + ['-d', pkg, 'all']\n            out = __salt__['cmd.run_all'](cmd, output_loglevel='trace', python_shell=False)\n            if out['retcode'] != 0 and out['stderr']:\n                errors.append(out['stderr'])\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n        if errors:\n            raise CommandExecutionError('Problem encountered installing package(s)', info={'errors': errors, 'changes': ret})\n    finally:\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n    return ret",
            "def install(name=None, sources=None, saltenv='base', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Install the passed package. Can install packages from the following\\n    sources:\\n\\n    * Locally (package already exists on the minion\\n    * HTTP/HTTPS server\\n    * FTP server\\n    * Salt master\\n\\n    Returns a dict containing the new package names and versions:\\n\\n    .. code-block:: python\\n\\n        {\\'<package>\\': {\\'old\\': \\'<old-version>\\',\\n                       \\'new\\': \\'<new-version>\\'}}\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        # Installing a data stream pkg that already exists on the minion\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"/dir/on/minion/<pkg filename>\"}]\\'\\n        salt \\'*\\' pkg.install sources=\\'[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\'\\n\\n        # Installing a data stream pkg that exists on the salt master\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\'\\n        salt \\'*\\' pkg.install sources=\\'[{\"SMClgcc346\": \"salt://pkgs/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\'\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Installing a data stream pkg that exists on a HTTP server\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"http://packages.server.com/<pkg filename>\"}]\\'\\n        salt \\'*\\' pkg.install sources=\\'[{\"SMClgcc346\": \"http://packages.server.com/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\'\\n\\n    If working with solaris zones and you want to install a package only in the\\n    global zone you can pass \\'current_zone_only=True\\' to salt to have the\\n    package only installed in the global zone. (Behind the scenes this is\\n    passing \\'-G\\' to the pkgadd command.) Solaris default when installing a\\n    package in the global zone is to install it in all zones. This overrides\\n    that and installs the package only in the global.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Installing a data stream package only in the global zone:\\n        salt \\'global_zone\\' pkg.install sources=\\'[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\' current_zone_only=True\\n\\n    By default salt automatically provides an adminfile, to automate package\\n    installation, with these options set::\\n\\n        email=\\n        instance=quit\\n        partial=nocheck\\n        runlevel=nocheck\\n        idepend=nocheck\\n        rdepend=nocheck\\n        space=nocheck\\n        setuid=nocheck\\n        conflict=nocheck\\n        action=nocheck\\n        basedir=default\\n\\n    You can override any of these options in two ways. First you can optionally\\n    pass any of the options as a kwarg to the module/state to override the\\n    default value or you can optionally pass the \\'admin_source\\' option\\n    providing your own adminfile to the minions.\\n\\n    Note: You can find all of the possible options to provide to the adminfile\\n    by reading the admin man page:\\n\\n    .. code-block:: bash\\n\\n        man -s 4 admin\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Overriding the \\'instance\\' adminfile option when calling the module directly\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\' instance=\"overwrite\"\\n\\n    SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        # Overriding the \\'instance\\' adminfile option when used in a state\\n\\n        SMClgcc346:\\n          pkg.installed:\\n            - sources:\\n              - SMClgcc346: salt://srv/salt/pkgs/gcc-3.4.6-sol10-sparc-local.pkg\\n            - instance: overwrite\\n\\n    .. note::\\n        The ID declaration is ignored, as the package name is read from the\\n        ``sources`` parameter.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Providing your own adminfile when calling the module directly\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\' admin_source=\\'salt://pkgs/<adminfile filename>\\'\\n\\n        # Providing your own adminfile when using states\\n\\n        <pkg name>:\\n          pkg.installed:\\n            - sources:\\n              - <pkg name>: salt://pkgs/<pkg filename>\\n            - admin_source: salt://pkgs/<adminfile filename>\\n\\n    .. note::\\n        The ID declaration is ignored, as the package name is read from the\\n        ``sources`` parameter.\\n    '\n    if salt.utils.data.is_true(kwargs.get('refresh')):\n        log.warning(\"'refresh' argument not implemented for solarispkg module\")\n    pkgs = kwargs.pop('pkgs', None)\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    if not sources:\n        log.error('\"sources\" param required for solaris pkg_add installs')\n        return {}\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            adminfile = _write_adminfile(kwargs)\n        old = list_pkgs()\n        cmd_prefix = ['/usr/sbin/pkgadd', '-n', '-a', adminfile]\n        if kwargs.get('current_zone_only') in (True, 'True'):\n            cmd_prefix.append('-G ')\n        errors = []\n        for pkg in pkg_params:\n            cmd = cmd_prefix + ['-d', pkg, 'all']\n            out = __salt__['cmd.run_all'](cmd, output_loglevel='trace', python_shell=False)\n            if out['retcode'] != 0 and out['stderr']:\n                errors.append(out['stderr'])\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n        if errors:\n            raise CommandExecutionError('Problem encountered installing package(s)', info={'errors': errors, 'changes': ret})\n    finally:\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n    return ret",
            "def install(name=None, sources=None, saltenv='base', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Install the passed package. Can install packages from the following\\n    sources:\\n\\n    * Locally (package already exists on the minion\\n    * HTTP/HTTPS server\\n    * FTP server\\n    * Salt master\\n\\n    Returns a dict containing the new package names and versions:\\n\\n    .. code-block:: python\\n\\n        {\\'<package>\\': {\\'old\\': \\'<old-version>\\',\\n                       \\'new\\': \\'<new-version>\\'}}\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        # Installing a data stream pkg that already exists on the minion\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"/dir/on/minion/<pkg filename>\"}]\\'\\n        salt \\'*\\' pkg.install sources=\\'[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\'\\n\\n        # Installing a data stream pkg that exists on the salt master\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\'\\n        salt \\'*\\' pkg.install sources=\\'[{\"SMClgcc346\": \"salt://pkgs/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\'\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Installing a data stream pkg that exists on a HTTP server\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"http://packages.server.com/<pkg filename>\"}]\\'\\n        salt \\'*\\' pkg.install sources=\\'[{\"SMClgcc346\": \"http://packages.server.com/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\'\\n\\n    If working with solaris zones and you want to install a package only in the\\n    global zone you can pass \\'current_zone_only=True\\' to salt to have the\\n    package only installed in the global zone. (Behind the scenes this is\\n    passing \\'-G\\' to the pkgadd command.) Solaris default when installing a\\n    package in the global zone is to install it in all zones. This overrides\\n    that and installs the package only in the global.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Installing a data stream package only in the global zone:\\n        salt \\'global_zone\\' pkg.install sources=\\'[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\' current_zone_only=True\\n\\n    By default salt automatically provides an adminfile, to automate package\\n    installation, with these options set::\\n\\n        email=\\n        instance=quit\\n        partial=nocheck\\n        runlevel=nocheck\\n        idepend=nocheck\\n        rdepend=nocheck\\n        space=nocheck\\n        setuid=nocheck\\n        conflict=nocheck\\n        action=nocheck\\n        basedir=default\\n\\n    You can override any of these options in two ways. First you can optionally\\n    pass any of the options as a kwarg to the module/state to override the\\n    default value or you can optionally pass the \\'admin_source\\' option\\n    providing your own adminfile to the minions.\\n\\n    Note: You can find all of the possible options to provide to the adminfile\\n    by reading the admin man page:\\n\\n    .. code-block:: bash\\n\\n        man -s 4 admin\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Overriding the \\'instance\\' adminfile option when calling the module directly\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\' instance=\"overwrite\"\\n\\n    SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        # Overriding the \\'instance\\' adminfile option when used in a state\\n\\n        SMClgcc346:\\n          pkg.installed:\\n            - sources:\\n              - SMClgcc346: salt://srv/salt/pkgs/gcc-3.4.6-sol10-sparc-local.pkg\\n            - instance: overwrite\\n\\n    .. note::\\n        The ID declaration is ignored, as the package name is read from the\\n        ``sources`` parameter.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Providing your own adminfile when calling the module directly\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\' admin_source=\\'salt://pkgs/<adminfile filename>\\'\\n\\n        # Providing your own adminfile when using states\\n\\n        <pkg name>:\\n          pkg.installed:\\n            - sources:\\n              - <pkg name>: salt://pkgs/<pkg filename>\\n            - admin_source: salt://pkgs/<adminfile filename>\\n\\n    .. note::\\n        The ID declaration is ignored, as the package name is read from the\\n        ``sources`` parameter.\\n    '\n    if salt.utils.data.is_true(kwargs.get('refresh')):\n        log.warning(\"'refresh' argument not implemented for solarispkg module\")\n    pkgs = kwargs.pop('pkgs', None)\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    if not sources:\n        log.error('\"sources\" param required for solaris pkg_add installs')\n        return {}\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            adminfile = _write_adminfile(kwargs)\n        old = list_pkgs()\n        cmd_prefix = ['/usr/sbin/pkgadd', '-n', '-a', adminfile]\n        if kwargs.get('current_zone_only') in (True, 'True'):\n            cmd_prefix.append('-G ')\n        errors = []\n        for pkg in pkg_params:\n            cmd = cmd_prefix + ['-d', pkg, 'all']\n            out = __salt__['cmd.run_all'](cmd, output_loglevel='trace', python_shell=False)\n            if out['retcode'] != 0 and out['stderr']:\n                errors.append(out['stderr'])\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n        if errors:\n            raise CommandExecutionError('Problem encountered installing package(s)', info={'errors': errors, 'changes': ret})\n    finally:\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n    return ret",
            "def install(name=None, sources=None, saltenv='base', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Install the passed package. Can install packages from the following\\n    sources:\\n\\n    * Locally (package already exists on the minion\\n    * HTTP/HTTPS server\\n    * FTP server\\n    * Salt master\\n\\n    Returns a dict containing the new package names and versions:\\n\\n    .. code-block:: python\\n\\n        {\\'<package>\\': {\\'old\\': \\'<old-version>\\',\\n                       \\'new\\': \\'<new-version>\\'}}\\n\\n    CLI Examples:\\n\\n    .. code-block:: bash\\n\\n        # Installing a data stream pkg that already exists on the minion\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"/dir/on/minion/<pkg filename>\"}]\\'\\n        salt \\'*\\' pkg.install sources=\\'[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\'\\n\\n        # Installing a data stream pkg that exists on the salt master\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\'\\n        salt \\'*\\' pkg.install sources=\\'[{\"SMClgcc346\": \"salt://pkgs/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\'\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Installing a data stream pkg that exists on a HTTP server\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"http://packages.server.com/<pkg filename>\"}]\\'\\n        salt \\'*\\' pkg.install sources=\\'[{\"SMClgcc346\": \"http://packages.server.com/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\'\\n\\n    If working with solaris zones and you want to install a package only in the\\n    global zone you can pass \\'current_zone_only=True\\' to salt to have the\\n    package only installed in the global zone. (Behind the scenes this is\\n    passing \\'-G\\' to the pkgadd command.) Solaris default when installing a\\n    package in the global zone is to install it in all zones. This overrides\\n    that and installs the package only in the global.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Installing a data stream package only in the global zone:\\n        salt \\'global_zone\\' pkg.install sources=\\'[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]\\' current_zone_only=True\\n\\n    By default salt automatically provides an adminfile, to automate package\\n    installation, with these options set::\\n\\n        email=\\n        instance=quit\\n        partial=nocheck\\n        runlevel=nocheck\\n        idepend=nocheck\\n        rdepend=nocheck\\n        space=nocheck\\n        setuid=nocheck\\n        conflict=nocheck\\n        action=nocheck\\n        basedir=default\\n\\n    You can override any of these options in two ways. First you can optionally\\n    pass any of the options as a kwarg to the module/state to override the\\n    default value or you can optionally pass the \\'admin_source\\' option\\n    providing your own adminfile to the minions.\\n\\n    Note: You can find all of the possible options to provide to the adminfile\\n    by reading the admin man page:\\n\\n    .. code-block:: bash\\n\\n        man -s 4 admin\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Overriding the \\'instance\\' adminfile option when calling the module directly\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\' instance=\"overwrite\"\\n\\n    SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        # Overriding the \\'instance\\' adminfile option when used in a state\\n\\n        SMClgcc346:\\n          pkg.installed:\\n            - sources:\\n              - SMClgcc346: salt://srv/salt/pkgs/gcc-3.4.6-sol10-sparc-local.pkg\\n            - instance: overwrite\\n\\n    .. note::\\n        The ID declaration is ignored, as the package name is read from the\\n        ``sources`` parameter.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        # Providing your own adminfile when calling the module directly\\n\\n        salt \\'*\\' pkg.install sources=\\'[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]\\' admin_source=\\'salt://pkgs/<adminfile filename>\\'\\n\\n        # Providing your own adminfile when using states\\n\\n        <pkg name>:\\n          pkg.installed:\\n            - sources:\\n              - <pkg name>: salt://pkgs/<pkg filename>\\n            - admin_source: salt://pkgs/<adminfile filename>\\n\\n    .. note::\\n        The ID declaration is ignored, as the package name is read from the\\n        ``sources`` parameter.\\n    '\n    if salt.utils.data.is_true(kwargs.get('refresh')):\n        log.warning(\"'refresh' argument not implemented for solarispkg module\")\n    pkgs = kwargs.pop('pkgs', None)\n    try:\n        (pkg_params, pkg_type) = __salt__['pkg_resource.parse_targets'](name, pkgs, sources, **kwargs)\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    if not pkg_params:\n        return {}\n    if not sources:\n        log.error('\"sources\" param required for solaris pkg_add installs')\n        return {}\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            adminfile = _write_adminfile(kwargs)\n        old = list_pkgs()\n        cmd_prefix = ['/usr/sbin/pkgadd', '-n', '-a', adminfile]\n        if kwargs.get('current_zone_only') in (True, 'True'):\n            cmd_prefix.append('-G ')\n        errors = []\n        for pkg in pkg_params:\n            cmd = cmd_prefix + ['-d', pkg, 'all']\n            out = __salt__['cmd.run_all'](cmd, output_loglevel='trace', python_shell=False)\n            if out['retcode'] != 0 and out['stderr']:\n                errors.append(out['stderr'])\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n        if errors:\n            raise CommandExecutionError('Problem encountered installing package(s)', info={'errors': errors, 'changes': ret})\n    finally:\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n    return ret"
        ]
    },
    {
        "func_name": "remove",
        "original": "def remove(name=None, pkgs=None, saltenv='base', **kwargs):\n    \"\"\"\n    Remove packages with pkgrm\n\n    name\n        The name of the package to be deleted\n\n    By default salt automatically provides an adminfile, to automate package\n    removal, with these options set::\n\n        email=\n        instance=quit\n        partial=nocheck\n        runlevel=nocheck\n        idepend=nocheck\n        rdepend=nocheck\n        space=nocheck\n        setuid=nocheck\n        conflict=nocheck\n        action=nocheck\n        basedir=default\n\n    You can override any of these options in two ways. First you can optionally\n    pass any of the options as a kwarg to the module/state to override the\n    default value or you can optionally pass the 'admin_source' option\n    providing your own adminfile to the minions.\n\n    Note: You can find all of the possible options to provide to the adminfile\n    by reading the admin man page:\n\n    .. code-block:: bash\n\n        man -s 4 admin\n\n\n    Multiple Package Options:\n\n    pkgs\n        A list of packages to delete. Must be passed as a python list. The\n        ``name`` parameter will be ignored if this option is passed.\n\n    .. versionadded:: 0.16.0\n\n\n    Returns a dict containing the changes.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.remove <package name>\n        salt '*' pkg.remove SUNWgit\n        salt '*' pkg.remove <package1>,<package2>,<package3>\n        salt '*' pkg.remove pkgs='[\"foo\", \"bar\"]'\n    \"\"\"\n    try:\n        pkg_params = __salt__['pkg_resource.parse_targets'](name, pkgs)[0]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = [x for x in pkg_params if x in old]\n    if not targets:\n        return {}\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            adminfile = _write_adminfile(kwargs)\n        cmd = ['/usr/sbin/pkgrm', '-n', '-a', adminfile] + targets\n        out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n        if out['retcode'] != 0 and out['stderr']:\n            errors = [out['stderr']]\n        else:\n            errors = []\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n        if errors:\n            raise CommandExecutionError('Problem encountered removing package(s)', info={'errors': errors, 'changes': ret})\n    finally:\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n    return ret",
        "mutated": [
            "def remove(name=None, pkgs=None, saltenv='base', **kwargs):\n    if False:\n        i = 10\n    '\\n    Remove packages with pkgrm\\n\\n    name\\n        The name of the package to be deleted\\n\\n    By default salt automatically provides an adminfile, to automate package\\n    removal, with these options set::\\n\\n        email=\\n        instance=quit\\n        partial=nocheck\\n        runlevel=nocheck\\n        idepend=nocheck\\n        rdepend=nocheck\\n        space=nocheck\\n        setuid=nocheck\\n        conflict=nocheck\\n        action=nocheck\\n        basedir=default\\n\\n    You can override any of these options in two ways. First you can optionally\\n    pass any of the options as a kwarg to the module/state to override the\\n    default value or you can optionally pass the \\'admin_source\\' option\\n    providing your own adminfile to the minions.\\n\\n    Note: You can find all of the possible options to provide to the adminfile\\n    by reading the admin man page:\\n\\n    .. code-block:: bash\\n\\n        man -s 4 admin\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.remove <package name>\\n        salt \\'*\\' pkg.remove SUNWgit\\n        salt \\'*\\' pkg.remove <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.remove pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    try:\n        pkg_params = __salt__['pkg_resource.parse_targets'](name, pkgs)[0]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = [x for x in pkg_params if x in old]\n    if not targets:\n        return {}\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            adminfile = _write_adminfile(kwargs)\n        cmd = ['/usr/sbin/pkgrm', '-n', '-a', adminfile] + targets\n        out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n        if out['retcode'] != 0 and out['stderr']:\n            errors = [out['stderr']]\n        else:\n            errors = []\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n        if errors:\n            raise CommandExecutionError('Problem encountered removing package(s)', info={'errors': errors, 'changes': ret})\n    finally:\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n    return ret",
            "def remove(name=None, pkgs=None, saltenv='base', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Remove packages with pkgrm\\n\\n    name\\n        The name of the package to be deleted\\n\\n    By default salt automatically provides an adminfile, to automate package\\n    removal, with these options set::\\n\\n        email=\\n        instance=quit\\n        partial=nocheck\\n        runlevel=nocheck\\n        idepend=nocheck\\n        rdepend=nocheck\\n        space=nocheck\\n        setuid=nocheck\\n        conflict=nocheck\\n        action=nocheck\\n        basedir=default\\n\\n    You can override any of these options in two ways. First you can optionally\\n    pass any of the options as a kwarg to the module/state to override the\\n    default value or you can optionally pass the \\'admin_source\\' option\\n    providing your own adminfile to the minions.\\n\\n    Note: You can find all of the possible options to provide to the adminfile\\n    by reading the admin man page:\\n\\n    .. code-block:: bash\\n\\n        man -s 4 admin\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.remove <package name>\\n        salt \\'*\\' pkg.remove SUNWgit\\n        salt \\'*\\' pkg.remove <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.remove pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    try:\n        pkg_params = __salt__['pkg_resource.parse_targets'](name, pkgs)[0]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = [x for x in pkg_params if x in old]\n    if not targets:\n        return {}\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            adminfile = _write_adminfile(kwargs)\n        cmd = ['/usr/sbin/pkgrm', '-n', '-a', adminfile] + targets\n        out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n        if out['retcode'] != 0 and out['stderr']:\n            errors = [out['stderr']]\n        else:\n            errors = []\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n        if errors:\n            raise CommandExecutionError('Problem encountered removing package(s)', info={'errors': errors, 'changes': ret})\n    finally:\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n    return ret",
            "def remove(name=None, pkgs=None, saltenv='base', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Remove packages with pkgrm\\n\\n    name\\n        The name of the package to be deleted\\n\\n    By default salt automatically provides an adminfile, to automate package\\n    removal, with these options set::\\n\\n        email=\\n        instance=quit\\n        partial=nocheck\\n        runlevel=nocheck\\n        idepend=nocheck\\n        rdepend=nocheck\\n        space=nocheck\\n        setuid=nocheck\\n        conflict=nocheck\\n        action=nocheck\\n        basedir=default\\n\\n    You can override any of these options in two ways. First you can optionally\\n    pass any of the options as a kwarg to the module/state to override the\\n    default value or you can optionally pass the \\'admin_source\\' option\\n    providing your own adminfile to the minions.\\n\\n    Note: You can find all of the possible options to provide to the adminfile\\n    by reading the admin man page:\\n\\n    .. code-block:: bash\\n\\n        man -s 4 admin\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.remove <package name>\\n        salt \\'*\\' pkg.remove SUNWgit\\n        salt \\'*\\' pkg.remove <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.remove pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    try:\n        pkg_params = __salt__['pkg_resource.parse_targets'](name, pkgs)[0]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = [x for x in pkg_params if x in old]\n    if not targets:\n        return {}\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            adminfile = _write_adminfile(kwargs)\n        cmd = ['/usr/sbin/pkgrm', '-n', '-a', adminfile] + targets\n        out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n        if out['retcode'] != 0 and out['stderr']:\n            errors = [out['stderr']]\n        else:\n            errors = []\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n        if errors:\n            raise CommandExecutionError('Problem encountered removing package(s)', info={'errors': errors, 'changes': ret})\n    finally:\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n    return ret",
            "def remove(name=None, pkgs=None, saltenv='base', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Remove packages with pkgrm\\n\\n    name\\n        The name of the package to be deleted\\n\\n    By default salt automatically provides an adminfile, to automate package\\n    removal, with these options set::\\n\\n        email=\\n        instance=quit\\n        partial=nocheck\\n        runlevel=nocheck\\n        idepend=nocheck\\n        rdepend=nocheck\\n        space=nocheck\\n        setuid=nocheck\\n        conflict=nocheck\\n        action=nocheck\\n        basedir=default\\n\\n    You can override any of these options in two ways. First you can optionally\\n    pass any of the options as a kwarg to the module/state to override the\\n    default value or you can optionally pass the \\'admin_source\\' option\\n    providing your own adminfile to the minions.\\n\\n    Note: You can find all of the possible options to provide to the adminfile\\n    by reading the admin man page:\\n\\n    .. code-block:: bash\\n\\n        man -s 4 admin\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.remove <package name>\\n        salt \\'*\\' pkg.remove SUNWgit\\n        salt \\'*\\' pkg.remove <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.remove pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    try:\n        pkg_params = __salt__['pkg_resource.parse_targets'](name, pkgs)[0]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = [x for x in pkg_params if x in old]\n    if not targets:\n        return {}\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            adminfile = _write_adminfile(kwargs)\n        cmd = ['/usr/sbin/pkgrm', '-n', '-a', adminfile] + targets\n        out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n        if out['retcode'] != 0 and out['stderr']:\n            errors = [out['stderr']]\n        else:\n            errors = []\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n        if errors:\n            raise CommandExecutionError('Problem encountered removing package(s)', info={'errors': errors, 'changes': ret})\n    finally:\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n    return ret",
            "def remove(name=None, pkgs=None, saltenv='base', **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Remove packages with pkgrm\\n\\n    name\\n        The name of the package to be deleted\\n\\n    By default salt automatically provides an adminfile, to automate package\\n    removal, with these options set::\\n\\n        email=\\n        instance=quit\\n        partial=nocheck\\n        runlevel=nocheck\\n        idepend=nocheck\\n        rdepend=nocheck\\n        space=nocheck\\n        setuid=nocheck\\n        conflict=nocheck\\n        action=nocheck\\n        basedir=default\\n\\n    You can override any of these options in two ways. First you can optionally\\n    pass any of the options as a kwarg to the module/state to override the\\n    default value or you can optionally pass the \\'admin_source\\' option\\n    providing your own adminfile to the minions.\\n\\n    Note: You can find all of the possible options to provide to the adminfile\\n    by reading the admin man page:\\n\\n    .. code-block:: bash\\n\\n        man -s 4 admin\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.remove <package name>\\n        salt \\'*\\' pkg.remove SUNWgit\\n        salt \\'*\\' pkg.remove <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.remove pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    try:\n        pkg_params = __salt__['pkg_resource.parse_targets'](name, pkgs)[0]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n    old = list_pkgs()\n    targets = [x for x in pkg_params if x in old]\n    if not targets:\n        return {}\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            adminfile = _write_adminfile(kwargs)\n        cmd = ['/usr/sbin/pkgrm', '-n', '-a', adminfile] + targets\n        out = __salt__['cmd.run_all'](cmd, python_shell=False, output_loglevel='trace')\n        if out['retcode'] != 0 and out['stderr']:\n            errors = [out['stderr']]\n        else:\n            errors = []\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n        if errors:\n            raise CommandExecutionError('Problem encountered removing package(s)', info={'errors': errors, 'changes': ret})\n    finally:\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n    return ret"
        ]
    },
    {
        "func_name": "purge",
        "original": "def purge(name=None, pkgs=None, **kwargs):\n    \"\"\"\n    Package purges are not supported, this function is identical to\n    ``remove()``.\n\n    name\n        The name of the package to be deleted\n\n\n    Multiple Package Options:\n\n    pkgs\n        A list of packages to delete. Must be passed as a python list. The\n        ``name`` parameter will be ignored if this option is passed.\n\n    .. versionadded:: 0.16.0\n\n\n    Returns a dict containing the changes.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.purge <package name>\n        salt '*' pkg.purge <package1>,<package2>,<package3>\n        salt '*' pkg.purge pkgs='[\"foo\", \"bar\"]'\n    \"\"\"\n    return remove(name=name, pkgs=pkgs, **kwargs)",
        "mutated": [
            "def purge(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n    '\\n    Package purges are not supported, this function is identical to\\n    ``remove()``.\\n\\n    name\\n        The name of the package to be deleted\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.purge <package name>\\n        salt \\'*\\' pkg.purge <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.purge pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    return remove(name=name, pkgs=pkgs, **kwargs)",
            "def purge(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Package purges are not supported, this function is identical to\\n    ``remove()``.\\n\\n    name\\n        The name of the package to be deleted\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.purge <package name>\\n        salt \\'*\\' pkg.purge <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.purge pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    return remove(name=name, pkgs=pkgs, **kwargs)",
            "def purge(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Package purges are not supported, this function is identical to\\n    ``remove()``.\\n\\n    name\\n        The name of the package to be deleted\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.purge <package name>\\n        salt \\'*\\' pkg.purge <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.purge pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    return remove(name=name, pkgs=pkgs, **kwargs)",
            "def purge(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Package purges are not supported, this function is identical to\\n    ``remove()``.\\n\\n    name\\n        The name of the package to be deleted\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.purge <package name>\\n        salt \\'*\\' pkg.purge <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.purge pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    return remove(name=name, pkgs=pkgs, **kwargs)",
            "def purge(name=None, pkgs=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Package purges are not supported, this function is identical to\\n    ``remove()``.\\n\\n    name\\n        The name of the package to be deleted\\n\\n\\n    Multiple Package Options:\\n\\n    pkgs\\n        A list of packages to delete. Must be passed as a python list. The\\n        ``name`` parameter will be ignored if this option is passed.\\n\\n    .. versionadded:: 0.16.0\\n\\n\\n    Returns a dict containing the changes.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' pkg.purge <package name>\\n        salt \\'*\\' pkg.purge <package1>,<package2>,<package3>\\n        salt \\'*\\' pkg.purge pkgs=\\'[\"foo\", \"bar\"]\\'\\n    '\n    return remove(name=name, pkgs=pkgs, **kwargs)"
        ]
    }
]