[
    {
        "func_name": "_extract_subtitles",
        "original": "@staticmethod\ndef _extract_subtitles(data_captions):\n    subtitles = {}\n    for f in traverse_obj(data_captions, ('files', lambda _, v: url_or_none(v['file']))):\n        subtitles.setdefault(f.get('label') or 'fra', []).append({'url': f['file']})\n    return subtitles",
        "mutated": [
            "@staticmethod\ndef _extract_subtitles(data_captions):\n    if False:\n        i = 10\n    subtitles = {}\n    for f in traverse_obj(data_captions, ('files', lambda _, v: url_or_none(v['file']))):\n        subtitles.setdefault(f.get('label') or 'fra', []).append({'url': f['file']})\n    return subtitles",
            "@staticmethod\ndef _extract_subtitles(data_captions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    subtitles = {}\n    for f in traverse_obj(data_captions, ('files', lambda _, v: url_or_none(v['file']))):\n        subtitles.setdefault(f.get('label') or 'fra', []).append({'url': f['file']})\n    return subtitles",
            "@staticmethod\ndef _extract_subtitles(data_captions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    subtitles = {}\n    for f in traverse_obj(data_captions, ('files', lambda _, v: url_or_none(v['file']))):\n        subtitles.setdefault(f.get('label') or 'fra', []).append({'url': f['file']})\n    return subtitles",
            "@staticmethod\ndef _extract_subtitles(data_captions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    subtitles = {}\n    for f in traverse_obj(data_captions, ('files', lambda _, v: url_or_none(v['file']))):\n        subtitles.setdefault(f.get('label') or 'fra', []).append({'url': f['file']})\n    return subtitles",
            "@staticmethod\ndef _extract_subtitles(data_captions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    subtitles = {}\n    for f in traverse_obj(data_captions, ('files', lambda _, v: url_or_none(v['file']))):\n        subtitles.setdefault(f.get('label') or 'fra', []).append({'url': f['file']})\n    return subtitles"
        ]
    },
    {
        "func_name": "process_video_files",
        "original": "def process_video_files(v):\n    nonlocal video_id\n    for video_file in v:\n        v_url = video_file.get('url')\n        if not v_url:\n            continue\n        if video_file.get('type') == 'application/deferred':\n            d_param = urllib.parse.quote(v_url)\n            token = video_file.get('token')\n            if not token:\n                continue\n            deferred_json = self._download_json(f'https://api.tv5monde.com/player/asset/{d_param}/resolve?condenseKS=true', display_id, note='Downloading deferred info', headers={'Authorization': f'Bearer {token}'}, fatal=False)\n            v_url = traverse_obj(deferred_json, (0, 'url', {url_or_none}))\n            if not v_url:\n                continue\n            video_id = self._search_regex('materials/([\\\\da-zA-Z]{10}_[\\\\da-fA-F]{7})/', v_url, 'video id', default=None)\n            process_video_files(deferred_json)\n        video_format = video_file.get('format') or determine_ext(v_url)\n        if video_format == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(v_url, display_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n        elif video_format == 'mpd':\n            formats.extend(self._extract_mpd_formats(v_url, display_id, fatal=False))\n        else:\n            formats.append({'url': v_url, 'format_id': video_format})",
        "mutated": [
            "def process_video_files(v):\n    if False:\n        i = 10\n    nonlocal video_id\n    for video_file in v:\n        v_url = video_file.get('url')\n        if not v_url:\n            continue\n        if video_file.get('type') == 'application/deferred':\n            d_param = urllib.parse.quote(v_url)\n            token = video_file.get('token')\n            if not token:\n                continue\n            deferred_json = self._download_json(f'https://api.tv5monde.com/player/asset/{d_param}/resolve?condenseKS=true', display_id, note='Downloading deferred info', headers={'Authorization': f'Bearer {token}'}, fatal=False)\n            v_url = traverse_obj(deferred_json, (0, 'url', {url_or_none}))\n            if not v_url:\n                continue\n            video_id = self._search_regex('materials/([\\\\da-zA-Z]{10}_[\\\\da-fA-F]{7})/', v_url, 'video id', default=None)\n            process_video_files(deferred_json)\n        video_format = video_file.get('format') or determine_ext(v_url)\n        if video_format == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(v_url, display_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n        elif video_format == 'mpd':\n            formats.extend(self._extract_mpd_formats(v_url, display_id, fatal=False))\n        else:\n            formats.append({'url': v_url, 'format_id': video_format})",
            "def process_video_files(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nonlocal video_id\n    for video_file in v:\n        v_url = video_file.get('url')\n        if not v_url:\n            continue\n        if video_file.get('type') == 'application/deferred':\n            d_param = urllib.parse.quote(v_url)\n            token = video_file.get('token')\n            if not token:\n                continue\n            deferred_json = self._download_json(f'https://api.tv5monde.com/player/asset/{d_param}/resolve?condenseKS=true', display_id, note='Downloading deferred info', headers={'Authorization': f'Bearer {token}'}, fatal=False)\n            v_url = traverse_obj(deferred_json, (0, 'url', {url_or_none}))\n            if not v_url:\n                continue\n            video_id = self._search_regex('materials/([\\\\da-zA-Z]{10}_[\\\\da-fA-F]{7})/', v_url, 'video id', default=None)\n            process_video_files(deferred_json)\n        video_format = video_file.get('format') or determine_ext(v_url)\n        if video_format == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(v_url, display_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n        elif video_format == 'mpd':\n            formats.extend(self._extract_mpd_formats(v_url, display_id, fatal=False))\n        else:\n            formats.append({'url': v_url, 'format_id': video_format})",
            "def process_video_files(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nonlocal video_id\n    for video_file in v:\n        v_url = video_file.get('url')\n        if not v_url:\n            continue\n        if video_file.get('type') == 'application/deferred':\n            d_param = urllib.parse.quote(v_url)\n            token = video_file.get('token')\n            if not token:\n                continue\n            deferred_json = self._download_json(f'https://api.tv5monde.com/player/asset/{d_param}/resolve?condenseKS=true', display_id, note='Downloading deferred info', headers={'Authorization': f'Bearer {token}'}, fatal=False)\n            v_url = traverse_obj(deferred_json, (0, 'url', {url_or_none}))\n            if not v_url:\n                continue\n            video_id = self._search_regex('materials/([\\\\da-zA-Z]{10}_[\\\\da-fA-F]{7})/', v_url, 'video id', default=None)\n            process_video_files(deferred_json)\n        video_format = video_file.get('format') or determine_ext(v_url)\n        if video_format == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(v_url, display_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n        elif video_format == 'mpd':\n            formats.extend(self._extract_mpd_formats(v_url, display_id, fatal=False))\n        else:\n            formats.append({'url': v_url, 'format_id': video_format})",
            "def process_video_files(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nonlocal video_id\n    for video_file in v:\n        v_url = video_file.get('url')\n        if not v_url:\n            continue\n        if video_file.get('type') == 'application/deferred':\n            d_param = urllib.parse.quote(v_url)\n            token = video_file.get('token')\n            if not token:\n                continue\n            deferred_json = self._download_json(f'https://api.tv5monde.com/player/asset/{d_param}/resolve?condenseKS=true', display_id, note='Downloading deferred info', headers={'Authorization': f'Bearer {token}'}, fatal=False)\n            v_url = traverse_obj(deferred_json, (0, 'url', {url_or_none}))\n            if not v_url:\n                continue\n            video_id = self._search_regex('materials/([\\\\da-zA-Z]{10}_[\\\\da-fA-F]{7})/', v_url, 'video id', default=None)\n            process_video_files(deferred_json)\n        video_format = video_file.get('format') or determine_ext(v_url)\n        if video_format == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(v_url, display_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n        elif video_format == 'mpd':\n            formats.extend(self._extract_mpd_formats(v_url, display_id, fatal=False))\n        else:\n            formats.append({'url': v_url, 'format_id': video_format})",
            "def process_video_files(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nonlocal video_id\n    for video_file in v:\n        v_url = video_file.get('url')\n        if not v_url:\n            continue\n        if video_file.get('type') == 'application/deferred':\n            d_param = urllib.parse.quote(v_url)\n            token = video_file.get('token')\n            if not token:\n                continue\n            deferred_json = self._download_json(f'https://api.tv5monde.com/player/asset/{d_param}/resolve?condenseKS=true', display_id, note='Downloading deferred info', headers={'Authorization': f'Bearer {token}'}, fatal=False)\n            v_url = traverse_obj(deferred_json, (0, 'url', {url_or_none}))\n            if not v_url:\n                continue\n            video_id = self._search_regex('materials/([\\\\da-zA-Z]{10}_[\\\\da-fA-F]{7})/', v_url, 'video id', default=None)\n            process_video_files(deferred_json)\n        video_format = video_file.get('format') or determine_ext(v_url)\n        if video_format == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(v_url, display_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n        elif video_format == 'mpd':\n            formats.extend(self._extract_mpd_formats(v_url, display_id, fatal=False))\n        else:\n            formats.append({'url': v_url, 'format_id': video_format})"
        ]
    },
    {
        "func_name": "_real_extract",
        "original": "def _real_extract(self, url):\n    display_id = self._match_id(url)\n    webpage = self._download_webpage(url, display_id)\n    if \">Ce programme n'est malheureusement pas disponible pour votre zone g\u00e9ographique.<\" in webpage:\n        self.raise_geo_restricted(countries=['FR'])\n    title = episode = self._html_search_regex('<h1>([^<]+)', webpage, 'title')\n    vpl_data = extract_attributes(self._search_regex('(<[^>]+class=\"video_player_loader\"[^>]+>)', webpage, 'video player loader'))\n    video_files = self._parse_json(vpl_data['data-broadcast'], display_id)\n    formats = []\n    video_id = None\n\n    def process_video_files(v):\n        nonlocal video_id\n        for video_file in v:\n            v_url = video_file.get('url')\n            if not v_url:\n                continue\n            if video_file.get('type') == 'application/deferred':\n                d_param = urllib.parse.quote(v_url)\n                token = video_file.get('token')\n                if not token:\n                    continue\n                deferred_json = self._download_json(f'https://api.tv5monde.com/player/asset/{d_param}/resolve?condenseKS=true', display_id, note='Downloading deferred info', headers={'Authorization': f'Bearer {token}'}, fatal=False)\n                v_url = traverse_obj(deferred_json, (0, 'url', {url_or_none}))\n                if not v_url:\n                    continue\n                video_id = self._search_regex('materials/([\\\\da-zA-Z]{10}_[\\\\da-fA-F]{7})/', v_url, 'video id', default=None)\n                process_video_files(deferred_json)\n            video_format = video_file.get('format') or determine_ext(v_url)\n            if video_format == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(v_url, display_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n            elif video_format == 'mpd':\n                formats.extend(self._extract_mpd_formats(v_url, display_id, fatal=False))\n            else:\n                formats.append({'url': v_url, 'format_id': video_format})\n    process_video_files(video_files)\n    metadata = self._parse_json(vpl_data['data-metadata'], display_id)\n    duration = int_or_none(try_get(metadata, lambda x: x['content']['duration'])) or parse_duration(self._html_search_meta('duration', webpage))\n    description = self._html_search_regex('(?s)<div[^>]+class=[\"\\\\\\']episode-texte[^>]+>(.+?)</div>', webpage, 'description', fatal=False)\n    series = self._html_search_regex('<p[^>]+class=[\"\\\\\\']episode-emission[^>]+>([^<]+)', webpage, 'series', default=None)\n    if series and series != title:\n        title = '%s - %s' % (series, title)\n    upload_date = self._search_regex('(?:date_publication|publish_date)[\"\\\\\\']\\\\s*:\\\\s*[\"\\\\\\'](\\\\d{4}_\\\\d{2}_\\\\d{2})', webpage, 'upload date', default=None)\n    if upload_date:\n        upload_date = upload_date.replace('_', '')\n    if not video_id:\n        video_id = self._search_regex(('data-guid=[\"\\\\\\']([\\\\da-f]{8}-[\\\\da-f]{4}-[\\\\da-f]{4}-[\\\\da-f]{4}-[\\\\da-f]{12})', 'id_contenu[\"\\\\\\']\\\\s:\\\\s*(\\\\d+)'), webpage, 'video id', default=display_id)\n    return {'id': video_id, 'display_id': display_id, 'title': title, 'description': description, 'thumbnail': vpl_data.get('data-image'), 'duration': duration, 'upload_date': upload_date, 'formats': formats, 'subtitles': self._extract_subtitles(self._parse_json(traverse_obj(vpl_data, ('data-captions', {str}), default='{}'), display_id, fatal=False)), 'series': series, 'episode': episode}",
        "mutated": [
            "def _real_extract(self, url):\n    if False:\n        i = 10\n    display_id = self._match_id(url)\n    webpage = self._download_webpage(url, display_id)\n    if \">Ce programme n'est malheureusement pas disponible pour votre zone g\u00e9ographique.<\" in webpage:\n        self.raise_geo_restricted(countries=['FR'])\n    title = episode = self._html_search_regex('<h1>([^<]+)', webpage, 'title')\n    vpl_data = extract_attributes(self._search_regex('(<[^>]+class=\"video_player_loader\"[^>]+>)', webpage, 'video player loader'))\n    video_files = self._parse_json(vpl_data['data-broadcast'], display_id)\n    formats = []\n    video_id = None\n\n    def process_video_files(v):\n        nonlocal video_id\n        for video_file in v:\n            v_url = video_file.get('url')\n            if not v_url:\n                continue\n            if video_file.get('type') == 'application/deferred':\n                d_param = urllib.parse.quote(v_url)\n                token = video_file.get('token')\n                if not token:\n                    continue\n                deferred_json = self._download_json(f'https://api.tv5monde.com/player/asset/{d_param}/resolve?condenseKS=true', display_id, note='Downloading deferred info', headers={'Authorization': f'Bearer {token}'}, fatal=False)\n                v_url = traverse_obj(deferred_json, (0, 'url', {url_or_none}))\n                if not v_url:\n                    continue\n                video_id = self._search_regex('materials/([\\\\da-zA-Z]{10}_[\\\\da-fA-F]{7})/', v_url, 'video id', default=None)\n                process_video_files(deferred_json)\n            video_format = video_file.get('format') or determine_ext(v_url)\n            if video_format == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(v_url, display_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n            elif video_format == 'mpd':\n                formats.extend(self._extract_mpd_formats(v_url, display_id, fatal=False))\n            else:\n                formats.append({'url': v_url, 'format_id': video_format})\n    process_video_files(video_files)\n    metadata = self._parse_json(vpl_data['data-metadata'], display_id)\n    duration = int_or_none(try_get(metadata, lambda x: x['content']['duration'])) or parse_duration(self._html_search_meta('duration', webpage))\n    description = self._html_search_regex('(?s)<div[^>]+class=[\"\\\\\\']episode-texte[^>]+>(.+?)</div>', webpage, 'description', fatal=False)\n    series = self._html_search_regex('<p[^>]+class=[\"\\\\\\']episode-emission[^>]+>([^<]+)', webpage, 'series', default=None)\n    if series and series != title:\n        title = '%s - %s' % (series, title)\n    upload_date = self._search_regex('(?:date_publication|publish_date)[\"\\\\\\']\\\\s*:\\\\s*[\"\\\\\\'](\\\\d{4}_\\\\d{2}_\\\\d{2})', webpage, 'upload date', default=None)\n    if upload_date:\n        upload_date = upload_date.replace('_', '')\n    if not video_id:\n        video_id = self._search_regex(('data-guid=[\"\\\\\\']([\\\\da-f]{8}-[\\\\da-f]{4}-[\\\\da-f]{4}-[\\\\da-f]{4}-[\\\\da-f]{12})', 'id_contenu[\"\\\\\\']\\\\s:\\\\s*(\\\\d+)'), webpage, 'video id', default=display_id)\n    return {'id': video_id, 'display_id': display_id, 'title': title, 'description': description, 'thumbnail': vpl_data.get('data-image'), 'duration': duration, 'upload_date': upload_date, 'formats': formats, 'subtitles': self._extract_subtitles(self._parse_json(traverse_obj(vpl_data, ('data-captions', {str}), default='{}'), display_id, fatal=False)), 'series': series, 'episode': episode}",
            "def _real_extract(self, url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    display_id = self._match_id(url)\n    webpage = self._download_webpage(url, display_id)\n    if \">Ce programme n'est malheureusement pas disponible pour votre zone g\u00e9ographique.<\" in webpage:\n        self.raise_geo_restricted(countries=['FR'])\n    title = episode = self._html_search_regex('<h1>([^<]+)', webpage, 'title')\n    vpl_data = extract_attributes(self._search_regex('(<[^>]+class=\"video_player_loader\"[^>]+>)', webpage, 'video player loader'))\n    video_files = self._parse_json(vpl_data['data-broadcast'], display_id)\n    formats = []\n    video_id = None\n\n    def process_video_files(v):\n        nonlocal video_id\n        for video_file in v:\n            v_url = video_file.get('url')\n            if not v_url:\n                continue\n            if video_file.get('type') == 'application/deferred':\n                d_param = urllib.parse.quote(v_url)\n                token = video_file.get('token')\n                if not token:\n                    continue\n                deferred_json = self._download_json(f'https://api.tv5monde.com/player/asset/{d_param}/resolve?condenseKS=true', display_id, note='Downloading deferred info', headers={'Authorization': f'Bearer {token}'}, fatal=False)\n                v_url = traverse_obj(deferred_json, (0, 'url', {url_or_none}))\n                if not v_url:\n                    continue\n                video_id = self._search_regex('materials/([\\\\da-zA-Z]{10}_[\\\\da-fA-F]{7})/', v_url, 'video id', default=None)\n                process_video_files(deferred_json)\n            video_format = video_file.get('format') or determine_ext(v_url)\n            if video_format == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(v_url, display_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n            elif video_format == 'mpd':\n                formats.extend(self._extract_mpd_formats(v_url, display_id, fatal=False))\n            else:\n                formats.append({'url': v_url, 'format_id': video_format})\n    process_video_files(video_files)\n    metadata = self._parse_json(vpl_data['data-metadata'], display_id)\n    duration = int_or_none(try_get(metadata, lambda x: x['content']['duration'])) or parse_duration(self._html_search_meta('duration', webpage))\n    description = self._html_search_regex('(?s)<div[^>]+class=[\"\\\\\\']episode-texte[^>]+>(.+?)</div>', webpage, 'description', fatal=False)\n    series = self._html_search_regex('<p[^>]+class=[\"\\\\\\']episode-emission[^>]+>([^<]+)', webpage, 'series', default=None)\n    if series and series != title:\n        title = '%s - %s' % (series, title)\n    upload_date = self._search_regex('(?:date_publication|publish_date)[\"\\\\\\']\\\\s*:\\\\s*[\"\\\\\\'](\\\\d{4}_\\\\d{2}_\\\\d{2})', webpage, 'upload date', default=None)\n    if upload_date:\n        upload_date = upload_date.replace('_', '')\n    if not video_id:\n        video_id = self._search_regex(('data-guid=[\"\\\\\\']([\\\\da-f]{8}-[\\\\da-f]{4}-[\\\\da-f]{4}-[\\\\da-f]{4}-[\\\\da-f]{12})', 'id_contenu[\"\\\\\\']\\\\s:\\\\s*(\\\\d+)'), webpage, 'video id', default=display_id)\n    return {'id': video_id, 'display_id': display_id, 'title': title, 'description': description, 'thumbnail': vpl_data.get('data-image'), 'duration': duration, 'upload_date': upload_date, 'formats': formats, 'subtitles': self._extract_subtitles(self._parse_json(traverse_obj(vpl_data, ('data-captions', {str}), default='{}'), display_id, fatal=False)), 'series': series, 'episode': episode}",
            "def _real_extract(self, url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    display_id = self._match_id(url)\n    webpage = self._download_webpage(url, display_id)\n    if \">Ce programme n'est malheureusement pas disponible pour votre zone g\u00e9ographique.<\" in webpage:\n        self.raise_geo_restricted(countries=['FR'])\n    title = episode = self._html_search_regex('<h1>([^<]+)', webpage, 'title')\n    vpl_data = extract_attributes(self._search_regex('(<[^>]+class=\"video_player_loader\"[^>]+>)', webpage, 'video player loader'))\n    video_files = self._parse_json(vpl_data['data-broadcast'], display_id)\n    formats = []\n    video_id = None\n\n    def process_video_files(v):\n        nonlocal video_id\n        for video_file in v:\n            v_url = video_file.get('url')\n            if not v_url:\n                continue\n            if video_file.get('type') == 'application/deferred':\n                d_param = urllib.parse.quote(v_url)\n                token = video_file.get('token')\n                if not token:\n                    continue\n                deferred_json = self._download_json(f'https://api.tv5monde.com/player/asset/{d_param}/resolve?condenseKS=true', display_id, note='Downloading deferred info', headers={'Authorization': f'Bearer {token}'}, fatal=False)\n                v_url = traverse_obj(deferred_json, (0, 'url', {url_or_none}))\n                if not v_url:\n                    continue\n                video_id = self._search_regex('materials/([\\\\da-zA-Z]{10}_[\\\\da-fA-F]{7})/', v_url, 'video id', default=None)\n                process_video_files(deferred_json)\n            video_format = video_file.get('format') or determine_ext(v_url)\n            if video_format == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(v_url, display_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n            elif video_format == 'mpd':\n                formats.extend(self._extract_mpd_formats(v_url, display_id, fatal=False))\n            else:\n                formats.append({'url': v_url, 'format_id': video_format})\n    process_video_files(video_files)\n    metadata = self._parse_json(vpl_data['data-metadata'], display_id)\n    duration = int_or_none(try_get(metadata, lambda x: x['content']['duration'])) or parse_duration(self._html_search_meta('duration', webpage))\n    description = self._html_search_regex('(?s)<div[^>]+class=[\"\\\\\\']episode-texte[^>]+>(.+?)</div>', webpage, 'description', fatal=False)\n    series = self._html_search_regex('<p[^>]+class=[\"\\\\\\']episode-emission[^>]+>([^<]+)', webpage, 'series', default=None)\n    if series and series != title:\n        title = '%s - %s' % (series, title)\n    upload_date = self._search_regex('(?:date_publication|publish_date)[\"\\\\\\']\\\\s*:\\\\s*[\"\\\\\\'](\\\\d{4}_\\\\d{2}_\\\\d{2})', webpage, 'upload date', default=None)\n    if upload_date:\n        upload_date = upload_date.replace('_', '')\n    if not video_id:\n        video_id = self._search_regex(('data-guid=[\"\\\\\\']([\\\\da-f]{8}-[\\\\da-f]{4}-[\\\\da-f]{4}-[\\\\da-f]{4}-[\\\\da-f]{12})', 'id_contenu[\"\\\\\\']\\\\s:\\\\s*(\\\\d+)'), webpage, 'video id', default=display_id)\n    return {'id': video_id, 'display_id': display_id, 'title': title, 'description': description, 'thumbnail': vpl_data.get('data-image'), 'duration': duration, 'upload_date': upload_date, 'formats': formats, 'subtitles': self._extract_subtitles(self._parse_json(traverse_obj(vpl_data, ('data-captions', {str}), default='{}'), display_id, fatal=False)), 'series': series, 'episode': episode}",
            "def _real_extract(self, url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    display_id = self._match_id(url)\n    webpage = self._download_webpage(url, display_id)\n    if \">Ce programme n'est malheureusement pas disponible pour votre zone g\u00e9ographique.<\" in webpage:\n        self.raise_geo_restricted(countries=['FR'])\n    title = episode = self._html_search_regex('<h1>([^<]+)', webpage, 'title')\n    vpl_data = extract_attributes(self._search_regex('(<[^>]+class=\"video_player_loader\"[^>]+>)', webpage, 'video player loader'))\n    video_files = self._parse_json(vpl_data['data-broadcast'], display_id)\n    formats = []\n    video_id = None\n\n    def process_video_files(v):\n        nonlocal video_id\n        for video_file in v:\n            v_url = video_file.get('url')\n            if not v_url:\n                continue\n            if video_file.get('type') == 'application/deferred':\n                d_param = urllib.parse.quote(v_url)\n                token = video_file.get('token')\n                if not token:\n                    continue\n                deferred_json = self._download_json(f'https://api.tv5monde.com/player/asset/{d_param}/resolve?condenseKS=true', display_id, note='Downloading deferred info', headers={'Authorization': f'Bearer {token}'}, fatal=False)\n                v_url = traverse_obj(deferred_json, (0, 'url', {url_or_none}))\n                if not v_url:\n                    continue\n                video_id = self._search_regex('materials/([\\\\da-zA-Z]{10}_[\\\\da-fA-F]{7})/', v_url, 'video id', default=None)\n                process_video_files(deferred_json)\n            video_format = video_file.get('format') or determine_ext(v_url)\n            if video_format == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(v_url, display_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n            elif video_format == 'mpd':\n                formats.extend(self._extract_mpd_formats(v_url, display_id, fatal=False))\n            else:\n                formats.append({'url': v_url, 'format_id': video_format})\n    process_video_files(video_files)\n    metadata = self._parse_json(vpl_data['data-metadata'], display_id)\n    duration = int_or_none(try_get(metadata, lambda x: x['content']['duration'])) or parse_duration(self._html_search_meta('duration', webpage))\n    description = self._html_search_regex('(?s)<div[^>]+class=[\"\\\\\\']episode-texte[^>]+>(.+?)</div>', webpage, 'description', fatal=False)\n    series = self._html_search_regex('<p[^>]+class=[\"\\\\\\']episode-emission[^>]+>([^<]+)', webpage, 'series', default=None)\n    if series and series != title:\n        title = '%s - %s' % (series, title)\n    upload_date = self._search_regex('(?:date_publication|publish_date)[\"\\\\\\']\\\\s*:\\\\s*[\"\\\\\\'](\\\\d{4}_\\\\d{2}_\\\\d{2})', webpage, 'upload date', default=None)\n    if upload_date:\n        upload_date = upload_date.replace('_', '')\n    if not video_id:\n        video_id = self._search_regex(('data-guid=[\"\\\\\\']([\\\\da-f]{8}-[\\\\da-f]{4}-[\\\\da-f]{4}-[\\\\da-f]{4}-[\\\\da-f]{12})', 'id_contenu[\"\\\\\\']\\\\s:\\\\s*(\\\\d+)'), webpage, 'video id', default=display_id)\n    return {'id': video_id, 'display_id': display_id, 'title': title, 'description': description, 'thumbnail': vpl_data.get('data-image'), 'duration': duration, 'upload_date': upload_date, 'formats': formats, 'subtitles': self._extract_subtitles(self._parse_json(traverse_obj(vpl_data, ('data-captions', {str}), default='{}'), display_id, fatal=False)), 'series': series, 'episode': episode}",
            "def _real_extract(self, url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    display_id = self._match_id(url)\n    webpage = self._download_webpage(url, display_id)\n    if \">Ce programme n'est malheureusement pas disponible pour votre zone g\u00e9ographique.<\" in webpage:\n        self.raise_geo_restricted(countries=['FR'])\n    title = episode = self._html_search_regex('<h1>([^<]+)', webpage, 'title')\n    vpl_data = extract_attributes(self._search_regex('(<[^>]+class=\"video_player_loader\"[^>]+>)', webpage, 'video player loader'))\n    video_files = self._parse_json(vpl_data['data-broadcast'], display_id)\n    formats = []\n    video_id = None\n\n    def process_video_files(v):\n        nonlocal video_id\n        for video_file in v:\n            v_url = video_file.get('url')\n            if not v_url:\n                continue\n            if video_file.get('type') == 'application/deferred':\n                d_param = urllib.parse.quote(v_url)\n                token = video_file.get('token')\n                if not token:\n                    continue\n                deferred_json = self._download_json(f'https://api.tv5monde.com/player/asset/{d_param}/resolve?condenseKS=true', display_id, note='Downloading deferred info', headers={'Authorization': f'Bearer {token}'}, fatal=False)\n                v_url = traverse_obj(deferred_json, (0, 'url', {url_or_none}))\n                if not v_url:\n                    continue\n                video_id = self._search_regex('materials/([\\\\da-zA-Z]{10}_[\\\\da-fA-F]{7})/', v_url, 'video id', default=None)\n                process_video_files(deferred_json)\n            video_format = video_file.get('format') or determine_ext(v_url)\n            if video_format == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(v_url, display_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n            elif video_format == 'mpd':\n                formats.extend(self._extract_mpd_formats(v_url, display_id, fatal=False))\n            else:\n                formats.append({'url': v_url, 'format_id': video_format})\n    process_video_files(video_files)\n    metadata = self._parse_json(vpl_data['data-metadata'], display_id)\n    duration = int_or_none(try_get(metadata, lambda x: x['content']['duration'])) or parse_duration(self._html_search_meta('duration', webpage))\n    description = self._html_search_regex('(?s)<div[^>]+class=[\"\\\\\\']episode-texte[^>]+>(.+?)</div>', webpage, 'description', fatal=False)\n    series = self._html_search_regex('<p[^>]+class=[\"\\\\\\']episode-emission[^>]+>([^<]+)', webpage, 'series', default=None)\n    if series and series != title:\n        title = '%s - %s' % (series, title)\n    upload_date = self._search_regex('(?:date_publication|publish_date)[\"\\\\\\']\\\\s*:\\\\s*[\"\\\\\\'](\\\\d{4}_\\\\d{2}_\\\\d{2})', webpage, 'upload date', default=None)\n    if upload_date:\n        upload_date = upload_date.replace('_', '')\n    if not video_id:\n        video_id = self._search_regex(('data-guid=[\"\\\\\\']([\\\\da-f]{8}-[\\\\da-f]{4}-[\\\\da-f]{4}-[\\\\da-f]{4}-[\\\\da-f]{12})', 'id_contenu[\"\\\\\\']\\\\s:\\\\s*(\\\\d+)'), webpage, 'video id', default=display_id)\n    return {'id': video_id, 'display_id': display_id, 'title': title, 'description': description, 'thumbnail': vpl_data.get('data-image'), 'duration': duration, 'upload_date': upload_date, 'formats': formats, 'subtitles': self._extract_subtitles(self._parse_json(traverse_obj(vpl_data, ('data-captions', {str}), default='{}'), display_id, fatal=False)), 'series': series, 'episode': episode}"
        ]
    }
]