[
    {
        "func_name": "_term",
        "original": "def _term(expr, j: int, dims: Tuple[int], axis: Optional[int]=0):\n    \"\"\"Helper function for partial trace.\n\n    Parameters\n    ----------\n    expr : :class:`~cvxpy.expressions.expression.Expression`\n        The 2D expression to take the partial trace of.\n    j : int\n        Term in the partial trace sum.\n    dims : tuple of ints.\n        A tuple of integers encoding the dimensions of each subsystem.\n    axis : int\n        The index of the subsystem to be traced out\n        from the tensor product that defines expr.\n    \"\"\"\n    a = sp.coo_matrix(([1.0], ([0], [0])))\n    b = sp.coo_matrix(([1.0], ([0], [0])))\n    for (i_axis, dim) in enumerate(dims):\n        if i_axis == axis:\n            v = sp.coo_matrix(([1], ([j], [0])), shape=(dim, 1))\n            a = sp.kron(a, v.T)\n            b = sp.kron(b, v)\n        else:\n            eye_mat = sp.eye(dim)\n            a = sp.kron(a, eye_mat)\n            b = sp.kron(b, eye_mat)\n    return a @ expr @ b",
        "mutated": [
            "def _term(expr, j: int, dims: Tuple[int], axis: Optional[int]=0):\n    if False:\n        i = 10\n    'Helper function for partial trace.\\n\\n    Parameters\\n    ----------\\n    expr : :class:`~cvxpy.expressions.expression.Expression`\\n        The 2D expression to take the partial trace of.\\n    j : int\\n        Term in the partial trace sum.\\n    dims : tuple of ints.\\n        A tuple of integers encoding the dimensions of each subsystem.\\n    axis : int\\n        The index of the subsystem to be traced out\\n        from the tensor product that defines expr.\\n    '\n    a = sp.coo_matrix(([1.0], ([0], [0])))\n    b = sp.coo_matrix(([1.0], ([0], [0])))\n    for (i_axis, dim) in enumerate(dims):\n        if i_axis == axis:\n            v = sp.coo_matrix(([1], ([j], [0])), shape=(dim, 1))\n            a = sp.kron(a, v.T)\n            b = sp.kron(b, v)\n        else:\n            eye_mat = sp.eye(dim)\n            a = sp.kron(a, eye_mat)\n            b = sp.kron(b, eye_mat)\n    return a @ expr @ b",
            "def _term(expr, j: int, dims: Tuple[int], axis: Optional[int]=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Helper function for partial trace.\\n\\n    Parameters\\n    ----------\\n    expr : :class:`~cvxpy.expressions.expression.Expression`\\n        The 2D expression to take the partial trace of.\\n    j : int\\n        Term in the partial trace sum.\\n    dims : tuple of ints.\\n        A tuple of integers encoding the dimensions of each subsystem.\\n    axis : int\\n        The index of the subsystem to be traced out\\n        from the tensor product that defines expr.\\n    '\n    a = sp.coo_matrix(([1.0], ([0], [0])))\n    b = sp.coo_matrix(([1.0], ([0], [0])))\n    for (i_axis, dim) in enumerate(dims):\n        if i_axis == axis:\n            v = sp.coo_matrix(([1], ([j], [0])), shape=(dim, 1))\n            a = sp.kron(a, v.T)\n            b = sp.kron(b, v)\n        else:\n            eye_mat = sp.eye(dim)\n            a = sp.kron(a, eye_mat)\n            b = sp.kron(b, eye_mat)\n    return a @ expr @ b",
            "def _term(expr, j: int, dims: Tuple[int], axis: Optional[int]=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Helper function for partial trace.\\n\\n    Parameters\\n    ----------\\n    expr : :class:`~cvxpy.expressions.expression.Expression`\\n        The 2D expression to take the partial trace of.\\n    j : int\\n        Term in the partial trace sum.\\n    dims : tuple of ints.\\n        A tuple of integers encoding the dimensions of each subsystem.\\n    axis : int\\n        The index of the subsystem to be traced out\\n        from the tensor product that defines expr.\\n    '\n    a = sp.coo_matrix(([1.0], ([0], [0])))\n    b = sp.coo_matrix(([1.0], ([0], [0])))\n    for (i_axis, dim) in enumerate(dims):\n        if i_axis == axis:\n            v = sp.coo_matrix(([1], ([j], [0])), shape=(dim, 1))\n            a = sp.kron(a, v.T)\n            b = sp.kron(b, v)\n        else:\n            eye_mat = sp.eye(dim)\n            a = sp.kron(a, eye_mat)\n            b = sp.kron(b, eye_mat)\n    return a @ expr @ b",
            "def _term(expr, j: int, dims: Tuple[int], axis: Optional[int]=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Helper function for partial trace.\\n\\n    Parameters\\n    ----------\\n    expr : :class:`~cvxpy.expressions.expression.Expression`\\n        The 2D expression to take the partial trace of.\\n    j : int\\n        Term in the partial trace sum.\\n    dims : tuple of ints.\\n        A tuple of integers encoding the dimensions of each subsystem.\\n    axis : int\\n        The index of the subsystem to be traced out\\n        from the tensor product that defines expr.\\n    '\n    a = sp.coo_matrix(([1.0], ([0], [0])))\n    b = sp.coo_matrix(([1.0], ([0], [0])))\n    for (i_axis, dim) in enumerate(dims):\n        if i_axis == axis:\n            v = sp.coo_matrix(([1], ([j], [0])), shape=(dim, 1))\n            a = sp.kron(a, v.T)\n            b = sp.kron(b, v)\n        else:\n            eye_mat = sp.eye(dim)\n            a = sp.kron(a, eye_mat)\n            b = sp.kron(b, eye_mat)\n    return a @ expr @ b",
            "def _term(expr, j: int, dims: Tuple[int], axis: Optional[int]=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Helper function for partial trace.\\n\\n    Parameters\\n    ----------\\n    expr : :class:`~cvxpy.expressions.expression.Expression`\\n        The 2D expression to take the partial trace of.\\n    j : int\\n        Term in the partial trace sum.\\n    dims : tuple of ints.\\n        A tuple of integers encoding the dimensions of each subsystem.\\n    axis : int\\n        The index of the subsystem to be traced out\\n        from the tensor product that defines expr.\\n    '\n    a = sp.coo_matrix(([1.0], ([0], [0])))\n    b = sp.coo_matrix(([1.0], ([0], [0])))\n    for (i_axis, dim) in enumerate(dims):\n        if i_axis == axis:\n            v = sp.coo_matrix(([1], ([j], [0])), shape=(dim, 1))\n            a = sp.kron(a, v.T)\n            b = sp.kron(b, v)\n        else:\n            eye_mat = sp.eye(dim)\n            a = sp.kron(a, eye_mat)\n            b = sp.kron(b, eye_mat)\n    return a @ expr @ b"
        ]
    },
    {
        "func_name": "partial_trace",
        "original": "def partial_trace(expr, dims: Tuple[int], axis: Optional[int]=0):\n    \"\"\"\n    Assumes :math:`\\\\texttt{expr} = X_1 \\\\otimes \\\\cdots \\\\otimes X_n` is a 2D Kronecker\n    product composed of :math:`n = \\\\texttt{len(dims)}` implicit subsystems.\n    Letting :math:`k = \\\\texttt{axis}`, the returned expression represents\n    the *partial trace* of :math:`\\\\texttt{expr}` along its :math:`k^{\\\\text{th}}` implicit subsystem:\n\n    .. math::\n\n        \\\\text{tr}(X_k) (X_1 \\\\otimes \\\\cdots \\\\otimes X_{k-1} \\\\otimes X_{k+1} \\\\otimes \\\\cdots \\\\otimes X_n).\n\n    Parameters\n    ----------\n    expr : :class:`~cvxpy.expressions.expression.Expression`\n        The 2D expression to take the partial trace of.\n    dims : tuple of ints.\n        A tuple of integers encoding the dimensions of each subsystem.\n    axis : int\n        The index of the subsystem to be traced out\n        from the tensor product that defines expr.\n    \"\"\"\n    expr = Atom.cast_to_const(expr)\n    if expr.ndim < 2 or expr.shape[0] != expr.shape[1]:\n        raise ValueError('Only supports square matrices.')\n    if axis < 0 or axis >= len(dims):\n        raise ValueError(f'Invalid axis argument, should be between 0 and {len(dims)}, got {axis}.')\n    if expr.shape[0] != np.prod(dims):\n        raise ValueError(\"Dimension of system doesn't correspond to dimension of subsystems.\")\n    return sum([_term(expr, j, dims, axis) for j in range(dims[axis])])",
        "mutated": [
            "def partial_trace(expr, dims: Tuple[int], axis: Optional[int]=0):\n    if False:\n        i = 10\n    '\\n    Assumes :math:`\\\\texttt{expr} = X_1 \\\\otimes \\\\cdots \\\\otimes X_n` is a 2D Kronecker\\n    product composed of :math:`n = \\\\texttt{len(dims)}` implicit subsystems.\\n    Letting :math:`k = \\\\texttt{axis}`, the returned expression represents\\n    the *partial trace* of :math:`\\\\texttt{expr}` along its :math:`k^{\\\\text{th}}` implicit subsystem:\\n\\n    .. math::\\n\\n        \\\\text{tr}(X_k) (X_1 \\\\otimes \\\\cdots \\\\otimes X_{k-1} \\\\otimes X_{k+1} \\\\otimes \\\\cdots \\\\otimes X_n).\\n\\n    Parameters\\n    ----------\\n    expr : :class:`~cvxpy.expressions.expression.Expression`\\n        The 2D expression to take the partial trace of.\\n    dims : tuple of ints.\\n        A tuple of integers encoding the dimensions of each subsystem.\\n    axis : int\\n        The index of the subsystem to be traced out\\n        from the tensor product that defines expr.\\n    '\n    expr = Atom.cast_to_const(expr)\n    if expr.ndim < 2 or expr.shape[0] != expr.shape[1]:\n        raise ValueError('Only supports square matrices.')\n    if axis < 0 or axis >= len(dims):\n        raise ValueError(f'Invalid axis argument, should be between 0 and {len(dims)}, got {axis}.')\n    if expr.shape[0] != np.prod(dims):\n        raise ValueError(\"Dimension of system doesn't correspond to dimension of subsystems.\")\n    return sum([_term(expr, j, dims, axis) for j in range(dims[axis])])",
            "def partial_trace(expr, dims: Tuple[int], axis: Optional[int]=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Assumes :math:`\\\\texttt{expr} = X_1 \\\\otimes \\\\cdots \\\\otimes X_n` is a 2D Kronecker\\n    product composed of :math:`n = \\\\texttt{len(dims)}` implicit subsystems.\\n    Letting :math:`k = \\\\texttt{axis}`, the returned expression represents\\n    the *partial trace* of :math:`\\\\texttt{expr}` along its :math:`k^{\\\\text{th}}` implicit subsystem:\\n\\n    .. math::\\n\\n        \\\\text{tr}(X_k) (X_1 \\\\otimes \\\\cdots \\\\otimes X_{k-1} \\\\otimes X_{k+1} \\\\otimes \\\\cdots \\\\otimes X_n).\\n\\n    Parameters\\n    ----------\\n    expr : :class:`~cvxpy.expressions.expression.Expression`\\n        The 2D expression to take the partial trace of.\\n    dims : tuple of ints.\\n        A tuple of integers encoding the dimensions of each subsystem.\\n    axis : int\\n        The index of the subsystem to be traced out\\n        from the tensor product that defines expr.\\n    '\n    expr = Atom.cast_to_const(expr)\n    if expr.ndim < 2 or expr.shape[0] != expr.shape[1]:\n        raise ValueError('Only supports square matrices.')\n    if axis < 0 or axis >= len(dims):\n        raise ValueError(f'Invalid axis argument, should be between 0 and {len(dims)}, got {axis}.')\n    if expr.shape[0] != np.prod(dims):\n        raise ValueError(\"Dimension of system doesn't correspond to dimension of subsystems.\")\n    return sum([_term(expr, j, dims, axis) for j in range(dims[axis])])",
            "def partial_trace(expr, dims: Tuple[int], axis: Optional[int]=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Assumes :math:`\\\\texttt{expr} = X_1 \\\\otimes \\\\cdots \\\\otimes X_n` is a 2D Kronecker\\n    product composed of :math:`n = \\\\texttt{len(dims)}` implicit subsystems.\\n    Letting :math:`k = \\\\texttt{axis}`, the returned expression represents\\n    the *partial trace* of :math:`\\\\texttt{expr}` along its :math:`k^{\\\\text{th}}` implicit subsystem:\\n\\n    .. math::\\n\\n        \\\\text{tr}(X_k) (X_1 \\\\otimes \\\\cdots \\\\otimes X_{k-1} \\\\otimes X_{k+1} \\\\otimes \\\\cdots \\\\otimes X_n).\\n\\n    Parameters\\n    ----------\\n    expr : :class:`~cvxpy.expressions.expression.Expression`\\n        The 2D expression to take the partial trace of.\\n    dims : tuple of ints.\\n        A tuple of integers encoding the dimensions of each subsystem.\\n    axis : int\\n        The index of the subsystem to be traced out\\n        from the tensor product that defines expr.\\n    '\n    expr = Atom.cast_to_const(expr)\n    if expr.ndim < 2 or expr.shape[0] != expr.shape[1]:\n        raise ValueError('Only supports square matrices.')\n    if axis < 0 or axis >= len(dims):\n        raise ValueError(f'Invalid axis argument, should be between 0 and {len(dims)}, got {axis}.')\n    if expr.shape[0] != np.prod(dims):\n        raise ValueError(\"Dimension of system doesn't correspond to dimension of subsystems.\")\n    return sum([_term(expr, j, dims, axis) for j in range(dims[axis])])",
            "def partial_trace(expr, dims: Tuple[int], axis: Optional[int]=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Assumes :math:`\\\\texttt{expr} = X_1 \\\\otimes \\\\cdots \\\\otimes X_n` is a 2D Kronecker\\n    product composed of :math:`n = \\\\texttt{len(dims)}` implicit subsystems.\\n    Letting :math:`k = \\\\texttt{axis}`, the returned expression represents\\n    the *partial trace* of :math:`\\\\texttt{expr}` along its :math:`k^{\\\\text{th}}` implicit subsystem:\\n\\n    .. math::\\n\\n        \\\\text{tr}(X_k) (X_1 \\\\otimes \\\\cdots \\\\otimes X_{k-1} \\\\otimes X_{k+1} \\\\otimes \\\\cdots \\\\otimes X_n).\\n\\n    Parameters\\n    ----------\\n    expr : :class:`~cvxpy.expressions.expression.Expression`\\n        The 2D expression to take the partial trace of.\\n    dims : tuple of ints.\\n        A tuple of integers encoding the dimensions of each subsystem.\\n    axis : int\\n        The index of the subsystem to be traced out\\n        from the tensor product that defines expr.\\n    '\n    expr = Atom.cast_to_const(expr)\n    if expr.ndim < 2 or expr.shape[0] != expr.shape[1]:\n        raise ValueError('Only supports square matrices.')\n    if axis < 0 or axis >= len(dims):\n        raise ValueError(f'Invalid axis argument, should be between 0 and {len(dims)}, got {axis}.')\n    if expr.shape[0] != np.prod(dims):\n        raise ValueError(\"Dimension of system doesn't correspond to dimension of subsystems.\")\n    return sum([_term(expr, j, dims, axis) for j in range(dims[axis])])",
            "def partial_trace(expr, dims: Tuple[int], axis: Optional[int]=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Assumes :math:`\\\\texttt{expr} = X_1 \\\\otimes \\\\cdots \\\\otimes X_n` is a 2D Kronecker\\n    product composed of :math:`n = \\\\texttt{len(dims)}` implicit subsystems.\\n    Letting :math:`k = \\\\texttt{axis}`, the returned expression represents\\n    the *partial trace* of :math:`\\\\texttt{expr}` along its :math:`k^{\\\\text{th}}` implicit subsystem:\\n\\n    .. math::\\n\\n        \\\\text{tr}(X_k) (X_1 \\\\otimes \\\\cdots \\\\otimes X_{k-1} \\\\otimes X_{k+1} \\\\otimes \\\\cdots \\\\otimes X_n).\\n\\n    Parameters\\n    ----------\\n    expr : :class:`~cvxpy.expressions.expression.Expression`\\n        The 2D expression to take the partial trace of.\\n    dims : tuple of ints.\\n        A tuple of integers encoding the dimensions of each subsystem.\\n    axis : int\\n        The index of the subsystem to be traced out\\n        from the tensor product that defines expr.\\n    '\n    expr = Atom.cast_to_const(expr)\n    if expr.ndim < 2 or expr.shape[0] != expr.shape[1]:\n        raise ValueError('Only supports square matrices.')\n    if axis < 0 or axis >= len(dims):\n        raise ValueError(f'Invalid axis argument, should be between 0 and {len(dims)}, got {axis}.')\n    if expr.shape[0] != np.prod(dims):\n        raise ValueError(\"Dimension of system doesn't correspond to dimension of subsystems.\")\n    return sum([_term(expr, j, dims, axis) for j in range(dims[axis])])"
        ]
    }
]