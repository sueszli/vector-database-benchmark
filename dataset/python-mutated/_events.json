[
    {
        "func_name": "get_outdated_red_messages",
        "original": "def get_outdated_red_messages(pypi_version: str, py_version_req: str) -> Tuple[str, str]:\n    outdated_red_message = _('Your Red instance is out of date! {} is the current version, however you are using {}!').format(pypi_version, red_version)\n    rich_outdated_message = f\"[red]Outdated version![/red]\\n[red]!!![/red]Version [cyan]{pypi_version}[/] is available, but you're using [cyan]{red_version}[/][red]!!![/red]\"\n    current_python = platform.python_version()\n    extra_update = _('\\n\\nWhile the following command should work in most scenarios as it is based on your current OS, environment, and Python version, **we highly recommend you to read the update docs at <{docs}> and make sure there is nothing else that needs to be done during the update.**').format(docs='https://docs.discord.red/en/stable/update_red.html')\n    if not expected_version(current_python, py_version_req):\n        extra_update += _('\\n\\nYou have Python `{py_version}` and this update requires `{req_py}`; you cannot simply run the update command.\\n\\nYou will need to follow the update instructions in our docs above, if you still need help updating after following the docs go to our #support channel in <https://discord.gg/red>').format(py_version=current_python, req_py=py_version_req)\n        outdated_red_message += extra_update\n        return (outdated_red_message, rich_outdated_message)\n    red_dist = importlib.metadata.distribution('Red-DiscordBot')\n    installed_extras = red_dist.metadata.get_all('Provides-Extra')\n    installed_extras.remove('dev')\n    installed_extras.remove('all')\n    distributions = {}\n    for req_str in red_dist.requires:\n        req = Requirement(req_str)\n        if req.marker is None or req.marker.evaluate():\n            continue\n        for extra in reversed(installed_extras):\n            if not req.marker.evaluate({'extra': extra}):\n                continue\n            if req.name in distributions:\n                dist = distributions[req.name]\n            else:\n                try:\n                    dist = importlib.metadata.distribution(req.name)\n                except importlib.metadata.PackageNotFoundError:\n                    dist = None\n                distributions[req.name] = dist\n            if dist is None or not req.specifier.contains(dist.version, prereleases=True):\n                installed_extras.remove(extra)\n    if installed_extras:\n        package_extras = f\"[{','.join(installed_extras)}]\"\n    else:\n        package_extras = ''\n    extra_update += _(\"\\n\\nTo update your bot, first shutdown your bot then open a window of {console} (Not as admin) and run the following:{command_1}\\nOnce you've started up your bot again, we recommend that you update any installed 3rd-party cogs with this command in Discord:{command_2}\").format(console=_('Command Prompt') if platform.system() == 'Windows' else _('Terminal'), command_1=f'```\"{sys.executable}\" -m pip install -U \"Red-DiscordBot{package_extras}\"```', command_2=f'```[p]cog update```')\n    outdated_red_message += extra_update\n    return (outdated_red_message, rich_outdated_message)",
        "mutated": [
            "def get_outdated_red_messages(pypi_version: str, py_version_req: str) -> Tuple[str, str]:\n    if False:\n        i = 10\n    outdated_red_message = _('Your Red instance is out of date! {} is the current version, however you are using {}!').format(pypi_version, red_version)\n    rich_outdated_message = f\"[red]Outdated version![/red]\\n[red]!!![/red]Version [cyan]{pypi_version}[/] is available, but you're using [cyan]{red_version}[/][red]!!![/red]\"\n    current_python = platform.python_version()\n    extra_update = _('\\n\\nWhile the following command should work in most scenarios as it is based on your current OS, environment, and Python version, **we highly recommend you to read the update docs at <{docs}> and make sure there is nothing else that needs to be done during the update.**').format(docs='https://docs.discord.red/en/stable/update_red.html')\n    if not expected_version(current_python, py_version_req):\n        extra_update += _('\\n\\nYou have Python `{py_version}` and this update requires `{req_py}`; you cannot simply run the update command.\\n\\nYou will need to follow the update instructions in our docs above, if you still need help updating after following the docs go to our #support channel in <https://discord.gg/red>').format(py_version=current_python, req_py=py_version_req)\n        outdated_red_message += extra_update\n        return (outdated_red_message, rich_outdated_message)\n    red_dist = importlib.metadata.distribution('Red-DiscordBot')\n    installed_extras = red_dist.metadata.get_all('Provides-Extra')\n    installed_extras.remove('dev')\n    installed_extras.remove('all')\n    distributions = {}\n    for req_str in red_dist.requires:\n        req = Requirement(req_str)\n        if req.marker is None or req.marker.evaluate():\n            continue\n        for extra in reversed(installed_extras):\n            if not req.marker.evaluate({'extra': extra}):\n                continue\n            if req.name in distributions:\n                dist = distributions[req.name]\n            else:\n                try:\n                    dist = importlib.metadata.distribution(req.name)\n                except importlib.metadata.PackageNotFoundError:\n                    dist = None\n                distributions[req.name] = dist\n            if dist is None or not req.specifier.contains(dist.version, prereleases=True):\n                installed_extras.remove(extra)\n    if installed_extras:\n        package_extras = f\"[{','.join(installed_extras)}]\"\n    else:\n        package_extras = ''\n    extra_update += _(\"\\n\\nTo update your bot, first shutdown your bot then open a window of {console} (Not as admin) and run the following:{command_1}\\nOnce you've started up your bot again, we recommend that you update any installed 3rd-party cogs with this command in Discord:{command_2}\").format(console=_('Command Prompt') if platform.system() == 'Windows' else _('Terminal'), command_1=f'```\"{sys.executable}\" -m pip install -U \"Red-DiscordBot{package_extras}\"```', command_2=f'```[p]cog update```')\n    outdated_red_message += extra_update\n    return (outdated_red_message, rich_outdated_message)",
            "def get_outdated_red_messages(pypi_version: str, py_version_req: str) -> Tuple[str, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    outdated_red_message = _('Your Red instance is out of date! {} is the current version, however you are using {}!').format(pypi_version, red_version)\n    rich_outdated_message = f\"[red]Outdated version![/red]\\n[red]!!![/red]Version [cyan]{pypi_version}[/] is available, but you're using [cyan]{red_version}[/][red]!!![/red]\"\n    current_python = platform.python_version()\n    extra_update = _('\\n\\nWhile the following command should work in most scenarios as it is based on your current OS, environment, and Python version, **we highly recommend you to read the update docs at <{docs}> and make sure there is nothing else that needs to be done during the update.**').format(docs='https://docs.discord.red/en/stable/update_red.html')\n    if not expected_version(current_python, py_version_req):\n        extra_update += _('\\n\\nYou have Python `{py_version}` and this update requires `{req_py}`; you cannot simply run the update command.\\n\\nYou will need to follow the update instructions in our docs above, if you still need help updating after following the docs go to our #support channel in <https://discord.gg/red>').format(py_version=current_python, req_py=py_version_req)\n        outdated_red_message += extra_update\n        return (outdated_red_message, rich_outdated_message)\n    red_dist = importlib.metadata.distribution('Red-DiscordBot')\n    installed_extras = red_dist.metadata.get_all('Provides-Extra')\n    installed_extras.remove('dev')\n    installed_extras.remove('all')\n    distributions = {}\n    for req_str in red_dist.requires:\n        req = Requirement(req_str)\n        if req.marker is None or req.marker.evaluate():\n            continue\n        for extra in reversed(installed_extras):\n            if not req.marker.evaluate({'extra': extra}):\n                continue\n            if req.name in distributions:\n                dist = distributions[req.name]\n            else:\n                try:\n                    dist = importlib.metadata.distribution(req.name)\n                except importlib.metadata.PackageNotFoundError:\n                    dist = None\n                distributions[req.name] = dist\n            if dist is None or not req.specifier.contains(dist.version, prereleases=True):\n                installed_extras.remove(extra)\n    if installed_extras:\n        package_extras = f\"[{','.join(installed_extras)}]\"\n    else:\n        package_extras = ''\n    extra_update += _(\"\\n\\nTo update your bot, first shutdown your bot then open a window of {console} (Not as admin) and run the following:{command_1}\\nOnce you've started up your bot again, we recommend that you update any installed 3rd-party cogs with this command in Discord:{command_2}\").format(console=_('Command Prompt') if platform.system() == 'Windows' else _('Terminal'), command_1=f'```\"{sys.executable}\" -m pip install -U \"Red-DiscordBot{package_extras}\"```', command_2=f'```[p]cog update```')\n    outdated_red_message += extra_update\n    return (outdated_red_message, rich_outdated_message)",
            "def get_outdated_red_messages(pypi_version: str, py_version_req: str) -> Tuple[str, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    outdated_red_message = _('Your Red instance is out of date! {} is the current version, however you are using {}!').format(pypi_version, red_version)\n    rich_outdated_message = f\"[red]Outdated version![/red]\\n[red]!!![/red]Version [cyan]{pypi_version}[/] is available, but you're using [cyan]{red_version}[/][red]!!![/red]\"\n    current_python = platform.python_version()\n    extra_update = _('\\n\\nWhile the following command should work in most scenarios as it is based on your current OS, environment, and Python version, **we highly recommend you to read the update docs at <{docs}> and make sure there is nothing else that needs to be done during the update.**').format(docs='https://docs.discord.red/en/stable/update_red.html')\n    if not expected_version(current_python, py_version_req):\n        extra_update += _('\\n\\nYou have Python `{py_version}` and this update requires `{req_py}`; you cannot simply run the update command.\\n\\nYou will need to follow the update instructions in our docs above, if you still need help updating after following the docs go to our #support channel in <https://discord.gg/red>').format(py_version=current_python, req_py=py_version_req)\n        outdated_red_message += extra_update\n        return (outdated_red_message, rich_outdated_message)\n    red_dist = importlib.metadata.distribution('Red-DiscordBot')\n    installed_extras = red_dist.metadata.get_all('Provides-Extra')\n    installed_extras.remove('dev')\n    installed_extras.remove('all')\n    distributions = {}\n    for req_str in red_dist.requires:\n        req = Requirement(req_str)\n        if req.marker is None or req.marker.evaluate():\n            continue\n        for extra in reversed(installed_extras):\n            if not req.marker.evaluate({'extra': extra}):\n                continue\n            if req.name in distributions:\n                dist = distributions[req.name]\n            else:\n                try:\n                    dist = importlib.metadata.distribution(req.name)\n                except importlib.metadata.PackageNotFoundError:\n                    dist = None\n                distributions[req.name] = dist\n            if dist is None or not req.specifier.contains(dist.version, prereleases=True):\n                installed_extras.remove(extra)\n    if installed_extras:\n        package_extras = f\"[{','.join(installed_extras)}]\"\n    else:\n        package_extras = ''\n    extra_update += _(\"\\n\\nTo update your bot, first shutdown your bot then open a window of {console} (Not as admin) and run the following:{command_1}\\nOnce you've started up your bot again, we recommend that you update any installed 3rd-party cogs with this command in Discord:{command_2}\").format(console=_('Command Prompt') if platform.system() == 'Windows' else _('Terminal'), command_1=f'```\"{sys.executable}\" -m pip install -U \"Red-DiscordBot{package_extras}\"```', command_2=f'```[p]cog update```')\n    outdated_red_message += extra_update\n    return (outdated_red_message, rich_outdated_message)",
            "def get_outdated_red_messages(pypi_version: str, py_version_req: str) -> Tuple[str, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    outdated_red_message = _('Your Red instance is out of date! {} is the current version, however you are using {}!').format(pypi_version, red_version)\n    rich_outdated_message = f\"[red]Outdated version![/red]\\n[red]!!![/red]Version [cyan]{pypi_version}[/] is available, but you're using [cyan]{red_version}[/][red]!!![/red]\"\n    current_python = platform.python_version()\n    extra_update = _('\\n\\nWhile the following command should work in most scenarios as it is based on your current OS, environment, and Python version, **we highly recommend you to read the update docs at <{docs}> and make sure there is nothing else that needs to be done during the update.**').format(docs='https://docs.discord.red/en/stable/update_red.html')\n    if not expected_version(current_python, py_version_req):\n        extra_update += _('\\n\\nYou have Python `{py_version}` and this update requires `{req_py}`; you cannot simply run the update command.\\n\\nYou will need to follow the update instructions in our docs above, if you still need help updating after following the docs go to our #support channel in <https://discord.gg/red>').format(py_version=current_python, req_py=py_version_req)\n        outdated_red_message += extra_update\n        return (outdated_red_message, rich_outdated_message)\n    red_dist = importlib.metadata.distribution('Red-DiscordBot')\n    installed_extras = red_dist.metadata.get_all('Provides-Extra')\n    installed_extras.remove('dev')\n    installed_extras.remove('all')\n    distributions = {}\n    for req_str in red_dist.requires:\n        req = Requirement(req_str)\n        if req.marker is None or req.marker.evaluate():\n            continue\n        for extra in reversed(installed_extras):\n            if not req.marker.evaluate({'extra': extra}):\n                continue\n            if req.name in distributions:\n                dist = distributions[req.name]\n            else:\n                try:\n                    dist = importlib.metadata.distribution(req.name)\n                except importlib.metadata.PackageNotFoundError:\n                    dist = None\n                distributions[req.name] = dist\n            if dist is None or not req.specifier.contains(dist.version, prereleases=True):\n                installed_extras.remove(extra)\n    if installed_extras:\n        package_extras = f\"[{','.join(installed_extras)}]\"\n    else:\n        package_extras = ''\n    extra_update += _(\"\\n\\nTo update your bot, first shutdown your bot then open a window of {console} (Not as admin) and run the following:{command_1}\\nOnce you've started up your bot again, we recommend that you update any installed 3rd-party cogs with this command in Discord:{command_2}\").format(console=_('Command Prompt') if platform.system() == 'Windows' else _('Terminal'), command_1=f'```\"{sys.executable}\" -m pip install -U \"Red-DiscordBot{package_extras}\"```', command_2=f'```[p]cog update```')\n    outdated_red_message += extra_update\n    return (outdated_red_message, rich_outdated_message)",
            "def get_outdated_red_messages(pypi_version: str, py_version_req: str) -> Tuple[str, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    outdated_red_message = _('Your Red instance is out of date! {} is the current version, however you are using {}!').format(pypi_version, red_version)\n    rich_outdated_message = f\"[red]Outdated version![/red]\\n[red]!!![/red]Version [cyan]{pypi_version}[/] is available, but you're using [cyan]{red_version}[/][red]!!![/red]\"\n    current_python = platform.python_version()\n    extra_update = _('\\n\\nWhile the following command should work in most scenarios as it is based on your current OS, environment, and Python version, **we highly recommend you to read the update docs at <{docs}> and make sure there is nothing else that needs to be done during the update.**').format(docs='https://docs.discord.red/en/stable/update_red.html')\n    if not expected_version(current_python, py_version_req):\n        extra_update += _('\\n\\nYou have Python `{py_version}` and this update requires `{req_py}`; you cannot simply run the update command.\\n\\nYou will need to follow the update instructions in our docs above, if you still need help updating after following the docs go to our #support channel in <https://discord.gg/red>').format(py_version=current_python, req_py=py_version_req)\n        outdated_red_message += extra_update\n        return (outdated_red_message, rich_outdated_message)\n    red_dist = importlib.metadata.distribution('Red-DiscordBot')\n    installed_extras = red_dist.metadata.get_all('Provides-Extra')\n    installed_extras.remove('dev')\n    installed_extras.remove('all')\n    distributions = {}\n    for req_str in red_dist.requires:\n        req = Requirement(req_str)\n        if req.marker is None or req.marker.evaluate():\n            continue\n        for extra in reversed(installed_extras):\n            if not req.marker.evaluate({'extra': extra}):\n                continue\n            if req.name in distributions:\n                dist = distributions[req.name]\n            else:\n                try:\n                    dist = importlib.metadata.distribution(req.name)\n                except importlib.metadata.PackageNotFoundError:\n                    dist = None\n                distributions[req.name] = dist\n            if dist is None or not req.specifier.contains(dist.version, prereleases=True):\n                installed_extras.remove(extra)\n    if installed_extras:\n        package_extras = f\"[{','.join(installed_extras)}]\"\n    else:\n        package_extras = ''\n    extra_update += _(\"\\n\\nTo update your bot, first shutdown your bot then open a window of {console} (Not as admin) and run the following:{command_1}\\nOnce you've started up your bot again, we recommend that you update any installed 3rd-party cogs with this command in Discord:{command_2}\").format(console=_('Command Prompt') if platform.system() == 'Windows' else _('Terminal'), command_1=f'```\"{sys.executable}\" -m pip install -U \"Red-DiscordBot{package_extras}\"```', command_2=f'```[p]cog update```')\n    outdated_red_message += extra_update\n    return (outdated_red_message, rich_outdated_message)"
        ]
    },
    {
        "func_name": "init_events",
        "original": "def init_events(bot, cli_flags):\n\n    @bot.event\n    async def on_connect():\n        if bot._uptime is None:\n            log.info('Connected to Discord. Getting ready...')\n\n    @bot.event\n    async def on_ready():\n        try:\n            await _on_ready()\n        except Exception as exc:\n            log.critical('The bot failed to get ready!', exc_info=exc)\n            sys.exit(ExitCodes.CRITICAL)\n\n    async def _on_ready():\n        if bot._uptime is not None:\n            return\n        bot._uptime = datetime.utcnow()\n        guilds = len(bot.guilds)\n        users = len(set([m for m in bot.get_all_members()]))\n        invite_url = discord.utils.oauth_url(bot.application_id, scopes=('bot',))\n        prefixes = cli_flags.prefix or await bot._config.prefix()\n        lang = await bot._config.locale()\n        dpy_version = discord.__version__\n        table_general_info = Table(show_edge=False, show_header=False, box=box.MINIMAL)\n        table_general_info.add_row('Prefixes', ', '.join(prefixes))\n        table_general_info.add_row('Language', lang)\n        table_general_info.add_row('Red version', red_version)\n        table_general_info.add_row('Discord.py version', dpy_version)\n        table_general_info.add_row('Storage type', data_manager.storage_type())\n        table_counts = Table(show_edge=False, show_header=False, box=box.MINIMAL)\n        table_counts.add_row('Shards', str(bot.shard_count))\n        table_counts.add_row('Servers', str(guilds))\n        if bot.intents.members:\n            table_counts.add_row('Unique Users', str(users))\n        outdated_red_message = ''\n        rich_outdated_message = ''\n        (pypi_version, py_version_req) = await fetch_latest_red_version_info()\n        outdated = pypi_version and pypi_version > red_version_info\n        if outdated:\n            (outdated_red_message, rich_outdated_message) = get_outdated_red_messages(pypi_version, py_version_req)\n        rich_console = rich.get_console()\n        rich_console.print(INTRO, style='red', markup=False, highlight=False)\n        if guilds:\n            rich_console.print(Columns([Panel(table_general_info, title=bot.user.display_name), Panel(table_counts)], equal=True, align='center'))\n        else:\n            rich_console.print(Columns([Panel(table_general_info, title=bot.user.display_name)]))\n        rich_console.print('Loaded {} cogs with {} commands'.format(len(bot.cogs), len(bot.commands)))\n        if invite_url:\n            rich_console.print(f\"\\nInvite URL: {Text(invite_url, style=f'link {invite_url}')}\")\n        if not guilds:\n            rich_console.print(f\"Looking for a quick guide on setting up Red? Checkout {Text('https://start.discord.red', style='link https://start.discord.red}')}\")\n        if rich_outdated_message:\n            rich_console.print(rich_outdated_message)\n        bot._red_ready.set()\n        if outdated_red_message:\n            await send_to_owners_with_prefix_replaced(bot, outdated_red_message)\n\n    @bot.event\n    async def on_command_completion(ctx: commands.Context):\n        await bot._delete_delay(ctx)\n\n    @bot.event\n    async def on_command_error(ctx, error, unhandled_by_cog=False):\n        if not unhandled_by_cog:\n            if hasattr(ctx.command, 'on_error'):\n                return\n            if ctx.cog:\n                if ctx.cog.has_error_handler():\n                    return\n        if not isinstance(error, commands.CommandNotFound):\n            asyncio.create_task(bot._delete_delay(ctx))\n        converter = getattr(ctx.current_parameter, 'converter', None)\n        argument = ctx.current_argument\n        if isinstance(error, commands.MissingRequiredArgument):\n            await ctx.send_help()\n        elif isinstance(error, commands.ArgParserFailure):\n            msg = _('`{user_input}` is not a valid value for `{command}`').format(user_input=error.user_input, command=error.cmd)\n            if error.custom_help_msg:\n                msg += f'\\n{error.custom_help_msg}'\n            await ctx.send(msg)\n            if error.send_cmd_help:\n                await ctx.send_help()\n        elif isinstance(error, commands.RangeError):\n            if isinstance(error.value, int):\n                if error.minimum == 0 and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a positive integer.')\n                elif error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be an integer no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be an integer no less than {minimum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be an integer between {minimum} and {maximum}.')\n            elif isinstance(error.value, float):\n                if error.minimum == 0 and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a positive number.')\n                elif error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be a number no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a number no less than {maximum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be a number between {minimum} and {maximum}.')\n            elif isinstance(error.value, str):\n                if error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of no less than {minimum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of between {minimum} and {maximum}.')\n            await ctx.send(message.format(maximum=error.maximum, minimum=error.minimum, parameter_name=ctx.current_parameter.name))\n            return\n        elif isinstance(error, commands.BadArgument):\n            if isinstance(converter, commands.Range):\n                if converter.annotation is int:\n                    if converter.min == 0 and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a positive integer.')\n                    elif converter.min is None and converter.max is not None:\n                        message = _('Argument `{parameter_name}` must be an integer no more than {maximum}.')\n                    elif converter.min is not None and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be an integer no less than {minimum}.')\n                    elif converter.max is not None and converter.min is not None:\n                        message = _('Argument `{parameter_name}` must be an integer between {minimum} and {maximum}.')\n                elif converter.annotation is float:\n                    if converter.min == 0 and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a positive number.')\n                    elif converter.min is None and converter.max is not None:\n                        message = _('Argument `{parameter_name}` must be a number no more than {maximum}.')\n                    elif converter.min is not None and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a number no less than {minimum}.')\n                    elif converter.max is not None and converter.min is not None:\n                        message = _('Argument `{parameter_name}` must be a number between {minimum} and {maximum}.')\n                elif converter.annotation is str:\n                    if error.minimum is None and error.maximum is not None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of no more than {maximum}.')\n                    elif error.minimum is not None and error.maximum is None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of no less than {minimum}.')\n                    elif error.maximum is not None and error.minimum is not None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of between {minimum} and {maximum}.')\n                await ctx.send(message.format(maximum=converter.max, minimum=converter.min, parameter_name=ctx.current_parameter.name))\n                return\n            if isinstance(error.__cause__, ValueError):\n                if converter is int:\n                    await ctx.send(_('\"{argument}\" is not an integer.').format(argument=argument))\n                    return\n                if converter is float:\n                    await ctx.send(_('\"{argument}\" is not a number.').format(argument=argument))\n                    return\n            if error.args:\n                await ctx.send(error.args[0])\n            else:\n                await ctx.send_help()\n        elif isinstance(error, commands.UserInputError):\n            await ctx.send_help()\n        elif isinstance(error, commands.DisabledCommand):\n            disabled_message = await bot._config.disabled_command_msg()\n            if disabled_message:\n                await ctx.send(disabled_message.replace('{command}', ctx.invoked_with))\n        elif isinstance(error, commands.CommandInvokeError):\n            log.exception(\"Exception in command '{}'\".format(ctx.command.qualified_name), exc_info=error.original)\n            exception_log = \"Exception in command '{}'\\n\".format(ctx.command.qualified_name)\n            exception_log += ''.join(traceback.format_exception(type(error), error, error.__traceback__))\n            bot._last_exception = exception_log\n            message = await bot._config.invoke_error_msg()\n            if not message:\n                if ctx.author.id in bot.owner_ids:\n                    message = inline(_(\"Error in command '{command}'. Check your console or logs for details.\"))\n                else:\n                    message = inline(_(\"Error in command '{command}'.\"))\n            await ctx.send(message.replace('{command}', ctx.command.qualified_name))\n        elif isinstance(error, commands.CommandNotFound):\n            help_settings = await HelpSettings.from_context(ctx)\n            fuzzy_commands = await fuzzy_command_search(ctx, commands=RedHelpFormatter.help_filter_func(ctx, bot.walk_commands(), help_settings=help_settings))\n            if not fuzzy_commands:\n                pass\n            elif await ctx.embed_requested():\n                await ctx.send(embed=await format_fuzzy_results(ctx, fuzzy_commands, embed=True))\n            else:\n                await ctx.send(await format_fuzzy_results(ctx, fuzzy_commands, embed=False))\n        elif isinstance(error, commands.BotMissingPermissions):\n            if bin(error.missing.value).count('1') == 1:\n                msg = _('I require the {permission} permission to execute that command.').format(permission=format_perms_list(error.missing))\n            else:\n                msg = _('I require {permission_list} permissions to execute that command.').format(permission_list=format_perms_list(error.missing))\n            await ctx.send(msg)\n        elif isinstance(error, commands.UserFeedbackCheckFailure):\n            if error.message:\n                await ctx.send(error.message)\n        elif isinstance(error, commands.NoPrivateMessage):\n            await ctx.send(_('That command is not available in DMs.'))\n        elif isinstance(error, commands.PrivateMessageOnly):\n            await ctx.send(_('That command is only available in DMs.'))\n        elif isinstance(error, commands.NSFWChannelRequired):\n            await ctx.send(_('That command is only available in NSFW channels.'))\n        elif isinstance(error, commands.CheckFailure):\n            pass\n        elif isinstance(error, commands.CommandOnCooldown):\n            if bot._bypass_cooldowns and ctx.author.id in bot.owner_ids:\n                ctx.command.reset_cooldown(ctx)\n                new_ctx = await bot.get_context(ctx.message)\n                await bot.invoke(new_ctx)\n                return\n            relative_time = discord.utils.format_dt(datetime.now(timezone.utc) + timedelta(seconds=error.retry_after), 'R')\n            msg = _('This command is on cooldown. Try again {relative_time}.').format(relative_time=relative_time)\n            await ctx.send(msg, delete_after=error.retry_after)\n        elif isinstance(error, commands.MaxConcurrencyReached):\n            if error.per is commands.BucketType.default:\n                if error.number > 1:\n                    msg = _('Too many people using this command. It can only be used {number} times concurrently.').format(number=error.number)\n                else:\n                    msg = _('Too many people using this command. It can only be used once concurrently.')\n            elif error.per in (commands.BucketType.user, commands.BucketType.member):\n                if error.number > 1:\n                    msg = _('That command is still completing, it can only be used {number} times per {type} concurrently.').format(number=error.number, type=error.per.name)\n                else:\n                    msg = _('That command is still completing, it can only be used once per {type} concurrently.').format(type=error.per.name)\n            elif error.number > 1:\n                msg = _('Too many people using this command. It can only be used {number} times per {type} concurrently.').format(number=error.number, type=error.per.name)\n            else:\n                msg = _('Too many people using this command. It can only be used once per {type} concurrently.').format(type=error.per.name)\n            await ctx.send(msg)\n        else:\n            log.exception(type(error).__name__, exc_info=error)\n\n    @bot.event\n    async def on_message(message, /):\n        await set_contextual_locales_from_guild(bot, message.guild)\n        await bot.process_commands(message)\n        discord_now = message.created_at\n        if not bot._checked_time_accuracy or discord_now - timedelta(minutes=60) > bot._checked_time_accuracy:\n            system_now = datetime.now(timezone.utc)\n            diff = abs((discord_now - system_now).total_seconds())\n            if diff > 60:\n                log.warning(\"Detected significant difference (%d seconds) in system clock to discord's clock. Any time sensitive code may fail.\", diff)\n            bot._checked_time_accuracy = discord_now\n\n    @bot.event\n    async def on_command_add(command: commands.Command):\n        if command.cog is not None:\n            return\n        await _disable_command_no_cog(command)\n\n    async def _guild_added(guild: discord.Guild):\n        disabled_commands = await bot._config.guild(guild).disabled_commands()\n        for command_name in disabled_commands:\n            command_obj = bot.get_command(command_name)\n            if command_obj is not None:\n                command_obj.disable_in(guild)\n\n    @bot.event\n    async def on_guild_join(guild: discord.Guild):\n        await _guild_added(guild)\n\n    @bot.event\n    async def on_guild_available(guild: discord.Guild):\n        await _guild_added(guild)\n\n    @bot.event\n    async def on_guild_remove(guild: discord.Guild):\n        disabled_commands = await bot._config.guild(guild).disabled_commands()\n        for command_name in disabled_commands:\n            command_obj = bot.get_command(command_name)\n            if command_obj is not None:\n                command_obj.enable_in(guild)\n\n    @bot.event\n    async def on_cog_add(cog: commands.Cog):\n        confs = get_latest_confs()\n        for c in confs:\n            uuid = c.unique_identifier\n            group_data = c.custom_groups\n            await bot._config.custom('CUSTOM_GROUPS', c.cog_name, uuid).set(group_data)\n        await _disable_commands_cog(cog)\n\n    async def _disable_command(command: commands.Command, global_disabled: list, guilds_data: dict):\n        if command.qualified_name in global_disabled:\n            command.enabled = False\n        for (guild_id, data) in guilds_data.items():\n            guild_disabled_cmds = data.get('disabled_commands', [])\n            if command.qualified_name in guild_disabled_cmds:\n                command.disable_in(discord.Object(id=guild_id))\n\n    async def _disable_commands_cog(cog: commands.Cog):\n        global_disabled = await bot._config.disabled_commands()\n        guilds_data = await bot._config.all_guilds()\n        for command in cog.walk_commands():\n            await _disable_command(command, global_disabled, guilds_data)\n\n    async def _disable_command_no_cog(command: commands.Command):\n        global_disabled = await bot._config.disabled_commands()\n        guilds_data = await bot._config.all_guilds()\n        await _disable_command(command, global_disabled, guilds_data)",
        "mutated": [
            "def init_events(bot, cli_flags):\n    if False:\n        i = 10\n\n    @bot.event\n    async def on_connect():\n        if bot._uptime is None:\n            log.info('Connected to Discord. Getting ready...')\n\n    @bot.event\n    async def on_ready():\n        try:\n            await _on_ready()\n        except Exception as exc:\n            log.critical('The bot failed to get ready!', exc_info=exc)\n            sys.exit(ExitCodes.CRITICAL)\n\n    async def _on_ready():\n        if bot._uptime is not None:\n            return\n        bot._uptime = datetime.utcnow()\n        guilds = len(bot.guilds)\n        users = len(set([m for m in bot.get_all_members()]))\n        invite_url = discord.utils.oauth_url(bot.application_id, scopes=('bot',))\n        prefixes = cli_flags.prefix or await bot._config.prefix()\n        lang = await bot._config.locale()\n        dpy_version = discord.__version__\n        table_general_info = Table(show_edge=False, show_header=False, box=box.MINIMAL)\n        table_general_info.add_row('Prefixes', ', '.join(prefixes))\n        table_general_info.add_row('Language', lang)\n        table_general_info.add_row('Red version', red_version)\n        table_general_info.add_row('Discord.py version', dpy_version)\n        table_general_info.add_row('Storage type', data_manager.storage_type())\n        table_counts = Table(show_edge=False, show_header=False, box=box.MINIMAL)\n        table_counts.add_row('Shards', str(bot.shard_count))\n        table_counts.add_row('Servers', str(guilds))\n        if bot.intents.members:\n            table_counts.add_row('Unique Users', str(users))\n        outdated_red_message = ''\n        rich_outdated_message = ''\n        (pypi_version, py_version_req) = await fetch_latest_red_version_info()\n        outdated = pypi_version and pypi_version > red_version_info\n        if outdated:\n            (outdated_red_message, rich_outdated_message) = get_outdated_red_messages(pypi_version, py_version_req)\n        rich_console = rich.get_console()\n        rich_console.print(INTRO, style='red', markup=False, highlight=False)\n        if guilds:\n            rich_console.print(Columns([Panel(table_general_info, title=bot.user.display_name), Panel(table_counts)], equal=True, align='center'))\n        else:\n            rich_console.print(Columns([Panel(table_general_info, title=bot.user.display_name)]))\n        rich_console.print('Loaded {} cogs with {} commands'.format(len(bot.cogs), len(bot.commands)))\n        if invite_url:\n            rich_console.print(f\"\\nInvite URL: {Text(invite_url, style=f'link {invite_url}')}\")\n        if not guilds:\n            rich_console.print(f\"Looking for a quick guide on setting up Red? Checkout {Text('https://start.discord.red', style='link https://start.discord.red}')}\")\n        if rich_outdated_message:\n            rich_console.print(rich_outdated_message)\n        bot._red_ready.set()\n        if outdated_red_message:\n            await send_to_owners_with_prefix_replaced(bot, outdated_red_message)\n\n    @bot.event\n    async def on_command_completion(ctx: commands.Context):\n        await bot._delete_delay(ctx)\n\n    @bot.event\n    async def on_command_error(ctx, error, unhandled_by_cog=False):\n        if not unhandled_by_cog:\n            if hasattr(ctx.command, 'on_error'):\n                return\n            if ctx.cog:\n                if ctx.cog.has_error_handler():\n                    return\n        if not isinstance(error, commands.CommandNotFound):\n            asyncio.create_task(bot._delete_delay(ctx))\n        converter = getattr(ctx.current_parameter, 'converter', None)\n        argument = ctx.current_argument\n        if isinstance(error, commands.MissingRequiredArgument):\n            await ctx.send_help()\n        elif isinstance(error, commands.ArgParserFailure):\n            msg = _('`{user_input}` is not a valid value for `{command}`').format(user_input=error.user_input, command=error.cmd)\n            if error.custom_help_msg:\n                msg += f'\\n{error.custom_help_msg}'\n            await ctx.send(msg)\n            if error.send_cmd_help:\n                await ctx.send_help()\n        elif isinstance(error, commands.RangeError):\n            if isinstance(error.value, int):\n                if error.minimum == 0 and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a positive integer.')\n                elif error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be an integer no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be an integer no less than {minimum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be an integer between {minimum} and {maximum}.')\n            elif isinstance(error.value, float):\n                if error.minimum == 0 and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a positive number.')\n                elif error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be a number no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a number no less than {maximum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be a number between {minimum} and {maximum}.')\n            elif isinstance(error.value, str):\n                if error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of no less than {minimum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of between {minimum} and {maximum}.')\n            await ctx.send(message.format(maximum=error.maximum, minimum=error.minimum, parameter_name=ctx.current_parameter.name))\n            return\n        elif isinstance(error, commands.BadArgument):\n            if isinstance(converter, commands.Range):\n                if converter.annotation is int:\n                    if converter.min == 0 and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a positive integer.')\n                    elif converter.min is None and converter.max is not None:\n                        message = _('Argument `{parameter_name}` must be an integer no more than {maximum}.')\n                    elif converter.min is not None and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be an integer no less than {minimum}.')\n                    elif converter.max is not None and converter.min is not None:\n                        message = _('Argument `{parameter_name}` must be an integer between {minimum} and {maximum}.')\n                elif converter.annotation is float:\n                    if converter.min == 0 and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a positive number.')\n                    elif converter.min is None and converter.max is not None:\n                        message = _('Argument `{parameter_name}` must be a number no more than {maximum}.')\n                    elif converter.min is not None and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a number no less than {minimum}.')\n                    elif converter.max is not None and converter.min is not None:\n                        message = _('Argument `{parameter_name}` must be a number between {minimum} and {maximum}.')\n                elif converter.annotation is str:\n                    if error.minimum is None and error.maximum is not None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of no more than {maximum}.')\n                    elif error.minimum is not None and error.maximum is None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of no less than {minimum}.')\n                    elif error.maximum is not None and error.minimum is not None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of between {minimum} and {maximum}.')\n                await ctx.send(message.format(maximum=converter.max, minimum=converter.min, parameter_name=ctx.current_parameter.name))\n                return\n            if isinstance(error.__cause__, ValueError):\n                if converter is int:\n                    await ctx.send(_('\"{argument}\" is not an integer.').format(argument=argument))\n                    return\n                if converter is float:\n                    await ctx.send(_('\"{argument}\" is not a number.').format(argument=argument))\n                    return\n            if error.args:\n                await ctx.send(error.args[0])\n            else:\n                await ctx.send_help()\n        elif isinstance(error, commands.UserInputError):\n            await ctx.send_help()\n        elif isinstance(error, commands.DisabledCommand):\n            disabled_message = await bot._config.disabled_command_msg()\n            if disabled_message:\n                await ctx.send(disabled_message.replace('{command}', ctx.invoked_with))\n        elif isinstance(error, commands.CommandInvokeError):\n            log.exception(\"Exception in command '{}'\".format(ctx.command.qualified_name), exc_info=error.original)\n            exception_log = \"Exception in command '{}'\\n\".format(ctx.command.qualified_name)\n            exception_log += ''.join(traceback.format_exception(type(error), error, error.__traceback__))\n            bot._last_exception = exception_log\n            message = await bot._config.invoke_error_msg()\n            if not message:\n                if ctx.author.id in bot.owner_ids:\n                    message = inline(_(\"Error in command '{command}'. Check your console or logs for details.\"))\n                else:\n                    message = inline(_(\"Error in command '{command}'.\"))\n            await ctx.send(message.replace('{command}', ctx.command.qualified_name))\n        elif isinstance(error, commands.CommandNotFound):\n            help_settings = await HelpSettings.from_context(ctx)\n            fuzzy_commands = await fuzzy_command_search(ctx, commands=RedHelpFormatter.help_filter_func(ctx, bot.walk_commands(), help_settings=help_settings))\n            if not fuzzy_commands:\n                pass\n            elif await ctx.embed_requested():\n                await ctx.send(embed=await format_fuzzy_results(ctx, fuzzy_commands, embed=True))\n            else:\n                await ctx.send(await format_fuzzy_results(ctx, fuzzy_commands, embed=False))\n        elif isinstance(error, commands.BotMissingPermissions):\n            if bin(error.missing.value).count('1') == 1:\n                msg = _('I require the {permission} permission to execute that command.').format(permission=format_perms_list(error.missing))\n            else:\n                msg = _('I require {permission_list} permissions to execute that command.').format(permission_list=format_perms_list(error.missing))\n            await ctx.send(msg)\n        elif isinstance(error, commands.UserFeedbackCheckFailure):\n            if error.message:\n                await ctx.send(error.message)\n        elif isinstance(error, commands.NoPrivateMessage):\n            await ctx.send(_('That command is not available in DMs.'))\n        elif isinstance(error, commands.PrivateMessageOnly):\n            await ctx.send(_('That command is only available in DMs.'))\n        elif isinstance(error, commands.NSFWChannelRequired):\n            await ctx.send(_('That command is only available in NSFW channels.'))\n        elif isinstance(error, commands.CheckFailure):\n            pass\n        elif isinstance(error, commands.CommandOnCooldown):\n            if bot._bypass_cooldowns and ctx.author.id in bot.owner_ids:\n                ctx.command.reset_cooldown(ctx)\n                new_ctx = await bot.get_context(ctx.message)\n                await bot.invoke(new_ctx)\n                return\n            relative_time = discord.utils.format_dt(datetime.now(timezone.utc) + timedelta(seconds=error.retry_after), 'R')\n            msg = _('This command is on cooldown. Try again {relative_time}.').format(relative_time=relative_time)\n            await ctx.send(msg, delete_after=error.retry_after)\n        elif isinstance(error, commands.MaxConcurrencyReached):\n            if error.per is commands.BucketType.default:\n                if error.number > 1:\n                    msg = _('Too many people using this command. It can only be used {number} times concurrently.').format(number=error.number)\n                else:\n                    msg = _('Too many people using this command. It can only be used once concurrently.')\n            elif error.per in (commands.BucketType.user, commands.BucketType.member):\n                if error.number > 1:\n                    msg = _('That command is still completing, it can only be used {number} times per {type} concurrently.').format(number=error.number, type=error.per.name)\n                else:\n                    msg = _('That command is still completing, it can only be used once per {type} concurrently.').format(type=error.per.name)\n            elif error.number > 1:\n                msg = _('Too many people using this command. It can only be used {number} times per {type} concurrently.').format(number=error.number, type=error.per.name)\n            else:\n                msg = _('Too many people using this command. It can only be used once per {type} concurrently.').format(type=error.per.name)\n            await ctx.send(msg)\n        else:\n            log.exception(type(error).__name__, exc_info=error)\n\n    @bot.event\n    async def on_message(message, /):\n        await set_contextual_locales_from_guild(bot, message.guild)\n        await bot.process_commands(message)\n        discord_now = message.created_at\n        if not bot._checked_time_accuracy or discord_now - timedelta(minutes=60) > bot._checked_time_accuracy:\n            system_now = datetime.now(timezone.utc)\n            diff = abs((discord_now - system_now).total_seconds())\n            if diff > 60:\n                log.warning(\"Detected significant difference (%d seconds) in system clock to discord's clock. Any time sensitive code may fail.\", diff)\n            bot._checked_time_accuracy = discord_now\n\n    @bot.event\n    async def on_command_add(command: commands.Command):\n        if command.cog is not None:\n            return\n        await _disable_command_no_cog(command)\n\n    async def _guild_added(guild: discord.Guild):\n        disabled_commands = await bot._config.guild(guild).disabled_commands()\n        for command_name in disabled_commands:\n            command_obj = bot.get_command(command_name)\n            if command_obj is not None:\n                command_obj.disable_in(guild)\n\n    @bot.event\n    async def on_guild_join(guild: discord.Guild):\n        await _guild_added(guild)\n\n    @bot.event\n    async def on_guild_available(guild: discord.Guild):\n        await _guild_added(guild)\n\n    @bot.event\n    async def on_guild_remove(guild: discord.Guild):\n        disabled_commands = await bot._config.guild(guild).disabled_commands()\n        for command_name in disabled_commands:\n            command_obj = bot.get_command(command_name)\n            if command_obj is not None:\n                command_obj.enable_in(guild)\n\n    @bot.event\n    async def on_cog_add(cog: commands.Cog):\n        confs = get_latest_confs()\n        for c in confs:\n            uuid = c.unique_identifier\n            group_data = c.custom_groups\n            await bot._config.custom('CUSTOM_GROUPS', c.cog_name, uuid).set(group_data)\n        await _disable_commands_cog(cog)\n\n    async def _disable_command(command: commands.Command, global_disabled: list, guilds_data: dict):\n        if command.qualified_name in global_disabled:\n            command.enabled = False\n        for (guild_id, data) in guilds_data.items():\n            guild_disabled_cmds = data.get('disabled_commands', [])\n            if command.qualified_name in guild_disabled_cmds:\n                command.disable_in(discord.Object(id=guild_id))\n\n    async def _disable_commands_cog(cog: commands.Cog):\n        global_disabled = await bot._config.disabled_commands()\n        guilds_data = await bot._config.all_guilds()\n        for command in cog.walk_commands():\n            await _disable_command(command, global_disabled, guilds_data)\n\n    async def _disable_command_no_cog(command: commands.Command):\n        global_disabled = await bot._config.disabled_commands()\n        guilds_data = await bot._config.all_guilds()\n        await _disable_command(command, global_disabled, guilds_data)",
            "def init_events(bot, cli_flags):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    @bot.event\n    async def on_connect():\n        if bot._uptime is None:\n            log.info('Connected to Discord. Getting ready...')\n\n    @bot.event\n    async def on_ready():\n        try:\n            await _on_ready()\n        except Exception as exc:\n            log.critical('The bot failed to get ready!', exc_info=exc)\n            sys.exit(ExitCodes.CRITICAL)\n\n    async def _on_ready():\n        if bot._uptime is not None:\n            return\n        bot._uptime = datetime.utcnow()\n        guilds = len(bot.guilds)\n        users = len(set([m for m in bot.get_all_members()]))\n        invite_url = discord.utils.oauth_url(bot.application_id, scopes=('bot',))\n        prefixes = cli_flags.prefix or await bot._config.prefix()\n        lang = await bot._config.locale()\n        dpy_version = discord.__version__\n        table_general_info = Table(show_edge=False, show_header=False, box=box.MINIMAL)\n        table_general_info.add_row('Prefixes', ', '.join(prefixes))\n        table_general_info.add_row('Language', lang)\n        table_general_info.add_row('Red version', red_version)\n        table_general_info.add_row('Discord.py version', dpy_version)\n        table_general_info.add_row('Storage type', data_manager.storage_type())\n        table_counts = Table(show_edge=False, show_header=False, box=box.MINIMAL)\n        table_counts.add_row('Shards', str(bot.shard_count))\n        table_counts.add_row('Servers', str(guilds))\n        if bot.intents.members:\n            table_counts.add_row('Unique Users', str(users))\n        outdated_red_message = ''\n        rich_outdated_message = ''\n        (pypi_version, py_version_req) = await fetch_latest_red_version_info()\n        outdated = pypi_version and pypi_version > red_version_info\n        if outdated:\n            (outdated_red_message, rich_outdated_message) = get_outdated_red_messages(pypi_version, py_version_req)\n        rich_console = rich.get_console()\n        rich_console.print(INTRO, style='red', markup=False, highlight=False)\n        if guilds:\n            rich_console.print(Columns([Panel(table_general_info, title=bot.user.display_name), Panel(table_counts)], equal=True, align='center'))\n        else:\n            rich_console.print(Columns([Panel(table_general_info, title=bot.user.display_name)]))\n        rich_console.print('Loaded {} cogs with {} commands'.format(len(bot.cogs), len(bot.commands)))\n        if invite_url:\n            rich_console.print(f\"\\nInvite URL: {Text(invite_url, style=f'link {invite_url}')}\")\n        if not guilds:\n            rich_console.print(f\"Looking for a quick guide on setting up Red? Checkout {Text('https://start.discord.red', style='link https://start.discord.red}')}\")\n        if rich_outdated_message:\n            rich_console.print(rich_outdated_message)\n        bot._red_ready.set()\n        if outdated_red_message:\n            await send_to_owners_with_prefix_replaced(bot, outdated_red_message)\n\n    @bot.event\n    async def on_command_completion(ctx: commands.Context):\n        await bot._delete_delay(ctx)\n\n    @bot.event\n    async def on_command_error(ctx, error, unhandled_by_cog=False):\n        if not unhandled_by_cog:\n            if hasattr(ctx.command, 'on_error'):\n                return\n            if ctx.cog:\n                if ctx.cog.has_error_handler():\n                    return\n        if not isinstance(error, commands.CommandNotFound):\n            asyncio.create_task(bot._delete_delay(ctx))\n        converter = getattr(ctx.current_parameter, 'converter', None)\n        argument = ctx.current_argument\n        if isinstance(error, commands.MissingRequiredArgument):\n            await ctx.send_help()\n        elif isinstance(error, commands.ArgParserFailure):\n            msg = _('`{user_input}` is not a valid value for `{command}`').format(user_input=error.user_input, command=error.cmd)\n            if error.custom_help_msg:\n                msg += f'\\n{error.custom_help_msg}'\n            await ctx.send(msg)\n            if error.send_cmd_help:\n                await ctx.send_help()\n        elif isinstance(error, commands.RangeError):\n            if isinstance(error.value, int):\n                if error.minimum == 0 and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a positive integer.')\n                elif error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be an integer no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be an integer no less than {minimum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be an integer between {minimum} and {maximum}.')\n            elif isinstance(error.value, float):\n                if error.minimum == 0 and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a positive number.')\n                elif error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be a number no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a number no less than {maximum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be a number between {minimum} and {maximum}.')\n            elif isinstance(error.value, str):\n                if error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of no less than {minimum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of between {minimum} and {maximum}.')\n            await ctx.send(message.format(maximum=error.maximum, minimum=error.minimum, parameter_name=ctx.current_parameter.name))\n            return\n        elif isinstance(error, commands.BadArgument):\n            if isinstance(converter, commands.Range):\n                if converter.annotation is int:\n                    if converter.min == 0 and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a positive integer.')\n                    elif converter.min is None and converter.max is not None:\n                        message = _('Argument `{parameter_name}` must be an integer no more than {maximum}.')\n                    elif converter.min is not None and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be an integer no less than {minimum}.')\n                    elif converter.max is not None and converter.min is not None:\n                        message = _('Argument `{parameter_name}` must be an integer between {minimum} and {maximum}.')\n                elif converter.annotation is float:\n                    if converter.min == 0 and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a positive number.')\n                    elif converter.min is None and converter.max is not None:\n                        message = _('Argument `{parameter_name}` must be a number no more than {maximum}.')\n                    elif converter.min is not None and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a number no less than {minimum}.')\n                    elif converter.max is not None and converter.min is not None:\n                        message = _('Argument `{parameter_name}` must be a number between {minimum} and {maximum}.')\n                elif converter.annotation is str:\n                    if error.minimum is None and error.maximum is not None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of no more than {maximum}.')\n                    elif error.minimum is not None and error.maximum is None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of no less than {minimum}.')\n                    elif error.maximum is not None and error.minimum is not None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of between {minimum} and {maximum}.')\n                await ctx.send(message.format(maximum=converter.max, minimum=converter.min, parameter_name=ctx.current_parameter.name))\n                return\n            if isinstance(error.__cause__, ValueError):\n                if converter is int:\n                    await ctx.send(_('\"{argument}\" is not an integer.').format(argument=argument))\n                    return\n                if converter is float:\n                    await ctx.send(_('\"{argument}\" is not a number.').format(argument=argument))\n                    return\n            if error.args:\n                await ctx.send(error.args[0])\n            else:\n                await ctx.send_help()\n        elif isinstance(error, commands.UserInputError):\n            await ctx.send_help()\n        elif isinstance(error, commands.DisabledCommand):\n            disabled_message = await bot._config.disabled_command_msg()\n            if disabled_message:\n                await ctx.send(disabled_message.replace('{command}', ctx.invoked_with))\n        elif isinstance(error, commands.CommandInvokeError):\n            log.exception(\"Exception in command '{}'\".format(ctx.command.qualified_name), exc_info=error.original)\n            exception_log = \"Exception in command '{}'\\n\".format(ctx.command.qualified_name)\n            exception_log += ''.join(traceback.format_exception(type(error), error, error.__traceback__))\n            bot._last_exception = exception_log\n            message = await bot._config.invoke_error_msg()\n            if not message:\n                if ctx.author.id in bot.owner_ids:\n                    message = inline(_(\"Error in command '{command}'. Check your console or logs for details.\"))\n                else:\n                    message = inline(_(\"Error in command '{command}'.\"))\n            await ctx.send(message.replace('{command}', ctx.command.qualified_name))\n        elif isinstance(error, commands.CommandNotFound):\n            help_settings = await HelpSettings.from_context(ctx)\n            fuzzy_commands = await fuzzy_command_search(ctx, commands=RedHelpFormatter.help_filter_func(ctx, bot.walk_commands(), help_settings=help_settings))\n            if not fuzzy_commands:\n                pass\n            elif await ctx.embed_requested():\n                await ctx.send(embed=await format_fuzzy_results(ctx, fuzzy_commands, embed=True))\n            else:\n                await ctx.send(await format_fuzzy_results(ctx, fuzzy_commands, embed=False))\n        elif isinstance(error, commands.BotMissingPermissions):\n            if bin(error.missing.value).count('1') == 1:\n                msg = _('I require the {permission} permission to execute that command.').format(permission=format_perms_list(error.missing))\n            else:\n                msg = _('I require {permission_list} permissions to execute that command.').format(permission_list=format_perms_list(error.missing))\n            await ctx.send(msg)\n        elif isinstance(error, commands.UserFeedbackCheckFailure):\n            if error.message:\n                await ctx.send(error.message)\n        elif isinstance(error, commands.NoPrivateMessage):\n            await ctx.send(_('That command is not available in DMs.'))\n        elif isinstance(error, commands.PrivateMessageOnly):\n            await ctx.send(_('That command is only available in DMs.'))\n        elif isinstance(error, commands.NSFWChannelRequired):\n            await ctx.send(_('That command is only available in NSFW channels.'))\n        elif isinstance(error, commands.CheckFailure):\n            pass\n        elif isinstance(error, commands.CommandOnCooldown):\n            if bot._bypass_cooldowns and ctx.author.id in bot.owner_ids:\n                ctx.command.reset_cooldown(ctx)\n                new_ctx = await bot.get_context(ctx.message)\n                await bot.invoke(new_ctx)\n                return\n            relative_time = discord.utils.format_dt(datetime.now(timezone.utc) + timedelta(seconds=error.retry_after), 'R')\n            msg = _('This command is on cooldown. Try again {relative_time}.').format(relative_time=relative_time)\n            await ctx.send(msg, delete_after=error.retry_after)\n        elif isinstance(error, commands.MaxConcurrencyReached):\n            if error.per is commands.BucketType.default:\n                if error.number > 1:\n                    msg = _('Too many people using this command. It can only be used {number} times concurrently.').format(number=error.number)\n                else:\n                    msg = _('Too many people using this command. It can only be used once concurrently.')\n            elif error.per in (commands.BucketType.user, commands.BucketType.member):\n                if error.number > 1:\n                    msg = _('That command is still completing, it can only be used {number} times per {type} concurrently.').format(number=error.number, type=error.per.name)\n                else:\n                    msg = _('That command is still completing, it can only be used once per {type} concurrently.').format(type=error.per.name)\n            elif error.number > 1:\n                msg = _('Too many people using this command. It can only be used {number} times per {type} concurrently.').format(number=error.number, type=error.per.name)\n            else:\n                msg = _('Too many people using this command. It can only be used once per {type} concurrently.').format(type=error.per.name)\n            await ctx.send(msg)\n        else:\n            log.exception(type(error).__name__, exc_info=error)\n\n    @bot.event\n    async def on_message(message, /):\n        await set_contextual_locales_from_guild(bot, message.guild)\n        await bot.process_commands(message)\n        discord_now = message.created_at\n        if not bot._checked_time_accuracy or discord_now - timedelta(minutes=60) > bot._checked_time_accuracy:\n            system_now = datetime.now(timezone.utc)\n            diff = abs((discord_now - system_now).total_seconds())\n            if diff > 60:\n                log.warning(\"Detected significant difference (%d seconds) in system clock to discord's clock. Any time sensitive code may fail.\", diff)\n            bot._checked_time_accuracy = discord_now\n\n    @bot.event\n    async def on_command_add(command: commands.Command):\n        if command.cog is not None:\n            return\n        await _disable_command_no_cog(command)\n\n    async def _guild_added(guild: discord.Guild):\n        disabled_commands = await bot._config.guild(guild).disabled_commands()\n        for command_name in disabled_commands:\n            command_obj = bot.get_command(command_name)\n            if command_obj is not None:\n                command_obj.disable_in(guild)\n\n    @bot.event\n    async def on_guild_join(guild: discord.Guild):\n        await _guild_added(guild)\n\n    @bot.event\n    async def on_guild_available(guild: discord.Guild):\n        await _guild_added(guild)\n\n    @bot.event\n    async def on_guild_remove(guild: discord.Guild):\n        disabled_commands = await bot._config.guild(guild).disabled_commands()\n        for command_name in disabled_commands:\n            command_obj = bot.get_command(command_name)\n            if command_obj is not None:\n                command_obj.enable_in(guild)\n\n    @bot.event\n    async def on_cog_add(cog: commands.Cog):\n        confs = get_latest_confs()\n        for c in confs:\n            uuid = c.unique_identifier\n            group_data = c.custom_groups\n            await bot._config.custom('CUSTOM_GROUPS', c.cog_name, uuid).set(group_data)\n        await _disable_commands_cog(cog)\n\n    async def _disable_command(command: commands.Command, global_disabled: list, guilds_data: dict):\n        if command.qualified_name in global_disabled:\n            command.enabled = False\n        for (guild_id, data) in guilds_data.items():\n            guild_disabled_cmds = data.get('disabled_commands', [])\n            if command.qualified_name in guild_disabled_cmds:\n                command.disable_in(discord.Object(id=guild_id))\n\n    async def _disable_commands_cog(cog: commands.Cog):\n        global_disabled = await bot._config.disabled_commands()\n        guilds_data = await bot._config.all_guilds()\n        for command in cog.walk_commands():\n            await _disable_command(command, global_disabled, guilds_data)\n\n    async def _disable_command_no_cog(command: commands.Command):\n        global_disabled = await bot._config.disabled_commands()\n        guilds_data = await bot._config.all_guilds()\n        await _disable_command(command, global_disabled, guilds_data)",
            "def init_events(bot, cli_flags):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    @bot.event\n    async def on_connect():\n        if bot._uptime is None:\n            log.info('Connected to Discord. Getting ready...')\n\n    @bot.event\n    async def on_ready():\n        try:\n            await _on_ready()\n        except Exception as exc:\n            log.critical('The bot failed to get ready!', exc_info=exc)\n            sys.exit(ExitCodes.CRITICAL)\n\n    async def _on_ready():\n        if bot._uptime is not None:\n            return\n        bot._uptime = datetime.utcnow()\n        guilds = len(bot.guilds)\n        users = len(set([m for m in bot.get_all_members()]))\n        invite_url = discord.utils.oauth_url(bot.application_id, scopes=('bot',))\n        prefixes = cli_flags.prefix or await bot._config.prefix()\n        lang = await bot._config.locale()\n        dpy_version = discord.__version__\n        table_general_info = Table(show_edge=False, show_header=False, box=box.MINIMAL)\n        table_general_info.add_row('Prefixes', ', '.join(prefixes))\n        table_general_info.add_row('Language', lang)\n        table_general_info.add_row('Red version', red_version)\n        table_general_info.add_row('Discord.py version', dpy_version)\n        table_general_info.add_row('Storage type', data_manager.storage_type())\n        table_counts = Table(show_edge=False, show_header=False, box=box.MINIMAL)\n        table_counts.add_row('Shards', str(bot.shard_count))\n        table_counts.add_row('Servers', str(guilds))\n        if bot.intents.members:\n            table_counts.add_row('Unique Users', str(users))\n        outdated_red_message = ''\n        rich_outdated_message = ''\n        (pypi_version, py_version_req) = await fetch_latest_red_version_info()\n        outdated = pypi_version and pypi_version > red_version_info\n        if outdated:\n            (outdated_red_message, rich_outdated_message) = get_outdated_red_messages(pypi_version, py_version_req)\n        rich_console = rich.get_console()\n        rich_console.print(INTRO, style='red', markup=False, highlight=False)\n        if guilds:\n            rich_console.print(Columns([Panel(table_general_info, title=bot.user.display_name), Panel(table_counts)], equal=True, align='center'))\n        else:\n            rich_console.print(Columns([Panel(table_general_info, title=bot.user.display_name)]))\n        rich_console.print('Loaded {} cogs with {} commands'.format(len(bot.cogs), len(bot.commands)))\n        if invite_url:\n            rich_console.print(f\"\\nInvite URL: {Text(invite_url, style=f'link {invite_url}')}\")\n        if not guilds:\n            rich_console.print(f\"Looking for a quick guide on setting up Red? Checkout {Text('https://start.discord.red', style='link https://start.discord.red}')}\")\n        if rich_outdated_message:\n            rich_console.print(rich_outdated_message)\n        bot._red_ready.set()\n        if outdated_red_message:\n            await send_to_owners_with_prefix_replaced(bot, outdated_red_message)\n\n    @bot.event\n    async def on_command_completion(ctx: commands.Context):\n        await bot._delete_delay(ctx)\n\n    @bot.event\n    async def on_command_error(ctx, error, unhandled_by_cog=False):\n        if not unhandled_by_cog:\n            if hasattr(ctx.command, 'on_error'):\n                return\n            if ctx.cog:\n                if ctx.cog.has_error_handler():\n                    return\n        if not isinstance(error, commands.CommandNotFound):\n            asyncio.create_task(bot._delete_delay(ctx))\n        converter = getattr(ctx.current_parameter, 'converter', None)\n        argument = ctx.current_argument\n        if isinstance(error, commands.MissingRequiredArgument):\n            await ctx.send_help()\n        elif isinstance(error, commands.ArgParserFailure):\n            msg = _('`{user_input}` is not a valid value for `{command}`').format(user_input=error.user_input, command=error.cmd)\n            if error.custom_help_msg:\n                msg += f'\\n{error.custom_help_msg}'\n            await ctx.send(msg)\n            if error.send_cmd_help:\n                await ctx.send_help()\n        elif isinstance(error, commands.RangeError):\n            if isinstance(error.value, int):\n                if error.minimum == 0 and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a positive integer.')\n                elif error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be an integer no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be an integer no less than {minimum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be an integer between {minimum} and {maximum}.')\n            elif isinstance(error.value, float):\n                if error.minimum == 0 and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a positive number.')\n                elif error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be a number no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a number no less than {maximum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be a number between {minimum} and {maximum}.')\n            elif isinstance(error.value, str):\n                if error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of no less than {minimum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of between {minimum} and {maximum}.')\n            await ctx.send(message.format(maximum=error.maximum, minimum=error.minimum, parameter_name=ctx.current_parameter.name))\n            return\n        elif isinstance(error, commands.BadArgument):\n            if isinstance(converter, commands.Range):\n                if converter.annotation is int:\n                    if converter.min == 0 and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a positive integer.')\n                    elif converter.min is None and converter.max is not None:\n                        message = _('Argument `{parameter_name}` must be an integer no more than {maximum}.')\n                    elif converter.min is not None and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be an integer no less than {minimum}.')\n                    elif converter.max is not None and converter.min is not None:\n                        message = _('Argument `{parameter_name}` must be an integer between {minimum} and {maximum}.')\n                elif converter.annotation is float:\n                    if converter.min == 0 and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a positive number.')\n                    elif converter.min is None and converter.max is not None:\n                        message = _('Argument `{parameter_name}` must be a number no more than {maximum}.')\n                    elif converter.min is not None and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a number no less than {minimum}.')\n                    elif converter.max is not None and converter.min is not None:\n                        message = _('Argument `{parameter_name}` must be a number between {minimum} and {maximum}.')\n                elif converter.annotation is str:\n                    if error.minimum is None and error.maximum is not None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of no more than {maximum}.')\n                    elif error.minimum is not None and error.maximum is None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of no less than {minimum}.')\n                    elif error.maximum is not None and error.minimum is not None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of between {minimum} and {maximum}.')\n                await ctx.send(message.format(maximum=converter.max, minimum=converter.min, parameter_name=ctx.current_parameter.name))\n                return\n            if isinstance(error.__cause__, ValueError):\n                if converter is int:\n                    await ctx.send(_('\"{argument}\" is not an integer.').format(argument=argument))\n                    return\n                if converter is float:\n                    await ctx.send(_('\"{argument}\" is not a number.').format(argument=argument))\n                    return\n            if error.args:\n                await ctx.send(error.args[0])\n            else:\n                await ctx.send_help()\n        elif isinstance(error, commands.UserInputError):\n            await ctx.send_help()\n        elif isinstance(error, commands.DisabledCommand):\n            disabled_message = await bot._config.disabled_command_msg()\n            if disabled_message:\n                await ctx.send(disabled_message.replace('{command}', ctx.invoked_with))\n        elif isinstance(error, commands.CommandInvokeError):\n            log.exception(\"Exception in command '{}'\".format(ctx.command.qualified_name), exc_info=error.original)\n            exception_log = \"Exception in command '{}'\\n\".format(ctx.command.qualified_name)\n            exception_log += ''.join(traceback.format_exception(type(error), error, error.__traceback__))\n            bot._last_exception = exception_log\n            message = await bot._config.invoke_error_msg()\n            if not message:\n                if ctx.author.id in bot.owner_ids:\n                    message = inline(_(\"Error in command '{command}'. Check your console or logs for details.\"))\n                else:\n                    message = inline(_(\"Error in command '{command}'.\"))\n            await ctx.send(message.replace('{command}', ctx.command.qualified_name))\n        elif isinstance(error, commands.CommandNotFound):\n            help_settings = await HelpSettings.from_context(ctx)\n            fuzzy_commands = await fuzzy_command_search(ctx, commands=RedHelpFormatter.help_filter_func(ctx, bot.walk_commands(), help_settings=help_settings))\n            if not fuzzy_commands:\n                pass\n            elif await ctx.embed_requested():\n                await ctx.send(embed=await format_fuzzy_results(ctx, fuzzy_commands, embed=True))\n            else:\n                await ctx.send(await format_fuzzy_results(ctx, fuzzy_commands, embed=False))\n        elif isinstance(error, commands.BotMissingPermissions):\n            if bin(error.missing.value).count('1') == 1:\n                msg = _('I require the {permission} permission to execute that command.').format(permission=format_perms_list(error.missing))\n            else:\n                msg = _('I require {permission_list} permissions to execute that command.').format(permission_list=format_perms_list(error.missing))\n            await ctx.send(msg)\n        elif isinstance(error, commands.UserFeedbackCheckFailure):\n            if error.message:\n                await ctx.send(error.message)\n        elif isinstance(error, commands.NoPrivateMessage):\n            await ctx.send(_('That command is not available in DMs.'))\n        elif isinstance(error, commands.PrivateMessageOnly):\n            await ctx.send(_('That command is only available in DMs.'))\n        elif isinstance(error, commands.NSFWChannelRequired):\n            await ctx.send(_('That command is only available in NSFW channels.'))\n        elif isinstance(error, commands.CheckFailure):\n            pass\n        elif isinstance(error, commands.CommandOnCooldown):\n            if bot._bypass_cooldowns and ctx.author.id in bot.owner_ids:\n                ctx.command.reset_cooldown(ctx)\n                new_ctx = await bot.get_context(ctx.message)\n                await bot.invoke(new_ctx)\n                return\n            relative_time = discord.utils.format_dt(datetime.now(timezone.utc) + timedelta(seconds=error.retry_after), 'R')\n            msg = _('This command is on cooldown. Try again {relative_time}.').format(relative_time=relative_time)\n            await ctx.send(msg, delete_after=error.retry_after)\n        elif isinstance(error, commands.MaxConcurrencyReached):\n            if error.per is commands.BucketType.default:\n                if error.number > 1:\n                    msg = _('Too many people using this command. It can only be used {number} times concurrently.').format(number=error.number)\n                else:\n                    msg = _('Too many people using this command. It can only be used once concurrently.')\n            elif error.per in (commands.BucketType.user, commands.BucketType.member):\n                if error.number > 1:\n                    msg = _('That command is still completing, it can only be used {number} times per {type} concurrently.').format(number=error.number, type=error.per.name)\n                else:\n                    msg = _('That command is still completing, it can only be used once per {type} concurrently.').format(type=error.per.name)\n            elif error.number > 1:\n                msg = _('Too many people using this command. It can only be used {number} times per {type} concurrently.').format(number=error.number, type=error.per.name)\n            else:\n                msg = _('Too many people using this command. It can only be used once per {type} concurrently.').format(type=error.per.name)\n            await ctx.send(msg)\n        else:\n            log.exception(type(error).__name__, exc_info=error)\n\n    @bot.event\n    async def on_message(message, /):\n        await set_contextual_locales_from_guild(bot, message.guild)\n        await bot.process_commands(message)\n        discord_now = message.created_at\n        if not bot._checked_time_accuracy or discord_now - timedelta(minutes=60) > bot._checked_time_accuracy:\n            system_now = datetime.now(timezone.utc)\n            diff = abs((discord_now - system_now).total_seconds())\n            if diff > 60:\n                log.warning(\"Detected significant difference (%d seconds) in system clock to discord's clock. Any time sensitive code may fail.\", diff)\n            bot._checked_time_accuracy = discord_now\n\n    @bot.event\n    async def on_command_add(command: commands.Command):\n        if command.cog is not None:\n            return\n        await _disable_command_no_cog(command)\n\n    async def _guild_added(guild: discord.Guild):\n        disabled_commands = await bot._config.guild(guild).disabled_commands()\n        for command_name in disabled_commands:\n            command_obj = bot.get_command(command_name)\n            if command_obj is not None:\n                command_obj.disable_in(guild)\n\n    @bot.event\n    async def on_guild_join(guild: discord.Guild):\n        await _guild_added(guild)\n\n    @bot.event\n    async def on_guild_available(guild: discord.Guild):\n        await _guild_added(guild)\n\n    @bot.event\n    async def on_guild_remove(guild: discord.Guild):\n        disabled_commands = await bot._config.guild(guild).disabled_commands()\n        for command_name in disabled_commands:\n            command_obj = bot.get_command(command_name)\n            if command_obj is not None:\n                command_obj.enable_in(guild)\n\n    @bot.event\n    async def on_cog_add(cog: commands.Cog):\n        confs = get_latest_confs()\n        for c in confs:\n            uuid = c.unique_identifier\n            group_data = c.custom_groups\n            await bot._config.custom('CUSTOM_GROUPS', c.cog_name, uuid).set(group_data)\n        await _disable_commands_cog(cog)\n\n    async def _disable_command(command: commands.Command, global_disabled: list, guilds_data: dict):\n        if command.qualified_name in global_disabled:\n            command.enabled = False\n        for (guild_id, data) in guilds_data.items():\n            guild_disabled_cmds = data.get('disabled_commands', [])\n            if command.qualified_name in guild_disabled_cmds:\n                command.disable_in(discord.Object(id=guild_id))\n\n    async def _disable_commands_cog(cog: commands.Cog):\n        global_disabled = await bot._config.disabled_commands()\n        guilds_data = await bot._config.all_guilds()\n        for command in cog.walk_commands():\n            await _disable_command(command, global_disabled, guilds_data)\n\n    async def _disable_command_no_cog(command: commands.Command):\n        global_disabled = await bot._config.disabled_commands()\n        guilds_data = await bot._config.all_guilds()\n        await _disable_command(command, global_disabled, guilds_data)",
            "def init_events(bot, cli_flags):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    @bot.event\n    async def on_connect():\n        if bot._uptime is None:\n            log.info('Connected to Discord. Getting ready...')\n\n    @bot.event\n    async def on_ready():\n        try:\n            await _on_ready()\n        except Exception as exc:\n            log.critical('The bot failed to get ready!', exc_info=exc)\n            sys.exit(ExitCodes.CRITICAL)\n\n    async def _on_ready():\n        if bot._uptime is not None:\n            return\n        bot._uptime = datetime.utcnow()\n        guilds = len(bot.guilds)\n        users = len(set([m for m in bot.get_all_members()]))\n        invite_url = discord.utils.oauth_url(bot.application_id, scopes=('bot',))\n        prefixes = cli_flags.prefix or await bot._config.prefix()\n        lang = await bot._config.locale()\n        dpy_version = discord.__version__\n        table_general_info = Table(show_edge=False, show_header=False, box=box.MINIMAL)\n        table_general_info.add_row('Prefixes', ', '.join(prefixes))\n        table_general_info.add_row('Language', lang)\n        table_general_info.add_row('Red version', red_version)\n        table_general_info.add_row('Discord.py version', dpy_version)\n        table_general_info.add_row('Storage type', data_manager.storage_type())\n        table_counts = Table(show_edge=False, show_header=False, box=box.MINIMAL)\n        table_counts.add_row('Shards', str(bot.shard_count))\n        table_counts.add_row('Servers', str(guilds))\n        if bot.intents.members:\n            table_counts.add_row('Unique Users', str(users))\n        outdated_red_message = ''\n        rich_outdated_message = ''\n        (pypi_version, py_version_req) = await fetch_latest_red_version_info()\n        outdated = pypi_version and pypi_version > red_version_info\n        if outdated:\n            (outdated_red_message, rich_outdated_message) = get_outdated_red_messages(pypi_version, py_version_req)\n        rich_console = rich.get_console()\n        rich_console.print(INTRO, style='red', markup=False, highlight=False)\n        if guilds:\n            rich_console.print(Columns([Panel(table_general_info, title=bot.user.display_name), Panel(table_counts)], equal=True, align='center'))\n        else:\n            rich_console.print(Columns([Panel(table_general_info, title=bot.user.display_name)]))\n        rich_console.print('Loaded {} cogs with {} commands'.format(len(bot.cogs), len(bot.commands)))\n        if invite_url:\n            rich_console.print(f\"\\nInvite URL: {Text(invite_url, style=f'link {invite_url}')}\")\n        if not guilds:\n            rich_console.print(f\"Looking for a quick guide on setting up Red? Checkout {Text('https://start.discord.red', style='link https://start.discord.red}')}\")\n        if rich_outdated_message:\n            rich_console.print(rich_outdated_message)\n        bot._red_ready.set()\n        if outdated_red_message:\n            await send_to_owners_with_prefix_replaced(bot, outdated_red_message)\n\n    @bot.event\n    async def on_command_completion(ctx: commands.Context):\n        await bot._delete_delay(ctx)\n\n    @bot.event\n    async def on_command_error(ctx, error, unhandled_by_cog=False):\n        if not unhandled_by_cog:\n            if hasattr(ctx.command, 'on_error'):\n                return\n            if ctx.cog:\n                if ctx.cog.has_error_handler():\n                    return\n        if not isinstance(error, commands.CommandNotFound):\n            asyncio.create_task(bot._delete_delay(ctx))\n        converter = getattr(ctx.current_parameter, 'converter', None)\n        argument = ctx.current_argument\n        if isinstance(error, commands.MissingRequiredArgument):\n            await ctx.send_help()\n        elif isinstance(error, commands.ArgParserFailure):\n            msg = _('`{user_input}` is not a valid value for `{command}`').format(user_input=error.user_input, command=error.cmd)\n            if error.custom_help_msg:\n                msg += f'\\n{error.custom_help_msg}'\n            await ctx.send(msg)\n            if error.send_cmd_help:\n                await ctx.send_help()\n        elif isinstance(error, commands.RangeError):\n            if isinstance(error.value, int):\n                if error.minimum == 0 and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a positive integer.')\n                elif error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be an integer no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be an integer no less than {minimum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be an integer between {minimum} and {maximum}.')\n            elif isinstance(error.value, float):\n                if error.minimum == 0 and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a positive number.')\n                elif error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be a number no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a number no less than {maximum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be a number between {minimum} and {maximum}.')\n            elif isinstance(error.value, str):\n                if error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of no less than {minimum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of between {minimum} and {maximum}.')\n            await ctx.send(message.format(maximum=error.maximum, minimum=error.minimum, parameter_name=ctx.current_parameter.name))\n            return\n        elif isinstance(error, commands.BadArgument):\n            if isinstance(converter, commands.Range):\n                if converter.annotation is int:\n                    if converter.min == 0 and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a positive integer.')\n                    elif converter.min is None and converter.max is not None:\n                        message = _('Argument `{parameter_name}` must be an integer no more than {maximum}.')\n                    elif converter.min is not None and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be an integer no less than {minimum}.')\n                    elif converter.max is not None and converter.min is not None:\n                        message = _('Argument `{parameter_name}` must be an integer between {minimum} and {maximum}.')\n                elif converter.annotation is float:\n                    if converter.min == 0 and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a positive number.')\n                    elif converter.min is None and converter.max is not None:\n                        message = _('Argument `{parameter_name}` must be a number no more than {maximum}.')\n                    elif converter.min is not None and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a number no less than {minimum}.')\n                    elif converter.max is not None and converter.min is not None:\n                        message = _('Argument `{parameter_name}` must be a number between {minimum} and {maximum}.')\n                elif converter.annotation is str:\n                    if error.minimum is None and error.maximum is not None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of no more than {maximum}.')\n                    elif error.minimum is not None and error.maximum is None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of no less than {minimum}.')\n                    elif error.maximum is not None and error.minimum is not None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of between {minimum} and {maximum}.')\n                await ctx.send(message.format(maximum=converter.max, minimum=converter.min, parameter_name=ctx.current_parameter.name))\n                return\n            if isinstance(error.__cause__, ValueError):\n                if converter is int:\n                    await ctx.send(_('\"{argument}\" is not an integer.').format(argument=argument))\n                    return\n                if converter is float:\n                    await ctx.send(_('\"{argument}\" is not a number.').format(argument=argument))\n                    return\n            if error.args:\n                await ctx.send(error.args[0])\n            else:\n                await ctx.send_help()\n        elif isinstance(error, commands.UserInputError):\n            await ctx.send_help()\n        elif isinstance(error, commands.DisabledCommand):\n            disabled_message = await bot._config.disabled_command_msg()\n            if disabled_message:\n                await ctx.send(disabled_message.replace('{command}', ctx.invoked_with))\n        elif isinstance(error, commands.CommandInvokeError):\n            log.exception(\"Exception in command '{}'\".format(ctx.command.qualified_name), exc_info=error.original)\n            exception_log = \"Exception in command '{}'\\n\".format(ctx.command.qualified_name)\n            exception_log += ''.join(traceback.format_exception(type(error), error, error.__traceback__))\n            bot._last_exception = exception_log\n            message = await bot._config.invoke_error_msg()\n            if not message:\n                if ctx.author.id in bot.owner_ids:\n                    message = inline(_(\"Error in command '{command}'. Check your console or logs for details.\"))\n                else:\n                    message = inline(_(\"Error in command '{command}'.\"))\n            await ctx.send(message.replace('{command}', ctx.command.qualified_name))\n        elif isinstance(error, commands.CommandNotFound):\n            help_settings = await HelpSettings.from_context(ctx)\n            fuzzy_commands = await fuzzy_command_search(ctx, commands=RedHelpFormatter.help_filter_func(ctx, bot.walk_commands(), help_settings=help_settings))\n            if not fuzzy_commands:\n                pass\n            elif await ctx.embed_requested():\n                await ctx.send(embed=await format_fuzzy_results(ctx, fuzzy_commands, embed=True))\n            else:\n                await ctx.send(await format_fuzzy_results(ctx, fuzzy_commands, embed=False))\n        elif isinstance(error, commands.BotMissingPermissions):\n            if bin(error.missing.value).count('1') == 1:\n                msg = _('I require the {permission} permission to execute that command.').format(permission=format_perms_list(error.missing))\n            else:\n                msg = _('I require {permission_list} permissions to execute that command.').format(permission_list=format_perms_list(error.missing))\n            await ctx.send(msg)\n        elif isinstance(error, commands.UserFeedbackCheckFailure):\n            if error.message:\n                await ctx.send(error.message)\n        elif isinstance(error, commands.NoPrivateMessage):\n            await ctx.send(_('That command is not available in DMs.'))\n        elif isinstance(error, commands.PrivateMessageOnly):\n            await ctx.send(_('That command is only available in DMs.'))\n        elif isinstance(error, commands.NSFWChannelRequired):\n            await ctx.send(_('That command is only available in NSFW channels.'))\n        elif isinstance(error, commands.CheckFailure):\n            pass\n        elif isinstance(error, commands.CommandOnCooldown):\n            if bot._bypass_cooldowns and ctx.author.id in bot.owner_ids:\n                ctx.command.reset_cooldown(ctx)\n                new_ctx = await bot.get_context(ctx.message)\n                await bot.invoke(new_ctx)\n                return\n            relative_time = discord.utils.format_dt(datetime.now(timezone.utc) + timedelta(seconds=error.retry_after), 'R')\n            msg = _('This command is on cooldown. Try again {relative_time}.').format(relative_time=relative_time)\n            await ctx.send(msg, delete_after=error.retry_after)\n        elif isinstance(error, commands.MaxConcurrencyReached):\n            if error.per is commands.BucketType.default:\n                if error.number > 1:\n                    msg = _('Too many people using this command. It can only be used {number} times concurrently.').format(number=error.number)\n                else:\n                    msg = _('Too many people using this command. It can only be used once concurrently.')\n            elif error.per in (commands.BucketType.user, commands.BucketType.member):\n                if error.number > 1:\n                    msg = _('That command is still completing, it can only be used {number} times per {type} concurrently.').format(number=error.number, type=error.per.name)\n                else:\n                    msg = _('That command is still completing, it can only be used once per {type} concurrently.').format(type=error.per.name)\n            elif error.number > 1:\n                msg = _('Too many people using this command. It can only be used {number} times per {type} concurrently.').format(number=error.number, type=error.per.name)\n            else:\n                msg = _('Too many people using this command. It can only be used once per {type} concurrently.').format(type=error.per.name)\n            await ctx.send(msg)\n        else:\n            log.exception(type(error).__name__, exc_info=error)\n\n    @bot.event\n    async def on_message(message, /):\n        await set_contextual_locales_from_guild(bot, message.guild)\n        await bot.process_commands(message)\n        discord_now = message.created_at\n        if not bot._checked_time_accuracy or discord_now - timedelta(minutes=60) > bot._checked_time_accuracy:\n            system_now = datetime.now(timezone.utc)\n            diff = abs((discord_now - system_now).total_seconds())\n            if diff > 60:\n                log.warning(\"Detected significant difference (%d seconds) in system clock to discord's clock. Any time sensitive code may fail.\", diff)\n            bot._checked_time_accuracy = discord_now\n\n    @bot.event\n    async def on_command_add(command: commands.Command):\n        if command.cog is not None:\n            return\n        await _disable_command_no_cog(command)\n\n    async def _guild_added(guild: discord.Guild):\n        disabled_commands = await bot._config.guild(guild).disabled_commands()\n        for command_name in disabled_commands:\n            command_obj = bot.get_command(command_name)\n            if command_obj is not None:\n                command_obj.disable_in(guild)\n\n    @bot.event\n    async def on_guild_join(guild: discord.Guild):\n        await _guild_added(guild)\n\n    @bot.event\n    async def on_guild_available(guild: discord.Guild):\n        await _guild_added(guild)\n\n    @bot.event\n    async def on_guild_remove(guild: discord.Guild):\n        disabled_commands = await bot._config.guild(guild).disabled_commands()\n        for command_name in disabled_commands:\n            command_obj = bot.get_command(command_name)\n            if command_obj is not None:\n                command_obj.enable_in(guild)\n\n    @bot.event\n    async def on_cog_add(cog: commands.Cog):\n        confs = get_latest_confs()\n        for c in confs:\n            uuid = c.unique_identifier\n            group_data = c.custom_groups\n            await bot._config.custom('CUSTOM_GROUPS', c.cog_name, uuid).set(group_data)\n        await _disable_commands_cog(cog)\n\n    async def _disable_command(command: commands.Command, global_disabled: list, guilds_data: dict):\n        if command.qualified_name in global_disabled:\n            command.enabled = False\n        for (guild_id, data) in guilds_data.items():\n            guild_disabled_cmds = data.get('disabled_commands', [])\n            if command.qualified_name in guild_disabled_cmds:\n                command.disable_in(discord.Object(id=guild_id))\n\n    async def _disable_commands_cog(cog: commands.Cog):\n        global_disabled = await bot._config.disabled_commands()\n        guilds_data = await bot._config.all_guilds()\n        for command in cog.walk_commands():\n            await _disable_command(command, global_disabled, guilds_data)\n\n    async def _disable_command_no_cog(command: commands.Command):\n        global_disabled = await bot._config.disabled_commands()\n        guilds_data = await bot._config.all_guilds()\n        await _disable_command(command, global_disabled, guilds_data)",
            "def init_events(bot, cli_flags):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    @bot.event\n    async def on_connect():\n        if bot._uptime is None:\n            log.info('Connected to Discord. Getting ready...')\n\n    @bot.event\n    async def on_ready():\n        try:\n            await _on_ready()\n        except Exception as exc:\n            log.critical('The bot failed to get ready!', exc_info=exc)\n            sys.exit(ExitCodes.CRITICAL)\n\n    async def _on_ready():\n        if bot._uptime is not None:\n            return\n        bot._uptime = datetime.utcnow()\n        guilds = len(bot.guilds)\n        users = len(set([m for m in bot.get_all_members()]))\n        invite_url = discord.utils.oauth_url(bot.application_id, scopes=('bot',))\n        prefixes = cli_flags.prefix or await bot._config.prefix()\n        lang = await bot._config.locale()\n        dpy_version = discord.__version__\n        table_general_info = Table(show_edge=False, show_header=False, box=box.MINIMAL)\n        table_general_info.add_row('Prefixes', ', '.join(prefixes))\n        table_general_info.add_row('Language', lang)\n        table_general_info.add_row('Red version', red_version)\n        table_general_info.add_row('Discord.py version', dpy_version)\n        table_general_info.add_row('Storage type', data_manager.storage_type())\n        table_counts = Table(show_edge=False, show_header=False, box=box.MINIMAL)\n        table_counts.add_row('Shards', str(bot.shard_count))\n        table_counts.add_row('Servers', str(guilds))\n        if bot.intents.members:\n            table_counts.add_row('Unique Users', str(users))\n        outdated_red_message = ''\n        rich_outdated_message = ''\n        (pypi_version, py_version_req) = await fetch_latest_red_version_info()\n        outdated = pypi_version and pypi_version > red_version_info\n        if outdated:\n            (outdated_red_message, rich_outdated_message) = get_outdated_red_messages(pypi_version, py_version_req)\n        rich_console = rich.get_console()\n        rich_console.print(INTRO, style='red', markup=False, highlight=False)\n        if guilds:\n            rich_console.print(Columns([Panel(table_general_info, title=bot.user.display_name), Panel(table_counts)], equal=True, align='center'))\n        else:\n            rich_console.print(Columns([Panel(table_general_info, title=bot.user.display_name)]))\n        rich_console.print('Loaded {} cogs with {} commands'.format(len(bot.cogs), len(bot.commands)))\n        if invite_url:\n            rich_console.print(f\"\\nInvite URL: {Text(invite_url, style=f'link {invite_url}')}\")\n        if not guilds:\n            rich_console.print(f\"Looking for a quick guide on setting up Red? Checkout {Text('https://start.discord.red', style='link https://start.discord.red}')}\")\n        if rich_outdated_message:\n            rich_console.print(rich_outdated_message)\n        bot._red_ready.set()\n        if outdated_red_message:\n            await send_to_owners_with_prefix_replaced(bot, outdated_red_message)\n\n    @bot.event\n    async def on_command_completion(ctx: commands.Context):\n        await bot._delete_delay(ctx)\n\n    @bot.event\n    async def on_command_error(ctx, error, unhandled_by_cog=False):\n        if not unhandled_by_cog:\n            if hasattr(ctx.command, 'on_error'):\n                return\n            if ctx.cog:\n                if ctx.cog.has_error_handler():\n                    return\n        if not isinstance(error, commands.CommandNotFound):\n            asyncio.create_task(bot._delete_delay(ctx))\n        converter = getattr(ctx.current_parameter, 'converter', None)\n        argument = ctx.current_argument\n        if isinstance(error, commands.MissingRequiredArgument):\n            await ctx.send_help()\n        elif isinstance(error, commands.ArgParserFailure):\n            msg = _('`{user_input}` is not a valid value for `{command}`').format(user_input=error.user_input, command=error.cmd)\n            if error.custom_help_msg:\n                msg += f'\\n{error.custom_help_msg}'\n            await ctx.send(msg)\n            if error.send_cmd_help:\n                await ctx.send_help()\n        elif isinstance(error, commands.RangeError):\n            if isinstance(error.value, int):\n                if error.minimum == 0 and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a positive integer.')\n                elif error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be an integer no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be an integer no less than {minimum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be an integer between {minimum} and {maximum}.')\n            elif isinstance(error.value, float):\n                if error.minimum == 0 and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a positive number.')\n                elif error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be a number no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a number no less than {maximum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be a number between {minimum} and {maximum}.')\n            elif isinstance(error.value, str):\n                if error.minimum is None and error.maximum is not None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of no more than {maximum}.')\n                elif error.minimum is not None and error.maximum is None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of no less than {minimum}.')\n                elif error.maximum is not None and error.minimum is not None:\n                    message = _('Argument `{parameter_name}` must be a string with a length of between {minimum} and {maximum}.')\n            await ctx.send(message.format(maximum=error.maximum, minimum=error.minimum, parameter_name=ctx.current_parameter.name))\n            return\n        elif isinstance(error, commands.BadArgument):\n            if isinstance(converter, commands.Range):\n                if converter.annotation is int:\n                    if converter.min == 0 and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a positive integer.')\n                    elif converter.min is None and converter.max is not None:\n                        message = _('Argument `{parameter_name}` must be an integer no more than {maximum}.')\n                    elif converter.min is not None and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be an integer no less than {minimum}.')\n                    elif converter.max is not None and converter.min is not None:\n                        message = _('Argument `{parameter_name}` must be an integer between {minimum} and {maximum}.')\n                elif converter.annotation is float:\n                    if converter.min == 0 and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a positive number.')\n                    elif converter.min is None and converter.max is not None:\n                        message = _('Argument `{parameter_name}` must be a number no more than {maximum}.')\n                    elif converter.min is not None and converter.max is None:\n                        message = _('Argument `{parameter_name}` must be a number no less than {minimum}.')\n                    elif converter.max is not None and converter.min is not None:\n                        message = _('Argument `{parameter_name}` must be a number between {minimum} and {maximum}.')\n                elif converter.annotation is str:\n                    if error.minimum is None and error.maximum is not None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of no more than {maximum}.')\n                    elif error.minimum is not None and error.maximum is None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of no less than {minimum}.')\n                    elif error.maximum is not None and error.minimum is not None:\n                        message = _('Argument `{parameter_name}` must be a string with a length of between {minimum} and {maximum}.')\n                await ctx.send(message.format(maximum=converter.max, minimum=converter.min, parameter_name=ctx.current_parameter.name))\n                return\n            if isinstance(error.__cause__, ValueError):\n                if converter is int:\n                    await ctx.send(_('\"{argument}\" is not an integer.').format(argument=argument))\n                    return\n                if converter is float:\n                    await ctx.send(_('\"{argument}\" is not a number.').format(argument=argument))\n                    return\n            if error.args:\n                await ctx.send(error.args[0])\n            else:\n                await ctx.send_help()\n        elif isinstance(error, commands.UserInputError):\n            await ctx.send_help()\n        elif isinstance(error, commands.DisabledCommand):\n            disabled_message = await bot._config.disabled_command_msg()\n            if disabled_message:\n                await ctx.send(disabled_message.replace('{command}', ctx.invoked_with))\n        elif isinstance(error, commands.CommandInvokeError):\n            log.exception(\"Exception in command '{}'\".format(ctx.command.qualified_name), exc_info=error.original)\n            exception_log = \"Exception in command '{}'\\n\".format(ctx.command.qualified_name)\n            exception_log += ''.join(traceback.format_exception(type(error), error, error.__traceback__))\n            bot._last_exception = exception_log\n            message = await bot._config.invoke_error_msg()\n            if not message:\n                if ctx.author.id in bot.owner_ids:\n                    message = inline(_(\"Error in command '{command}'. Check your console or logs for details.\"))\n                else:\n                    message = inline(_(\"Error in command '{command}'.\"))\n            await ctx.send(message.replace('{command}', ctx.command.qualified_name))\n        elif isinstance(error, commands.CommandNotFound):\n            help_settings = await HelpSettings.from_context(ctx)\n            fuzzy_commands = await fuzzy_command_search(ctx, commands=RedHelpFormatter.help_filter_func(ctx, bot.walk_commands(), help_settings=help_settings))\n            if not fuzzy_commands:\n                pass\n            elif await ctx.embed_requested():\n                await ctx.send(embed=await format_fuzzy_results(ctx, fuzzy_commands, embed=True))\n            else:\n                await ctx.send(await format_fuzzy_results(ctx, fuzzy_commands, embed=False))\n        elif isinstance(error, commands.BotMissingPermissions):\n            if bin(error.missing.value).count('1') == 1:\n                msg = _('I require the {permission} permission to execute that command.').format(permission=format_perms_list(error.missing))\n            else:\n                msg = _('I require {permission_list} permissions to execute that command.').format(permission_list=format_perms_list(error.missing))\n            await ctx.send(msg)\n        elif isinstance(error, commands.UserFeedbackCheckFailure):\n            if error.message:\n                await ctx.send(error.message)\n        elif isinstance(error, commands.NoPrivateMessage):\n            await ctx.send(_('That command is not available in DMs.'))\n        elif isinstance(error, commands.PrivateMessageOnly):\n            await ctx.send(_('That command is only available in DMs.'))\n        elif isinstance(error, commands.NSFWChannelRequired):\n            await ctx.send(_('That command is only available in NSFW channels.'))\n        elif isinstance(error, commands.CheckFailure):\n            pass\n        elif isinstance(error, commands.CommandOnCooldown):\n            if bot._bypass_cooldowns and ctx.author.id in bot.owner_ids:\n                ctx.command.reset_cooldown(ctx)\n                new_ctx = await bot.get_context(ctx.message)\n                await bot.invoke(new_ctx)\n                return\n            relative_time = discord.utils.format_dt(datetime.now(timezone.utc) + timedelta(seconds=error.retry_after), 'R')\n            msg = _('This command is on cooldown. Try again {relative_time}.').format(relative_time=relative_time)\n            await ctx.send(msg, delete_after=error.retry_after)\n        elif isinstance(error, commands.MaxConcurrencyReached):\n            if error.per is commands.BucketType.default:\n                if error.number > 1:\n                    msg = _('Too many people using this command. It can only be used {number} times concurrently.').format(number=error.number)\n                else:\n                    msg = _('Too many people using this command. It can only be used once concurrently.')\n            elif error.per in (commands.BucketType.user, commands.BucketType.member):\n                if error.number > 1:\n                    msg = _('That command is still completing, it can only be used {number} times per {type} concurrently.').format(number=error.number, type=error.per.name)\n                else:\n                    msg = _('That command is still completing, it can only be used once per {type} concurrently.').format(type=error.per.name)\n            elif error.number > 1:\n                msg = _('Too many people using this command. It can only be used {number} times per {type} concurrently.').format(number=error.number, type=error.per.name)\n            else:\n                msg = _('Too many people using this command. It can only be used once per {type} concurrently.').format(type=error.per.name)\n            await ctx.send(msg)\n        else:\n            log.exception(type(error).__name__, exc_info=error)\n\n    @bot.event\n    async def on_message(message, /):\n        await set_contextual_locales_from_guild(bot, message.guild)\n        await bot.process_commands(message)\n        discord_now = message.created_at\n        if not bot._checked_time_accuracy or discord_now - timedelta(minutes=60) > bot._checked_time_accuracy:\n            system_now = datetime.now(timezone.utc)\n            diff = abs((discord_now - system_now).total_seconds())\n            if diff > 60:\n                log.warning(\"Detected significant difference (%d seconds) in system clock to discord's clock. Any time sensitive code may fail.\", diff)\n            bot._checked_time_accuracy = discord_now\n\n    @bot.event\n    async def on_command_add(command: commands.Command):\n        if command.cog is not None:\n            return\n        await _disable_command_no_cog(command)\n\n    async def _guild_added(guild: discord.Guild):\n        disabled_commands = await bot._config.guild(guild).disabled_commands()\n        for command_name in disabled_commands:\n            command_obj = bot.get_command(command_name)\n            if command_obj is not None:\n                command_obj.disable_in(guild)\n\n    @bot.event\n    async def on_guild_join(guild: discord.Guild):\n        await _guild_added(guild)\n\n    @bot.event\n    async def on_guild_available(guild: discord.Guild):\n        await _guild_added(guild)\n\n    @bot.event\n    async def on_guild_remove(guild: discord.Guild):\n        disabled_commands = await bot._config.guild(guild).disabled_commands()\n        for command_name in disabled_commands:\n            command_obj = bot.get_command(command_name)\n            if command_obj is not None:\n                command_obj.enable_in(guild)\n\n    @bot.event\n    async def on_cog_add(cog: commands.Cog):\n        confs = get_latest_confs()\n        for c in confs:\n            uuid = c.unique_identifier\n            group_data = c.custom_groups\n            await bot._config.custom('CUSTOM_GROUPS', c.cog_name, uuid).set(group_data)\n        await _disable_commands_cog(cog)\n\n    async def _disable_command(command: commands.Command, global_disabled: list, guilds_data: dict):\n        if command.qualified_name in global_disabled:\n            command.enabled = False\n        for (guild_id, data) in guilds_data.items():\n            guild_disabled_cmds = data.get('disabled_commands', [])\n            if command.qualified_name in guild_disabled_cmds:\n                command.disable_in(discord.Object(id=guild_id))\n\n    async def _disable_commands_cog(cog: commands.Cog):\n        global_disabled = await bot._config.disabled_commands()\n        guilds_data = await bot._config.all_guilds()\n        for command in cog.walk_commands():\n            await _disable_command(command, global_disabled, guilds_data)\n\n    async def _disable_command_no_cog(command: commands.Command):\n        global_disabled = await bot._config.disabled_commands()\n        guilds_data = await bot._config.all_guilds()\n        await _disable_command(command, global_disabled, guilds_data)"
        ]
    }
]