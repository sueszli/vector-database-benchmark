[
    {
        "func_name": "ret2csu",
        "original": "def ret2csu(rop, elf, edi, rsi, rdx, rbx, rbp, r12, r13, r14, r15, call=None):\n    \"\"\"Build a ret2csu ROPchain\n\n    Arguments:\n        edi, rsi, rdx: Three primary registers to populate\n        rbx, rbp, r12, r13, r14, r15: Optional registers to populate\n        call: Pointer to the address of a function to call during\n            second gadget. If None then use the address of _fini in the\n            .dynamic section. .got.plt entries are a good target. Required\n            for PIE binaries.\n    \"\"\"\n    md = Cs(CS_ARCH_X86, CS_MODE_64)\n    md.detail = True\n    md.skipdata = True\n    if '__libc_csu_init' not in elf.symbols:\n        textaddr = elf.offset_to_vaddr(elf.get_section_by_name('.text').header.sh_offset)\n        entry = elf.entry\n        data = elf.section('.text')[entry - textaddr:]\n        mnemonic = elf.pie and 'lea' or 'mov'\n        for insn in md.disasm(data, entry):\n            if insn.mnemonic == mnemonic:\n                if mnemonic == 'lea':\n                    addr = insn.address + insn.size + insn.disp\n                else:\n                    addr = insn.operands[1].imm\n                if insn.operands[0].reg == X86_REG_R8:\n                    elf.sym['__libc_csu_fini'] = addr\n                if insn.operands[0].reg == X86_REG_RCX:\n                    elf.sym['__libc_csu_init'] = addr\n                    break\n            elif insn.mnemonic == 'xor' and insn.operands[0].reg == insn.operands[1].reg == X86_REG_ECX:\n                log.error('This binary is compiled for glibc 2.34+ and does not have __libc_csu_init')\n            elif insn.mnemonic in ('hlt', 'jmp', 'call', 'syscall'):\n                log.error('No __libc_csu_init (no glibc _start)')\n        else:\n            log.error('Weird _start, definitely no __libc_csu_init')\n    if not elf.pie and (not call):\n        call = next(elf.search(p64(elf.dynamic_by_tag('DT_FINI')['d_ptr'])))\n    elif elf.pie and (not call):\n        log.error(\"No non-PIE binaries in [elfs], 'call' parameter is required\")\n    csu_function = elf.read(elf.sym['__libc_csu_init'], elf.sym['__libc_csu_fini'] - elf.sym['__libc_csu_init'])\n    for insn in md.disasm(csu_function, elf.sym['__libc_csu_init']):\n        if insn.mnemonic == 'pop' and insn.operands[0].reg == X86_REG_RBX:\n            rop.raw(insn.address)\n            break\n    rop.raw(0)\n    rop.raw(1)\n    for insn in md.disasm(csu_function, elf.sym['__libc_csu_init']):\n        if insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R13):\n            rop.raw(call)\n            rop.raw(rdx)\n            rop.raw(rsi)\n            rop.raw(edi)\n            rop.raw(insn.address)\n            break\n        elif insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R14):\n            rop.raw(edi)\n            rop.raw(rsi)\n            rop.raw(rdx)\n            rop.raw(call)\n            rop.raw(insn.address)\n            break\n        elif insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R15):\n            rop.raw(call)\n            rop.raw(edi)\n            rop.raw(rsi)\n            rop.raw(rdx)\n            rop.raw(insn.address)\n            break\n    else:\n        log.error('This CSU init variant is not supported by pwntools')\n    rop.raw(Padding('<add rsp, 8>'))\n    rop.raw(rbx)\n    rop.raw(rbp)\n    rop.raw(r12)\n    rop.raw(r13)\n    rop.raw(r14)\n    rop.raw(r15)",
        "mutated": [
            "def ret2csu(rop, elf, edi, rsi, rdx, rbx, rbp, r12, r13, r14, r15, call=None):\n    if False:\n        i = 10\n    'Build a ret2csu ROPchain\\n\\n    Arguments:\\n        edi, rsi, rdx: Three primary registers to populate\\n        rbx, rbp, r12, r13, r14, r15: Optional registers to populate\\n        call: Pointer to the address of a function to call during\\n            second gadget. If None then use the address of _fini in the\\n            .dynamic section. .got.plt entries are a good target. Required\\n            for PIE binaries.\\n    '\n    md = Cs(CS_ARCH_X86, CS_MODE_64)\n    md.detail = True\n    md.skipdata = True\n    if '__libc_csu_init' not in elf.symbols:\n        textaddr = elf.offset_to_vaddr(elf.get_section_by_name('.text').header.sh_offset)\n        entry = elf.entry\n        data = elf.section('.text')[entry - textaddr:]\n        mnemonic = elf.pie and 'lea' or 'mov'\n        for insn in md.disasm(data, entry):\n            if insn.mnemonic == mnemonic:\n                if mnemonic == 'lea':\n                    addr = insn.address + insn.size + insn.disp\n                else:\n                    addr = insn.operands[1].imm\n                if insn.operands[0].reg == X86_REG_R8:\n                    elf.sym['__libc_csu_fini'] = addr\n                if insn.operands[0].reg == X86_REG_RCX:\n                    elf.sym['__libc_csu_init'] = addr\n                    break\n            elif insn.mnemonic == 'xor' and insn.operands[0].reg == insn.operands[1].reg == X86_REG_ECX:\n                log.error('This binary is compiled for glibc 2.34+ and does not have __libc_csu_init')\n            elif insn.mnemonic in ('hlt', 'jmp', 'call', 'syscall'):\n                log.error('No __libc_csu_init (no glibc _start)')\n        else:\n            log.error('Weird _start, definitely no __libc_csu_init')\n    if not elf.pie and (not call):\n        call = next(elf.search(p64(elf.dynamic_by_tag('DT_FINI')['d_ptr'])))\n    elif elf.pie and (not call):\n        log.error(\"No non-PIE binaries in [elfs], 'call' parameter is required\")\n    csu_function = elf.read(elf.sym['__libc_csu_init'], elf.sym['__libc_csu_fini'] - elf.sym['__libc_csu_init'])\n    for insn in md.disasm(csu_function, elf.sym['__libc_csu_init']):\n        if insn.mnemonic == 'pop' and insn.operands[0].reg == X86_REG_RBX:\n            rop.raw(insn.address)\n            break\n    rop.raw(0)\n    rop.raw(1)\n    for insn in md.disasm(csu_function, elf.sym['__libc_csu_init']):\n        if insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R13):\n            rop.raw(call)\n            rop.raw(rdx)\n            rop.raw(rsi)\n            rop.raw(edi)\n            rop.raw(insn.address)\n            break\n        elif insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R14):\n            rop.raw(edi)\n            rop.raw(rsi)\n            rop.raw(rdx)\n            rop.raw(call)\n            rop.raw(insn.address)\n            break\n        elif insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R15):\n            rop.raw(call)\n            rop.raw(edi)\n            rop.raw(rsi)\n            rop.raw(rdx)\n            rop.raw(insn.address)\n            break\n    else:\n        log.error('This CSU init variant is not supported by pwntools')\n    rop.raw(Padding('<add rsp, 8>'))\n    rop.raw(rbx)\n    rop.raw(rbp)\n    rop.raw(r12)\n    rop.raw(r13)\n    rop.raw(r14)\n    rop.raw(r15)",
            "def ret2csu(rop, elf, edi, rsi, rdx, rbx, rbp, r12, r13, r14, r15, call=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Build a ret2csu ROPchain\\n\\n    Arguments:\\n        edi, rsi, rdx: Three primary registers to populate\\n        rbx, rbp, r12, r13, r14, r15: Optional registers to populate\\n        call: Pointer to the address of a function to call during\\n            second gadget. If None then use the address of _fini in the\\n            .dynamic section. .got.plt entries are a good target. Required\\n            for PIE binaries.\\n    '\n    md = Cs(CS_ARCH_X86, CS_MODE_64)\n    md.detail = True\n    md.skipdata = True\n    if '__libc_csu_init' not in elf.symbols:\n        textaddr = elf.offset_to_vaddr(elf.get_section_by_name('.text').header.sh_offset)\n        entry = elf.entry\n        data = elf.section('.text')[entry - textaddr:]\n        mnemonic = elf.pie and 'lea' or 'mov'\n        for insn in md.disasm(data, entry):\n            if insn.mnemonic == mnemonic:\n                if mnemonic == 'lea':\n                    addr = insn.address + insn.size + insn.disp\n                else:\n                    addr = insn.operands[1].imm\n                if insn.operands[0].reg == X86_REG_R8:\n                    elf.sym['__libc_csu_fini'] = addr\n                if insn.operands[0].reg == X86_REG_RCX:\n                    elf.sym['__libc_csu_init'] = addr\n                    break\n            elif insn.mnemonic == 'xor' and insn.operands[0].reg == insn.operands[1].reg == X86_REG_ECX:\n                log.error('This binary is compiled for glibc 2.34+ and does not have __libc_csu_init')\n            elif insn.mnemonic in ('hlt', 'jmp', 'call', 'syscall'):\n                log.error('No __libc_csu_init (no glibc _start)')\n        else:\n            log.error('Weird _start, definitely no __libc_csu_init')\n    if not elf.pie and (not call):\n        call = next(elf.search(p64(elf.dynamic_by_tag('DT_FINI')['d_ptr'])))\n    elif elf.pie and (not call):\n        log.error(\"No non-PIE binaries in [elfs], 'call' parameter is required\")\n    csu_function = elf.read(elf.sym['__libc_csu_init'], elf.sym['__libc_csu_fini'] - elf.sym['__libc_csu_init'])\n    for insn in md.disasm(csu_function, elf.sym['__libc_csu_init']):\n        if insn.mnemonic == 'pop' and insn.operands[0].reg == X86_REG_RBX:\n            rop.raw(insn.address)\n            break\n    rop.raw(0)\n    rop.raw(1)\n    for insn in md.disasm(csu_function, elf.sym['__libc_csu_init']):\n        if insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R13):\n            rop.raw(call)\n            rop.raw(rdx)\n            rop.raw(rsi)\n            rop.raw(edi)\n            rop.raw(insn.address)\n            break\n        elif insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R14):\n            rop.raw(edi)\n            rop.raw(rsi)\n            rop.raw(rdx)\n            rop.raw(call)\n            rop.raw(insn.address)\n            break\n        elif insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R15):\n            rop.raw(call)\n            rop.raw(edi)\n            rop.raw(rsi)\n            rop.raw(rdx)\n            rop.raw(insn.address)\n            break\n    else:\n        log.error('This CSU init variant is not supported by pwntools')\n    rop.raw(Padding('<add rsp, 8>'))\n    rop.raw(rbx)\n    rop.raw(rbp)\n    rop.raw(r12)\n    rop.raw(r13)\n    rop.raw(r14)\n    rop.raw(r15)",
            "def ret2csu(rop, elf, edi, rsi, rdx, rbx, rbp, r12, r13, r14, r15, call=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Build a ret2csu ROPchain\\n\\n    Arguments:\\n        edi, rsi, rdx: Three primary registers to populate\\n        rbx, rbp, r12, r13, r14, r15: Optional registers to populate\\n        call: Pointer to the address of a function to call during\\n            second gadget. If None then use the address of _fini in the\\n            .dynamic section. .got.plt entries are a good target. Required\\n            for PIE binaries.\\n    '\n    md = Cs(CS_ARCH_X86, CS_MODE_64)\n    md.detail = True\n    md.skipdata = True\n    if '__libc_csu_init' not in elf.symbols:\n        textaddr = elf.offset_to_vaddr(elf.get_section_by_name('.text').header.sh_offset)\n        entry = elf.entry\n        data = elf.section('.text')[entry - textaddr:]\n        mnemonic = elf.pie and 'lea' or 'mov'\n        for insn in md.disasm(data, entry):\n            if insn.mnemonic == mnemonic:\n                if mnemonic == 'lea':\n                    addr = insn.address + insn.size + insn.disp\n                else:\n                    addr = insn.operands[1].imm\n                if insn.operands[0].reg == X86_REG_R8:\n                    elf.sym['__libc_csu_fini'] = addr\n                if insn.operands[0].reg == X86_REG_RCX:\n                    elf.sym['__libc_csu_init'] = addr\n                    break\n            elif insn.mnemonic == 'xor' and insn.operands[0].reg == insn.operands[1].reg == X86_REG_ECX:\n                log.error('This binary is compiled for glibc 2.34+ and does not have __libc_csu_init')\n            elif insn.mnemonic in ('hlt', 'jmp', 'call', 'syscall'):\n                log.error('No __libc_csu_init (no glibc _start)')\n        else:\n            log.error('Weird _start, definitely no __libc_csu_init')\n    if not elf.pie and (not call):\n        call = next(elf.search(p64(elf.dynamic_by_tag('DT_FINI')['d_ptr'])))\n    elif elf.pie and (not call):\n        log.error(\"No non-PIE binaries in [elfs], 'call' parameter is required\")\n    csu_function = elf.read(elf.sym['__libc_csu_init'], elf.sym['__libc_csu_fini'] - elf.sym['__libc_csu_init'])\n    for insn in md.disasm(csu_function, elf.sym['__libc_csu_init']):\n        if insn.mnemonic == 'pop' and insn.operands[0].reg == X86_REG_RBX:\n            rop.raw(insn.address)\n            break\n    rop.raw(0)\n    rop.raw(1)\n    for insn in md.disasm(csu_function, elf.sym['__libc_csu_init']):\n        if insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R13):\n            rop.raw(call)\n            rop.raw(rdx)\n            rop.raw(rsi)\n            rop.raw(edi)\n            rop.raw(insn.address)\n            break\n        elif insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R14):\n            rop.raw(edi)\n            rop.raw(rsi)\n            rop.raw(rdx)\n            rop.raw(call)\n            rop.raw(insn.address)\n            break\n        elif insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R15):\n            rop.raw(call)\n            rop.raw(edi)\n            rop.raw(rsi)\n            rop.raw(rdx)\n            rop.raw(insn.address)\n            break\n    else:\n        log.error('This CSU init variant is not supported by pwntools')\n    rop.raw(Padding('<add rsp, 8>'))\n    rop.raw(rbx)\n    rop.raw(rbp)\n    rop.raw(r12)\n    rop.raw(r13)\n    rop.raw(r14)\n    rop.raw(r15)",
            "def ret2csu(rop, elf, edi, rsi, rdx, rbx, rbp, r12, r13, r14, r15, call=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Build a ret2csu ROPchain\\n\\n    Arguments:\\n        edi, rsi, rdx: Three primary registers to populate\\n        rbx, rbp, r12, r13, r14, r15: Optional registers to populate\\n        call: Pointer to the address of a function to call during\\n            second gadget. If None then use the address of _fini in the\\n            .dynamic section. .got.plt entries are a good target. Required\\n            for PIE binaries.\\n    '\n    md = Cs(CS_ARCH_X86, CS_MODE_64)\n    md.detail = True\n    md.skipdata = True\n    if '__libc_csu_init' not in elf.symbols:\n        textaddr = elf.offset_to_vaddr(elf.get_section_by_name('.text').header.sh_offset)\n        entry = elf.entry\n        data = elf.section('.text')[entry - textaddr:]\n        mnemonic = elf.pie and 'lea' or 'mov'\n        for insn in md.disasm(data, entry):\n            if insn.mnemonic == mnemonic:\n                if mnemonic == 'lea':\n                    addr = insn.address + insn.size + insn.disp\n                else:\n                    addr = insn.operands[1].imm\n                if insn.operands[0].reg == X86_REG_R8:\n                    elf.sym['__libc_csu_fini'] = addr\n                if insn.operands[0].reg == X86_REG_RCX:\n                    elf.sym['__libc_csu_init'] = addr\n                    break\n            elif insn.mnemonic == 'xor' and insn.operands[0].reg == insn.operands[1].reg == X86_REG_ECX:\n                log.error('This binary is compiled for glibc 2.34+ and does not have __libc_csu_init')\n            elif insn.mnemonic in ('hlt', 'jmp', 'call', 'syscall'):\n                log.error('No __libc_csu_init (no glibc _start)')\n        else:\n            log.error('Weird _start, definitely no __libc_csu_init')\n    if not elf.pie and (not call):\n        call = next(elf.search(p64(elf.dynamic_by_tag('DT_FINI')['d_ptr'])))\n    elif elf.pie and (not call):\n        log.error(\"No non-PIE binaries in [elfs], 'call' parameter is required\")\n    csu_function = elf.read(elf.sym['__libc_csu_init'], elf.sym['__libc_csu_fini'] - elf.sym['__libc_csu_init'])\n    for insn in md.disasm(csu_function, elf.sym['__libc_csu_init']):\n        if insn.mnemonic == 'pop' and insn.operands[0].reg == X86_REG_RBX:\n            rop.raw(insn.address)\n            break\n    rop.raw(0)\n    rop.raw(1)\n    for insn in md.disasm(csu_function, elf.sym['__libc_csu_init']):\n        if insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R13):\n            rop.raw(call)\n            rop.raw(rdx)\n            rop.raw(rsi)\n            rop.raw(edi)\n            rop.raw(insn.address)\n            break\n        elif insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R14):\n            rop.raw(edi)\n            rop.raw(rsi)\n            rop.raw(rdx)\n            rop.raw(call)\n            rop.raw(insn.address)\n            break\n        elif insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R15):\n            rop.raw(call)\n            rop.raw(edi)\n            rop.raw(rsi)\n            rop.raw(rdx)\n            rop.raw(insn.address)\n            break\n    else:\n        log.error('This CSU init variant is not supported by pwntools')\n    rop.raw(Padding('<add rsp, 8>'))\n    rop.raw(rbx)\n    rop.raw(rbp)\n    rop.raw(r12)\n    rop.raw(r13)\n    rop.raw(r14)\n    rop.raw(r15)",
            "def ret2csu(rop, elf, edi, rsi, rdx, rbx, rbp, r12, r13, r14, r15, call=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Build a ret2csu ROPchain\\n\\n    Arguments:\\n        edi, rsi, rdx: Three primary registers to populate\\n        rbx, rbp, r12, r13, r14, r15: Optional registers to populate\\n        call: Pointer to the address of a function to call during\\n            second gadget. If None then use the address of _fini in the\\n            .dynamic section. .got.plt entries are a good target. Required\\n            for PIE binaries.\\n    '\n    md = Cs(CS_ARCH_X86, CS_MODE_64)\n    md.detail = True\n    md.skipdata = True\n    if '__libc_csu_init' not in elf.symbols:\n        textaddr = elf.offset_to_vaddr(elf.get_section_by_name('.text').header.sh_offset)\n        entry = elf.entry\n        data = elf.section('.text')[entry - textaddr:]\n        mnemonic = elf.pie and 'lea' or 'mov'\n        for insn in md.disasm(data, entry):\n            if insn.mnemonic == mnemonic:\n                if mnemonic == 'lea':\n                    addr = insn.address + insn.size + insn.disp\n                else:\n                    addr = insn.operands[1].imm\n                if insn.operands[0].reg == X86_REG_R8:\n                    elf.sym['__libc_csu_fini'] = addr\n                if insn.operands[0].reg == X86_REG_RCX:\n                    elf.sym['__libc_csu_init'] = addr\n                    break\n            elif insn.mnemonic == 'xor' and insn.operands[0].reg == insn.operands[1].reg == X86_REG_ECX:\n                log.error('This binary is compiled for glibc 2.34+ and does not have __libc_csu_init')\n            elif insn.mnemonic in ('hlt', 'jmp', 'call', 'syscall'):\n                log.error('No __libc_csu_init (no glibc _start)')\n        else:\n            log.error('Weird _start, definitely no __libc_csu_init')\n    if not elf.pie and (not call):\n        call = next(elf.search(p64(elf.dynamic_by_tag('DT_FINI')['d_ptr'])))\n    elif elf.pie and (not call):\n        log.error(\"No non-PIE binaries in [elfs], 'call' parameter is required\")\n    csu_function = elf.read(elf.sym['__libc_csu_init'], elf.sym['__libc_csu_fini'] - elf.sym['__libc_csu_init'])\n    for insn in md.disasm(csu_function, elf.sym['__libc_csu_init']):\n        if insn.mnemonic == 'pop' and insn.operands[0].reg == X86_REG_RBX:\n            rop.raw(insn.address)\n            break\n    rop.raw(0)\n    rop.raw(1)\n    for insn in md.disasm(csu_function, elf.sym['__libc_csu_init']):\n        if insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R13):\n            rop.raw(call)\n            rop.raw(rdx)\n            rop.raw(rsi)\n            rop.raw(edi)\n            rop.raw(insn.address)\n            break\n        elif insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R14):\n            rop.raw(edi)\n            rop.raw(rsi)\n            rop.raw(rdx)\n            rop.raw(call)\n            rop.raw(insn.address)\n            break\n        elif insn.mnemonic == 'mov' and insn.operands[0].reg == X86_REG_RDX and (insn.operands[1].reg == X86_REG_R15):\n            rop.raw(call)\n            rop.raw(edi)\n            rop.raw(rsi)\n            rop.raw(rdx)\n            rop.raw(insn.address)\n            break\n    else:\n        log.error('This CSU init variant is not supported by pwntools')\n    rop.raw(Padding('<add rsp, 8>'))\n    rop.raw(rbx)\n    rop.raw(rbp)\n    rop.raw(r12)\n    rop.raw(r13)\n    rop.raw(r14)\n    rop.raw(r15)"
        ]
    }
]