[
    {
        "func_name": "get_lon_lat_path",
        "original": "def get_lon_lat_path(lon_lat, pixel, lon_lat_check):\n    \"\"\"\n    Draw a curve, taking into account discontinuities.\n\n    Parameters\n    ----------\n    lon_lat : ndarray\n        The longitude and latitude values along the curve, given as a (n,2)\n        array.\n    pixel : ndarray\n        The pixel coordinates corresponding to ``lon_lat``\n    lon_lat_check : ndarray\n        The world coordinates derived from converting from ``pixel``, which is\n        used to ensure round-tripping.\n    \"\"\"\n    sep = angular_separation(np.radians(lon_lat[:, 0]), np.radians(lon_lat[:, 1]), np.radians(lon_lat_check[:, 0]), np.radians(lon_lat_check[:, 1]))\n    scale_size = angular_separation(*np.radians(lon_lat[0, :]), *np.radians(lon_lat[1, :]))\n    with np.errstate(invalid='ignore'):\n        sep[sep > np.pi] -= 2.0 * np.pi\n        mask = np.abs(sep > ROUND_TRIP_RTOL * scale_size)\n    mask = mask | np.isnan(pixel[:, 0]) | np.isnan(pixel[:, 1])\n    codes = np.zeros(lon_lat.shape[0], dtype=np.uint8)\n    codes[:] = Path.LINETO\n    codes[0] = Path.MOVETO\n    codes[mask] = Path.MOVETO\n    codes[1:][mask[:-1]] = Path.MOVETO\n    step = np.sqrt((pixel[1:, 0] - pixel[:-1, 0]) ** 2 + (pixel[1:, 1] - pixel[:-1, 1]) ** 2)\n    discontinuous = step[1:] > DISCONT_FACTOR * step[:-1]\n    codes[2:][discontinuous] = Path.MOVETO\n    if step[0] > DISCONT_FACTOR * step[1]:\n        codes[1] = Path.MOVETO\n    path = Path(pixel, codes=codes)\n    return path",
        "mutated": [
            "def get_lon_lat_path(lon_lat, pixel, lon_lat_check):\n    if False:\n        i = 10\n    '\\n    Draw a curve, taking into account discontinuities.\\n\\n    Parameters\\n    ----------\\n    lon_lat : ndarray\\n        The longitude and latitude values along the curve, given as a (n,2)\\n        array.\\n    pixel : ndarray\\n        The pixel coordinates corresponding to ``lon_lat``\\n    lon_lat_check : ndarray\\n        The world coordinates derived from converting from ``pixel``, which is\\n        used to ensure round-tripping.\\n    '\n    sep = angular_separation(np.radians(lon_lat[:, 0]), np.radians(lon_lat[:, 1]), np.radians(lon_lat_check[:, 0]), np.radians(lon_lat_check[:, 1]))\n    scale_size = angular_separation(*np.radians(lon_lat[0, :]), *np.radians(lon_lat[1, :]))\n    with np.errstate(invalid='ignore'):\n        sep[sep > np.pi] -= 2.0 * np.pi\n        mask = np.abs(sep > ROUND_TRIP_RTOL * scale_size)\n    mask = mask | np.isnan(pixel[:, 0]) | np.isnan(pixel[:, 1])\n    codes = np.zeros(lon_lat.shape[0], dtype=np.uint8)\n    codes[:] = Path.LINETO\n    codes[0] = Path.MOVETO\n    codes[mask] = Path.MOVETO\n    codes[1:][mask[:-1]] = Path.MOVETO\n    step = np.sqrt((pixel[1:, 0] - pixel[:-1, 0]) ** 2 + (pixel[1:, 1] - pixel[:-1, 1]) ** 2)\n    discontinuous = step[1:] > DISCONT_FACTOR * step[:-1]\n    codes[2:][discontinuous] = Path.MOVETO\n    if step[0] > DISCONT_FACTOR * step[1]:\n        codes[1] = Path.MOVETO\n    path = Path(pixel, codes=codes)\n    return path",
            "def get_lon_lat_path(lon_lat, pixel, lon_lat_check):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Draw a curve, taking into account discontinuities.\\n\\n    Parameters\\n    ----------\\n    lon_lat : ndarray\\n        The longitude and latitude values along the curve, given as a (n,2)\\n        array.\\n    pixel : ndarray\\n        The pixel coordinates corresponding to ``lon_lat``\\n    lon_lat_check : ndarray\\n        The world coordinates derived from converting from ``pixel``, which is\\n        used to ensure round-tripping.\\n    '\n    sep = angular_separation(np.radians(lon_lat[:, 0]), np.radians(lon_lat[:, 1]), np.radians(lon_lat_check[:, 0]), np.radians(lon_lat_check[:, 1]))\n    scale_size = angular_separation(*np.radians(lon_lat[0, :]), *np.radians(lon_lat[1, :]))\n    with np.errstate(invalid='ignore'):\n        sep[sep > np.pi] -= 2.0 * np.pi\n        mask = np.abs(sep > ROUND_TRIP_RTOL * scale_size)\n    mask = mask | np.isnan(pixel[:, 0]) | np.isnan(pixel[:, 1])\n    codes = np.zeros(lon_lat.shape[0], dtype=np.uint8)\n    codes[:] = Path.LINETO\n    codes[0] = Path.MOVETO\n    codes[mask] = Path.MOVETO\n    codes[1:][mask[:-1]] = Path.MOVETO\n    step = np.sqrt((pixel[1:, 0] - pixel[:-1, 0]) ** 2 + (pixel[1:, 1] - pixel[:-1, 1]) ** 2)\n    discontinuous = step[1:] > DISCONT_FACTOR * step[:-1]\n    codes[2:][discontinuous] = Path.MOVETO\n    if step[0] > DISCONT_FACTOR * step[1]:\n        codes[1] = Path.MOVETO\n    path = Path(pixel, codes=codes)\n    return path",
            "def get_lon_lat_path(lon_lat, pixel, lon_lat_check):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Draw a curve, taking into account discontinuities.\\n\\n    Parameters\\n    ----------\\n    lon_lat : ndarray\\n        The longitude and latitude values along the curve, given as a (n,2)\\n        array.\\n    pixel : ndarray\\n        The pixel coordinates corresponding to ``lon_lat``\\n    lon_lat_check : ndarray\\n        The world coordinates derived from converting from ``pixel``, which is\\n        used to ensure round-tripping.\\n    '\n    sep = angular_separation(np.radians(lon_lat[:, 0]), np.radians(lon_lat[:, 1]), np.radians(lon_lat_check[:, 0]), np.radians(lon_lat_check[:, 1]))\n    scale_size = angular_separation(*np.radians(lon_lat[0, :]), *np.radians(lon_lat[1, :]))\n    with np.errstate(invalid='ignore'):\n        sep[sep > np.pi] -= 2.0 * np.pi\n        mask = np.abs(sep > ROUND_TRIP_RTOL * scale_size)\n    mask = mask | np.isnan(pixel[:, 0]) | np.isnan(pixel[:, 1])\n    codes = np.zeros(lon_lat.shape[0], dtype=np.uint8)\n    codes[:] = Path.LINETO\n    codes[0] = Path.MOVETO\n    codes[mask] = Path.MOVETO\n    codes[1:][mask[:-1]] = Path.MOVETO\n    step = np.sqrt((pixel[1:, 0] - pixel[:-1, 0]) ** 2 + (pixel[1:, 1] - pixel[:-1, 1]) ** 2)\n    discontinuous = step[1:] > DISCONT_FACTOR * step[:-1]\n    codes[2:][discontinuous] = Path.MOVETO\n    if step[0] > DISCONT_FACTOR * step[1]:\n        codes[1] = Path.MOVETO\n    path = Path(pixel, codes=codes)\n    return path",
            "def get_lon_lat_path(lon_lat, pixel, lon_lat_check):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Draw a curve, taking into account discontinuities.\\n\\n    Parameters\\n    ----------\\n    lon_lat : ndarray\\n        The longitude and latitude values along the curve, given as a (n,2)\\n        array.\\n    pixel : ndarray\\n        The pixel coordinates corresponding to ``lon_lat``\\n    lon_lat_check : ndarray\\n        The world coordinates derived from converting from ``pixel``, which is\\n        used to ensure round-tripping.\\n    '\n    sep = angular_separation(np.radians(lon_lat[:, 0]), np.radians(lon_lat[:, 1]), np.radians(lon_lat_check[:, 0]), np.radians(lon_lat_check[:, 1]))\n    scale_size = angular_separation(*np.radians(lon_lat[0, :]), *np.radians(lon_lat[1, :]))\n    with np.errstate(invalid='ignore'):\n        sep[sep > np.pi] -= 2.0 * np.pi\n        mask = np.abs(sep > ROUND_TRIP_RTOL * scale_size)\n    mask = mask | np.isnan(pixel[:, 0]) | np.isnan(pixel[:, 1])\n    codes = np.zeros(lon_lat.shape[0], dtype=np.uint8)\n    codes[:] = Path.LINETO\n    codes[0] = Path.MOVETO\n    codes[mask] = Path.MOVETO\n    codes[1:][mask[:-1]] = Path.MOVETO\n    step = np.sqrt((pixel[1:, 0] - pixel[:-1, 0]) ** 2 + (pixel[1:, 1] - pixel[:-1, 1]) ** 2)\n    discontinuous = step[1:] > DISCONT_FACTOR * step[:-1]\n    codes[2:][discontinuous] = Path.MOVETO\n    if step[0] > DISCONT_FACTOR * step[1]:\n        codes[1] = Path.MOVETO\n    path = Path(pixel, codes=codes)\n    return path",
            "def get_lon_lat_path(lon_lat, pixel, lon_lat_check):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Draw a curve, taking into account discontinuities.\\n\\n    Parameters\\n    ----------\\n    lon_lat : ndarray\\n        The longitude and latitude values along the curve, given as a (n,2)\\n        array.\\n    pixel : ndarray\\n        The pixel coordinates corresponding to ``lon_lat``\\n    lon_lat_check : ndarray\\n        The world coordinates derived from converting from ``pixel``, which is\\n        used to ensure round-tripping.\\n    '\n    sep = angular_separation(np.radians(lon_lat[:, 0]), np.radians(lon_lat[:, 1]), np.radians(lon_lat_check[:, 0]), np.radians(lon_lat_check[:, 1]))\n    scale_size = angular_separation(*np.radians(lon_lat[0, :]), *np.radians(lon_lat[1, :]))\n    with np.errstate(invalid='ignore'):\n        sep[sep > np.pi] -= 2.0 * np.pi\n        mask = np.abs(sep > ROUND_TRIP_RTOL * scale_size)\n    mask = mask | np.isnan(pixel[:, 0]) | np.isnan(pixel[:, 1])\n    codes = np.zeros(lon_lat.shape[0], dtype=np.uint8)\n    codes[:] = Path.LINETO\n    codes[0] = Path.MOVETO\n    codes[mask] = Path.MOVETO\n    codes[1:][mask[:-1]] = Path.MOVETO\n    step = np.sqrt((pixel[1:, 0] - pixel[:-1, 0]) ** 2 + (pixel[1:, 1] - pixel[:-1, 1]) ** 2)\n    discontinuous = step[1:] > DISCONT_FACTOR * step[:-1]\n    codes[2:][discontinuous] = Path.MOVETO\n    if step[0] > DISCONT_FACTOR * step[1]:\n        codes[1] = Path.MOVETO\n    path = Path(pixel, codes=codes)\n    return path"
        ]
    },
    {
        "func_name": "get_gridline_path",
        "original": "def get_gridline_path(world, pixel):\n    \"\"\"\n    Draw a grid line.\n\n    Parameters\n    ----------\n    world : ndarray\n        The longitude and latitude values along the curve, given as a (n,2)\n        array.\n    pixel : ndarray\n        The pixel coordinates corresponding to ``lon_lat``\n    \"\"\"\n    mask = np.isnan(pixel[:, 0]) | np.isnan(pixel[:, 1])\n    codes = np.zeros(world.shape[0], dtype=np.uint8)\n    codes[:] = Path.LINETO\n    codes[0] = Path.MOVETO\n    codes[mask] = Path.MOVETO\n    codes[1:][mask[:-1]] = Path.MOVETO\n    path = Path(pixel, codes=codes)\n    return path",
        "mutated": [
            "def get_gridline_path(world, pixel):\n    if False:\n        i = 10\n    '\\n    Draw a grid line.\\n\\n    Parameters\\n    ----------\\n    world : ndarray\\n        The longitude and latitude values along the curve, given as a (n,2)\\n        array.\\n    pixel : ndarray\\n        The pixel coordinates corresponding to ``lon_lat``\\n    '\n    mask = np.isnan(pixel[:, 0]) | np.isnan(pixel[:, 1])\n    codes = np.zeros(world.shape[0], dtype=np.uint8)\n    codes[:] = Path.LINETO\n    codes[0] = Path.MOVETO\n    codes[mask] = Path.MOVETO\n    codes[1:][mask[:-1]] = Path.MOVETO\n    path = Path(pixel, codes=codes)\n    return path",
            "def get_gridline_path(world, pixel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Draw a grid line.\\n\\n    Parameters\\n    ----------\\n    world : ndarray\\n        The longitude and latitude values along the curve, given as a (n,2)\\n        array.\\n    pixel : ndarray\\n        The pixel coordinates corresponding to ``lon_lat``\\n    '\n    mask = np.isnan(pixel[:, 0]) | np.isnan(pixel[:, 1])\n    codes = np.zeros(world.shape[0], dtype=np.uint8)\n    codes[:] = Path.LINETO\n    codes[0] = Path.MOVETO\n    codes[mask] = Path.MOVETO\n    codes[1:][mask[:-1]] = Path.MOVETO\n    path = Path(pixel, codes=codes)\n    return path",
            "def get_gridline_path(world, pixel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Draw a grid line.\\n\\n    Parameters\\n    ----------\\n    world : ndarray\\n        The longitude and latitude values along the curve, given as a (n,2)\\n        array.\\n    pixel : ndarray\\n        The pixel coordinates corresponding to ``lon_lat``\\n    '\n    mask = np.isnan(pixel[:, 0]) | np.isnan(pixel[:, 1])\n    codes = np.zeros(world.shape[0], dtype=np.uint8)\n    codes[:] = Path.LINETO\n    codes[0] = Path.MOVETO\n    codes[mask] = Path.MOVETO\n    codes[1:][mask[:-1]] = Path.MOVETO\n    path = Path(pixel, codes=codes)\n    return path",
            "def get_gridline_path(world, pixel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Draw a grid line.\\n\\n    Parameters\\n    ----------\\n    world : ndarray\\n        The longitude and latitude values along the curve, given as a (n,2)\\n        array.\\n    pixel : ndarray\\n        The pixel coordinates corresponding to ``lon_lat``\\n    '\n    mask = np.isnan(pixel[:, 0]) | np.isnan(pixel[:, 1])\n    codes = np.zeros(world.shape[0], dtype=np.uint8)\n    codes[:] = Path.LINETO\n    codes[0] = Path.MOVETO\n    codes[mask] = Path.MOVETO\n    codes[1:][mask[:-1]] = Path.MOVETO\n    path = Path(pixel, codes=codes)\n    return path",
            "def get_gridline_path(world, pixel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Draw a grid line.\\n\\n    Parameters\\n    ----------\\n    world : ndarray\\n        The longitude and latitude values along the curve, given as a (n,2)\\n        array.\\n    pixel : ndarray\\n        The pixel coordinates corresponding to ``lon_lat``\\n    '\n    mask = np.isnan(pixel[:, 0]) | np.isnan(pixel[:, 1])\n    codes = np.zeros(world.shape[0], dtype=np.uint8)\n    codes[:] = Path.LINETO\n    codes[0] = Path.MOVETO\n    codes[mask] = Path.MOVETO\n    codes[1:][mask[:-1]] = Path.MOVETO\n    path = Path(pixel, codes=codes)\n    return path"
        ]
    }
]