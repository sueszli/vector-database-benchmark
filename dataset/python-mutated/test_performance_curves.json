[
    {
        "func_name": "setUp",
        "original": "def setUp(self):\n    (n, p) = (0, 1)\n    self.data = np.array([(p, 0.8), (n, 0.7), (p, 0.6), (p, 0.55), (p, 0.54), (n, 0.53), (n, 0.52), (p, 0.51), (n, 0.505), (p, 0.4), (n, 0.39), (p, 0.38), (n, 0.37), (n, 0.36), (n, 0.35), (p, 0.34), (n, 0.33), (p, 0.3), (n, 0.1)])",
        "mutated": [
            "def setUp(self):\n    if False:\n        i = 10\n    (n, p) = (0, 1)\n    self.data = np.array([(p, 0.8), (n, 0.7), (p, 0.6), (p, 0.55), (p, 0.54), (n, 0.53), (n, 0.52), (p, 0.51), (n, 0.505), (p, 0.4), (n, 0.39), (p, 0.38), (n, 0.37), (n, 0.36), (n, 0.35), (p, 0.34), (n, 0.33), (p, 0.3), (n, 0.1)])",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (n, p) = (0, 1)\n    self.data = np.array([(p, 0.8), (n, 0.7), (p, 0.6), (p, 0.55), (p, 0.54), (n, 0.53), (n, 0.52), (p, 0.51), (n, 0.505), (p, 0.4), (n, 0.39), (p, 0.38), (n, 0.37), (n, 0.36), (n, 0.35), (p, 0.34), (n, 0.33), (p, 0.3), (n, 0.1)])",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (n, p) = (0, 1)\n    self.data = np.array([(p, 0.8), (n, 0.7), (p, 0.6), (p, 0.55), (p, 0.54), (n, 0.53), (n, 0.52), (p, 0.51), (n, 0.505), (p, 0.4), (n, 0.39), (p, 0.38), (n, 0.37), (n, 0.36), (n, 0.35), (p, 0.34), (n, 0.33), (p, 0.3), (n, 0.1)])",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (n, p) = (0, 1)\n    self.data = np.array([(p, 0.8), (n, 0.7), (p, 0.6), (p, 0.55), (p, 0.54), (n, 0.53), (n, 0.52), (p, 0.51), (n, 0.505), (p, 0.4), (n, 0.39), (p, 0.38), (n, 0.37), (n, 0.36), (n, 0.35), (p, 0.34), (n, 0.33), (p, 0.3), (n, 0.1)])",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (n, p) = (0, 1)\n    self.data = np.array([(p, 0.8), (n, 0.7), (p, 0.6), (p, 0.55), (p, 0.54), (n, 0.53), (n, 0.52), (p, 0.51), (n, 0.505), (p, 0.4), (n, 0.39), (p, 0.38), (n, 0.37), (n, 0.36), (n, 0.35), (p, 0.34), (n, 0.33), (p, 0.3), (n, 0.1)])"
        ]
    },
    {
        "func_name": "test_curves",
        "original": "def test_curves(self):\n    np.random.shuffle(self.data)\n    (ytrue, probs) = self.data.T\n    curves = Curves(ytrue, probs)\n    tn = np.array([0, 1, 1, 2, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 9, 9, 9, 9, 10, 10])\n    np.testing.assert_equal(curves.tn, tn)\n    np.testing.assert_equal(curves.fp, 10 - tn)\n    np.testing.assert_almost_equal(curves.specificity(), tn / 10)\n    tp = np.array([9, 9, 8, 8, 7, 7, 7, 7, 6, 6, 5, 5, 4, 4, 4, 3, 2, 1, 1, 0])\n    np.testing.assert_equal(curves.tp, tp)\n    np.testing.assert_equal(curves.fn, 9 - tp)\n    np.testing.assert_almost_equal(curves.sensitivity(), tp / 9)\n    np.testing.assert_almost_equal(curves.ca(), np.array([9, 10, 9, 10, 9, 10, 11, 12, 11, 12, 11, 12, 11, 12, 13, 12, 11, 10, 11, 10]) / 19)\n    precision = np.array([9 / 19, 9 / 18, 8 / 17, 8 / 16, 7 / 15, 7 / 14, 7 / 13, 7 / 12, 6 / 11, 6 / 10, 5 / 9, 5 / 8, 4 / 7, 4 / 6, 4 / 5, 3 / 4, 2 / 3, 1 / 2, 1 / 1, 1])\n    np.testing.assert_almost_equal(curves.precision(), precision)\n    np.testing.assert_almost_equal(curves.recall(), tp / 9)\n    np.testing.assert_almost_equal(curves.ppv(), precision)\n    np.testing.assert_almost_equal(curves.npv(), np.array([1, 1 / 1, 1 / 2, 2 / 3, 2 / 4, 3 / 5, 4 / 6, 5 / 7, 5 / 8, 6 / 9, 6 / 10, 7 / 11, 7 / 12, 8 / 13, 9 / 14, 9 / 15, 9 / 16, 9 / 17, 10 / 18, 10 / 19]))\n    np.testing.assert_almost_equal(curves.tpr(), tp / 9)\n    np.testing.assert_almost_equal(curves.fpr(), (10 - tn) / 10)",
        "mutated": [
            "def test_curves(self):\n    if False:\n        i = 10\n    np.random.shuffle(self.data)\n    (ytrue, probs) = self.data.T\n    curves = Curves(ytrue, probs)\n    tn = np.array([0, 1, 1, 2, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 9, 9, 9, 9, 10, 10])\n    np.testing.assert_equal(curves.tn, tn)\n    np.testing.assert_equal(curves.fp, 10 - tn)\n    np.testing.assert_almost_equal(curves.specificity(), tn / 10)\n    tp = np.array([9, 9, 8, 8, 7, 7, 7, 7, 6, 6, 5, 5, 4, 4, 4, 3, 2, 1, 1, 0])\n    np.testing.assert_equal(curves.tp, tp)\n    np.testing.assert_equal(curves.fn, 9 - tp)\n    np.testing.assert_almost_equal(curves.sensitivity(), tp / 9)\n    np.testing.assert_almost_equal(curves.ca(), np.array([9, 10, 9, 10, 9, 10, 11, 12, 11, 12, 11, 12, 11, 12, 13, 12, 11, 10, 11, 10]) / 19)\n    precision = np.array([9 / 19, 9 / 18, 8 / 17, 8 / 16, 7 / 15, 7 / 14, 7 / 13, 7 / 12, 6 / 11, 6 / 10, 5 / 9, 5 / 8, 4 / 7, 4 / 6, 4 / 5, 3 / 4, 2 / 3, 1 / 2, 1 / 1, 1])\n    np.testing.assert_almost_equal(curves.precision(), precision)\n    np.testing.assert_almost_equal(curves.recall(), tp / 9)\n    np.testing.assert_almost_equal(curves.ppv(), precision)\n    np.testing.assert_almost_equal(curves.npv(), np.array([1, 1 / 1, 1 / 2, 2 / 3, 2 / 4, 3 / 5, 4 / 6, 5 / 7, 5 / 8, 6 / 9, 6 / 10, 7 / 11, 7 / 12, 8 / 13, 9 / 14, 9 / 15, 9 / 16, 9 / 17, 10 / 18, 10 / 19]))\n    np.testing.assert_almost_equal(curves.tpr(), tp / 9)\n    np.testing.assert_almost_equal(curves.fpr(), (10 - tn) / 10)",
            "def test_curves(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    np.random.shuffle(self.data)\n    (ytrue, probs) = self.data.T\n    curves = Curves(ytrue, probs)\n    tn = np.array([0, 1, 1, 2, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 9, 9, 9, 9, 10, 10])\n    np.testing.assert_equal(curves.tn, tn)\n    np.testing.assert_equal(curves.fp, 10 - tn)\n    np.testing.assert_almost_equal(curves.specificity(), tn / 10)\n    tp = np.array([9, 9, 8, 8, 7, 7, 7, 7, 6, 6, 5, 5, 4, 4, 4, 3, 2, 1, 1, 0])\n    np.testing.assert_equal(curves.tp, tp)\n    np.testing.assert_equal(curves.fn, 9 - tp)\n    np.testing.assert_almost_equal(curves.sensitivity(), tp / 9)\n    np.testing.assert_almost_equal(curves.ca(), np.array([9, 10, 9, 10, 9, 10, 11, 12, 11, 12, 11, 12, 11, 12, 13, 12, 11, 10, 11, 10]) / 19)\n    precision = np.array([9 / 19, 9 / 18, 8 / 17, 8 / 16, 7 / 15, 7 / 14, 7 / 13, 7 / 12, 6 / 11, 6 / 10, 5 / 9, 5 / 8, 4 / 7, 4 / 6, 4 / 5, 3 / 4, 2 / 3, 1 / 2, 1 / 1, 1])\n    np.testing.assert_almost_equal(curves.precision(), precision)\n    np.testing.assert_almost_equal(curves.recall(), tp / 9)\n    np.testing.assert_almost_equal(curves.ppv(), precision)\n    np.testing.assert_almost_equal(curves.npv(), np.array([1, 1 / 1, 1 / 2, 2 / 3, 2 / 4, 3 / 5, 4 / 6, 5 / 7, 5 / 8, 6 / 9, 6 / 10, 7 / 11, 7 / 12, 8 / 13, 9 / 14, 9 / 15, 9 / 16, 9 / 17, 10 / 18, 10 / 19]))\n    np.testing.assert_almost_equal(curves.tpr(), tp / 9)\n    np.testing.assert_almost_equal(curves.fpr(), (10 - tn) / 10)",
            "def test_curves(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    np.random.shuffle(self.data)\n    (ytrue, probs) = self.data.T\n    curves = Curves(ytrue, probs)\n    tn = np.array([0, 1, 1, 2, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 9, 9, 9, 9, 10, 10])\n    np.testing.assert_equal(curves.tn, tn)\n    np.testing.assert_equal(curves.fp, 10 - tn)\n    np.testing.assert_almost_equal(curves.specificity(), tn / 10)\n    tp = np.array([9, 9, 8, 8, 7, 7, 7, 7, 6, 6, 5, 5, 4, 4, 4, 3, 2, 1, 1, 0])\n    np.testing.assert_equal(curves.tp, tp)\n    np.testing.assert_equal(curves.fn, 9 - tp)\n    np.testing.assert_almost_equal(curves.sensitivity(), tp / 9)\n    np.testing.assert_almost_equal(curves.ca(), np.array([9, 10, 9, 10, 9, 10, 11, 12, 11, 12, 11, 12, 11, 12, 13, 12, 11, 10, 11, 10]) / 19)\n    precision = np.array([9 / 19, 9 / 18, 8 / 17, 8 / 16, 7 / 15, 7 / 14, 7 / 13, 7 / 12, 6 / 11, 6 / 10, 5 / 9, 5 / 8, 4 / 7, 4 / 6, 4 / 5, 3 / 4, 2 / 3, 1 / 2, 1 / 1, 1])\n    np.testing.assert_almost_equal(curves.precision(), precision)\n    np.testing.assert_almost_equal(curves.recall(), tp / 9)\n    np.testing.assert_almost_equal(curves.ppv(), precision)\n    np.testing.assert_almost_equal(curves.npv(), np.array([1, 1 / 1, 1 / 2, 2 / 3, 2 / 4, 3 / 5, 4 / 6, 5 / 7, 5 / 8, 6 / 9, 6 / 10, 7 / 11, 7 / 12, 8 / 13, 9 / 14, 9 / 15, 9 / 16, 9 / 17, 10 / 18, 10 / 19]))\n    np.testing.assert_almost_equal(curves.tpr(), tp / 9)\n    np.testing.assert_almost_equal(curves.fpr(), (10 - tn) / 10)",
            "def test_curves(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    np.random.shuffle(self.data)\n    (ytrue, probs) = self.data.T\n    curves = Curves(ytrue, probs)\n    tn = np.array([0, 1, 1, 2, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 9, 9, 9, 9, 10, 10])\n    np.testing.assert_equal(curves.tn, tn)\n    np.testing.assert_equal(curves.fp, 10 - tn)\n    np.testing.assert_almost_equal(curves.specificity(), tn / 10)\n    tp = np.array([9, 9, 8, 8, 7, 7, 7, 7, 6, 6, 5, 5, 4, 4, 4, 3, 2, 1, 1, 0])\n    np.testing.assert_equal(curves.tp, tp)\n    np.testing.assert_equal(curves.fn, 9 - tp)\n    np.testing.assert_almost_equal(curves.sensitivity(), tp / 9)\n    np.testing.assert_almost_equal(curves.ca(), np.array([9, 10, 9, 10, 9, 10, 11, 12, 11, 12, 11, 12, 11, 12, 13, 12, 11, 10, 11, 10]) / 19)\n    precision = np.array([9 / 19, 9 / 18, 8 / 17, 8 / 16, 7 / 15, 7 / 14, 7 / 13, 7 / 12, 6 / 11, 6 / 10, 5 / 9, 5 / 8, 4 / 7, 4 / 6, 4 / 5, 3 / 4, 2 / 3, 1 / 2, 1 / 1, 1])\n    np.testing.assert_almost_equal(curves.precision(), precision)\n    np.testing.assert_almost_equal(curves.recall(), tp / 9)\n    np.testing.assert_almost_equal(curves.ppv(), precision)\n    np.testing.assert_almost_equal(curves.npv(), np.array([1, 1 / 1, 1 / 2, 2 / 3, 2 / 4, 3 / 5, 4 / 6, 5 / 7, 5 / 8, 6 / 9, 6 / 10, 7 / 11, 7 / 12, 8 / 13, 9 / 14, 9 / 15, 9 / 16, 9 / 17, 10 / 18, 10 / 19]))\n    np.testing.assert_almost_equal(curves.tpr(), tp / 9)\n    np.testing.assert_almost_equal(curves.fpr(), (10 - tn) / 10)",
            "def test_curves(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    np.random.shuffle(self.data)\n    (ytrue, probs) = self.data.T\n    curves = Curves(ytrue, probs)\n    tn = np.array([0, 1, 1, 2, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 9, 9, 9, 9, 10, 10])\n    np.testing.assert_equal(curves.tn, tn)\n    np.testing.assert_equal(curves.fp, 10 - tn)\n    np.testing.assert_almost_equal(curves.specificity(), tn / 10)\n    tp = np.array([9, 9, 8, 8, 7, 7, 7, 7, 6, 6, 5, 5, 4, 4, 4, 3, 2, 1, 1, 0])\n    np.testing.assert_equal(curves.tp, tp)\n    np.testing.assert_equal(curves.fn, 9 - tp)\n    np.testing.assert_almost_equal(curves.sensitivity(), tp / 9)\n    np.testing.assert_almost_equal(curves.ca(), np.array([9, 10, 9, 10, 9, 10, 11, 12, 11, 12, 11, 12, 11, 12, 13, 12, 11, 10, 11, 10]) / 19)\n    precision = np.array([9 / 19, 9 / 18, 8 / 17, 8 / 16, 7 / 15, 7 / 14, 7 / 13, 7 / 12, 6 / 11, 6 / 10, 5 / 9, 5 / 8, 4 / 7, 4 / 6, 4 / 5, 3 / 4, 2 / 3, 1 / 2, 1 / 1, 1])\n    np.testing.assert_almost_equal(curves.precision(), precision)\n    np.testing.assert_almost_equal(curves.recall(), tp / 9)\n    np.testing.assert_almost_equal(curves.ppv(), precision)\n    np.testing.assert_almost_equal(curves.npv(), np.array([1, 1 / 1, 1 / 2, 2 / 3, 2 / 4, 3 / 5, 4 / 6, 5 / 7, 5 / 8, 6 / 9, 6 / 10, 7 / 11, 7 / 12, 8 / 13, 9 / 14, 9 / 15, 9 / 16, 9 / 17, 10 / 18, 10 / 19]))\n    np.testing.assert_almost_equal(curves.tpr(), tp / 9)\n    np.testing.assert_almost_equal(curves.fpr(), (10 - tn) / 10)"
        ]
    },
    {
        "func_name": "test_curves_from_results",
        "original": "@patch('Orange.evaluation.performance_curves.Curves.__init__', return_value=None)\ndef test_curves_from_results(self, init):\n    res = Results()\n    (ytrue, probs) = self.data.T\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.vstack((1 - probs, probs)).T.reshape(1, -1, 2)\n    Curves.from_results(res)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue)\n    np.testing.assert_equal(cprobs, probs)\n    Curves.from_results(res, target_class=0)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, 1 - ytrue)\n    np.testing.assert_equal(cprobs, 1 - probs)\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.random.random((2, 19, 2))\n    res.probabilities[1] = np.vstack((1 - probs, probs)).T\n    Curves.from_results(res, model_index=1)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue)\n    np.testing.assert_equal(cprobs, probs)\n    self.assertRaises(ValueError, Curves.from_results, res)\n    ytrue[ytrue == 0] = 2 * (np.arange(10) % 2)\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.random.random((2, 19, 3))\n    res.probabilities[1] = np.vstack(((1 - probs) / 3, probs, (1 - probs) * 2 / 3)).T\n    Curves.from_results(res, model_index=1, target_class=1)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 1)\n    np.testing.assert_equal(cprobs, probs)\n    Curves.from_results(res, model_index=1, target_class=0)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 0)\n    np.testing.assert_equal(cprobs, (1 - probs) / 3)\n    Curves.from_results(res, model_index=1, target_class=2)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 2)\n    np.testing.assert_equal(cprobs, (1 - probs) * 2 / 3)\n    self.assertRaises(ValueError, Curves.from_results, res, model_index=1)",
        "mutated": [
            "@patch('Orange.evaluation.performance_curves.Curves.__init__', return_value=None)\ndef test_curves_from_results(self, init):\n    if False:\n        i = 10\n    res = Results()\n    (ytrue, probs) = self.data.T\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.vstack((1 - probs, probs)).T.reshape(1, -1, 2)\n    Curves.from_results(res)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue)\n    np.testing.assert_equal(cprobs, probs)\n    Curves.from_results(res, target_class=0)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, 1 - ytrue)\n    np.testing.assert_equal(cprobs, 1 - probs)\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.random.random((2, 19, 2))\n    res.probabilities[1] = np.vstack((1 - probs, probs)).T\n    Curves.from_results(res, model_index=1)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue)\n    np.testing.assert_equal(cprobs, probs)\n    self.assertRaises(ValueError, Curves.from_results, res)\n    ytrue[ytrue == 0] = 2 * (np.arange(10) % 2)\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.random.random((2, 19, 3))\n    res.probabilities[1] = np.vstack(((1 - probs) / 3, probs, (1 - probs) * 2 / 3)).T\n    Curves.from_results(res, model_index=1, target_class=1)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 1)\n    np.testing.assert_equal(cprobs, probs)\n    Curves.from_results(res, model_index=1, target_class=0)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 0)\n    np.testing.assert_equal(cprobs, (1 - probs) / 3)\n    Curves.from_results(res, model_index=1, target_class=2)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 2)\n    np.testing.assert_equal(cprobs, (1 - probs) * 2 / 3)\n    self.assertRaises(ValueError, Curves.from_results, res, model_index=1)",
            "@patch('Orange.evaluation.performance_curves.Curves.__init__', return_value=None)\ndef test_curves_from_results(self, init):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    res = Results()\n    (ytrue, probs) = self.data.T\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.vstack((1 - probs, probs)).T.reshape(1, -1, 2)\n    Curves.from_results(res)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue)\n    np.testing.assert_equal(cprobs, probs)\n    Curves.from_results(res, target_class=0)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, 1 - ytrue)\n    np.testing.assert_equal(cprobs, 1 - probs)\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.random.random((2, 19, 2))\n    res.probabilities[1] = np.vstack((1 - probs, probs)).T\n    Curves.from_results(res, model_index=1)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue)\n    np.testing.assert_equal(cprobs, probs)\n    self.assertRaises(ValueError, Curves.from_results, res)\n    ytrue[ytrue == 0] = 2 * (np.arange(10) % 2)\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.random.random((2, 19, 3))\n    res.probabilities[1] = np.vstack(((1 - probs) / 3, probs, (1 - probs) * 2 / 3)).T\n    Curves.from_results(res, model_index=1, target_class=1)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 1)\n    np.testing.assert_equal(cprobs, probs)\n    Curves.from_results(res, model_index=1, target_class=0)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 0)\n    np.testing.assert_equal(cprobs, (1 - probs) / 3)\n    Curves.from_results(res, model_index=1, target_class=2)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 2)\n    np.testing.assert_equal(cprobs, (1 - probs) * 2 / 3)\n    self.assertRaises(ValueError, Curves.from_results, res, model_index=1)",
            "@patch('Orange.evaluation.performance_curves.Curves.__init__', return_value=None)\ndef test_curves_from_results(self, init):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    res = Results()\n    (ytrue, probs) = self.data.T\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.vstack((1 - probs, probs)).T.reshape(1, -1, 2)\n    Curves.from_results(res)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue)\n    np.testing.assert_equal(cprobs, probs)\n    Curves.from_results(res, target_class=0)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, 1 - ytrue)\n    np.testing.assert_equal(cprobs, 1 - probs)\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.random.random((2, 19, 2))\n    res.probabilities[1] = np.vstack((1 - probs, probs)).T\n    Curves.from_results(res, model_index=1)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue)\n    np.testing.assert_equal(cprobs, probs)\n    self.assertRaises(ValueError, Curves.from_results, res)\n    ytrue[ytrue == 0] = 2 * (np.arange(10) % 2)\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.random.random((2, 19, 3))\n    res.probabilities[1] = np.vstack(((1 - probs) / 3, probs, (1 - probs) * 2 / 3)).T\n    Curves.from_results(res, model_index=1, target_class=1)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 1)\n    np.testing.assert_equal(cprobs, probs)\n    Curves.from_results(res, model_index=1, target_class=0)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 0)\n    np.testing.assert_equal(cprobs, (1 - probs) / 3)\n    Curves.from_results(res, model_index=1, target_class=2)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 2)\n    np.testing.assert_equal(cprobs, (1 - probs) * 2 / 3)\n    self.assertRaises(ValueError, Curves.from_results, res, model_index=1)",
            "@patch('Orange.evaluation.performance_curves.Curves.__init__', return_value=None)\ndef test_curves_from_results(self, init):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    res = Results()\n    (ytrue, probs) = self.data.T\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.vstack((1 - probs, probs)).T.reshape(1, -1, 2)\n    Curves.from_results(res)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue)\n    np.testing.assert_equal(cprobs, probs)\n    Curves.from_results(res, target_class=0)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, 1 - ytrue)\n    np.testing.assert_equal(cprobs, 1 - probs)\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.random.random((2, 19, 2))\n    res.probabilities[1] = np.vstack((1 - probs, probs)).T\n    Curves.from_results(res, model_index=1)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue)\n    np.testing.assert_equal(cprobs, probs)\n    self.assertRaises(ValueError, Curves.from_results, res)\n    ytrue[ytrue == 0] = 2 * (np.arange(10) % 2)\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.random.random((2, 19, 3))\n    res.probabilities[1] = np.vstack(((1 - probs) / 3, probs, (1 - probs) * 2 / 3)).T\n    Curves.from_results(res, model_index=1, target_class=1)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 1)\n    np.testing.assert_equal(cprobs, probs)\n    Curves.from_results(res, model_index=1, target_class=0)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 0)\n    np.testing.assert_equal(cprobs, (1 - probs) / 3)\n    Curves.from_results(res, model_index=1, target_class=2)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 2)\n    np.testing.assert_equal(cprobs, (1 - probs) * 2 / 3)\n    self.assertRaises(ValueError, Curves.from_results, res, model_index=1)",
            "@patch('Orange.evaluation.performance_curves.Curves.__init__', return_value=None)\ndef test_curves_from_results(self, init):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    res = Results()\n    (ytrue, probs) = self.data.T\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.vstack((1 - probs, probs)).T.reshape(1, -1, 2)\n    Curves.from_results(res)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue)\n    np.testing.assert_equal(cprobs, probs)\n    Curves.from_results(res, target_class=0)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, 1 - ytrue)\n    np.testing.assert_equal(cprobs, 1 - probs)\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.random.random((2, 19, 2))\n    res.probabilities[1] = np.vstack((1 - probs, probs)).T\n    Curves.from_results(res, model_index=1)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue)\n    np.testing.assert_equal(cprobs, probs)\n    self.assertRaises(ValueError, Curves.from_results, res)\n    ytrue[ytrue == 0] = 2 * (np.arange(10) % 2)\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.random.random((2, 19, 3))\n    res.probabilities[1] = np.vstack(((1 - probs) / 3, probs, (1 - probs) * 2 / 3)).T\n    Curves.from_results(res, model_index=1, target_class=1)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 1)\n    np.testing.assert_equal(cprobs, probs)\n    Curves.from_results(res, model_index=1, target_class=0)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 0)\n    np.testing.assert_equal(cprobs, (1 - probs) / 3)\n    Curves.from_results(res, model_index=1, target_class=2)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue == 2)\n    np.testing.assert_equal(cprobs, (1 - probs) * 2 / 3)\n    self.assertRaises(ValueError, Curves.from_results, res, model_index=1)"
        ]
    },
    {
        "func_name": "test_curves_from_results_nans",
        "original": "@patch('Orange.evaluation.performance_curves.Curves.__init__', return_value=None)\ndef test_curves_from_results_nans(self, init):\n    res = Results()\n    (ytrue, probs) = self.data.T\n    ytrue[0] = np.nan\n    probs[-1] = np.nan\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.vstack((1 - probs, probs)).T.reshape(1, -1, 2)\n    Curves.from_results(res)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue[1:-1])\n    np.testing.assert_equal(cprobs, probs[1:-1])",
        "mutated": [
            "@patch('Orange.evaluation.performance_curves.Curves.__init__', return_value=None)\ndef test_curves_from_results_nans(self, init):\n    if False:\n        i = 10\n    res = Results()\n    (ytrue, probs) = self.data.T\n    ytrue[0] = np.nan\n    probs[-1] = np.nan\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.vstack((1 - probs, probs)).T.reshape(1, -1, 2)\n    Curves.from_results(res)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue[1:-1])\n    np.testing.assert_equal(cprobs, probs[1:-1])",
            "@patch('Orange.evaluation.performance_curves.Curves.__init__', return_value=None)\ndef test_curves_from_results_nans(self, init):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    res = Results()\n    (ytrue, probs) = self.data.T\n    ytrue[0] = np.nan\n    probs[-1] = np.nan\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.vstack((1 - probs, probs)).T.reshape(1, -1, 2)\n    Curves.from_results(res)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue[1:-1])\n    np.testing.assert_equal(cprobs, probs[1:-1])",
            "@patch('Orange.evaluation.performance_curves.Curves.__init__', return_value=None)\ndef test_curves_from_results_nans(self, init):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    res = Results()\n    (ytrue, probs) = self.data.T\n    ytrue[0] = np.nan\n    probs[-1] = np.nan\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.vstack((1 - probs, probs)).T.reshape(1, -1, 2)\n    Curves.from_results(res)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue[1:-1])\n    np.testing.assert_equal(cprobs, probs[1:-1])",
            "@patch('Orange.evaluation.performance_curves.Curves.__init__', return_value=None)\ndef test_curves_from_results_nans(self, init):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    res = Results()\n    (ytrue, probs) = self.data.T\n    ytrue[0] = np.nan\n    probs[-1] = np.nan\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.vstack((1 - probs, probs)).T.reshape(1, -1, 2)\n    Curves.from_results(res)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue[1:-1])\n    np.testing.assert_equal(cprobs, probs[1:-1])",
            "@patch('Orange.evaluation.performance_curves.Curves.__init__', return_value=None)\ndef test_curves_from_results_nans(self, init):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    res = Results()\n    (ytrue, probs) = self.data.T\n    ytrue[0] = np.nan\n    probs[-1] = np.nan\n    res.actual = ytrue.astype(float)\n    res.probabilities = np.vstack((1 - probs, probs)).T.reshape(1, -1, 2)\n    Curves.from_results(res)\n    (cytrue, cprobs) = init.call_args[0]\n    np.testing.assert_equal(cytrue, ytrue[1:-1])\n    np.testing.assert_equal(cprobs, probs[1:-1])"
        ]
    }
]