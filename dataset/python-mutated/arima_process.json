[
    {
        "func_name": "arma_generate_sample",
        "original": "def arma_generate_sample(ar, ma, nsample, scale=1, distrvs=None, axis=0, burnin=0):\n    \"\"\"\n    Simulate data from an ARMA.\n\n    Parameters\n    ----------\n    ar : array_like\n        The coefficient for autoregressive lag polynomial, including zero lag.\n    ma : array_like\n        The coefficient for moving-average lag polynomial, including zero lag.\n    nsample : int or tuple of ints\n        If nsample is an integer, then this creates a 1d timeseries of\n        length size. If nsample is a tuple, creates a len(nsample)\n        dimensional time series where time is indexed along the input\n        variable ``axis``. All series are unless ``distrvs`` generates\n        dependent data.\n    scale : float\n        The standard deviation of noise.\n    distrvs : function, random number generator\n        A function that generates the random numbers, and takes ``size``\n        as argument. The default is np.random.standard_normal.\n    axis : int\n        See nsample for details.\n    burnin : int\n        Number of observation at the beginning of the sample to drop.\n        Used to reduce dependence on initial values.\n\n    Returns\n    -------\n    ndarray\n        Random sample(s) from an ARMA process.\n\n    Notes\n    -----\n    As mentioned above, both the AR and MA components should include the\n    coefficient on the zero-lag. This is typically 1. Further, due to the\n    conventions used in signal processing used in signal.lfilter vs.\n    conventions in statistics for ARMA processes, the AR parameters should\n    have the opposite sign of what you might expect. See the examples below.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> np.random.seed(12345)\n    >>> arparams = np.array([.75, -.25])\n    >>> maparams = np.array([.65, .35])\n    >>> ar = np.r_[1, -arparams] # add zero-lag and negate\n    >>> ma = np.r_[1, maparams] # add zero-lag\n    >>> y = sm.tsa.arma_generate_sample(ar, ma, 250)\n    >>> model = sm.tsa.ARIMA(y, (2, 0, 2), trend='n').fit(disp=0)\n    >>> model.params\n    array([ 0.79044189, -0.23140636,  0.70072904,  0.40608028])\n    \"\"\"\n    distrvs = np.random.standard_normal if distrvs is None else distrvs\n    if np.ndim(nsample) == 0:\n        nsample = [nsample]\n    if burnin:\n        newsize = list(nsample)\n        newsize[axis] += burnin\n        newsize = tuple(newsize)\n        fslice = [slice(None)] * len(newsize)\n        fslice[axis] = slice(burnin, None, None)\n        fslice = tuple(fslice)\n    else:\n        newsize = tuple(nsample)\n        fslice = tuple([slice(None)] * np.ndim(newsize))\n    eta = scale * distrvs(size=newsize)\n    return signal.lfilter(ma, ar, eta, axis=axis)[fslice]",
        "mutated": [
            "def arma_generate_sample(ar, ma, nsample, scale=1, distrvs=None, axis=0, burnin=0):\n    if False:\n        i = 10\n    \"\\n    Simulate data from an ARMA.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        The coefficient for autoregressive lag polynomial, including zero lag.\\n    ma : array_like\\n        The coefficient for moving-average lag polynomial, including zero lag.\\n    nsample : int or tuple of ints\\n        If nsample is an integer, then this creates a 1d timeseries of\\n        length size. If nsample is a tuple, creates a len(nsample)\\n        dimensional time series where time is indexed along the input\\n        variable ``axis``. All series are unless ``distrvs`` generates\\n        dependent data.\\n    scale : float\\n        The standard deviation of noise.\\n    distrvs : function, random number generator\\n        A function that generates the random numbers, and takes ``size``\\n        as argument. The default is np.random.standard_normal.\\n    axis : int\\n        See nsample for details.\\n    burnin : int\\n        Number of observation at the beginning of the sample to drop.\\n        Used to reduce dependence on initial values.\\n\\n    Returns\\n    -------\\n    ndarray\\n        Random sample(s) from an ARMA process.\\n\\n    Notes\\n    -----\\n    As mentioned above, both the AR and MA components should include the\\n    coefficient on the zero-lag. This is typically 1. Further, due to the\\n    conventions used in signal processing used in signal.lfilter vs.\\n    conventions in statistics for ARMA processes, the AR parameters should\\n    have the opposite sign of what you might expect. See the examples below.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> np.random.seed(12345)\\n    >>> arparams = np.array([.75, -.25])\\n    >>> maparams = np.array([.65, .35])\\n    >>> ar = np.r_[1, -arparams] # add zero-lag and negate\\n    >>> ma = np.r_[1, maparams] # add zero-lag\\n    >>> y = sm.tsa.arma_generate_sample(ar, ma, 250)\\n    >>> model = sm.tsa.ARIMA(y, (2, 0, 2), trend='n').fit(disp=0)\\n    >>> model.params\\n    array([ 0.79044189, -0.23140636,  0.70072904,  0.40608028])\\n    \"\n    distrvs = np.random.standard_normal if distrvs is None else distrvs\n    if np.ndim(nsample) == 0:\n        nsample = [nsample]\n    if burnin:\n        newsize = list(nsample)\n        newsize[axis] += burnin\n        newsize = tuple(newsize)\n        fslice = [slice(None)] * len(newsize)\n        fslice[axis] = slice(burnin, None, None)\n        fslice = tuple(fslice)\n    else:\n        newsize = tuple(nsample)\n        fslice = tuple([slice(None)] * np.ndim(newsize))\n    eta = scale * distrvs(size=newsize)\n    return signal.lfilter(ma, ar, eta, axis=axis)[fslice]",
            "def arma_generate_sample(ar, ma, nsample, scale=1, distrvs=None, axis=0, burnin=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Simulate data from an ARMA.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        The coefficient for autoregressive lag polynomial, including zero lag.\\n    ma : array_like\\n        The coefficient for moving-average lag polynomial, including zero lag.\\n    nsample : int or tuple of ints\\n        If nsample is an integer, then this creates a 1d timeseries of\\n        length size. If nsample is a tuple, creates a len(nsample)\\n        dimensional time series where time is indexed along the input\\n        variable ``axis``. All series are unless ``distrvs`` generates\\n        dependent data.\\n    scale : float\\n        The standard deviation of noise.\\n    distrvs : function, random number generator\\n        A function that generates the random numbers, and takes ``size``\\n        as argument. The default is np.random.standard_normal.\\n    axis : int\\n        See nsample for details.\\n    burnin : int\\n        Number of observation at the beginning of the sample to drop.\\n        Used to reduce dependence on initial values.\\n\\n    Returns\\n    -------\\n    ndarray\\n        Random sample(s) from an ARMA process.\\n\\n    Notes\\n    -----\\n    As mentioned above, both the AR and MA components should include the\\n    coefficient on the zero-lag. This is typically 1. Further, due to the\\n    conventions used in signal processing used in signal.lfilter vs.\\n    conventions in statistics for ARMA processes, the AR parameters should\\n    have the opposite sign of what you might expect. See the examples below.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> np.random.seed(12345)\\n    >>> arparams = np.array([.75, -.25])\\n    >>> maparams = np.array([.65, .35])\\n    >>> ar = np.r_[1, -arparams] # add zero-lag and negate\\n    >>> ma = np.r_[1, maparams] # add zero-lag\\n    >>> y = sm.tsa.arma_generate_sample(ar, ma, 250)\\n    >>> model = sm.tsa.ARIMA(y, (2, 0, 2), trend='n').fit(disp=0)\\n    >>> model.params\\n    array([ 0.79044189, -0.23140636,  0.70072904,  0.40608028])\\n    \"\n    distrvs = np.random.standard_normal if distrvs is None else distrvs\n    if np.ndim(nsample) == 0:\n        nsample = [nsample]\n    if burnin:\n        newsize = list(nsample)\n        newsize[axis] += burnin\n        newsize = tuple(newsize)\n        fslice = [slice(None)] * len(newsize)\n        fslice[axis] = slice(burnin, None, None)\n        fslice = tuple(fslice)\n    else:\n        newsize = tuple(nsample)\n        fslice = tuple([slice(None)] * np.ndim(newsize))\n    eta = scale * distrvs(size=newsize)\n    return signal.lfilter(ma, ar, eta, axis=axis)[fslice]",
            "def arma_generate_sample(ar, ma, nsample, scale=1, distrvs=None, axis=0, burnin=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Simulate data from an ARMA.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        The coefficient for autoregressive lag polynomial, including zero lag.\\n    ma : array_like\\n        The coefficient for moving-average lag polynomial, including zero lag.\\n    nsample : int or tuple of ints\\n        If nsample is an integer, then this creates a 1d timeseries of\\n        length size. If nsample is a tuple, creates a len(nsample)\\n        dimensional time series where time is indexed along the input\\n        variable ``axis``. All series are unless ``distrvs`` generates\\n        dependent data.\\n    scale : float\\n        The standard deviation of noise.\\n    distrvs : function, random number generator\\n        A function that generates the random numbers, and takes ``size``\\n        as argument. The default is np.random.standard_normal.\\n    axis : int\\n        See nsample for details.\\n    burnin : int\\n        Number of observation at the beginning of the sample to drop.\\n        Used to reduce dependence on initial values.\\n\\n    Returns\\n    -------\\n    ndarray\\n        Random sample(s) from an ARMA process.\\n\\n    Notes\\n    -----\\n    As mentioned above, both the AR and MA components should include the\\n    coefficient on the zero-lag. This is typically 1. Further, due to the\\n    conventions used in signal processing used in signal.lfilter vs.\\n    conventions in statistics for ARMA processes, the AR parameters should\\n    have the opposite sign of what you might expect. See the examples below.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> np.random.seed(12345)\\n    >>> arparams = np.array([.75, -.25])\\n    >>> maparams = np.array([.65, .35])\\n    >>> ar = np.r_[1, -arparams] # add zero-lag and negate\\n    >>> ma = np.r_[1, maparams] # add zero-lag\\n    >>> y = sm.tsa.arma_generate_sample(ar, ma, 250)\\n    >>> model = sm.tsa.ARIMA(y, (2, 0, 2), trend='n').fit(disp=0)\\n    >>> model.params\\n    array([ 0.79044189, -0.23140636,  0.70072904,  0.40608028])\\n    \"\n    distrvs = np.random.standard_normal if distrvs is None else distrvs\n    if np.ndim(nsample) == 0:\n        nsample = [nsample]\n    if burnin:\n        newsize = list(nsample)\n        newsize[axis] += burnin\n        newsize = tuple(newsize)\n        fslice = [slice(None)] * len(newsize)\n        fslice[axis] = slice(burnin, None, None)\n        fslice = tuple(fslice)\n    else:\n        newsize = tuple(nsample)\n        fslice = tuple([slice(None)] * np.ndim(newsize))\n    eta = scale * distrvs(size=newsize)\n    return signal.lfilter(ma, ar, eta, axis=axis)[fslice]",
            "def arma_generate_sample(ar, ma, nsample, scale=1, distrvs=None, axis=0, burnin=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Simulate data from an ARMA.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        The coefficient for autoregressive lag polynomial, including zero lag.\\n    ma : array_like\\n        The coefficient for moving-average lag polynomial, including zero lag.\\n    nsample : int or tuple of ints\\n        If nsample is an integer, then this creates a 1d timeseries of\\n        length size. If nsample is a tuple, creates a len(nsample)\\n        dimensional time series where time is indexed along the input\\n        variable ``axis``. All series are unless ``distrvs`` generates\\n        dependent data.\\n    scale : float\\n        The standard deviation of noise.\\n    distrvs : function, random number generator\\n        A function that generates the random numbers, and takes ``size``\\n        as argument. The default is np.random.standard_normal.\\n    axis : int\\n        See nsample for details.\\n    burnin : int\\n        Number of observation at the beginning of the sample to drop.\\n        Used to reduce dependence on initial values.\\n\\n    Returns\\n    -------\\n    ndarray\\n        Random sample(s) from an ARMA process.\\n\\n    Notes\\n    -----\\n    As mentioned above, both the AR and MA components should include the\\n    coefficient on the zero-lag. This is typically 1. Further, due to the\\n    conventions used in signal processing used in signal.lfilter vs.\\n    conventions in statistics for ARMA processes, the AR parameters should\\n    have the opposite sign of what you might expect. See the examples below.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> np.random.seed(12345)\\n    >>> arparams = np.array([.75, -.25])\\n    >>> maparams = np.array([.65, .35])\\n    >>> ar = np.r_[1, -arparams] # add zero-lag and negate\\n    >>> ma = np.r_[1, maparams] # add zero-lag\\n    >>> y = sm.tsa.arma_generate_sample(ar, ma, 250)\\n    >>> model = sm.tsa.ARIMA(y, (2, 0, 2), trend='n').fit(disp=0)\\n    >>> model.params\\n    array([ 0.79044189, -0.23140636,  0.70072904,  0.40608028])\\n    \"\n    distrvs = np.random.standard_normal if distrvs is None else distrvs\n    if np.ndim(nsample) == 0:\n        nsample = [nsample]\n    if burnin:\n        newsize = list(nsample)\n        newsize[axis] += burnin\n        newsize = tuple(newsize)\n        fslice = [slice(None)] * len(newsize)\n        fslice[axis] = slice(burnin, None, None)\n        fslice = tuple(fslice)\n    else:\n        newsize = tuple(nsample)\n        fslice = tuple([slice(None)] * np.ndim(newsize))\n    eta = scale * distrvs(size=newsize)\n    return signal.lfilter(ma, ar, eta, axis=axis)[fslice]",
            "def arma_generate_sample(ar, ma, nsample, scale=1, distrvs=None, axis=0, burnin=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Simulate data from an ARMA.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        The coefficient for autoregressive lag polynomial, including zero lag.\\n    ma : array_like\\n        The coefficient for moving-average lag polynomial, including zero lag.\\n    nsample : int or tuple of ints\\n        If nsample is an integer, then this creates a 1d timeseries of\\n        length size. If nsample is a tuple, creates a len(nsample)\\n        dimensional time series where time is indexed along the input\\n        variable ``axis``. All series are unless ``distrvs`` generates\\n        dependent data.\\n    scale : float\\n        The standard deviation of noise.\\n    distrvs : function, random number generator\\n        A function that generates the random numbers, and takes ``size``\\n        as argument. The default is np.random.standard_normal.\\n    axis : int\\n        See nsample for details.\\n    burnin : int\\n        Number of observation at the beginning of the sample to drop.\\n        Used to reduce dependence on initial values.\\n\\n    Returns\\n    -------\\n    ndarray\\n        Random sample(s) from an ARMA process.\\n\\n    Notes\\n    -----\\n    As mentioned above, both the AR and MA components should include the\\n    coefficient on the zero-lag. This is typically 1. Further, due to the\\n    conventions used in signal processing used in signal.lfilter vs.\\n    conventions in statistics for ARMA processes, the AR parameters should\\n    have the opposite sign of what you might expect. See the examples below.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> np.random.seed(12345)\\n    >>> arparams = np.array([.75, -.25])\\n    >>> maparams = np.array([.65, .35])\\n    >>> ar = np.r_[1, -arparams] # add zero-lag and negate\\n    >>> ma = np.r_[1, maparams] # add zero-lag\\n    >>> y = sm.tsa.arma_generate_sample(ar, ma, 250)\\n    >>> model = sm.tsa.ARIMA(y, (2, 0, 2), trend='n').fit(disp=0)\\n    >>> model.params\\n    array([ 0.79044189, -0.23140636,  0.70072904,  0.40608028])\\n    \"\n    distrvs = np.random.standard_normal if distrvs is None else distrvs\n    if np.ndim(nsample) == 0:\n        nsample = [nsample]\n    if burnin:\n        newsize = list(nsample)\n        newsize[axis] += burnin\n        newsize = tuple(newsize)\n        fslice = [slice(None)] * len(newsize)\n        fslice[axis] = slice(burnin, None, None)\n        fslice = tuple(fslice)\n    else:\n        newsize = tuple(nsample)\n        fslice = tuple([slice(None)] * np.ndim(newsize))\n    eta = scale * distrvs(size=newsize)\n    return signal.lfilter(ma, ar, eta, axis=axis)[fslice]"
        ]
    },
    {
        "func_name": "arma_acovf",
        "original": "def arma_acovf(ar, ma, nobs=10, sigma2=1, dtype=None):\n    \"\"\"\n    Theoretical autocovariances of stationary ARMA processes\n\n    Parameters\n    ----------\n    ar : array_like, 1d\n        The coefficients for autoregressive lag polynomial, including zero lag.\n    ma : array_like, 1d\n        The coefficients for moving-average lag polynomial, including zero lag.\n    nobs : int\n        The number of terms (lags plus zero lag) to include in returned acovf.\n    sigma2 : float\n        Variance of the innovation term.\n\n    Returns\n    -------\n    ndarray\n        The autocovariance of ARMA process given by ar, ma.\n\n    See Also\n    --------\n    arma_acf : Autocorrelation function for ARMA processes.\n    acovf : Sample autocovariance estimation.\n\n    References\n    ----------\n    .. [*] Brockwell, Peter J., and Richard A. Davis. 2009. Time Series:\n        Theory and Methods. 2nd ed. 1991. New York, NY: Springer.\n    \"\"\"\n    if dtype is None:\n        dtype = np.common_type(np.array(ar), np.array(ma), np.array(sigma2))\n    p = len(ar) - 1\n    q = len(ma) - 1\n    m = max(p, q) + 1\n    if sigma2.real < 0:\n        raise ValueError('Must have positive innovation variance.')\n    if p == q == 0:\n        out = np.zeros(nobs, dtype=dtype)\n        out[0] = sigma2\n        return out\n    elif p > 0 and np.max(np.abs(np.roots(ar))) >= 1:\n        raise ValueError(NONSTATIONARY_ERROR)\n    ma_coeffs = arma2ma(ar, ma, lags=m)\n    A = np.zeros((m, m), dtype=dtype)\n    b = np.zeros((m, 1), dtype=dtype)\n    tmp_ar = np.zeros(m, dtype=dtype)\n    tmp_ar[:p + 1] = ar\n    for k in range(m):\n        A[k, :k + 1] = tmp_ar[:k + 1][::-1]\n        A[k, 1:m - k] += tmp_ar[k + 1:m]\n        b[k] = sigma2 * np.dot(ma[k:q + 1], ma_coeffs[:max(q + 1 - k, 0)])\n    acovf = np.zeros(max(nobs, m), dtype=dtype)\n    try:\n        acovf[:m] = np.linalg.solve(A, b)[:, 0]\n    except np.linalg.LinAlgError:\n        raise ValueError(NONSTATIONARY_ERROR)\n    if nobs > m:\n        zi = signal.lfiltic([1], ar, acovf[:m][::-1])\n        acovf[m:] = signal.lfilter([1], ar, np.zeros(nobs - m, dtype=dtype), zi=zi)[0]\n    return acovf[:nobs]",
        "mutated": [
            "def arma_acovf(ar, ma, nobs=10, sigma2=1, dtype=None):\n    if False:\n        i = 10\n    '\\n    Theoretical autocovariances of stationary ARMA processes\\n\\n    Parameters\\n    ----------\\n    ar : array_like, 1d\\n        The coefficients for autoregressive lag polynomial, including zero lag.\\n    ma : array_like, 1d\\n        The coefficients for moving-average lag polynomial, including zero lag.\\n    nobs : int\\n        The number of terms (lags plus zero lag) to include in returned acovf.\\n    sigma2 : float\\n        Variance of the innovation term.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The autocovariance of ARMA process given by ar, ma.\\n\\n    See Also\\n    --------\\n    arma_acf : Autocorrelation function for ARMA processes.\\n    acovf : Sample autocovariance estimation.\\n\\n    References\\n    ----------\\n    .. [*] Brockwell, Peter J., and Richard A. Davis. 2009. Time Series:\\n        Theory and Methods. 2nd ed. 1991. New York, NY: Springer.\\n    '\n    if dtype is None:\n        dtype = np.common_type(np.array(ar), np.array(ma), np.array(sigma2))\n    p = len(ar) - 1\n    q = len(ma) - 1\n    m = max(p, q) + 1\n    if sigma2.real < 0:\n        raise ValueError('Must have positive innovation variance.')\n    if p == q == 0:\n        out = np.zeros(nobs, dtype=dtype)\n        out[0] = sigma2\n        return out\n    elif p > 0 and np.max(np.abs(np.roots(ar))) >= 1:\n        raise ValueError(NONSTATIONARY_ERROR)\n    ma_coeffs = arma2ma(ar, ma, lags=m)\n    A = np.zeros((m, m), dtype=dtype)\n    b = np.zeros((m, 1), dtype=dtype)\n    tmp_ar = np.zeros(m, dtype=dtype)\n    tmp_ar[:p + 1] = ar\n    for k in range(m):\n        A[k, :k + 1] = tmp_ar[:k + 1][::-1]\n        A[k, 1:m - k] += tmp_ar[k + 1:m]\n        b[k] = sigma2 * np.dot(ma[k:q + 1], ma_coeffs[:max(q + 1 - k, 0)])\n    acovf = np.zeros(max(nobs, m), dtype=dtype)\n    try:\n        acovf[:m] = np.linalg.solve(A, b)[:, 0]\n    except np.linalg.LinAlgError:\n        raise ValueError(NONSTATIONARY_ERROR)\n    if nobs > m:\n        zi = signal.lfiltic([1], ar, acovf[:m][::-1])\n        acovf[m:] = signal.lfilter([1], ar, np.zeros(nobs - m, dtype=dtype), zi=zi)[0]\n    return acovf[:nobs]",
            "def arma_acovf(ar, ma, nobs=10, sigma2=1, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Theoretical autocovariances of stationary ARMA processes\\n\\n    Parameters\\n    ----------\\n    ar : array_like, 1d\\n        The coefficients for autoregressive lag polynomial, including zero lag.\\n    ma : array_like, 1d\\n        The coefficients for moving-average lag polynomial, including zero lag.\\n    nobs : int\\n        The number of terms (lags plus zero lag) to include in returned acovf.\\n    sigma2 : float\\n        Variance of the innovation term.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The autocovariance of ARMA process given by ar, ma.\\n\\n    See Also\\n    --------\\n    arma_acf : Autocorrelation function for ARMA processes.\\n    acovf : Sample autocovariance estimation.\\n\\n    References\\n    ----------\\n    .. [*] Brockwell, Peter J., and Richard A. Davis. 2009. Time Series:\\n        Theory and Methods. 2nd ed. 1991. New York, NY: Springer.\\n    '\n    if dtype is None:\n        dtype = np.common_type(np.array(ar), np.array(ma), np.array(sigma2))\n    p = len(ar) - 1\n    q = len(ma) - 1\n    m = max(p, q) + 1\n    if sigma2.real < 0:\n        raise ValueError('Must have positive innovation variance.')\n    if p == q == 0:\n        out = np.zeros(nobs, dtype=dtype)\n        out[0] = sigma2\n        return out\n    elif p > 0 and np.max(np.abs(np.roots(ar))) >= 1:\n        raise ValueError(NONSTATIONARY_ERROR)\n    ma_coeffs = arma2ma(ar, ma, lags=m)\n    A = np.zeros((m, m), dtype=dtype)\n    b = np.zeros((m, 1), dtype=dtype)\n    tmp_ar = np.zeros(m, dtype=dtype)\n    tmp_ar[:p + 1] = ar\n    for k in range(m):\n        A[k, :k + 1] = tmp_ar[:k + 1][::-1]\n        A[k, 1:m - k] += tmp_ar[k + 1:m]\n        b[k] = sigma2 * np.dot(ma[k:q + 1], ma_coeffs[:max(q + 1 - k, 0)])\n    acovf = np.zeros(max(nobs, m), dtype=dtype)\n    try:\n        acovf[:m] = np.linalg.solve(A, b)[:, 0]\n    except np.linalg.LinAlgError:\n        raise ValueError(NONSTATIONARY_ERROR)\n    if nobs > m:\n        zi = signal.lfiltic([1], ar, acovf[:m][::-1])\n        acovf[m:] = signal.lfilter([1], ar, np.zeros(nobs - m, dtype=dtype), zi=zi)[0]\n    return acovf[:nobs]",
            "def arma_acovf(ar, ma, nobs=10, sigma2=1, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Theoretical autocovariances of stationary ARMA processes\\n\\n    Parameters\\n    ----------\\n    ar : array_like, 1d\\n        The coefficients for autoregressive lag polynomial, including zero lag.\\n    ma : array_like, 1d\\n        The coefficients for moving-average lag polynomial, including zero lag.\\n    nobs : int\\n        The number of terms (lags plus zero lag) to include in returned acovf.\\n    sigma2 : float\\n        Variance of the innovation term.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The autocovariance of ARMA process given by ar, ma.\\n\\n    See Also\\n    --------\\n    arma_acf : Autocorrelation function for ARMA processes.\\n    acovf : Sample autocovariance estimation.\\n\\n    References\\n    ----------\\n    .. [*] Brockwell, Peter J., and Richard A. Davis. 2009. Time Series:\\n        Theory and Methods. 2nd ed. 1991. New York, NY: Springer.\\n    '\n    if dtype is None:\n        dtype = np.common_type(np.array(ar), np.array(ma), np.array(sigma2))\n    p = len(ar) - 1\n    q = len(ma) - 1\n    m = max(p, q) + 1\n    if sigma2.real < 0:\n        raise ValueError('Must have positive innovation variance.')\n    if p == q == 0:\n        out = np.zeros(nobs, dtype=dtype)\n        out[0] = sigma2\n        return out\n    elif p > 0 and np.max(np.abs(np.roots(ar))) >= 1:\n        raise ValueError(NONSTATIONARY_ERROR)\n    ma_coeffs = arma2ma(ar, ma, lags=m)\n    A = np.zeros((m, m), dtype=dtype)\n    b = np.zeros((m, 1), dtype=dtype)\n    tmp_ar = np.zeros(m, dtype=dtype)\n    tmp_ar[:p + 1] = ar\n    for k in range(m):\n        A[k, :k + 1] = tmp_ar[:k + 1][::-1]\n        A[k, 1:m - k] += tmp_ar[k + 1:m]\n        b[k] = sigma2 * np.dot(ma[k:q + 1], ma_coeffs[:max(q + 1 - k, 0)])\n    acovf = np.zeros(max(nobs, m), dtype=dtype)\n    try:\n        acovf[:m] = np.linalg.solve(A, b)[:, 0]\n    except np.linalg.LinAlgError:\n        raise ValueError(NONSTATIONARY_ERROR)\n    if nobs > m:\n        zi = signal.lfiltic([1], ar, acovf[:m][::-1])\n        acovf[m:] = signal.lfilter([1], ar, np.zeros(nobs - m, dtype=dtype), zi=zi)[0]\n    return acovf[:nobs]",
            "def arma_acovf(ar, ma, nobs=10, sigma2=1, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Theoretical autocovariances of stationary ARMA processes\\n\\n    Parameters\\n    ----------\\n    ar : array_like, 1d\\n        The coefficients for autoregressive lag polynomial, including zero lag.\\n    ma : array_like, 1d\\n        The coefficients for moving-average lag polynomial, including zero lag.\\n    nobs : int\\n        The number of terms (lags plus zero lag) to include in returned acovf.\\n    sigma2 : float\\n        Variance of the innovation term.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The autocovariance of ARMA process given by ar, ma.\\n\\n    See Also\\n    --------\\n    arma_acf : Autocorrelation function for ARMA processes.\\n    acovf : Sample autocovariance estimation.\\n\\n    References\\n    ----------\\n    .. [*] Brockwell, Peter J., and Richard A. Davis. 2009. Time Series:\\n        Theory and Methods. 2nd ed. 1991. New York, NY: Springer.\\n    '\n    if dtype is None:\n        dtype = np.common_type(np.array(ar), np.array(ma), np.array(sigma2))\n    p = len(ar) - 1\n    q = len(ma) - 1\n    m = max(p, q) + 1\n    if sigma2.real < 0:\n        raise ValueError('Must have positive innovation variance.')\n    if p == q == 0:\n        out = np.zeros(nobs, dtype=dtype)\n        out[0] = sigma2\n        return out\n    elif p > 0 and np.max(np.abs(np.roots(ar))) >= 1:\n        raise ValueError(NONSTATIONARY_ERROR)\n    ma_coeffs = arma2ma(ar, ma, lags=m)\n    A = np.zeros((m, m), dtype=dtype)\n    b = np.zeros((m, 1), dtype=dtype)\n    tmp_ar = np.zeros(m, dtype=dtype)\n    tmp_ar[:p + 1] = ar\n    for k in range(m):\n        A[k, :k + 1] = tmp_ar[:k + 1][::-1]\n        A[k, 1:m - k] += tmp_ar[k + 1:m]\n        b[k] = sigma2 * np.dot(ma[k:q + 1], ma_coeffs[:max(q + 1 - k, 0)])\n    acovf = np.zeros(max(nobs, m), dtype=dtype)\n    try:\n        acovf[:m] = np.linalg.solve(A, b)[:, 0]\n    except np.linalg.LinAlgError:\n        raise ValueError(NONSTATIONARY_ERROR)\n    if nobs > m:\n        zi = signal.lfiltic([1], ar, acovf[:m][::-1])\n        acovf[m:] = signal.lfilter([1], ar, np.zeros(nobs - m, dtype=dtype), zi=zi)[0]\n    return acovf[:nobs]",
            "def arma_acovf(ar, ma, nobs=10, sigma2=1, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Theoretical autocovariances of stationary ARMA processes\\n\\n    Parameters\\n    ----------\\n    ar : array_like, 1d\\n        The coefficients for autoregressive lag polynomial, including zero lag.\\n    ma : array_like, 1d\\n        The coefficients for moving-average lag polynomial, including zero lag.\\n    nobs : int\\n        The number of terms (lags plus zero lag) to include in returned acovf.\\n    sigma2 : float\\n        Variance of the innovation term.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The autocovariance of ARMA process given by ar, ma.\\n\\n    See Also\\n    --------\\n    arma_acf : Autocorrelation function for ARMA processes.\\n    acovf : Sample autocovariance estimation.\\n\\n    References\\n    ----------\\n    .. [*] Brockwell, Peter J., and Richard A. Davis. 2009. Time Series:\\n        Theory and Methods. 2nd ed. 1991. New York, NY: Springer.\\n    '\n    if dtype is None:\n        dtype = np.common_type(np.array(ar), np.array(ma), np.array(sigma2))\n    p = len(ar) - 1\n    q = len(ma) - 1\n    m = max(p, q) + 1\n    if sigma2.real < 0:\n        raise ValueError('Must have positive innovation variance.')\n    if p == q == 0:\n        out = np.zeros(nobs, dtype=dtype)\n        out[0] = sigma2\n        return out\n    elif p > 0 and np.max(np.abs(np.roots(ar))) >= 1:\n        raise ValueError(NONSTATIONARY_ERROR)\n    ma_coeffs = arma2ma(ar, ma, lags=m)\n    A = np.zeros((m, m), dtype=dtype)\n    b = np.zeros((m, 1), dtype=dtype)\n    tmp_ar = np.zeros(m, dtype=dtype)\n    tmp_ar[:p + 1] = ar\n    for k in range(m):\n        A[k, :k + 1] = tmp_ar[:k + 1][::-1]\n        A[k, 1:m - k] += tmp_ar[k + 1:m]\n        b[k] = sigma2 * np.dot(ma[k:q + 1], ma_coeffs[:max(q + 1 - k, 0)])\n    acovf = np.zeros(max(nobs, m), dtype=dtype)\n    try:\n        acovf[:m] = np.linalg.solve(A, b)[:, 0]\n    except np.linalg.LinAlgError:\n        raise ValueError(NONSTATIONARY_ERROR)\n    if nobs > m:\n        zi = signal.lfiltic([1], ar, acovf[:m][::-1])\n        acovf[m:] = signal.lfilter([1], ar, np.zeros(nobs - m, dtype=dtype), zi=zi)[0]\n    return acovf[:nobs]"
        ]
    },
    {
        "func_name": "arma_acf",
        "original": "def arma_acf(ar, ma, lags=10):\n    \"\"\"\n    Theoretical autocorrelation function of an ARMA process.\n\n    Parameters\n    ----------\n    ar : array_like\n        Coefficients for autoregressive lag polynomial, including zero lag.\n    ma : array_like\n        Coefficients for moving-average lag polynomial, including zero lag.\n    lags : int\n        The number of terms (lags plus zero lag) to include in returned acf.\n\n    Returns\n    -------\n    ndarray\n        The autocorrelations of ARMA process given by ar and ma.\n\n    See Also\n    --------\n    arma_acovf : Autocovariances from ARMA processes.\n    acf : Sample autocorrelation function estimation.\n    acovf : Sample autocovariance function estimation.\n    \"\"\"\n    acovf = arma_acovf(ar, ma, lags)\n    return acovf / acovf[0]",
        "mutated": [
            "def arma_acf(ar, ma, lags=10):\n    if False:\n        i = 10\n    '\\n    Theoretical autocorrelation function of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        Coefficients for autoregressive lag polynomial, including zero lag.\\n    ma : array_like\\n        Coefficients for moving-average lag polynomial, including zero lag.\\n    lags : int\\n        The number of terms (lags plus zero lag) to include in returned acf.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The autocorrelations of ARMA process given by ar and ma.\\n\\n    See Also\\n    --------\\n    arma_acovf : Autocovariances from ARMA processes.\\n    acf : Sample autocorrelation function estimation.\\n    acovf : Sample autocovariance function estimation.\\n    '\n    acovf = arma_acovf(ar, ma, lags)\n    return acovf / acovf[0]",
            "def arma_acf(ar, ma, lags=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Theoretical autocorrelation function of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        Coefficients for autoregressive lag polynomial, including zero lag.\\n    ma : array_like\\n        Coefficients for moving-average lag polynomial, including zero lag.\\n    lags : int\\n        The number of terms (lags plus zero lag) to include in returned acf.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The autocorrelations of ARMA process given by ar and ma.\\n\\n    See Also\\n    --------\\n    arma_acovf : Autocovariances from ARMA processes.\\n    acf : Sample autocorrelation function estimation.\\n    acovf : Sample autocovariance function estimation.\\n    '\n    acovf = arma_acovf(ar, ma, lags)\n    return acovf / acovf[0]",
            "def arma_acf(ar, ma, lags=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Theoretical autocorrelation function of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        Coefficients for autoregressive lag polynomial, including zero lag.\\n    ma : array_like\\n        Coefficients for moving-average lag polynomial, including zero lag.\\n    lags : int\\n        The number of terms (lags plus zero lag) to include in returned acf.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The autocorrelations of ARMA process given by ar and ma.\\n\\n    See Also\\n    --------\\n    arma_acovf : Autocovariances from ARMA processes.\\n    acf : Sample autocorrelation function estimation.\\n    acovf : Sample autocovariance function estimation.\\n    '\n    acovf = arma_acovf(ar, ma, lags)\n    return acovf / acovf[0]",
            "def arma_acf(ar, ma, lags=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Theoretical autocorrelation function of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        Coefficients for autoregressive lag polynomial, including zero lag.\\n    ma : array_like\\n        Coefficients for moving-average lag polynomial, including zero lag.\\n    lags : int\\n        The number of terms (lags plus zero lag) to include in returned acf.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The autocorrelations of ARMA process given by ar and ma.\\n\\n    See Also\\n    --------\\n    arma_acovf : Autocovariances from ARMA processes.\\n    acf : Sample autocorrelation function estimation.\\n    acovf : Sample autocovariance function estimation.\\n    '\n    acovf = arma_acovf(ar, ma, lags)\n    return acovf / acovf[0]",
            "def arma_acf(ar, ma, lags=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Theoretical autocorrelation function of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        Coefficients for autoregressive lag polynomial, including zero lag.\\n    ma : array_like\\n        Coefficients for moving-average lag polynomial, including zero lag.\\n    lags : int\\n        The number of terms (lags plus zero lag) to include in returned acf.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The autocorrelations of ARMA process given by ar and ma.\\n\\n    See Also\\n    --------\\n    arma_acovf : Autocovariances from ARMA processes.\\n    acf : Sample autocorrelation function estimation.\\n    acovf : Sample autocovariance function estimation.\\n    '\n    acovf = arma_acovf(ar, ma, lags)\n    return acovf / acovf[0]"
        ]
    },
    {
        "func_name": "arma_pacf",
        "original": "def arma_pacf(ar, ma, lags=10):\n    \"\"\"\n    Theoretical partial autocorrelation function of an ARMA process.\n\n    Parameters\n    ----------\n    ar : array_like, 1d\n        The coefficients for autoregressive lag polynomial, including zero lag.\n    ma : array_like, 1d\n        The coefficients for moving-average lag polynomial, including zero lag.\n    lags : int\n        The number of terms (lags plus zero lag) to include in returned pacf.\n\n    Returns\n    -------\n    ndarrray\n        The partial autocorrelation of ARMA process given by ar and ma.\n\n    Notes\n    -----\n    Solves yule-walker equation for each lag order up to nobs lags.\n\n    not tested/checked yet\n    \"\"\"\n    apacf = np.zeros(lags)\n    acov = arma_acf(ar, ma, lags=lags + 1)\n    apacf[0] = 1.0\n    for k in range(2, lags + 1):\n        r = acov[:k]\n        apacf[k - 1] = linalg.solve(linalg.toeplitz(r[:-1]), r[1:])[-1]\n    return apacf",
        "mutated": [
            "def arma_pacf(ar, ma, lags=10):\n    if False:\n        i = 10\n    '\\n    Theoretical partial autocorrelation function of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like, 1d\\n        The coefficients for autoregressive lag polynomial, including zero lag.\\n    ma : array_like, 1d\\n        The coefficients for moving-average lag polynomial, including zero lag.\\n    lags : int\\n        The number of terms (lags plus zero lag) to include in returned pacf.\\n\\n    Returns\\n    -------\\n    ndarrray\\n        The partial autocorrelation of ARMA process given by ar and ma.\\n\\n    Notes\\n    -----\\n    Solves yule-walker equation for each lag order up to nobs lags.\\n\\n    not tested/checked yet\\n    '\n    apacf = np.zeros(lags)\n    acov = arma_acf(ar, ma, lags=lags + 1)\n    apacf[0] = 1.0\n    for k in range(2, lags + 1):\n        r = acov[:k]\n        apacf[k - 1] = linalg.solve(linalg.toeplitz(r[:-1]), r[1:])[-1]\n    return apacf",
            "def arma_pacf(ar, ma, lags=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Theoretical partial autocorrelation function of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like, 1d\\n        The coefficients for autoregressive lag polynomial, including zero lag.\\n    ma : array_like, 1d\\n        The coefficients for moving-average lag polynomial, including zero lag.\\n    lags : int\\n        The number of terms (lags plus zero lag) to include in returned pacf.\\n\\n    Returns\\n    -------\\n    ndarrray\\n        The partial autocorrelation of ARMA process given by ar and ma.\\n\\n    Notes\\n    -----\\n    Solves yule-walker equation for each lag order up to nobs lags.\\n\\n    not tested/checked yet\\n    '\n    apacf = np.zeros(lags)\n    acov = arma_acf(ar, ma, lags=lags + 1)\n    apacf[0] = 1.0\n    for k in range(2, lags + 1):\n        r = acov[:k]\n        apacf[k - 1] = linalg.solve(linalg.toeplitz(r[:-1]), r[1:])[-1]\n    return apacf",
            "def arma_pacf(ar, ma, lags=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Theoretical partial autocorrelation function of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like, 1d\\n        The coefficients for autoregressive lag polynomial, including zero lag.\\n    ma : array_like, 1d\\n        The coefficients for moving-average lag polynomial, including zero lag.\\n    lags : int\\n        The number of terms (lags plus zero lag) to include in returned pacf.\\n\\n    Returns\\n    -------\\n    ndarrray\\n        The partial autocorrelation of ARMA process given by ar and ma.\\n\\n    Notes\\n    -----\\n    Solves yule-walker equation for each lag order up to nobs lags.\\n\\n    not tested/checked yet\\n    '\n    apacf = np.zeros(lags)\n    acov = arma_acf(ar, ma, lags=lags + 1)\n    apacf[0] = 1.0\n    for k in range(2, lags + 1):\n        r = acov[:k]\n        apacf[k - 1] = linalg.solve(linalg.toeplitz(r[:-1]), r[1:])[-1]\n    return apacf",
            "def arma_pacf(ar, ma, lags=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Theoretical partial autocorrelation function of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like, 1d\\n        The coefficients for autoregressive lag polynomial, including zero lag.\\n    ma : array_like, 1d\\n        The coefficients for moving-average lag polynomial, including zero lag.\\n    lags : int\\n        The number of terms (lags plus zero lag) to include in returned pacf.\\n\\n    Returns\\n    -------\\n    ndarrray\\n        The partial autocorrelation of ARMA process given by ar and ma.\\n\\n    Notes\\n    -----\\n    Solves yule-walker equation for each lag order up to nobs lags.\\n\\n    not tested/checked yet\\n    '\n    apacf = np.zeros(lags)\n    acov = arma_acf(ar, ma, lags=lags + 1)\n    apacf[0] = 1.0\n    for k in range(2, lags + 1):\n        r = acov[:k]\n        apacf[k - 1] = linalg.solve(linalg.toeplitz(r[:-1]), r[1:])[-1]\n    return apacf",
            "def arma_pacf(ar, ma, lags=10):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Theoretical partial autocorrelation function of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like, 1d\\n        The coefficients for autoregressive lag polynomial, including zero lag.\\n    ma : array_like, 1d\\n        The coefficients for moving-average lag polynomial, including zero lag.\\n    lags : int\\n        The number of terms (lags plus zero lag) to include in returned pacf.\\n\\n    Returns\\n    -------\\n    ndarrray\\n        The partial autocorrelation of ARMA process given by ar and ma.\\n\\n    Notes\\n    -----\\n    Solves yule-walker equation for each lag order up to nobs lags.\\n\\n    not tested/checked yet\\n    '\n    apacf = np.zeros(lags)\n    acov = arma_acf(ar, ma, lags=lags + 1)\n    apacf[0] = 1.0\n    for k in range(2, lags + 1):\n        r = acov[:k]\n        apacf[k - 1] = linalg.solve(linalg.toeplitz(r[:-1]), r[1:])[-1]\n    return apacf"
        ]
    },
    {
        "func_name": "arma_periodogram",
        "original": "def arma_periodogram(ar, ma, worN=None, whole=0):\n    \"\"\"\n    Periodogram for ARMA process given by lag-polynomials ar and ma.\n\n    Parameters\n    ----------\n    ar : array_like\n        The autoregressive lag-polynomial with leading 1 and lhs sign.\n    ma : array_like\n        The moving average lag-polynomial with leading 1.\n    worN : {None, int}, optional\n        An option for scipy.signal.freqz (read \"w or N\").\n        If None, then compute at 512 frequencies around the unit circle.\n        If a single integer, the compute at that many frequencies.\n        Otherwise, compute the response at frequencies given in worN.\n    whole : {0,1}, optional\n        An options for scipy.signal.freqz/\n        Normally, frequencies are computed from 0 to pi (upper-half of\n        unit-circle.  If whole is non-zero compute frequencies from 0 to 2*pi.\n\n    Returns\n    -------\n    w : ndarray\n        The frequencies.\n    sd : ndarray\n        The periodogram, also known as the spectral density.\n\n    Notes\n    -----\n    Normalization ?\n\n    This uses signal.freqz, which does not use fft. There is a fft version\n    somewhere.\n    \"\"\"\n    (w, h) = signal.freqz(ma, ar, worN=worN, whole=whole)\n    sd = np.abs(h) ** 2 / np.sqrt(2 * np.pi)\n    if np.any(np.isnan(h)):\n        import warnings\n        warnings.warn('Warning: nan in frequency response h, maybe a unit root', RuntimeWarning, stacklevel=2)\n    return (w, sd)",
        "mutated": [
            "def arma_periodogram(ar, ma, worN=None, whole=0):\n    if False:\n        i = 10\n    '\\n    Periodogram for ARMA process given by lag-polynomials ar and ma.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        The autoregressive lag-polynomial with leading 1 and lhs sign.\\n    ma : array_like\\n        The moving average lag-polynomial with leading 1.\\n    worN : {None, int}, optional\\n        An option for scipy.signal.freqz (read \"w or N\").\\n        If None, then compute at 512 frequencies around the unit circle.\\n        If a single integer, the compute at that many frequencies.\\n        Otherwise, compute the response at frequencies given in worN.\\n    whole : {0,1}, optional\\n        An options for scipy.signal.freqz/\\n        Normally, frequencies are computed from 0 to pi (upper-half of\\n        unit-circle.  If whole is non-zero compute frequencies from 0 to 2*pi.\\n\\n    Returns\\n    -------\\n    w : ndarray\\n        The frequencies.\\n    sd : ndarray\\n        The periodogram, also known as the spectral density.\\n\\n    Notes\\n    -----\\n    Normalization ?\\n\\n    This uses signal.freqz, which does not use fft. There is a fft version\\n    somewhere.\\n    '\n    (w, h) = signal.freqz(ma, ar, worN=worN, whole=whole)\n    sd = np.abs(h) ** 2 / np.sqrt(2 * np.pi)\n    if np.any(np.isnan(h)):\n        import warnings\n        warnings.warn('Warning: nan in frequency response h, maybe a unit root', RuntimeWarning, stacklevel=2)\n    return (w, sd)",
            "def arma_periodogram(ar, ma, worN=None, whole=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Periodogram for ARMA process given by lag-polynomials ar and ma.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        The autoregressive lag-polynomial with leading 1 and lhs sign.\\n    ma : array_like\\n        The moving average lag-polynomial with leading 1.\\n    worN : {None, int}, optional\\n        An option for scipy.signal.freqz (read \"w or N\").\\n        If None, then compute at 512 frequencies around the unit circle.\\n        If a single integer, the compute at that many frequencies.\\n        Otherwise, compute the response at frequencies given in worN.\\n    whole : {0,1}, optional\\n        An options for scipy.signal.freqz/\\n        Normally, frequencies are computed from 0 to pi (upper-half of\\n        unit-circle.  If whole is non-zero compute frequencies from 0 to 2*pi.\\n\\n    Returns\\n    -------\\n    w : ndarray\\n        The frequencies.\\n    sd : ndarray\\n        The periodogram, also known as the spectral density.\\n\\n    Notes\\n    -----\\n    Normalization ?\\n\\n    This uses signal.freqz, which does not use fft. There is a fft version\\n    somewhere.\\n    '\n    (w, h) = signal.freqz(ma, ar, worN=worN, whole=whole)\n    sd = np.abs(h) ** 2 / np.sqrt(2 * np.pi)\n    if np.any(np.isnan(h)):\n        import warnings\n        warnings.warn('Warning: nan in frequency response h, maybe a unit root', RuntimeWarning, stacklevel=2)\n    return (w, sd)",
            "def arma_periodogram(ar, ma, worN=None, whole=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Periodogram for ARMA process given by lag-polynomials ar and ma.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        The autoregressive lag-polynomial with leading 1 and lhs sign.\\n    ma : array_like\\n        The moving average lag-polynomial with leading 1.\\n    worN : {None, int}, optional\\n        An option for scipy.signal.freqz (read \"w or N\").\\n        If None, then compute at 512 frequencies around the unit circle.\\n        If a single integer, the compute at that many frequencies.\\n        Otherwise, compute the response at frequencies given in worN.\\n    whole : {0,1}, optional\\n        An options for scipy.signal.freqz/\\n        Normally, frequencies are computed from 0 to pi (upper-half of\\n        unit-circle.  If whole is non-zero compute frequencies from 0 to 2*pi.\\n\\n    Returns\\n    -------\\n    w : ndarray\\n        The frequencies.\\n    sd : ndarray\\n        The periodogram, also known as the spectral density.\\n\\n    Notes\\n    -----\\n    Normalization ?\\n\\n    This uses signal.freqz, which does not use fft. There is a fft version\\n    somewhere.\\n    '\n    (w, h) = signal.freqz(ma, ar, worN=worN, whole=whole)\n    sd = np.abs(h) ** 2 / np.sqrt(2 * np.pi)\n    if np.any(np.isnan(h)):\n        import warnings\n        warnings.warn('Warning: nan in frequency response h, maybe a unit root', RuntimeWarning, stacklevel=2)\n    return (w, sd)",
            "def arma_periodogram(ar, ma, worN=None, whole=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Periodogram for ARMA process given by lag-polynomials ar and ma.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        The autoregressive lag-polynomial with leading 1 and lhs sign.\\n    ma : array_like\\n        The moving average lag-polynomial with leading 1.\\n    worN : {None, int}, optional\\n        An option for scipy.signal.freqz (read \"w or N\").\\n        If None, then compute at 512 frequencies around the unit circle.\\n        If a single integer, the compute at that many frequencies.\\n        Otherwise, compute the response at frequencies given in worN.\\n    whole : {0,1}, optional\\n        An options for scipy.signal.freqz/\\n        Normally, frequencies are computed from 0 to pi (upper-half of\\n        unit-circle.  If whole is non-zero compute frequencies from 0 to 2*pi.\\n\\n    Returns\\n    -------\\n    w : ndarray\\n        The frequencies.\\n    sd : ndarray\\n        The periodogram, also known as the spectral density.\\n\\n    Notes\\n    -----\\n    Normalization ?\\n\\n    This uses signal.freqz, which does not use fft. There is a fft version\\n    somewhere.\\n    '\n    (w, h) = signal.freqz(ma, ar, worN=worN, whole=whole)\n    sd = np.abs(h) ** 2 / np.sqrt(2 * np.pi)\n    if np.any(np.isnan(h)):\n        import warnings\n        warnings.warn('Warning: nan in frequency response h, maybe a unit root', RuntimeWarning, stacklevel=2)\n    return (w, sd)",
            "def arma_periodogram(ar, ma, worN=None, whole=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Periodogram for ARMA process given by lag-polynomials ar and ma.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        The autoregressive lag-polynomial with leading 1 and lhs sign.\\n    ma : array_like\\n        The moving average lag-polynomial with leading 1.\\n    worN : {None, int}, optional\\n        An option for scipy.signal.freqz (read \"w or N\").\\n        If None, then compute at 512 frequencies around the unit circle.\\n        If a single integer, the compute at that many frequencies.\\n        Otherwise, compute the response at frequencies given in worN.\\n    whole : {0,1}, optional\\n        An options for scipy.signal.freqz/\\n        Normally, frequencies are computed from 0 to pi (upper-half of\\n        unit-circle.  If whole is non-zero compute frequencies from 0 to 2*pi.\\n\\n    Returns\\n    -------\\n    w : ndarray\\n        The frequencies.\\n    sd : ndarray\\n        The periodogram, also known as the spectral density.\\n\\n    Notes\\n    -----\\n    Normalization ?\\n\\n    This uses signal.freqz, which does not use fft. There is a fft version\\n    somewhere.\\n    '\n    (w, h) = signal.freqz(ma, ar, worN=worN, whole=whole)\n    sd = np.abs(h) ** 2 / np.sqrt(2 * np.pi)\n    if np.any(np.isnan(h)):\n        import warnings\n        warnings.warn('Warning: nan in frequency response h, maybe a unit root', RuntimeWarning, stacklevel=2)\n    return (w, sd)"
        ]
    },
    {
        "func_name": "arma_impulse_response",
        "original": "def arma_impulse_response(ar, ma, leads=100):\n    \"\"\"\n    Compute the impulse response function (MA representation) for ARMA process.\n\n    Parameters\n    ----------\n    ar : array_like, 1d\n        The auto regressive lag polynomial.\n    ma : array_like, 1d\n        The moving average lag polynomial.\n    leads : int\n        The number of observations to calculate.\n\n    Returns\n    -------\n    ndarray\n        The impulse response function with nobs elements.\n\n    Notes\n    -----\n    This is the same as finding the MA representation of an ARMA(p,q).\n    By reversing the role of ar and ma in the function arguments, the\n    returned result is the AR representation of an ARMA(p,q), i.e\n\n    ma_representation = arma_impulse_response(ar, ma, leads=100)\n    ar_representation = arma_impulse_response(ma, ar, leads=100)\n\n    Fully tested against matlab\n\n    Examples\n    --------\n    AR(1)\n\n    >>> arma_impulse_response([1.0, -0.8], [1.], leads=10)\n    array([ 1.        ,  0.8       ,  0.64      ,  0.512     ,  0.4096    ,\n            0.32768   ,  0.262144  ,  0.2097152 ,  0.16777216,  0.13421773])\n\n    this is the same as\n\n    >>> 0.8**np.arange(10)\n    array([ 1.        ,  0.8       ,  0.64      ,  0.512     ,  0.4096    ,\n            0.32768   ,  0.262144  ,  0.2097152 ,  0.16777216,  0.13421773])\n\n    MA(2)\n\n    >>> arma_impulse_response([1.0], [1., 0.5, 0.2], leads=10)\n    array([ 1. ,  0.5,  0.2,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ])\n\n    ARMA(1,2)\n\n    >>> arma_impulse_response([1.0, -0.8], [1., 0.5, 0.2], leads=10)\n    array([ 1.        ,  1.3       ,  1.24      ,  0.992     ,  0.7936    ,\n            0.63488   ,  0.507904  ,  0.4063232 ,  0.32505856,  0.26004685])\n    \"\"\"\n    impulse = np.zeros(leads)\n    impulse[0] = 1.0\n    return signal.lfilter(ma, ar, impulse)",
        "mutated": [
            "def arma_impulse_response(ar, ma, leads=100):\n    if False:\n        i = 10\n    '\\n    Compute the impulse response function (MA representation) for ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like, 1d\\n        The auto regressive lag polynomial.\\n    ma : array_like, 1d\\n        The moving average lag polynomial.\\n    leads : int\\n        The number of observations to calculate.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The impulse response function with nobs elements.\\n\\n    Notes\\n    -----\\n    This is the same as finding the MA representation of an ARMA(p,q).\\n    By reversing the role of ar and ma in the function arguments, the\\n    returned result is the AR representation of an ARMA(p,q), i.e\\n\\n    ma_representation = arma_impulse_response(ar, ma, leads=100)\\n    ar_representation = arma_impulse_response(ma, ar, leads=100)\\n\\n    Fully tested against matlab\\n\\n    Examples\\n    --------\\n    AR(1)\\n\\n    >>> arma_impulse_response([1.0, -0.8], [1.], leads=10)\\n    array([ 1.        ,  0.8       ,  0.64      ,  0.512     ,  0.4096    ,\\n            0.32768   ,  0.262144  ,  0.2097152 ,  0.16777216,  0.13421773])\\n\\n    this is the same as\\n\\n    >>> 0.8**np.arange(10)\\n    array([ 1.        ,  0.8       ,  0.64      ,  0.512     ,  0.4096    ,\\n            0.32768   ,  0.262144  ,  0.2097152 ,  0.16777216,  0.13421773])\\n\\n    MA(2)\\n\\n    >>> arma_impulse_response([1.0], [1., 0.5, 0.2], leads=10)\\n    array([ 1. ,  0.5,  0.2,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ])\\n\\n    ARMA(1,2)\\n\\n    >>> arma_impulse_response([1.0, -0.8], [1., 0.5, 0.2], leads=10)\\n    array([ 1.        ,  1.3       ,  1.24      ,  0.992     ,  0.7936    ,\\n            0.63488   ,  0.507904  ,  0.4063232 ,  0.32505856,  0.26004685])\\n    '\n    impulse = np.zeros(leads)\n    impulse[0] = 1.0\n    return signal.lfilter(ma, ar, impulse)",
            "def arma_impulse_response(ar, ma, leads=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the impulse response function (MA representation) for ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like, 1d\\n        The auto regressive lag polynomial.\\n    ma : array_like, 1d\\n        The moving average lag polynomial.\\n    leads : int\\n        The number of observations to calculate.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The impulse response function with nobs elements.\\n\\n    Notes\\n    -----\\n    This is the same as finding the MA representation of an ARMA(p,q).\\n    By reversing the role of ar and ma in the function arguments, the\\n    returned result is the AR representation of an ARMA(p,q), i.e\\n\\n    ma_representation = arma_impulse_response(ar, ma, leads=100)\\n    ar_representation = arma_impulse_response(ma, ar, leads=100)\\n\\n    Fully tested against matlab\\n\\n    Examples\\n    --------\\n    AR(1)\\n\\n    >>> arma_impulse_response([1.0, -0.8], [1.], leads=10)\\n    array([ 1.        ,  0.8       ,  0.64      ,  0.512     ,  0.4096    ,\\n            0.32768   ,  0.262144  ,  0.2097152 ,  0.16777216,  0.13421773])\\n\\n    this is the same as\\n\\n    >>> 0.8**np.arange(10)\\n    array([ 1.        ,  0.8       ,  0.64      ,  0.512     ,  0.4096    ,\\n            0.32768   ,  0.262144  ,  0.2097152 ,  0.16777216,  0.13421773])\\n\\n    MA(2)\\n\\n    >>> arma_impulse_response([1.0], [1., 0.5, 0.2], leads=10)\\n    array([ 1. ,  0.5,  0.2,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ])\\n\\n    ARMA(1,2)\\n\\n    >>> arma_impulse_response([1.0, -0.8], [1., 0.5, 0.2], leads=10)\\n    array([ 1.        ,  1.3       ,  1.24      ,  0.992     ,  0.7936    ,\\n            0.63488   ,  0.507904  ,  0.4063232 ,  0.32505856,  0.26004685])\\n    '\n    impulse = np.zeros(leads)\n    impulse[0] = 1.0\n    return signal.lfilter(ma, ar, impulse)",
            "def arma_impulse_response(ar, ma, leads=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the impulse response function (MA representation) for ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like, 1d\\n        The auto regressive lag polynomial.\\n    ma : array_like, 1d\\n        The moving average lag polynomial.\\n    leads : int\\n        The number of observations to calculate.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The impulse response function with nobs elements.\\n\\n    Notes\\n    -----\\n    This is the same as finding the MA representation of an ARMA(p,q).\\n    By reversing the role of ar and ma in the function arguments, the\\n    returned result is the AR representation of an ARMA(p,q), i.e\\n\\n    ma_representation = arma_impulse_response(ar, ma, leads=100)\\n    ar_representation = arma_impulse_response(ma, ar, leads=100)\\n\\n    Fully tested against matlab\\n\\n    Examples\\n    --------\\n    AR(1)\\n\\n    >>> arma_impulse_response([1.0, -0.8], [1.], leads=10)\\n    array([ 1.        ,  0.8       ,  0.64      ,  0.512     ,  0.4096    ,\\n            0.32768   ,  0.262144  ,  0.2097152 ,  0.16777216,  0.13421773])\\n\\n    this is the same as\\n\\n    >>> 0.8**np.arange(10)\\n    array([ 1.        ,  0.8       ,  0.64      ,  0.512     ,  0.4096    ,\\n            0.32768   ,  0.262144  ,  0.2097152 ,  0.16777216,  0.13421773])\\n\\n    MA(2)\\n\\n    >>> arma_impulse_response([1.0], [1., 0.5, 0.2], leads=10)\\n    array([ 1. ,  0.5,  0.2,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ])\\n\\n    ARMA(1,2)\\n\\n    >>> arma_impulse_response([1.0, -0.8], [1., 0.5, 0.2], leads=10)\\n    array([ 1.        ,  1.3       ,  1.24      ,  0.992     ,  0.7936    ,\\n            0.63488   ,  0.507904  ,  0.4063232 ,  0.32505856,  0.26004685])\\n    '\n    impulse = np.zeros(leads)\n    impulse[0] = 1.0\n    return signal.lfilter(ma, ar, impulse)",
            "def arma_impulse_response(ar, ma, leads=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the impulse response function (MA representation) for ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like, 1d\\n        The auto regressive lag polynomial.\\n    ma : array_like, 1d\\n        The moving average lag polynomial.\\n    leads : int\\n        The number of observations to calculate.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The impulse response function with nobs elements.\\n\\n    Notes\\n    -----\\n    This is the same as finding the MA representation of an ARMA(p,q).\\n    By reversing the role of ar and ma in the function arguments, the\\n    returned result is the AR representation of an ARMA(p,q), i.e\\n\\n    ma_representation = arma_impulse_response(ar, ma, leads=100)\\n    ar_representation = arma_impulse_response(ma, ar, leads=100)\\n\\n    Fully tested against matlab\\n\\n    Examples\\n    --------\\n    AR(1)\\n\\n    >>> arma_impulse_response([1.0, -0.8], [1.], leads=10)\\n    array([ 1.        ,  0.8       ,  0.64      ,  0.512     ,  0.4096    ,\\n            0.32768   ,  0.262144  ,  0.2097152 ,  0.16777216,  0.13421773])\\n\\n    this is the same as\\n\\n    >>> 0.8**np.arange(10)\\n    array([ 1.        ,  0.8       ,  0.64      ,  0.512     ,  0.4096    ,\\n            0.32768   ,  0.262144  ,  0.2097152 ,  0.16777216,  0.13421773])\\n\\n    MA(2)\\n\\n    >>> arma_impulse_response([1.0], [1., 0.5, 0.2], leads=10)\\n    array([ 1. ,  0.5,  0.2,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ])\\n\\n    ARMA(1,2)\\n\\n    >>> arma_impulse_response([1.0, -0.8], [1., 0.5, 0.2], leads=10)\\n    array([ 1.        ,  1.3       ,  1.24      ,  0.992     ,  0.7936    ,\\n            0.63488   ,  0.507904  ,  0.4063232 ,  0.32505856,  0.26004685])\\n    '\n    impulse = np.zeros(leads)\n    impulse[0] = 1.0\n    return signal.lfilter(ma, ar, impulse)",
            "def arma_impulse_response(ar, ma, leads=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the impulse response function (MA representation) for ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like, 1d\\n        The auto regressive lag polynomial.\\n    ma : array_like, 1d\\n        The moving average lag polynomial.\\n    leads : int\\n        The number of observations to calculate.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The impulse response function with nobs elements.\\n\\n    Notes\\n    -----\\n    This is the same as finding the MA representation of an ARMA(p,q).\\n    By reversing the role of ar and ma in the function arguments, the\\n    returned result is the AR representation of an ARMA(p,q), i.e\\n\\n    ma_representation = arma_impulse_response(ar, ma, leads=100)\\n    ar_representation = arma_impulse_response(ma, ar, leads=100)\\n\\n    Fully tested against matlab\\n\\n    Examples\\n    --------\\n    AR(1)\\n\\n    >>> arma_impulse_response([1.0, -0.8], [1.], leads=10)\\n    array([ 1.        ,  0.8       ,  0.64      ,  0.512     ,  0.4096    ,\\n            0.32768   ,  0.262144  ,  0.2097152 ,  0.16777216,  0.13421773])\\n\\n    this is the same as\\n\\n    >>> 0.8**np.arange(10)\\n    array([ 1.        ,  0.8       ,  0.64      ,  0.512     ,  0.4096    ,\\n            0.32768   ,  0.262144  ,  0.2097152 ,  0.16777216,  0.13421773])\\n\\n    MA(2)\\n\\n    >>> arma_impulse_response([1.0], [1., 0.5, 0.2], leads=10)\\n    array([ 1. ,  0.5,  0.2,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ])\\n\\n    ARMA(1,2)\\n\\n    >>> arma_impulse_response([1.0, -0.8], [1., 0.5, 0.2], leads=10)\\n    array([ 1.        ,  1.3       ,  1.24      ,  0.992     ,  0.7936    ,\\n            0.63488   ,  0.507904  ,  0.4063232 ,  0.32505856,  0.26004685])\\n    '\n    impulse = np.zeros(leads)\n    impulse[0] = 1.0\n    return signal.lfilter(ma, ar, impulse)"
        ]
    },
    {
        "func_name": "arma2ma",
        "original": "def arma2ma(ar, ma, lags=100):\n    \"\"\"\n    A finite-lag approximate MA representation of an ARMA process.\n\n    Parameters\n    ----------\n    ar : ndarray\n        The auto regressive lag polynomial.\n    ma : ndarray\n        The moving average lag polynomial.\n    lags : int\n        The number of coefficients to calculate.\n\n    Returns\n    -------\n    ndarray\n        The coefficients of AR lag polynomial with nobs elements.\n\n    Notes\n    -----\n    Equivalent to ``arma_impulse_response(ma, ar, leads=100)``\n    \"\"\"\n    return arma_impulse_response(ar, ma, leads=lags)",
        "mutated": [
            "def arma2ma(ar, ma, lags=100):\n    if False:\n        i = 10\n    '\\n    A finite-lag approximate MA representation of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : ndarray\\n        The auto regressive lag polynomial.\\n    ma : ndarray\\n        The moving average lag polynomial.\\n    lags : int\\n        The number of coefficients to calculate.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The coefficients of AR lag polynomial with nobs elements.\\n\\n    Notes\\n    -----\\n    Equivalent to ``arma_impulse_response(ma, ar, leads=100)``\\n    '\n    return arma_impulse_response(ar, ma, leads=lags)",
            "def arma2ma(ar, ma, lags=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    A finite-lag approximate MA representation of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : ndarray\\n        The auto regressive lag polynomial.\\n    ma : ndarray\\n        The moving average lag polynomial.\\n    lags : int\\n        The number of coefficients to calculate.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The coefficients of AR lag polynomial with nobs elements.\\n\\n    Notes\\n    -----\\n    Equivalent to ``arma_impulse_response(ma, ar, leads=100)``\\n    '\n    return arma_impulse_response(ar, ma, leads=lags)",
            "def arma2ma(ar, ma, lags=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    A finite-lag approximate MA representation of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : ndarray\\n        The auto regressive lag polynomial.\\n    ma : ndarray\\n        The moving average lag polynomial.\\n    lags : int\\n        The number of coefficients to calculate.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The coefficients of AR lag polynomial with nobs elements.\\n\\n    Notes\\n    -----\\n    Equivalent to ``arma_impulse_response(ma, ar, leads=100)``\\n    '\n    return arma_impulse_response(ar, ma, leads=lags)",
            "def arma2ma(ar, ma, lags=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    A finite-lag approximate MA representation of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : ndarray\\n        The auto regressive lag polynomial.\\n    ma : ndarray\\n        The moving average lag polynomial.\\n    lags : int\\n        The number of coefficients to calculate.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The coefficients of AR lag polynomial with nobs elements.\\n\\n    Notes\\n    -----\\n    Equivalent to ``arma_impulse_response(ma, ar, leads=100)``\\n    '\n    return arma_impulse_response(ar, ma, leads=lags)",
            "def arma2ma(ar, ma, lags=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    A finite-lag approximate MA representation of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : ndarray\\n        The auto regressive lag polynomial.\\n    ma : ndarray\\n        The moving average lag polynomial.\\n    lags : int\\n        The number of coefficients to calculate.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The coefficients of AR lag polynomial with nobs elements.\\n\\n    Notes\\n    -----\\n    Equivalent to ``arma_impulse_response(ma, ar, leads=100)``\\n    '\n    return arma_impulse_response(ar, ma, leads=lags)"
        ]
    },
    {
        "func_name": "arma2ar",
        "original": "def arma2ar(ar, ma, lags=100):\n    \"\"\"\n    A finite-lag AR approximation of an ARMA process.\n\n    Parameters\n    ----------\n    ar : array_like\n        The auto regressive lag polynomial.\n    ma : array_like\n        The moving average lag polynomial.\n    lags : int\n        The number of coefficients to calculate.\n\n    Returns\n    -------\n    ndarray\n        The coefficients of AR lag polynomial with nobs elements.\n\n    Notes\n    -----\n    Equivalent to ``arma_impulse_response(ma, ar, leads=100)``\n    \"\"\"\n    return arma_impulse_response(ma, ar, leads=lags)",
        "mutated": [
            "def arma2ar(ar, ma, lags=100):\n    if False:\n        i = 10\n    '\\n    A finite-lag AR approximation of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        The auto regressive lag polynomial.\\n    ma : array_like\\n        The moving average lag polynomial.\\n    lags : int\\n        The number of coefficients to calculate.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The coefficients of AR lag polynomial with nobs elements.\\n\\n    Notes\\n    -----\\n    Equivalent to ``arma_impulse_response(ma, ar, leads=100)``\\n    '\n    return arma_impulse_response(ma, ar, leads=lags)",
            "def arma2ar(ar, ma, lags=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    A finite-lag AR approximation of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        The auto regressive lag polynomial.\\n    ma : array_like\\n        The moving average lag polynomial.\\n    lags : int\\n        The number of coefficients to calculate.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The coefficients of AR lag polynomial with nobs elements.\\n\\n    Notes\\n    -----\\n    Equivalent to ``arma_impulse_response(ma, ar, leads=100)``\\n    '\n    return arma_impulse_response(ma, ar, leads=lags)",
            "def arma2ar(ar, ma, lags=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    A finite-lag AR approximation of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        The auto regressive lag polynomial.\\n    ma : array_like\\n        The moving average lag polynomial.\\n    lags : int\\n        The number of coefficients to calculate.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The coefficients of AR lag polynomial with nobs elements.\\n\\n    Notes\\n    -----\\n    Equivalent to ``arma_impulse_response(ma, ar, leads=100)``\\n    '\n    return arma_impulse_response(ma, ar, leads=lags)",
            "def arma2ar(ar, ma, lags=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    A finite-lag AR approximation of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        The auto regressive lag polynomial.\\n    ma : array_like\\n        The moving average lag polynomial.\\n    lags : int\\n        The number of coefficients to calculate.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The coefficients of AR lag polynomial with nobs elements.\\n\\n    Notes\\n    -----\\n    Equivalent to ``arma_impulse_response(ma, ar, leads=100)``\\n    '\n    return arma_impulse_response(ma, ar, leads=lags)",
            "def arma2ar(ar, ma, lags=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    A finite-lag AR approximation of an ARMA process.\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        The auto regressive lag polynomial.\\n    ma : array_like\\n        The moving average lag polynomial.\\n    lags : int\\n        The number of coefficients to calculate.\\n\\n    Returns\\n    -------\\n    ndarray\\n        The coefficients of AR lag polynomial with nobs elements.\\n\\n    Notes\\n    -----\\n    Equivalent to ``arma_impulse_response(ma, ar, leads=100)``\\n    '\n    return arma_impulse_response(ma, ar, leads=lags)"
        ]
    },
    {
        "func_name": "msear_err",
        "original": "def msear_err(arma, ar_des):\n    (ar, ma) = (np.r_[1, arma[:p - 1]], np.r_[1, arma[p - 1:]])\n    ar_approx = arma_impulse_response(ma, ar, n)\n    return ar_des - ar_approx",
        "mutated": [
            "def msear_err(arma, ar_des):\n    if False:\n        i = 10\n    (ar, ma) = (np.r_[1, arma[:p - 1]], np.r_[1, arma[p - 1:]])\n    ar_approx = arma_impulse_response(ma, ar, n)\n    return ar_des - ar_approx",
            "def msear_err(arma, ar_des):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (ar, ma) = (np.r_[1, arma[:p - 1]], np.r_[1, arma[p - 1:]])\n    ar_approx = arma_impulse_response(ma, ar, n)\n    return ar_des - ar_approx",
            "def msear_err(arma, ar_des):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (ar, ma) = (np.r_[1, arma[:p - 1]], np.r_[1, arma[p - 1:]])\n    ar_approx = arma_impulse_response(ma, ar, n)\n    return ar_des - ar_approx",
            "def msear_err(arma, ar_des):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (ar, ma) = (np.r_[1, arma[:p - 1]], np.r_[1, arma[p - 1:]])\n    ar_approx = arma_impulse_response(ma, ar, n)\n    return ar_des - ar_approx",
            "def msear_err(arma, ar_des):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (ar, ma) = (np.r_[1, arma[:p - 1]], np.r_[1, arma[p - 1:]])\n    ar_approx = arma_impulse_response(ma, ar, n)\n    return ar_des - ar_approx"
        ]
    },
    {
        "func_name": "ar2arma",
        "original": "def ar2arma(ar_des, p, q, n=20, mse='ar', start=None):\n    \"\"\"\n    Find arma approximation to ar process.\n\n    This finds the ARMA(p,q) coefficients that minimize the integrated\n    squared difference between the impulse_response functions (MA\n    representation) of the AR and the ARMA process. This does not  check\n    whether the MA lag polynomial of the ARMA process is invertible, neither\n    does it check the roots of the AR lag polynomial.\n\n    Parameters\n    ----------\n    ar_des : array_like\n        The coefficients of original AR lag polynomial, including lag zero.\n    p : int\n        The length of desired AR lag polynomials.\n    q : int\n        The length of desired MA lag polynomials.\n    n : int\n        The number of terms of the impulse_response function to include in the\n        objective function for the approximation.\n    mse : str, 'ar'\n        Not used.\n    start : ndarray\n        Initial values to use when finding the approximation.\n\n    Returns\n    -------\n    ar_app : ndarray\n        The coefficients of the AR lag polynomials of the approximation.\n    ma_app : ndarray\n        The coefficients of the MA lag polynomials of the approximation.\n    res : tuple\n        The result of optimize.leastsq.\n\n    Notes\n    -----\n    Extension is possible if we want to match autocovariance instead\n    of impulse response function.\n    \"\"\"\n\n    def msear_err(arma, ar_des):\n        (ar, ma) = (np.r_[1, arma[:p - 1]], np.r_[1, arma[p - 1:]])\n        ar_approx = arma_impulse_response(ma, ar, n)\n        return ar_des - ar_approx\n    if start is None:\n        arma0 = np.r_[-0.9 * np.ones(p - 1), np.zeros(q - 1)]\n    else:\n        arma0 = start\n    res = optimize.leastsq(msear_err, arma0, ar_des, maxfev=5000)\n    arma_app = np.atleast_1d(res[0])\n    ar_app = (np.r_[1, arma_app[:p - 1]],)\n    ma_app = np.r_[1, arma_app[p - 1:]]\n    return (ar_app, ma_app, res)",
        "mutated": [
            "def ar2arma(ar_des, p, q, n=20, mse='ar', start=None):\n    if False:\n        i = 10\n    \"\\n    Find arma approximation to ar process.\\n\\n    This finds the ARMA(p,q) coefficients that minimize the integrated\\n    squared difference between the impulse_response functions (MA\\n    representation) of the AR and the ARMA process. This does not  check\\n    whether the MA lag polynomial of the ARMA process is invertible, neither\\n    does it check the roots of the AR lag polynomial.\\n\\n    Parameters\\n    ----------\\n    ar_des : array_like\\n        The coefficients of original AR lag polynomial, including lag zero.\\n    p : int\\n        The length of desired AR lag polynomials.\\n    q : int\\n        The length of desired MA lag polynomials.\\n    n : int\\n        The number of terms of the impulse_response function to include in the\\n        objective function for the approximation.\\n    mse : str, 'ar'\\n        Not used.\\n    start : ndarray\\n        Initial values to use when finding the approximation.\\n\\n    Returns\\n    -------\\n    ar_app : ndarray\\n        The coefficients of the AR lag polynomials of the approximation.\\n    ma_app : ndarray\\n        The coefficients of the MA lag polynomials of the approximation.\\n    res : tuple\\n        The result of optimize.leastsq.\\n\\n    Notes\\n    -----\\n    Extension is possible if we want to match autocovariance instead\\n    of impulse response function.\\n    \"\n\n    def msear_err(arma, ar_des):\n        (ar, ma) = (np.r_[1, arma[:p - 1]], np.r_[1, arma[p - 1:]])\n        ar_approx = arma_impulse_response(ma, ar, n)\n        return ar_des - ar_approx\n    if start is None:\n        arma0 = np.r_[-0.9 * np.ones(p - 1), np.zeros(q - 1)]\n    else:\n        arma0 = start\n    res = optimize.leastsq(msear_err, arma0, ar_des, maxfev=5000)\n    arma_app = np.atleast_1d(res[0])\n    ar_app = (np.r_[1, arma_app[:p - 1]],)\n    ma_app = np.r_[1, arma_app[p - 1:]]\n    return (ar_app, ma_app, res)",
            "def ar2arma(ar_des, p, q, n=20, mse='ar', start=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Find arma approximation to ar process.\\n\\n    This finds the ARMA(p,q) coefficients that minimize the integrated\\n    squared difference between the impulse_response functions (MA\\n    representation) of the AR and the ARMA process. This does not  check\\n    whether the MA lag polynomial of the ARMA process is invertible, neither\\n    does it check the roots of the AR lag polynomial.\\n\\n    Parameters\\n    ----------\\n    ar_des : array_like\\n        The coefficients of original AR lag polynomial, including lag zero.\\n    p : int\\n        The length of desired AR lag polynomials.\\n    q : int\\n        The length of desired MA lag polynomials.\\n    n : int\\n        The number of terms of the impulse_response function to include in the\\n        objective function for the approximation.\\n    mse : str, 'ar'\\n        Not used.\\n    start : ndarray\\n        Initial values to use when finding the approximation.\\n\\n    Returns\\n    -------\\n    ar_app : ndarray\\n        The coefficients of the AR lag polynomials of the approximation.\\n    ma_app : ndarray\\n        The coefficients of the MA lag polynomials of the approximation.\\n    res : tuple\\n        The result of optimize.leastsq.\\n\\n    Notes\\n    -----\\n    Extension is possible if we want to match autocovariance instead\\n    of impulse response function.\\n    \"\n\n    def msear_err(arma, ar_des):\n        (ar, ma) = (np.r_[1, arma[:p - 1]], np.r_[1, arma[p - 1:]])\n        ar_approx = arma_impulse_response(ma, ar, n)\n        return ar_des - ar_approx\n    if start is None:\n        arma0 = np.r_[-0.9 * np.ones(p - 1), np.zeros(q - 1)]\n    else:\n        arma0 = start\n    res = optimize.leastsq(msear_err, arma0, ar_des, maxfev=5000)\n    arma_app = np.atleast_1d(res[0])\n    ar_app = (np.r_[1, arma_app[:p - 1]],)\n    ma_app = np.r_[1, arma_app[p - 1:]]\n    return (ar_app, ma_app, res)",
            "def ar2arma(ar_des, p, q, n=20, mse='ar', start=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Find arma approximation to ar process.\\n\\n    This finds the ARMA(p,q) coefficients that minimize the integrated\\n    squared difference between the impulse_response functions (MA\\n    representation) of the AR and the ARMA process. This does not  check\\n    whether the MA lag polynomial of the ARMA process is invertible, neither\\n    does it check the roots of the AR lag polynomial.\\n\\n    Parameters\\n    ----------\\n    ar_des : array_like\\n        The coefficients of original AR lag polynomial, including lag zero.\\n    p : int\\n        The length of desired AR lag polynomials.\\n    q : int\\n        The length of desired MA lag polynomials.\\n    n : int\\n        The number of terms of the impulse_response function to include in the\\n        objective function for the approximation.\\n    mse : str, 'ar'\\n        Not used.\\n    start : ndarray\\n        Initial values to use when finding the approximation.\\n\\n    Returns\\n    -------\\n    ar_app : ndarray\\n        The coefficients of the AR lag polynomials of the approximation.\\n    ma_app : ndarray\\n        The coefficients of the MA lag polynomials of the approximation.\\n    res : tuple\\n        The result of optimize.leastsq.\\n\\n    Notes\\n    -----\\n    Extension is possible if we want to match autocovariance instead\\n    of impulse response function.\\n    \"\n\n    def msear_err(arma, ar_des):\n        (ar, ma) = (np.r_[1, arma[:p - 1]], np.r_[1, arma[p - 1:]])\n        ar_approx = arma_impulse_response(ma, ar, n)\n        return ar_des - ar_approx\n    if start is None:\n        arma0 = np.r_[-0.9 * np.ones(p - 1), np.zeros(q - 1)]\n    else:\n        arma0 = start\n    res = optimize.leastsq(msear_err, arma0, ar_des, maxfev=5000)\n    arma_app = np.atleast_1d(res[0])\n    ar_app = (np.r_[1, arma_app[:p - 1]],)\n    ma_app = np.r_[1, arma_app[p - 1:]]\n    return (ar_app, ma_app, res)",
            "def ar2arma(ar_des, p, q, n=20, mse='ar', start=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Find arma approximation to ar process.\\n\\n    This finds the ARMA(p,q) coefficients that minimize the integrated\\n    squared difference between the impulse_response functions (MA\\n    representation) of the AR and the ARMA process. This does not  check\\n    whether the MA lag polynomial of the ARMA process is invertible, neither\\n    does it check the roots of the AR lag polynomial.\\n\\n    Parameters\\n    ----------\\n    ar_des : array_like\\n        The coefficients of original AR lag polynomial, including lag zero.\\n    p : int\\n        The length of desired AR lag polynomials.\\n    q : int\\n        The length of desired MA lag polynomials.\\n    n : int\\n        The number of terms of the impulse_response function to include in the\\n        objective function for the approximation.\\n    mse : str, 'ar'\\n        Not used.\\n    start : ndarray\\n        Initial values to use when finding the approximation.\\n\\n    Returns\\n    -------\\n    ar_app : ndarray\\n        The coefficients of the AR lag polynomials of the approximation.\\n    ma_app : ndarray\\n        The coefficients of the MA lag polynomials of the approximation.\\n    res : tuple\\n        The result of optimize.leastsq.\\n\\n    Notes\\n    -----\\n    Extension is possible if we want to match autocovariance instead\\n    of impulse response function.\\n    \"\n\n    def msear_err(arma, ar_des):\n        (ar, ma) = (np.r_[1, arma[:p - 1]], np.r_[1, arma[p - 1:]])\n        ar_approx = arma_impulse_response(ma, ar, n)\n        return ar_des - ar_approx\n    if start is None:\n        arma0 = np.r_[-0.9 * np.ones(p - 1), np.zeros(q - 1)]\n    else:\n        arma0 = start\n    res = optimize.leastsq(msear_err, arma0, ar_des, maxfev=5000)\n    arma_app = np.atleast_1d(res[0])\n    ar_app = (np.r_[1, arma_app[:p - 1]],)\n    ma_app = np.r_[1, arma_app[p - 1:]]\n    return (ar_app, ma_app, res)",
            "def ar2arma(ar_des, p, q, n=20, mse='ar', start=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Find arma approximation to ar process.\\n\\n    This finds the ARMA(p,q) coefficients that minimize the integrated\\n    squared difference between the impulse_response functions (MA\\n    representation) of the AR and the ARMA process. This does not  check\\n    whether the MA lag polynomial of the ARMA process is invertible, neither\\n    does it check the roots of the AR lag polynomial.\\n\\n    Parameters\\n    ----------\\n    ar_des : array_like\\n        The coefficients of original AR lag polynomial, including lag zero.\\n    p : int\\n        The length of desired AR lag polynomials.\\n    q : int\\n        The length of desired MA lag polynomials.\\n    n : int\\n        The number of terms of the impulse_response function to include in the\\n        objective function for the approximation.\\n    mse : str, 'ar'\\n        Not used.\\n    start : ndarray\\n        Initial values to use when finding the approximation.\\n\\n    Returns\\n    -------\\n    ar_app : ndarray\\n        The coefficients of the AR lag polynomials of the approximation.\\n    ma_app : ndarray\\n        The coefficients of the MA lag polynomials of the approximation.\\n    res : tuple\\n        The result of optimize.leastsq.\\n\\n    Notes\\n    -----\\n    Extension is possible if we want to match autocovariance instead\\n    of impulse response function.\\n    \"\n\n    def msear_err(arma, ar_des):\n        (ar, ma) = (np.r_[1, arma[:p - 1]], np.r_[1, arma[p - 1:]])\n        ar_approx = arma_impulse_response(ma, ar, n)\n        return ar_des - ar_approx\n    if start is None:\n        arma0 = np.r_[-0.9 * np.ones(p - 1), np.zeros(q - 1)]\n    else:\n        arma0 = start\n    res = optimize.leastsq(msear_err, arma0, ar_des, maxfev=5000)\n    arma_app = np.atleast_1d(res[0])\n    ar_app = (np.r_[1, arma_app[:p - 1]],)\n    ma_app = np.r_[1, arma_app[p - 1:]]\n    return (ar_app, ma_app, res)"
        ]
    },
    {
        "func_name": "lpol2index",
        "original": "def lpol2index(ar):\n    \"\"\"\n    Remove zeros from lag polynomial\n\n    Parameters\n    ----------\n    ar : array_like\n        coefficients of lag polynomial\n\n    Returns\n    -------\n    coeffs : ndarray\n        non-zero coefficients of lag polynomial\n    index : ndarray\n        index (lags) of lag polynomial with non-zero elements\n    \"\"\"\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', np.ComplexWarning)\n        ar = array_like(ar, 'ar')\n    index = np.nonzero(ar)[0]\n    coeffs = ar[index]\n    return (coeffs, index)",
        "mutated": [
            "def lpol2index(ar):\n    if False:\n        i = 10\n    '\\n    Remove zeros from lag polynomial\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        coefficients of lag polynomial\\n\\n    Returns\\n    -------\\n    coeffs : ndarray\\n        non-zero coefficients of lag polynomial\\n    index : ndarray\\n        index (lags) of lag polynomial with non-zero elements\\n    '\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', np.ComplexWarning)\n        ar = array_like(ar, 'ar')\n    index = np.nonzero(ar)[0]\n    coeffs = ar[index]\n    return (coeffs, index)",
            "def lpol2index(ar):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Remove zeros from lag polynomial\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        coefficients of lag polynomial\\n\\n    Returns\\n    -------\\n    coeffs : ndarray\\n        non-zero coefficients of lag polynomial\\n    index : ndarray\\n        index (lags) of lag polynomial with non-zero elements\\n    '\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', np.ComplexWarning)\n        ar = array_like(ar, 'ar')\n    index = np.nonzero(ar)[0]\n    coeffs = ar[index]\n    return (coeffs, index)",
            "def lpol2index(ar):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Remove zeros from lag polynomial\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        coefficients of lag polynomial\\n\\n    Returns\\n    -------\\n    coeffs : ndarray\\n        non-zero coefficients of lag polynomial\\n    index : ndarray\\n        index (lags) of lag polynomial with non-zero elements\\n    '\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', np.ComplexWarning)\n        ar = array_like(ar, 'ar')\n    index = np.nonzero(ar)[0]\n    coeffs = ar[index]\n    return (coeffs, index)",
            "def lpol2index(ar):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Remove zeros from lag polynomial\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        coefficients of lag polynomial\\n\\n    Returns\\n    -------\\n    coeffs : ndarray\\n        non-zero coefficients of lag polynomial\\n    index : ndarray\\n        index (lags) of lag polynomial with non-zero elements\\n    '\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', np.ComplexWarning)\n        ar = array_like(ar, 'ar')\n    index = np.nonzero(ar)[0]\n    coeffs = ar[index]\n    return (coeffs, index)",
            "def lpol2index(ar):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Remove zeros from lag polynomial\\n\\n    Parameters\\n    ----------\\n    ar : array_like\\n        coefficients of lag polynomial\\n\\n    Returns\\n    -------\\n    coeffs : ndarray\\n        non-zero coefficients of lag polynomial\\n    index : ndarray\\n        index (lags) of lag polynomial with non-zero elements\\n    '\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', np.ComplexWarning)\n        ar = array_like(ar, 'ar')\n    index = np.nonzero(ar)[0]\n    coeffs = ar[index]\n    return (coeffs, index)"
        ]
    },
    {
        "func_name": "index2lpol",
        "original": "def index2lpol(coeffs, index):\n    \"\"\"\n    Expand coefficients to lag poly\n\n    Parameters\n    ----------\n    coeffs : ndarray\n        non-zero coefficients of lag polynomial\n    index : ndarray\n        index (lags) of lag polynomial with non-zero elements\n\n    Returns\n    -------\n    ar : array_like\n        coefficients of lag polynomial\n    \"\"\"\n    n = max(index)\n    ar = np.zeros(n + 1)\n    ar[index] = coeffs\n    return ar",
        "mutated": [
            "def index2lpol(coeffs, index):\n    if False:\n        i = 10\n    '\\n    Expand coefficients to lag poly\\n\\n    Parameters\\n    ----------\\n    coeffs : ndarray\\n        non-zero coefficients of lag polynomial\\n    index : ndarray\\n        index (lags) of lag polynomial with non-zero elements\\n\\n    Returns\\n    -------\\n    ar : array_like\\n        coefficients of lag polynomial\\n    '\n    n = max(index)\n    ar = np.zeros(n + 1)\n    ar[index] = coeffs\n    return ar",
            "def index2lpol(coeffs, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Expand coefficients to lag poly\\n\\n    Parameters\\n    ----------\\n    coeffs : ndarray\\n        non-zero coefficients of lag polynomial\\n    index : ndarray\\n        index (lags) of lag polynomial with non-zero elements\\n\\n    Returns\\n    -------\\n    ar : array_like\\n        coefficients of lag polynomial\\n    '\n    n = max(index)\n    ar = np.zeros(n + 1)\n    ar[index] = coeffs\n    return ar",
            "def index2lpol(coeffs, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Expand coefficients to lag poly\\n\\n    Parameters\\n    ----------\\n    coeffs : ndarray\\n        non-zero coefficients of lag polynomial\\n    index : ndarray\\n        index (lags) of lag polynomial with non-zero elements\\n\\n    Returns\\n    -------\\n    ar : array_like\\n        coefficients of lag polynomial\\n    '\n    n = max(index)\n    ar = np.zeros(n + 1)\n    ar[index] = coeffs\n    return ar",
            "def index2lpol(coeffs, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Expand coefficients to lag poly\\n\\n    Parameters\\n    ----------\\n    coeffs : ndarray\\n        non-zero coefficients of lag polynomial\\n    index : ndarray\\n        index (lags) of lag polynomial with non-zero elements\\n\\n    Returns\\n    -------\\n    ar : array_like\\n        coefficients of lag polynomial\\n    '\n    n = max(index)\n    ar = np.zeros(n + 1)\n    ar[index] = coeffs\n    return ar",
            "def index2lpol(coeffs, index):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Expand coefficients to lag poly\\n\\n    Parameters\\n    ----------\\n    coeffs : ndarray\\n        non-zero coefficients of lag polynomial\\n    index : ndarray\\n        index (lags) of lag polynomial with non-zero elements\\n\\n    Returns\\n    -------\\n    ar : array_like\\n        coefficients of lag polynomial\\n    '\n    n = max(index)\n    ar = np.zeros(n + 1)\n    ar[index] = coeffs\n    return ar"
        ]
    },
    {
        "func_name": "lpol_fima",
        "original": "def lpol_fima(d, n=20):\n    \"\"\"MA representation of fractional integration\n\n    .. math:: (1-L)^{-d} for |d|<0.5  or |d|<1 (?)\n\n    Parameters\n    ----------\n    d : float\n        fractional power\n    n : int\n        number of terms to calculate, including lag zero\n\n    Returns\n    -------\n    ma : ndarray\n        coefficients of lag polynomial\n    \"\"\"\n    from scipy.special import gammaln\n    j = np.arange(n)\n    return np.exp(gammaln(d + j) - gammaln(j + 1) - gammaln(d))",
        "mutated": [
            "def lpol_fima(d, n=20):\n    if False:\n        i = 10\n    'MA representation of fractional integration\\n\\n    .. math:: (1-L)^{-d} for |d|<0.5  or |d|<1 (?)\\n\\n    Parameters\\n    ----------\\n    d : float\\n        fractional power\\n    n : int\\n        number of terms to calculate, including lag zero\\n\\n    Returns\\n    -------\\n    ma : ndarray\\n        coefficients of lag polynomial\\n    '\n    from scipy.special import gammaln\n    j = np.arange(n)\n    return np.exp(gammaln(d + j) - gammaln(j + 1) - gammaln(d))",
            "def lpol_fima(d, n=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'MA representation of fractional integration\\n\\n    .. math:: (1-L)^{-d} for |d|<0.5  or |d|<1 (?)\\n\\n    Parameters\\n    ----------\\n    d : float\\n        fractional power\\n    n : int\\n        number of terms to calculate, including lag zero\\n\\n    Returns\\n    -------\\n    ma : ndarray\\n        coefficients of lag polynomial\\n    '\n    from scipy.special import gammaln\n    j = np.arange(n)\n    return np.exp(gammaln(d + j) - gammaln(j + 1) - gammaln(d))",
            "def lpol_fima(d, n=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'MA representation of fractional integration\\n\\n    .. math:: (1-L)^{-d} for |d|<0.5  or |d|<1 (?)\\n\\n    Parameters\\n    ----------\\n    d : float\\n        fractional power\\n    n : int\\n        number of terms to calculate, including lag zero\\n\\n    Returns\\n    -------\\n    ma : ndarray\\n        coefficients of lag polynomial\\n    '\n    from scipy.special import gammaln\n    j = np.arange(n)\n    return np.exp(gammaln(d + j) - gammaln(j + 1) - gammaln(d))",
            "def lpol_fima(d, n=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'MA representation of fractional integration\\n\\n    .. math:: (1-L)^{-d} for |d|<0.5  or |d|<1 (?)\\n\\n    Parameters\\n    ----------\\n    d : float\\n        fractional power\\n    n : int\\n        number of terms to calculate, including lag zero\\n\\n    Returns\\n    -------\\n    ma : ndarray\\n        coefficients of lag polynomial\\n    '\n    from scipy.special import gammaln\n    j = np.arange(n)\n    return np.exp(gammaln(d + j) - gammaln(j + 1) - gammaln(d))",
            "def lpol_fima(d, n=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'MA representation of fractional integration\\n\\n    .. math:: (1-L)^{-d} for |d|<0.5  or |d|<1 (?)\\n\\n    Parameters\\n    ----------\\n    d : float\\n        fractional power\\n    n : int\\n        number of terms to calculate, including lag zero\\n\\n    Returns\\n    -------\\n    ma : ndarray\\n        coefficients of lag polynomial\\n    '\n    from scipy.special import gammaln\n    j = np.arange(n)\n    return np.exp(gammaln(d + j) - gammaln(j + 1) - gammaln(d))"
        ]
    },
    {
        "func_name": "lpol_fiar",
        "original": "def lpol_fiar(d, n=20):\n    \"\"\"AR representation of fractional integration\n\n    .. math:: (1-L)^{d} for |d|<0.5  or |d|<1 (?)\n\n    Parameters\n    ----------\n    d : float\n        fractional power\n    n : int\n        number of terms to calculate, including lag zero\n\n    Returns\n    -------\n    ar : ndarray\n        coefficients of lag polynomial\n\n    Notes:\n    first coefficient is 1, negative signs except for first term,\n    ar(L)*x_t\n    \"\"\"\n    from scipy.special import gammaln\n    j = np.arange(n)\n    ar = -np.exp(gammaln(-d + j) - gammaln(j + 1) - gammaln(-d))\n    ar[0] = 1\n    return ar",
        "mutated": [
            "def lpol_fiar(d, n=20):\n    if False:\n        i = 10\n    'AR representation of fractional integration\\n\\n    .. math:: (1-L)^{d} for |d|<0.5  or |d|<1 (?)\\n\\n    Parameters\\n    ----------\\n    d : float\\n        fractional power\\n    n : int\\n        number of terms to calculate, including lag zero\\n\\n    Returns\\n    -------\\n    ar : ndarray\\n        coefficients of lag polynomial\\n\\n    Notes:\\n    first coefficient is 1, negative signs except for first term,\\n    ar(L)*x_t\\n    '\n    from scipy.special import gammaln\n    j = np.arange(n)\n    ar = -np.exp(gammaln(-d + j) - gammaln(j + 1) - gammaln(-d))\n    ar[0] = 1\n    return ar",
            "def lpol_fiar(d, n=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'AR representation of fractional integration\\n\\n    .. math:: (1-L)^{d} for |d|<0.5  or |d|<1 (?)\\n\\n    Parameters\\n    ----------\\n    d : float\\n        fractional power\\n    n : int\\n        number of terms to calculate, including lag zero\\n\\n    Returns\\n    -------\\n    ar : ndarray\\n        coefficients of lag polynomial\\n\\n    Notes:\\n    first coefficient is 1, negative signs except for first term,\\n    ar(L)*x_t\\n    '\n    from scipy.special import gammaln\n    j = np.arange(n)\n    ar = -np.exp(gammaln(-d + j) - gammaln(j + 1) - gammaln(-d))\n    ar[0] = 1\n    return ar",
            "def lpol_fiar(d, n=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'AR representation of fractional integration\\n\\n    .. math:: (1-L)^{d} for |d|<0.5  or |d|<1 (?)\\n\\n    Parameters\\n    ----------\\n    d : float\\n        fractional power\\n    n : int\\n        number of terms to calculate, including lag zero\\n\\n    Returns\\n    -------\\n    ar : ndarray\\n        coefficients of lag polynomial\\n\\n    Notes:\\n    first coefficient is 1, negative signs except for first term,\\n    ar(L)*x_t\\n    '\n    from scipy.special import gammaln\n    j = np.arange(n)\n    ar = -np.exp(gammaln(-d + j) - gammaln(j + 1) - gammaln(-d))\n    ar[0] = 1\n    return ar",
            "def lpol_fiar(d, n=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'AR representation of fractional integration\\n\\n    .. math:: (1-L)^{d} for |d|<0.5  or |d|<1 (?)\\n\\n    Parameters\\n    ----------\\n    d : float\\n        fractional power\\n    n : int\\n        number of terms to calculate, including lag zero\\n\\n    Returns\\n    -------\\n    ar : ndarray\\n        coefficients of lag polynomial\\n\\n    Notes:\\n    first coefficient is 1, negative signs except for first term,\\n    ar(L)*x_t\\n    '\n    from scipy.special import gammaln\n    j = np.arange(n)\n    ar = -np.exp(gammaln(-d + j) - gammaln(j + 1) - gammaln(-d))\n    ar[0] = 1\n    return ar",
            "def lpol_fiar(d, n=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'AR representation of fractional integration\\n\\n    .. math:: (1-L)^{d} for |d|<0.5  or |d|<1 (?)\\n\\n    Parameters\\n    ----------\\n    d : float\\n        fractional power\\n    n : int\\n        number of terms to calculate, including lag zero\\n\\n    Returns\\n    -------\\n    ar : ndarray\\n        coefficients of lag polynomial\\n\\n    Notes:\\n    first coefficient is 1, negative signs except for first term,\\n    ar(L)*x_t\\n    '\n    from scipy.special import gammaln\n    j = np.arange(n)\n    ar = -np.exp(gammaln(-d + j) - gammaln(j + 1) - gammaln(-d))\n    ar[0] = 1\n    return ar"
        ]
    },
    {
        "func_name": "lpol_sdiff",
        "original": "def lpol_sdiff(s):\n    \"\"\"return coefficients for seasonal difference (1-L^s)\n\n    just a trivial convenience function\n\n    Parameters\n    ----------\n    s : int\n        number of periods in season\n\n    Returns\n    -------\n    sdiff : list, length s+1\n    \"\"\"\n    return [1] + [0] * (s - 1) + [-1]",
        "mutated": [
            "def lpol_sdiff(s):\n    if False:\n        i = 10\n    'return coefficients for seasonal difference (1-L^s)\\n\\n    just a trivial convenience function\\n\\n    Parameters\\n    ----------\\n    s : int\\n        number of periods in season\\n\\n    Returns\\n    -------\\n    sdiff : list, length s+1\\n    '\n    return [1] + [0] * (s - 1) + [-1]",
            "def lpol_sdiff(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'return coefficients for seasonal difference (1-L^s)\\n\\n    just a trivial convenience function\\n\\n    Parameters\\n    ----------\\n    s : int\\n        number of periods in season\\n\\n    Returns\\n    -------\\n    sdiff : list, length s+1\\n    '\n    return [1] + [0] * (s - 1) + [-1]",
            "def lpol_sdiff(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'return coefficients for seasonal difference (1-L^s)\\n\\n    just a trivial convenience function\\n\\n    Parameters\\n    ----------\\n    s : int\\n        number of periods in season\\n\\n    Returns\\n    -------\\n    sdiff : list, length s+1\\n    '\n    return [1] + [0] * (s - 1) + [-1]",
            "def lpol_sdiff(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'return coefficients for seasonal difference (1-L^s)\\n\\n    just a trivial convenience function\\n\\n    Parameters\\n    ----------\\n    s : int\\n        number of periods in season\\n\\n    Returns\\n    -------\\n    sdiff : list, length s+1\\n    '\n    return [1] + [0] * (s - 1) + [-1]",
            "def lpol_sdiff(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'return coefficients for seasonal difference (1-L^s)\\n\\n    just a trivial convenience function\\n\\n    Parameters\\n    ----------\\n    s : int\\n        number of periods in season\\n\\n    Returns\\n    -------\\n    sdiff : list, length s+1\\n    '\n    return [1] + [0] * (s - 1) + [-1]"
        ]
    },
    {
        "func_name": "deconvolve",
        "original": "def deconvolve(num, den, n=None):\n    \"\"\"Deconvolves divisor out of signal, division of polynomials for n terms\n\n    calculates den^{-1} * num\n\n    Parameters\n    ----------\n    num : array_like\n        signal or lag polynomial\n    denom : array_like\n        coefficients of lag polynomial (linear filter)\n    n : None or int\n        number of terms of quotient\n\n    Returns\n    -------\n    quot : ndarray\n        quotient or filtered series\n    rem : ndarray\n        remainder\n\n    Notes\n    -----\n    If num is a time series, then this applies the linear filter den^{-1}.\n    If both num and den are both lag polynomials, then this calculates the\n    quotient polynomial for n terms and also returns the remainder.\n\n    This is copied from scipy.signal.signaltools and added n as optional\n    parameter.\n    \"\"\"\n    num = np.atleast_1d(num)\n    den = np.atleast_1d(den)\n    N = len(num)\n    D = len(den)\n    if D > N and n is None:\n        quot = []\n        rem = num\n    else:\n        if n is None:\n            n = N - D + 1\n        input = np.zeros(n, float)\n        input[0] = 1\n        quot = signal.lfilter(num, den, input)\n        num_approx = signal.convolve(den, quot, mode='full')\n        if len(num) < len(num_approx):\n            num = np.concatenate((num, np.zeros(len(num_approx) - len(num))))\n        rem = num - num_approx\n    return (quot, rem)",
        "mutated": [
            "def deconvolve(num, den, n=None):\n    if False:\n        i = 10\n    'Deconvolves divisor out of signal, division of polynomials for n terms\\n\\n    calculates den^{-1} * num\\n\\n    Parameters\\n    ----------\\n    num : array_like\\n        signal or lag polynomial\\n    denom : array_like\\n        coefficients of lag polynomial (linear filter)\\n    n : None or int\\n        number of terms of quotient\\n\\n    Returns\\n    -------\\n    quot : ndarray\\n        quotient or filtered series\\n    rem : ndarray\\n        remainder\\n\\n    Notes\\n    -----\\n    If num is a time series, then this applies the linear filter den^{-1}.\\n    If both num and den are both lag polynomials, then this calculates the\\n    quotient polynomial for n terms and also returns the remainder.\\n\\n    This is copied from scipy.signal.signaltools and added n as optional\\n    parameter.\\n    '\n    num = np.atleast_1d(num)\n    den = np.atleast_1d(den)\n    N = len(num)\n    D = len(den)\n    if D > N and n is None:\n        quot = []\n        rem = num\n    else:\n        if n is None:\n            n = N - D + 1\n        input = np.zeros(n, float)\n        input[0] = 1\n        quot = signal.lfilter(num, den, input)\n        num_approx = signal.convolve(den, quot, mode='full')\n        if len(num) < len(num_approx):\n            num = np.concatenate((num, np.zeros(len(num_approx) - len(num))))\n        rem = num - num_approx\n    return (quot, rem)",
            "def deconvolve(num, den, n=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Deconvolves divisor out of signal, division of polynomials for n terms\\n\\n    calculates den^{-1} * num\\n\\n    Parameters\\n    ----------\\n    num : array_like\\n        signal or lag polynomial\\n    denom : array_like\\n        coefficients of lag polynomial (linear filter)\\n    n : None or int\\n        number of terms of quotient\\n\\n    Returns\\n    -------\\n    quot : ndarray\\n        quotient or filtered series\\n    rem : ndarray\\n        remainder\\n\\n    Notes\\n    -----\\n    If num is a time series, then this applies the linear filter den^{-1}.\\n    If both num and den are both lag polynomials, then this calculates the\\n    quotient polynomial for n terms and also returns the remainder.\\n\\n    This is copied from scipy.signal.signaltools and added n as optional\\n    parameter.\\n    '\n    num = np.atleast_1d(num)\n    den = np.atleast_1d(den)\n    N = len(num)\n    D = len(den)\n    if D > N and n is None:\n        quot = []\n        rem = num\n    else:\n        if n is None:\n            n = N - D + 1\n        input = np.zeros(n, float)\n        input[0] = 1\n        quot = signal.lfilter(num, den, input)\n        num_approx = signal.convolve(den, quot, mode='full')\n        if len(num) < len(num_approx):\n            num = np.concatenate((num, np.zeros(len(num_approx) - len(num))))\n        rem = num - num_approx\n    return (quot, rem)",
            "def deconvolve(num, den, n=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Deconvolves divisor out of signal, division of polynomials for n terms\\n\\n    calculates den^{-1} * num\\n\\n    Parameters\\n    ----------\\n    num : array_like\\n        signal or lag polynomial\\n    denom : array_like\\n        coefficients of lag polynomial (linear filter)\\n    n : None or int\\n        number of terms of quotient\\n\\n    Returns\\n    -------\\n    quot : ndarray\\n        quotient or filtered series\\n    rem : ndarray\\n        remainder\\n\\n    Notes\\n    -----\\n    If num is a time series, then this applies the linear filter den^{-1}.\\n    If both num and den are both lag polynomials, then this calculates the\\n    quotient polynomial for n terms and also returns the remainder.\\n\\n    This is copied from scipy.signal.signaltools and added n as optional\\n    parameter.\\n    '\n    num = np.atleast_1d(num)\n    den = np.atleast_1d(den)\n    N = len(num)\n    D = len(den)\n    if D > N and n is None:\n        quot = []\n        rem = num\n    else:\n        if n is None:\n            n = N - D + 1\n        input = np.zeros(n, float)\n        input[0] = 1\n        quot = signal.lfilter(num, den, input)\n        num_approx = signal.convolve(den, quot, mode='full')\n        if len(num) < len(num_approx):\n            num = np.concatenate((num, np.zeros(len(num_approx) - len(num))))\n        rem = num - num_approx\n    return (quot, rem)",
            "def deconvolve(num, den, n=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Deconvolves divisor out of signal, division of polynomials for n terms\\n\\n    calculates den^{-1} * num\\n\\n    Parameters\\n    ----------\\n    num : array_like\\n        signal or lag polynomial\\n    denom : array_like\\n        coefficients of lag polynomial (linear filter)\\n    n : None or int\\n        number of terms of quotient\\n\\n    Returns\\n    -------\\n    quot : ndarray\\n        quotient or filtered series\\n    rem : ndarray\\n        remainder\\n\\n    Notes\\n    -----\\n    If num is a time series, then this applies the linear filter den^{-1}.\\n    If both num and den are both lag polynomials, then this calculates the\\n    quotient polynomial for n terms and also returns the remainder.\\n\\n    This is copied from scipy.signal.signaltools and added n as optional\\n    parameter.\\n    '\n    num = np.atleast_1d(num)\n    den = np.atleast_1d(den)\n    N = len(num)\n    D = len(den)\n    if D > N and n is None:\n        quot = []\n        rem = num\n    else:\n        if n is None:\n            n = N - D + 1\n        input = np.zeros(n, float)\n        input[0] = 1\n        quot = signal.lfilter(num, den, input)\n        num_approx = signal.convolve(den, quot, mode='full')\n        if len(num) < len(num_approx):\n            num = np.concatenate((num, np.zeros(len(num_approx) - len(num))))\n        rem = num - num_approx\n    return (quot, rem)",
            "def deconvolve(num, den, n=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Deconvolves divisor out of signal, division of polynomials for n terms\\n\\n    calculates den^{-1} * num\\n\\n    Parameters\\n    ----------\\n    num : array_like\\n        signal or lag polynomial\\n    denom : array_like\\n        coefficients of lag polynomial (linear filter)\\n    n : None or int\\n        number of terms of quotient\\n\\n    Returns\\n    -------\\n    quot : ndarray\\n        quotient or filtered series\\n    rem : ndarray\\n        remainder\\n\\n    Notes\\n    -----\\n    If num is a time series, then this applies the linear filter den^{-1}.\\n    If both num and den are both lag polynomials, then this calculates the\\n    quotient polynomial for n terms and also returns the remainder.\\n\\n    This is copied from scipy.signal.signaltools and added n as optional\\n    parameter.\\n    '\n    num = np.atleast_1d(num)\n    den = np.atleast_1d(den)\n    N = len(num)\n    D = len(den)\n    if D > N and n is None:\n        quot = []\n        rem = num\n    else:\n        if n is None:\n            n = N - D + 1\n        input = np.zeros(n, float)\n        input[0] = 1\n        quot = signal.lfilter(num, den, input)\n        num_approx = signal.convolve(den, quot, mode='full')\n        if len(num) < len(num_approx):\n            num = np.concatenate((num, np.zeros(len(num_approx) - len(num))))\n        rem = num - num_approx\n    return (quot, rem)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, ar=None, ma=None, nobs=100):\n    if ar is None:\n        ar = np.array([1.0])\n    if ma is None:\n        ma = np.array([1.0])\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', np.ComplexWarning)\n        self.ar = array_like(ar, 'ar')\n        self.ma = array_like(ma, 'ma')\n    self.arcoefs = -self.ar[1:]\n    self.macoefs = self.ma[1:]\n    self.arpoly = np.polynomial.Polynomial(self.ar)\n    self.mapoly = np.polynomial.Polynomial(self.ma)\n    self.nobs = nobs",
        "mutated": [
            "def __init__(self, ar=None, ma=None, nobs=100):\n    if False:\n        i = 10\n    if ar is None:\n        ar = np.array([1.0])\n    if ma is None:\n        ma = np.array([1.0])\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', np.ComplexWarning)\n        self.ar = array_like(ar, 'ar')\n        self.ma = array_like(ma, 'ma')\n    self.arcoefs = -self.ar[1:]\n    self.macoefs = self.ma[1:]\n    self.arpoly = np.polynomial.Polynomial(self.ar)\n    self.mapoly = np.polynomial.Polynomial(self.ma)\n    self.nobs = nobs",
            "def __init__(self, ar=None, ma=None, nobs=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if ar is None:\n        ar = np.array([1.0])\n    if ma is None:\n        ma = np.array([1.0])\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', np.ComplexWarning)\n        self.ar = array_like(ar, 'ar')\n        self.ma = array_like(ma, 'ma')\n    self.arcoefs = -self.ar[1:]\n    self.macoefs = self.ma[1:]\n    self.arpoly = np.polynomial.Polynomial(self.ar)\n    self.mapoly = np.polynomial.Polynomial(self.ma)\n    self.nobs = nobs",
            "def __init__(self, ar=None, ma=None, nobs=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if ar is None:\n        ar = np.array([1.0])\n    if ma is None:\n        ma = np.array([1.0])\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', np.ComplexWarning)\n        self.ar = array_like(ar, 'ar')\n        self.ma = array_like(ma, 'ma')\n    self.arcoefs = -self.ar[1:]\n    self.macoefs = self.ma[1:]\n    self.arpoly = np.polynomial.Polynomial(self.ar)\n    self.mapoly = np.polynomial.Polynomial(self.ma)\n    self.nobs = nobs",
            "def __init__(self, ar=None, ma=None, nobs=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if ar is None:\n        ar = np.array([1.0])\n    if ma is None:\n        ma = np.array([1.0])\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', np.ComplexWarning)\n        self.ar = array_like(ar, 'ar')\n        self.ma = array_like(ma, 'ma')\n    self.arcoefs = -self.ar[1:]\n    self.macoefs = self.ma[1:]\n    self.arpoly = np.polynomial.Polynomial(self.ar)\n    self.mapoly = np.polynomial.Polynomial(self.ma)\n    self.nobs = nobs",
            "def __init__(self, ar=None, ma=None, nobs=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if ar is None:\n        ar = np.array([1.0])\n    if ma is None:\n        ma = np.array([1.0])\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', np.ComplexWarning)\n        self.ar = array_like(ar, 'ar')\n        self.ma = array_like(ma, 'ma')\n    self.arcoefs = -self.ar[1:]\n    self.macoefs = self.ma[1:]\n    self.arpoly = np.polynomial.Polynomial(self.ar)\n    self.mapoly = np.polynomial.Polynomial(self.ma)\n    self.nobs = nobs"
        ]
    },
    {
        "func_name": "from_roots",
        "original": "@classmethod\ndef from_roots(cls, maroots=None, arroots=None, nobs=100):\n    \"\"\"\n        Create ArmaProcess from AR and MA polynomial roots.\n\n        Parameters\n        ----------\n        maroots : array_like, optional\n            Roots for the MA polynomial\n            1 + theta_1*z + theta_2*z^2 + ..... + theta_n*z^n\n        arroots : array_like, optional\n            Roots for the AR polynomial\n            1 - phi_1*z - phi_2*z^2 - ..... - phi_n*z^n\n        nobs : int, optional\n            Length of simulated time series. Used, for example, if a sample\n            is generated.\n\n        Returns\n        -------\n        ArmaProcess\n            Class instance initialized with arcoefs and macoefs.\n\n        Examples\n        --------\n        >>> arroots = [.75, -.25]\n        >>> maroots = [.65, .35]\n        >>> arma_process = sm.tsa.ArmaProcess.from_roots(arroots, maroots)\n        >>> arma_process.isstationary\n        True\n        >>> arma_process.isinvertible\n        True\n        \"\"\"\n    if arroots is not None and len(arroots):\n        arpoly = np.polynomial.polynomial.Polynomial.fromroots(arroots)\n        arcoefs = arpoly.coef[1:] / arpoly.coef[0]\n    else:\n        arcoefs = []\n    if maroots is not None and len(maroots):\n        mapoly = np.polynomial.polynomial.Polynomial.fromroots(maroots)\n        macoefs = mapoly.coef[1:] / mapoly.coef[0]\n    else:\n        macoefs = []\n    return cls(np.r_[1, arcoefs], np.r_[1, macoefs], nobs=nobs)",
        "mutated": [
            "@classmethod\ndef from_roots(cls, maroots=None, arroots=None, nobs=100):\n    if False:\n        i = 10\n    '\\n        Create ArmaProcess from AR and MA polynomial roots.\\n\\n        Parameters\\n        ----------\\n        maroots : array_like, optional\\n            Roots for the MA polynomial\\n            1 + theta_1*z + theta_2*z^2 + ..... + theta_n*z^n\\n        arroots : array_like, optional\\n            Roots for the AR polynomial\\n            1 - phi_1*z - phi_2*z^2 - ..... - phi_n*z^n\\n        nobs : int, optional\\n            Length of simulated time series. Used, for example, if a sample\\n            is generated.\\n\\n        Returns\\n        -------\\n        ArmaProcess\\n            Class instance initialized with arcoefs and macoefs.\\n\\n        Examples\\n        --------\\n        >>> arroots = [.75, -.25]\\n        >>> maroots = [.65, .35]\\n        >>> arma_process = sm.tsa.ArmaProcess.from_roots(arroots, maroots)\\n        >>> arma_process.isstationary\\n        True\\n        >>> arma_process.isinvertible\\n        True\\n        '\n    if arroots is not None and len(arroots):\n        arpoly = np.polynomial.polynomial.Polynomial.fromroots(arroots)\n        arcoefs = arpoly.coef[1:] / arpoly.coef[0]\n    else:\n        arcoefs = []\n    if maroots is not None and len(maroots):\n        mapoly = np.polynomial.polynomial.Polynomial.fromroots(maroots)\n        macoefs = mapoly.coef[1:] / mapoly.coef[0]\n    else:\n        macoefs = []\n    return cls(np.r_[1, arcoefs], np.r_[1, macoefs], nobs=nobs)",
            "@classmethod\ndef from_roots(cls, maroots=None, arroots=None, nobs=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Create ArmaProcess from AR and MA polynomial roots.\\n\\n        Parameters\\n        ----------\\n        maroots : array_like, optional\\n            Roots for the MA polynomial\\n            1 + theta_1*z + theta_2*z^2 + ..... + theta_n*z^n\\n        arroots : array_like, optional\\n            Roots for the AR polynomial\\n            1 - phi_1*z - phi_2*z^2 - ..... - phi_n*z^n\\n        nobs : int, optional\\n            Length of simulated time series. Used, for example, if a sample\\n            is generated.\\n\\n        Returns\\n        -------\\n        ArmaProcess\\n            Class instance initialized with arcoefs and macoefs.\\n\\n        Examples\\n        --------\\n        >>> arroots = [.75, -.25]\\n        >>> maroots = [.65, .35]\\n        >>> arma_process = sm.tsa.ArmaProcess.from_roots(arroots, maroots)\\n        >>> arma_process.isstationary\\n        True\\n        >>> arma_process.isinvertible\\n        True\\n        '\n    if arroots is not None and len(arroots):\n        arpoly = np.polynomial.polynomial.Polynomial.fromroots(arroots)\n        arcoefs = arpoly.coef[1:] / arpoly.coef[0]\n    else:\n        arcoefs = []\n    if maroots is not None and len(maroots):\n        mapoly = np.polynomial.polynomial.Polynomial.fromroots(maroots)\n        macoefs = mapoly.coef[1:] / mapoly.coef[0]\n    else:\n        macoefs = []\n    return cls(np.r_[1, arcoefs], np.r_[1, macoefs], nobs=nobs)",
            "@classmethod\ndef from_roots(cls, maroots=None, arroots=None, nobs=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Create ArmaProcess from AR and MA polynomial roots.\\n\\n        Parameters\\n        ----------\\n        maroots : array_like, optional\\n            Roots for the MA polynomial\\n            1 + theta_1*z + theta_2*z^2 + ..... + theta_n*z^n\\n        arroots : array_like, optional\\n            Roots for the AR polynomial\\n            1 - phi_1*z - phi_2*z^2 - ..... - phi_n*z^n\\n        nobs : int, optional\\n            Length of simulated time series. Used, for example, if a sample\\n            is generated.\\n\\n        Returns\\n        -------\\n        ArmaProcess\\n            Class instance initialized with arcoefs and macoefs.\\n\\n        Examples\\n        --------\\n        >>> arroots = [.75, -.25]\\n        >>> maroots = [.65, .35]\\n        >>> arma_process = sm.tsa.ArmaProcess.from_roots(arroots, maroots)\\n        >>> arma_process.isstationary\\n        True\\n        >>> arma_process.isinvertible\\n        True\\n        '\n    if arroots is not None and len(arroots):\n        arpoly = np.polynomial.polynomial.Polynomial.fromroots(arroots)\n        arcoefs = arpoly.coef[1:] / arpoly.coef[0]\n    else:\n        arcoefs = []\n    if maroots is not None and len(maroots):\n        mapoly = np.polynomial.polynomial.Polynomial.fromroots(maroots)\n        macoefs = mapoly.coef[1:] / mapoly.coef[0]\n    else:\n        macoefs = []\n    return cls(np.r_[1, arcoefs], np.r_[1, macoefs], nobs=nobs)",
            "@classmethod\ndef from_roots(cls, maroots=None, arroots=None, nobs=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Create ArmaProcess from AR and MA polynomial roots.\\n\\n        Parameters\\n        ----------\\n        maroots : array_like, optional\\n            Roots for the MA polynomial\\n            1 + theta_1*z + theta_2*z^2 + ..... + theta_n*z^n\\n        arroots : array_like, optional\\n            Roots for the AR polynomial\\n            1 - phi_1*z - phi_2*z^2 - ..... - phi_n*z^n\\n        nobs : int, optional\\n            Length of simulated time series. Used, for example, if a sample\\n            is generated.\\n\\n        Returns\\n        -------\\n        ArmaProcess\\n            Class instance initialized with arcoefs and macoefs.\\n\\n        Examples\\n        --------\\n        >>> arroots = [.75, -.25]\\n        >>> maroots = [.65, .35]\\n        >>> arma_process = sm.tsa.ArmaProcess.from_roots(arroots, maroots)\\n        >>> arma_process.isstationary\\n        True\\n        >>> arma_process.isinvertible\\n        True\\n        '\n    if arroots is not None and len(arroots):\n        arpoly = np.polynomial.polynomial.Polynomial.fromroots(arroots)\n        arcoefs = arpoly.coef[1:] / arpoly.coef[0]\n    else:\n        arcoefs = []\n    if maroots is not None and len(maroots):\n        mapoly = np.polynomial.polynomial.Polynomial.fromroots(maroots)\n        macoefs = mapoly.coef[1:] / mapoly.coef[0]\n    else:\n        macoefs = []\n    return cls(np.r_[1, arcoefs], np.r_[1, macoefs], nobs=nobs)",
            "@classmethod\ndef from_roots(cls, maroots=None, arroots=None, nobs=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Create ArmaProcess from AR and MA polynomial roots.\\n\\n        Parameters\\n        ----------\\n        maroots : array_like, optional\\n            Roots for the MA polynomial\\n            1 + theta_1*z + theta_2*z^2 + ..... + theta_n*z^n\\n        arroots : array_like, optional\\n            Roots for the AR polynomial\\n            1 - phi_1*z - phi_2*z^2 - ..... - phi_n*z^n\\n        nobs : int, optional\\n            Length of simulated time series. Used, for example, if a sample\\n            is generated.\\n\\n        Returns\\n        -------\\n        ArmaProcess\\n            Class instance initialized with arcoefs and macoefs.\\n\\n        Examples\\n        --------\\n        >>> arroots = [.75, -.25]\\n        >>> maroots = [.65, .35]\\n        >>> arma_process = sm.tsa.ArmaProcess.from_roots(arroots, maroots)\\n        >>> arma_process.isstationary\\n        True\\n        >>> arma_process.isinvertible\\n        True\\n        '\n    if arroots is not None and len(arroots):\n        arpoly = np.polynomial.polynomial.Polynomial.fromroots(arroots)\n        arcoefs = arpoly.coef[1:] / arpoly.coef[0]\n    else:\n        arcoefs = []\n    if maroots is not None and len(maroots):\n        mapoly = np.polynomial.polynomial.Polynomial.fromroots(maroots)\n        macoefs = mapoly.coef[1:] / mapoly.coef[0]\n    else:\n        macoefs = []\n    return cls(np.r_[1, arcoefs], np.r_[1, macoefs], nobs=nobs)"
        ]
    },
    {
        "func_name": "from_coeffs",
        "original": "@classmethod\ndef from_coeffs(cls, arcoefs=None, macoefs=None, nobs=100):\n    \"\"\"\n        Create ArmaProcess from an ARMA representation.\n\n        Parameters\n        ----------\n        arcoefs : array_like\n            Coefficient for autoregressive lag polynomial, not including zero\n            lag. The sign is inverted to conform to the usual time series\n            representation of an ARMA process in statistics. See the class\n            docstring for more information.\n        macoefs : array_like\n            Coefficient for moving-average lag polynomial, excluding zero lag.\n        nobs : int, optional\n            Length of simulated time series. Used, for example, if a sample\n            is generated.\n\n        Returns\n        -------\n        ArmaProcess\n            Class instance initialized with arcoefs and macoefs.\n\n        Examples\n        --------\n        >>> arparams = [.75, -.25]\n        >>> maparams = [.65, .35]\n        >>> arma_process = sm.tsa.ArmaProcess.from_coeffs(ar, ma)\n        >>> arma_process.isstationary\n        True\n        >>> arma_process.isinvertible\n        True\n        \"\"\"\n    arcoefs = [] if arcoefs is None else arcoefs\n    macoefs = [] if macoefs is None else macoefs\n    return cls(np.r_[1, -np.asarray(arcoefs)], np.r_[1, np.asarray(macoefs)], nobs=nobs)",
        "mutated": [
            "@classmethod\ndef from_coeffs(cls, arcoefs=None, macoefs=None, nobs=100):\n    if False:\n        i = 10\n    '\\n        Create ArmaProcess from an ARMA representation.\\n\\n        Parameters\\n        ----------\\n        arcoefs : array_like\\n            Coefficient for autoregressive lag polynomial, not including zero\\n            lag. The sign is inverted to conform to the usual time series\\n            representation of an ARMA process in statistics. See the class\\n            docstring for more information.\\n        macoefs : array_like\\n            Coefficient for moving-average lag polynomial, excluding zero lag.\\n        nobs : int, optional\\n            Length of simulated time series. Used, for example, if a sample\\n            is generated.\\n\\n        Returns\\n        -------\\n        ArmaProcess\\n            Class instance initialized with arcoefs and macoefs.\\n\\n        Examples\\n        --------\\n        >>> arparams = [.75, -.25]\\n        >>> maparams = [.65, .35]\\n        >>> arma_process = sm.tsa.ArmaProcess.from_coeffs(ar, ma)\\n        >>> arma_process.isstationary\\n        True\\n        >>> arma_process.isinvertible\\n        True\\n        '\n    arcoefs = [] if arcoefs is None else arcoefs\n    macoefs = [] if macoefs is None else macoefs\n    return cls(np.r_[1, -np.asarray(arcoefs)], np.r_[1, np.asarray(macoefs)], nobs=nobs)",
            "@classmethod\ndef from_coeffs(cls, arcoefs=None, macoefs=None, nobs=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Create ArmaProcess from an ARMA representation.\\n\\n        Parameters\\n        ----------\\n        arcoefs : array_like\\n            Coefficient for autoregressive lag polynomial, not including zero\\n            lag. The sign is inverted to conform to the usual time series\\n            representation of an ARMA process in statistics. See the class\\n            docstring for more information.\\n        macoefs : array_like\\n            Coefficient for moving-average lag polynomial, excluding zero lag.\\n        nobs : int, optional\\n            Length of simulated time series. Used, for example, if a sample\\n            is generated.\\n\\n        Returns\\n        -------\\n        ArmaProcess\\n            Class instance initialized with arcoefs and macoefs.\\n\\n        Examples\\n        --------\\n        >>> arparams = [.75, -.25]\\n        >>> maparams = [.65, .35]\\n        >>> arma_process = sm.tsa.ArmaProcess.from_coeffs(ar, ma)\\n        >>> arma_process.isstationary\\n        True\\n        >>> arma_process.isinvertible\\n        True\\n        '\n    arcoefs = [] if arcoefs is None else arcoefs\n    macoefs = [] if macoefs is None else macoefs\n    return cls(np.r_[1, -np.asarray(arcoefs)], np.r_[1, np.asarray(macoefs)], nobs=nobs)",
            "@classmethod\ndef from_coeffs(cls, arcoefs=None, macoefs=None, nobs=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Create ArmaProcess from an ARMA representation.\\n\\n        Parameters\\n        ----------\\n        arcoefs : array_like\\n            Coefficient for autoregressive lag polynomial, not including zero\\n            lag. The sign is inverted to conform to the usual time series\\n            representation of an ARMA process in statistics. See the class\\n            docstring for more information.\\n        macoefs : array_like\\n            Coefficient for moving-average lag polynomial, excluding zero lag.\\n        nobs : int, optional\\n            Length of simulated time series. Used, for example, if a sample\\n            is generated.\\n\\n        Returns\\n        -------\\n        ArmaProcess\\n            Class instance initialized with arcoefs and macoefs.\\n\\n        Examples\\n        --------\\n        >>> arparams = [.75, -.25]\\n        >>> maparams = [.65, .35]\\n        >>> arma_process = sm.tsa.ArmaProcess.from_coeffs(ar, ma)\\n        >>> arma_process.isstationary\\n        True\\n        >>> arma_process.isinvertible\\n        True\\n        '\n    arcoefs = [] if arcoefs is None else arcoefs\n    macoefs = [] if macoefs is None else macoefs\n    return cls(np.r_[1, -np.asarray(arcoefs)], np.r_[1, np.asarray(macoefs)], nobs=nobs)",
            "@classmethod\ndef from_coeffs(cls, arcoefs=None, macoefs=None, nobs=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Create ArmaProcess from an ARMA representation.\\n\\n        Parameters\\n        ----------\\n        arcoefs : array_like\\n            Coefficient for autoregressive lag polynomial, not including zero\\n            lag. The sign is inverted to conform to the usual time series\\n            representation of an ARMA process in statistics. See the class\\n            docstring for more information.\\n        macoefs : array_like\\n            Coefficient for moving-average lag polynomial, excluding zero lag.\\n        nobs : int, optional\\n            Length of simulated time series. Used, for example, if a sample\\n            is generated.\\n\\n        Returns\\n        -------\\n        ArmaProcess\\n            Class instance initialized with arcoefs and macoefs.\\n\\n        Examples\\n        --------\\n        >>> arparams = [.75, -.25]\\n        >>> maparams = [.65, .35]\\n        >>> arma_process = sm.tsa.ArmaProcess.from_coeffs(ar, ma)\\n        >>> arma_process.isstationary\\n        True\\n        >>> arma_process.isinvertible\\n        True\\n        '\n    arcoefs = [] if arcoefs is None else arcoefs\n    macoefs = [] if macoefs is None else macoefs\n    return cls(np.r_[1, -np.asarray(arcoefs)], np.r_[1, np.asarray(macoefs)], nobs=nobs)",
            "@classmethod\ndef from_coeffs(cls, arcoefs=None, macoefs=None, nobs=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Create ArmaProcess from an ARMA representation.\\n\\n        Parameters\\n        ----------\\n        arcoefs : array_like\\n            Coefficient for autoregressive lag polynomial, not including zero\\n            lag. The sign is inverted to conform to the usual time series\\n            representation of an ARMA process in statistics. See the class\\n            docstring for more information.\\n        macoefs : array_like\\n            Coefficient for moving-average lag polynomial, excluding zero lag.\\n        nobs : int, optional\\n            Length of simulated time series. Used, for example, if a sample\\n            is generated.\\n\\n        Returns\\n        -------\\n        ArmaProcess\\n            Class instance initialized with arcoefs and macoefs.\\n\\n        Examples\\n        --------\\n        >>> arparams = [.75, -.25]\\n        >>> maparams = [.65, .35]\\n        >>> arma_process = sm.tsa.ArmaProcess.from_coeffs(ar, ma)\\n        >>> arma_process.isstationary\\n        True\\n        >>> arma_process.isinvertible\\n        True\\n        '\n    arcoefs = [] if arcoefs is None else arcoefs\n    macoefs = [] if macoefs is None else macoefs\n    return cls(np.r_[1, -np.asarray(arcoefs)], np.r_[1, np.asarray(macoefs)], nobs=nobs)"
        ]
    },
    {
        "func_name": "from_estimation",
        "original": "@classmethod\ndef from_estimation(cls, model_results, nobs=None):\n    \"\"\"\n        Create an ArmaProcess from the results of an ARIMA estimation.\n\n        Parameters\n        ----------\n        model_results : ARIMAResults instance\n            A fitted model.\n        nobs : int, optional\n            If None, nobs is taken from the results.\n\n        Returns\n        -------\n        ArmaProcess\n            Class instance initialized from model_results.\n\n        See Also\n        --------\n        statsmodels.tsa.arima.model.ARIMA\n            The models class used to create the ArmaProcess\n        \"\"\"\n    nobs = nobs or model_results.nobs\n    return cls(model_results.polynomial_reduced_ar, model_results.polynomial_reduced_ma, nobs=nobs)",
        "mutated": [
            "@classmethod\ndef from_estimation(cls, model_results, nobs=None):\n    if False:\n        i = 10\n    '\\n        Create an ArmaProcess from the results of an ARIMA estimation.\\n\\n        Parameters\\n        ----------\\n        model_results : ARIMAResults instance\\n            A fitted model.\\n        nobs : int, optional\\n            If None, nobs is taken from the results.\\n\\n        Returns\\n        -------\\n        ArmaProcess\\n            Class instance initialized from model_results.\\n\\n        See Also\\n        --------\\n        statsmodels.tsa.arima.model.ARIMA\\n            The models class used to create the ArmaProcess\\n        '\n    nobs = nobs or model_results.nobs\n    return cls(model_results.polynomial_reduced_ar, model_results.polynomial_reduced_ma, nobs=nobs)",
            "@classmethod\ndef from_estimation(cls, model_results, nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Create an ArmaProcess from the results of an ARIMA estimation.\\n\\n        Parameters\\n        ----------\\n        model_results : ARIMAResults instance\\n            A fitted model.\\n        nobs : int, optional\\n            If None, nobs is taken from the results.\\n\\n        Returns\\n        -------\\n        ArmaProcess\\n            Class instance initialized from model_results.\\n\\n        See Also\\n        --------\\n        statsmodels.tsa.arima.model.ARIMA\\n            The models class used to create the ArmaProcess\\n        '\n    nobs = nobs or model_results.nobs\n    return cls(model_results.polynomial_reduced_ar, model_results.polynomial_reduced_ma, nobs=nobs)",
            "@classmethod\ndef from_estimation(cls, model_results, nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Create an ArmaProcess from the results of an ARIMA estimation.\\n\\n        Parameters\\n        ----------\\n        model_results : ARIMAResults instance\\n            A fitted model.\\n        nobs : int, optional\\n            If None, nobs is taken from the results.\\n\\n        Returns\\n        -------\\n        ArmaProcess\\n            Class instance initialized from model_results.\\n\\n        See Also\\n        --------\\n        statsmodels.tsa.arima.model.ARIMA\\n            The models class used to create the ArmaProcess\\n        '\n    nobs = nobs or model_results.nobs\n    return cls(model_results.polynomial_reduced_ar, model_results.polynomial_reduced_ma, nobs=nobs)",
            "@classmethod\ndef from_estimation(cls, model_results, nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Create an ArmaProcess from the results of an ARIMA estimation.\\n\\n        Parameters\\n        ----------\\n        model_results : ARIMAResults instance\\n            A fitted model.\\n        nobs : int, optional\\n            If None, nobs is taken from the results.\\n\\n        Returns\\n        -------\\n        ArmaProcess\\n            Class instance initialized from model_results.\\n\\n        See Also\\n        --------\\n        statsmodels.tsa.arima.model.ARIMA\\n            The models class used to create the ArmaProcess\\n        '\n    nobs = nobs or model_results.nobs\n    return cls(model_results.polynomial_reduced_ar, model_results.polynomial_reduced_ma, nobs=nobs)",
            "@classmethod\ndef from_estimation(cls, model_results, nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Create an ArmaProcess from the results of an ARIMA estimation.\\n\\n        Parameters\\n        ----------\\n        model_results : ARIMAResults instance\\n            A fitted model.\\n        nobs : int, optional\\n            If None, nobs is taken from the results.\\n\\n        Returns\\n        -------\\n        ArmaProcess\\n            Class instance initialized from model_results.\\n\\n        See Also\\n        --------\\n        statsmodels.tsa.arima.model.ARIMA\\n            The models class used to create the ArmaProcess\\n        '\n    nobs = nobs or model_results.nobs\n    return cls(model_results.polynomial_reduced_ar, model_results.polynomial_reduced_ma, nobs=nobs)"
        ]
    },
    {
        "func_name": "__mul__",
        "original": "def __mul__(self, oth):\n    if isinstance(oth, self.__class__):\n        ar = (self.arpoly * oth.arpoly).coef\n        ma = (self.mapoly * oth.mapoly).coef\n    else:\n        try:\n            (aroth, maoth) = oth\n            arpolyoth = np.polynomial.Polynomial(aroth)\n            mapolyoth = np.polynomial.Polynomial(maoth)\n            ar = (self.arpoly * arpolyoth).coef\n            ma = (self.mapoly * mapolyoth).coef\n        except:\n            raise TypeError('Other type is not a valid type')\n    return self.__class__(ar, ma, nobs=self.nobs)",
        "mutated": [
            "def __mul__(self, oth):\n    if False:\n        i = 10\n    if isinstance(oth, self.__class__):\n        ar = (self.arpoly * oth.arpoly).coef\n        ma = (self.mapoly * oth.mapoly).coef\n    else:\n        try:\n            (aroth, maoth) = oth\n            arpolyoth = np.polynomial.Polynomial(aroth)\n            mapolyoth = np.polynomial.Polynomial(maoth)\n            ar = (self.arpoly * arpolyoth).coef\n            ma = (self.mapoly * mapolyoth).coef\n        except:\n            raise TypeError('Other type is not a valid type')\n    return self.__class__(ar, ma, nobs=self.nobs)",
            "def __mul__(self, oth):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(oth, self.__class__):\n        ar = (self.arpoly * oth.arpoly).coef\n        ma = (self.mapoly * oth.mapoly).coef\n    else:\n        try:\n            (aroth, maoth) = oth\n            arpolyoth = np.polynomial.Polynomial(aroth)\n            mapolyoth = np.polynomial.Polynomial(maoth)\n            ar = (self.arpoly * arpolyoth).coef\n            ma = (self.mapoly * mapolyoth).coef\n        except:\n            raise TypeError('Other type is not a valid type')\n    return self.__class__(ar, ma, nobs=self.nobs)",
            "def __mul__(self, oth):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(oth, self.__class__):\n        ar = (self.arpoly * oth.arpoly).coef\n        ma = (self.mapoly * oth.mapoly).coef\n    else:\n        try:\n            (aroth, maoth) = oth\n            arpolyoth = np.polynomial.Polynomial(aroth)\n            mapolyoth = np.polynomial.Polynomial(maoth)\n            ar = (self.arpoly * arpolyoth).coef\n            ma = (self.mapoly * mapolyoth).coef\n        except:\n            raise TypeError('Other type is not a valid type')\n    return self.__class__(ar, ma, nobs=self.nobs)",
            "def __mul__(self, oth):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(oth, self.__class__):\n        ar = (self.arpoly * oth.arpoly).coef\n        ma = (self.mapoly * oth.mapoly).coef\n    else:\n        try:\n            (aroth, maoth) = oth\n            arpolyoth = np.polynomial.Polynomial(aroth)\n            mapolyoth = np.polynomial.Polynomial(maoth)\n            ar = (self.arpoly * arpolyoth).coef\n            ma = (self.mapoly * mapolyoth).coef\n        except:\n            raise TypeError('Other type is not a valid type')\n    return self.__class__(ar, ma, nobs=self.nobs)",
            "def __mul__(self, oth):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(oth, self.__class__):\n        ar = (self.arpoly * oth.arpoly).coef\n        ma = (self.mapoly * oth.mapoly).coef\n    else:\n        try:\n            (aroth, maoth) = oth\n            arpolyoth = np.polynomial.Polynomial(aroth)\n            mapolyoth = np.polynomial.Polynomial(maoth)\n            ar = (self.arpoly * arpolyoth).coef\n            ma = (self.mapoly * mapolyoth).coef\n        except:\n            raise TypeError('Other type is not a valid type')\n    return self.__class__(ar, ma, nobs=self.nobs)"
        ]
    },
    {
        "func_name": "__repr__",
        "original": "def __repr__(self):\n    msg = 'ArmaProcess({0}, {1}, nobs={2}) at {3}'\n    return msg.format(self.ar.tolist(), self.ma.tolist(), self.nobs, hex(id(self)))",
        "mutated": [
            "def __repr__(self):\n    if False:\n        i = 10\n    msg = 'ArmaProcess({0}, {1}, nobs={2}) at {3}'\n    return msg.format(self.ar.tolist(), self.ma.tolist(), self.nobs, hex(id(self)))",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    msg = 'ArmaProcess({0}, {1}, nobs={2}) at {3}'\n    return msg.format(self.ar.tolist(), self.ma.tolist(), self.nobs, hex(id(self)))",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    msg = 'ArmaProcess({0}, {1}, nobs={2}) at {3}'\n    return msg.format(self.ar.tolist(), self.ma.tolist(), self.nobs, hex(id(self)))",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    msg = 'ArmaProcess({0}, {1}, nobs={2}) at {3}'\n    return msg.format(self.ar.tolist(), self.ma.tolist(), self.nobs, hex(id(self)))",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    msg = 'ArmaProcess({0}, {1}, nobs={2}) at {3}'\n    return msg.format(self.ar.tolist(), self.ma.tolist(), self.nobs, hex(id(self)))"
        ]
    },
    {
        "func_name": "__str__",
        "original": "def __str__(self):\n    return 'ArmaProcess\\nAR: {0}\\nMA: {1}'.format(self.ar.tolist(), self.ma.tolist())",
        "mutated": [
            "def __str__(self):\n    if False:\n        i = 10\n    return 'ArmaProcess\\nAR: {0}\\nMA: {1}'.format(self.ar.tolist(), self.ma.tolist())",
            "def __str__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 'ArmaProcess\\nAR: {0}\\nMA: {1}'.format(self.ar.tolist(), self.ma.tolist())",
            "def __str__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 'ArmaProcess\\nAR: {0}\\nMA: {1}'.format(self.ar.tolist(), self.ma.tolist())",
            "def __str__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 'ArmaProcess\\nAR: {0}\\nMA: {1}'.format(self.ar.tolist(), self.ma.tolist())",
            "def __str__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 'ArmaProcess\\nAR: {0}\\nMA: {1}'.format(self.ar.tolist(), self.ma.tolist())"
        ]
    },
    {
        "func_name": "acovf",
        "original": "@Appender(remove_parameters(arma_acovf.__doc__, ['ar', 'ma', 'sigma2']))\ndef acovf(self, nobs=None):\n    nobs = nobs or self.nobs\n    return arma_acovf(self.ar, self.ma, nobs=nobs)",
        "mutated": [
            "@Appender(remove_parameters(arma_acovf.__doc__, ['ar', 'ma', 'sigma2']))\ndef acovf(self, nobs=None):\n    if False:\n        i = 10\n    nobs = nobs or self.nobs\n    return arma_acovf(self.ar, self.ma, nobs=nobs)",
            "@Appender(remove_parameters(arma_acovf.__doc__, ['ar', 'ma', 'sigma2']))\ndef acovf(self, nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nobs = nobs or self.nobs\n    return arma_acovf(self.ar, self.ma, nobs=nobs)",
            "@Appender(remove_parameters(arma_acovf.__doc__, ['ar', 'ma', 'sigma2']))\ndef acovf(self, nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nobs = nobs or self.nobs\n    return arma_acovf(self.ar, self.ma, nobs=nobs)",
            "@Appender(remove_parameters(arma_acovf.__doc__, ['ar', 'ma', 'sigma2']))\ndef acovf(self, nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nobs = nobs or self.nobs\n    return arma_acovf(self.ar, self.ma, nobs=nobs)",
            "@Appender(remove_parameters(arma_acovf.__doc__, ['ar', 'ma', 'sigma2']))\ndef acovf(self, nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nobs = nobs or self.nobs\n    return arma_acovf(self.ar, self.ma, nobs=nobs)"
        ]
    },
    {
        "func_name": "acf",
        "original": "@Appender(remove_parameters(arma_acf.__doc__, ['ar', 'ma']))\ndef acf(self, lags=None):\n    lags = lags or self.nobs\n    return arma_acf(self.ar, self.ma, lags=lags)",
        "mutated": [
            "@Appender(remove_parameters(arma_acf.__doc__, ['ar', 'ma']))\ndef acf(self, lags=None):\n    if False:\n        i = 10\n    lags = lags or self.nobs\n    return arma_acf(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma_acf.__doc__, ['ar', 'ma']))\ndef acf(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    lags = lags or self.nobs\n    return arma_acf(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma_acf.__doc__, ['ar', 'ma']))\ndef acf(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    lags = lags or self.nobs\n    return arma_acf(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma_acf.__doc__, ['ar', 'ma']))\ndef acf(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    lags = lags or self.nobs\n    return arma_acf(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma_acf.__doc__, ['ar', 'ma']))\ndef acf(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    lags = lags or self.nobs\n    return arma_acf(self.ar, self.ma, lags=lags)"
        ]
    },
    {
        "func_name": "pacf",
        "original": "@Appender(remove_parameters(arma_pacf.__doc__, ['ar', 'ma']))\ndef pacf(self, lags=None):\n    lags = lags or self.nobs\n    return arma_pacf(self.ar, self.ma, lags=lags)",
        "mutated": [
            "@Appender(remove_parameters(arma_pacf.__doc__, ['ar', 'ma']))\ndef pacf(self, lags=None):\n    if False:\n        i = 10\n    lags = lags or self.nobs\n    return arma_pacf(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma_pacf.__doc__, ['ar', 'ma']))\ndef pacf(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    lags = lags or self.nobs\n    return arma_pacf(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma_pacf.__doc__, ['ar', 'ma']))\ndef pacf(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    lags = lags or self.nobs\n    return arma_pacf(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma_pacf.__doc__, ['ar', 'ma']))\ndef pacf(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    lags = lags or self.nobs\n    return arma_pacf(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma_pacf.__doc__, ['ar', 'ma']))\ndef pacf(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    lags = lags or self.nobs\n    return arma_pacf(self.ar, self.ma, lags=lags)"
        ]
    },
    {
        "func_name": "periodogram",
        "original": "@Appender(remove_parameters(arma_periodogram.__doc__, ['ar', 'ma', 'worN', 'whole']))\ndef periodogram(self, nobs=None):\n    nobs = nobs or self.nobs\n    return arma_periodogram(self.ar, self.ma, worN=nobs)",
        "mutated": [
            "@Appender(remove_parameters(arma_periodogram.__doc__, ['ar', 'ma', 'worN', 'whole']))\ndef periodogram(self, nobs=None):\n    if False:\n        i = 10\n    nobs = nobs or self.nobs\n    return arma_periodogram(self.ar, self.ma, worN=nobs)",
            "@Appender(remove_parameters(arma_periodogram.__doc__, ['ar', 'ma', 'worN', 'whole']))\ndef periodogram(self, nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nobs = nobs or self.nobs\n    return arma_periodogram(self.ar, self.ma, worN=nobs)",
            "@Appender(remove_parameters(arma_periodogram.__doc__, ['ar', 'ma', 'worN', 'whole']))\ndef periodogram(self, nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nobs = nobs or self.nobs\n    return arma_periodogram(self.ar, self.ma, worN=nobs)",
            "@Appender(remove_parameters(arma_periodogram.__doc__, ['ar', 'ma', 'worN', 'whole']))\ndef periodogram(self, nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nobs = nobs or self.nobs\n    return arma_periodogram(self.ar, self.ma, worN=nobs)",
            "@Appender(remove_parameters(arma_periodogram.__doc__, ['ar', 'ma', 'worN', 'whole']))\ndef periodogram(self, nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nobs = nobs or self.nobs\n    return arma_periodogram(self.ar, self.ma, worN=nobs)"
        ]
    },
    {
        "func_name": "impulse_response",
        "original": "@Appender(remove_parameters(arma_impulse_response.__doc__, ['ar', 'ma']))\ndef impulse_response(self, leads=None):\n    leads = leads or self.nobs\n    return arma_impulse_response(self.ar, self.ma, leads=leads)",
        "mutated": [
            "@Appender(remove_parameters(arma_impulse_response.__doc__, ['ar', 'ma']))\ndef impulse_response(self, leads=None):\n    if False:\n        i = 10\n    leads = leads or self.nobs\n    return arma_impulse_response(self.ar, self.ma, leads=leads)",
            "@Appender(remove_parameters(arma_impulse_response.__doc__, ['ar', 'ma']))\ndef impulse_response(self, leads=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    leads = leads or self.nobs\n    return arma_impulse_response(self.ar, self.ma, leads=leads)",
            "@Appender(remove_parameters(arma_impulse_response.__doc__, ['ar', 'ma']))\ndef impulse_response(self, leads=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    leads = leads or self.nobs\n    return arma_impulse_response(self.ar, self.ma, leads=leads)",
            "@Appender(remove_parameters(arma_impulse_response.__doc__, ['ar', 'ma']))\ndef impulse_response(self, leads=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    leads = leads or self.nobs\n    return arma_impulse_response(self.ar, self.ma, leads=leads)",
            "@Appender(remove_parameters(arma_impulse_response.__doc__, ['ar', 'ma']))\ndef impulse_response(self, leads=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    leads = leads or self.nobs\n    return arma_impulse_response(self.ar, self.ma, leads=leads)"
        ]
    },
    {
        "func_name": "arma2ma",
        "original": "@Appender(remove_parameters(arma2ma.__doc__, ['ar', 'ma']))\ndef arma2ma(self, lags=None):\n    lags = lags or self.lags\n    return arma2ma(self.ar, self.ma, lags=lags)",
        "mutated": [
            "@Appender(remove_parameters(arma2ma.__doc__, ['ar', 'ma']))\ndef arma2ma(self, lags=None):\n    if False:\n        i = 10\n    lags = lags or self.lags\n    return arma2ma(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma2ma.__doc__, ['ar', 'ma']))\ndef arma2ma(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    lags = lags or self.lags\n    return arma2ma(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma2ma.__doc__, ['ar', 'ma']))\ndef arma2ma(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    lags = lags or self.lags\n    return arma2ma(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma2ma.__doc__, ['ar', 'ma']))\ndef arma2ma(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    lags = lags or self.lags\n    return arma2ma(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma2ma.__doc__, ['ar', 'ma']))\ndef arma2ma(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    lags = lags or self.lags\n    return arma2ma(self.ar, self.ma, lags=lags)"
        ]
    },
    {
        "func_name": "arma2ar",
        "original": "@Appender(remove_parameters(arma2ar.__doc__, ['ar', 'ma']))\ndef arma2ar(self, lags=None):\n    lags = lags or self.lags\n    return arma2ar(self.ar, self.ma, lags=lags)",
        "mutated": [
            "@Appender(remove_parameters(arma2ar.__doc__, ['ar', 'ma']))\ndef arma2ar(self, lags=None):\n    if False:\n        i = 10\n    lags = lags or self.lags\n    return arma2ar(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma2ar.__doc__, ['ar', 'ma']))\ndef arma2ar(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    lags = lags or self.lags\n    return arma2ar(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma2ar.__doc__, ['ar', 'ma']))\ndef arma2ar(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    lags = lags or self.lags\n    return arma2ar(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma2ar.__doc__, ['ar', 'ma']))\ndef arma2ar(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    lags = lags or self.lags\n    return arma2ar(self.ar, self.ma, lags=lags)",
            "@Appender(remove_parameters(arma2ar.__doc__, ['ar', 'ma']))\ndef arma2ar(self, lags=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    lags = lags or self.lags\n    return arma2ar(self.ar, self.ma, lags=lags)"
        ]
    },
    {
        "func_name": "arroots",
        "original": "@property\ndef arroots(self):\n    \"\"\"Roots of autoregressive lag-polynomial\"\"\"\n    return self.arpoly.roots()",
        "mutated": [
            "@property\ndef arroots(self):\n    if False:\n        i = 10\n    'Roots of autoregressive lag-polynomial'\n    return self.arpoly.roots()",
            "@property\ndef arroots(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Roots of autoregressive lag-polynomial'\n    return self.arpoly.roots()",
            "@property\ndef arroots(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Roots of autoregressive lag-polynomial'\n    return self.arpoly.roots()",
            "@property\ndef arroots(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Roots of autoregressive lag-polynomial'\n    return self.arpoly.roots()",
            "@property\ndef arroots(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Roots of autoregressive lag-polynomial'\n    return self.arpoly.roots()"
        ]
    },
    {
        "func_name": "maroots",
        "original": "@property\ndef maroots(self):\n    \"\"\"Roots of moving average lag-polynomial\"\"\"\n    return self.mapoly.roots()",
        "mutated": [
            "@property\ndef maroots(self):\n    if False:\n        i = 10\n    'Roots of moving average lag-polynomial'\n    return self.mapoly.roots()",
            "@property\ndef maroots(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Roots of moving average lag-polynomial'\n    return self.mapoly.roots()",
            "@property\ndef maroots(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Roots of moving average lag-polynomial'\n    return self.mapoly.roots()",
            "@property\ndef maroots(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Roots of moving average lag-polynomial'\n    return self.mapoly.roots()",
            "@property\ndef maroots(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Roots of moving average lag-polynomial'\n    return self.mapoly.roots()"
        ]
    },
    {
        "func_name": "isstationary",
        "original": "@property\ndef isstationary(self):\n    \"\"\"\n        Arma process is stationary if AR roots are outside unit circle.\n\n        Returns\n        -------\n        bool\n             True if autoregressive roots are outside unit circle.\n        \"\"\"\n    if np.all(np.abs(self.arroots) > 1.0):\n        return True\n    else:\n        return False",
        "mutated": [
            "@property\ndef isstationary(self):\n    if False:\n        i = 10\n    '\\n        Arma process is stationary if AR roots are outside unit circle.\\n\\n        Returns\\n        -------\\n        bool\\n             True if autoregressive roots are outside unit circle.\\n        '\n    if np.all(np.abs(self.arroots) > 1.0):\n        return True\n    else:\n        return False",
            "@property\ndef isstationary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Arma process is stationary if AR roots are outside unit circle.\\n\\n        Returns\\n        -------\\n        bool\\n             True if autoregressive roots are outside unit circle.\\n        '\n    if np.all(np.abs(self.arroots) > 1.0):\n        return True\n    else:\n        return False",
            "@property\ndef isstationary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Arma process is stationary if AR roots are outside unit circle.\\n\\n        Returns\\n        -------\\n        bool\\n             True if autoregressive roots are outside unit circle.\\n        '\n    if np.all(np.abs(self.arroots) > 1.0):\n        return True\n    else:\n        return False",
            "@property\ndef isstationary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Arma process is stationary if AR roots are outside unit circle.\\n\\n        Returns\\n        -------\\n        bool\\n             True if autoregressive roots are outside unit circle.\\n        '\n    if np.all(np.abs(self.arroots) > 1.0):\n        return True\n    else:\n        return False",
            "@property\ndef isstationary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Arma process is stationary if AR roots are outside unit circle.\\n\\n        Returns\\n        -------\\n        bool\\n             True if autoregressive roots are outside unit circle.\\n        '\n    if np.all(np.abs(self.arroots) > 1.0):\n        return True\n    else:\n        return False"
        ]
    },
    {
        "func_name": "isinvertible",
        "original": "@property\ndef isinvertible(self):\n    \"\"\"\n        Arma process is invertible if MA roots are outside unit circle.\n\n        Returns\n        -------\n        bool\n             True if moving average roots are outside unit circle.\n        \"\"\"\n    if np.all(np.abs(self.maroots) > 1):\n        return True\n    else:\n        return False",
        "mutated": [
            "@property\ndef isinvertible(self):\n    if False:\n        i = 10\n    '\\n        Arma process is invertible if MA roots are outside unit circle.\\n\\n        Returns\\n        -------\\n        bool\\n             True if moving average roots are outside unit circle.\\n        '\n    if np.all(np.abs(self.maroots) > 1):\n        return True\n    else:\n        return False",
            "@property\ndef isinvertible(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Arma process is invertible if MA roots are outside unit circle.\\n\\n        Returns\\n        -------\\n        bool\\n             True if moving average roots are outside unit circle.\\n        '\n    if np.all(np.abs(self.maroots) > 1):\n        return True\n    else:\n        return False",
            "@property\ndef isinvertible(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Arma process is invertible if MA roots are outside unit circle.\\n\\n        Returns\\n        -------\\n        bool\\n             True if moving average roots are outside unit circle.\\n        '\n    if np.all(np.abs(self.maroots) > 1):\n        return True\n    else:\n        return False",
            "@property\ndef isinvertible(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Arma process is invertible if MA roots are outside unit circle.\\n\\n        Returns\\n        -------\\n        bool\\n             True if moving average roots are outside unit circle.\\n        '\n    if np.all(np.abs(self.maroots) > 1):\n        return True\n    else:\n        return False",
            "@property\ndef isinvertible(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Arma process is invertible if MA roots are outside unit circle.\\n\\n        Returns\\n        -------\\n        bool\\n             True if moving average roots are outside unit circle.\\n        '\n    if np.all(np.abs(self.maroots) > 1):\n        return True\n    else:\n        return False"
        ]
    },
    {
        "func_name": "invertroots",
        "original": "def invertroots(self, retnew=False):\n    \"\"\"\n        Make MA polynomial invertible by inverting roots inside unit circle.\n\n        Parameters\n        ----------\n        retnew : bool\n            If False (default), then return the lag-polynomial as array.\n            If True, then return a new instance with invertible MA-polynomial.\n\n        Returns\n        -------\n        manew : ndarray\n           A new invertible MA lag-polynomial, returned if retnew is false.\n        wasinvertible : bool\n           True if the MA lag-polynomial was already invertible, returned if\n           retnew is false.\n        armaprocess : new instance of class\n           If retnew is true, then return a new instance with invertible\n           MA-polynomial.\n        \"\"\"\n    pr = self.maroots\n    mainv = self.ma\n    invertible = self.isinvertible\n    if not invertible:\n        pr[np.abs(pr) < 1] = 1.0 / pr[np.abs(pr) < 1]\n        pnew = np.polynomial.Polynomial.fromroots(pr)\n        mainv = pnew.coef / pnew.coef[0]\n    if retnew:\n        return self.__class__(self.ar, mainv, nobs=self.nobs)\n    else:\n        return (mainv, invertible)",
        "mutated": [
            "def invertroots(self, retnew=False):\n    if False:\n        i = 10\n    '\\n        Make MA polynomial invertible by inverting roots inside unit circle.\\n\\n        Parameters\\n        ----------\\n        retnew : bool\\n            If False (default), then return the lag-polynomial as array.\\n            If True, then return a new instance with invertible MA-polynomial.\\n\\n        Returns\\n        -------\\n        manew : ndarray\\n           A new invertible MA lag-polynomial, returned if retnew is false.\\n        wasinvertible : bool\\n           True if the MA lag-polynomial was already invertible, returned if\\n           retnew is false.\\n        armaprocess : new instance of class\\n           If retnew is true, then return a new instance with invertible\\n           MA-polynomial.\\n        '\n    pr = self.maroots\n    mainv = self.ma\n    invertible = self.isinvertible\n    if not invertible:\n        pr[np.abs(pr) < 1] = 1.0 / pr[np.abs(pr) < 1]\n        pnew = np.polynomial.Polynomial.fromroots(pr)\n        mainv = pnew.coef / pnew.coef[0]\n    if retnew:\n        return self.__class__(self.ar, mainv, nobs=self.nobs)\n    else:\n        return (mainv, invertible)",
            "def invertroots(self, retnew=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Make MA polynomial invertible by inverting roots inside unit circle.\\n\\n        Parameters\\n        ----------\\n        retnew : bool\\n            If False (default), then return the lag-polynomial as array.\\n            If True, then return a new instance with invertible MA-polynomial.\\n\\n        Returns\\n        -------\\n        manew : ndarray\\n           A new invertible MA lag-polynomial, returned if retnew is false.\\n        wasinvertible : bool\\n           True if the MA lag-polynomial was already invertible, returned if\\n           retnew is false.\\n        armaprocess : new instance of class\\n           If retnew is true, then return a new instance with invertible\\n           MA-polynomial.\\n        '\n    pr = self.maroots\n    mainv = self.ma\n    invertible = self.isinvertible\n    if not invertible:\n        pr[np.abs(pr) < 1] = 1.0 / pr[np.abs(pr) < 1]\n        pnew = np.polynomial.Polynomial.fromroots(pr)\n        mainv = pnew.coef / pnew.coef[0]\n    if retnew:\n        return self.__class__(self.ar, mainv, nobs=self.nobs)\n    else:\n        return (mainv, invertible)",
            "def invertroots(self, retnew=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Make MA polynomial invertible by inverting roots inside unit circle.\\n\\n        Parameters\\n        ----------\\n        retnew : bool\\n            If False (default), then return the lag-polynomial as array.\\n            If True, then return a new instance with invertible MA-polynomial.\\n\\n        Returns\\n        -------\\n        manew : ndarray\\n           A new invertible MA lag-polynomial, returned if retnew is false.\\n        wasinvertible : bool\\n           True if the MA lag-polynomial was already invertible, returned if\\n           retnew is false.\\n        armaprocess : new instance of class\\n           If retnew is true, then return a new instance with invertible\\n           MA-polynomial.\\n        '\n    pr = self.maroots\n    mainv = self.ma\n    invertible = self.isinvertible\n    if not invertible:\n        pr[np.abs(pr) < 1] = 1.0 / pr[np.abs(pr) < 1]\n        pnew = np.polynomial.Polynomial.fromroots(pr)\n        mainv = pnew.coef / pnew.coef[0]\n    if retnew:\n        return self.__class__(self.ar, mainv, nobs=self.nobs)\n    else:\n        return (mainv, invertible)",
            "def invertroots(self, retnew=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Make MA polynomial invertible by inverting roots inside unit circle.\\n\\n        Parameters\\n        ----------\\n        retnew : bool\\n            If False (default), then return the lag-polynomial as array.\\n            If True, then return a new instance with invertible MA-polynomial.\\n\\n        Returns\\n        -------\\n        manew : ndarray\\n           A new invertible MA lag-polynomial, returned if retnew is false.\\n        wasinvertible : bool\\n           True if the MA lag-polynomial was already invertible, returned if\\n           retnew is false.\\n        armaprocess : new instance of class\\n           If retnew is true, then return a new instance with invertible\\n           MA-polynomial.\\n        '\n    pr = self.maroots\n    mainv = self.ma\n    invertible = self.isinvertible\n    if not invertible:\n        pr[np.abs(pr) < 1] = 1.0 / pr[np.abs(pr) < 1]\n        pnew = np.polynomial.Polynomial.fromroots(pr)\n        mainv = pnew.coef / pnew.coef[0]\n    if retnew:\n        return self.__class__(self.ar, mainv, nobs=self.nobs)\n    else:\n        return (mainv, invertible)",
            "def invertroots(self, retnew=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Make MA polynomial invertible by inverting roots inside unit circle.\\n\\n        Parameters\\n        ----------\\n        retnew : bool\\n            If False (default), then return the lag-polynomial as array.\\n            If True, then return a new instance with invertible MA-polynomial.\\n\\n        Returns\\n        -------\\n        manew : ndarray\\n           A new invertible MA lag-polynomial, returned if retnew is false.\\n        wasinvertible : bool\\n           True if the MA lag-polynomial was already invertible, returned if\\n           retnew is false.\\n        armaprocess : new instance of class\\n           If retnew is true, then return a new instance with invertible\\n           MA-polynomial.\\n        '\n    pr = self.maroots\n    mainv = self.ma\n    invertible = self.isinvertible\n    if not invertible:\n        pr[np.abs(pr) < 1] = 1.0 / pr[np.abs(pr) < 1]\n        pnew = np.polynomial.Polynomial.fromroots(pr)\n        mainv = pnew.coef / pnew.coef[0]\n    if retnew:\n        return self.__class__(self.ar, mainv, nobs=self.nobs)\n    else:\n        return (mainv, invertible)"
        ]
    },
    {
        "func_name": "generate_sample",
        "original": "@Appender(str(_generate_sample_doc))\ndef generate_sample(self, nsample=100, scale=1.0, distrvs=None, axis=0, burnin=0):\n    return arma_generate_sample(self.ar, self.ma, nsample, scale, distrvs, axis=axis, burnin=burnin)",
        "mutated": [
            "@Appender(str(_generate_sample_doc))\ndef generate_sample(self, nsample=100, scale=1.0, distrvs=None, axis=0, burnin=0):\n    if False:\n        i = 10\n    return arma_generate_sample(self.ar, self.ma, nsample, scale, distrvs, axis=axis, burnin=burnin)",
            "@Appender(str(_generate_sample_doc))\ndef generate_sample(self, nsample=100, scale=1.0, distrvs=None, axis=0, burnin=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return arma_generate_sample(self.ar, self.ma, nsample, scale, distrvs, axis=axis, burnin=burnin)",
            "@Appender(str(_generate_sample_doc))\ndef generate_sample(self, nsample=100, scale=1.0, distrvs=None, axis=0, burnin=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return arma_generate_sample(self.ar, self.ma, nsample, scale, distrvs, axis=axis, burnin=burnin)",
            "@Appender(str(_generate_sample_doc))\ndef generate_sample(self, nsample=100, scale=1.0, distrvs=None, axis=0, burnin=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return arma_generate_sample(self.ar, self.ma, nsample, scale, distrvs, axis=axis, burnin=burnin)",
            "@Appender(str(_generate_sample_doc))\ndef generate_sample(self, nsample=100, scale=1.0, distrvs=None, axis=0, burnin=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return arma_generate_sample(self.ar, self.ma, nsample, scale, distrvs, axis=axis, burnin=burnin)"
        ]
    }
]