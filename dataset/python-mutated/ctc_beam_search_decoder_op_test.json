[
    {
        "func_name": "input_generater",
        "original": "def input_generater():\n    inputs = np.random.rand(max_time, batch, alphabet_size).astype(np.float32)\n    seq_len = np.random.randint(1, max_time + 1, size=batch).astype(np.int32)\n    return (inputs, seq_len)",
        "mutated": [
            "def input_generater():\n    if False:\n        i = 10\n    inputs = np.random.rand(max_time, batch, alphabet_size).astype(np.float32)\n    seq_len = np.random.randint(1, max_time + 1, size=batch).astype(np.int32)\n    return (inputs, seq_len)",
            "def input_generater():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    inputs = np.random.rand(max_time, batch, alphabet_size).astype(np.float32)\n    seq_len = np.random.randint(1, max_time + 1, size=batch).astype(np.int32)\n    return (inputs, seq_len)",
            "def input_generater():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    inputs = np.random.rand(max_time, batch, alphabet_size).astype(np.float32)\n    seq_len = np.random.randint(1, max_time + 1, size=batch).astype(np.int32)\n    return (inputs, seq_len)",
            "def input_generater():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    inputs = np.random.rand(max_time, batch, alphabet_size).astype(np.float32)\n    seq_len = np.random.randint(1, max_time + 1, size=batch).astype(np.int32)\n    return (inputs, seq_len)",
            "def input_generater():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    inputs = np.random.rand(max_time, batch, alphabet_size).astype(np.float32)\n    seq_len = np.random.randint(1, max_time + 1, size=batch).astype(np.int32)\n    return (inputs, seq_len)"
        ]
    },
    {
        "func_name": "ref_ctc_decoder",
        "original": "def ref_ctc_decoder(inputs, seq_len):\n    output_len = np.zeros(batch * num_candidates, dtype=np.int32)\n    output_prob = np.zeros(batch * num_candidates, dtype=np.float32)\n    val = np.array([]).astype(np.int32)\n    for i in range(batch):\n        (Pb, Pnb) = (defaultdict(Counter), defaultdict(Counter))\n        Pb[0][()] = 1\n        Pnb[0][()] = 0\n        A_prev = [()]\n        ctc = inputs[:, i, :]\n        ctc = np.vstack((np.zeros(alphabet_size), ctc))\n        len_i = seq_len[i] if seq_len is not None else max_time\n        for t in range(1, len_i + 1):\n            pruned_alphabet = np.where(ctc[t] > DEFAULT_PRUNE_THRESHOLD)[0]\n            for l in A_prev:\n                for c in pruned_alphabet:\n                    if c == 0:\n                        Pb[t][l] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                    else:\n                        l_plus = l + (c,)\n                        if len(l) > 0 and c == l[-1]:\n                            Pnb[t][l_plus] += ctc[t][c] * Pb[t - 1][l]\n                            Pnb[t][l] += ctc[t][c] * Pnb[t - 1][l]\n                        else:\n                            Pnb[t][l_plus] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                        if l_plus not in A_prev:\n                            Pb[t][l_plus] += ctc[t][0] * (Pb[t - 1][l_plus] + Pnb[t - 1][l_plus])\n                            Pnb[t][l_plus] += ctc[t][c] * Pnb[t - 1][l_plus]\n            A_next = Pb[t] + Pnb[t]\n            A_prev = sorted(A_next, key=A_next.get, reverse=True)\n            A_prev = A_prev[:beam_width]\n        candidates = A_prev[:num_candidates]\n        index = 0\n        for candidate in candidates:\n            val = np.hstack((val, candidate))\n            output_len[i * num_candidates + index] = len(candidate)\n            output_prob[i * num_candidates + index] = Pb[t][candidate] + Pnb[t][candidate]\n            index += 1\n    return [output_len, val, output_prob]",
        "mutated": [
            "def ref_ctc_decoder(inputs, seq_len):\n    if False:\n        i = 10\n    output_len = np.zeros(batch * num_candidates, dtype=np.int32)\n    output_prob = np.zeros(batch * num_candidates, dtype=np.float32)\n    val = np.array([]).astype(np.int32)\n    for i in range(batch):\n        (Pb, Pnb) = (defaultdict(Counter), defaultdict(Counter))\n        Pb[0][()] = 1\n        Pnb[0][()] = 0\n        A_prev = [()]\n        ctc = inputs[:, i, :]\n        ctc = np.vstack((np.zeros(alphabet_size), ctc))\n        len_i = seq_len[i] if seq_len is not None else max_time\n        for t in range(1, len_i + 1):\n            pruned_alphabet = np.where(ctc[t] > DEFAULT_PRUNE_THRESHOLD)[0]\n            for l in A_prev:\n                for c in pruned_alphabet:\n                    if c == 0:\n                        Pb[t][l] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                    else:\n                        l_plus = l + (c,)\n                        if len(l) > 0 and c == l[-1]:\n                            Pnb[t][l_plus] += ctc[t][c] * Pb[t - 1][l]\n                            Pnb[t][l] += ctc[t][c] * Pnb[t - 1][l]\n                        else:\n                            Pnb[t][l_plus] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                        if l_plus not in A_prev:\n                            Pb[t][l_plus] += ctc[t][0] * (Pb[t - 1][l_plus] + Pnb[t - 1][l_plus])\n                            Pnb[t][l_plus] += ctc[t][c] * Pnb[t - 1][l_plus]\n            A_next = Pb[t] + Pnb[t]\n            A_prev = sorted(A_next, key=A_next.get, reverse=True)\n            A_prev = A_prev[:beam_width]\n        candidates = A_prev[:num_candidates]\n        index = 0\n        for candidate in candidates:\n            val = np.hstack((val, candidate))\n            output_len[i * num_candidates + index] = len(candidate)\n            output_prob[i * num_candidates + index] = Pb[t][candidate] + Pnb[t][candidate]\n            index += 1\n    return [output_len, val, output_prob]",
            "def ref_ctc_decoder(inputs, seq_len):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    output_len = np.zeros(batch * num_candidates, dtype=np.int32)\n    output_prob = np.zeros(batch * num_candidates, dtype=np.float32)\n    val = np.array([]).astype(np.int32)\n    for i in range(batch):\n        (Pb, Pnb) = (defaultdict(Counter), defaultdict(Counter))\n        Pb[0][()] = 1\n        Pnb[0][()] = 0\n        A_prev = [()]\n        ctc = inputs[:, i, :]\n        ctc = np.vstack((np.zeros(alphabet_size), ctc))\n        len_i = seq_len[i] if seq_len is not None else max_time\n        for t in range(1, len_i + 1):\n            pruned_alphabet = np.where(ctc[t] > DEFAULT_PRUNE_THRESHOLD)[0]\n            for l in A_prev:\n                for c in pruned_alphabet:\n                    if c == 0:\n                        Pb[t][l] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                    else:\n                        l_plus = l + (c,)\n                        if len(l) > 0 and c == l[-1]:\n                            Pnb[t][l_plus] += ctc[t][c] * Pb[t - 1][l]\n                            Pnb[t][l] += ctc[t][c] * Pnb[t - 1][l]\n                        else:\n                            Pnb[t][l_plus] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                        if l_plus not in A_prev:\n                            Pb[t][l_plus] += ctc[t][0] * (Pb[t - 1][l_plus] + Pnb[t - 1][l_plus])\n                            Pnb[t][l_plus] += ctc[t][c] * Pnb[t - 1][l_plus]\n            A_next = Pb[t] + Pnb[t]\n            A_prev = sorted(A_next, key=A_next.get, reverse=True)\n            A_prev = A_prev[:beam_width]\n        candidates = A_prev[:num_candidates]\n        index = 0\n        for candidate in candidates:\n            val = np.hstack((val, candidate))\n            output_len[i * num_candidates + index] = len(candidate)\n            output_prob[i * num_candidates + index] = Pb[t][candidate] + Pnb[t][candidate]\n            index += 1\n    return [output_len, val, output_prob]",
            "def ref_ctc_decoder(inputs, seq_len):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    output_len = np.zeros(batch * num_candidates, dtype=np.int32)\n    output_prob = np.zeros(batch * num_candidates, dtype=np.float32)\n    val = np.array([]).astype(np.int32)\n    for i in range(batch):\n        (Pb, Pnb) = (defaultdict(Counter), defaultdict(Counter))\n        Pb[0][()] = 1\n        Pnb[0][()] = 0\n        A_prev = [()]\n        ctc = inputs[:, i, :]\n        ctc = np.vstack((np.zeros(alphabet_size), ctc))\n        len_i = seq_len[i] if seq_len is not None else max_time\n        for t in range(1, len_i + 1):\n            pruned_alphabet = np.where(ctc[t] > DEFAULT_PRUNE_THRESHOLD)[0]\n            for l in A_prev:\n                for c in pruned_alphabet:\n                    if c == 0:\n                        Pb[t][l] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                    else:\n                        l_plus = l + (c,)\n                        if len(l) > 0 and c == l[-1]:\n                            Pnb[t][l_plus] += ctc[t][c] * Pb[t - 1][l]\n                            Pnb[t][l] += ctc[t][c] * Pnb[t - 1][l]\n                        else:\n                            Pnb[t][l_plus] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                        if l_plus not in A_prev:\n                            Pb[t][l_plus] += ctc[t][0] * (Pb[t - 1][l_plus] + Pnb[t - 1][l_plus])\n                            Pnb[t][l_plus] += ctc[t][c] * Pnb[t - 1][l_plus]\n            A_next = Pb[t] + Pnb[t]\n            A_prev = sorted(A_next, key=A_next.get, reverse=True)\n            A_prev = A_prev[:beam_width]\n        candidates = A_prev[:num_candidates]\n        index = 0\n        for candidate in candidates:\n            val = np.hstack((val, candidate))\n            output_len[i * num_candidates + index] = len(candidate)\n            output_prob[i * num_candidates + index] = Pb[t][candidate] + Pnb[t][candidate]\n            index += 1\n    return [output_len, val, output_prob]",
            "def ref_ctc_decoder(inputs, seq_len):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    output_len = np.zeros(batch * num_candidates, dtype=np.int32)\n    output_prob = np.zeros(batch * num_candidates, dtype=np.float32)\n    val = np.array([]).astype(np.int32)\n    for i in range(batch):\n        (Pb, Pnb) = (defaultdict(Counter), defaultdict(Counter))\n        Pb[0][()] = 1\n        Pnb[0][()] = 0\n        A_prev = [()]\n        ctc = inputs[:, i, :]\n        ctc = np.vstack((np.zeros(alphabet_size), ctc))\n        len_i = seq_len[i] if seq_len is not None else max_time\n        for t in range(1, len_i + 1):\n            pruned_alphabet = np.where(ctc[t] > DEFAULT_PRUNE_THRESHOLD)[0]\n            for l in A_prev:\n                for c in pruned_alphabet:\n                    if c == 0:\n                        Pb[t][l] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                    else:\n                        l_plus = l + (c,)\n                        if len(l) > 0 and c == l[-1]:\n                            Pnb[t][l_plus] += ctc[t][c] * Pb[t - 1][l]\n                            Pnb[t][l] += ctc[t][c] * Pnb[t - 1][l]\n                        else:\n                            Pnb[t][l_plus] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                        if l_plus not in A_prev:\n                            Pb[t][l_plus] += ctc[t][0] * (Pb[t - 1][l_plus] + Pnb[t - 1][l_plus])\n                            Pnb[t][l_plus] += ctc[t][c] * Pnb[t - 1][l_plus]\n            A_next = Pb[t] + Pnb[t]\n            A_prev = sorted(A_next, key=A_next.get, reverse=True)\n            A_prev = A_prev[:beam_width]\n        candidates = A_prev[:num_candidates]\n        index = 0\n        for candidate in candidates:\n            val = np.hstack((val, candidate))\n            output_len[i * num_candidates + index] = len(candidate)\n            output_prob[i * num_candidates + index] = Pb[t][candidate] + Pnb[t][candidate]\n            index += 1\n    return [output_len, val, output_prob]",
            "def ref_ctc_decoder(inputs, seq_len):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    output_len = np.zeros(batch * num_candidates, dtype=np.int32)\n    output_prob = np.zeros(batch * num_candidates, dtype=np.float32)\n    val = np.array([]).astype(np.int32)\n    for i in range(batch):\n        (Pb, Pnb) = (defaultdict(Counter), defaultdict(Counter))\n        Pb[0][()] = 1\n        Pnb[0][()] = 0\n        A_prev = [()]\n        ctc = inputs[:, i, :]\n        ctc = np.vstack((np.zeros(alphabet_size), ctc))\n        len_i = seq_len[i] if seq_len is not None else max_time\n        for t in range(1, len_i + 1):\n            pruned_alphabet = np.where(ctc[t] > DEFAULT_PRUNE_THRESHOLD)[0]\n            for l in A_prev:\n                for c in pruned_alphabet:\n                    if c == 0:\n                        Pb[t][l] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                    else:\n                        l_plus = l + (c,)\n                        if len(l) > 0 and c == l[-1]:\n                            Pnb[t][l_plus] += ctc[t][c] * Pb[t - 1][l]\n                            Pnb[t][l] += ctc[t][c] * Pnb[t - 1][l]\n                        else:\n                            Pnb[t][l_plus] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                        if l_plus not in A_prev:\n                            Pb[t][l_plus] += ctc[t][0] * (Pb[t - 1][l_plus] + Pnb[t - 1][l_plus])\n                            Pnb[t][l_plus] += ctc[t][c] * Pnb[t - 1][l_plus]\n            A_next = Pb[t] + Pnb[t]\n            A_prev = sorted(A_next, key=A_next.get, reverse=True)\n            A_prev = A_prev[:beam_width]\n        candidates = A_prev[:num_candidates]\n        index = 0\n        for candidate in candidates:\n            val = np.hstack((val, candidate))\n            output_len[i * num_candidates + index] = len(candidate)\n            output_prob[i * num_candidates + index] = Pb[t][candidate] + Pnb[t][candidate]\n            index += 1\n    return [output_len, val, output_prob]"
        ]
    },
    {
        "func_name": "ref_ctc_decoder_max_time",
        "original": "def ref_ctc_decoder_max_time(inputs):\n    return ref_ctc_decoder(inputs, None)",
        "mutated": [
            "def ref_ctc_decoder_max_time(inputs):\n    if False:\n        i = 10\n    return ref_ctc_decoder(inputs, None)",
            "def ref_ctc_decoder_max_time(inputs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return ref_ctc_decoder(inputs, None)",
            "def ref_ctc_decoder_max_time(inputs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return ref_ctc_decoder(inputs, None)",
            "def ref_ctc_decoder_max_time(inputs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return ref_ctc_decoder(inputs, None)",
            "def ref_ctc_decoder_max_time(inputs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return ref_ctc_decoder(inputs, None)"
        ]
    },
    {
        "func_name": "test_ctc_beam_search_decoder",
        "original": "@given(batch=st.sampled_from([1, 2, 4]), max_time=st.sampled_from([1, 8, 64]), alphabet_size=st.sampled_from([1, 2, 32, 128, 512]), beam_width=st.sampled_from([1, 2, 16, None]), num_candidates=st.sampled_from([1, 2]), **hu.gcs_cpu_only)\n@settings(deadline=None, max_examples=30)\ndef test_ctc_beam_search_decoder(self, batch, max_time, alphabet_size, beam_width, num_candidates, gc, dc):\n    if not beam_width:\n        beam_width = DEFAULT_BEAM_WIDTH\n        op_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS', 'SEQ_LEN'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], num_candidates=num_candidates)\n        op_no_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], num_candidates=num_candidates)\n    else:\n        num_candidates = min(num_candidates, beam_width)\n        op_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS', 'SEQ_LEN'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], beam_width=beam_width, num_candidates=num_candidates)\n        op_no_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], beam_width=beam_width, num_candidates=num_candidates)\n\n    def input_generater():\n        inputs = np.random.rand(max_time, batch, alphabet_size).astype(np.float32)\n        seq_len = np.random.randint(1, max_time + 1, size=batch).astype(np.int32)\n        return (inputs, seq_len)\n\n    def ref_ctc_decoder(inputs, seq_len):\n        output_len = np.zeros(batch * num_candidates, dtype=np.int32)\n        output_prob = np.zeros(batch * num_candidates, dtype=np.float32)\n        val = np.array([]).astype(np.int32)\n        for i in range(batch):\n            (Pb, Pnb) = (defaultdict(Counter), defaultdict(Counter))\n            Pb[0][()] = 1\n            Pnb[0][()] = 0\n            A_prev = [()]\n            ctc = inputs[:, i, :]\n            ctc = np.vstack((np.zeros(alphabet_size), ctc))\n            len_i = seq_len[i] if seq_len is not None else max_time\n            for t in range(1, len_i + 1):\n                pruned_alphabet = np.where(ctc[t] > DEFAULT_PRUNE_THRESHOLD)[0]\n                for l in A_prev:\n                    for c in pruned_alphabet:\n                        if c == 0:\n                            Pb[t][l] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                        else:\n                            l_plus = l + (c,)\n                            if len(l) > 0 and c == l[-1]:\n                                Pnb[t][l_plus] += ctc[t][c] * Pb[t - 1][l]\n                                Pnb[t][l] += ctc[t][c] * Pnb[t - 1][l]\n                            else:\n                                Pnb[t][l_plus] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                            if l_plus not in A_prev:\n                                Pb[t][l_plus] += ctc[t][0] * (Pb[t - 1][l_plus] + Pnb[t - 1][l_plus])\n                                Pnb[t][l_plus] += ctc[t][c] * Pnb[t - 1][l_plus]\n                A_next = Pb[t] + Pnb[t]\n                A_prev = sorted(A_next, key=A_next.get, reverse=True)\n                A_prev = A_prev[:beam_width]\n            candidates = A_prev[:num_candidates]\n            index = 0\n            for candidate in candidates:\n                val = np.hstack((val, candidate))\n                output_len[i * num_candidates + index] = len(candidate)\n                output_prob[i * num_candidates + index] = Pb[t][candidate] + Pnb[t][candidate]\n                index += 1\n        return [output_len, val, output_prob]\n\n    def ref_ctc_decoder_max_time(inputs):\n        return ref_ctc_decoder(inputs, None)\n    (inputs, seq_len) = input_generater()\n    self.assertReferenceChecks(device_option=gc, op=op_seq_len, inputs=[inputs, seq_len], reference=ref_ctc_decoder)\n    self.assertReferenceChecks(device_option=gc, op=op_no_seq_len, inputs=[inputs], reference=ref_ctc_decoder_max_time)",
        "mutated": [
            "@given(batch=st.sampled_from([1, 2, 4]), max_time=st.sampled_from([1, 8, 64]), alphabet_size=st.sampled_from([1, 2, 32, 128, 512]), beam_width=st.sampled_from([1, 2, 16, None]), num_candidates=st.sampled_from([1, 2]), **hu.gcs_cpu_only)\n@settings(deadline=None, max_examples=30)\ndef test_ctc_beam_search_decoder(self, batch, max_time, alphabet_size, beam_width, num_candidates, gc, dc):\n    if False:\n        i = 10\n    if not beam_width:\n        beam_width = DEFAULT_BEAM_WIDTH\n        op_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS', 'SEQ_LEN'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], num_candidates=num_candidates)\n        op_no_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], num_candidates=num_candidates)\n    else:\n        num_candidates = min(num_candidates, beam_width)\n        op_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS', 'SEQ_LEN'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], beam_width=beam_width, num_candidates=num_candidates)\n        op_no_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], beam_width=beam_width, num_candidates=num_candidates)\n\n    def input_generater():\n        inputs = np.random.rand(max_time, batch, alphabet_size).astype(np.float32)\n        seq_len = np.random.randint(1, max_time + 1, size=batch).astype(np.int32)\n        return (inputs, seq_len)\n\n    def ref_ctc_decoder(inputs, seq_len):\n        output_len = np.zeros(batch * num_candidates, dtype=np.int32)\n        output_prob = np.zeros(batch * num_candidates, dtype=np.float32)\n        val = np.array([]).astype(np.int32)\n        for i in range(batch):\n            (Pb, Pnb) = (defaultdict(Counter), defaultdict(Counter))\n            Pb[0][()] = 1\n            Pnb[0][()] = 0\n            A_prev = [()]\n            ctc = inputs[:, i, :]\n            ctc = np.vstack((np.zeros(alphabet_size), ctc))\n            len_i = seq_len[i] if seq_len is not None else max_time\n            for t in range(1, len_i + 1):\n                pruned_alphabet = np.where(ctc[t] > DEFAULT_PRUNE_THRESHOLD)[0]\n                for l in A_prev:\n                    for c in pruned_alphabet:\n                        if c == 0:\n                            Pb[t][l] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                        else:\n                            l_plus = l + (c,)\n                            if len(l) > 0 and c == l[-1]:\n                                Pnb[t][l_plus] += ctc[t][c] * Pb[t - 1][l]\n                                Pnb[t][l] += ctc[t][c] * Pnb[t - 1][l]\n                            else:\n                                Pnb[t][l_plus] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                            if l_plus not in A_prev:\n                                Pb[t][l_plus] += ctc[t][0] * (Pb[t - 1][l_plus] + Pnb[t - 1][l_plus])\n                                Pnb[t][l_plus] += ctc[t][c] * Pnb[t - 1][l_plus]\n                A_next = Pb[t] + Pnb[t]\n                A_prev = sorted(A_next, key=A_next.get, reverse=True)\n                A_prev = A_prev[:beam_width]\n            candidates = A_prev[:num_candidates]\n            index = 0\n            for candidate in candidates:\n                val = np.hstack((val, candidate))\n                output_len[i * num_candidates + index] = len(candidate)\n                output_prob[i * num_candidates + index] = Pb[t][candidate] + Pnb[t][candidate]\n                index += 1\n        return [output_len, val, output_prob]\n\n    def ref_ctc_decoder_max_time(inputs):\n        return ref_ctc_decoder(inputs, None)\n    (inputs, seq_len) = input_generater()\n    self.assertReferenceChecks(device_option=gc, op=op_seq_len, inputs=[inputs, seq_len], reference=ref_ctc_decoder)\n    self.assertReferenceChecks(device_option=gc, op=op_no_seq_len, inputs=[inputs], reference=ref_ctc_decoder_max_time)",
            "@given(batch=st.sampled_from([1, 2, 4]), max_time=st.sampled_from([1, 8, 64]), alphabet_size=st.sampled_from([1, 2, 32, 128, 512]), beam_width=st.sampled_from([1, 2, 16, None]), num_candidates=st.sampled_from([1, 2]), **hu.gcs_cpu_only)\n@settings(deadline=None, max_examples=30)\ndef test_ctc_beam_search_decoder(self, batch, max_time, alphabet_size, beam_width, num_candidates, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not beam_width:\n        beam_width = DEFAULT_BEAM_WIDTH\n        op_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS', 'SEQ_LEN'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], num_candidates=num_candidates)\n        op_no_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], num_candidates=num_candidates)\n    else:\n        num_candidates = min(num_candidates, beam_width)\n        op_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS', 'SEQ_LEN'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], beam_width=beam_width, num_candidates=num_candidates)\n        op_no_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], beam_width=beam_width, num_candidates=num_candidates)\n\n    def input_generater():\n        inputs = np.random.rand(max_time, batch, alphabet_size).astype(np.float32)\n        seq_len = np.random.randint(1, max_time + 1, size=batch).astype(np.int32)\n        return (inputs, seq_len)\n\n    def ref_ctc_decoder(inputs, seq_len):\n        output_len = np.zeros(batch * num_candidates, dtype=np.int32)\n        output_prob = np.zeros(batch * num_candidates, dtype=np.float32)\n        val = np.array([]).astype(np.int32)\n        for i in range(batch):\n            (Pb, Pnb) = (defaultdict(Counter), defaultdict(Counter))\n            Pb[0][()] = 1\n            Pnb[0][()] = 0\n            A_prev = [()]\n            ctc = inputs[:, i, :]\n            ctc = np.vstack((np.zeros(alphabet_size), ctc))\n            len_i = seq_len[i] if seq_len is not None else max_time\n            for t in range(1, len_i + 1):\n                pruned_alphabet = np.where(ctc[t] > DEFAULT_PRUNE_THRESHOLD)[0]\n                for l in A_prev:\n                    for c in pruned_alphabet:\n                        if c == 0:\n                            Pb[t][l] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                        else:\n                            l_plus = l + (c,)\n                            if len(l) > 0 and c == l[-1]:\n                                Pnb[t][l_plus] += ctc[t][c] * Pb[t - 1][l]\n                                Pnb[t][l] += ctc[t][c] * Pnb[t - 1][l]\n                            else:\n                                Pnb[t][l_plus] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                            if l_plus not in A_prev:\n                                Pb[t][l_plus] += ctc[t][0] * (Pb[t - 1][l_plus] + Pnb[t - 1][l_plus])\n                                Pnb[t][l_plus] += ctc[t][c] * Pnb[t - 1][l_plus]\n                A_next = Pb[t] + Pnb[t]\n                A_prev = sorted(A_next, key=A_next.get, reverse=True)\n                A_prev = A_prev[:beam_width]\n            candidates = A_prev[:num_candidates]\n            index = 0\n            for candidate in candidates:\n                val = np.hstack((val, candidate))\n                output_len[i * num_candidates + index] = len(candidate)\n                output_prob[i * num_candidates + index] = Pb[t][candidate] + Pnb[t][candidate]\n                index += 1\n        return [output_len, val, output_prob]\n\n    def ref_ctc_decoder_max_time(inputs):\n        return ref_ctc_decoder(inputs, None)\n    (inputs, seq_len) = input_generater()\n    self.assertReferenceChecks(device_option=gc, op=op_seq_len, inputs=[inputs, seq_len], reference=ref_ctc_decoder)\n    self.assertReferenceChecks(device_option=gc, op=op_no_seq_len, inputs=[inputs], reference=ref_ctc_decoder_max_time)",
            "@given(batch=st.sampled_from([1, 2, 4]), max_time=st.sampled_from([1, 8, 64]), alphabet_size=st.sampled_from([1, 2, 32, 128, 512]), beam_width=st.sampled_from([1, 2, 16, None]), num_candidates=st.sampled_from([1, 2]), **hu.gcs_cpu_only)\n@settings(deadline=None, max_examples=30)\ndef test_ctc_beam_search_decoder(self, batch, max_time, alphabet_size, beam_width, num_candidates, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not beam_width:\n        beam_width = DEFAULT_BEAM_WIDTH\n        op_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS', 'SEQ_LEN'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], num_candidates=num_candidates)\n        op_no_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], num_candidates=num_candidates)\n    else:\n        num_candidates = min(num_candidates, beam_width)\n        op_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS', 'SEQ_LEN'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], beam_width=beam_width, num_candidates=num_candidates)\n        op_no_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], beam_width=beam_width, num_candidates=num_candidates)\n\n    def input_generater():\n        inputs = np.random.rand(max_time, batch, alphabet_size).astype(np.float32)\n        seq_len = np.random.randint(1, max_time + 1, size=batch).astype(np.int32)\n        return (inputs, seq_len)\n\n    def ref_ctc_decoder(inputs, seq_len):\n        output_len = np.zeros(batch * num_candidates, dtype=np.int32)\n        output_prob = np.zeros(batch * num_candidates, dtype=np.float32)\n        val = np.array([]).astype(np.int32)\n        for i in range(batch):\n            (Pb, Pnb) = (defaultdict(Counter), defaultdict(Counter))\n            Pb[0][()] = 1\n            Pnb[0][()] = 0\n            A_prev = [()]\n            ctc = inputs[:, i, :]\n            ctc = np.vstack((np.zeros(alphabet_size), ctc))\n            len_i = seq_len[i] if seq_len is not None else max_time\n            for t in range(1, len_i + 1):\n                pruned_alphabet = np.where(ctc[t] > DEFAULT_PRUNE_THRESHOLD)[0]\n                for l in A_prev:\n                    for c in pruned_alphabet:\n                        if c == 0:\n                            Pb[t][l] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                        else:\n                            l_plus = l + (c,)\n                            if len(l) > 0 and c == l[-1]:\n                                Pnb[t][l_plus] += ctc[t][c] * Pb[t - 1][l]\n                                Pnb[t][l] += ctc[t][c] * Pnb[t - 1][l]\n                            else:\n                                Pnb[t][l_plus] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                            if l_plus not in A_prev:\n                                Pb[t][l_plus] += ctc[t][0] * (Pb[t - 1][l_plus] + Pnb[t - 1][l_plus])\n                                Pnb[t][l_plus] += ctc[t][c] * Pnb[t - 1][l_plus]\n                A_next = Pb[t] + Pnb[t]\n                A_prev = sorted(A_next, key=A_next.get, reverse=True)\n                A_prev = A_prev[:beam_width]\n            candidates = A_prev[:num_candidates]\n            index = 0\n            for candidate in candidates:\n                val = np.hstack((val, candidate))\n                output_len[i * num_candidates + index] = len(candidate)\n                output_prob[i * num_candidates + index] = Pb[t][candidate] + Pnb[t][candidate]\n                index += 1\n        return [output_len, val, output_prob]\n\n    def ref_ctc_decoder_max_time(inputs):\n        return ref_ctc_decoder(inputs, None)\n    (inputs, seq_len) = input_generater()\n    self.assertReferenceChecks(device_option=gc, op=op_seq_len, inputs=[inputs, seq_len], reference=ref_ctc_decoder)\n    self.assertReferenceChecks(device_option=gc, op=op_no_seq_len, inputs=[inputs], reference=ref_ctc_decoder_max_time)",
            "@given(batch=st.sampled_from([1, 2, 4]), max_time=st.sampled_from([1, 8, 64]), alphabet_size=st.sampled_from([1, 2, 32, 128, 512]), beam_width=st.sampled_from([1, 2, 16, None]), num_candidates=st.sampled_from([1, 2]), **hu.gcs_cpu_only)\n@settings(deadline=None, max_examples=30)\ndef test_ctc_beam_search_decoder(self, batch, max_time, alphabet_size, beam_width, num_candidates, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not beam_width:\n        beam_width = DEFAULT_BEAM_WIDTH\n        op_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS', 'SEQ_LEN'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], num_candidates=num_candidates)\n        op_no_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], num_candidates=num_candidates)\n    else:\n        num_candidates = min(num_candidates, beam_width)\n        op_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS', 'SEQ_LEN'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], beam_width=beam_width, num_candidates=num_candidates)\n        op_no_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], beam_width=beam_width, num_candidates=num_candidates)\n\n    def input_generater():\n        inputs = np.random.rand(max_time, batch, alphabet_size).astype(np.float32)\n        seq_len = np.random.randint(1, max_time + 1, size=batch).astype(np.int32)\n        return (inputs, seq_len)\n\n    def ref_ctc_decoder(inputs, seq_len):\n        output_len = np.zeros(batch * num_candidates, dtype=np.int32)\n        output_prob = np.zeros(batch * num_candidates, dtype=np.float32)\n        val = np.array([]).astype(np.int32)\n        for i in range(batch):\n            (Pb, Pnb) = (defaultdict(Counter), defaultdict(Counter))\n            Pb[0][()] = 1\n            Pnb[0][()] = 0\n            A_prev = [()]\n            ctc = inputs[:, i, :]\n            ctc = np.vstack((np.zeros(alphabet_size), ctc))\n            len_i = seq_len[i] if seq_len is not None else max_time\n            for t in range(1, len_i + 1):\n                pruned_alphabet = np.where(ctc[t] > DEFAULT_PRUNE_THRESHOLD)[0]\n                for l in A_prev:\n                    for c in pruned_alphabet:\n                        if c == 0:\n                            Pb[t][l] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                        else:\n                            l_plus = l + (c,)\n                            if len(l) > 0 and c == l[-1]:\n                                Pnb[t][l_plus] += ctc[t][c] * Pb[t - 1][l]\n                                Pnb[t][l] += ctc[t][c] * Pnb[t - 1][l]\n                            else:\n                                Pnb[t][l_plus] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                            if l_plus not in A_prev:\n                                Pb[t][l_plus] += ctc[t][0] * (Pb[t - 1][l_plus] + Pnb[t - 1][l_plus])\n                                Pnb[t][l_plus] += ctc[t][c] * Pnb[t - 1][l_plus]\n                A_next = Pb[t] + Pnb[t]\n                A_prev = sorted(A_next, key=A_next.get, reverse=True)\n                A_prev = A_prev[:beam_width]\n            candidates = A_prev[:num_candidates]\n            index = 0\n            for candidate in candidates:\n                val = np.hstack((val, candidate))\n                output_len[i * num_candidates + index] = len(candidate)\n                output_prob[i * num_candidates + index] = Pb[t][candidate] + Pnb[t][candidate]\n                index += 1\n        return [output_len, val, output_prob]\n\n    def ref_ctc_decoder_max_time(inputs):\n        return ref_ctc_decoder(inputs, None)\n    (inputs, seq_len) = input_generater()\n    self.assertReferenceChecks(device_option=gc, op=op_seq_len, inputs=[inputs, seq_len], reference=ref_ctc_decoder)\n    self.assertReferenceChecks(device_option=gc, op=op_no_seq_len, inputs=[inputs], reference=ref_ctc_decoder_max_time)",
            "@given(batch=st.sampled_from([1, 2, 4]), max_time=st.sampled_from([1, 8, 64]), alphabet_size=st.sampled_from([1, 2, 32, 128, 512]), beam_width=st.sampled_from([1, 2, 16, None]), num_candidates=st.sampled_from([1, 2]), **hu.gcs_cpu_only)\n@settings(deadline=None, max_examples=30)\ndef test_ctc_beam_search_decoder(self, batch, max_time, alphabet_size, beam_width, num_candidates, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not beam_width:\n        beam_width = DEFAULT_BEAM_WIDTH\n        op_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS', 'SEQ_LEN'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], num_candidates=num_candidates)\n        op_no_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], num_candidates=num_candidates)\n    else:\n        num_candidates = min(num_candidates, beam_width)\n        op_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS', 'SEQ_LEN'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], beam_width=beam_width, num_candidates=num_candidates)\n        op_no_seq_len = core.CreateOperator('CTCBeamSearchDecoder', ['INPUTS'], ['OUTPUT_LEN', 'VALUES', 'OUTPUT_PROB'], beam_width=beam_width, num_candidates=num_candidates)\n\n    def input_generater():\n        inputs = np.random.rand(max_time, batch, alphabet_size).astype(np.float32)\n        seq_len = np.random.randint(1, max_time + 1, size=batch).astype(np.int32)\n        return (inputs, seq_len)\n\n    def ref_ctc_decoder(inputs, seq_len):\n        output_len = np.zeros(batch * num_candidates, dtype=np.int32)\n        output_prob = np.zeros(batch * num_candidates, dtype=np.float32)\n        val = np.array([]).astype(np.int32)\n        for i in range(batch):\n            (Pb, Pnb) = (defaultdict(Counter), defaultdict(Counter))\n            Pb[0][()] = 1\n            Pnb[0][()] = 0\n            A_prev = [()]\n            ctc = inputs[:, i, :]\n            ctc = np.vstack((np.zeros(alphabet_size), ctc))\n            len_i = seq_len[i] if seq_len is not None else max_time\n            for t in range(1, len_i + 1):\n                pruned_alphabet = np.where(ctc[t] > DEFAULT_PRUNE_THRESHOLD)[0]\n                for l in A_prev:\n                    for c in pruned_alphabet:\n                        if c == 0:\n                            Pb[t][l] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                        else:\n                            l_plus = l + (c,)\n                            if len(l) > 0 and c == l[-1]:\n                                Pnb[t][l_plus] += ctc[t][c] * Pb[t - 1][l]\n                                Pnb[t][l] += ctc[t][c] * Pnb[t - 1][l]\n                            else:\n                                Pnb[t][l_plus] += ctc[t][c] * (Pb[t - 1][l] + Pnb[t - 1][l])\n                            if l_plus not in A_prev:\n                                Pb[t][l_plus] += ctc[t][0] * (Pb[t - 1][l_plus] + Pnb[t - 1][l_plus])\n                                Pnb[t][l_plus] += ctc[t][c] * Pnb[t - 1][l_plus]\n                A_next = Pb[t] + Pnb[t]\n                A_prev = sorted(A_next, key=A_next.get, reverse=True)\n                A_prev = A_prev[:beam_width]\n            candidates = A_prev[:num_candidates]\n            index = 0\n            for candidate in candidates:\n                val = np.hstack((val, candidate))\n                output_len[i * num_candidates + index] = len(candidate)\n                output_prob[i * num_candidates + index] = Pb[t][candidate] + Pnb[t][candidate]\n                index += 1\n        return [output_len, val, output_prob]\n\n    def ref_ctc_decoder_max_time(inputs):\n        return ref_ctc_decoder(inputs, None)\n    (inputs, seq_len) = input_generater()\n    self.assertReferenceChecks(device_option=gc, op=op_seq_len, inputs=[inputs, seq_len], reference=ref_ctc_decoder)\n    self.assertReferenceChecks(device_option=gc, op=op_no_seq_len, inputs=[inputs], reference=ref_ctc_decoder_max_time)"
        ]
    }
]