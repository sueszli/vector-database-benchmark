[
    {
        "func_name": "CountWordErrors",
        "original": "def CountWordErrors(ocr_text, truth_text):\n    \"\"\"Counts the word drop and add errors as a bag of words.\n\n  Args:\n    ocr_text:    OCR text string.\n    truth_text:  Truth text string.\n\n  Returns:\n    ErrorCounts named tuple.\n  \"\"\"\n    return CountErrors(ocr_text.split(), truth_text.split())",
        "mutated": [
            "def CountWordErrors(ocr_text, truth_text):\n    if False:\n        i = 10\n    'Counts the word drop and add errors as a bag of words.\\n\\n  Args:\\n    ocr_text:    OCR text string.\\n    truth_text:  Truth text string.\\n\\n  Returns:\\n    ErrorCounts named tuple.\\n  '\n    return CountErrors(ocr_text.split(), truth_text.split())",
            "def CountWordErrors(ocr_text, truth_text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Counts the word drop and add errors as a bag of words.\\n\\n  Args:\\n    ocr_text:    OCR text string.\\n    truth_text:  Truth text string.\\n\\n  Returns:\\n    ErrorCounts named tuple.\\n  '\n    return CountErrors(ocr_text.split(), truth_text.split())",
            "def CountWordErrors(ocr_text, truth_text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Counts the word drop and add errors as a bag of words.\\n\\n  Args:\\n    ocr_text:    OCR text string.\\n    truth_text:  Truth text string.\\n\\n  Returns:\\n    ErrorCounts named tuple.\\n  '\n    return CountErrors(ocr_text.split(), truth_text.split())",
            "def CountWordErrors(ocr_text, truth_text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Counts the word drop and add errors as a bag of words.\\n\\n  Args:\\n    ocr_text:    OCR text string.\\n    truth_text:  Truth text string.\\n\\n  Returns:\\n    ErrorCounts named tuple.\\n  '\n    return CountErrors(ocr_text.split(), truth_text.split())",
            "def CountWordErrors(ocr_text, truth_text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Counts the word drop and add errors as a bag of words.\\n\\n  Args:\\n    ocr_text:    OCR text string.\\n    truth_text:  Truth text string.\\n\\n  Returns:\\n    ErrorCounts named tuple.\\n  '\n    return CountErrors(ocr_text.split(), truth_text.split())"
        ]
    },
    {
        "func_name": "CountErrors",
        "original": "def CountErrors(ocr_text, truth_text):\n    \"\"\"Counts the drops and adds between 2 bags of iterables.\n\n  Simple bag of objects count returns the number of dropped and added\n  elements, regardless of order, from anything that is iterable, eg\n  a pair of strings gives character errors, and a pair of word lists give\n  word errors.\n  Args:\n    ocr_text:    OCR text iterable (eg string for chars, word list for words).\n    truth_text:  Truth text iterable.\n\n  Returns:\n    ErrorCounts named tuple.\n  \"\"\"\n    counts = collections.Counter(truth_text)\n    counts.subtract(ocr_text)\n    drops = sum((c for c in counts.values() if c > 0))\n    adds = sum((-c for c in counts.values() if c < 0))\n    return ErrorCounts(drops, adds, len(truth_text), len(ocr_text))",
        "mutated": [
            "def CountErrors(ocr_text, truth_text):\n    if False:\n        i = 10\n    'Counts the drops and adds between 2 bags of iterables.\\n\\n  Simple bag of objects count returns the number of dropped and added\\n  elements, regardless of order, from anything that is iterable, eg\\n  a pair of strings gives character errors, and a pair of word lists give\\n  word errors.\\n  Args:\\n    ocr_text:    OCR text iterable (eg string for chars, word list for words).\\n    truth_text:  Truth text iterable.\\n\\n  Returns:\\n    ErrorCounts named tuple.\\n  '\n    counts = collections.Counter(truth_text)\n    counts.subtract(ocr_text)\n    drops = sum((c for c in counts.values() if c > 0))\n    adds = sum((-c for c in counts.values() if c < 0))\n    return ErrorCounts(drops, adds, len(truth_text), len(ocr_text))",
            "def CountErrors(ocr_text, truth_text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Counts the drops and adds between 2 bags of iterables.\\n\\n  Simple bag of objects count returns the number of dropped and added\\n  elements, regardless of order, from anything that is iterable, eg\\n  a pair of strings gives character errors, and a pair of word lists give\\n  word errors.\\n  Args:\\n    ocr_text:    OCR text iterable (eg string for chars, word list for words).\\n    truth_text:  Truth text iterable.\\n\\n  Returns:\\n    ErrorCounts named tuple.\\n  '\n    counts = collections.Counter(truth_text)\n    counts.subtract(ocr_text)\n    drops = sum((c for c in counts.values() if c > 0))\n    adds = sum((-c for c in counts.values() if c < 0))\n    return ErrorCounts(drops, adds, len(truth_text), len(ocr_text))",
            "def CountErrors(ocr_text, truth_text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Counts the drops and adds between 2 bags of iterables.\\n\\n  Simple bag of objects count returns the number of dropped and added\\n  elements, regardless of order, from anything that is iterable, eg\\n  a pair of strings gives character errors, and a pair of word lists give\\n  word errors.\\n  Args:\\n    ocr_text:    OCR text iterable (eg string for chars, word list for words).\\n    truth_text:  Truth text iterable.\\n\\n  Returns:\\n    ErrorCounts named tuple.\\n  '\n    counts = collections.Counter(truth_text)\n    counts.subtract(ocr_text)\n    drops = sum((c for c in counts.values() if c > 0))\n    adds = sum((-c for c in counts.values() if c < 0))\n    return ErrorCounts(drops, adds, len(truth_text), len(ocr_text))",
            "def CountErrors(ocr_text, truth_text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Counts the drops and adds between 2 bags of iterables.\\n\\n  Simple bag of objects count returns the number of dropped and added\\n  elements, regardless of order, from anything that is iterable, eg\\n  a pair of strings gives character errors, and a pair of word lists give\\n  word errors.\\n  Args:\\n    ocr_text:    OCR text iterable (eg string for chars, word list for words).\\n    truth_text:  Truth text iterable.\\n\\n  Returns:\\n    ErrorCounts named tuple.\\n  '\n    counts = collections.Counter(truth_text)\n    counts.subtract(ocr_text)\n    drops = sum((c for c in counts.values() if c > 0))\n    adds = sum((-c for c in counts.values() if c < 0))\n    return ErrorCounts(drops, adds, len(truth_text), len(ocr_text))",
            "def CountErrors(ocr_text, truth_text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Counts the drops and adds between 2 bags of iterables.\\n\\n  Simple bag of objects count returns the number of dropped and added\\n  elements, regardless of order, from anything that is iterable, eg\\n  a pair of strings gives character errors, and a pair of word lists give\\n  word errors.\\n  Args:\\n    ocr_text:    OCR text iterable (eg string for chars, word list for words).\\n    truth_text:  Truth text iterable.\\n\\n  Returns:\\n    ErrorCounts named tuple.\\n  '\n    counts = collections.Counter(truth_text)\n    counts.subtract(ocr_text)\n    drops = sum((c for c in counts.values() if c > 0))\n    adds = sum((-c for c in counts.values() if c < 0))\n    return ErrorCounts(drops, adds, len(truth_text), len(ocr_text))"
        ]
    },
    {
        "func_name": "AddErrors",
        "original": "def AddErrors(counts1, counts2):\n    \"\"\"Adds the counts and returns a new sum tuple.\n\n  Args:\n    counts1: ErrorCounts named tuples to sum.\n    counts2: ErrorCounts named tuples to sum.\n  Returns:\n    Sum of counts1, counts2.\n  \"\"\"\n    return ErrorCounts(counts1.fn + counts2.fn, counts1.fp + counts2.fp, counts1.truth_count + counts2.truth_count, counts1.test_count + counts2.test_count)",
        "mutated": [
            "def AddErrors(counts1, counts2):\n    if False:\n        i = 10\n    'Adds the counts and returns a new sum tuple.\\n\\n  Args:\\n    counts1: ErrorCounts named tuples to sum.\\n    counts2: ErrorCounts named tuples to sum.\\n  Returns:\\n    Sum of counts1, counts2.\\n  '\n    return ErrorCounts(counts1.fn + counts2.fn, counts1.fp + counts2.fp, counts1.truth_count + counts2.truth_count, counts1.test_count + counts2.test_count)",
            "def AddErrors(counts1, counts2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Adds the counts and returns a new sum tuple.\\n\\n  Args:\\n    counts1: ErrorCounts named tuples to sum.\\n    counts2: ErrorCounts named tuples to sum.\\n  Returns:\\n    Sum of counts1, counts2.\\n  '\n    return ErrorCounts(counts1.fn + counts2.fn, counts1.fp + counts2.fp, counts1.truth_count + counts2.truth_count, counts1.test_count + counts2.test_count)",
            "def AddErrors(counts1, counts2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Adds the counts and returns a new sum tuple.\\n\\n  Args:\\n    counts1: ErrorCounts named tuples to sum.\\n    counts2: ErrorCounts named tuples to sum.\\n  Returns:\\n    Sum of counts1, counts2.\\n  '\n    return ErrorCounts(counts1.fn + counts2.fn, counts1.fp + counts2.fp, counts1.truth_count + counts2.truth_count, counts1.test_count + counts2.test_count)",
            "def AddErrors(counts1, counts2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Adds the counts and returns a new sum tuple.\\n\\n  Args:\\n    counts1: ErrorCounts named tuples to sum.\\n    counts2: ErrorCounts named tuples to sum.\\n  Returns:\\n    Sum of counts1, counts2.\\n  '\n    return ErrorCounts(counts1.fn + counts2.fn, counts1.fp + counts2.fp, counts1.truth_count + counts2.truth_count, counts1.test_count + counts2.test_count)",
            "def AddErrors(counts1, counts2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Adds the counts and returns a new sum tuple.\\n\\n  Args:\\n    counts1: ErrorCounts named tuples to sum.\\n    counts2: ErrorCounts named tuples to sum.\\n  Returns:\\n    Sum of counts1, counts2.\\n  '\n    return ErrorCounts(counts1.fn + counts2.fn, counts1.fp + counts2.fp, counts1.truth_count + counts2.truth_count, counts1.test_count + counts2.test_count)"
        ]
    },
    {
        "func_name": "ComputeErrorRates",
        "original": "def ComputeErrorRates(label_counts, word_counts, seq_errors, num_seqs):\n    \"\"\"Returns an ErrorRates corresponding to the given counts.\n\n  Args:\n    label_counts: ErrorCounts for the character labels\n    word_counts:  ErrorCounts for the words\n    seq_errors:   Number of sequence errors\n    num_seqs:     Total sequences\n  Returns:\n    ErrorRates corresponding to the given counts.\n  \"\"\"\n    label_errors = label_counts.fn + label_counts.fp\n    num_labels = label_counts.truth_count + label_counts.test_count\n    return ErrorRates(ComputeErrorRate(label_errors, num_labels), ComputeErrorRate(word_counts.fn, word_counts.truth_count), ComputeErrorRate(word_counts.fp, word_counts.test_count), ComputeErrorRate(seq_errors, num_seqs))",
        "mutated": [
            "def ComputeErrorRates(label_counts, word_counts, seq_errors, num_seqs):\n    if False:\n        i = 10\n    'Returns an ErrorRates corresponding to the given counts.\\n\\n  Args:\\n    label_counts: ErrorCounts for the character labels\\n    word_counts:  ErrorCounts for the words\\n    seq_errors:   Number of sequence errors\\n    num_seqs:     Total sequences\\n  Returns:\\n    ErrorRates corresponding to the given counts.\\n  '\n    label_errors = label_counts.fn + label_counts.fp\n    num_labels = label_counts.truth_count + label_counts.test_count\n    return ErrorRates(ComputeErrorRate(label_errors, num_labels), ComputeErrorRate(word_counts.fn, word_counts.truth_count), ComputeErrorRate(word_counts.fp, word_counts.test_count), ComputeErrorRate(seq_errors, num_seqs))",
            "def ComputeErrorRates(label_counts, word_counts, seq_errors, num_seqs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns an ErrorRates corresponding to the given counts.\\n\\n  Args:\\n    label_counts: ErrorCounts for the character labels\\n    word_counts:  ErrorCounts for the words\\n    seq_errors:   Number of sequence errors\\n    num_seqs:     Total sequences\\n  Returns:\\n    ErrorRates corresponding to the given counts.\\n  '\n    label_errors = label_counts.fn + label_counts.fp\n    num_labels = label_counts.truth_count + label_counts.test_count\n    return ErrorRates(ComputeErrorRate(label_errors, num_labels), ComputeErrorRate(word_counts.fn, word_counts.truth_count), ComputeErrorRate(word_counts.fp, word_counts.test_count), ComputeErrorRate(seq_errors, num_seqs))",
            "def ComputeErrorRates(label_counts, word_counts, seq_errors, num_seqs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns an ErrorRates corresponding to the given counts.\\n\\n  Args:\\n    label_counts: ErrorCounts for the character labels\\n    word_counts:  ErrorCounts for the words\\n    seq_errors:   Number of sequence errors\\n    num_seqs:     Total sequences\\n  Returns:\\n    ErrorRates corresponding to the given counts.\\n  '\n    label_errors = label_counts.fn + label_counts.fp\n    num_labels = label_counts.truth_count + label_counts.test_count\n    return ErrorRates(ComputeErrorRate(label_errors, num_labels), ComputeErrorRate(word_counts.fn, word_counts.truth_count), ComputeErrorRate(word_counts.fp, word_counts.test_count), ComputeErrorRate(seq_errors, num_seqs))",
            "def ComputeErrorRates(label_counts, word_counts, seq_errors, num_seqs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns an ErrorRates corresponding to the given counts.\\n\\n  Args:\\n    label_counts: ErrorCounts for the character labels\\n    word_counts:  ErrorCounts for the words\\n    seq_errors:   Number of sequence errors\\n    num_seqs:     Total sequences\\n  Returns:\\n    ErrorRates corresponding to the given counts.\\n  '\n    label_errors = label_counts.fn + label_counts.fp\n    num_labels = label_counts.truth_count + label_counts.test_count\n    return ErrorRates(ComputeErrorRate(label_errors, num_labels), ComputeErrorRate(word_counts.fn, word_counts.truth_count), ComputeErrorRate(word_counts.fp, word_counts.test_count), ComputeErrorRate(seq_errors, num_seqs))",
            "def ComputeErrorRates(label_counts, word_counts, seq_errors, num_seqs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns an ErrorRates corresponding to the given counts.\\n\\n  Args:\\n    label_counts: ErrorCounts for the character labels\\n    word_counts:  ErrorCounts for the words\\n    seq_errors:   Number of sequence errors\\n    num_seqs:     Total sequences\\n  Returns:\\n    ErrorRates corresponding to the given counts.\\n  '\n    label_errors = label_counts.fn + label_counts.fp\n    num_labels = label_counts.truth_count + label_counts.test_count\n    return ErrorRates(ComputeErrorRate(label_errors, num_labels), ComputeErrorRate(word_counts.fn, word_counts.truth_count), ComputeErrorRate(word_counts.fp, word_counts.test_count), ComputeErrorRate(seq_errors, num_seqs))"
        ]
    },
    {
        "func_name": "ComputeErrorRate",
        "original": "def ComputeErrorRate(error_count, truth_count):\n    \"\"\"Returns a sanitized percent error rate from the raw counts.\n\n  Prevents div by 0 and clips return to 100%.\n  Args:\n    error_count: Number of errors.\n    truth_count: Number to divide by.\n\n  Returns:\n    100.0 * error_count / truth_count clipped to 100.\n  \"\"\"\n    if truth_count == 0:\n        truth_count = 1\n        error_count = 1\n    elif error_count > truth_count:\n        error_count = truth_count\n    return error_count * 100.0 / truth_count",
        "mutated": [
            "def ComputeErrorRate(error_count, truth_count):\n    if False:\n        i = 10\n    'Returns a sanitized percent error rate from the raw counts.\\n\\n  Prevents div by 0 and clips return to 100%.\\n  Args:\\n    error_count: Number of errors.\\n    truth_count: Number to divide by.\\n\\n  Returns:\\n    100.0 * error_count / truth_count clipped to 100.\\n  '\n    if truth_count == 0:\n        truth_count = 1\n        error_count = 1\n    elif error_count > truth_count:\n        error_count = truth_count\n    return error_count * 100.0 / truth_count",
            "def ComputeErrorRate(error_count, truth_count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a sanitized percent error rate from the raw counts.\\n\\n  Prevents div by 0 and clips return to 100%.\\n  Args:\\n    error_count: Number of errors.\\n    truth_count: Number to divide by.\\n\\n  Returns:\\n    100.0 * error_count / truth_count clipped to 100.\\n  '\n    if truth_count == 0:\n        truth_count = 1\n        error_count = 1\n    elif error_count > truth_count:\n        error_count = truth_count\n    return error_count * 100.0 / truth_count",
            "def ComputeErrorRate(error_count, truth_count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a sanitized percent error rate from the raw counts.\\n\\n  Prevents div by 0 and clips return to 100%.\\n  Args:\\n    error_count: Number of errors.\\n    truth_count: Number to divide by.\\n\\n  Returns:\\n    100.0 * error_count / truth_count clipped to 100.\\n  '\n    if truth_count == 0:\n        truth_count = 1\n        error_count = 1\n    elif error_count > truth_count:\n        error_count = truth_count\n    return error_count * 100.0 / truth_count",
            "def ComputeErrorRate(error_count, truth_count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a sanitized percent error rate from the raw counts.\\n\\n  Prevents div by 0 and clips return to 100%.\\n  Args:\\n    error_count: Number of errors.\\n    truth_count: Number to divide by.\\n\\n  Returns:\\n    100.0 * error_count / truth_count clipped to 100.\\n  '\n    if truth_count == 0:\n        truth_count = 1\n        error_count = 1\n    elif error_count > truth_count:\n        error_count = truth_count\n    return error_count * 100.0 / truth_count",
            "def ComputeErrorRate(error_count, truth_count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a sanitized percent error rate from the raw counts.\\n\\n  Prevents div by 0 and clips return to 100%.\\n  Args:\\n    error_count: Number of errors.\\n    truth_count: Number to divide by.\\n\\n  Returns:\\n    100.0 * error_count / truth_count clipped to 100.\\n  '\n    if truth_count == 0:\n        truth_count = 1\n        error_count = 1\n    elif error_count > truth_count:\n        error_count = truth_count\n    return error_count * 100.0 / truth_count"
        ]
    }
]