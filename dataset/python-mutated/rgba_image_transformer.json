[
    {
        "func_name": "_construct_smask_stream",
        "original": "@staticmethod\ndef _construct_smask_stream(image: PILImage.Image) -> Stream:\n    w: int = image.width\n    h: int = image.height\n    smask_bytes: bytes = bytes([a for (r, g, b, a) in image.getdata()])\n    smask_compressed_bytes = zlib.compress(smask_bytes)\n    out: Stream = Stream()\n    out[Name('BitsPerComponent')] = bDecimal(8)\n    out[Name('Bytes')] = smask_compressed_bytes\n    out[Name('ColorSpace')] = Name('DeviceGray')\n    out[Name('Filter')] = Name('FlateDecode')\n    out[Name('Height')] = bDecimal(h)\n    out[Name('Length')] = bDecimal(len(smask_compressed_bytes))\n    out[Name('Subtype')] = Name('Image')\n    out[Name('Type')] = Name('XObject')\n    out[Name('Width')] = bDecimal(w)\n    return out",
        "mutated": [
            "@staticmethod\ndef _construct_smask_stream(image: PILImage.Image) -> Stream:\n    if False:\n        i = 10\n    w: int = image.width\n    h: int = image.height\n    smask_bytes: bytes = bytes([a for (r, g, b, a) in image.getdata()])\n    smask_compressed_bytes = zlib.compress(smask_bytes)\n    out: Stream = Stream()\n    out[Name('BitsPerComponent')] = bDecimal(8)\n    out[Name('Bytes')] = smask_compressed_bytes\n    out[Name('ColorSpace')] = Name('DeviceGray')\n    out[Name('Filter')] = Name('FlateDecode')\n    out[Name('Height')] = bDecimal(h)\n    out[Name('Length')] = bDecimal(len(smask_compressed_bytes))\n    out[Name('Subtype')] = Name('Image')\n    out[Name('Type')] = Name('XObject')\n    out[Name('Width')] = bDecimal(w)\n    return out",
            "@staticmethod\ndef _construct_smask_stream(image: PILImage.Image) -> Stream:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    w: int = image.width\n    h: int = image.height\n    smask_bytes: bytes = bytes([a for (r, g, b, a) in image.getdata()])\n    smask_compressed_bytes = zlib.compress(smask_bytes)\n    out: Stream = Stream()\n    out[Name('BitsPerComponent')] = bDecimal(8)\n    out[Name('Bytes')] = smask_compressed_bytes\n    out[Name('ColorSpace')] = Name('DeviceGray')\n    out[Name('Filter')] = Name('FlateDecode')\n    out[Name('Height')] = bDecimal(h)\n    out[Name('Length')] = bDecimal(len(smask_compressed_bytes))\n    out[Name('Subtype')] = Name('Image')\n    out[Name('Type')] = Name('XObject')\n    out[Name('Width')] = bDecimal(w)\n    return out",
            "@staticmethod\ndef _construct_smask_stream(image: PILImage.Image) -> Stream:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    w: int = image.width\n    h: int = image.height\n    smask_bytes: bytes = bytes([a for (r, g, b, a) in image.getdata()])\n    smask_compressed_bytes = zlib.compress(smask_bytes)\n    out: Stream = Stream()\n    out[Name('BitsPerComponent')] = bDecimal(8)\n    out[Name('Bytes')] = smask_compressed_bytes\n    out[Name('ColorSpace')] = Name('DeviceGray')\n    out[Name('Filter')] = Name('FlateDecode')\n    out[Name('Height')] = bDecimal(h)\n    out[Name('Length')] = bDecimal(len(smask_compressed_bytes))\n    out[Name('Subtype')] = Name('Image')\n    out[Name('Type')] = Name('XObject')\n    out[Name('Width')] = bDecimal(w)\n    return out",
            "@staticmethod\ndef _construct_smask_stream(image: PILImage.Image) -> Stream:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    w: int = image.width\n    h: int = image.height\n    smask_bytes: bytes = bytes([a for (r, g, b, a) in image.getdata()])\n    smask_compressed_bytes = zlib.compress(smask_bytes)\n    out: Stream = Stream()\n    out[Name('BitsPerComponent')] = bDecimal(8)\n    out[Name('Bytes')] = smask_compressed_bytes\n    out[Name('ColorSpace')] = Name('DeviceGray')\n    out[Name('Filter')] = Name('FlateDecode')\n    out[Name('Height')] = bDecimal(h)\n    out[Name('Length')] = bDecimal(len(smask_compressed_bytes))\n    out[Name('Subtype')] = Name('Image')\n    out[Name('Type')] = Name('XObject')\n    out[Name('Width')] = bDecimal(w)\n    return out",
            "@staticmethod\ndef _construct_smask_stream(image: PILImage.Image) -> Stream:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    w: int = image.width\n    h: int = image.height\n    smask_bytes: bytes = bytes([a for (r, g, b, a) in image.getdata()])\n    smask_compressed_bytes = zlib.compress(smask_bytes)\n    out: Stream = Stream()\n    out[Name('BitsPerComponent')] = bDecimal(8)\n    out[Name('Bytes')] = smask_compressed_bytes\n    out[Name('ColorSpace')] = Name('DeviceGray')\n    out[Name('Filter')] = Name('FlateDecode')\n    out[Name('Height')] = bDecimal(h)\n    out[Name('Length')] = bDecimal(len(smask_compressed_bytes))\n    out[Name('Subtype')] = Name('Image')\n    out[Name('Type')] = Name('XObject')\n    out[Name('Width')] = bDecimal(w)\n    return out"
        ]
    },
    {
        "func_name": "_rgb_array",
        "original": "@staticmethod\ndef _rgb_array(image: PILImage.Image) -> bytes:\n    s0 = [(r, g, b) for (r, g, b, a) in image.getdata()]\n    s1 = [x for x in itertools.chain(*s0)]\n    return bytes(s1)",
        "mutated": [
            "@staticmethod\ndef _rgb_array(image: PILImage.Image) -> bytes:\n    if False:\n        i = 10\n    s0 = [(r, g, b) for (r, g, b, a) in image.getdata()]\n    s1 = [x for x in itertools.chain(*s0)]\n    return bytes(s1)",
            "@staticmethod\ndef _rgb_array(image: PILImage.Image) -> bytes:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s0 = [(r, g, b) for (r, g, b, a) in image.getdata()]\n    s1 = [x for x in itertools.chain(*s0)]\n    return bytes(s1)",
            "@staticmethod\ndef _rgb_array(image: PILImage.Image) -> bytes:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s0 = [(r, g, b) for (r, g, b, a) in image.getdata()]\n    s1 = [x for x in itertools.chain(*s0)]\n    return bytes(s1)",
            "@staticmethod\ndef _rgb_array(image: PILImage.Image) -> bytes:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s0 = [(r, g, b) for (r, g, b, a) in image.getdata()]\n    s1 = [x for x in itertools.chain(*s0)]\n    return bytes(s1)",
            "@staticmethod\ndef _rgb_array(image: PILImage.Image) -> bytes:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s0 = [(r, g, b) for (r, g, b, a) in image.getdata()]\n    s1 = [x for x in itertools.chain(*s0)]\n    return bytes(s1)"
        ]
    },
    {
        "func_name": "can_be_transformed",
        "original": "def can_be_transformed(self, any: AnyPDFType):\n    \"\"\"\n        This function returns True if the object to be converted represents an Image object\n        \"\"\"\n    return isinstance(any, PILImage.Image) and any.mode == 'RGBA'",
        "mutated": [
            "def can_be_transformed(self, any: AnyPDFType):\n    if False:\n        i = 10\n    '\\n        This function returns True if the object to be converted represents an Image object\\n        '\n    return isinstance(any, PILImage.Image) and any.mode == 'RGBA'",
            "def can_be_transformed(self, any: AnyPDFType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        This function returns True if the object to be converted represents an Image object\\n        '\n    return isinstance(any, PILImage.Image) and any.mode == 'RGBA'",
            "def can_be_transformed(self, any: AnyPDFType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        This function returns True if the object to be converted represents an Image object\\n        '\n    return isinstance(any, PILImage.Image) and any.mode == 'RGBA'",
            "def can_be_transformed(self, any: AnyPDFType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        This function returns True if the object to be converted represents an Image object\\n        '\n    return isinstance(any, PILImage.Image) and any.mode == 'RGBA'",
            "def can_be_transformed(self, any: AnyPDFType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        This function returns True if the object to be converted represents an Image object\\n        '\n    return isinstance(any, PILImage.Image) and any.mode == 'RGBA'"
        ]
    },
    {
        "func_name": "transform",
        "original": "def transform(self, object_to_transform: AnyPDFType, context: typing.Optional[WriteTransformerState]=None):\n    \"\"\"\n        This method writes an Image to a byte stream\n        \"\"\"\n    assert context is not None, 'context must be defined in order to write Image objects.'\n    assert context.destination is not None, 'context.destination must be defined in order to write Image objects.'\n    assert isinstance(object_to_transform, PILImage.Image), 'object_to_transform must be of type PILImage.Image'\n    smask_img: Stream = RGBAImageTransformer._construct_smask_stream(object_to_transform)\n    smask_img.set_is_inline(False)\n    smask_img.set_is_unique(True)\n    self.get_reference(smask_img, context)\n    self._start_object(smask_img, context)\n    self.get_root_transformer().transform(smask_img, context)\n    self._end_object(smask_img, context)\n    rgb_bytes: bytes = RGBAImageTransformer._rgb_array(object_to_transform)\n    out_value = Stream()\n    out_value[Name('BitsPerComponent')] = bDecimal(8)\n    out_value[Name('Bytes')] = zlib.compress(rgb_bytes)\n    out_value[Name('ColorSpace')] = Name('DeviceRGB')\n    out_value[Name('Filter')] = Name('FlateDecode')\n    out_value[Name('Height')] = bDecimal(object_to_transform.height)\n    out_value[Name('Length')] = bDecimal(len(out_value[Name('Bytes')]))\n    out_value[Name('SMask')] = smask_img\n    out_value[Name('Subtype')] = Name('Image')\n    out_value[Name('Type')] = Name('XObject')\n    out_value[Name('Width')] = bDecimal(object_to_transform.width)\n    out_value.set_reference(object_to_transform.get_reference())\n    started_object = False\n    ref = out_value.get_reference()\n    if ref is not None:\n        assert isinstance(ref, Reference)\n        if ref.object_number is not None and ref.byte_offset is None:\n            started_object = True\n            self._start_object(out_value, context)\n    cl = context.compression_level\n    context.compression_level = 9\n    self.get_root_transformer().transform(out_value, context)\n    context.compression_level = cl\n    if started_object:\n        self._end_object(out_value, context)",
        "mutated": [
            "def transform(self, object_to_transform: AnyPDFType, context: typing.Optional[WriteTransformerState]=None):\n    if False:\n        i = 10\n    '\\n        This method writes an Image to a byte stream\\n        '\n    assert context is not None, 'context must be defined in order to write Image objects.'\n    assert context.destination is not None, 'context.destination must be defined in order to write Image objects.'\n    assert isinstance(object_to_transform, PILImage.Image), 'object_to_transform must be of type PILImage.Image'\n    smask_img: Stream = RGBAImageTransformer._construct_smask_stream(object_to_transform)\n    smask_img.set_is_inline(False)\n    smask_img.set_is_unique(True)\n    self.get_reference(smask_img, context)\n    self._start_object(smask_img, context)\n    self.get_root_transformer().transform(smask_img, context)\n    self._end_object(smask_img, context)\n    rgb_bytes: bytes = RGBAImageTransformer._rgb_array(object_to_transform)\n    out_value = Stream()\n    out_value[Name('BitsPerComponent')] = bDecimal(8)\n    out_value[Name('Bytes')] = zlib.compress(rgb_bytes)\n    out_value[Name('ColorSpace')] = Name('DeviceRGB')\n    out_value[Name('Filter')] = Name('FlateDecode')\n    out_value[Name('Height')] = bDecimal(object_to_transform.height)\n    out_value[Name('Length')] = bDecimal(len(out_value[Name('Bytes')]))\n    out_value[Name('SMask')] = smask_img\n    out_value[Name('Subtype')] = Name('Image')\n    out_value[Name('Type')] = Name('XObject')\n    out_value[Name('Width')] = bDecimal(object_to_transform.width)\n    out_value.set_reference(object_to_transform.get_reference())\n    started_object = False\n    ref = out_value.get_reference()\n    if ref is not None:\n        assert isinstance(ref, Reference)\n        if ref.object_number is not None and ref.byte_offset is None:\n            started_object = True\n            self._start_object(out_value, context)\n    cl = context.compression_level\n    context.compression_level = 9\n    self.get_root_transformer().transform(out_value, context)\n    context.compression_level = cl\n    if started_object:\n        self._end_object(out_value, context)",
            "def transform(self, object_to_transform: AnyPDFType, context: typing.Optional[WriteTransformerState]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        This method writes an Image to a byte stream\\n        '\n    assert context is not None, 'context must be defined in order to write Image objects.'\n    assert context.destination is not None, 'context.destination must be defined in order to write Image objects.'\n    assert isinstance(object_to_transform, PILImage.Image), 'object_to_transform must be of type PILImage.Image'\n    smask_img: Stream = RGBAImageTransformer._construct_smask_stream(object_to_transform)\n    smask_img.set_is_inline(False)\n    smask_img.set_is_unique(True)\n    self.get_reference(smask_img, context)\n    self._start_object(smask_img, context)\n    self.get_root_transformer().transform(smask_img, context)\n    self._end_object(smask_img, context)\n    rgb_bytes: bytes = RGBAImageTransformer._rgb_array(object_to_transform)\n    out_value = Stream()\n    out_value[Name('BitsPerComponent')] = bDecimal(8)\n    out_value[Name('Bytes')] = zlib.compress(rgb_bytes)\n    out_value[Name('ColorSpace')] = Name('DeviceRGB')\n    out_value[Name('Filter')] = Name('FlateDecode')\n    out_value[Name('Height')] = bDecimal(object_to_transform.height)\n    out_value[Name('Length')] = bDecimal(len(out_value[Name('Bytes')]))\n    out_value[Name('SMask')] = smask_img\n    out_value[Name('Subtype')] = Name('Image')\n    out_value[Name('Type')] = Name('XObject')\n    out_value[Name('Width')] = bDecimal(object_to_transform.width)\n    out_value.set_reference(object_to_transform.get_reference())\n    started_object = False\n    ref = out_value.get_reference()\n    if ref is not None:\n        assert isinstance(ref, Reference)\n        if ref.object_number is not None and ref.byte_offset is None:\n            started_object = True\n            self._start_object(out_value, context)\n    cl = context.compression_level\n    context.compression_level = 9\n    self.get_root_transformer().transform(out_value, context)\n    context.compression_level = cl\n    if started_object:\n        self._end_object(out_value, context)",
            "def transform(self, object_to_transform: AnyPDFType, context: typing.Optional[WriteTransformerState]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        This method writes an Image to a byte stream\\n        '\n    assert context is not None, 'context must be defined in order to write Image objects.'\n    assert context.destination is not None, 'context.destination must be defined in order to write Image objects.'\n    assert isinstance(object_to_transform, PILImage.Image), 'object_to_transform must be of type PILImage.Image'\n    smask_img: Stream = RGBAImageTransformer._construct_smask_stream(object_to_transform)\n    smask_img.set_is_inline(False)\n    smask_img.set_is_unique(True)\n    self.get_reference(smask_img, context)\n    self._start_object(smask_img, context)\n    self.get_root_transformer().transform(smask_img, context)\n    self._end_object(smask_img, context)\n    rgb_bytes: bytes = RGBAImageTransformer._rgb_array(object_to_transform)\n    out_value = Stream()\n    out_value[Name('BitsPerComponent')] = bDecimal(8)\n    out_value[Name('Bytes')] = zlib.compress(rgb_bytes)\n    out_value[Name('ColorSpace')] = Name('DeviceRGB')\n    out_value[Name('Filter')] = Name('FlateDecode')\n    out_value[Name('Height')] = bDecimal(object_to_transform.height)\n    out_value[Name('Length')] = bDecimal(len(out_value[Name('Bytes')]))\n    out_value[Name('SMask')] = smask_img\n    out_value[Name('Subtype')] = Name('Image')\n    out_value[Name('Type')] = Name('XObject')\n    out_value[Name('Width')] = bDecimal(object_to_transform.width)\n    out_value.set_reference(object_to_transform.get_reference())\n    started_object = False\n    ref = out_value.get_reference()\n    if ref is not None:\n        assert isinstance(ref, Reference)\n        if ref.object_number is not None and ref.byte_offset is None:\n            started_object = True\n            self._start_object(out_value, context)\n    cl = context.compression_level\n    context.compression_level = 9\n    self.get_root_transformer().transform(out_value, context)\n    context.compression_level = cl\n    if started_object:\n        self._end_object(out_value, context)",
            "def transform(self, object_to_transform: AnyPDFType, context: typing.Optional[WriteTransformerState]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        This method writes an Image to a byte stream\\n        '\n    assert context is not None, 'context must be defined in order to write Image objects.'\n    assert context.destination is not None, 'context.destination must be defined in order to write Image objects.'\n    assert isinstance(object_to_transform, PILImage.Image), 'object_to_transform must be of type PILImage.Image'\n    smask_img: Stream = RGBAImageTransformer._construct_smask_stream(object_to_transform)\n    smask_img.set_is_inline(False)\n    smask_img.set_is_unique(True)\n    self.get_reference(smask_img, context)\n    self._start_object(smask_img, context)\n    self.get_root_transformer().transform(smask_img, context)\n    self._end_object(smask_img, context)\n    rgb_bytes: bytes = RGBAImageTransformer._rgb_array(object_to_transform)\n    out_value = Stream()\n    out_value[Name('BitsPerComponent')] = bDecimal(8)\n    out_value[Name('Bytes')] = zlib.compress(rgb_bytes)\n    out_value[Name('ColorSpace')] = Name('DeviceRGB')\n    out_value[Name('Filter')] = Name('FlateDecode')\n    out_value[Name('Height')] = bDecimal(object_to_transform.height)\n    out_value[Name('Length')] = bDecimal(len(out_value[Name('Bytes')]))\n    out_value[Name('SMask')] = smask_img\n    out_value[Name('Subtype')] = Name('Image')\n    out_value[Name('Type')] = Name('XObject')\n    out_value[Name('Width')] = bDecimal(object_to_transform.width)\n    out_value.set_reference(object_to_transform.get_reference())\n    started_object = False\n    ref = out_value.get_reference()\n    if ref is not None:\n        assert isinstance(ref, Reference)\n        if ref.object_number is not None and ref.byte_offset is None:\n            started_object = True\n            self._start_object(out_value, context)\n    cl = context.compression_level\n    context.compression_level = 9\n    self.get_root_transformer().transform(out_value, context)\n    context.compression_level = cl\n    if started_object:\n        self._end_object(out_value, context)",
            "def transform(self, object_to_transform: AnyPDFType, context: typing.Optional[WriteTransformerState]=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        This method writes an Image to a byte stream\\n        '\n    assert context is not None, 'context must be defined in order to write Image objects.'\n    assert context.destination is not None, 'context.destination must be defined in order to write Image objects.'\n    assert isinstance(object_to_transform, PILImage.Image), 'object_to_transform must be of type PILImage.Image'\n    smask_img: Stream = RGBAImageTransformer._construct_smask_stream(object_to_transform)\n    smask_img.set_is_inline(False)\n    smask_img.set_is_unique(True)\n    self.get_reference(smask_img, context)\n    self._start_object(smask_img, context)\n    self.get_root_transformer().transform(smask_img, context)\n    self._end_object(smask_img, context)\n    rgb_bytes: bytes = RGBAImageTransformer._rgb_array(object_to_transform)\n    out_value = Stream()\n    out_value[Name('BitsPerComponent')] = bDecimal(8)\n    out_value[Name('Bytes')] = zlib.compress(rgb_bytes)\n    out_value[Name('ColorSpace')] = Name('DeviceRGB')\n    out_value[Name('Filter')] = Name('FlateDecode')\n    out_value[Name('Height')] = bDecimal(object_to_transform.height)\n    out_value[Name('Length')] = bDecimal(len(out_value[Name('Bytes')]))\n    out_value[Name('SMask')] = smask_img\n    out_value[Name('Subtype')] = Name('Image')\n    out_value[Name('Type')] = Name('XObject')\n    out_value[Name('Width')] = bDecimal(object_to_transform.width)\n    out_value.set_reference(object_to_transform.get_reference())\n    started_object = False\n    ref = out_value.get_reference()\n    if ref is not None:\n        assert isinstance(ref, Reference)\n        if ref.object_number is not None and ref.byte_offset is None:\n            started_object = True\n            self._start_object(out_value, context)\n    cl = context.compression_level\n    context.compression_level = 9\n    self.get_root_transformer().transform(out_value, context)\n    context.compression_level = cl\n    if started_object:\n        self._end_object(out_value, context)"
        ]
    }
]