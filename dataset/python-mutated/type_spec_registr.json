[
    {
        "func_name": "decorator_fn",
        "original": "def decorator_fn(cls):\n    if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n        raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n    if cls in _TYPE_SPEC_TO_NAME:\n        raise ValueError('Class %s.%s has already been registered with name %s.' % (cls.__module__, cls.__name__, _TYPE_SPEC_TO_NAME[cls]))\n    if name in _NAME_TO_TYPE_SPEC:\n        raise ValueError('Name %s has already been registered for class %s.%s.' % (name, _NAME_TO_TYPE_SPEC[name].__module__, _NAME_TO_TYPE_SPEC[name].__name__))\n    _TYPE_SPEC_TO_NAME[cls] = name\n    _NAME_TO_TYPE_SPEC[name] = cls\n    return cls",
        "mutated": [
            "def decorator_fn(cls):\n    if False:\n        i = 10\n    if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n        raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n    if cls in _TYPE_SPEC_TO_NAME:\n        raise ValueError('Class %s.%s has already been registered with name %s.' % (cls.__module__, cls.__name__, _TYPE_SPEC_TO_NAME[cls]))\n    if name in _NAME_TO_TYPE_SPEC:\n        raise ValueError('Name %s has already been registered for class %s.%s.' % (name, _NAME_TO_TYPE_SPEC[name].__module__, _NAME_TO_TYPE_SPEC[name].__name__))\n    _TYPE_SPEC_TO_NAME[cls] = name\n    _NAME_TO_TYPE_SPEC[name] = cls\n    return cls",
            "def decorator_fn(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n        raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n    if cls in _TYPE_SPEC_TO_NAME:\n        raise ValueError('Class %s.%s has already been registered with name %s.' % (cls.__module__, cls.__name__, _TYPE_SPEC_TO_NAME[cls]))\n    if name in _NAME_TO_TYPE_SPEC:\n        raise ValueError('Name %s has already been registered for class %s.%s.' % (name, _NAME_TO_TYPE_SPEC[name].__module__, _NAME_TO_TYPE_SPEC[name].__name__))\n    _TYPE_SPEC_TO_NAME[cls] = name\n    _NAME_TO_TYPE_SPEC[name] = cls\n    return cls",
            "def decorator_fn(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n        raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n    if cls in _TYPE_SPEC_TO_NAME:\n        raise ValueError('Class %s.%s has already been registered with name %s.' % (cls.__module__, cls.__name__, _TYPE_SPEC_TO_NAME[cls]))\n    if name in _NAME_TO_TYPE_SPEC:\n        raise ValueError('Name %s has already been registered for class %s.%s.' % (name, _NAME_TO_TYPE_SPEC[name].__module__, _NAME_TO_TYPE_SPEC[name].__name__))\n    _TYPE_SPEC_TO_NAME[cls] = name\n    _NAME_TO_TYPE_SPEC[name] = cls\n    return cls",
            "def decorator_fn(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n        raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n    if cls in _TYPE_SPEC_TO_NAME:\n        raise ValueError('Class %s.%s has already been registered with name %s.' % (cls.__module__, cls.__name__, _TYPE_SPEC_TO_NAME[cls]))\n    if name in _NAME_TO_TYPE_SPEC:\n        raise ValueError('Name %s has already been registered for class %s.%s.' % (name, _NAME_TO_TYPE_SPEC[name].__module__, _NAME_TO_TYPE_SPEC[name].__name__))\n    _TYPE_SPEC_TO_NAME[cls] = name\n    _NAME_TO_TYPE_SPEC[name] = cls\n    return cls",
            "def decorator_fn(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n        raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n    if cls in _TYPE_SPEC_TO_NAME:\n        raise ValueError('Class %s.%s has already been registered with name %s.' % (cls.__module__, cls.__name__, _TYPE_SPEC_TO_NAME[cls]))\n    if name in _NAME_TO_TYPE_SPEC:\n        raise ValueError('Name %s has already been registered for class %s.%s.' % (name, _NAME_TO_TYPE_SPEC[name].__module__, _NAME_TO_TYPE_SPEC[name].__name__))\n    _TYPE_SPEC_TO_NAME[cls] = name\n    _NAME_TO_TYPE_SPEC[name] = cls\n    return cls"
        ]
    },
    {
        "func_name": "register",
        "original": "def register(name):\n    \"\"\"Decorator used to register a globally unique name for a TypeSpec subclass.\n\n  Args:\n    name: The name of the type spec.  Must be globally unique.  Must have the\n      form `\"{project_name}.{type_name}\"`.  E.g. `\"my_project.MyTypeSpec\"`.\n\n  Returns:\n    A class decorator that registers the decorated class with the given name.\n  \"\"\"\n    if not isinstance(name, str):\n        raise TypeError('Expected `name` to be a string; got %r' % (name,))\n    if not _REGISTERED_NAME_RE.match(name):\n        raise ValueError(\"Registered name must have the form '{project_name}.{type_name}' (e.g. 'my_project.MyTypeSpec'); got %r.\" % name)\n\n    def decorator_fn(cls):\n        if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n            raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n        if cls in _TYPE_SPEC_TO_NAME:\n            raise ValueError('Class %s.%s has already been registered with name %s.' % (cls.__module__, cls.__name__, _TYPE_SPEC_TO_NAME[cls]))\n        if name in _NAME_TO_TYPE_SPEC:\n            raise ValueError('Name %s has already been registered for class %s.%s.' % (name, _NAME_TO_TYPE_SPEC[name].__module__, _NAME_TO_TYPE_SPEC[name].__name__))\n        _TYPE_SPEC_TO_NAME[cls] = name\n        _NAME_TO_TYPE_SPEC[name] = cls\n        return cls\n    return decorator_fn",
        "mutated": [
            "def register(name):\n    if False:\n        i = 10\n    'Decorator used to register a globally unique name for a TypeSpec subclass.\\n\\n  Args:\\n    name: The name of the type spec.  Must be globally unique.  Must have the\\n      form `\"{project_name}.{type_name}\"`.  E.g. `\"my_project.MyTypeSpec\"`.\\n\\n  Returns:\\n    A class decorator that registers the decorated class with the given name.\\n  '\n    if not isinstance(name, str):\n        raise TypeError('Expected `name` to be a string; got %r' % (name,))\n    if not _REGISTERED_NAME_RE.match(name):\n        raise ValueError(\"Registered name must have the form '{project_name}.{type_name}' (e.g. 'my_project.MyTypeSpec'); got %r.\" % name)\n\n    def decorator_fn(cls):\n        if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n            raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n        if cls in _TYPE_SPEC_TO_NAME:\n            raise ValueError('Class %s.%s has already been registered with name %s.' % (cls.__module__, cls.__name__, _TYPE_SPEC_TO_NAME[cls]))\n        if name in _NAME_TO_TYPE_SPEC:\n            raise ValueError('Name %s has already been registered for class %s.%s.' % (name, _NAME_TO_TYPE_SPEC[name].__module__, _NAME_TO_TYPE_SPEC[name].__name__))\n        _TYPE_SPEC_TO_NAME[cls] = name\n        _NAME_TO_TYPE_SPEC[name] = cls\n        return cls\n    return decorator_fn",
            "def register(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Decorator used to register a globally unique name for a TypeSpec subclass.\\n\\n  Args:\\n    name: The name of the type spec.  Must be globally unique.  Must have the\\n      form `\"{project_name}.{type_name}\"`.  E.g. `\"my_project.MyTypeSpec\"`.\\n\\n  Returns:\\n    A class decorator that registers the decorated class with the given name.\\n  '\n    if not isinstance(name, str):\n        raise TypeError('Expected `name` to be a string; got %r' % (name,))\n    if not _REGISTERED_NAME_RE.match(name):\n        raise ValueError(\"Registered name must have the form '{project_name}.{type_name}' (e.g. 'my_project.MyTypeSpec'); got %r.\" % name)\n\n    def decorator_fn(cls):\n        if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n            raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n        if cls in _TYPE_SPEC_TO_NAME:\n            raise ValueError('Class %s.%s has already been registered with name %s.' % (cls.__module__, cls.__name__, _TYPE_SPEC_TO_NAME[cls]))\n        if name in _NAME_TO_TYPE_SPEC:\n            raise ValueError('Name %s has already been registered for class %s.%s.' % (name, _NAME_TO_TYPE_SPEC[name].__module__, _NAME_TO_TYPE_SPEC[name].__name__))\n        _TYPE_SPEC_TO_NAME[cls] = name\n        _NAME_TO_TYPE_SPEC[name] = cls\n        return cls\n    return decorator_fn",
            "def register(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Decorator used to register a globally unique name for a TypeSpec subclass.\\n\\n  Args:\\n    name: The name of the type spec.  Must be globally unique.  Must have the\\n      form `\"{project_name}.{type_name}\"`.  E.g. `\"my_project.MyTypeSpec\"`.\\n\\n  Returns:\\n    A class decorator that registers the decorated class with the given name.\\n  '\n    if not isinstance(name, str):\n        raise TypeError('Expected `name` to be a string; got %r' % (name,))\n    if not _REGISTERED_NAME_RE.match(name):\n        raise ValueError(\"Registered name must have the form '{project_name}.{type_name}' (e.g. 'my_project.MyTypeSpec'); got %r.\" % name)\n\n    def decorator_fn(cls):\n        if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n            raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n        if cls in _TYPE_SPEC_TO_NAME:\n            raise ValueError('Class %s.%s has already been registered with name %s.' % (cls.__module__, cls.__name__, _TYPE_SPEC_TO_NAME[cls]))\n        if name in _NAME_TO_TYPE_SPEC:\n            raise ValueError('Name %s has already been registered for class %s.%s.' % (name, _NAME_TO_TYPE_SPEC[name].__module__, _NAME_TO_TYPE_SPEC[name].__name__))\n        _TYPE_SPEC_TO_NAME[cls] = name\n        _NAME_TO_TYPE_SPEC[name] = cls\n        return cls\n    return decorator_fn",
            "def register(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Decorator used to register a globally unique name for a TypeSpec subclass.\\n\\n  Args:\\n    name: The name of the type spec.  Must be globally unique.  Must have the\\n      form `\"{project_name}.{type_name}\"`.  E.g. `\"my_project.MyTypeSpec\"`.\\n\\n  Returns:\\n    A class decorator that registers the decorated class with the given name.\\n  '\n    if not isinstance(name, str):\n        raise TypeError('Expected `name` to be a string; got %r' % (name,))\n    if not _REGISTERED_NAME_RE.match(name):\n        raise ValueError(\"Registered name must have the form '{project_name}.{type_name}' (e.g. 'my_project.MyTypeSpec'); got %r.\" % name)\n\n    def decorator_fn(cls):\n        if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n            raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n        if cls in _TYPE_SPEC_TO_NAME:\n            raise ValueError('Class %s.%s has already been registered with name %s.' % (cls.__module__, cls.__name__, _TYPE_SPEC_TO_NAME[cls]))\n        if name in _NAME_TO_TYPE_SPEC:\n            raise ValueError('Name %s has already been registered for class %s.%s.' % (name, _NAME_TO_TYPE_SPEC[name].__module__, _NAME_TO_TYPE_SPEC[name].__name__))\n        _TYPE_SPEC_TO_NAME[cls] = name\n        _NAME_TO_TYPE_SPEC[name] = cls\n        return cls\n    return decorator_fn",
            "def register(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Decorator used to register a globally unique name for a TypeSpec subclass.\\n\\n  Args:\\n    name: The name of the type spec.  Must be globally unique.  Must have the\\n      form `\"{project_name}.{type_name}\"`.  E.g. `\"my_project.MyTypeSpec\"`.\\n\\n  Returns:\\n    A class decorator that registers the decorated class with the given name.\\n  '\n    if not isinstance(name, str):\n        raise TypeError('Expected `name` to be a string; got %r' % (name,))\n    if not _REGISTERED_NAME_RE.match(name):\n        raise ValueError(\"Registered name must have the form '{project_name}.{type_name}' (e.g. 'my_project.MyTypeSpec'); got %r.\" % name)\n\n    def decorator_fn(cls):\n        if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n            raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n        if cls in _TYPE_SPEC_TO_NAME:\n            raise ValueError('Class %s.%s has already been registered with name %s.' % (cls.__module__, cls.__name__, _TYPE_SPEC_TO_NAME[cls]))\n        if name in _NAME_TO_TYPE_SPEC:\n            raise ValueError('Name %s has already been registered for class %s.%s.' % (name, _NAME_TO_TYPE_SPEC[name].__module__, _NAME_TO_TYPE_SPEC[name].__name__))\n        _TYPE_SPEC_TO_NAME[cls] = name\n        _NAME_TO_TYPE_SPEC[name] = cls\n        return cls\n    return decorator_fn"
        ]
    },
    {
        "func_name": "get_name",
        "original": "def get_name(cls):\n    \"\"\"Returns the registered name for TypeSpec `cls`.\"\"\"\n    if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n        raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n    if cls not in _TYPE_SPEC_TO_NAME:\n        raise ValueError('TypeSpec %s.%s has not been registered.' % (cls.__module__, cls.__name__))\n    return _TYPE_SPEC_TO_NAME[cls]",
        "mutated": [
            "def get_name(cls):\n    if False:\n        i = 10\n    'Returns the registered name for TypeSpec `cls`.'\n    if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n        raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n    if cls not in _TYPE_SPEC_TO_NAME:\n        raise ValueError('TypeSpec %s.%s has not been registered.' % (cls.__module__, cls.__name__))\n    return _TYPE_SPEC_TO_NAME[cls]",
            "def get_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the registered name for TypeSpec `cls`.'\n    if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n        raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n    if cls not in _TYPE_SPEC_TO_NAME:\n        raise ValueError('TypeSpec %s.%s has not been registered.' % (cls.__module__, cls.__name__))\n    return _TYPE_SPEC_TO_NAME[cls]",
            "def get_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the registered name for TypeSpec `cls`.'\n    if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n        raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n    if cls not in _TYPE_SPEC_TO_NAME:\n        raise ValueError('TypeSpec %s.%s has not been registered.' % (cls.__module__, cls.__name__))\n    return _TYPE_SPEC_TO_NAME[cls]",
            "def get_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the registered name for TypeSpec `cls`.'\n    if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n        raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n    if cls not in _TYPE_SPEC_TO_NAME:\n        raise ValueError('TypeSpec %s.%s has not been registered.' % (cls.__module__, cls.__name__))\n    return _TYPE_SPEC_TO_NAME[cls]",
            "def get_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the registered name for TypeSpec `cls`.'\n    if not (isinstance(cls, type) and issubclass(cls, internal.TypeSpec)):\n        raise TypeError('Expected `cls` to be a TypeSpec; got %r' % (cls,))\n    if cls not in _TYPE_SPEC_TO_NAME:\n        raise ValueError('TypeSpec %s.%s has not been registered.' % (cls.__module__, cls.__name__))\n    return _TYPE_SPEC_TO_NAME[cls]"
        ]
    },
    {
        "func_name": "lookup",
        "original": "def lookup(name):\n    \"\"\"Returns the TypeSpec that has been registered with name `name`.\"\"\"\n    if not isinstance(name, str):\n        raise TypeError('Expected `name` to be a string; got %r' % (name,))\n    if name not in _NAME_TO_TYPE_SPEC:\n        raise ValueError('No TypeSpec has been registered with name %r' % (name,))\n    return _NAME_TO_TYPE_SPEC[name]",
        "mutated": [
            "def lookup(name):\n    if False:\n        i = 10\n    'Returns the TypeSpec that has been registered with name `name`.'\n    if not isinstance(name, str):\n        raise TypeError('Expected `name` to be a string; got %r' % (name,))\n    if name not in _NAME_TO_TYPE_SPEC:\n        raise ValueError('No TypeSpec has been registered with name %r' % (name,))\n    return _NAME_TO_TYPE_SPEC[name]",
            "def lookup(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the TypeSpec that has been registered with name `name`.'\n    if not isinstance(name, str):\n        raise TypeError('Expected `name` to be a string; got %r' % (name,))\n    if name not in _NAME_TO_TYPE_SPEC:\n        raise ValueError('No TypeSpec has been registered with name %r' % (name,))\n    return _NAME_TO_TYPE_SPEC[name]",
            "def lookup(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the TypeSpec that has been registered with name `name`.'\n    if not isinstance(name, str):\n        raise TypeError('Expected `name` to be a string; got %r' % (name,))\n    if name not in _NAME_TO_TYPE_SPEC:\n        raise ValueError('No TypeSpec has been registered with name %r' % (name,))\n    return _NAME_TO_TYPE_SPEC[name]",
            "def lookup(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the TypeSpec that has been registered with name `name`.'\n    if not isinstance(name, str):\n        raise TypeError('Expected `name` to be a string; got %r' % (name,))\n    if name not in _NAME_TO_TYPE_SPEC:\n        raise ValueError('No TypeSpec has been registered with name %r' % (name,))\n    return _NAME_TO_TYPE_SPEC[name]",
            "def lookup(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the TypeSpec that has been registered with name `name`.'\n    if not isinstance(name, str):\n        raise TypeError('Expected `name` to be a string; got %r' % (name,))\n    if name not in _NAME_TO_TYPE_SPEC:\n        raise ValueError('No TypeSpec has been registered with name %r' % (name,))\n    return _NAME_TO_TYPE_SPEC[name]"
        ]
    }
]