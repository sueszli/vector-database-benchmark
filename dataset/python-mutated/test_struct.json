[
    {
        "func_name": "test_single_field",
        "original": "@pytest.mark.notimpl(['dask', 'snowflake'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\ndef test_single_field(backend, struct, struct_df, field):\n    expr = struct.abc[field]\n    result = expr.execute().sort_values().reset_index(drop=True)\n    expected = struct_df.abc.map(lambda value: value[field] if isinstance(value, dict) else value).rename(field).sort_values().reset_index(drop=True)\n    backend.assert_series_equal(result, expected)",
        "mutated": [
            "@pytest.mark.notimpl(['dask', 'snowflake'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\ndef test_single_field(backend, struct, struct_df, field):\n    if False:\n        i = 10\n    expr = struct.abc[field]\n    result = expr.execute().sort_values().reset_index(drop=True)\n    expected = struct_df.abc.map(lambda value: value[field] if isinstance(value, dict) else value).rename(field).sort_values().reset_index(drop=True)\n    backend.assert_series_equal(result, expected)",
            "@pytest.mark.notimpl(['dask', 'snowflake'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\ndef test_single_field(backend, struct, struct_df, field):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    expr = struct.abc[field]\n    result = expr.execute().sort_values().reset_index(drop=True)\n    expected = struct_df.abc.map(lambda value: value[field] if isinstance(value, dict) else value).rename(field).sort_values().reset_index(drop=True)\n    backend.assert_series_equal(result, expected)",
            "@pytest.mark.notimpl(['dask', 'snowflake'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\ndef test_single_field(backend, struct, struct_df, field):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    expr = struct.abc[field]\n    result = expr.execute().sort_values().reset_index(drop=True)\n    expected = struct_df.abc.map(lambda value: value[field] if isinstance(value, dict) else value).rename(field).sort_values().reset_index(drop=True)\n    backend.assert_series_equal(result, expected)",
            "@pytest.mark.notimpl(['dask', 'snowflake'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\ndef test_single_field(backend, struct, struct_df, field):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    expr = struct.abc[field]\n    result = expr.execute().sort_values().reset_index(drop=True)\n    expected = struct_df.abc.map(lambda value: value[field] if isinstance(value, dict) else value).rename(field).sort_values().reset_index(drop=True)\n    backend.assert_series_equal(result, expected)",
            "@pytest.mark.notimpl(['dask', 'snowflake'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\ndef test_single_field(backend, struct, struct_df, field):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    expr = struct.abc[field]\n    result = expr.execute().sort_values().reset_index(drop=True)\n    expected = struct_df.abc.map(lambda value: value[field] if isinstance(value, dict) else value).rename(field).sort_values().reset_index(drop=True)\n    backend.assert_series_equal(result, expected)"
        ]
    },
    {
        "func_name": "test_all_fields",
        "original": "@pytest.mark.notimpl(['dask'])\ndef test_all_fields(struct, struct_df):\n    result = struct.abc.execute()\n    expected = struct_df.abc\n    assert {row if not isinstance(row, Mapping) else tuple(row.items()) for row in result} == {row if not isinstance(row, Mapping) else tuple(row.items()) for row in expected}",
        "mutated": [
            "@pytest.mark.notimpl(['dask'])\ndef test_all_fields(struct, struct_df):\n    if False:\n        i = 10\n    result = struct.abc.execute()\n    expected = struct_df.abc\n    assert {row if not isinstance(row, Mapping) else tuple(row.items()) for row in result} == {row if not isinstance(row, Mapping) else tuple(row.items()) for row in expected}",
            "@pytest.mark.notimpl(['dask'])\ndef test_all_fields(struct, struct_df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    result = struct.abc.execute()\n    expected = struct_df.abc\n    assert {row if not isinstance(row, Mapping) else tuple(row.items()) for row in result} == {row if not isinstance(row, Mapping) else tuple(row.items()) for row in expected}",
            "@pytest.mark.notimpl(['dask'])\ndef test_all_fields(struct, struct_df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    result = struct.abc.execute()\n    expected = struct_df.abc\n    assert {row if not isinstance(row, Mapping) else tuple(row.items()) for row in result} == {row if not isinstance(row, Mapping) else tuple(row.items()) for row in expected}",
            "@pytest.mark.notimpl(['dask'])\ndef test_all_fields(struct, struct_df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    result = struct.abc.execute()\n    expected = struct_df.abc\n    assert {row if not isinstance(row, Mapping) else tuple(row.items()) for row in result} == {row if not isinstance(row, Mapping) else tuple(row.items()) for row in expected}",
            "@pytest.mark.notimpl(['dask'])\ndef test_all_fields(struct, struct_df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    result = struct.abc.execute()\n    expected = struct_df.abc\n    assert {row if not isinstance(row, Mapping) else tuple(row.items()) for row in result} == {row if not isinstance(row, Mapping) else tuple(row.items()) for row in expected}"
        ]
    },
    {
        "func_name": "test_literal",
        "original": "@pytest.mark.notimpl(['postgres'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\ndef test_literal(con, field):\n    query = _STRUCT_LITERAL[field]\n    dtype = query.type().to_pandas()\n    result = pd.Series([con.execute(query)], dtype=dtype)\n    result = result.replace({np.nan: None})\n    expected = pd.Series([_SIMPLE_DICT[field]])\n    tm.assert_series_equal(result, expected.astype(dtype))",
        "mutated": [
            "@pytest.mark.notimpl(['postgres'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\ndef test_literal(con, field):\n    if False:\n        i = 10\n    query = _STRUCT_LITERAL[field]\n    dtype = query.type().to_pandas()\n    result = pd.Series([con.execute(query)], dtype=dtype)\n    result = result.replace({np.nan: None})\n    expected = pd.Series([_SIMPLE_DICT[field]])\n    tm.assert_series_equal(result, expected.astype(dtype))",
            "@pytest.mark.notimpl(['postgres'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\ndef test_literal(con, field):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    query = _STRUCT_LITERAL[field]\n    dtype = query.type().to_pandas()\n    result = pd.Series([con.execute(query)], dtype=dtype)\n    result = result.replace({np.nan: None})\n    expected = pd.Series([_SIMPLE_DICT[field]])\n    tm.assert_series_equal(result, expected.astype(dtype))",
            "@pytest.mark.notimpl(['postgres'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\ndef test_literal(con, field):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    query = _STRUCT_LITERAL[field]\n    dtype = query.type().to_pandas()\n    result = pd.Series([con.execute(query)], dtype=dtype)\n    result = result.replace({np.nan: None})\n    expected = pd.Series([_SIMPLE_DICT[field]])\n    tm.assert_series_equal(result, expected.astype(dtype))",
            "@pytest.mark.notimpl(['postgres'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\ndef test_literal(con, field):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    query = _STRUCT_LITERAL[field]\n    dtype = query.type().to_pandas()\n    result = pd.Series([con.execute(query)], dtype=dtype)\n    result = result.replace({np.nan: None})\n    expected = pd.Series([_SIMPLE_DICT[field]])\n    tm.assert_series_equal(result, expected.astype(dtype))",
            "@pytest.mark.notimpl(['postgres'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\ndef test_literal(con, field):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    query = _STRUCT_LITERAL[field]\n    dtype = query.type().to_pandas()\n    result = pd.Series([con.execute(query)], dtype=dtype)\n    result = result.replace({np.nan: None})\n    expected = pd.Series([_SIMPLE_DICT[field]])\n    tm.assert_series_equal(result, expected.astype(dtype))"
        ]
    },
    {
        "func_name": "test_null_literal",
        "original": "@pytest.mark.notimpl(['postgres'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\n@pytest.mark.notyet(['clickhouse'], reason=\"clickhouse doesn't support nullable nested types\")\ndef test_null_literal(con, field):\n    query = _NULL_STRUCT_LITERAL[field]\n    result = pd.Series([con.execute(query)])\n    result = result.replace({np.nan: None})\n    expected = pd.Series([None], dtype='object')\n    tm.assert_series_equal(result, expected)",
        "mutated": [
            "@pytest.mark.notimpl(['postgres'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\n@pytest.mark.notyet(['clickhouse'], reason=\"clickhouse doesn't support nullable nested types\")\ndef test_null_literal(con, field):\n    if False:\n        i = 10\n    query = _NULL_STRUCT_LITERAL[field]\n    result = pd.Series([con.execute(query)])\n    result = result.replace({np.nan: None})\n    expected = pd.Series([None], dtype='object')\n    tm.assert_series_equal(result, expected)",
            "@pytest.mark.notimpl(['postgres'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\n@pytest.mark.notyet(['clickhouse'], reason=\"clickhouse doesn't support nullable nested types\")\ndef test_null_literal(con, field):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    query = _NULL_STRUCT_LITERAL[field]\n    result = pd.Series([con.execute(query)])\n    result = result.replace({np.nan: None})\n    expected = pd.Series([None], dtype='object')\n    tm.assert_series_equal(result, expected)",
            "@pytest.mark.notimpl(['postgres'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\n@pytest.mark.notyet(['clickhouse'], reason=\"clickhouse doesn't support nullable nested types\")\ndef test_null_literal(con, field):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    query = _NULL_STRUCT_LITERAL[field]\n    result = pd.Series([con.execute(query)])\n    result = result.replace({np.nan: None})\n    expected = pd.Series([None], dtype='object')\n    tm.assert_series_equal(result, expected)",
            "@pytest.mark.notimpl(['postgres'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\n@pytest.mark.notyet(['clickhouse'], reason=\"clickhouse doesn't support nullable nested types\")\ndef test_null_literal(con, field):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    query = _NULL_STRUCT_LITERAL[field]\n    result = pd.Series([con.execute(query)])\n    result = result.replace({np.nan: None})\n    expected = pd.Series([None], dtype='object')\n    tm.assert_series_equal(result, expected)",
            "@pytest.mark.notimpl(['postgres'])\n@pytest.mark.parametrize('field', ['a', 'b', 'c'])\n@pytest.mark.notyet(['clickhouse'], reason=\"clickhouse doesn't support nullable nested types\")\ndef test_null_literal(con, field):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    query = _NULL_STRUCT_LITERAL[field]\n    result = pd.Series([con.execute(query)])\n    result = result.replace({np.nan: None})\n    expected = pd.Series([None], dtype='object')\n    tm.assert_series_equal(result, expected)"
        ]
    },
    {
        "func_name": "test_struct_column",
        "original": "@pytest.mark.notimpl(['dask', 'pandas', 'postgres'])\ndef test_struct_column(alltypes, df):\n    t = alltypes\n    expr = ibis.struct(dict(a=t.string_col, b=1, c=t.bigint_col)).name('s')\n    assert expr.type() == dt.Struct(dict(a=dt.string, b=dt.int8, c=dt.int64))\n    result = expr.execute()\n    expected = pd.Series((dict(a=a, b=1, c=c) for (a, c) in zip(df.string_col, df.bigint_col)), name='s')\n    tm.assert_series_equal(result, expected)",
        "mutated": [
            "@pytest.mark.notimpl(['dask', 'pandas', 'postgres'])\ndef test_struct_column(alltypes, df):\n    if False:\n        i = 10\n    t = alltypes\n    expr = ibis.struct(dict(a=t.string_col, b=1, c=t.bigint_col)).name('s')\n    assert expr.type() == dt.Struct(dict(a=dt.string, b=dt.int8, c=dt.int64))\n    result = expr.execute()\n    expected = pd.Series((dict(a=a, b=1, c=c) for (a, c) in zip(df.string_col, df.bigint_col)), name='s')\n    tm.assert_series_equal(result, expected)",
            "@pytest.mark.notimpl(['dask', 'pandas', 'postgres'])\ndef test_struct_column(alltypes, df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    t = alltypes\n    expr = ibis.struct(dict(a=t.string_col, b=1, c=t.bigint_col)).name('s')\n    assert expr.type() == dt.Struct(dict(a=dt.string, b=dt.int8, c=dt.int64))\n    result = expr.execute()\n    expected = pd.Series((dict(a=a, b=1, c=c) for (a, c) in zip(df.string_col, df.bigint_col)), name='s')\n    tm.assert_series_equal(result, expected)",
            "@pytest.mark.notimpl(['dask', 'pandas', 'postgres'])\ndef test_struct_column(alltypes, df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    t = alltypes\n    expr = ibis.struct(dict(a=t.string_col, b=1, c=t.bigint_col)).name('s')\n    assert expr.type() == dt.Struct(dict(a=dt.string, b=dt.int8, c=dt.int64))\n    result = expr.execute()\n    expected = pd.Series((dict(a=a, b=1, c=c) for (a, c) in zip(df.string_col, df.bigint_col)), name='s')\n    tm.assert_series_equal(result, expected)",
            "@pytest.mark.notimpl(['dask', 'pandas', 'postgres'])\ndef test_struct_column(alltypes, df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    t = alltypes\n    expr = ibis.struct(dict(a=t.string_col, b=1, c=t.bigint_col)).name('s')\n    assert expr.type() == dt.Struct(dict(a=dt.string, b=dt.int8, c=dt.int64))\n    result = expr.execute()\n    expected = pd.Series((dict(a=a, b=1, c=c) for (a, c) in zip(df.string_col, df.bigint_col)), name='s')\n    tm.assert_series_equal(result, expected)",
            "@pytest.mark.notimpl(['dask', 'pandas', 'postgres'])\ndef test_struct_column(alltypes, df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    t = alltypes\n    expr = ibis.struct(dict(a=t.string_col, b=1, c=t.bigint_col)).name('s')\n    assert expr.type() == dt.Struct(dict(a=dt.string, b=dt.int8, c=dt.int64))\n    result = expr.execute()\n    expected = pd.Series((dict(a=a, b=1, c=c) for (a, c) in zip(df.string_col, df.bigint_col)), name='s')\n    tm.assert_series_equal(result, expected)"
        ]
    },
    {
        "func_name": "test_collect_into_struct",
        "original": "@pytest.mark.notimpl(['dask', 'pandas', 'postgres', 'polars'])\ndef test_collect_into_struct(alltypes):\n    from ibis import _\n    t = alltypes\n    expr = t[_.string_col.isin(('0', '1'))].group_by(group='string_col').agg(val=lambda t: ibis.struct(dict(key=t.bigint_col.collect().cast('!array<int64>'))))\n    result = expr.execute()\n    assert result.shape == (2, 2)\n    assert set(result.group) == {'0', '1'}\n    val = result.val\n    assert len(val.loc[result.group == '0'].iat[0]['key']) == 730\n    assert len(val.loc[result.group == '1'].iat[0]['key']) == 730",
        "mutated": [
            "@pytest.mark.notimpl(['dask', 'pandas', 'postgres', 'polars'])\ndef test_collect_into_struct(alltypes):\n    if False:\n        i = 10\n    from ibis import _\n    t = alltypes\n    expr = t[_.string_col.isin(('0', '1'))].group_by(group='string_col').agg(val=lambda t: ibis.struct(dict(key=t.bigint_col.collect().cast('!array<int64>'))))\n    result = expr.execute()\n    assert result.shape == (2, 2)\n    assert set(result.group) == {'0', '1'}\n    val = result.val\n    assert len(val.loc[result.group == '0'].iat[0]['key']) == 730\n    assert len(val.loc[result.group == '1'].iat[0]['key']) == 730",
            "@pytest.mark.notimpl(['dask', 'pandas', 'postgres', 'polars'])\ndef test_collect_into_struct(alltypes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from ibis import _\n    t = alltypes\n    expr = t[_.string_col.isin(('0', '1'))].group_by(group='string_col').agg(val=lambda t: ibis.struct(dict(key=t.bigint_col.collect().cast('!array<int64>'))))\n    result = expr.execute()\n    assert result.shape == (2, 2)\n    assert set(result.group) == {'0', '1'}\n    val = result.val\n    assert len(val.loc[result.group == '0'].iat[0]['key']) == 730\n    assert len(val.loc[result.group == '1'].iat[0]['key']) == 730",
            "@pytest.mark.notimpl(['dask', 'pandas', 'postgres', 'polars'])\ndef test_collect_into_struct(alltypes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from ibis import _\n    t = alltypes\n    expr = t[_.string_col.isin(('0', '1'))].group_by(group='string_col').agg(val=lambda t: ibis.struct(dict(key=t.bigint_col.collect().cast('!array<int64>'))))\n    result = expr.execute()\n    assert result.shape == (2, 2)\n    assert set(result.group) == {'0', '1'}\n    val = result.val\n    assert len(val.loc[result.group == '0'].iat[0]['key']) == 730\n    assert len(val.loc[result.group == '1'].iat[0]['key']) == 730",
            "@pytest.mark.notimpl(['dask', 'pandas', 'postgres', 'polars'])\ndef test_collect_into_struct(alltypes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from ibis import _\n    t = alltypes\n    expr = t[_.string_col.isin(('0', '1'))].group_by(group='string_col').agg(val=lambda t: ibis.struct(dict(key=t.bigint_col.collect().cast('!array<int64>'))))\n    result = expr.execute()\n    assert result.shape == (2, 2)\n    assert set(result.group) == {'0', '1'}\n    val = result.val\n    assert len(val.loc[result.group == '0'].iat[0]['key']) == 730\n    assert len(val.loc[result.group == '1'].iat[0]['key']) == 730",
            "@pytest.mark.notimpl(['dask', 'pandas', 'postgres', 'polars'])\ndef test_collect_into_struct(alltypes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from ibis import _\n    t = alltypes\n    expr = t[_.string_col.isin(('0', '1'))].group_by(group='string_col').agg(val=lambda t: ibis.struct(dict(key=t.bigint_col.collect().cast('!array<int64>'))))\n    result = expr.execute()\n    assert result.shape == (2, 2)\n    assert set(result.group) == {'0', '1'}\n    val = result.val\n    assert len(val.loc[result.group == '0'].iat[0]['key']) == 730\n    assert len(val.loc[result.group == '1'].iat[0]['key']) == 730"
        ]
    }
]