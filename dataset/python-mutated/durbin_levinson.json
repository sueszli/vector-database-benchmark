[
    {
        "func_name": "durbin_levinson",
        "original": "@deprecate_kwarg('unbiased', 'adjusted')\ndef durbin_levinson(endog, ar_order=0, demean=True, adjusted=False):\n    \"\"\"\n    Estimate AR parameters at multiple orders using Durbin-Levinson recursions.\n\n    Parameters\n    ----------\n    endog : array_like or SARIMAXSpecification\n        Input time series array, assumed to be stationary.\n    ar_order : int, optional\n        Autoregressive order. Default is 0.\n    demean : bool, optional\n        Whether to estimate and remove the mean from the process prior to\n        fitting the autoregressive coefficients. Default is True.\n    adjusted : bool, optional\n        Whether to use the \"adjusted\" autocovariance estimator, which uses\n        n - h degrees of freedom rather than n. This option can result in\n        a non-positive definite autocovariance matrix. Default is False.\n\n    Returns\n    -------\n    parameters : list of SARIMAXParams objects\n        List elements correspond to estimates at different `ar_order`. For\n        example, parameters[0] is an `SARIMAXParams` instance corresponding to\n        `ar_order=0`.\n    other_results : Bunch\n        Includes one component, `spec`, containing the `SARIMAXSpecification`\n        instance corresponding to the input arguments.\n\n    Notes\n    -----\n    The primary reference is [1]_, section 2.5.1.\n\n    This procedure assumes that the series is stationary.\n\n    References\n    ----------\n    .. [1] Brockwell, Peter J., and Richard A. Davis. 2016.\n       Introduction to Time Series and Forecasting. Springer.\n    \"\"\"\n    spec = max_spec = SARIMAXSpecification(endog, ar_order=ar_order)\n    endog = max_spec.endog\n    if not max_spec.is_ar_consecutive:\n        raise ValueError('Durbin-Levinson estimation unavailable for models with seasonal or otherwise non-consecutive AR orders.')\n    gamma = acovf(endog, adjusted=adjusted, fft=True, demean=demean, nlag=max_spec.ar_order)\n    if max_spec.ar_order == 0:\n        ar_params = [None]\n        sigma2 = [gamma[0]]\n    else:\n        Phi = np.zeros((max_spec.ar_order, max_spec.ar_order))\n        v = np.zeros(max_spec.ar_order + 1)\n        Phi[0, 0] = gamma[1] / gamma[0]\n        v[0] = gamma[0]\n        v[1] = v[0] * (1 - Phi[0, 0] ** 2)\n        for i in range(1, max_spec.ar_order):\n            tmp = Phi[i - 1, :i]\n            Phi[i, i] = (gamma[i + 1] - np.dot(tmp, gamma[i:0:-1])) / v[i]\n            Phi[i, :i] = tmp - Phi[i, i] * tmp[::-1]\n            v[i + 1] = v[i] * (1 - Phi[i, i] ** 2)\n        ar_params = [None] + [Phi[i, :i + 1] for i in range(max_spec.ar_order)]\n        sigma2 = v\n    out = []\n    for i in range(max_spec.ar_order + 1):\n        spec = SARIMAXSpecification(ar_order=i)\n        p = SARIMAXParams(spec=spec)\n        if i == 0:\n            p.params = sigma2[i]\n        else:\n            p.params = np.r_[ar_params[i], sigma2[i]]\n        out.append(p)\n    other_results = Bunch({'spec': spec})\n    return (out, other_results)",
        "mutated": [
            "@deprecate_kwarg('unbiased', 'adjusted')\ndef durbin_levinson(endog, ar_order=0, demean=True, adjusted=False):\n    if False:\n        i = 10\n    '\\n    Estimate AR parameters at multiple orders using Durbin-Levinson recursions.\\n\\n    Parameters\\n    ----------\\n    endog : array_like or SARIMAXSpecification\\n        Input time series array, assumed to be stationary.\\n    ar_order : int, optional\\n        Autoregressive order. Default is 0.\\n    demean : bool, optional\\n        Whether to estimate and remove the mean from the process prior to\\n        fitting the autoregressive coefficients. Default is True.\\n    adjusted : bool, optional\\n        Whether to use the \"adjusted\" autocovariance estimator, which uses\\n        n - h degrees of freedom rather than n. This option can result in\\n        a non-positive definite autocovariance matrix. Default is False.\\n\\n    Returns\\n    -------\\n    parameters : list of SARIMAXParams objects\\n        List elements correspond to estimates at different `ar_order`. For\\n        example, parameters[0] is an `SARIMAXParams` instance corresponding to\\n        `ar_order=0`.\\n    other_results : Bunch\\n        Includes one component, `spec`, containing the `SARIMAXSpecification`\\n        instance corresponding to the input arguments.\\n\\n    Notes\\n    -----\\n    The primary reference is [1]_, section 2.5.1.\\n\\n    This procedure assumes that the series is stationary.\\n\\n    References\\n    ----------\\n    .. [1] Brockwell, Peter J., and Richard A. Davis. 2016.\\n       Introduction to Time Series and Forecasting. Springer.\\n    '\n    spec = max_spec = SARIMAXSpecification(endog, ar_order=ar_order)\n    endog = max_spec.endog\n    if not max_spec.is_ar_consecutive:\n        raise ValueError('Durbin-Levinson estimation unavailable for models with seasonal or otherwise non-consecutive AR orders.')\n    gamma = acovf(endog, adjusted=adjusted, fft=True, demean=demean, nlag=max_spec.ar_order)\n    if max_spec.ar_order == 0:\n        ar_params = [None]\n        sigma2 = [gamma[0]]\n    else:\n        Phi = np.zeros((max_spec.ar_order, max_spec.ar_order))\n        v = np.zeros(max_spec.ar_order + 1)\n        Phi[0, 0] = gamma[1] / gamma[0]\n        v[0] = gamma[0]\n        v[1] = v[0] * (1 - Phi[0, 0] ** 2)\n        for i in range(1, max_spec.ar_order):\n            tmp = Phi[i - 1, :i]\n            Phi[i, i] = (gamma[i + 1] - np.dot(tmp, gamma[i:0:-1])) / v[i]\n            Phi[i, :i] = tmp - Phi[i, i] * tmp[::-1]\n            v[i + 1] = v[i] * (1 - Phi[i, i] ** 2)\n        ar_params = [None] + [Phi[i, :i + 1] for i in range(max_spec.ar_order)]\n        sigma2 = v\n    out = []\n    for i in range(max_spec.ar_order + 1):\n        spec = SARIMAXSpecification(ar_order=i)\n        p = SARIMAXParams(spec=spec)\n        if i == 0:\n            p.params = sigma2[i]\n        else:\n            p.params = np.r_[ar_params[i], sigma2[i]]\n        out.append(p)\n    other_results = Bunch({'spec': spec})\n    return (out, other_results)",
            "@deprecate_kwarg('unbiased', 'adjusted')\ndef durbin_levinson(endog, ar_order=0, demean=True, adjusted=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Estimate AR parameters at multiple orders using Durbin-Levinson recursions.\\n\\n    Parameters\\n    ----------\\n    endog : array_like or SARIMAXSpecification\\n        Input time series array, assumed to be stationary.\\n    ar_order : int, optional\\n        Autoregressive order. Default is 0.\\n    demean : bool, optional\\n        Whether to estimate and remove the mean from the process prior to\\n        fitting the autoregressive coefficients. Default is True.\\n    adjusted : bool, optional\\n        Whether to use the \"adjusted\" autocovariance estimator, which uses\\n        n - h degrees of freedom rather than n. This option can result in\\n        a non-positive definite autocovariance matrix. Default is False.\\n\\n    Returns\\n    -------\\n    parameters : list of SARIMAXParams objects\\n        List elements correspond to estimates at different `ar_order`. For\\n        example, parameters[0] is an `SARIMAXParams` instance corresponding to\\n        `ar_order=0`.\\n    other_results : Bunch\\n        Includes one component, `spec`, containing the `SARIMAXSpecification`\\n        instance corresponding to the input arguments.\\n\\n    Notes\\n    -----\\n    The primary reference is [1]_, section 2.5.1.\\n\\n    This procedure assumes that the series is stationary.\\n\\n    References\\n    ----------\\n    .. [1] Brockwell, Peter J., and Richard A. Davis. 2016.\\n       Introduction to Time Series and Forecasting. Springer.\\n    '\n    spec = max_spec = SARIMAXSpecification(endog, ar_order=ar_order)\n    endog = max_spec.endog\n    if not max_spec.is_ar_consecutive:\n        raise ValueError('Durbin-Levinson estimation unavailable for models with seasonal or otherwise non-consecutive AR orders.')\n    gamma = acovf(endog, adjusted=adjusted, fft=True, demean=demean, nlag=max_spec.ar_order)\n    if max_spec.ar_order == 0:\n        ar_params = [None]\n        sigma2 = [gamma[0]]\n    else:\n        Phi = np.zeros((max_spec.ar_order, max_spec.ar_order))\n        v = np.zeros(max_spec.ar_order + 1)\n        Phi[0, 0] = gamma[1] / gamma[0]\n        v[0] = gamma[0]\n        v[1] = v[0] * (1 - Phi[0, 0] ** 2)\n        for i in range(1, max_spec.ar_order):\n            tmp = Phi[i - 1, :i]\n            Phi[i, i] = (gamma[i + 1] - np.dot(tmp, gamma[i:0:-1])) / v[i]\n            Phi[i, :i] = tmp - Phi[i, i] * tmp[::-1]\n            v[i + 1] = v[i] * (1 - Phi[i, i] ** 2)\n        ar_params = [None] + [Phi[i, :i + 1] for i in range(max_spec.ar_order)]\n        sigma2 = v\n    out = []\n    for i in range(max_spec.ar_order + 1):\n        spec = SARIMAXSpecification(ar_order=i)\n        p = SARIMAXParams(spec=spec)\n        if i == 0:\n            p.params = sigma2[i]\n        else:\n            p.params = np.r_[ar_params[i], sigma2[i]]\n        out.append(p)\n    other_results = Bunch({'spec': spec})\n    return (out, other_results)",
            "@deprecate_kwarg('unbiased', 'adjusted')\ndef durbin_levinson(endog, ar_order=0, demean=True, adjusted=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Estimate AR parameters at multiple orders using Durbin-Levinson recursions.\\n\\n    Parameters\\n    ----------\\n    endog : array_like or SARIMAXSpecification\\n        Input time series array, assumed to be stationary.\\n    ar_order : int, optional\\n        Autoregressive order. Default is 0.\\n    demean : bool, optional\\n        Whether to estimate and remove the mean from the process prior to\\n        fitting the autoregressive coefficients. Default is True.\\n    adjusted : bool, optional\\n        Whether to use the \"adjusted\" autocovariance estimator, which uses\\n        n - h degrees of freedom rather than n. This option can result in\\n        a non-positive definite autocovariance matrix. Default is False.\\n\\n    Returns\\n    -------\\n    parameters : list of SARIMAXParams objects\\n        List elements correspond to estimates at different `ar_order`. For\\n        example, parameters[0] is an `SARIMAXParams` instance corresponding to\\n        `ar_order=0`.\\n    other_results : Bunch\\n        Includes one component, `spec`, containing the `SARIMAXSpecification`\\n        instance corresponding to the input arguments.\\n\\n    Notes\\n    -----\\n    The primary reference is [1]_, section 2.5.1.\\n\\n    This procedure assumes that the series is stationary.\\n\\n    References\\n    ----------\\n    .. [1] Brockwell, Peter J., and Richard A. Davis. 2016.\\n       Introduction to Time Series and Forecasting. Springer.\\n    '\n    spec = max_spec = SARIMAXSpecification(endog, ar_order=ar_order)\n    endog = max_spec.endog\n    if not max_spec.is_ar_consecutive:\n        raise ValueError('Durbin-Levinson estimation unavailable for models with seasonal or otherwise non-consecutive AR orders.')\n    gamma = acovf(endog, adjusted=adjusted, fft=True, demean=demean, nlag=max_spec.ar_order)\n    if max_spec.ar_order == 0:\n        ar_params = [None]\n        sigma2 = [gamma[0]]\n    else:\n        Phi = np.zeros((max_spec.ar_order, max_spec.ar_order))\n        v = np.zeros(max_spec.ar_order + 1)\n        Phi[0, 0] = gamma[1] / gamma[0]\n        v[0] = gamma[0]\n        v[1] = v[0] * (1 - Phi[0, 0] ** 2)\n        for i in range(1, max_spec.ar_order):\n            tmp = Phi[i - 1, :i]\n            Phi[i, i] = (gamma[i + 1] - np.dot(tmp, gamma[i:0:-1])) / v[i]\n            Phi[i, :i] = tmp - Phi[i, i] * tmp[::-1]\n            v[i + 1] = v[i] * (1 - Phi[i, i] ** 2)\n        ar_params = [None] + [Phi[i, :i + 1] for i in range(max_spec.ar_order)]\n        sigma2 = v\n    out = []\n    for i in range(max_spec.ar_order + 1):\n        spec = SARIMAXSpecification(ar_order=i)\n        p = SARIMAXParams(spec=spec)\n        if i == 0:\n            p.params = sigma2[i]\n        else:\n            p.params = np.r_[ar_params[i], sigma2[i]]\n        out.append(p)\n    other_results = Bunch({'spec': spec})\n    return (out, other_results)",
            "@deprecate_kwarg('unbiased', 'adjusted')\ndef durbin_levinson(endog, ar_order=0, demean=True, adjusted=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Estimate AR parameters at multiple orders using Durbin-Levinson recursions.\\n\\n    Parameters\\n    ----------\\n    endog : array_like or SARIMAXSpecification\\n        Input time series array, assumed to be stationary.\\n    ar_order : int, optional\\n        Autoregressive order. Default is 0.\\n    demean : bool, optional\\n        Whether to estimate and remove the mean from the process prior to\\n        fitting the autoregressive coefficients. Default is True.\\n    adjusted : bool, optional\\n        Whether to use the \"adjusted\" autocovariance estimator, which uses\\n        n - h degrees of freedom rather than n. This option can result in\\n        a non-positive definite autocovariance matrix. Default is False.\\n\\n    Returns\\n    -------\\n    parameters : list of SARIMAXParams objects\\n        List elements correspond to estimates at different `ar_order`. For\\n        example, parameters[0] is an `SARIMAXParams` instance corresponding to\\n        `ar_order=0`.\\n    other_results : Bunch\\n        Includes one component, `spec`, containing the `SARIMAXSpecification`\\n        instance corresponding to the input arguments.\\n\\n    Notes\\n    -----\\n    The primary reference is [1]_, section 2.5.1.\\n\\n    This procedure assumes that the series is stationary.\\n\\n    References\\n    ----------\\n    .. [1] Brockwell, Peter J., and Richard A. Davis. 2016.\\n       Introduction to Time Series and Forecasting. Springer.\\n    '\n    spec = max_spec = SARIMAXSpecification(endog, ar_order=ar_order)\n    endog = max_spec.endog\n    if not max_spec.is_ar_consecutive:\n        raise ValueError('Durbin-Levinson estimation unavailable for models with seasonal or otherwise non-consecutive AR orders.')\n    gamma = acovf(endog, adjusted=adjusted, fft=True, demean=demean, nlag=max_spec.ar_order)\n    if max_spec.ar_order == 0:\n        ar_params = [None]\n        sigma2 = [gamma[0]]\n    else:\n        Phi = np.zeros((max_spec.ar_order, max_spec.ar_order))\n        v = np.zeros(max_spec.ar_order + 1)\n        Phi[0, 0] = gamma[1] / gamma[0]\n        v[0] = gamma[0]\n        v[1] = v[0] * (1 - Phi[0, 0] ** 2)\n        for i in range(1, max_spec.ar_order):\n            tmp = Phi[i - 1, :i]\n            Phi[i, i] = (gamma[i + 1] - np.dot(tmp, gamma[i:0:-1])) / v[i]\n            Phi[i, :i] = tmp - Phi[i, i] * tmp[::-1]\n            v[i + 1] = v[i] * (1 - Phi[i, i] ** 2)\n        ar_params = [None] + [Phi[i, :i + 1] for i in range(max_spec.ar_order)]\n        sigma2 = v\n    out = []\n    for i in range(max_spec.ar_order + 1):\n        spec = SARIMAXSpecification(ar_order=i)\n        p = SARIMAXParams(spec=spec)\n        if i == 0:\n            p.params = sigma2[i]\n        else:\n            p.params = np.r_[ar_params[i], sigma2[i]]\n        out.append(p)\n    other_results = Bunch({'spec': spec})\n    return (out, other_results)",
            "@deprecate_kwarg('unbiased', 'adjusted')\ndef durbin_levinson(endog, ar_order=0, demean=True, adjusted=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Estimate AR parameters at multiple orders using Durbin-Levinson recursions.\\n\\n    Parameters\\n    ----------\\n    endog : array_like or SARIMAXSpecification\\n        Input time series array, assumed to be stationary.\\n    ar_order : int, optional\\n        Autoregressive order. Default is 0.\\n    demean : bool, optional\\n        Whether to estimate and remove the mean from the process prior to\\n        fitting the autoregressive coefficients. Default is True.\\n    adjusted : bool, optional\\n        Whether to use the \"adjusted\" autocovariance estimator, which uses\\n        n - h degrees of freedom rather than n. This option can result in\\n        a non-positive definite autocovariance matrix. Default is False.\\n\\n    Returns\\n    -------\\n    parameters : list of SARIMAXParams objects\\n        List elements correspond to estimates at different `ar_order`. For\\n        example, parameters[0] is an `SARIMAXParams` instance corresponding to\\n        `ar_order=0`.\\n    other_results : Bunch\\n        Includes one component, `spec`, containing the `SARIMAXSpecification`\\n        instance corresponding to the input arguments.\\n\\n    Notes\\n    -----\\n    The primary reference is [1]_, section 2.5.1.\\n\\n    This procedure assumes that the series is stationary.\\n\\n    References\\n    ----------\\n    .. [1] Brockwell, Peter J., and Richard A. Davis. 2016.\\n       Introduction to Time Series and Forecasting. Springer.\\n    '\n    spec = max_spec = SARIMAXSpecification(endog, ar_order=ar_order)\n    endog = max_spec.endog\n    if not max_spec.is_ar_consecutive:\n        raise ValueError('Durbin-Levinson estimation unavailable for models with seasonal or otherwise non-consecutive AR orders.')\n    gamma = acovf(endog, adjusted=adjusted, fft=True, demean=demean, nlag=max_spec.ar_order)\n    if max_spec.ar_order == 0:\n        ar_params = [None]\n        sigma2 = [gamma[0]]\n    else:\n        Phi = np.zeros((max_spec.ar_order, max_spec.ar_order))\n        v = np.zeros(max_spec.ar_order + 1)\n        Phi[0, 0] = gamma[1] / gamma[0]\n        v[0] = gamma[0]\n        v[1] = v[0] * (1 - Phi[0, 0] ** 2)\n        for i in range(1, max_spec.ar_order):\n            tmp = Phi[i - 1, :i]\n            Phi[i, i] = (gamma[i + 1] - np.dot(tmp, gamma[i:0:-1])) / v[i]\n            Phi[i, :i] = tmp - Phi[i, i] * tmp[::-1]\n            v[i + 1] = v[i] * (1 - Phi[i, i] ** 2)\n        ar_params = [None] + [Phi[i, :i + 1] for i in range(max_spec.ar_order)]\n        sigma2 = v\n    out = []\n    for i in range(max_spec.ar_order + 1):\n        spec = SARIMAXSpecification(ar_order=i)\n        p = SARIMAXParams(spec=spec)\n        if i == 0:\n            p.params = sigma2[i]\n        else:\n            p.params = np.r_[ar_params[i], sigma2[i]]\n        out.append(p)\n    other_results = Bunch({'spec': spec})\n    return (out, other_results)"
        ]
    }
]