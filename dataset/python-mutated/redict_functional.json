[
    {
        "func_name": "_make_exog_from_formula",
        "original": "def _make_exog_from_formula(result, focus_var, summaries, values, num_points):\n    \"\"\"\n    Create dataframes for exploring a fitted model as a function of one variable.\n\n    This works for models fit with a formula.\n\n    Returns\n    -------\n    dexog : data frame\n        A data frame in which the focus variable varies and the other variables\n        are fixed at specified or computed values.\n    fexog : data frame\n        The data frame `dexog` processed through the model formula.\n    \"\"\"\n    model = result.model\n    exog = model.data.frame\n    if summaries is None:\n        summaries = {}\n    if values is None:\n        values = {}\n    if exog[focus_var].dtype is np.dtype('O'):\n        raise ValueError('focus variable may not have object type')\n    colnames = list(summaries.keys()) + list(values.keys()) + [focus_var]\n    dtypes = [exog[x].dtype for x in colnames]\n    varl = set(exog.columns.tolist()) - set([model.endog_names])\n    unmatched = varl - set(colnames)\n    unmatched = list(unmatched)\n    if len(unmatched) > 0:\n        warnings.warn('%s in data frame but not in summaries or values.' % ', '.join([\"'%s'\" % x for x in unmatched]), ValueWarning)\n    ix = range(num_points)\n    fexog = pd.DataFrame(index=ix, columns=colnames)\n    for (d, x) in zip(dtypes, colnames):\n        fexog[x] = pd.Series(index=ix, dtype=d)\n    pctls = np.linspace(0, 100, num_points).tolist()\n    fvals = np.percentile(exog[focus_var], pctls)\n    fvals = np.asarray(fvals)\n    fexog.loc[:, focus_var] = fvals\n    for ky in summaries.keys():\n        fexog.loc[:, ky] = summaries[ky](exog.loc[:, ky])\n    for ky in values.keys():\n        fexog[ky] = values[ky]\n    dexog = patsy.dmatrix(model.data.design_info, fexog, return_type='dataframe')\n    return (dexog, fexog, fvals)",
        "mutated": [
            "def _make_exog_from_formula(result, focus_var, summaries, values, num_points):\n    if False:\n        i = 10\n    '\\n    Create dataframes for exploring a fitted model as a function of one variable.\\n\\n    This works for models fit with a formula.\\n\\n    Returns\\n    -------\\n    dexog : data frame\\n        A data frame in which the focus variable varies and the other variables\\n        are fixed at specified or computed values.\\n    fexog : data frame\\n        The data frame `dexog` processed through the model formula.\\n    '\n    model = result.model\n    exog = model.data.frame\n    if summaries is None:\n        summaries = {}\n    if values is None:\n        values = {}\n    if exog[focus_var].dtype is np.dtype('O'):\n        raise ValueError('focus variable may not have object type')\n    colnames = list(summaries.keys()) + list(values.keys()) + [focus_var]\n    dtypes = [exog[x].dtype for x in colnames]\n    varl = set(exog.columns.tolist()) - set([model.endog_names])\n    unmatched = varl - set(colnames)\n    unmatched = list(unmatched)\n    if len(unmatched) > 0:\n        warnings.warn('%s in data frame but not in summaries or values.' % ', '.join([\"'%s'\" % x for x in unmatched]), ValueWarning)\n    ix = range(num_points)\n    fexog = pd.DataFrame(index=ix, columns=colnames)\n    for (d, x) in zip(dtypes, colnames):\n        fexog[x] = pd.Series(index=ix, dtype=d)\n    pctls = np.linspace(0, 100, num_points).tolist()\n    fvals = np.percentile(exog[focus_var], pctls)\n    fvals = np.asarray(fvals)\n    fexog.loc[:, focus_var] = fvals\n    for ky in summaries.keys():\n        fexog.loc[:, ky] = summaries[ky](exog.loc[:, ky])\n    for ky in values.keys():\n        fexog[ky] = values[ky]\n    dexog = patsy.dmatrix(model.data.design_info, fexog, return_type='dataframe')\n    return (dexog, fexog, fvals)",
            "def _make_exog_from_formula(result, focus_var, summaries, values, num_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create dataframes for exploring a fitted model as a function of one variable.\\n\\n    This works for models fit with a formula.\\n\\n    Returns\\n    -------\\n    dexog : data frame\\n        A data frame in which the focus variable varies and the other variables\\n        are fixed at specified or computed values.\\n    fexog : data frame\\n        The data frame `dexog` processed through the model formula.\\n    '\n    model = result.model\n    exog = model.data.frame\n    if summaries is None:\n        summaries = {}\n    if values is None:\n        values = {}\n    if exog[focus_var].dtype is np.dtype('O'):\n        raise ValueError('focus variable may not have object type')\n    colnames = list(summaries.keys()) + list(values.keys()) + [focus_var]\n    dtypes = [exog[x].dtype for x in colnames]\n    varl = set(exog.columns.tolist()) - set([model.endog_names])\n    unmatched = varl - set(colnames)\n    unmatched = list(unmatched)\n    if len(unmatched) > 0:\n        warnings.warn('%s in data frame but not in summaries or values.' % ', '.join([\"'%s'\" % x for x in unmatched]), ValueWarning)\n    ix = range(num_points)\n    fexog = pd.DataFrame(index=ix, columns=colnames)\n    for (d, x) in zip(dtypes, colnames):\n        fexog[x] = pd.Series(index=ix, dtype=d)\n    pctls = np.linspace(0, 100, num_points).tolist()\n    fvals = np.percentile(exog[focus_var], pctls)\n    fvals = np.asarray(fvals)\n    fexog.loc[:, focus_var] = fvals\n    for ky in summaries.keys():\n        fexog.loc[:, ky] = summaries[ky](exog.loc[:, ky])\n    for ky in values.keys():\n        fexog[ky] = values[ky]\n    dexog = patsy.dmatrix(model.data.design_info, fexog, return_type='dataframe')\n    return (dexog, fexog, fvals)",
            "def _make_exog_from_formula(result, focus_var, summaries, values, num_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create dataframes for exploring a fitted model as a function of one variable.\\n\\n    This works for models fit with a formula.\\n\\n    Returns\\n    -------\\n    dexog : data frame\\n        A data frame in which the focus variable varies and the other variables\\n        are fixed at specified or computed values.\\n    fexog : data frame\\n        The data frame `dexog` processed through the model formula.\\n    '\n    model = result.model\n    exog = model.data.frame\n    if summaries is None:\n        summaries = {}\n    if values is None:\n        values = {}\n    if exog[focus_var].dtype is np.dtype('O'):\n        raise ValueError('focus variable may not have object type')\n    colnames = list(summaries.keys()) + list(values.keys()) + [focus_var]\n    dtypes = [exog[x].dtype for x in colnames]\n    varl = set(exog.columns.tolist()) - set([model.endog_names])\n    unmatched = varl - set(colnames)\n    unmatched = list(unmatched)\n    if len(unmatched) > 0:\n        warnings.warn('%s in data frame but not in summaries or values.' % ', '.join([\"'%s'\" % x for x in unmatched]), ValueWarning)\n    ix = range(num_points)\n    fexog = pd.DataFrame(index=ix, columns=colnames)\n    for (d, x) in zip(dtypes, colnames):\n        fexog[x] = pd.Series(index=ix, dtype=d)\n    pctls = np.linspace(0, 100, num_points).tolist()\n    fvals = np.percentile(exog[focus_var], pctls)\n    fvals = np.asarray(fvals)\n    fexog.loc[:, focus_var] = fvals\n    for ky in summaries.keys():\n        fexog.loc[:, ky] = summaries[ky](exog.loc[:, ky])\n    for ky in values.keys():\n        fexog[ky] = values[ky]\n    dexog = patsy.dmatrix(model.data.design_info, fexog, return_type='dataframe')\n    return (dexog, fexog, fvals)",
            "def _make_exog_from_formula(result, focus_var, summaries, values, num_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create dataframes for exploring a fitted model as a function of one variable.\\n\\n    This works for models fit with a formula.\\n\\n    Returns\\n    -------\\n    dexog : data frame\\n        A data frame in which the focus variable varies and the other variables\\n        are fixed at specified or computed values.\\n    fexog : data frame\\n        The data frame `dexog` processed through the model formula.\\n    '\n    model = result.model\n    exog = model.data.frame\n    if summaries is None:\n        summaries = {}\n    if values is None:\n        values = {}\n    if exog[focus_var].dtype is np.dtype('O'):\n        raise ValueError('focus variable may not have object type')\n    colnames = list(summaries.keys()) + list(values.keys()) + [focus_var]\n    dtypes = [exog[x].dtype for x in colnames]\n    varl = set(exog.columns.tolist()) - set([model.endog_names])\n    unmatched = varl - set(colnames)\n    unmatched = list(unmatched)\n    if len(unmatched) > 0:\n        warnings.warn('%s in data frame but not in summaries or values.' % ', '.join([\"'%s'\" % x for x in unmatched]), ValueWarning)\n    ix = range(num_points)\n    fexog = pd.DataFrame(index=ix, columns=colnames)\n    for (d, x) in zip(dtypes, colnames):\n        fexog[x] = pd.Series(index=ix, dtype=d)\n    pctls = np.linspace(0, 100, num_points).tolist()\n    fvals = np.percentile(exog[focus_var], pctls)\n    fvals = np.asarray(fvals)\n    fexog.loc[:, focus_var] = fvals\n    for ky in summaries.keys():\n        fexog.loc[:, ky] = summaries[ky](exog.loc[:, ky])\n    for ky in values.keys():\n        fexog[ky] = values[ky]\n    dexog = patsy.dmatrix(model.data.design_info, fexog, return_type='dataframe')\n    return (dexog, fexog, fvals)",
            "def _make_exog_from_formula(result, focus_var, summaries, values, num_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create dataframes for exploring a fitted model as a function of one variable.\\n\\n    This works for models fit with a formula.\\n\\n    Returns\\n    -------\\n    dexog : data frame\\n        A data frame in which the focus variable varies and the other variables\\n        are fixed at specified or computed values.\\n    fexog : data frame\\n        The data frame `dexog` processed through the model formula.\\n    '\n    model = result.model\n    exog = model.data.frame\n    if summaries is None:\n        summaries = {}\n    if values is None:\n        values = {}\n    if exog[focus_var].dtype is np.dtype('O'):\n        raise ValueError('focus variable may not have object type')\n    colnames = list(summaries.keys()) + list(values.keys()) + [focus_var]\n    dtypes = [exog[x].dtype for x in colnames]\n    varl = set(exog.columns.tolist()) - set([model.endog_names])\n    unmatched = varl - set(colnames)\n    unmatched = list(unmatched)\n    if len(unmatched) > 0:\n        warnings.warn('%s in data frame but not in summaries or values.' % ', '.join([\"'%s'\" % x for x in unmatched]), ValueWarning)\n    ix = range(num_points)\n    fexog = pd.DataFrame(index=ix, columns=colnames)\n    for (d, x) in zip(dtypes, colnames):\n        fexog[x] = pd.Series(index=ix, dtype=d)\n    pctls = np.linspace(0, 100, num_points).tolist()\n    fvals = np.percentile(exog[focus_var], pctls)\n    fvals = np.asarray(fvals)\n    fexog.loc[:, focus_var] = fvals\n    for ky in summaries.keys():\n        fexog.loc[:, ky] = summaries[ky](exog.loc[:, ky])\n    for ky in values.keys():\n        fexog[ky] = values[ky]\n    dexog = patsy.dmatrix(model.data.design_info, fexog, return_type='dataframe')\n    return (dexog, fexog, fvals)"
        ]
    },
    {
        "func_name": "_make_exog_from_arrays",
        "original": "def _make_exog_from_arrays(result, focus_var, summaries, values, num_points):\n    \"\"\"\n    Create dataframes for exploring a fitted model as a function of one variable.\n\n    This works for models fit without a formula.\n\n    Returns\n    -------\n    exog : data frame\n        A data frame in which the focus variable varies and the other variables\n        are fixed at specified or computed values.\n    \"\"\"\n    model = result.model\n    model_exog = model.exog\n    exog_names = model.exog_names\n    if summaries is None:\n        summaries = {}\n    if values is None:\n        values = {}\n    exog = np.zeros((num_points, model_exog.shape[1]))\n    colnames = list(values.keys()) + list(summaries.keys()) + [focus_var]\n    unmatched = set(exog_names) - set(colnames)\n    unmatched = list(unmatched)\n    if len(unmatched) > 0:\n        warnings.warn('%s in model but not in `summaries` or `values`.' % ', '.join([\"'%s'\" % x for x in unmatched]), ValueWarning)\n    pctls = np.linspace(0, 100, num_points).tolist()\n    ix = exog_names.index(focus_var)\n    fvals = np.percentile(model_exog[:, ix], pctls)\n    exog[:, ix] = fvals\n    for ky in summaries.keys():\n        ix = exog_names.index(ky)\n        exog[:, ix] = summaries[ky](model_exog[:, ix])\n    for ky in values.keys():\n        ix = exog_names.index(ky)\n        exog[:, ix] = values[ky]\n    return (exog, fvals)",
        "mutated": [
            "def _make_exog_from_arrays(result, focus_var, summaries, values, num_points):\n    if False:\n        i = 10\n    '\\n    Create dataframes for exploring a fitted model as a function of one variable.\\n\\n    This works for models fit without a formula.\\n\\n    Returns\\n    -------\\n    exog : data frame\\n        A data frame in which the focus variable varies and the other variables\\n        are fixed at specified or computed values.\\n    '\n    model = result.model\n    model_exog = model.exog\n    exog_names = model.exog_names\n    if summaries is None:\n        summaries = {}\n    if values is None:\n        values = {}\n    exog = np.zeros((num_points, model_exog.shape[1]))\n    colnames = list(values.keys()) + list(summaries.keys()) + [focus_var]\n    unmatched = set(exog_names) - set(colnames)\n    unmatched = list(unmatched)\n    if len(unmatched) > 0:\n        warnings.warn('%s in model but not in `summaries` or `values`.' % ', '.join([\"'%s'\" % x for x in unmatched]), ValueWarning)\n    pctls = np.linspace(0, 100, num_points).tolist()\n    ix = exog_names.index(focus_var)\n    fvals = np.percentile(model_exog[:, ix], pctls)\n    exog[:, ix] = fvals\n    for ky in summaries.keys():\n        ix = exog_names.index(ky)\n        exog[:, ix] = summaries[ky](model_exog[:, ix])\n    for ky in values.keys():\n        ix = exog_names.index(ky)\n        exog[:, ix] = values[ky]\n    return (exog, fvals)",
            "def _make_exog_from_arrays(result, focus_var, summaries, values, num_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create dataframes for exploring a fitted model as a function of one variable.\\n\\n    This works for models fit without a formula.\\n\\n    Returns\\n    -------\\n    exog : data frame\\n        A data frame in which the focus variable varies and the other variables\\n        are fixed at specified or computed values.\\n    '\n    model = result.model\n    model_exog = model.exog\n    exog_names = model.exog_names\n    if summaries is None:\n        summaries = {}\n    if values is None:\n        values = {}\n    exog = np.zeros((num_points, model_exog.shape[1]))\n    colnames = list(values.keys()) + list(summaries.keys()) + [focus_var]\n    unmatched = set(exog_names) - set(colnames)\n    unmatched = list(unmatched)\n    if len(unmatched) > 0:\n        warnings.warn('%s in model but not in `summaries` or `values`.' % ', '.join([\"'%s'\" % x for x in unmatched]), ValueWarning)\n    pctls = np.linspace(0, 100, num_points).tolist()\n    ix = exog_names.index(focus_var)\n    fvals = np.percentile(model_exog[:, ix], pctls)\n    exog[:, ix] = fvals\n    for ky in summaries.keys():\n        ix = exog_names.index(ky)\n        exog[:, ix] = summaries[ky](model_exog[:, ix])\n    for ky in values.keys():\n        ix = exog_names.index(ky)\n        exog[:, ix] = values[ky]\n    return (exog, fvals)",
            "def _make_exog_from_arrays(result, focus_var, summaries, values, num_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create dataframes for exploring a fitted model as a function of one variable.\\n\\n    This works for models fit without a formula.\\n\\n    Returns\\n    -------\\n    exog : data frame\\n        A data frame in which the focus variable varies and the other variables\\n        are fixed at specified or computed values.\\n    '\n    model = result.model\n    model_exog = model.exog\n    exog_names = model.exog_names\n    if summaries is None:\n        summaries = {}\n    if values is None:\n        values = {}\n    exog = np.zeros((num_points, model_exog.shape[1]))\n    colnames = list(values.keys()) + list(summaries.keys()) + [focus_var]\n    unmatched = set(exog_names) - set(colnames)\n    unmatched = list(unmatched)\n    if len(unmatched) > 0:\n        warnings.warn('%s in model but not in `summaries` or `values`.' % ', '.join([\"'%s'\" % x for x in unmatched]), ValueWarning)\n    pctls = np.linspace(0, 100, num_points).tolist()\n    ix = exog_names.index(focus_var)\n    fvals = np.percentile(model_exog[:, ix], pctls)\n    exog[:, ix] = fvals\n    for ky in summaries.keys():\n        ix = exog_names.index(ky)\n        exog[:, ix] = summaries[ky](model_exog[:, ix])\n    for ky in values.keys():\n        ix = exog_names.index(ky)\n        exog[:, ix] = values[ky]\n    return (exog, fvals)",
            "def _make_exog_from_arrays(result, focus_var, summaries, values, num_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create dataframes for exploring a fitted model as a function of one variable.\\n\\n    This works for models fit without a formula.\\n\\n    Returns\\n    -------\\n    exog : data frame\\n        A data frame in which the focus variable varies and the other variables\\n        are fixed at specified or computed values.\\n    '\n    model = result.model\n    model_exog = model.exog\n    exog_names = model.exog_names\n    if summaries is None:\n        summaries = {}\n    if values is None:\n        values = {}\n    exog = np.zeros((num_points, model_exog.shape[1]))\n    colnames = list(values.keys()) + list(summaries.keys()) + [focus_var]\n    unmatched = set(exog_names) - set(colnames)\n    unmatched = list(unmatched)\n    if len(unmatched) > 0:\n        warnings.warn('%s in model but not in `summaries` or `values`.' % ', '.join([\"'%s'\" % x for x in unmatched]), ValueWarning)\n    pctls = np.linspace(0, 100, num_points).tolist()\n    ix = exog_names.index(focus_var)\n    fvals = np.percentile(model_exog[:, ix], pctls)\n    exog[:, ix] = fvals\n    for ky in summaries.keys():\n        ix = exog_names.index(ky)\n        exog[:, ix] = summaries[ky](model_exog[:, ix])\n    for ky in values.keys():\n        ix = exog_names.index(ky)\n        exog[:, ix] = values[ky]\n    return (exog, fvals)",
            "def _make_exog_from_arrays(result, focus_var, summaries, values, num_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create dataframes for exploring a fitted model as a function of one variable.\\n\\n    This works for models fit without a formula.\\n\\n    Returns\\n    -------\\n    exog : data frame\\n        A data frame in which the focus variable varies and the other variables\\n        are fixed at specified or computed values.\\n    '\n    model = result.model\n    model_exog = model.exog\n    exog_names = model.exog_names\n    if summaries is None:\n        summaries = {}\n    if values is None:\n        values = {}\n    exog = np.zeros((num_points, model_exog.shape[1]))\n    colnames = list(values.keys()) + list(summaries.keys()) + [focus_var]\n    unmatched = set(exog_names) - set(colnames)\n    unmatched = list(unmatched)\n    if len(unmatched) > 0:\n        warnings.warn('%s in model but not in `summaries` or `values`.' % ', '.join([\"'%s'\" % x for x in unmatched]), ValueWarning)\n    pctls = np.linspace(0, 100, num_points).tolist()\n    ix = exog_names.index(focus_var)\n    fvals = np.percentile(model_exog[:, ix], pctls)\n    exog[:, ix] = fvals\n    for ky in summaries.keys():\n        ix = exog_names.index(ky)\n        exog[:, ix] = summaries[ky](model_exog[:, ix])\n    for ky in values.keys():\n        ix = exog_names.index(ky)\n        exog[:, ix] = values[ky]\n    return (exog, fvals)"
        ]
    },
    {
        "func_name": "_make_exog",
        "original": "def _make_exog(result, focus_var, summaries, values, num_points):\n    if hasattr(result.model.data, 'frame'):\n        (dexog, fexog, fvals) = _make_exog_from_formula(result, focus_var, summaries, values, num_points)\n    else:\n        (exog, fvals) = _make_exog_from_arrays(result, focus_var, summaries, values, num_points)\n        (dexog, fexog) = (exog, exog)\n    return (dexog, fexog, fvals)",
        "mutated": [
            "def _make_exog(result, focus_var, summaries, values, num_points):\n    if False:\n        i = 10\n    if hasattr(result.model.data, 'frame'):\n        (dexog, fexog, fvals) = _make_exog_from_formula(result, focus_var, summaries, values, num_points)\n    else:\n        (exog, fvals) = _make_exog_from_arrays(result, focus_var, summaries, values, num_points)\n        (dexog, fexog) = (exog, exog)\n    return (dexog, fexog, fvals)",
            "def _make_exog(result, focus_var, summaries, values, num_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if hasattr(result.model.data, 'frame'):\n        (dexog, fexog, fvals) = _make_exog_from_formula(result, focus_var, summaries, values, num_points)\n    else:\n        (exog, fvals) = _make_exog_from_arrays(result, focus_var, summaries, values, num_points)\n        (dexog, fexog) = (exog, exog)\n    return (dexog, fexog, fvals)",
            "def _make_exog(result, focus_var, summaries, values, num_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if hasattr(result.model.data, 'frame'):\n        (dexog, fexog, fvals) = _make_exog_from_formula(result, focus_var, summaries, values, num_points)\n    else:\n        (exog, fvals) = _make_exog_from_arrays(result, focus_var, summaries, values, num_points)\n        (dexog, fexog) = (exog, exog)\n    return (dexog, fexog, fvals)",
            "def _make_exog(result, focus_var, summaries, values, num_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if hasattr(result.model.data, 'frame'):\n        (dexog, fexog, fvals) = _make_exog_from_formula(result, focus_var, summaries, values, num_points)\n    else:\n        (exog, fvals) = _make_exog_from_arrays(result, focus_var, summaries, values, num_points)\n        (dexog, fexog) = (exog, exog)\n    return (dexog, fexog, fvals)",
            "def _make_exog(result, focus_var, summaries, values, num_points):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if hasattr(result.model.data, 'frame'):\n        (dexog, fexog, fvals) = _make_exog_from_formula(result, focus_var, summaries, values, num_points)\n    else:\n        (exog, fvals) = _make_exog_from_arrays(result, focus_var, summaries, values, num_points)\n        (dexog, fexog) = (exog, exog)\n    return (dexog, fexog, fvals)"
        ]
    },
    {
        "func_name": "_check_args",
        "original": "def _check_args(values, summaries, values2, summaries2):\n    if values is None:\n        values = {}\n    if values2 is None:\n        values2 = {}\n    if summaries is None:\n        summaries = {}\n    if summaries2 is None:\n        summaries2 = {}\n    for (s, v) in ((summaries, values), (summaries2, values2)):\n        ky = set(v.keys()) & set(s.keys())\n        ky = list(ky)\n        if len(ky) > 0:\n            raise ValueError('One or more variable names are contained in both `summaries` and `values`:' + ', '.join(ky))\n    return (values, summaries, values2, summaries2)",
        "mutated": [
            "def _check_args(values, summaries, values2, summaries2):\n    if False:\n        i = 10\n    if values is None:\n        values = {}\n    if values2 is None:\n        values2 = {}\n    if summaries is None:\n        summaries = {}\n    if summaries2 is None:\n        summaries2 = {}\n    for (s, v) in ((summaries, values), (summaries2, values2)):\n        ky = set(v.keys()) & set(s.keys())\n        ky = list(ky)\n        if len(ky) > 0:\n            raise ValueError('One or more variable names are contained in both `summaries` and `values`:' + ', '.join(ky))\n    return (values, summaries, values2, summaries2)",
            "def _check_args(values, summaries, values2, summaries2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if values is None:\n        values = {}\n    if values2 is None:\n        values2 = {}\n    if summaries is None:\n        summaries = {}\n    if summaries2 is None:\n        summaries2 = {}\n    for (s, v) in ((summaries, values), (summaries2, values2)):\n        ky = set(v.keys()) & set(s.keys())\n        ky = list(ky)\n        if len(ky) > 0:\n            raise ValueError('One or more variable names are contained in both `summaries` and `values`:' + ', '.join(ky))\n    return (values, summaries, values2, summaries2)",
            "def _check_args(values, summaries, values2, summaries2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if values is None:\n        values = {}\n    if values2 is None:\n        values2 = {}\n    if summaries is None:\n        summaries = {}\n    if summaries2 is None:\n        summaries2 = {}\n    for (s, v) in ((summaries, values), (summaries2, values2)):\n        ky = set(v.keys()) & set(s.keys())\n        ky = list(ky)\n        if len(ky) > 0:\n            raise ValueError('One or more variable names are contained in both `summaries` and `values`:' + ', '.join(ky))\n    return (values, summaries, values2, summaries2)",
            "def _check_args(values, summaries, values2, summaries2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if values is None:\n        values = {}\n    if values2 is None:\n        values2 = {}\n    if summaries is None:\n        summaries = {}\n    if summaries2 is None:\n        summaries2 = {}\n    for (s, v) in ((summaries, values), (summaries2, values2)):\n        ky = set(v.keys()) & set(s.keys())\n        ky = list(ky)\n        if len(ky) > 0:\n            raise ValueError('One or more variable names are contained in both `summaries` and `values`:' + ', '.join(ky))\n    return (values, summaries, values2, summaries2)",
            "def _check_args(values, summaries, values2, summaries2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if values is None:\n        values = {}\n    if values2 is None:\n        values2 = {}\n    if summaries is None:\n        summaries = {}\n    if summaries2 is None:\n        summaries2 = {}\n    for (s, v) in ((summaries, values), (summaries2, values2)):\n        ky = set(v.keys()) & set(s.keys())\n        ky = list(ky)\n        if len(ky) > 0:\n            raise ValueError('One or more variable names are contained in both `summaries` and `values`:' + ', '.join(ky))\n    return (values, summaries, values2, summaries2)"
        ]
    },
    {
        "func_name": "predict_functional",
        "original": "@Appender(_predict_functional_doc)\ndef predict_functional(result, focus_var, summaries=None, values=None, summaries2=None, values2=None, alpha=0.05, ci_method='pointwise', linear=True, num_points=10, exog=None, exog2=None, **kwargs):\n    if ci_method not in ('pointwise', 'scheffe', 'simultaneous'):\n        raise ValueError('confidence band method must be one of `pointwise`, `scheffe`, and `simultaneous`.')\n    contrast = values2 is not None or summaries2 is not None\n    if contrast and (not linear):\n        raise ValueError('`linear` must be True for computing contrasts')\n    model = result.model\n    if exog is not None:\n        if any((x is not None for x in [summaries, summaries2, values, values2])):\n            raise ValueError('if `exog` is provided then do not provide `summaries` or `values`')\n        fexog = exog\n        dexog = patsy.dmatrix(model.data.design_info, fexog, return_type='dataframe')\n        fvals = exog[focus_var]\n        if exog2 is not None:\n            fexog2 = exog\n            dexog2 = patsy.dmatrix(model.data.design_info, fexog2, return_type='dataframe')\n            fvals2 = fvals\n    else:\n        (values, summaries, values2, summaries2) = _check_args(values, summaries, values2, summaries2)\n        (dexog, fexog, fvals) = _make_exog(result, focus_var, summaries, values, num_points)\n        if len(summaries2) + len(values2) > 0:\n            (dexog2, fexog2, fvals2) = _make_exog(result, focus_var, summaries2, values2, num_points)\n    from statsmodels.genmod.generalized_linear_model import GLM\n    from statsmodels.genmod.generalized_estimating_equations import GEE\n    if isinstance(result.model, (GLM, GEE)):\n        kwargs_pred = kwargs.copy()\n        kwargs_pred.update({'which': 'linear'})\n    else:\n        kwargs_pred = kwargs\n    pred = result.predict(exog=fexog, **kwargs_pred)\n    if contrast:\n        pred2 = result.predict(exog=fexog2, **kwargs_pred)\n        pred = pred - pred2\n        dexog = dexog - dexog2\n    if ci_method == 'pointwise':\n        t_test = result.t_test(dexog)\n        cb = t_test.conf_int(alpha=alpha)\n    elif ci_method == 'scheffe':\n        t_test = result.t_test(dexog)\n        sd = t_test.sd\n        cb = np.zeros((num_points, 2))\n        from scipy.stats.distributions import f as fdist\n        df1 = result.model.exog.shape[1]\n        df2 = result.model.exog.shape[0] - df1\n        qf = fdist.cdf(1 - alpha, df1, df2)\n        fx = sd * np.sqrt(df1 * qf)\n        cb[:, 0] = pred - fx\n        cb[:, 1] = pred + fx\n    elif ci_method == 'simultaneous':\n        (sigma, c) = _glm_basic_scr(result, dexog, alpha)\n        cb = np.zeros((dexog.shape[0], 2))\n        cb[:, 0] = pred - c * sigma\n        cb[:, 1] = pred + c * sigma\n    if not linear:\n        link = result.family.link\n        pred = link.inverse(pred)\n        cb = link.inverse(cb)\n    return (pred, cb, fvals)",
        "mutated": [
            "@Appender(_predict_functional_doc)\ndef predict_functional(result, focus_var, summaries=None, values=None, summaries2=None, values2=None, alpha=0.05, ci_method='pointwise', linear=True, num_points=10, exog=None, exog2=None, **kwargs):\n    if False:\n        i = 10\n    if ci_method not in ('pointwise', 'scheffe', 'simultaneous'):\n        raise ValueError('confidence band method must be one of `pointwise`, `scheffe`, and `simultaneous`.')\n    contrast = values2 is not None or summaries2 is not None\n    if contrast and (not linear):\n        raise ValueError('`linear` must be True for computing contrasts')\n    model = result.model\n    if exog is not None:\n        if any((x is not None for x in [summaries, summaries2, values, values2])):\n            raise ValueError('if `exog` is provided then do not provide `summaries` or `values`')\n        fexog = exog\n        dexog = patsy.dmatrix(model.data.design_info, fexog, return_type='dataframe')\n        fvals = exog[focus_var]\n        if exog2 is not None:\n            fexog2 = exog\n            dexog2 = patsy.dmatrix(model.data.design_info, fexog2, return_type='dataframe')\n            fvals2 = fvals\n    else:\n        (values, summaries, values2, summaries2) = _check_args(values, summaries, values2, summaries2)\n        (dexog, fexog, fvals) = _make_exog(result, focus_var, summaries, values, num_points)\n        if len(summaries2) + len(values2) > 0:\n            (dexog2, fexog2, fvals2) = _make_exog(result, focus_var, summaries2, values2, num_points)\n    from statsmodels.genmod.generalized_linear_model import GLM\n    from statsmodels.genmod.generalized_estimating_equations import GEE\n    if isinstance(result.model, (GLM, GEE)):\n        kwargs_pred = kwargs.copy()\n        kwargs_pred.update({'which': 'linear'})\n    else:\n        kwargs_pred = kwargs\n    pred = result.predict(exog=fexog, **kwargs_pred)\n    if contrast:\n        pred2 = result.predict(exog=fexog2, **kwargs_pred)\n        pred = pred - pred2\n        dexog = dexog - dexog2\n    if ci_method == 'pointwise':\n        t_test = result.t_test(dexog)\n        cb = t_test.conf_int(alpha=alpha)\n    elif ci_method == 'scheffe':\n        t_test = result.t_test(dexog)\n        sd = t_test.sd\n        cb = np.zeros((num_points, 2))\n        from scipy.stats.distributions import f as fdist\n        df1 = result.model.exog.shape[1]\n        df2 = result.model.exog.shape[0] - df1\n        qf = fdist.cdf(1 - alpha, df1, df2)\n        fx = sd * np.sqrt(df1 * qf)\n        cb[:, 0] = pred - fx\n        cb[:, 1] = pred + fx\n    elif ci_method == 'simultaneous':\n        (sigma, c) = _glm_basic_scr(result, dexog, alpha)\n        cb = np.zeros((dexog.shape[0], 2))\n        cb[:, 0] = pred - c * sigma\n        cb[:, 1] = pred + c * sigma\n    if not linear:\n        link = result.family.link\n        pred = link.inverse(pred)\n        cb = link.inverse(cb)\n    return (pred, cb, fvals)",
            "@Appender(_predict_functional_doc)\ndef predict_functional(result, focus_var, summaries=None, values=None, summaries2=None, values2=None, alpha=0.05, ci_method='pointwise', linear=True, num_points=10, exog=None, exog2=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if ci_method not in ('pointwise', 'scheffe', 'simultaneous'):\n        raise ValueError('confidence band method must be one of `pointwise`, `scheffe`, and `simultaneous`.')\n    contrast = values2 is not None or summaries2 is not None\n    if contrast and (not linear):\n        raise ValueError('`linear` must be True for computing contrasts')\n    model = result.model\n    if exog is not None:\n        if any((x is not None for x in [summaries, summaries2, values, values2])):\n            raise ValueError('if `exog` is provided then do not provide `summaries` or `values`')\n        fexog = exog\n        dexog = patsy.dmatrix(model.data.design_info, fexog, return_type='dataframe')\n        fvals = exog[focus_var]\n        if exog2 is not None:\n            fexog2 = exog\n            dexog2 = patsy.dmatrix(model.data.design_info, fexog2, return_type='dataframe')\n            fvals2 = fvals\n    else:\n        (values, summaries, values2, summaries2) = _check_args(values, summaries, values2, summaries2)\n        (dexog, fexog, fvals) = _make_exog(result, focus_var, summaries, values, num_points)\n        if len(summaries2) + len(values2) > 0:\n            (dexog2, fexog2, fvals2) = _make_exog(result, focus_var, summaries2, values2, num_points)\n    from statsmodels.genmod.generalized_linear_model import GLM\n    from statsmodels.genmod.generalized_estimating_equations import GEE\n    if isinstance(result.model, (GLM, GEE)):\n        kwargs_pred = kwargs.copy()\n        kwargs_pred.update({'which': 'linear'})\n    else:\n        kwargs_pred = kwargs\n    pred = result.predict(exog=fexog, **kwargs_pred)\n    if contrast:\n        pred2 = result.predict(exog=fexog2, **kwargs_pred)\n        pred = pred - pred2\n        dexog = dexog - dexog2\n    if ci_method == 'pointwise':\n        t_test = result.t_test(dexog)\n        cb = t_test.conf_int(alpha=alpha)\n    elif ci_method == 'scheffe':\n        t_test = result.t_test(dexog)\n        sd = t_test.sd\n        cb = np.zeros((num_points, 2))\n        from scipy.stats.distributions import f as fdist\n        df1 = result.model.exog.shape[1]\n        df2 = result.model.exog.shape[0] - df1\n        qf = fdist.cdf(1 - alpha, df1, df2)\n        fx = sd * np.sqrt(df1 * qf)\n        cb[:, 0] = pred - fx\n        cb[:, 1] = pred + fx\n    elif ci_method == 'simultaneous':\n        (sigma, c) = _glm_basic_scr(result, dexog, alpha)\n        cb = np.zeros((dexog.shape[0], 2))\n        cb[:, 0] = pred - c * sigma\n        cb[:, 1] = pred + c * sigma\n    if not linear:\n        link = result.family.link\n        pred = link.inverse(pred)\n        cb = link.inverse(cb)\n    return (pred, cb, fvals)",
            "@Appender(_predict_functional_doc)\ndef predict_functional(result, focus_var, summaries=None, values=None, summaries2=None, values2=None, alpha=0.05, ci_method='pointwise', linear=True, num_points=10, exog=None, exog2=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if ci_method not in ('pointwise', 'scheffe', 'simultaneous'):\n        raise ValueError('confidence band method must be one of `pointwise`, `scheffe`, and `simultaneous`.')\n    contrast = values2 is not None or summaries2 is not None\n    if contrast and (not linear):\n        raise ValueError('`linear` must be True for computing contrasts')\n    model = result.model\n    if exog is not None:\n        if any((x is not None for x in [summaries, summaries2, values, values2])):\n            raise ValueError('if `exog` is provided then do not provide `summaries` or `values`')\n        fexog = exog\n        dexog = patsy.dmatrix(model.data.design_info, fexog, return_type='dataframe')\n        fvals = exog[focus_var]\n        if exog2 is not None:\n            fexog2 = exog\n            dexog2 = patsy.dmatrix(model.data.design_info, fexog2, return_type='dataframe')\n            fvals2 = fvals\n    else:\n        (values, summaries, values2, summaries2) = _check_args(values, summaries, values2, summaries2)\n        (dexog, fexog, fvals) = _make_exog(result, focus_var, summaries, values, num_points)\n        if len(summaries2) + len(values2) > 0:\n            (dexog2, fexog2, fvals2) = _make_exog(result, focus_var, summaries2, values2, num_points)\n    from statsmodels.genmod.generalized_linear_model import GLM\n    from statsmodels.genmod.generalized_estimating_equations import GEE\n    if isinstance(result.model, (GLM, GEE)):\n        kwargs_pred = kwargs.copy()\n        kwargs_pred.update({'which': 'linear'})\n    else:\n        kwargs_pred = kwargs\n    pred = result.predict(exog=fexog, **kwargs_pred)\n    if contrast:\n        pred2 = result.predict(exog=fexog2, **kwargs_pred)\n        pred = pred - pred2\n        dexog = dexog - dexog2\n    if ci_method == 'pointwise':\n        t_test = result.t_test(dexog)\n        cb = t_test.conf_int(alpha=alpha)\n    elif ci_method == 'scheffe':\n        t_test = result.t_test(dexog)\n        sd = t_test.sd\n        cb = np.zeros((num_points, 2))\n        from scipy.stats.distributions import f as fdist\n        df1 = result.model.exog.shape[1]\n        df2 = result.model.exog.shape[0] - df1\n        qf = fdist.cdf(1 - alpha, df1, df2)\n        fx = sd * np.sqrt(df1 * qf)\n        cb[:, 0] = pred - fx\n        cb[:, 1] = pred + fx\n    elif ci_method == 'simultaneous':\n        (sigma, c) = _glm_basic_scr(result, dexog, alpha)\n        cb = np.zeros((dexog.shape[0], 2))\n        cb[:, 0] = pred - c * sigma\n        cb[:, 1] = pred + c * sigma\n    if not linear:\n        link = result.family.link\n        pred = link.inverse(pred)\n        cb = link.inverse(cb)\n    return (pred, cb, fvals)",
            "@Appender(_predict_functional_doc)\ndef predict_functional(result, focus_var, summaries=None, values=None, summaries2=None, values2=None, alpha=0.05, ci_method='pointwise', linear=True, num_points=10, exog=None, exog2=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if ci_method not in ('pointwise', 'scheffe', 'simultaneous'):\n        raise ValueError('confidence band method must be one of `pointwise`, `scheffe`, and `simultaneous`.')\n    contrast = values2 is not None or summaries2 is not None\n    if contrast and (not linear):\n        raise ValueError('`linear` must be True for computing contrasts')\n    model = result.model\n    if exog is not None:\n        if any((x is not None for x in [summaries, summaries2, values, values2])):\n            raise ValueError('if `exog` is provided then do not provide `summaries` or `values`')\n        fexog = exog\n        dexog = patsy.dmatrix(model.data.design_info, fexog, return_type='dataframe')\n        fvals = exog[focus_var]\n        if exog2 is not None:\n            fexog2 = exog\n            dexog2 = patsy.dmatrix(model.data.design_info, fexog2, return_type='dataframe')\n            fvals2 = fvals\n    else:\n        (values, summaries, values2, summaries2) = _check_args(values, summaries, values2, summaries2)\n        (dexog, fexog, fvals) = _make_exog(result, focus_var, summaries, values, num_points)\n        if len(summaries2) + len(values2) > 0:\n            (dexog2, fexog2, fvals2) = _make_exog(result, focus_var, summaries2, values2, num_points)\n    from statsmodels.genmod.generalized_linear_model import GLM\n    from statsmodels.genmod.generalized_estimating_equations import GEE\n    if isinstance(result.model, (GLM, GEE)):\n        kwargs_pred = kwargs.copy()\n        kwargs_pred.update({'which': 'linear'})\n    else:\n        kwargs_pred = kwargs\n    pred = result.predict(exog=fexog, **kwargs_pred)\n    if contrast:\n        pred2 = result.predict(exog=fexog2, **kwargs_pred)\n        pred = pred - pred2\n        dexog = dexog - dexog2\n    if ci_method == 'pointwise':\n        t_test = result.t_test(dexog)\n        cb = t_test.conf_int(alpha=alpha)\n    elif ci_method == 'scheffe':\n        t_test = result.t_test(dexog)\n        sd = t_test.sd\n        cb = np.zeros((num_points, 2))\n        from scipy.stats.distributions import f as fdist\n        df1 = result.model.exog.shape[1]\n        df2 = result.model.exog.shape[0] - df1\n        qf = fdist.cdf(1 - alpha, df1, df2)\n        fx = sd * np.sqrt(df1 * qf)\n        cb[:, 0] = pred - fx\n        cb[:, 1] = pred + fx\n    elif ci_method == 'simultaneous':\n        (sigma, c) = _glm_basic_scr(result, dexog, alpha)\n        cb = np.zeros((dexog.shape[0], 2))\n        cb[:, 0] = pred - c * sigma\n        cb[:, 1] = pred + c * sigma\n    if not linear:\n        link = result.family.link\n        pred = link.inverse(pred)\n        cb = link.inverse(cb)\n    return (pred, cb, fvals)",
            "@Appender(_predict_functional_doc)\ndef predict_functional(result, focus_var, summaries=None, values=None, summaries2=None, values2=None, alpha=0.05, ci_method='pointwise', linear=True, num_points=10, exog=None, exog2=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if ci_method not in ('pointwise', 'scheffe', 'simultaneous'):\n        raise ValueError('confidence band method must be one of `pointwise`, `scheffe`, and `simultaneous`.')\n    contrast = values2 is not None or summaries2 is not None\n    if contrast and (not linear):\n        raise ValueError('`linear` must be True for computing contrasts')\n    model = result.model\n    if exog is not None:\n        if any((x is not None for x in [summaries, summaries2, values, values2])):\n            raise ValueError('if `exog` is provided then do not provide `summaries` or `values`')\n        fexog = exog\n        dexog = patsy.dmatrix(model.data.design_info, fexog, return_type='dataframe')\n        fvals = exog[focus_var]\n        if exog2 is not None:\n            fexog2 = exog\n            dexog2 = patsy.dmatrix(model.data.design_info, fexog2, return_type='dataframe')\n            fvals2 = fvals\n    else:\n        (values, summaries, values2, summaries2) = _check_args(values, summaries, values2, summaries2)\n        (dexog, fexog, fvals) = _make_exog(result, focus_var, summaries, values, num_points)\n        if len(summaries2) + len(values2) > 0:\n            (dexog2, fexog2, fvals2) = _make_exog(result, focus_var, summaries2, values2, num_points)\n    from statsmodels.genmod.generalized_linear_model import GLM\n    from statsmodels.genmod.generalized_estimating_equations import GEE\n    if isinstance(result.model, (GLM, GEE)):\n        kwargs_pred = kwargs.copy()\n        kwargs_pred.update({'which': 'linear'})\n    else:\n        kwargs_pred = kwargs\n    pred = result.predict(exog=fexog, **kwargs_pred)\n    if contrast:\n        pred2 = result.predict(exog=fexog2, **kwargs_pred)\n        pred = pred - pred2\n        dexog = dexog - dexog2\n    if ci_method == 'pointwise':\n        t_test = result.t_test(dexog)\n        cb = t_test.conf_int(alpha=alpha)\n    elif ci_method == 'scheffe':\n        t_test = result.t_test(dexog)\n        sd = t_test.sd\n        cb = np.zeros((num_points, 2))\n        from scipy.stats.distributions import f as fdist\n        df1 = result.model.exog.shape[1]\n        df2 = result.model.exog.shape[0] - df1\n        qf = fdist.cdf(1 - alpha, df1, df2)\n        fx = sd * np.sqrt(df1 * qf)\n        cb[:, 0] = pred - fx\n        cb[:, 1] = pred + fx\n    elif ci_method == 'simultaneous':\n        (sigma, c) = _glm_basic_scr(result, dexog, alpha)\n        cb = np.zeros((dexog.shape[0], 2))\n        cb[:, 0] = pred - c * sigma\n        cb[:, 1] = pred + c * sigma\n    if not linear:\n        link = result.family.link\n        pred = link.inverse(pred)\n        cb = link.inverse(cb)\n    return (pred, cb, fvals)"
        ]
    },
    {
        "func_name": "func",
        "original": "def func(c):\n    return kappa_0 * np.exp(-c ** 2 / 2) / np.pi + 2 * (1 - norm.cdf(c)) - alpha",
        "mutated": [
            "def func(c):\n    if False:\n        i = 10\n    return kappa_0 * np.exp(-c ** 2 / 2) / np.pi + 2 * (1 - norm.cdf(c)) - alpha",
            "def func(c):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return kappa_0 * np.exp(-c ** 2 / 2) / np.pi + 2 * (1 - norm.cdf(c)) - alpha",
            "def func(c):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return kappa_0 * np.exp(-c ** 2 / 2) / np.pi + 2 * (1 - norm.cdf(c)) - alpha",
            "def func(c):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return kappa_0 * np.exp(-c ** 2 / 2) / np.pi + 2 * (1 - norm.cdf(c)) - alpha",
            "def func(c):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return kappa_0 * np.exp(-c ** 2 / 2) / np.pi + 2 * (1 - norm.cdf(c)) - alpha"
        ]
    },
    {
        "func_name": "_glm_basic_scr",
        "original": "def _glm_basic_scr(result, exog, alpha):\n    \"\"\"\n    The basic SCR from (Sun et al. Annals of Statistics 2000).\n\n    Computes simultaneous confidence regions (SCR).\n\n    Parameters\n    ----------\n    result : results instance\n        The fitted GLM results instance\n    exog : array_like\n        The exog values spanning the interval\n    alpha : float\n        `1 - alpha` is the coverage probability.\n\n    Returns\n    -------\n    An array with two columns, containing the lower and upper\n    confidence bounds, respectively.\n\n    Notes\n    -----\n    The rows of `exog` should be a sequence of covariate values\n    obtained by taking one 'free variable' x and varying it over an\n    interval.  The matrix `exog` is thus the basis functions and any\n    other covariates evaluated as x varies.\n    \"\"\"\n    model = result.model\n    n = model.exog.shape[0]\n    cov = result.cov_params()\n    hess = np.linalg.inv(cov)\n    A = hess / n\n    B = np.linalg.cholesky(A).T\n    sigma2 = (np.dot(exog, cov) * exog).sum(1)\n    sigma = np.asarray(np.sqrt(sigma2))\n    bz = np.linalg.solve(B.T, exog.T).T\n    bz /= np.sqrt(n)\n    bz /= sigma[:, None]\n    bzd = np.diff(bz, 1, axis=0)\n    bzdn = (bzd ** 2).sum(1)\n    kappa_0 = np.sqrt(bzdn).sum()\n    from scipy.stats.distributions import norm\n\n    def func(c):\n        return kappa_0 * np.exp(-c ** 2 / 2) / np.pi + 2 * (1 - norm.cdf(c)) - alpha\n    from scipy.optimize import brentq\n    (c, rslt) = brentq(func, 1, 10, full_output=True)\n    if not rslt.converged:\n        raise ValueError('Root finding error in basic SCR')\n    return (sigma, c)",
        "mutated": [
            "def _glm_basic_scr(result, exog, alpha):\n    if False:\n        i = 10\n    \"\\n    The basic SCR from (Sun et al. Annals of Statistics 2000).\\n\\n    Computes simultaneous confidence regions (SCR).\\n\\n    Parameters\\n    ----------\\n    result : results instance\\n        The fitted GLM results instance\\n    exog : array_like\\n        The exog values spanning the interval\\n    alpha : float\\n        `1 - alpha` is the coverage probability.\\n\\n    Returns\\n    -------\\n    An array with two columns, containing the lower and upper\\n    confidence bounds, respectively.\\n\\n    Notes\\n    -----\\n    The rows of `exog` should be a sequence of covariate values\\n    obtained by taking one 'free variable' x and varying it over an\\n    interval.  The matrix `exog` is thus the basis functions and any\\n    other covariates evaluated as x varies.\\n    \"\n    model = result.model\n    n = model.exog.shape[0]\n    cov = result.cov_params()\n    hess = np.linalg.inv(cov)\n    A = hess / n\n    B = np.linalg.cholesky(A).T\n    sigma2 = (np.dot(exog, cov) * exog).sum(1)\n    sigma = np.asarray(np.sqrt(sigma2))\n    bz = np.linalg.solve(B.T, exog.T).T\n    bz /= np.sqrt(n)\n    bz /= sigma[:, None]\n    bzd = np.diff(bz, 1, axis=0)\n    bzdn = (bzd ** 2).sum(1)\n    kappa_0 = np.sqrt(bzdn).sum()\n    from scipy.stats.distributions import norm\n\n    def func(c):\n        return kappa_0 * np.exp(-c ** 2 / 2) / np.pi + 2 * (1 - norm.cdf(c)) - alpha\n    from scipy.optimize import brentq\n    (c, rslt) = brentq(func, 1, 10, full_output=True)\n    if not rslt.converged:\n        raise ValueError('Root finding error in basic SCR')\n    return (sigma, c)",
            "def _glm_basic_scr(result, exog, alpha):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    The basic SCR from (Sun et al. Annals of Statistics 2000).\\n\\n    Computes simultaneous confidence regions (SCR).\\n\\n    Parameters\\n    ----------\\n    result : results instance\\n        The fitted GLM results instance\\n    exog : array_like\\n        The exog values spanning the interval\\n    alpha : float\\n        `1 - alpha` is the coverage probability.\\n\\n    Returns\\n    -------\\n    An array with two columns, containing the lower and upper\\n    confidence bounds, respectively.\\n\\n    Notes\\n    -----\\n    The rows of `exog` should be a sequence of covariate values\\n    obtained by taking one 'free variable' x and varying it over an\\n    interval.  The matrix `exog` is thus the basis functions and any\\n    other covariates evaluated as x varies.\\n    \"\n    model = result.model\n    n = model.exog.shape[0]\n    cov = result.cov_params()\n    hess = np.linalg.inv(cov)\n    A = hess / n\n    B = np.linalg.cholesky(A).T\n    sigma2 = (np.dot(exog, cov) * exog).sum(1)\n    sigma = np.asarray(np.sqrt(sigma2))\n    bz = np.linalg.solve(B.T, exog.T).T\n    bz /= np.sqrt(n)\n    bz /= sigma[:, None]\n    bzd = np.diff(bz, 1, axis=0)\n    bzdn = (bzd ** 2).sum(1)\n    kappa_0 = np.sqrt(bzdn).sum()\n    from scipy.stats.distributions import norm\n\n    def func(c):\n        return kappa_0 * np.exp(-c ** 2 / 2) / np.pi + 2 * (1 - norm.cdf(c)) - alpha\n    from scipy.optimize import brentq\n    (c, rslt) = brentq(func, 1, 10, full_output=True)\n    if not rslt.converged:\n        raise ValueError('Root finding error in basic SCR')\n    return (sigma, c)",
            "def _glm_basic_scr(result, exog, alpha):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    The basic SCR from (Sun et al. Annals of Statistics 2000).\\n\\n    Computes simultaneous confidence regions (SCR).\\n\\n    Parameters\\n    ----------\\n    result : results instance\\n        The fitted GLM results instance\\n    exog : array_like\\n        The exog values spanning the interval\\n    alpha : float\\n        `1 - alpha` is the coverage probability.\\n\\n    Returns\\n    -------\\n    An array with two columns, containing the lower and upper\\n    confidence bounds, respectively.\\n\\n    Notes\\n    -----\\n    The rows of `exog` should be a sequence of covariate values\\n    obtained by taking one 'free variable' x and varying it over an\\n    interval.  The matrix `exog` is thus the basis functions and any\\n    other covariates evaluated as x varies.\\n    \"\n    model = result.model\n    n = model.exog.shape[0]\n    cov = result.cov_params()\n    hess = np.linalg.inv(cov)\n    A = hess / n\n    B = np.linalg.cholesky(A).T\n    sigma2 = (np.dot(exog, cov) * exog).sum(1)\n    sigma = np.asarray(np.sqrt(sigma2))\n    bz = np.linalg.solve(B.T, exog.T).T\n    bz /= np.sqrt(n)\n    bz /= sigma[:, None]\n    bzd = np.diff(bz, 1, axis=0)\n    bzdn = (bzd ** 2).sum(1)\n    kappa_0 = np.sqrt(bzdn).sum()\n    from scipy.stats.distributions import norm\n\n    def func(c):\n        return kappa_0 * np.exp(-c ** 2 / 2) / np.pi + 2 * (1 - norm.cdf(c)) - alpha\n    from scipy.optimize import brentq\n    (c, rslt) = brentq(func, 1, 10, full_output=True)\n    if not rslt.converged:\n        raise ValueError('Root finding error in basic SCR')\n    return (sigma, c)",
            "def _glm_basic_scr(result, exog, alpha):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    The basic SCR from (Sun et al. Annals of Statistics 2000).\\n\\n    Computes simultaneous confidence regions (SCR).\\n\\n    Parameters\\n    ----------\\n    result : results instance\\n        The fitted GLM results instance\\n    exog : array_like\\n        The exog values spanning the interval\\n    alpha : float\\n        `1 - alpha` is the coverage probability.\\n\\n    Returns\\n    -------\\n    An array with two columns, containing the lower and upper\\n    confidence bounds, respectively.\\n\\n    Notes\\n    -----\\n    The rows of `exog` should be a sequence of covariate values\\n    obtained by taking one 'free variable' x and varying it over an\\n    interval.  The matrix `exog` is thus the basis functions and any\\n    other covariates evaluated as x varies.\\n    \"\n    model = result.model\n    n = model.exog.shape[0]\n    cov = result.cov_params()\n    hess = np.linalg.inv(cov)\n    A = hess / n\n    B = np.linalg.cholesky(A).T\n    sigma2 = (np.dot(exog, cov) * exog).sum(1)\n    sigma = np.asarray(np.sqrt(sigma2))\n    bz = np.linalg.solve(B.T, exog.T).T\n    bz /= np.sqrt(n)\n    bz /= sigma[:, None]\n    bzd = np.diff(bz, 1, axis=0)\n    bzdn = (bzd ** 2).sum(1)\n    kappa_0 = np.sqrt(bzdn).sum()\n    from scipy.stats.distributions import norm\n\n    def func(c):\n        return kappa_0 * np.exp(-c ** 2 / 2) / np.pi + 2 * (1 - norm.cdf(c)) - alpha\n    from scipy.optimize import brentq\n    (c, rslt) = brentq(func, 1, 10, full_output=True)\n    if not rslt.converged:\n        raise ValueError('Root finding error in basic SCR')\n    return (sigma, c)",
            "def _glm_basic_scr(result, exog, alpha):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    The basic SCR from (Sun et al. Annals of Statistics 2000).\\n\\n    Computes simultaneous confidence regions (SCR).\\n\\n    Parameters\\n    ----------\\n    result : results instance\\n        The fitted GLM results instance\\n    exog : array_like\\n        The exog values spanning the interval\\n    alpha : float\\n        `1 - alpha` is the coverage probability.\\n\\n    Returns\\n    -------\\n    An array with two columns, containing the lower and upper\\n    confidence bounds, respectively.\\n\\n    Notes\\n    -----\\n    The rows of `exog` should be a sequence of covariate values\\n    obtained by taking one 'free variable' x and varying it over an\\n    interval.  The matrix `exog` is thus the basis functions and any\\n    other covariates evaluated as x varies.\\n    \"\n    model = result.model\n    n = model.exog.shape[0]\n    cov = result.cov_params()\n    hess = np.linalg.inv(cov)\n    A = hess / n\n    B = np.linalg.cholesky(A).T\n    sigma2 = (np.dot(exog, cov) * exog).sum(1)\n    sigma = np.asarray(np.sqrt(sigma2))\n    bz = np.linalg.solve(B.T, exog.T).T\n    bz /= np.sqrt(n)\n    bz /= sigma[:, None]\n    bzd = np.diff(bz, 1, axis=0)\n    bzdn = (bzd ** 2).sum(1)\n    kappa_0 = np.sqrt(bzdn).sum()\n    from scipy.stats.distributions import norm\n\n    def func(c):\n        return kappa_0 * np.exp(-c ** 2 / 2) / np.pi + 2 * (1 - norm.cdf(c)) - alpha\n    from scipy.optimize import brentq\n    (c, rslt) = brentq(func, 1, 10, full_output=True)\n    if not rslt.converged:\n        raise ValueError('Root finding error in basic SCR')\n    return (sigma, c)"
        ]
    }
]