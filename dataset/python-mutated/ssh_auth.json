[
    {
        "func_name": "_present_test",
        "original": "def _present_test(user, name, enc, comment, options, source, config, fingerprint_hash_type):\n    \"\"\"\n    Run checks for \"present\"\n    \"\"\"\n    result = None\n    if source:\n        keys = __salt__['ssh.check_key_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n        if keys:\n            comment = ''\n            for (key, status) in keys.items():\n                if status == 'exists':\n                    continue\n                comment += f'Set to {status}: {key}\\n'\n            if comment:\n                return (result, comment)\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            return (False, err)\n        else:\n            return (True, f'All host keys in file {source} are already present')\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split()\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    check = __salt__['ssh.check_key'](user, name, enc, comment, options, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if check == 'update':\n        comment = f'Key {name} for user {user} is set to be updated'\n    elif check == 'add':\n        comment = f'Key {name} for user {user} is set to be added'\n    elif check == 'exists':\n        result = True\n        comment = 'The authorized host key {} is already present for user {}'.format(name, user)\n    return (result, comment)",
        "mutated": [
            "def _present_test(user, name, enc, comment, options, source, config, fingerprint_hash_type):\n    if False:\n        i = 10\n    '\\n    Run checks for \"present\"\\n    '\n    result = None\n    if source:\n        keys = __salt__['ssh.check_key_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n        if keys:\n            comment = ''\n            for (key, status) in keys.items():\n                if status == 'exists':\n                    continue\n                comment += f'Set to {status}: {key}\\n'\n            if comment:\n                return (result, comment)\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            return (False, err)\n        else:\n            return (True, f'All host keys in file {source} are already present')\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split()\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    check = __salt__['ssh.check_key'](user, name, enc, comment, options, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if check == 'update':\n        comment = f'Key {name} for user {user} is set to be updated'\n    elif check == 'add':\n        comment = f'Key {name} for user {user} is set to be added'\n    elif check == 'exists':\n        result = True\n        comment = 'The authorized host key {} is already present for user {}'.format(name, user)\n    return (result, comment)",
            "def _present_test(user, name, enc, comment, options, source, config, fingerprint_hash_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Run checks for \"present\"\\n    '\n    result = None\n    if source:\n        keys = __salt__['ssh.check_key_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n        if keys:\n            comment = ''\n            for (key, status) in keys.items():\n                if status == 'exists':\n                    continue\n                comment += f'Set to {status}: {key}\\n'\n            if comment:\n                return (result, comment)\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            return (False, err)\n        else:\n            return (True, f'All host keys in file {source} are already present')\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split()\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    check = __salt__['ssh.check_key'](user, name, enc, comment, options, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if check == 'update':\n        comment = f'Key {name} for user {user} is set to be updated'\n    elif check == 'add':\n        comment = f'Key {name} for user {user} is set to be added'\n    elif check == 'exists':\n        result = True\n        comment = 'The authorized host key {} is already present for user {}'.format(name, user)\n    return (result, comment)",
            "def _present_test(user, name, enc, comment, options, source, config, fingerprint_hash_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Run checks for \"present\"\\n    '\n    result = None\n    if source:\n        keys = __salt__['ssh.check_key_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n        if keys:\n            comment = ''\n            for (key, status) in keys.items():\n                if status == 'exists':\n                    continue\n                comment += f'Set to {status}: {key}\\n'\n            if comment:\n                return (result, comment)\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            return (False, err)\n        else:\n            return (True, f'All host keys in file {source} are already present')\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split()\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    check = __salt__['ssh.check_key'](user, name, enc, comment, options, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if check == 'update':\n        comment = f'Key {name} for user {user} is set to be updated'\n    elif check == 'add':\n        comment = f'Key {name} for user {user} is set to be added'\n    elif check == 'exists':\n        result = True\n        comment = 'The authorized host key {} is already present for user {}'.format(name, user)\n    return (result, comment)",
            "def _present_test(user, name, enc, comment, options, source, config, fingerprint_hash_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Run checks for \"present\"\\n    '\n    result = None\n    if source:\n        keys = __salt__['ssh.check_key_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n        if keys:\n            comment = ''\n            for (key, status) in keys.items():\n                if status == 'exists':\n                    continue\n                comment += f'Set to {status}: {key}\\n'\n            if comment:\n                return (result, comment)\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            return (False, err)\n        else:\n            return (True, f'All host keys in file {source} are already present')\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split()\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    check = __salt__['ssh.check_key'](user, name, enc, comment, options, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if check == 'update':\n        comment = f'Key {name} for user {user} is set to be updated'\n    elif check == 'add':\n        comment = f'Key {name} for user {user} is set to be added'\n    elif check == 'exists':\n        result = True\n        comment = 'The authorized host key {} is already present for user {}'.format(name, user)\n    return (result, comment)",
            "def _present_test(user, name, enc, comment, options, source, config, fingerprint_hash_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Run checks for \"present\"\\n    '\n    result = None\n    if source:\n        keys = __salt__['ssh.check_key_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n        if keys:\n            comment = ''\n            for (key, status) in keys.items():\n                if status == 'exists':\n                    continue\n                comment += f'Set to {status}: {key}\\n'\n            if comment:\n                return (result, comment)\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            return (False, err)\n        else:\n            return (True, f'All host keys in file {source} are already present')\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split()\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    check = __salt__['ssh.check_key'](user, name, enc, comment, options, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if check == 'update':\n        comment = f'Key {name} for user {user} is set to be updated'\n    elif check == 'add':\n        comment = f'Key {name} for user {user} is set to be added'\n    elif check == 'exists':\n        result = True\n        comment = 'The authorized host key {} is already present for user {}'.format(name, user)\n    return (result, comment)"
        ]
    },
    {
        "func_name": "_absent_test",
        "original": "def _absent_test(user, name, enc, comment, options, source, config, fingerprint_hash_type):\n    \"\"\"\n    Run checks for \"absent\"\n    \"\"\"\n    result = None\n    if source:\n        keys = __salt__['ssh.check_key_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n        if keys:\n            comment = ''\n            for (key, status) in list(keys.items()):\n                if status == 'add':\n                    continue\n                comment += f'Set to remove: {key}\\n'\n            if comment:\n                return (result, comment)\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            return (False, err)\n        else:\n            return (True, f'All host keys in file {source} are already absent')\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split()\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    check = __salt__['ssh.check_key'](user, name, enc, comment, options, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if check == 'update' or check == 'exists':\n        comment = f'Key {name} for user {user} is set for removal'\n    else:\n        comment = 'Key is already absent'\n        result = True\n    return (result, comment)",
        "mutated": [
            "def _absent_test(user, name, enc, comment, options, source, config, fingerprint_hash_type):\n    if False:\n        i = 10\n    '\\n    Run checks for \"absent\"\\n    '\n    result = None\n    if source:\n        keys = __salt__['ssh.check_key_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n        if keys:\n            comment = ''\n            for (key, status) in list(keys.items()):\n                if status == 'add':\n                    continue\n                comment += f'Set to remove: {key}\\n'\n            if comment:\n                return (result, comment)\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            return (False, err)\n        else:\n            return (True, f'All host keys in file {source} are already absent')\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split()\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    check = __salt__['ssh.check_key'](user, name, enc, comment, options, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if check == 'update' or check == 'exists':\n        comment = f'Key {name} for user {user} is set for removal'\n    else:\n        comment = 'Key is already absent'\n        result = True\n    return (result, comment)",
            "def _absent_test(user, name, enc, comment, options, source, config, fingerprint_hash_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Run checks for \"absent\"\\n    '\n    result = None\n    if source:\n        keys = __salt__['ssh.check_key_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n        if keys:\n            comment = ''\n            for (key, status) in list(keys.items()):\n                if status == 'add':\n                    continue\n                comment += f'Set to remove: {key}\\n'\n            if comment:\n                return (result, comment)\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            return (False, err)\n        else:\n            return (True, f'All host keys in file {source} are already absent')\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split()\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    check = __salt__['ssh.check_key'](user, name, enc, comment, options, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if check == 'update' or check == 'exists':\n        comment = f'Key {name} for user {user} is set for removal'\n    else:\n        comment = 'Key is already absent'\n        result = True\n    return (result, comment)",
            "def _absent_test(user, name, enc, comment, options, source, config, fingerprint_hash_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Run checks for \"absent\"\\n    '\n    result = None\n    if source:\n        keys = __salt__['ssh.check_key_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n        if keys:\n            comment = ''\n            for (key, status) in list(keys.items()):\n                if status == 'add':\n                    continue\n                comment += f'Set to remove: {key}\\n'\n            if comment:\n                return (result, comment)\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            return (False, err)\n        else:\n            return (True, f'All host keys in file {source} are already absent')\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split()\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    check = __salt__['ssh.check_key'](user, name, enc, comment, options, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if check == 'update' or check == 'exists':\n        comment = f'Key {name} for user {user} is set for removal'\n    else:\n        comment = 'Key is already absent'\n        result = True\n    return (result, comment)",
            "def _absent_test(user, name, enc, comment, options, source, config, fingerprint_hash_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Run checks for \"absent\"\\n    '\n    result = None\n    if source:\n        keys = __salt__['ssh.check_key_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n        if keys:\n            comment = ''\n            for (key, status) in list(keys.items()):\n                if status == 'add':\n                    continue\n                comment += f'Set to remove: {key}\\n'\n            if comment:\n                return (result, comment)\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            return (False, err)\n        else:\n            return (True, f'All host keys in file {source} are already absent')\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split()\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    check = __salt__['ssh.check_key'](user, name, enc, comment, options, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if check == 'update' or check == 'exists':\n        comment = f'Key {name} for user {user} is set for removal'\n    else:\n        comment = 'Key is already absent'\n        result = True\n    return (result, comment)",
            "def _absent_test(user, name, enc, comment, options, source, config, fingerprint_hash_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Run checks for \"absent\"\\n    '\n    result = None\n    if source:\n        keys = __salt__['ssh.check_key_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n        if keys:\n            comment = ''\n            for (key, status) in list(keys.items()):\n                if status == 'add':\n                    continue\n                comment += f'Set to remove: {key}\\n'\n            if comment:\n                return (result, comment)\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            return (False, err)\n        else:\n            return (True, f'All host keys in file {source} are already absent')\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split()\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    check = __salt__['ssh.check_key'](user, name, enc, comment, options, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if check == 'update' or check == 'exists':\n        comment = f'Key {name} for user {user} is set for removal'\n    else:\n        comment = 'Key is already absent'\n        result = True\n    return (result, comment)"
        ]
    },
    {
        "func_name": "present",
        "original": "def present(name, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None, **kwargs):\n    \"\"\"\n    Verifies that the specified SSH key is present for the specified user\n\n    name\n        The SSH key to manage\n\n    user\n        The user who owns the SSH authorized keys file to modify\n\n    enc\n        Defines what type of key is being used, can be ed25519, ecdsa,\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\n\n    comment\n        The comment to be placed with the SSH public key\n\n    source\n        The source file for the key(s). Can contain any number of public keys,\n        in standard \"authorized_keys\" format. If this is set, comment and enc\n        will be ignored.\n\n    .. note::\n        The source file must contain keys in the format ``<enc> <key>\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\n        will need to do the following to retrieve an OpenSSH-compatible public\n        key.\n\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\n           the public key), and click ``Open``.\n        2. Copy the public key from the box labeled ``Public key for pasting\n           into OpenSSH authorized_keys file``.\n        3. Paste it into a new file.\n\n    options\n        The options passed to the key, pass a list object\n\n    config\n        The location of the authorized keys file relative to the user's home\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\n        %h for username and home path supported.\n\n    fingerprint_hash_type\n        The public key fingerprint hash type that the public key fingerprint\n        was originally hashed with. This defaults to ``sha256`` if not specified.\n    \"\"\"\n    ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}\n    if source == '':\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split(None, 2)\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    if __opts__['test']:\n        (ret['result'], ret['comment']) = _present_test(user, name, enc, comment, options or [], source, config, fingerprint_hash_type)\n        return ret\n    if source != '':\n        source_path = __salt__['cp.get_url'](source, None, saltenv=__env__)\n    if source != '' and (not source_path):\n        data = 'no key'\n    elif source != '' and source_path:\n        key = __salt__['cp.get_file_str'](source, saltenv=__env__)\n        filehasoptions = False\n        sshre = re.compile('^(sk-)?(ssh\\\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                data = __salt__['ssh.set_auth_key_from_file'](user, source, config=config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                keyline = keyline.split(' ')\n                key_type = keyline[0]\n                key_value = keyline[1]\n                key_comment = keyline[2] if len(keyline) > 2 else ''\n                data = __salt__['ssh.set_auth_key'](user, key_value, enc=key_type, comment=key_comment, options=options or [], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        data = __salt__['ssh.set_auth_key'](user, name, enc=enc, comment=comment, options=options or [], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if data == 'replace':\n        ret['changes'][name] = 'Updated'\n        ret['comment'] = 'The authorized host key {} for user {} was updated'.format(name, user)\n        return ret\n    elif data == 'no change':\n        ret['comment'] = 'The authorized host key {} is already present for user {}'.format(name, user)\n    elif data == 'new':\n        ret['changes'][name] = 'New'\n        ret['comment'] = 'The authorized host key {} for user {} was added'.format(name, user)\n    elif data == 'no key':\n        ret['result'] = False\n        ret['comment'] = 'Failed to add the ssh key. Source file {} is missing'.format(source)\n    elif data == 'fail':\n        ret['result'] = False\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            ret['comment'] = err\n        else:\n            ret['comment'] = 'Failed to add the ssh key. Is the home directory available, and/or does the key file exist?'\n    elif data == 'invalid' or data == 'Invalid public key':\n        ret['result'] = False\n        ret['comment'] = 'Invalid public ssh key, most likely has spaces or invalid syntax'\n    return ret",
        "mutated": [
            "def present(name, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None, **kwargs):\n    if False:\n        i = 10\n    '\\n    Verifies that the specified SSH key is present for the specified user\\n\\n    name\\n        The SSH key to manage\\n\\n    user\\n        The user who owns the SSH authorized keys file to modify\\n\\n    enc\\n        Defines what type of key is being used, can be ed25519, ecdsa,\\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\\n\\n    comment\\n        The comment to be placed with the SSH public key\\n\\n    source\\n        The source file for the key(s). Can contain any number of public keys,\\n        in standard \"authorized_keys\" format. If this is set, comment and enc\\n        will be ignored.\\n\\n    .. note::\\n        The source file must contain keys in the format ``<enc> <key>\\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\\n        will need to do the following to retrieve an OpenSSH-compatible public\\n        key.\\n\\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\\n           the public key), and click ``Open``.\\n        2. Copy the public key from the box labeled ``Public key for pasting\\n           into OpenSSH authorized_keys file``.\\n        3. Paste it into a new file.\\n\\n    options\\n        The options passed to the key, pass a list object\\n\\n    config\\n        The location of the authorized keys file relative to the user\\'s home\\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\\n        %h for username and home path supported.\\n\\n    fingerprint_hash_type\\n        The public key fingerprint hash type that the public key fingerprint\\n        was originally hashed with. This defaults to ``sha256`` if not specified.\\n    '\n    ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}\n    if source == '':\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split(None, 2)\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    if __opts__['test']:\n        (ret['result'], ret['comment']) = _present_test(user, name, enc, comment, options or [], source, config, fingerprint_hash_type)\n        return ret\n    if source != '':\n        source_path = __salt__['cp.get_url'](source, None, saltenv=__env__)\n    if source != '' and (not source_path):\n        data = 'no key'\n    elif source != '' and source_path:\n        key = __salt__['cp.get_file_str'](source, saltenv=__env__)\n        filehasoptions = False\n        sshre = re.compile('^(sk-)?(ssh\\\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                data = __salt__['ssh.set_auth_key_from_file'](user, source, config=config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                keyline = keyline.split(' ')\n                key_type = keyline[0]\n                key_value = keyline[1]\n                key_comment = keyline[2] if len(keyline) > 2 else ''\n                data = __salt__['ssh.set_auth_key'](user, key_value, enc=key_type, comment=key_comment, options=options or [], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        data = __salt__['ssh.set_auth_key'](user, name, enc=enc, comment=comment, options=options or [], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if data == 'replace':\n        ret['changes'][name] = 'Updated'\n        ret['comment'] = 'The authorized host key {} for user {} was updated'.format(name, user)\n        return ret\n    elif data == 'no change':\n        ret['comment'] = 'The authorized host key {} is already present for user {}'.format(name, user)\n    elif data == 'new':\n        ret['changes'][name] = 'New'\n        ret['comment'] = 'The authorized host key {} for user {} was added'.format(name, user)\n    elif data == 'no key':\n        ret['result'] = False\n        ret['comment'] = 'Failed to add the ssh key. Source file {} is missing'.format(source)\n    elif data == 'fail':\n        ret['result'] = False\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            ret['comment'] = err\n        else:\n            ret['comment'] = 'Failed to add the ssh key. Is the home directory available, and/or does the key file exist?'\n    elif data == 'invalid' or data == 'Invalid public key':\n        ret['result'] = False\n        ret['comment'] = 'Invalid public ssh key, most likely has spaces or invalid syntax'\n    return ret",
            "def present(name, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Verifies that the specified SSH key is present for the specified user\\n\\n    name\\n        The SSH key to manage\\n\\n    user\\n        The user who owns the SSH authorized keys file to modify\\n\\n    enc\\n        Defines what type of key is being used, can be ed25519, ecdsa,\\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\\n\\n    comment\\n        The comment to be placed with the SSH public key\\n\\n    source\\n        The source file for the key(s). Can contain any number of public keys,\\n        in standard \"authorized_keys\" format. If this is set, comment and enc\\n        will be ignored.\\n\\n    .. note::\\n        The source file must contain keys in the format ``<enc> <key>\\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\\n        will need to do the following to retrieve an OpenSSH-compatible public\\n        key.\\n\\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\\n           the public key), and click ``Open``.\\n        2. Copy the public key from the box labeled ``Public key for pasting\\n           into OpenSSH authorized_keys file``.\\n        3. Paste it into a new file.\\n\\n    options\\n        The options passed to the key, pass a list object\\n\\n    config\\n        The location of the authorized keys file relative to the user\\'s home\\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\\n        %h for username and home path supported.\\n\\n    fingerprint_hash_type\\n        The public key fingerprint hash type that the public key fingerprint\\n        was originally hashed with. This defaults to ``sha256`` if not specified.\\n    '\n    ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}\n    if source == '':\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split(None, 2)\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    if __opts__['test']:\n        (ret['result'], ret['comment']) = _present_test(user, name, enc, comment, options or [], source, config, fingerprint_hash_type)\n        return ret\n    if source != '':\n        source_path = __salt__['cp.get_url'](source, None, saltenv=__env__)\n    if source != '' and (not source_path):\n        data = 'no key'\n    elif source != '' and source_path:\n        key = __salt__['cp.get_file_str'](source, saltenv=__env__)\n        filehasoptions = False\n        sshre = re.compile('^(sk-)?(ssh\\\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                data = __salt__['ssh.set_auth_key_from_file'](user, source, config=config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                keyline = keyline.split(' ')\n                key_type = keyline[0]\n                key_value = keyline[1]\n                key_comment = keyline[2] if len(keyline) > 2 else ''\n                data = __salt__['ssh.set_auth_key'](user, key_value, enc=key_type, comment=key_comment, options=options or [], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        data = __salt__['ssh.set_auth_key'](user, name, enc=enc, comment=comment, options=options or [], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if data == 'replace':\n        ret['changes'][name] = 'Updated'\n        ret['comment'] = 'The authorized host key {} for user {} was updated'.format(name, user)\n        return ret\n    elif data == 'no change':\n        ret['comment'] = 'The authorized host key {} is already present for user {}'.format(name, user)\n    elif data == 'new':\n        ret['changes'][name] = 'New'\n        ret['comment'] = 'The authorized host key {} for user {} was added'.format(name, user)\n    elif data == 'no key':\n        ret['result'] = False\n        ret['comment'] = 'Failed to add the ssh key. Source file {} is missing'.format(source)\n    elif data == 'fail':\n        ret['result'] = False\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            ret['comment'] = err\n        else:\n            ret['comment'] = 'Failed to add the ssh key. Is the home directory available, and/or does the key file exist?'\n    elif data == 'invalid' or data == 'Invalid public key':\n        ret['result'] = False\n        ret['comment'] = 'Invalid public ssh key, most likely has spaces or invalid syntax'\n    return ret",
            "def present(name, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Verifies that the specified SSH key is present for the specified user\\n\\n    name\\n        The SSH key to manage\\n\\n    user\\n        The user who owns the SSH authorized keys file to modify\\n\\n    enc\\n        Defines what type of key is being used, can be ed25519, ecdsa,\\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\\n\\n    comment\\n        The comment to be placed with the SSH public key\\n\\n    source\\n        The source file for the key(s). Can contain any number of public keys,\\n        in standard \"authorized_keys\" format. If this is set, comment and enc\\n        will be ignored.\\n\\n    .. note::\\n        The source file must contain keys in the format ``<enc> <key>\\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\\n        will need to do the following to retrieve an OpenSSH-compatible public\\n        key.\\n\\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\\n           the public key), and click ``Open``.\\n        2. Copy the public key from the box labeled ``Public key for pasting\\n           into OpenSSH authorized_keys file``.\\n        3. Paste it into a new file.\\n\\n    options\\n        The options passed to the key, pass a list object\\n\\n    config\\n        The location of the authorized keys file relative to the user\\'s home\\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\\n        %h for username and home path supported.\\n\\n    fingerprint_hash_type\\n        The public key fingerprint hash type that the public key fingerprint\\n        was originally hashed with. This defaults to ``sha256`` if not specified.\\n    '\n    ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}\n    if source == '':\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split(None, 2)\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    if __opts__['test']:\n        (ret['result'], ret['comment']) = _present_test(user, name, enc, comment, options or [], source, config, fingerprint_hash_type)\n        return ret\n    if source != '':\n        source_path = __salt__['cp.get_url'](source, None, saltenv=__env__)\n    if source != '' and (not source_path):\n        data = 'no key'\n    elif source != '' and source_path:\n        key = __salt__['cp.get_file_str'](source, saltenv=__env__)\n        filehasoptions = False\n        sshre = re.compile('^(sk-)?(ssh\\\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                data = __salt__['ssh.set_auth_key_from_file'](user, source, config=config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                keyline = keyline.split(' ')\n                key_type = keyline[0]\n                key_value = keyline[1]\n                key_comment = keyline[2] if len(keyline) > 2 else ''\n                data = __salt__['ssh.set_auth_key'](user, key_value, enc=key_type, comment=key_comment, options=options or [], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        data = __salt__['ssh.set_auth_key'](user, name, enc=enc, comment=comment, options=options or [], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if data == 'replace':\n        ret['changes'][name] = 'Updated'\n        ret['comment'] = 'The authorized host key {} for user {} was updated'.format(name, user)\n        return ret\n    elif data == 'no change':\n        ret['comment'] = 'The authorized host key {} is already present for user {}'.format(name, user)\n    elif data == 'new':\n        ret['changes'][name] = 'New'\n        ret['comment'] = 'The authorized host key {} for user {} was added'.format(name, user)\n    elif data == 'no key':\n        ret['result'] = False\n        ret['comment'] = 'Failed to add the ssh key. Source file {} is missing'.format(source)\n    elif data == 'fail':\n        ret['result'] = False\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            ret['comment'] = err\n        else:\n            ret['comment'] = 'Failed to add the ssh key. Is the home directory available, and/or does the key file exist?'\n    elif data == 'invalid' or data == 'Invalid public key':\n        ret['result'] = False\n        ret['comment'] = 'Invalid public ssh key, most likely has spaces or invalid syntax'\n    return ret",
            "def present(name, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Verifies that the specified SSH key is present for the specified user\\n\\n    name\\n        The SSH key to manage\\n\\n    user\\n        The user who owns the SSH authorized keys file to modify\\n\\n    enc\\n        Defines what type of key is being used, can be ed25519, ecdsa,\\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\\n\\n    comment\\n        The comment to be placed with the SSH public key\\n\\n    source\\n        The source file for the key(s). Can contain any number of public keys,\\n        in standard \"authorized_keys\" format. If this is set, comment and enc\\n        will be ignored.\\n\\n    .. note::\\n        The source file must contain keys in the format ``<enc> <key>\\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\\n        will need to do the following to retrieve an OpenSSH-compatible public\\n        key.\\n\\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\\n           the public key), and click ``Open``.\\n        2. Copy the public key from the box labeled ``Public key for pasting\\n           into OpenSSH authorized_keys file``.\\n        3. Paste it into a new file.\\n\\n    options\\n        The options passed to the key, pass a list object\\n\\n    config\\n        The location of the authorized keys file relative to the user\\'s home\\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\\n        %h for username and home path supported.\\n\\n    fingerprint_hash_type\\n        The public key fingerprint hash type that the public key fingerprint\\n        was originally hashed with. This defaults to ``sha256`` if not specified.\\n    '\n    ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}\n    if source == '':\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split(None, 2)\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    if __opts__['test']:\n        (ret['result'], ret['comment']) = _present_test(user, name, enc, comment, options or [], source, config, fingerprint_hash_type)\n        return ret\n    if source != '':\n        source_path = __salt__['cp.get_url'](source, None, saltenv=__env__)\n    if source != '' and (not source_path):\n        data = 'no key'\n    elif source != '' and source_path:\n        key = __salt__['cp.get_file_str'](source, saltenv=__env__)\n        filehasoptions = False\n        sshre = re.compile('^(sk-)?(ssh\\\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                data = __salt__['ssh.set_auth_key_from_file'](user, source, config=config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                keyline = keyline.split(' ')\n                key_type = keyline[0]\n                key_value = keyline[1]\n                key_comment = keyline[2] if len(keyline) > 2 else ''\n                data = __salt__['ssh.set_auth_key'](user, key_value, enc=key_type, comment=key_comment, options=options or [], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        data = __salt__['ssh.set_auth_key'](user, name, enc=enc, comment=comment, options=options or [], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if data == 'replace':\n        ret['changes'][name] = 'Updated'\n        ret['comment'] = 'The authorized host key {} for user {} was updated'.format(name, user)\n        return ret\n    elif data == 'no change':\n        ret['comment'] = 'The authorized host key {} is already present for user {}'.format(name, user)\n    elif data == 'new':\n        ret['changes'][name] = 'New'\n        ret['comment'] = 'The authorized host key {} for user {} was added'.format(name, user)\n    elif data == 'no key':\n        ret['result'] = False\n        ret['comment'] = 'Failed to add the ssh key. Source file {} is missing'.format(source)\n    elif data == 'fail':\n        ret['result'] = False\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            ret['comment'] = err\n        else:\n            ret['comment'] = 'Failed to add the ssh key. Is the home directory available, and/or does the key file exist?'\n    elif data == 'invalid' or data == 'Invalid public key':\n        ret['result'] = False\n        ret['comment'] = 'Invalid public ssh key, most likely has spaces or invalid syntax'\n    return ret",
            "def present(name, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Verifies that the specified SSH key is present for the specified user\\n\\n    name\\n        The SSH key to manage\\n\\n    user\\n        The user who owns the SSH authorized keys file to modify\\n\\n    enc\\n        Defines what type of key is being used, can be ed25519, ecdsa,\\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\\n\\n    comment\\n        The comment to be placed with the SSH public key\\n\\n    source\\n        The source file for the key(s). Can contain any number of public keys,\\n        in standard \"authorized_keys\" format. If this is set, comment and enc\\n        will be ignored.\\n\\n    .. note::\\n        The source file must contain keys in the format ``<enc> <key>\\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\\n        will need to do the following to retrieve an OpenSSH-compatible public\\n        key.\\n\\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\\n           the public key), and click ``Open``.\\n        2. Copy the public key from the box labeled ``Public key for pasting\\n           into OpenSSH authorized_keys file``.\\n        3. Paste it into a new file.\\n\\n    options\\n        The options passed to the key, pass a list object\\n\\n    config\\n        The location of the authorized keys file relative to the user\\'s home\\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\\n        %h for username and home path supported.\\n\\n    fingerprint_hash_type\\n        The public key fingerprint hash type that the public key fingerprint\\n        was originally hashed with. This defaults to ``sha256`` if not specified.\\n    '\n    ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}\n    if source == '':\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split(None, 2)\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n    if __opts__['test']:\n        (ret['result'], ret['comment']) = _present_test(user, name, enc, comment, options or [], source, config, fingerprint_hash_type)\n        return ret\n    if source != '':\n        source_path = __salt__['cp.get_url'](source, None, saltenv=__env__)\n    if source != '' and (not source_path):\n        data = 'no key'\n    elif source != '' and source_path:\n        key = __salt__['cp.get_file_str'](source, saltenv=__env__)\n        filehasoptions = False\n        sshre = re.compile('^(sk-)?(ssh\\\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                data = __salt__['ssh.set_auth_key_from_file'](user, source, config=config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                keyline = keyline.split(' ')\n                key_type = keyline[0]\n                key_value = keyline[1]\n                key_comment = keyline[2] if len(keyline) > 2 else ''\n                data = __salt__['ssh.set_auth_key'](user, key_value, enc=key_type, comment=key_comment, options=options or [], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        data = __salt__['ssh.set_auth_key'](user, name, enc=enc, comment=comment, options=options or [], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if data == 'replace':\n        ret['changes'][name] = 'Updated'\n        ret['comment'] = 'The authorized host key {} for user {} was updated'.format(name, user)\n        return ret\n    elif data == 'no change':\n        ret['comment'] = 'The authorized host key {} is already present for user {}'.format(name, user)\n    elif data == 'new':\n        ret['changes'][name] = 'New'\n        ret['comment'] = 'The authorized host key {} for user {} was added'.format(name, user)\n    elif data == 'no key':\n        ret['result'] = False\n        ret['comment'] = 'Failed to add the ssh key. Source file {} is missing'.format(source)\n    elif data == 'fail':\n        ret['result'] = False\n        err = sys.modules[__salt__['test.ping'].__module__].__context__.pop('ssh_auth.error', None)\n        if err:\n            ret['comment'] = err\n        else:\n            ret['comment'] = 'Failed to add the ssh key. Is the home directory available, and/or does the key file exist?'\n    elif data == 'invalid' or data == 'Invalid public key':\n        ret['result'] = False\n        ret['comment'] = 'Invalid public ssh key, most likely has spaces or invalid syntax'\n    return ret"
        ]
    },
    {
        "func_name": "absent",
        "original": "def absent(name, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None):\n    \"\"\"\n    Verifies that the specified SSH key is absent\n\n    name\n        The SSH key to manage\n\n    user\n        The user who owns the SSH authorized keys file to modify\n\n    enc\n        Defines what type of key is being used, can be ed25519, ecdsa,\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\n\n    comment\n        The comment to be placed with the SSH public key\n\n    options\n        The options passed to the key, pass a list object\n\n    source\n        The source file for the key(s). Can contain any number of public keys,\n        in standard \"authorized_keys\" format. If this is set, comment, enc and\n        options will be ignored.\n\n        .. versionadded:: 2015.8.0\n\n    config\n        The location of the authorized keys file relative to the user's home\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\n        %h for username and home path supported.\n\n    fingerprint_hash_type\n        The public key fingerprint hash type that the public key fingerprint\n        was originally hashed with. This defaults to ``sha256`` if not specified.\n\n        .. versionadded:: 2016.11.7\n    \"\"\"\n    ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}\n    if __opts__['test']:\n        (ret['result'], ret['comment']) = _absent_test(user, name, enc, comment, options or [], source, config, fingerprint_hash_type)\n        return ret\n    if source != '':\n        key = __salt__['cp.get_file_str'](source, saltenv=__env__)\n        filehasoptions = False\n        sshre = re.compile('^(sk-)?(ssh\\\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                ret['comment'] = __salt__['ssh.rm_auth_key_from_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                keyline = keyline.split(' ')\n                ret['comment'] = __salt__['ssh.rm_auth_key'](user, keyline[1], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n        ret['comment'] = __salt__['ssh.rm_auth_key'](user, name, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if ret['comment'] == 'User authorized keys file not present':\n        ret['result'] = False\n        return ret\n    elif ret['comment'] == 'Key removed':\n        ret['changes'][name] = 'Removed'\n    return ret",
        "mutated": [
            "def absent(name, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None):\n    if False:\n        i = 10\n    '\\n    Verifies that the specified SSH key is absent\\n\\n    name\\n        The SSH key to manage\\n\\n    user\\n        The user who owns the SSH authorized keys file to modify\\n\\n    enc\\n        Defines what type of key is being used, can be ed25519, ecdsa,\\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\\n\\n    comment\\n        The comment to be placed with the SSH public key\\n\\n    options\\n        The options passed to the key, pass a list object\\n\\n    source\\n        The source file for the key(s). Can contain any number of public keys,\\n        in standard \"authorized_keys\" format. If this is set, comment, enc and\\n        options will be ignored.\\n\\n        .. versionadded:: 2015.8.0\\n\\n    config\\n        The location of the authorized keys file relative to the user\\'s home\\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\\n        %h for username and home path supported.\\n\\n    fingerprint_hash_type\\n        The public key fingerprint hash type that the public key fingerprint\\n        was originally hashed with. This defaults to ``sha256`` if not specified.\\n\\n        .. versionadded:: 2016.11.7\\n    '\n    ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}\n    if __opts__['test']:\n        (ret['result'], ret['comment']) = _absent_test(user, name, enc, comment, options or [], source, config, fingerprint_hash_type)\n        return ret\n    if source != '':\n        key = __salt__['cp.get_file_str'](source, saltenv=__env__)\n        filehasoptions = False\n        sshre = re.compile('^(sk-)?(ssh\\\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                ret['comment'] = __salt__['ssh.rm_auth_key_from_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                keyline = keyline.split(' ')\n                ret['comment'] = __salt__['ssh.rm_auth_key'](user, keyline[1], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n        ret['comment'] = __salt__['ssh.rm_auth_key'](user, name, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if ret['comment'] == 'User authorized keys file not present':\n        ret['result'] = False\n        return ret\n    elif ret['comment'] == 'Key removed':\n        ret['changes'][name] = 'Removed'\n    return ret",
            "def absent(name, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Verifies that the specified SSH key is absent\\n\\n    name\\n        The SSH key to manage\\n\\n    user\\n        The user who owns the SSH authorized keys file to modify\\n\\n    enc\\n        Defines what type of key is being used, can be ed25519, ecdsa,\\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\\n\\n    comment\\n        The comment to be placed with the SSH public key\\n\\n    options\\n        The options passed to the key, pass a list object\\n\\n    source\\n        The source file for the key(s). Can contain any number of public keys,\\n        in standard \"authorized_keys\" format. If this is set, comment, enc and\\n        options will be ignored.\\n\\n        .. versionadded:: 2015.8.0\\n\\n    config\\n        The location of the authorized keys file relative to the user\\'s home\\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\\n        %h for username and home path supported.\\n\\n    fingerprint_hash_type\\n        The public key fingerprint hash type that the public key fingerprint\\n        was originally hashed with. This defaults to ``sha256`` if not specified.\\n\\n        .. versionadded:: 2016.11.7\\n    '\n    ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}\n    if __opts__['test']:\n        (ret['result'], ret['comment']) = _absent_test(user, name, enc, comment, options or [], source, config, fingerprint_hash_type)\n        return ret\n    if source != '':\n        key = __salt__['cp.get_file_str'](source, saltenv=__env__)\n        filehasoptions = False\n        sshre = re.compile('^(sk-)?(ssh\\\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                ret['comment'] = __salt__['ssh.rm_auth_key_from_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                keyline = keyline.split(' ')\n                ret['comment'] = __salt__['ssh.rm_auth_key'](user, keyline[1], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n        ret['comment'] = __salt__['ssh.rm_auth_key'](user, name, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if ret['comment'] == 'User authorized keys file not present':\n        ret['result'] = False\n        return ret\n    elif ret['comment'] == 'Key removed':\n        ret['changes'][name] = 'Removed'\n    return ret",
            "def absent(name, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Verifies that the specified SSH key is absent\\n\\n    name\\n        The SSH key to manage\\n\\n    user\\n        The user who owns the SSH authorized keys file to modify\\n\\n    enc\\n        Defines what type of key is being used, can be ed25519, ecdsa,\\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\\n\\n    comment\\n        The comment to be placed with the SSH public key\\n\\n    options\\n        The options passed to the key, pass a list object\\n\\n    source\\n        The source file for the key(s). Can contain any number of public keys,\\n        in standard \"authorized_keys\" format. If this is set, comment, enc and\\n        options will be ignored.\\n\\n        .. versionadded:: 2015.8.0\\n\\n    config\\n        The location of the authorized keys file relative to the user\\'s home\\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\\n        %h for username and home path supported.\\n\\n    fingerprint_hash_type\\n        The public key fingerprint hash type that the public key fingerprint\\n        was originally hashed with. This defaults to ``sha256`` if not specified.\\n\\n        .. versionadded:: 2016.11.7\\n    '\n    ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}\n    if __opts__['test']:\n        (ret['result'], ret['comment']) = _absent_test(user, name, enc, comment, options or [], source, config, fingerprint_hash_type)\n        return ret\n    if source != '':\n        key = __salt__['cp.get_file_str'](source, saltenv=__env__)\n        filehasoptions = False\n        sshre = re.compile('^(sk-)?(ssh\\\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                ret['comment'] = __salt__['ssh.rm_auth_key_from_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                keyline = keyline.split(' ')\n                ret['comment'] = __salt__['ssh.rm_auth_key'](user, keyline[1], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n        ret['comment'] = __salt__['ssh.rm_auth_key'](user, name, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if ret['comment'] == 'User authorized keys file not present':\n        ret['result'] = False\n        return ret\n    elif ret['comment'] == 'Key removed':\n        ret['changes'][name] = 'Removed'\n    return ret",
            "def absent(name, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Verifies that the specified SSH key is absent\\n\\n    name\\n        The SSH key to manage\\n\\n    user\\n        The user who owns the SSH authorized keys file to modify\\n\\n    enc\\n        Defines what type of key is being used, can be ed25519, ecdsa,\\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\\n\\n    comment\\n        The comment to be placed with the SSH public key\\n\\n    options\\n        The options passed to the key, pass a list object\\n\\n    source\\n        The source file for the key(s). Can contain any number of public keys,\\n        in standard \"authorized_keys\" format. If this is set, comment, enc and\\n        options will be ignored.\\n\\n        .. versionadded:: 2015.8.0\\n\\n    config\\n        The location of the authorized keys file relative to the user\\'s home\\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\\n        %h for username and home path supported.\\n\\n    fingerprint_hash_type\\n        The public key fingerprint hash type that the public key fingerprint\\n        was originally hashed with. This defaults to ``sha256`` if not specified.\\n\\n        .. versionadded:: 2016.11.7\\n    '\n    ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}\n    if __opts__['test']:\n        (ret['result'], ret['comment']) = _absent_test(user, name, enc, comment, options or [], source, config, fingerprint_hash_type)\n        return ret\n    if source != '':\n        key = __salt__['cp.get_file_str'](source, saltenv=__env__)\n        filehasoptions = False\n        sshre = re.compile('^(sk-)?(ssh\\\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                ret['comment'] = __salt__['ssh.rm_auth_key_from_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                keyline = keyline.split(' ')\n                ret['comment'] = __salt__['ssh.rm_auth_key'](user, keyline[1], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n        ret['comment'] = __salt__['ssh.rm_auth_key'](user, name, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if ret['comment'] == 'User authorized keys file not present':\n        ret['result'] = False\n        return ret\n    elif ret['comment'] == 'Key removed':\n        ret['changes'][name] = 'Removed'\n    return ret",
            "def absent(name, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Verifies that the specified SSH key is absent\\n\\n    name\\n        The SSH key to manage\\n\\n    user\\n        The user who owns the SSH authorized keys file to modify\\n\\n    enc\\n        Defines what type of key is being used, can be ed25519, ecdsa,\\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\\n\\n    comment\\n        The comment to be placed with the SSH public key\\n\\n    options\\n        The options passed to the key, pass a list object\\n\\n    source\\n        The source file for the key(s). Can contain any number of public keys,\\n        in standard \"authorized_keys\" format. If this is set, comment, enc and\\n        options will be ignored.\\n\\n        .. versionadded:: 2015.8.0\\n\\n    config\\n        The location of the authorized keys file relative to the user\\'s home\\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\\n        %h for username and home path supported.\\n\\n    fingerprint_hash_type\\n        The public key fingerprint hash type that the public key fingerprint\\n        was originally hashed with. This defaults to ``sha256`` if not specified.\\n\\n        .. versionadded:: 2016.11.7\\n    '\n    ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}\n    if __opts__['test']:\n        (ret['result'], ret['comment']) = _absent_test(user, name, enc, comment, options or [], source, config, fingerprint_hash_type)\n        return ret\n    if source != '':\n        key = __salt__['cp.get_file_str'](source, saltenv=__env__)\n        filehasoptions = False\n        sshre = re.compile('^(sk-)?(ssh\\\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                ret['comment'] = __salt__['ssh.rm_auth_key_from_file'](user, source, config, saltenv=__env__, fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                keyline = keyline.split(' ')\n                ret['comment'] = __salt__['ssh.rm_auth_key'](user, keyline[1], config=config, fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        sshre = re.compile('^(.*?)\\\\s?((?:sk-)?(?:ssh\\\\-|ecds)[\\\\w-]+\\\\s.+)$')\n        fullkey = sshre.search(name)\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n        ret['comment'] = __salt__['ssh.rm_auth_key'](user, name, config=config, fingerprint_hash_type=fingerprint_hash_type)\n    if ret['comment'] == 'User authorized keys file not present':\n        ret['result'] = False\n        return ret\n    elif ret['comment'] == 'Key removed':\n        ret['changes'][name] = 'Removed'\n    return ret"
        ]
    },
    {
        "func_name": "manage",
        "original": "def manage(name, ssh_keys, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None, **kwargs):\n    \"\"\"\n    .. versionadded:: 3000\n\n    Ensures that only the specified ssh_keys are present for the specified user\n\n    ssh_keys\n        The SSH key to manage\n\n    user\n        The user who owns the SSH authorized keys file to modify\n\n    enc\n        Defines what type of key is being used, can be ed25519, ecdsa,\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\n\n    comment\n        The comment to be placed with the SSH public key\n\n    source\n        The source file for the key(s). Can contain any number of public keys,\n        in standard \"authorized_keys\" format. If this is set, comment and enc\n        will be ignored.\n\n    .. note::\n        The source file must contain keys in the format ``<enc> <key>\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\n        will need to do the following to retrieve an OpenSSH-compatible public\n        key.\n\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\n           the public key), and click ``Open``.\n        2. Copy the public key from the box labeled ``Public key for pasting\n           into OpenSSH authorized_keys file``.\n        3. Paste it into a new file.\n\n    options\n        The options passed to the keys, pass a list object\n\n    config\n        The location of the authorized keys file relative to the user's home\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\n        %h for username and home path supported.\n\n    fingerprint_hash_type\n        The public key fingerprint hash type that the public key fingerprint\n        was originally hashed with. This defaults to ``sha256`` if not specified.\n    \"\"\"\n    ret = {'name': '', 'changes': {}, 'result': True, 'comment': ''}\n    all_potential_keys = []\n    for ssh_key in ssh_keys:\n        all_potential_keys.extend(ssh_key.split(' '))\n    existing_keys = __salt__['ssh.auth_keys'](user=user, config=config, fingerprint_hash_type=fingerprint_hash_type).keys()\n    remove_keys = set(existing_keys).difference(all_potential_keys)\n    for remove_key in remove_keys:\n        if __opts__['test']:\n            remove_comment = f'{remove_key} Key set for removal'\n            ret['comment'] = remove_comment\n            ret['result'] = None\n        else:\n            remove_comment = absent(remove_key, user, enc=enc, comment=comment, source=source, options=options, config=config, fingerprint_hash_type=fingerprint_hash_type, **kwargs)['comment']\n            ret['changes'][remove_key] = remove_comment\n    for ssh_key in ssh_keys:\n        run_return = present(ssh_key, user, enc, comment, source, options, config, fingerprint_hash_type, **kwargs)\n        if run_return['changes']:\n            ret['changes'].update(run_return['changes'])\n        else:\n            ret['comment'] += '\\n' + run_return['comment']\n            ret['comment'] = ret['comment'].strip()\n        if run_return['result'] is None:\n            ret['result'] = None\n        elif not run_return['result']:\n            ret['result'] = False\n    return ret",
        "mutated": [
            "def manage(name, ssh_keys, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None, **kwargs):\n    if False:\n        i = 10\n    '\\n    .. versionadded:: 3000\\n\\n    Ensures that only the specified ssh_keys are present for the specified user\\n\\n    ssh_keys\\n        The SSH key to manage\\n\\n    user\\n        The user who owns the SSH authorized keys file to modify\\n\\n    enc\\n        Defines what type of key is being used, can be ed25519, ecdsa,\\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\\n\\n    comment\\n        The comment to be placed with the SSH public key\\n\\n    source\\n        The source file for the key(s). Can contain any number of public keys,\\n        in standard \"authorized_keys\" format. If this is set, comment and enc\\n        will be ignored.\\n\\n    .. note::\\n        The source file must contain keys in the format ``<enc> <key>\\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\\n        will need to do the following to retrieve an OpenSSH-compatible public\\n        key.\\n\\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\\n           the public key), and click ``Open``.\\n        2. Copy the public key from the box labeled ``Public key for pasting\\n           into OpenSSH authorized_keys file``.\\n        3. Paste it into a new file.\\n\\n    options\\n        The options passed to the keys, pass a list object\\n\\n    config\\n        The location of the authorized keys file relative to the user\\'s home\\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\\n        %h for username and home path supported.\\n\\n    fingerprint_hash_type\\n        The public key fingerprint hash type that the public key fingerprint\\n        was originally hashed with. This defaults to ``sha256`` if not specified.\\n    '\n    ret = {'name': '', 'changes': {}, 'result': True, 'comment': ''}\n    all_potential_keys = []\n    for ssh_key in ssh_keys:\n        all_potential_keys.extend(ssh_key.split(' '))\n    existing_keys = __salt__['ssh.auth_keys'](user=user, config=config, fingerprint_hash_type=fingerprint_hash_type).keys()\n    remove_keys = set(existing_keys).difference(all_potential_keys)\n    for remove_key in remove_keys:\n        if __opts__['test']:\n            remove_comment = f'{remove_key} Key set for removal'\n            ret['comment'] = remove_comment\n            ret['result'] = None\n        else:\n            remove_comment = absent(remove_key, user, enc=enc, comment=comment, source=source, options=options, config=config, fingerprint_hash_type=fingerprint_hash_type, **kwargs)['comment']\n            ret['changes'][remove_key] = remove_comment\n    for ssh_key in ssh_keys:\n        run_return = present(ssh_key, user, enc, comment, source, options, config, fingerprint_hash_type, **kwargs)\n        if run_return['changes']:\n            ret['changes'].update(run_return['changes'])\n        else:\n            ret['comment'] += '\\n' + run_return['comment']\n            ret['comment'] = ret['comment'].strip()\n        if run_return['result'] is None:\n            ret['result'] = None\n        elif not run_return['result']:\n            ret['result'] = False\n    return ret",
            "def manage(name, ssh_keys, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    .. versionadded:: 3000\\n\\n    Ensures that only the specified ssh_keys are present for the specified user\\n\\n    ssh_keys\\n        The SSH key to manage\\n\\n    user\\n        The user who owns the SSH authorized keys file to modify\\n\\n    enc\\n        Defines what type of key is being used, can be ed25519, ecdsa,\\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\\n\\n    comment\\n        The comment to be placed with the SSH public key\\n\\n    source\\n        The source file for the key(s). Can contain any number of public keys,\\n        in standard \"authorized_keys\" format. If this is set, comment and enc\\n        will be ignored.\\n\\n    .. note::\\n        The source file must contain keys in the format ``<enc> <key>\\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\\n        will need to do the following to retrieve an OpenSSH-compatible public\\n        key.\\n\\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\\n           the public key), and click ``Open``.\\n        2. Copy the public key from the box labeled ``Public key for pasting\\n           into OpenSSH authorized_keys file``.\\n        3. Paste it into a new file.\\n\\n    options\\n        The options passed to the keys, pass a list object\\n\\n    config\\n        The location of the authorized keys file relative to the user\\'s home\\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\\n        %h for username and home path supported.\\n\\n    fingerprint_hash_type\\n        The public key fingerprint hash type that the public key fingerprint\\n        was originally hashed with. This defaults to ``sha256`` if not specified.\\n    '\n    ret = {'name': '', 'changes': {}, 'result': True, 'comment': ''}\n    all_potential_keys = []\n    for ssh_key in ssh_keys:\n        all_potential_keys.extend(ssh_key.split(' '))\n    existing_keys = __salt__['ssh.auth_keys'](user=user, config=config, fingerprint_hash_type=fingerprint_hash_type).keys()\n    remove_keys = set(existing_keys).difference(all_potential_keys)\n    for remove_key in remove_keys:\n        if __opts__['test']:\n            remove_comment = f'{remove_key} Key set for removal'\n            ret['comment'] = remove_comment\n            ret['result'] = None\n        else:\n            remove_comment = absent(remove_key, user, enc=enc, comment=comment, source=source, options=options, config=config, fingerprint_hash_type=fingerprint_hash_type, **kwargs)['comment']\n            ret['changes'][remove_key] = remove_comment\n    for ssh_key in ssh_keys:\n        run_return = present(ssh_key, user, enc, comment, source, options, config, fingerprint_hash_type, **kwargs)\n        if run_return['changes']:\n            ret['changes'].update(run_return['changes'])\n        else:\n            ret['comment'] += '\\n' + run_return['comment']\n            ret['comment'] = ret['comment'].strip()\n        if run_return['result'] is None:\n            ret['result'] = None\n        elif not run_return['result']:\n            ret['result'] = False\n    return ret",
            "def manage(name, ssh_keys, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    .. versionadded:: 3000\\n\\n    Ensures that only the specified ssh_keys are present for the specified user\\n\\n    ssh_keys\\n        The SSH key to manage\\n\\n    user\\n        The user who owns the SSH authorized keys file to modify\\n\\n    enc\\n        Defines what type of key is being used, can be ed25519, ecdsa,\\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\\n\\n    comment\\n        The comment to be placed with the SSH public key\\n\\n    source\\n        The source file for the key(s). Can contain any number of public keys,\\n        in standard \"authorized_keys\" format. If this is set, comment and enc\\n        will be ignored.\\n\\n    .. note::\\n        The source file must contain keys in the format ``<enc> <key>\\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\\n        will need to do the following to retrieve an OpenSSH-compatible public\\n        key.\\n\\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\\n           the public key), and click ``Open``.\\n        2. Copy the public key from the box labeled ``Public key for pasting\\n           into OpenSSH authorized_keys file``.\\n        3. Paste it into a new file.\\n\\n    options\\n        The options passed to the keys, pass a list object\\n\\n    config\\n        The location of the authorized keys file relative to the user\\'s home\\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\\n        %h for username and home path supported.\\n\\n    fingerprint_hash_type\\n        The public key fingerprint hash type that the public key fingerprint\\n        was originally hashed with. This defaults to ``sha256`` if not specified.\\n    '\n    ret = {'name': '', 'changes': {}, 'result': True, 'comment': ''}\n    all_potential_keys = []\n    for ssh_key in ssh_keys:\n        all_potential_keys.extend(ssh_key.split(' '))\n    existing_keys = __salt__['ssh.auth_keys'](user=user, config=config, fingerprint_hash_type=fingerprint_hash_type).keys()\n    remove_keys = set(existing_keys).difference(all_potential_keys)\n    for remove_key in remove_keys:\n        if __opts__['test']:\n            remove_comment = f'{remove_key} Key set for removal'\n            ret['comment'] = remove_comment\n            ret['result'] = None\n        else:\n            remove_comment = absent(remove_key, user, enc=enc, comment=comment, source=source, options=options, config=config, fingerprint_hash_type=fingerprint_hash_type, **kwargs)['comment']\n            ret['changes'][remove_key] = remove_comment\n    for ssh_key in ssh_keys:\n        run_return = present(ssh_key, user, enc, comment, source, options, config, fingerprint_hash_type, **kwargs)\n        if run_return['changes']:\n            ret['changes'].update(run_return['changes'])\n        else:\n            ret['comment'] += '\\n' + run_return['comment']\n            ret['comment'] = ret['comment'].strip()\n        if run_return['result'] is None:\n            ret['result'] = None\n        elif not run_return['result']:\n            ret['result'] = False\n    return ret",
            "def manage(name, ssh_keys, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    .. versionadded:: 3000\\n\\n    Ensures that only the specified ssh_keys are present for the specified user\\n\\n    ssh_keys\\n        The SSH key to manage\\n\\n    user\\n        The user who owns the SSH authorized keys file to modify\\n\\n    enc\\n        Defines what type of key is being used, can be ed25519, ecdsa,\\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\\n\\n    comment\\n        The comment to be placed with the SSH public key\\n\\n    source\\n        The source file for the key(s). Can contain any number of public keys,\\n        in standard \"authorized_keys\" format. If this is set, comment and enc\\n        will be ignored.\\n\\n    .. note::\\n        The source file must contain keys in the format ``<enc> <key>\\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\\n        will need to do the following to retrieve an OpenSSH-compatible public\\n        key.\\n\\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\\n           the public key), and click ``Open``.\\n        2. Copy the public key from the box labeled ``Public key for pasting\\n           into OpenSSH authorized_keys file``.\\n        3. Paste it into a new file.\\n\\n    options\\n        The options passed to the keys, pass a list object\\n\\n    config\\n        The location of the authorized keys file relative to the user\\'s home\\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\\n        %h for username and home path supported.\\n\\n    fingerprint_hash_type\\n        The public key fingerprint hash type that the public key fingerprint\\n        was originally hashed with. This defaults to ``sha256`` if not specified.\\n    '\n    ret = {'name': '', 'changes': {}, 'result': True, 'comment': ''}\n    all_potential_keys = []\n    for ssh_key in ssh_keys:\n        all_potential_keys.extend(ssh_key.split(' '))\n    existing_keys = __salt__['ssh.auth_keys'](user=user, config=config, fingerprint_hash_type=fingerprint_hash_type).keys()\n    remove_keys = set(existing_keys).difference(all_potential_keys)\n    for remove_key in remove_keys:\n        if __opts__['test']:\n            remove_comment = f'{remove_key} Key set for removal'\n            ret['comment'] = remove_comment\n            ret['result'] = None\n        else:\n            remove_comment = absent(remove_key, user, enc=enc, comment=comment, source=source, options=options, config=config, fingerprint_hash_type=fingerprint_hash_type, **kwargs)['comment']\n            ret['changes'][remove_key] = remove_comment\n    for ssh_key in ssh_keys:\n        run_return = present(ssh_key, user, enc, comment, source, options, config, fingerprint_hash_type, **kwargs)\n        if run_return['changes']:\n            ret['changes'].update(run_return['changes'])\n        else:\n            ret['comment'] += '\\n' + run_return['comment']\n            ret['comment'] = ret['comment'].strip()\n        if run_return['result'] is None:\n            ret['result'] = None\n        elif not run_return['result']:\n            ret['result'] = False\n    return ret",
            "def manage(name, ssh_keys, user, enc='ssh-rsa', comment='', source='', options=None, config='.ssh/authorized_keys', fingerprint_hash_type=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    .. versionadded:: 3000\\n\\n    Ensures that only the specified ssh_keys are present for the specified user\\n\\n    ssh_keys\\n        The SSH key to manage\\n\\n    user\\n        The user who owns the SSH authorized keys file to modify\\n\\n    enc\\n        Defines what type of key is being used, can be ed25519, ecdsa,\\n        ssh-rsa, ssh-dss or any other type as of openssh server version 8.7.\\n\\n    comment\\n        The comment to be placed with the SSH public key\\n\\n    source\\n        The source file for the key(s). Can contain any number of public keys,\\n        in standard \"authorized_keys\" format. If this is set, comment and enc\\n        will be ignored.\\n\\n    .. note::\\n        The source file must contain keys in the format ``<enc> <key>\\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\\n        will need to do the following to retrieve an OpenSSH-compatible public\\n        key.\\n\\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\\n           the public key), and click ``Open``.\\n        2. Copy the public key from the box labeled ``Public key for pasting\\n           into OpenSSH authorized_keys file``.\\n        3. Paste it into a new file.\\n\\n    options\\n        The options passed to the keys, pass a list object\\n\\n    config\\n        The location of the authorized keys file relative to the user\\'s home\\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\\n        %h for username and home path supported.\\n\\n    fingerprint_hash_type\\n        The public key fingerprint hash type that the public key fingerprint\\n        was originally hashed with. This defaults to ``sha256`` if not specified.\\n    '\n    ret = {'name': '', 'changes': {}, 'result': True, 'comment': ''}\n    all_potential_keys = []\n    for ssh_key in ssh_keys:\n        all_potential_keys.extend(ssh_key.split(' '))\n    existing_keys = __salt__['ssh.auth_keys'](user=user, config=config, fingerprint_hash_type=fingerprint_hash_type).keys()\n    remove_keys = set(existing_keys).difference(all_potential_keys)\n    for remove_key in remove_keys:\n        if __opts__['test']:\n            remove_comment = f'{remove_key} Key set for removal'\n            ret['comment'] = remove_comment\n            ret['result'] = None\n        else:\n            remove_comment = absent(remove_key, user, enc=enc, comment=comment, source=source, options=options, config=config, fingerprint_hash_type=fingerprint_hash_type, **kwargs)['comment']\n            ret['changes'][remove_key] = remove_comment\n    for ssh_key in ssh_keys:\n        run_return = present(ssh_key, user, enc, comment, source, options, config, fingerprint_hash_type, **kwargs)\n        if run_return['changes']:\n            ret['changes'].update(run_return['changes'])\n        else:\n            ret['comment'] += '\\n' + run_return['comment']\n            ret['comment'] = ret['comment'].strip()\n        if run_return['result'] is None:\n            ret['result'] = None\n        elif not run_return['result']:\n            ret['result'] = False\n    return ret"
        ]
    }
]