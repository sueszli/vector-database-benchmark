[
    {
        "func_name": "dfs",
        "original": "def dfs(n, adj, curr, parent, lookup, count, dp):\n    for child in adj[curr]:\n        if child == parent or lookup[child]:\n            continue\n        dfs(n, adj, child, curr, lookup, count, dp)\n    dp[curr][0][0] = 1\n    for child in adj[curr]:\n        if child == parent or lookup[child]:\n            continue\n        new_dp_curr = [row[:] for row in dp[curr]]\n        for curr_d in xrange(count[curr]):\n            for curr_max_d in xrange(curr_d, min(2 * curr_d + 1, count[curr])):\n                if not dp[curr][curr_d][curr_max_d]:\n                    continue\n                for child_d in xrange(count[child]):\n                    for child_max_d in xrange(child_d, min(2 * child_d + 1, count[child])):\n                        new_dp_curr[max(curr_d, child_d + 1)][max(curr_max_d, child_max_d, curr_d + child_d + 1)] += dp[curr][curr_d][curr_max_d] * dp[child][child_d][child_max_d]\n        count[curr] += count[child]\n        dp[curr] = new_dp_curr",
        "mutated": [
            "def dfs(n, adj, curr, parent, lookup, count, dp):\n    if False:\n        i = 10\n    for child in adj[curr]:\n        if child == parent or lookup[child]:\n            continue\n        dfs(n, adj, child, curr, lookup, count, dp)\n    dp[curr][0][0] = 1\n    for child in adj[curr]:\n        if child == parent or lookup[child]:\n            continue\n        new_dp_curr = [row[:] for row in dp[curr]]\n        for curr_d in xrange(count[curr]):\n            for curr_max_d in xrange(curr_d, min(2 * curr_d + 1, count[curr])):\n                if not dp[curr][curr_d][curr_max_d]:\n                    continue\n                for child_d in xrange(count[child]):\n                    for child_max_d in xrange(child_d, min(2 * child_d + 1, count[child])):\n                        new_dp_curr[max(curr_d, child_d + 1)][max(curr_max_d, child_max_d, curr_d + child_d + 1)] += dp[curr][curr_d][curr_max_d] * dp[child][child_d][child_max_d]\n        count[curr] += count[child]\n        dp[curr] = new_dp_curr",
            "def dfs(n, adj, curr, parent, lookup, count, dp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for child in adj[curr]:\n        if child == parent or lookup[child]:\n            continue\n        dfs(n, adj, child, curr, lookup, count, dp)\n    dp[curr][0][0] = 1\n    for child in adj[curr]:\n        if child == parent or lookup[child]:\n            continue\n        new_dp_curr = [row[:] for row in dp[curr]]\n        for curr_d in xrange(count[curr]):\n            for curr_max_d in xrange(curr_d, min(2 * curr_d + 1, count[curr])):\n                if not dp[curr][curr_d][curr_max_d]:\n                    continue\n                for child_d in xrange(count[child]):\n                    for child_max_d in xrange(child_d, min(2 * child_d + 1, count[child])):\n                        new_dp_curr[max(curr_d, child_d + 1)][max(curr_max_d, child_max_d, curr_d + child_d + 1)] += dp[curr][curr_d][curr_max_d] * dp[child][child_d][child_max_d]\n        count[curr] += count[child]\n        dp[curr] = new_dp_curr",
            "def dfs(n, adj, curr, parent, lookup, count, dp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for child in adj[curr]:\n        if child == parent or lookup[child]:\n            continue\n        dfs(n, adj, child, curr, lookup, count, dp)\n    dp[curr][0][0] = 1\n    for child in adj[curr]:\n        if child == parent or lookup[child]:\n            continue\n        new_dp_curr = [row[:] for row in dp[curr]]\n        for curr_d in xrange(count[curr]):\n            for curr_max_d in xrange(curr_d, min(2 * curr_d + 1, count[curr])):\n                if not dp[curr][curr_d][curr_max_d]:\n                    continue\n                for child_d in xrange(count[child]):\n                    for child_max_d in xrange(child_d, min(2 * child_d + 1, count[child])):\n                        new_dp_curr[max(curr_d, child_d + 1)][max(curr_max_d, child_max_d, curr_d + child_d + 1)] += dp[curr][curr_d][curr_max_d] * dp[child][child_d][child_max_d]\n        count[curr] += count[child]\n        dp[curr] = new_dp_curr",
            "def dfs(n, adj, curr, parent, lookup, count, dp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for child in adj[curr]:\n        if child == parent or lookup[child]:\n            continue\n        dfs(n, adj, child, curr, lookup, count, dp)\n    dp[curr][0][0] = 1\n    for child in adj[curr]:\n        if child == parent or lookup[child]:\n            continue\n        new_dp_curr = [row[:] for row in dp[curr]]\n        for curr_d in xrange(count[curr]):\n            for curr_max_d in xrange(curr_d, min(2 * curr_d + 1, count[curr])):\n                if not dp[curr][curr_d][curr_max_d]:\n                    continue\n                for child_d in xrange(count[child]):\n                    for child_max_d in xrange(child_d, min(2 * child_d + 1, count[child])):\n                        new_dp_curr[max(curr_d, child_d + 1)][max(curr_max_d, child_max_d, curr_d + child_d + 1)] += dp[curr][curr_d][curr_max_d] * dp[child][child_d][child_max_d]\n        count[curr] += count[child]\n        dp[curr] = new_dp_curr",
            "def dfs(n, adj, curr, parent, lookup, count, dp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for child in adj[curr]:\n        if child == parent or lookup[child]:\n            continue\n        dfs(n, adj, child, curr, lookup, count, dp)\n    dp[curr][0][0] = 1\n    for child in adj[curr]:\n        if child == parent or lookup[child]:\n            continue\n        new_dp_curr = [row[:] for row in dp[curr]]\n        for curr_d in xrange(count[curr]):\n            for curr_max_d in xrange(curr_d, min(2 * curr_d + 1, count[curr])):\n                if not dp[curr][curr_d][curr_max_d]:\n                    continue\n                for child_d in xrange(count[child]):\n                    for child_max_d in xrange(child_d, min(2 * child_d + 1, count[child])):\n                        new_dp_curr[max(curr_d, child_d + 1)][max(curr_max_d, child_max_d, curr_d + child_d + 1)] += dp[curr][curr_d][curr_max_d] * dp[child][child_d][child_max_d]\n        count[curr] += count[child]\n        dp[curr] = new_dp_curr"
        ]
    },
    {
        "func_name": "countSubgraphsForEachDiameter",
        "original": "def countSubgraphsForEachDiameter(self, n, edges):\n    \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n\n    def dfs(n, adj, curr, parent, lookup, count, dp):\n        for child in adj[curr]:\n            if child == parent or lookup[child]:\n                continue\n            dfs(n, adj, child, curr, lookup, count, dp)\n        dp[curr][0][0] = 1\n        for child in adj[curr]:\n            if child == parent or lookup[child]:\n                continue\n            new_dp_curr = [row[:] for row in dp[curr]]\n            for curr_d in xrange(count[curr]):\n                for curr_max_d in xrange(curr_d, min(2 * curr_d + 1, count[curr])):\n                    if not dp[curr][curr_d][curr_max_d]:\n                        continue\n                    for child_d in xrange(count[child]):\n                        for child_max_d in xrange(child_d, min(2 * child_d + 1, count[child])):\n                            new_dp_curr[max(curr_d, child_d + 1)][max(curr_max_d, child_max_d, curr_d + child_d + 1)] += dp[curr][curr_d][curr_max_d] * dp[child][child_d][child_max_d]\n            count[curr] += count[child]\n            dp[curr] = new_dp_curr\n    adj = collections.defaultdict(list)\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    (lookup, result) = ([0] * n, [0] * (n - 1))\n    for i in xrange(n):\n        dp = [[[0] * n for _ in xrange(n)] for _ in xrange(n)]\n        count = [1] * n\n        dfs(n, adj, i, -1, lookup, count, dp)\n        lookup[i] = 1\n        for d in xrange(1, n):\n            for max_d in xrange(d, min(2 * d + 1, n)):\n                result[max_d - 1] += dp[i][d][max_d]\n    return result",
        "mutated": [
            "def countSubgraphsForEachDiameter(self, n, edges):\n    if False:\n        i = 10\n    '\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        '\n\n    def dfs(n, adj, curr, parent, lookup, count, dp):\n        for child in adj[curr]:\n            if child == parent or lookup[child]:\n                continue\n            dfs(n, adj, child, curr, lookup, count, dp)\n        dp[curr][0][0] = 1\n        for child in adj[curr]:\n            if child == parent or lookup[child]:\n                continue\n            new_dp_curr = [row[:] for row in dp[curr]]\n            for curr_d in xrange(count[curr]):\n                for curr_max_d in xrange(curr_d, min(2 * curr_d + 1, count[curr])):\n                    if not dp[curr][curr_d][curr_max_d]:\n                        continue\n                    for child_d in xrange(count[child]):\n                        for child_max_d in xrange(child_d, min(2 * child_d + 1, count[child])):\n                            new_dp_curr[max(curr_d, child_d + 1)][max(curr_max_d, child_max_d, curr_d + child_d + 1)] += dp[curr][curr_d][curr_max_d] * dp[child][child_d][child_max_d]\n            count[curr] += count[child]\n            dp[curr] = new_dp_curr\n    adj = collections.defaultdict(list)\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    (lookup, result) = ([0] * n, [0] * (n - 1))\n    for i in xrange(n):\n        dp = [[[0] * n for _ in xrange(n)] for _ in xrange(n)]\n        count = [1] * n\n        dfs(n, adj, i, -1, lookup, count, dp)\n        lookup[i] = 1\n        for d in xrange(1, n):\n            for max_d in xrange(d, min(2 * d + 1, n)):\n                result[max_d - 1] += dp[i][d][max_d]\n    return result",
            "def countSubgraphsForEachDiameter(self, n, edges):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        '\n\n    def dfs(n, adj, curr, parent, lookup, count, dp):\n        for child in adj[curr]:\n            if child == parent or lookup[child]:\n                continue\n            dfs(n, adj, child, curr, lookup, count, dp)\n        dp[curr][0][0] = 1\n        for child in adj[curr]:\n            if child == parent or lookup[child]:\n                continue\n            new_dp_curr = [row[:] for row in dp[curr]]\n            for curr_d in xrange(count[curr]):\n                for curr_max_d in xrange(curr_d, min(2 * curr_d + 1, count[curr])):\n                    if not dp[curr][curr_d][curr_max_d]:\n                        continue\n                    for child_d in xrange(count[child]):\n                        for child_max_d in xrange(child_d, min(2 * child_d + 1, count[child])):\n                            new_dp_curr[max(curr_d, child_d + 1)][max(curr_max_d, child_max_d, curr_d + child_d + 1)] += dp[curr][curr_d][curr_max_d] * dp[child][child_d][child_max_d]\n            count[curr] += count[child]\n            dp[curr] = new_dp_curr\n    adj = collections.defaultdict(list)\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    (lookup, result) = ([0] * n, [0] * (n - 1))\n    for i in xrange(n):\n        dp = [[[0] * n for _ in xrange(n)] for _ in xrange(n)]\n        count = [1] * n\n        dfs(n, adj, i, -1, lookup, count, dp)\n        lookup[i] = 1\n        for d in xrange(1, n):\n            for max_d in xrange(d, min(2 * d + 1, n)):\n                result[max_d - 1] += dp[i][d][max_d]\n    return result",
            "def countSubgraphsForEachDiameter(self, n, edges):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        '\n\n    def dfs(n, adj, curr, parent, lookup, count, dp):\n        for child in adj[curr]:\n            if child == parent or lookup[child]:\n                continue\n            dfs(n, adj, child, curr, lookup, count, dp)\n        dp[curr][0][0] = 1\n        for child in adj[curr]:\n            if child == parent or lookup[child]:\n                continue\n            new_dp_curr = [row[:] for row in dp[curr]]\n            for curr_d in xrange(count[curr]):\n                for curr_max_d in xrange(curr_d, min(2 * curr_d + 1, count[curr])):\n                    if not dp[curr][curr_d][curr_max_d]:\n                        continue\n                    for child_d in xrange(count[child]):\n                        for child_max_d in xrange(child_d, min(2 * child_d + 1, count[child])):\n                            new_dp_curr[max(curr_d, child_d + 1)][max(curr_max_d, child_max_d, curr_d + child_d + 1)] += dp[curr][curr_d][curr_max_d] * dp[child][child_d][child_max_d]\n            count[curr] += count[child]\n            dp[curr] = new_dp_curr\n    adj = collections.defaultdict(list)\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    (lookup, result) = ([0] * n, [0] * (n - 1))\n    for i in xrange(n):\n        dp = [[[0] * n for _ in xrange(n)] for _ in xrange(n)]\n        count = [1] * n\n        dfs(n, adj, i, -1, lookup, count, dp)\n        lookup[i] = 1\n        for d in xrange(1, n):\n            for max_d in xrange(d, min(2 * d + 1, n)):\n                result[max_d - 1] += dp[i][d][max_d]\n    return result",
            "def countSubgraphsForEachDiameter(self, n, edges):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        '\n\n    def dfs(n, adj, curr, parent, lookup, count, dp):\n        for child in adj[curr]:\n            if child == parent or lookup[child]:\n                continue\n            dfs(n, adj, child, curr, lookup, count, dp)\n        dp[curr][0][0] = 1\n        for child in adj[curr]:\n            if child == parent or lookup[child]:\n                continue\n            new_dp_curr = [row[:] for row in dp[curr]]\n            for curr_d in xrange(count[curr]):\n                for curr_max_d in xrange(curr_d, min(2 * curr_d + 1, count[curr])):\n                    if not dp[curr][curr_d][curr_max_d]:\n                        continue\n                    for child_d in xrange(count[child]):\n                        for child_max_d in xrange(child_d, min(2 * child_d + 1, count[child])):\n                            new_dp_curr[max(curr_d, child_d + 1)][max(curr_max_d, child_max_d, curr_d + child_d + 1)] += dp[curr][curr_d][curr_max_d] * dp[child][child_d][child_max_d]\n            count[curr] += count[child]\n            dp[curr] = new_dp_curr\n    adj = collections.defaultdict(list)\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    (lookup, result) = ([0] * n, [0] * (n - 1))\n    for i in xrange(n):\n        dp = [[[0] * n for _ in xrange(n)] for _ in xrange(n)]\n        count = [1] * n\n        dfs(n, adj, i, -1, lookup, count, dp)\n        lookup[i] = 1\n        for d in xrange(1, n):\n            for max_d in xrange(d, min(2 * d + 1, n)):\n                result[max_d - 1] += dp[i][d][max_d]\n    return result",
            "def countSubgraphsForEachDiameter(self, n, edges):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        '\n\n    def dfs(n, adj, curr, parent, lookup, count, dp):\n        for child in adj[curr]:\n            if child == parent or lookup[child]:\n                continue\n            dfs(n, adj, child, curr, lookup, count, dp)\n        dp[curr][0][0] = 1\n        for child in adj[curr]:\n            if child == parent or lookup[child]:\n                continue\n            new_dp_curr = [row[:] for row in dp[curr]]\n            for curr_d in xrange(count[curr]):\n                for curr_max_d in xrange(curr_d, min(2 * curr_d + 1, count[curr])):\n                    if not dp[curr][curr_d][curr_max_d]:\n                        continue\n                    for child_d in xrange(count[child]):\n                        for child_max_d in xrange(child_d, min(2 * child_d + 1, count[child])):\n                            new_dp_curr[max(curr_d, child_d + 1)][max(curr_max_d, child_max_d, curr_d + child_d + 1)] += dp[curr][curr_d][curr_max_d] * dp[child][child_d][child_max_d]\n            count[curr] += count[child]\n            dp[curr] = new_dp_curr\n    adj = collections.defaultdict(list)\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    (lookup, result) = ([0] * n, [0] * (n - 1))\n    for i in xrange(n):\n        dp = [[[0] * n for _ in xrange(n)] for _ in xrange(n)]\n        count = [1] * n\n        dfs(n, adj, i, -1, lookup, count, dp)\n        lookup[i] = 1\n        for d in xrange(1, n):\n            for max_d in xrange(d, min(2 * d + 1, n)):\n                result[max_d - 1] += dp[i][d][max_d]\n    return result"
        ]
    },
    {
        "func_name": "popcount",
        "original": "def popcount(mask):\n    count = 0\n    while mask:\n        mask &= mask - 1\n        count += 1\n    return count",
        "mutated": [
            "def popcount(mask):\n    if False:\n        i = 10\n    count = 0\n    while mask:\n        mask &= mask - 1\n        count += 1\n    return count",
            "def popcount(mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    count = 0\n    while mask:\n        mask &= mask - 1\n        count += 1\n    return count",
            "def popcount(mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    count = 0\n    while mask:\n        mask &= mask - 1\n        count += 1\n    return count",
            "def popcount(mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    count = 0\n    while mask:\n        mask &= mask - 1\n        count += 1\n    return count",
            "def popcount(mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    count = 0\n    while mask:\n        mask &= mask - 1\n        count += 1\n    return count"
        ]
    },
    {
        "func_name": "bfs",
        "original": "def bfs(adj, mask, start):\n    q = collections.deque([(start, 0)])\n    lookup = 1 << start\n    count = popcount(mask) - 1\n    (u, d) = (None, None)\n    while q:\n        (u, d) = q.popleft()\n        for v in adj[u]:\n            if not mask & 1 << v or lookup & 1 << v:\n                continue\n            lookup |= 1 << v\n            count -= 1\n            q.append((v, d + 1))\n    return (count == 0, u, d)",
        "mutated": [
            "def bfs(adj, mask, start):\n    if False:\n        i = 10\n    q = collections.deque([(start, 0)])\n    lookup = 1 << start\n    count = popcount(mask) - 1\n    (u, d) = (None, None)\n    while q:\n        (u, d) = q.popleft()\n        for v in adj[u]:\n            if not mask & 1 << v or lookup & 1 << v:\n                continue\n            lookup |= 1 << v\n            count -= 1\n            q.append((v, d + 1))\n    return (count == 0, u, d)",
            "def bfs(adj, mask, start):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    q = collections.deque([(start, 0)])\n    lookup = 1 << start\n    count = popcount(mask) - 1\n    (u, d) = (None, None)\n    while q:\n        (u, d) = q.popleft()\n        for v in adj[u]:\n            if not mask & 1 << v or lookup & 1 << v:\n                continue\n            lookup |= 1 << v\n            count -= 1\n            q.append((v, d + 1))\n    return (count == 0, u, d)",
            "def bfs(adj, mask, start):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    q = collections.deque([(start, 0)])\n    lookup = 1 << start\n    count = popcount(mask) - 1\n    (u, d) = (None, None)\n    while q:\n        (u, d) = q.popleft()\n        for v in adj[u]:\n            if not mask & 1 << v or lookup & 1 << v:\n                continue\n            lookup |= 1 << v\n            count -= 1\n            q.append((v, d + 1))\n    return (count == 0, u, d)",
            "def bfs(adj, mask, start):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    q = collections.deque([(start, 0)])\n    lookup = 1 << start\n    count = popcount(mask) - 1\n    (u, d) = (None, None)\n    while q:\n        (u, d) = q.popleft()\n        for v in adj[u]:\n            if not mask & 1 << v or lookup & 1 << v:\n                continue\n            lookup |= 1 << v\n            count -= 1\n            q.append((v, d + 1))\n    return (count == 0, u, d)",
            "def bfs(adj, mask, start):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    q = collections.deque([(start, 0)])\n    lookup = 1 << start\n    count = popcount(mask) - 1\n    (u, d) = (None, None)\n    while q:\n        (u, d) = q.popleft()\n        for v in adj[u]:\n            if not mask & 1 << v or lookup & 1 << v:\n                continue\n            lookup |= 1 << v\n            count -= 1\n            q.append((v, d + 1))\n    return (count == 0, u, d)"
        ]
    },
    {
        "func_name": "max_distance",
        "original": "def max_distance(n, edges, adj, mask):\n    (is_valid, farthest, _) = bfs(adj, mask, int(math.log(mask & -mask, 2)))\n    return bfs(adj, mask, farthest)[-1] if is_valid else 0",
        "mutated": [
            "def max_distance(n, edges, adj, mask):\n    if False:\n        i = 10\n    (is_valid, farthest, _) = bfs(adj, mask, int(math.log(mask & -mask, 2)))\n    return bfs(adj, mask, farthest)[-1] if is_valid else 0",
            "def max_distance(n, edges, adj, mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (is_valid, farthest, _) = bfs(adj, mask, int(math.log(mask & -mask, 2)))\n    return bfs(adj, mask, farthest)[-1] if is_valid else 0",
            "def max_distance(n, edges, adj, mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (is_valid, farthest, _) = bfs(adj, mask, int(math.log(mask & -mask, 2)))\n    return bfs(adj, mask, farthest)[-1] if is_valid else 0",
            "def max_distance(n, edges, adj, mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (is_valid, farthest, _) = bfs(adj, mask, int(math.log(mask & -mask, 2)))\n    return bfs(adj, mask, farthest)[-1] if is_valid else 0",
            "def max_distance(n, edges, adj, mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (is_valid, farthest, _) = bfs(adj, mask, int(math.log(mask & -mask, 2)))\n    return bfs(adj, mask, farthest)[-1] if is_valid else 0"
        ]
    },
    {
        "func_name": "countSubgraphsForEachDiameter",
        "original": "def countSubgraphsForEachDiameter(self, n, edges):\n    \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n\n    def popcount(mask):\n        count = 0\n        while mask:\n            mask &= mask - 1\n            count += 1\n        return count\n\n    def bfs(adj, mask, start):\n        q = collections.deque([(start, 0)])\n        lookup = 1 << start\n        count = popcount(mask) - 1\n        (u, d) = (None, None)\n        while q:\n            (u, d) = q.popleft()\n            for v in adj[u]:\n                if not mask & 1 << v or lookup & 1 << v:\n                    continue\n                lookup |= 1 << v\n                count -= 1\n                q.append((v, d + 1))\n        return (count == 0, u, d)\n\n    def max_distance(n, edges, adj, mask):\n        (is_valid, farthest, _) = bfs(adj, mask, int(math.log(mask & -mask, 2)))\n        return bfs(adj, mask, farthest)[-1] if is_valid else 0\n    adj = collections.defaultdict(list)\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    result = [0] * (n - 1)\n    for mask in xrange(1, 2 ** n):\n        max_d = max_distance(n, edges, adj, mask)\n        if max_d - 1 >= 0:\n            result[max_d - 1] += 1\n    return result",
        "mutated": [
            "def countSubgraphsForEachDiameter(self, n, edges):\n    if False:\n        i = 10\n    '\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        '\n\n    def popcount(mask):\n        count = 0\n        while mask:\n            mask &= mask - 1\n            count += 1\n        return count\n\n    def bfs(adj, mask, start):\n        q = collections.deque([(start, 0)])\n        lookup = 1 << start\n        count = popcount(mask) - 1\n        (u, d) = (None, None)\n        while q:\n            (u, d) = q.popleft()\n            for v in adj[u]:\n                if not mask & 1 << v or lookup & 1 << v:\n                    continue\n                lookup |= 1 << v\n                count -= 1\n                q.append((v, d + 1))\n        return (count == 0, u, d)\n\n    def max_distance(n, edges, adj, mask):\n        (is_valid, farthest, _) = bfs(adj, mask, int(math.log(mask & -mask, 2)))\n        return bfs(adj, mask, farthest)[-1] if is_valid else 0\n    adj = collections.defaultdict(list)\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    result = [0] * (n - 1)\n    for mask in xrange(1, 2 ** n):\n        max_d = max_distance(n, edges, adj, mask)\n        if max_d - 1 >= 0:\n            result[max_d - 1] += 1\n    return result",
            "def countSubgraphsForEachDiameter(self, n, edges):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        '\n\n    def popcount(mask):\n        count = 0\n        while mask:\n            mask &= mask - 1\n            count += 1\n        return count\n\n    def bfs(adj, mask, start):\n        q = collections.deque([(start, 0)])\n        lookup = 1 << start\n        count = popcount(mask) - 1\n        (u, d) = (None, None)\n        while q:\n            (u, d) = q.popleft()\n            for v in adj[u]:\n                if not mask & 1 << v or lookup & 1 << v:\n                    continue\n                lookup |= 1 << v\n                count -= 1\n                q.append((v, d + 1))\n        return (count == 0, u, d)\n\n    def max_distance(n, edges, adj, mask):\n        (is_valid, farthest, _) = bfs(adj, mask, int(math.log(mask & -mask, 2)))\n        return bfs(adj, mask, farthest)[-1] if is_valid else 0\n    adj = collections.defaultdict(list)\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    result = [0] * (n - 1)\n    for mask in xrange(1, 2 ** n):\n        max_d = max_distance(n, edges, adj, mask)\n        if max_d - 1 >= 0:\n            result[max_d - 1] += 1\n    return result",
            "def countSubgraphsForEachDiameter(self, n, edges):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        '\n\n    def popcount(mask):\n        count = 0\n        while mask:\n            mask &= mask - 1\n            count += 1\n        return count\n\n    def bfs(adj, mask, start):\n        q = collections.deque([(start, 0)])\n        lookup = 1 << start\n        count = popcount(mask) - 1\n        (u, d) = (None, None)\n        while q:\n            (u, d) = q.popleft()\n            for v in adj[u]:\n                if not mask & 1 << v or lookup & 1 << v:\n                    continue\n                lookup |= 1 << v\n                count -= 1\n                q.append((v, d + 1))\n        return (count == 0, u, d)\n\n    def max_distance(n, edges, adj, mask):\n        (is_valid, farthest, _) = bfs(adj, mask, int(math.log(mask & -mask, 2)))\n        return bfs(adj, mask, farthest)[-1] if is_valid else 0\n    adj = collections.defaultdict(list)\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    result = [0] * (n - 1)\n    for mask in xrange(1, 2 ** n):\n        max_d = max_distance(n, edges, adj, mask)\n        if max_d - 1 >= 0:\n            result[max_d - 1] += 1\n    return result",
            "def countSubgraphsForEachDiameter(self, n, edges):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        '\n\n    def popcount(mask):\n        count = 0\n        while mask:\n            mask &= mask - 1\n            count += 1\n        return count\n\n    def bfs(adj, mask, start):\n        q = collections.deque([(start, 0)])\n        lookup = 1 << start\n        count = popcount(mask) - 1\n        (u, d) = (None, None)\n        while q:\n            (u, d) = q.popleft()\n            for v in adj[u]:\n                if not mask & 1 << v or lookup & 1 << v:\n                    continue\n                lookup |= 1 << v\n                count -= 1\n                q.append((v, d + 1))\n        return (count == 0, u, d)\n\n    def max_distance(n, edges, adj, mask):\n        (is_valid, farthest, _) = bfs(adj, mask, int(math.log(mask & -mask, 2)))\n        return bfs(adj, mask, farthest)[-1] if is_valid else 0\n    adj = collections.defaultdict(list)\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    result = [0] * (n - 1)\n    for mask in xrange(1, 2 ** n):\n        max_d = max_distance(n, edges, adj, mask)\n        if max_d - 1 >= 0:\n            result[max_d - 1] += 1\n    return result",
            "def countSubgraphsForEachDiameter(self, n, edges):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        '\n\n    def popcount(mask):\n        count = 0\n        while mask:\n            mask &= mask - 1\n            count += 1\n        return count\n\n    def bfs(adj, mask, start):\n        q = collections.deque([(start, 0)])\n        lookup = 1 << start\n        count = popcount(mask) - 1\n        (u, d) = (None, None)\n        while q:\n            (u, d) = q.popleft()\n            for v in adj[u]:\n                if not mask & 1 << v or lookup & 1 << v:\n                    continue\n                lookup |= 1 << v\n                count -= 1\n                q.append((v, d + 1))\n        return (count == 0, u, d)\n\n    def max_distance(n, edges, adj, mask):\n        (is_valid, farthest, _) = bfs(adj, mask, int(math.log(mask & -mask, 2)))\n        return bfs(adj, mask, farthest)[-1] if is_valid else 0\n    adj = collections.defaultdict(list)\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    result = [0] * (n - 1)\n    for mask in xrange(1, 2 ** n):\n        max_d = max_distance(n, edges, adj, mask)\n        if max_d - 1 >= 0:\n            result[max_d - 1] += 1\n    return result"
        ]
    }
]