"""
Parsers for yarn.lock versions 1 and 2/3
Version 1 parser based on
https://www.arahansen.com/the-ultimate-guide-to-yarn-lock-lockfiles/
https://classic.yarnpkg.com/lang/en/docs/yarn-lock/

Version 2/3 parser based on looking at examples on github, I could not find any documentation
Here are the Yarn 2/3 docs: https://yarnpkg.com/
"""
from pathlib import Path
from typing import List
from typing import Optional
from typing import Set
from typing import Tuple
from typing import TypeVar
from semdep.external.parsy import any_char
from semdep.external.parsy import Parser
from semdep.external.parsy import peek
from semdep.external.parsy import regex
from semdep.external.parsy import string
from semdep.external.parsy import success
from semdep.parsers.util import consume_line
from semdep.parsers.util import DependencyFileToParse
from semdep.parsers.util import DependencyParserError
from semdep.parsers.util import extract_npm_lockfile_hash
from semdep.parsers.util import JSON
from semdep.parsers.util import json_doc
from semdep.parsers.util import mark_line
from semdep.parsers.util import pair
from semdep.parsers.util import quoted
from semdep.parsers.util import safe_parse_lockfile_and_manifest
from semdep.parsers.util import transitivity
from semdep.parsers.util import upto
from semgrep.semgrep_interfaces.semgrep_output_v1 import Ecosystem
from semgrep.semgrep_interfaces.semgrep_output_v1 import FoundDependency
from semgrep.semgrep_interfaces.semgrep_output_v1 import Jsondoc
from semgrep.semgrep_interfaces.semgrep_output_v1 import Npm
from semgrep.semgrep_interfaces.semgrep_output_v1 import ScaParserName
from semgrep.semgrep_interfaces.semgrep_output_v1 import Yarn1
from semgrep.semgrep_interfaces.semgrep_output_v1 import Yarn2
from semgrep.verbose_logging import getLogger
logger = getLogger(__name__)
A = TypeVar('A')
part1 = regex('"?@?([^@:]*)', flags=0, group=1)
part2 = regex('@?([^:,"]*(:?(?!\n)[^:,"]*)*)"?', flags=0, group=1)
source1 = pair(part1, part2)
multi_source1 = source1.sep_by(string(', '))
key_value1: 'Parser[Optional[Tuple[str,str]]]' = string(' ').many().bind(lambda spaces: consume_line if len(spaces) != 2 else upto(' ', ':').bind(lambda key: peek(any_char).bind(lambda next: consume_line if next == ':' else string(' ') >> upto('\n').bind(lambda value: success((key, value.strip('"')))))))
yarn_dep1 = mark_line(pair(multi_source1 << string(':\n'), key_value1.sep_by(string('\n')).map(lambda xs: {x[0]: x[1] for x in xs if x})))
YARN1_PREFIX = '# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v1\n\n'
yarn1 = string(YARN1_PREFIX) >> string('\n').optional() >> yarn_dep1.sep_by(string('\n\n')) << string('\n').optional()

def remove_npm_prefix(s: str) -> str:
    if False:
        while True:
            i = 10
    if s.startswith('npm:'):
        return s[4:]
    else:
        return s
source2 = pair(string('@').optional('') + upto('@', consume_other=True), upto('"', ',').map(remove_npm_prefix))
multi_source2 = quoted(source2.sep_by(string(', ')))
key_value2: 'Parser[Optional[Tuple[str,str]]]' = string(' ').many().bind(lambda spaces: consume_line if len(spaces) != 2 else upto(':').bind(lambda key: string(':') >> peek(any_char).bind(lambda next: success(None) if next == '\n' else string(' ') >> upto('\n').bind(lambda value: success((key, value.strip('"')))))))
yarn_dep2 = mark_line(pair(multi_source2 << string(':\n'), key_value2.sep_by(string('\n')).map(lambda xs: {x[0]: x[1] for x in xs if x})))
YARN2_PREFIX = '# This file is generated by running "yarn install" inside your project.\n# Manual changes might be lost - proceed with caution!\n'
YARN2_METADATA_REGEX = '\n__metadata:\n  version: \\d+\n  cacheKey: \\d+\n'
yarn2 = string(YARN2_PREFIX) >> regex(YARN2_METADATA_REGEX).optional() >> string('\n').optional() >> yarn_dep2.sep_by(string('\n\n')) << string('\n').optional()

def get_manifest_deps(parsed_manifest: Optional[JSON]) -> Optional[Set[Tuple[str, str]]]:
    if False:
        print('Hello World!')
    '\n    Extract a set of constraints from a package.json file\n    '
    if not parsed_manifest:
        return None
    if not parsed_manifest:
        return None
    json = parsed_manifest.as_dict()
    deps = json.get('dependencies')
    if not deps:
        return set()
    return {(x[0], x[1].as_str()) for x in deps.as_dict().items()}

def remove_trailing_octothorpe(s: Optional[str]) -> Optional[str]:
    if False:
        while True:
            i = 10
    if s is None:
        return None
    else:
        return '#'.join(s.split('#')[:-1]) if '#' in s else s

def parse_yarn(lockfile_path: Path, manifest_path: Optional[Path]) -> Tuple[List[FoundDependency], List[DependencyParserError]]:
    if False:
        while True:
            i = 10
    with open(lockfile_path) as f:
        lockfile_text = f.read()
    yarn_version = 1 if lockfile_text.startswith(YARN1_PREFIX) else 2
    parser = yarn1 if yarn_version == 1 else yarn2
    parser_name = ScaParserName(Yarn1()) if yarn_version == 1 else ScaParserName(Yarn2())
    (parsed_lockfile, parsed_manifest, errors) = safe_parse_lockfile_and_manifest(DependencyFileToParse(lockfile_path, parser, parser_name), DependencyFileToParse(manifest_path, json_doc, ScaParserName(Jsondoc())) if manifest_path else None)
    if not parsed_lockfile:
        return ([], errors)
    manifest_deps = get_manifest_deps(parsed_manifest)
    output = []
    for (line_number, (sources, fields)) in parsed_lockfile:
        if len(sources) < 1:
            continue
        if 'version' not in fields:
            continue
        if yarn_version == 1:
            allowed_hashes = extract_npm_lockfile_hash(fields.get('integrity'))
        else:
            checksum = fields.get('checksum')
            allowed_hashes = {'sha512': [checksum]} if checksum else {}
        resolved_url = fields.get('resolved')
        output.append(FoundDependency(package=sources[0][0], version=fields['version'], ecosystem=Ecosystem(Npm()), allowed_hashes=allowed_hashes, resolved_url=remove_trailing_octothorpe(resolved_url), transitivity=transitivity(manifest_deps, sources), line_number=line_number))
    return (output, errors)