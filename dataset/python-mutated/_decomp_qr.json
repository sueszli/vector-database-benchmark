[
    {
        "func_name": "safecall",
        "original": "def safecall(f, name, *args, **kwargs):\n    \"\"\"Call a LAPACK routine, determining lwork automatically and handling\n    error return values\"\"\"\n    lwork = kwargs.get('lwork', None)\n    if lwork in (None, -1):\n        kwargs['lwork'] = -1\n        ret = f(*args, **kwargs)\n        kwargs['lwork'] = ret[-2][0].real.astype(numpy.int_)\n    ret = f(*args, **kwargs)\n    if ret[-1] < 0:\n        raise ValueError('illegal value in %dth argument of internal %s' % (-ret[-1], name))\n    return ret[:-2]",
        "mutated": [
            "def safecall(f, name, *args, **kwargs):\n    if False:\n        i = 10\n    'Call a LAPACK routine, determining lwork automatically and handling\\n    error return values'\n    lwork = kwargs.get('lwork', None)\n    if lwork in (None, -1):\n        kwargs['lwork'] = -1\n        ret = f(*args, **kwargs)\n        kwargs['lwork'] = ret[-2][0].real.astype(numpy.int_)\n    ret = f(*args, **kwargs)\n    if ret[-1] < 0:\n        raise ValueError('illegal value in %dth argument of internal %s' % (-ret[-1], name))\n    return ret[:-2]",
            "def safecall(f, name, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Call a LAPACK routine, determining lwork automatically and handling\\n    error return values'\n    lwork = kwargs.get('lwork', None)\n    if lwork in (None, -1):\n        kwargs['lwork'] = -1\n        ret = f(*args, **kwargs)\n        kwargs['lwork'] = ret[-2][0].real.astype(numpy.int_)\n    ret = f(*args, **kwargs)\n    if ret[-1] < 0:\n        raise ValueError('illegal value in %dth argument of internal %s' % (-ret[-1], name))\n    return ret[:-2]",
            "def safecall(f, name, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Call a LAPACK routine, determining lwork automatically and handling\\n    error return values'\n    lwork = kwargs.get('lwork', None)\n    if lwork in (None, -1):\n        kwargs['lwork'] = -1\n        ret = f(*args, **kwargs)\n        kwargs['lwork'] = ret[-2][0].real.astype(numpy.int_)\n    ret = f(*args, **kwargs)\n    if ret[-1] < 0:\n        raise ValueError('illegal value in %dth argument of internal %s' % (-ret[-1], name))\n    return ret[:-2]",
            "def safecall(f, name, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Call a LAPACK routine, determining lwork automatically and handling\\n    error return values'\n    lwork = kwargs.get('lwork', None)\n    if lwork in (None, -1):\n        kwargs['lwork'] = -1\n        ret = f(*args, **kwargs)\n        kwargs['lwork'] = ret[-2][0].real.astype(numpy.int_)\n    ret = f(*args, **kwargs)\n    if ret[-1] < 0:\n        raise ValueError('illegal value in %dth argument of internal %s' % (-ret[-1], name))\n    return ret[:-2]",
            "def safecall(f, name, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Call a LAPACK routine, determining lwork automatically and handling\\n    error return values'\n    lwork = kwargs.get('lwork', None)\n    if lwork in (None, -1):\n        kwargs['lwork'] = -1\n        ret = f(*args, **kwargs)\n        kwargs['lwork'] = ret[-2][0].real.astype(numpy.int_)\n    ret = f(*args, **kwargs)\n    if ret[-1] < 0:\n        raise ValueError('illegal value in %dth argument of internal %s' % (-ret[-1], name))\n    return ret[:-2]"
        ]
    },
    {
        "func_name": "qr",
        "original": "def qr(a, overwrite_a=False, lwork=None, mode='full', pivoting=False, check_finite=True):\n    \"\"\"\n    Compute QR decomposition of a matrix.\n\n    Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal\n    and R upper triangular.\n\n    Parameters\n    ----------\n    a : (M, N) array_like\n        Matrix to be decomposed\n    overwrite_a : bool, optional\n        Whether data in `a` is overwritten (may improve performance if\n        `overwrite_a` is set to True by reusing the existing input data\n        structure rather than creating a new one.)\n    lwork : int, optional\n        Work array size, lwork >= a.shape[1]. If None or -1, an optimal size\n        is computed.\n    mode : {'full', 'r', 'economic', 'raw'}, optional\n        Determines what information is to be returned: either both Q and R\n        ('full', default), only R ('r') or both Q and R but computed in\n        economy-size ('economic', see Notes). The final option 'raw'\n        (added in SciPy 0.11) makes the function return two matrices\n        (Q, TAU) in the internal format used by LAPACK.\n    pivoting : bool, optional\n        Whether or not factorization should include pivoting for rank-revealing\n        qr decomposition. If pivoting, compute the decomposition\n        ``A P = Q R`` as above, but where P is chosen such that the diagonal\n        of R is non-increasing.\n    check_finite : bool, optional\n        Whether to check that the input matrix contains only finite numbers.\n        Disabling may give a performance gain, but may result in problems\n        (crashes, non-termination) if the inputs do contain infinities or NaNs.\n\n    Returns\n    -------\n    Q : float or complex ndarray\n        Of shape (M, M), or (M, K) for ``mode='economic'``. Not returned\n        if ``mode='r'``. Replaced by tuple ``(Q, TAU)`` if ``mode='raw'``.\n    R : float or complex ndarray\n        Of shape (M, N), or (K, N) for ``mode in ['economic', 'raw']``.\n        ``K = min(M, N)``.\n    P : int ndarray\n        Of shape (N,) for ``pivoting=True``. Not returned if\n        ``pivoting=False``.\n\n    Raises\n    ------\n    LinAlgError\n        Raised if decomposition fails\n\n    Notes\n    -----\n    This is an interface to the LAPACK routines dgeqrf, zgeqrf,\n    dorgqr, zungqr, dgeqp3, and zgeqp3.\n\n    If ``mode=economic``, the shapes of Q and R are (M, K) and (K, N) instead\n    of (M,M) and (M,N), with ``K=min(M,N)``.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy import linalg\n    >>> rng = np.random.default_rng()\n    >>> a = rng.standard_normal((9, 6))\n\n    >>> q, r = linalg.qr(a)\n    >>> np.allclose(a, np.dot(q, r))\n    True\n    >>> q.shape, r.shape\n    ((9, 9), (9, 6))\n\n    >>> r2 = linalg.qr(a, mode='r')\n    >>> np.allclose(r, r2)\n    True\n\n    >>> q3, r3 = linalg.qr(a, mode='economic')\n    >>> q3.shape, r3.shape\n    ((9, 6), (6, 6))\n\n    >>> q4, r4, p4 = linalg.qr(a, pivoting=True)\n    >>> d = np.abs(np.diag(r4))\n    >>> np.all(d[1:] <= d[:-1])\n    True\n    >>> np.allclose(a[:, p4], np.dot(q4, r4))\n    True\n    >>> q4.shape, r4.shape, p4.shape\n    ((9, 9), (9, 6), (6,))\n\n    >>> q5, r5, p5 = linalg.qr(a, mode='economic', pivoting=True)\n    >>> q5.shape, r5.shape, p5.shape\n    ((9, 6), (6, 6), (6,))\n\n    \"\"\"\n    if mode not in ['full', 'qr', 'r', 'economic', 'raw']:\n        raise ValueError(\"Mode argument should be one of ['full', 'r','economic', 'raw']\")\n    if check_finite:\n        a1 = numpy.asarray_chkfinite(a)\n    else:\n        a1 = numpy.asarray(a)\n    if len(a1.shape) != 2:\n        raise ValueError('expected a 2-D array')\n    (M, N) = a1.shape\n    overwrite_a = overwrite_a or _datacopied(a1, a)\n    if pivoting:\n        (geqp3,) = get_lapack_funcs(('geqp3',), (a1,))\n        (qr, jpvt, tau) = safecall(geqp3, 'geqp3', a1, overwrite_a=overwrite_a)\n        jpvt -= 1\n    else:\n        (geqrf,) = get_lapack_funcs(('geqrf',), (a1,))\n        (qr, tau) = safecall(geqrf, 'geqrf', a1, lwork=lwork, overwrite_a=overwrite_a)\n    if mode not in ['economic', 'raw'] or M < N:\n        R = numpy.triu(qr)\n    else:\n        R = numpy.triu(qr[:N, :])\n    if pivoting:\n        Rj = (R, jpvt)\n    else:\n        Rj = (R,)\n    if mode == 'r':\n        return Rj\n    elif mode == 'raw':\n        return ((qr, tau),) + Rj\n    (gor_un_gqr,) = get_lapack_funcs(('orgqr',), (qr,))\n    if M < N:\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qr[:, :M], tau, lwork=lwork, overwrite_a=1)\n    elif mode == 'economic':\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qr, tau, lwork=lwork, overwrite_a=1)\n    else:\n        t = qr.dtype.char\n        qqr = numpy.empty((M, M), dtype=t)\n        qqr[:, :N] = qr\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qqr, tau, lwork=lwork, overwrite_a=1)\n    return (Q,) + Rj",
        "mutated": [
            "def qr(a, overwrite_a=False, lwork=None, mode='full', pivoting=False, check_finite=True):\n    if False:\n        i = 10\n    \"\\n    Compute QR decomposition of a matrix.\\n\\n    Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal\\n    and R upper triangular.\\n\\n    Parameters\\n    ----------\\n    a : (M, N) array_like\\n        Matrix to be decomposed\\n    overwrite_a : bool, optional\\n        Whether data in `a` is overwritten (may improve performance if\\n        `overwrite_a` is set to True by reusing the existing input data\\n        structure rather than creating a new one.)\\n    lwork : int, optional\\n        Work array size, lwork >= a.shape[1]. If None or -1, an optimal size\\n        is computed.\\n    mode : {'full', 'r', 'economic', 'raw'}, optional\\n        Determines what information is to be returned: either both Q and R\\n        ('full', default), only R ('r') or both Q and R but computed in\\n        economy-size ('economic', see Notes). The final option 'raw'\\n        (added in SciPy 0.11) makes the function return two matrices\\n        (Q, TAU) in the internal format used by LAPACK.\\n    pivoting : bool, optional\\n        Whether or not factorization should include pivoting for rank-revealing\\n        qr decomposition. If pivoting, compute the decomposition\\n        ``A P = Q R`` as above, but where P is chosen such that the diagonal\\n        of R is non-increasing.\\n    check_finite : bool, optional\\n        Whether to check that the input matrix contains only finite numbers.\\n        Disabling may give a performance gain, but may result in problems\\n        (crashes, non-termination) if the inputs do contain infinities or NaNs.\\n\\n    Returns\\n    -------\\n    Q : float or complex ndarray\\n        Of shape (M, M), or (M, K) for ``mode='economic'``. Not returned\\n        if ``mode='r'``. Replaced by tuple ``(Q, TAU)`` if ``mode='raw'``.\\n    R : float or complex ndarray\\n        Of shape (M, N), or (K, N) for ``mode in ['economic', 'raw']``.\\n        ``K = min(M, N)``.\\n    P : int ndarray\\n        Of shape (N,) for ``pivoting=True``. Not returned if\\n        ``pivoting=False``.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n        Raised if decomposition fails\\n\\n    Notes\\n    -----\\n    This is an interface to the LAPACK routines dgeqrf, zgeqrf,\\n    dorgqr, zungqr, dgeqp3, and zgeqp3.\\n\\n    If ``mode=economic``, the shapes of Q and R are (M, K) and (K, N) instead\\n    of (M,M) and (M,N), with ``K=min(M,N)``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy import linalg\\n    >>> rng = np.random.default_rng()\\n    >>> a = rng.standard_normal((9, 6))\\n\\n    >>> q, r = linalg.qr(a)\\n    >>> np.allclose(a, np.dot(q, r))\\n    True\\n    >>> q.shape, r.shape\\n    ((9, 9), (9, 6))\\n\\n    >>> r2 = linalg.qr(a, mode='r')\\n    >>> np.allclose(r, r2)\\n    True\\n\\n    >>> q3, r3 = linalg.qr(a, mode='economic')\\n    >>> q3.shape, r3.shape\\n    ((9, 6), (6, 6))\\n\\n    >>> q4, r4, p4 = linalg.qr(a, pivoting=True)\\n    >>> d = np.abs(np.diag(r4))\\n    >>> np.all(d[1:] <= d[:-1])\\n    True\\n    >>> np.allclose(a[:, p4], np.dot(q4, r4))\\n    True\\n    >>> q4.shape, r4.shape, p4.shape\\n    ((9, 9), (9, 6), (6,))\\n\\n    >>> q5, r5, p5 = linalg.qr(a, mode='economic', pivoting=True)\\n    >>> q5.shape, r5.shape, p5.shape\\n    ((9, 6), (6, 6), (6,))\\n\\n    \"\n    if mode not in ['full', 'qr', 'r', 'economic', 'raw']:\n        raise ValueError(\"Mode argument should be one of ['full', 'r','economic', 'raw']\")\n    if check_finite:\n        a1 = numpy.asarray_chkfinite(a)\n    else:\n        a1 = numpy.asarray(a)\n    if len(a1.shape) != 2:\n        raise ValueError('expected a 2-D array')\n    (M, N) = a1.shape\n    overwrite_a = overwrite_a or _datacopied(a1, a)\n    if pivoting:\n        (geqp3,) = get_lapack_funcs(('geqp3',), (a1,))\n        (qr, jpvt, tau) = safecall(geqp3, 'geqp3', a1, overwrite_a=overwrite_a)\n        jpvt -= 1\n    else:\n        (geqrf,) = get_lapack_funcs(('geqrf',), (a1,))\n        (qr, tau) = safecall(geqrf, 'geqrf', a1, lwork=lwork, overwrite_a=overwrite_a)\n    if mode not in ['economic', 'raw'] or M < N:\n        R = numpy.triu(qr)\n    else:\n        R = numpy.triu(qr[:N, :])\n    if pivoting:\n        Rj = (R, jpvt)\n    else:\n        Rj = (R,)\n    if mode == 'r':\n        return Rj\n    elif mode == 'raw':\n        return ((qr, tau),) + Rj\n    (gor_un_gqr,) = get_lapack_funcs(('orgqr',), (qr,))\n    if M < N:\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qr[:, :M], tau, lwork=lwork, overwrite_a=1)\n    elif mode == 'economic':\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qr, tau, lwork=lwork, overwrite_a=1)\n    else:\n        t = qr.dtype.char\n        qqr = numpy.empty((M, M), dtype=t)\n        qqr[:, :N] = qr\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qqr, tau, lwork=lwork, overwrite_a=1)\n    return (Q,) + Rj",
            "def qr(a, overwrite_a=False, lwork=None, mode='full', pivoting=False, check_finite=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Compute QR decomposition of a matrix.\\n\\n    Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal\\n    and R upper triangular.\\n\\n    Parameters\\n    ----------\\n    a : (M, N) array_like\\n        Matrix to be decomposed\\n    overwrite_a : bool, optional\\n        Whether data in `a` is overwritten (may improve performance if\\n        `overwrite_a` is set to True by reusing the existing input data\\n        structure rather than creating a new one.)\\n    lwork : int, optional\\n        Work array size, lwork >= a.shape[1]. If None or -1, an optimal size\\n        is computed.\\n    mode : {'full', 'r', 'economic', 'raw'}, optional\\n        Determines what information is to be returned: either both Q and R\\n        ('full', default), only R ('r') or both Q and R but computed in\\n        economy-size ('economic', see Notes). The final option 'raw'\\n        (added in SciPy 0.11) makes the function return two matrices\\n        (Q, TAU) in the internal format used by LAPACK.\\n    pivoting : bool, optional\\n        Whether or not factorization should include pivoting for rank-revealing\\n        qr decomposition. If pivoting, compute the decomposition\\n        ``A P = Q R`` as above, but where P is chosen such that the diagonal\\n        of R is non-increasing.\\n    check_finite : bool, optional\\n        Whether to check that the input matrix contains only finite numbers.\\n        Disabling may give a performance gain, but may result in problems\\n        (crashes, non-termination) if the inputs do contain infinities or NaNs.\\n\\n    Returns\\n    -------\\n    Q : float or complex ndarray\\n        Of shape (M, M), or (M, K) for ``mode='economic'``. Not returned\\n        if ``mode='r'``. Replaced by tuple ``(Q, TAU)`` if ``mode='raw'``.\\n    R : float or complex ndarray\\n        Of shape (M, N), or (K, N) for ``mode in ['economic', 'raw']``.\\n        ``K = min(M, N)``.\\n    P : int ndarray\\n        Of shape (N,) for ``pivoting=True``. Not returned if\\n        ``pivoting=False``.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n        Raised if decomposition fails\\n\\n    Notes\\n    -----\\n    This is an interface to the LAPACK routines dgeqrf, zgeqrf,\\n    dorgqr, zungqr, dgeqp3, and zgeqp3.\\n\\n    If ``mode=economic``, the shapes of Q and R are (M, K) and (K, N) instead\\n    of (M,M) and (M,N), with ``K=min(M,N)``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy import linalg\\n    >>> rng = np.random.default_rng()\\n    >>> a = rng.standard_normal((9, 6))\\n\\n    >>> q, r = linalg.qr(a)\\n    >>> np.allclose(a, np.dot(q, r))\\n    True\\n    >>> q.shape, r.shape\\n    ((9, 9), (9, 6))\\n\\n    >>> r2 = linalg.qr(a, mode='r')\\n    >>> np.allclose(r, r2)\\n    True\\n\\n    >>> q3, r3 = linalg.qr(a, mode='economic')\\n    >>> q3.shape, r3.shape\\n    ((9, 6), (6, 6))\\n\\n    >>> q4, r4, p4 = linalg.qr(a, pivoting=True)\\n    >>> d = np.abs(np.diag(r4))\\n    >>> np.all(d[1:] <= d[:-1])\\n    True\\n    >>> np.allclose(a[:, p4], np.dot(q4, r4))\\n    True\\n    >>> q4.shape, r4.shape, p4.shape\\n    ((9, 9), (9, 6), (6,))\\n\\n    >>> q5, r5, p5 = linalg.qr(a, mode='economic', pivoting=True)\\n    >>> q5.shape, r5.shape, p5.shape\\n    ((9, 6), (6, 6), (6,))\\n\\n    \"\n    if mode not in ['full', 'qr', 'r', 'economic', 'raw']:\n        raise ValueError(\"Mode argument should be one of ['full', 'r','economic', 'raw']\")\n    if check_finite:\n        a1 = numpy.asarray_chkfinite(a)\n    else:\n        a1 = numpy.asarray(a)\n    if len(a1.shape) != 2:\n        raise ValueError('expected a 2-D array')\n    (M, N) = a1.shape\n    overwrite_a = overwrite_a or _datacopied(a1, a)\n    if pivoting:\n        (geqp3,) = get_lapack_funcs(('geqp3',), (a1,))\n        (qr, jpvt, tau) = safecall(geqp3, 'geqp3', a1, overwrite_a=overwrite_a)\n        jpvt -= 1\n    else:\n        (geqrf,) = get_lapack_funcs(('geqrf',), (a1,))\n        (qr, tau) = safecall(geqrf, 'geqrf', a1, lwork=lwork, overwrite_a=overwrite_a)\n    if mode not in ['economic', 'raw'] or M < N:\n        R = numpy.triu(qr)\n    else:\n        R = numpy.triu(qr[:N, :])\n    if pivoting:\n        Rj = (R, jpvt)\n    else:\n        Rj = (R,)\n    if mode == 'r':\n        return Rj\n    elif mode == 'raw':\n        return ((qr, tau),) + Rj\n    (gor_un_gqr,) = get_lapack_funcs(('orgqr',), (qr,))\n    if M < N:\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qr[:, :M], tau, lwork=lwork, overwrite_a=1)\n    elif mode == 'economic':\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qr, tau, lwork=lwork, overwrite_a=1)\n    else:\n        t = qr.dtype.char\n        qqr = numpy.empty((M, M), dtype=t)\n        qqr[:, :N] = qr\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qqr, tau, lwork=lwork, overwrite_a=1)\n    return (Q,) + Rj",
            "def qr(a, overwrite_a=False, lwork=None, mode='full', pivoting=False, check_finite=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Compute QR decomposition of a matrix.\\n\\n    Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal\\n    and R upper triangular.\\n\\n    Parameters\\n    ----------\\n    a : (M, N) array_like\\n        Matrix to be decomposed\\n    overwrite_a : bool, optional\\n        Whether data in `a` is overwritten (may improve performance if\\n        `overwrite_a` is set to True by reusing the existing input data\\n        structure rather than creating a new one.)\\n    lwork : int, optional\\n        Work array size, lwork >= a.shape[1]. If None or -1, an optimal size\\n        is computed.\\n    mode : {'full', 'r', 'economic', 'raw'}, optional\\n        Determines what information is to be returned: either both Q and R\\n        ('full', default), only R ('r') or both Q and R but computed in\\n        economy-size ('economic', see Notes). The final option 'raw'\\n        (added in SciPy 0.11) makes the function return two matrices\\n        (Q, TAU) in the internal format used by LAPACK.\\n    pivoting : bool, optional\\n        Whether or not factorization should include pivoting for rank-revealing\\n        qr decomposition. If pivoting, compute the decomposition\\n        ``A P = Q R`` as above, but where P is chosen such that the diagonal\\n        of R is non-increasing.\\n    check_finite : bool, optional\\n        Whether to check that the input matrix contains only finite numbers.\\n        Disabling may give a performance gain, but may result in problems\\n        (crashes, non-termination) if the inputs do contain infinities or NaNs.\\n\\n    Returns\\n    -------\\n    Q : float or complex ndarray\\n        Of shape (M, M), or (M, K) for ``mode='economic'``. Not returned\\n        if ``mode='r'``. Replaced by tuple ``(Q, TAU)`` if ``mode='raw'``.\\n    R : float or complex ndarray\\n        Of shape (M, N), or (K, N) for ``mode in ['economic', 'raw']``.\\n        ``K = min(M, N)``.\\n    P : int ndarray\\n        Of shape (N,) for ``pivoting=True``. Not returned if\\n        ``pivoting=False``.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n        Raised if decomposition fails\\n\\n    Notes\\n    -----\\n    This is an interface to the LAPACK routines dgeqrf, zgeqrf,\\n    dorgqr, zungqr, dgeqp3, and zgeqp3.\\n\\n    If ``mode=economic``, the shapes of Q and R are (M, K) and (K, N) instead\\n    of (M,M) and (M,N), with ``K=min(M,N)``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy import linalg\\n    >>> rng = np.random.default_rng()\\n    >>> a = rng.standard_normal((9, 6))\\n\\n    >>> q, r = linalg.qr(a)\\n    >>> np.allclose(a, np.dot(q, r))\\n    True\\n    >>> q.shape, r.shape\\n    ((9, 9), (9, 6))\\n\\n    >>> r2 = linalg.qr(a, mode='r')\\n    >>> np.allclose(r, r2)\\n    True\\n\\n    >>> q3, r3 = linalg.qr(a, mode='economic')\\n    >>> q3.shape, r3.shape\\n    ((9, 6), (6, 6))\\n\\n    >>> q4, r4, p4 = linalg.qr(a, pivoting=True)\\n    >>> d = np.abs(np.diag(r4))\\n    >>> np.all(d[1:] <= d[:-1])\\n    True\\n    >>> np.allclose(a[:, p4], np.dot(q4, r4))\\n    True\\n    >>> q4.shape, r4.shape, p4.shape\\n    ((9, 9), (9, 6), (6,))\\n\\n    >>> q5, r5, p5 = linalg.qr(a, mode='economic', pivoting=True)\\n    >>> q5.shape, r5.shape, p5.shape\\n    ((9, 6), (6, 6), (6,))\\n\\n    \"\n    if mode not in ['full', 'qr', 'r', 'economic', 'raw']:\n        raise ValueError(\"Mode argument should be one of ['full', 'r','economic', 'raw']\")\n    if check_finite:\n        a1 = numpy.asarray_chkfinite(a)\n    else:\n        a1 = numpy.asarray(a)\n    if len(a1.shape) != 2:\n        raise ValueError('expected a 2-D array')\n    (M, N) = a1.shape\n    overwrite_a = overwrite_a or _datacopied(a1, a)\n    if pivoting:\n        (geqp3,) = get_lapack_funcs(('geqp3',), (a1,))\n        (qr, jpvt, tau) = safecall(geqp3, 'geqp3', a1, overwrite_a=overwrite_a)\n        jpvt -= 1\n    else:\n        (geqrf,) = get_lapack_funcs(('geqrf',), (a1,))\n        (qr, tau) = safecall(geqrf, 'geqrf', a1, lwork=lwork, overwrite_a=overwrite_a)\n    if mode not in ['economic', 'raw'] or M < N:\n        R = numpy.triu(qr)\n    else:\n        R = numpy.triu(qr[:N, :])\n    if pivoting:\n        Rj = (R, jpvt)\n    else:\n        Rj = (R,)\n    if mode == 'r':\n        return Rj\n    elif mode == 'raw':\n        return ((qr, tau),) + Rj\n    (gor_un_gqr,) = get_lapack_funcs(('orgqr',), (qr,))\n    if M < N:\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qr[:, :M], tau, lwork=lwork, overwrite_a=1)\n    elif mode == 'economic':\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qr, tau, lwork=lwork, overwrite_a=1)\n    else:\n        t = qr.dtype.char\n        qqr = numpy.empty((M, M), dtype=t)\n        qqr[:, :N] = qr\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qqr, tau, lwork=lwork, overwrite_a=1)\n    return (Q,) + Rj",
            "def qr(a, overwrite_a=False, lwork=None, mode='full', pivoting=False, check_finite=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Compute QR decomposition of a matrix.\\n\\n    Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal\\n    and R upper triangular.\\n\\n    Parameters\\n    ----------\\n    a : (M, N) array_like\\n        Matrix to be decomposed\\n    overwrite_a : bool, optional\\n        Whether data in `a` is overwritten (may improve performance if\\n        `overwrite_a` is set to True by reusing the existing input data\\n        structure rather than creating a new one.)\\n    lwork : int, optional\\n        Work array size, lwork >= a.shape[1]. If None or -1, an optimal size\\n        is computed.\\n    mode : {'full', 'r', 'economic', 'raw'}, optional\\n        Determines what information is to be returned: either both Q and R\\n        ('full', default), only R ('r') or both Q and R but computed in\\n        economy-size ('economic', see Notes). The final option 'raw'\\n        (added in SciPy 0.11) makes the function return two matrices\\n        (Q, TAU) in the internal format used by LAPACK.\\n    pivoting : bool, optional\\n        Whether or not factorization should include pivoting for rank-revealing\\n        qr decomposition. If pivoting, compute the decomposition\\n        ``A P = Q R`` as above, but where P is chosen such that the diagonal\\n        of R is non-increasing.\\n    check_finite : bool, optional\\n        Whether to check that the input matrix contains only finite numbers.\\n        Disabling may give a performance gain, but may result in problems\\n        (crashes, non-termination) if the inputs do contain infinities or NaNs.\\n\\n    Returns\\n    -------\\n    Q : float or complex ndarray\\n        Of shape (M, M), or (M, K) for ``mode='economic'``. Not returned\\n        if ``mode='r'``. Replaced by tuple ``(Q, TAU)`` if ``mode='raw'``.\\n    R : float or complex ndarray\\n        Of shape (M, N), or (K, N) for ``mode in ['economic', 'raw']``.\\n        ``K = min(M, N)``.\\n    P : int ndarray\\n        Of shape (N,) for ``pivoting=True``. Not returned if\\n        ``pivoting=False``.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n        Raised if decomposition fails\\n\\n    Notes\\n    -----\\n    This is an interface to the LAPACK routines dgeqrf, zgeqrf,\\n    dorgqr, zungqr, dgeqp3, and zgeqp3.\\n\\n    If ``mode=economic``, the shapes of Q and R are (M, K) and (K, N) instead\\n    of (M,M) and (M,N), with ``K=min(M,N)``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy import linalg\\n    >>> rng = np.random.default_rng()\\n    >>> a = rng.standard_normal((9, 6))\\n\\n    >>> q, r = linalg.qr(a)\\n    >>> np.allclose(a, np.dot(q, r))\\n    True\\n    >>> q.shape, r.shape\\n    ((9, 9), (9, 6))\\n\\n    >>> r2 = linalg.qr(a, mode='r')\\n    >>> np.allclose(r, r2)\\n    True\\n\\n    >>> q3, r3 = linalg.qr(a, mode='economic')\\n    >>> q3.shape, r3.shape\\n    ((9, 6), (6, 6))\\n\\n    >>> q4, r4, p4 = linalg.qr(a, pivoting=True)\\n    >>> d = np.abs(np.diag(r4))\\n    >>> np.all(d[1:] <= d[:-1])\\n    True\\n    >>> np.allclose(a[:, p4], np.dot(q4, r4))\\n    True\\n    >>> q4.shape, r4.shape, p4.shape\\n    ((9, 9), (9, 6), (6,))\\n\\n    >>> q5, r5, p5 = linalg.qr(a, mode='economic', pivoting=True)\\n    >>> q5.shape, r5.shape, p5.shape\\n    ((9, 6), (6, 6), (6,))\\n\\n    \"\n    if mode not in ['full', 'qr', 'r', 'economic', 'raw']:\n        raise ValueError(\"Mode argument should be one of ['full', 'r','economic', 'raw']\")\n    if check_finite:\n        a1 = numpy.asarray_chkfinite(a)\n    else:\n        a1 = numpy.asarray(a)\n    if len(a1.shape) != 2:\n        raise ValueError('expected a 2-D array')\n    (M, N) = a1.shape\n    overwrite_a = overwrite_a or _datacopied(a1, a)\n    if pivoting:\n        (geqp3,) = get_lapack_funcs(('geqp3',), (a1,))\n        (qr, jpvt, tau) = safecall(geqp3, 'geqp3', a1, overwrite_a=overwrite_a)\n        jpvt -= 1\n    else:\n        (geqrf,) = get_lapack_funcs(('geqrf',), (a1,))\n        (qr, tau) = safecall(geqrf, 'geqrf', a1, lwork=lwork, overwrite_a=overwrite_a)\n    if mode not in ['economic', 'raw'] or M < N:\n        R = numpy.triu(qr)\n    else:\n        R = numpy.triu(qr[:N, :])\n    if pivoting:\n        Rj = (R, jpvt)\n    else:\n        Rj = (R,)\n    if mode == 'r':\n        return Rj\n    elif mode == 'raw':\n        return ((qr, tau),) + Rj\n    (gor_un_gqr,) = get_lapack_funcs(('orgqr',), (qr,))\n    if M < N:\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qr[:, :M], tau, lwork=lwork, overwrite_a=1)\n    elif mode == 'economic':\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qr, tau, lwork=lwork, overwrite_a=1)\n    else:\n        t = qr.dtype.char\n        qqr = numpy.empty((M, M), dtype=t)\n        qqr[:, :N] = qr\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qqr, tau, lwork=lwork, overwrite_a=1)\n    return (Q,) + Rj",
            "def qr(a, overwrite_a=False, lwork=None, mode='full', pivoting=False, check_finite=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Compute QR decomposition of a matrix.\\n\\n    Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal\\n    and R upper triangular.\\n\\n    Parameters\\n    ----------\\n    a : (M, N) array_like\\n        Matrix to be decomposed\\n    overwrite_a : bool, optional\\n        Whether data in `a` is overwritten (may improve performance if\\n        `overwrite_a` is set to True by reusing the existing input data\\n        structure rather than creating a new one.)\\n    lwork : int, optional\\n        Work array size, lwork >= a.shape[1]. If None or -1, an optimal size\\n        is computed.\\n    mode : {'full', 'r', 'economic', 'raw'}, optional\\n        Determines what information is to be returned: either both Q and R\\n        ('full', default), only R ('r') or both Q and R but computed in\\n        economy-size ('economic', see Notes). The final option 'raw'\\n        (added in SciPy 0.11) makes the function return two matrices\\n        (Q, TAU) in the internal format used by LAPACK.\\n    pivoting : bool, optional\\n        Whether or not factorization should include pivoting for rank-revealing\\n        qr decomposition. If pivoting, compute the decomposition\\n        ``A P = Q R`` as above, but where P is chosen such that the diagonal\\n        of R is non-increasing.\\n    check_finite : bool, optional\\n        Whether to check that the input matrix contains only finite numbers.\\n        Disabling may give a performance gain, but may result in problems\\n        (crashes, non-termination) if the inputs do contain infinities or NaNs.\\n\\n    Returns\\n    -------\\n    Q : float or complex ndarray\\n        Of shape (M, M), or (M, K) for ``mode='economic'``. Not returned\\n        if ``mode='r'``. Replaced by tuple ``(Q, TAU)`` if ``mode='raw'``.\\n    R : float or complex ndarray\\n        Of shape (M, N), or (K, N) for ``mode in ['economic', 'raw']``.\\n        ``K = min(M, N)``.\\n    P : int ndarray\\n        Of shape (N,) for ``pivoting=True``. Not returned if\\n        ``pivoting=False``.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n        Raised if decomposition fails\\n\\n    Notes\\n    -----\\n    This is an interface to the LAPACK routines dgeqrf, zgeqrf,\\n    dorgqr, zungqr, dgeqp3, and zgeqp3.\\n\\n    If ``mode=economic``, the shapes of Q and R are (M, K) and (K, N) instead\\n    of (M,M) and (M,N), with ``K=min(M,N)``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy import linalg\\n    >>> rng = np.random.default_rng()\\n    >>> a = rng.standard_normal((9, 6))\\n\\n    >>> q, r = linalg.qr(a)\\n    >>> np.allclose(a, np.dot(q, r))\\n    True\\n    >>> q.shape, r.shape\\n    ((9, 9), (9, 6))\\n\\n    >>> r2 = linalg.qr(a, mode='r')\\n    >>> np.allclose(r, r2)\\n    True\\n\\n    >>> q3, r3 = linalg.qr(a, mode='economic')\\n    >>> q3.shape, r3.shape\\n    ((9, 6), (6, 6))\\n\\n    >>> q4, r4, p4 = linalg.qr(a, pivoting=True)\\n    >>> d = np.abs(np.diag(r4))\\n    >>> np.all(d[1:] <= d[:-1])\\n    True\\n    >>> np.allclose(a[:, p4], np.dot(q4, r4))\\n    True\\n    >>> q4.shape, r4.shape, p4.shape\\n    ((9, 9), (9, 6), (6,))\\n\\n    >>> q5, r5, p5 = linalg.qr(a, mode='economic', pivoting=True)\\n    >>> q5.shape, r5.shape, p5.shape\\n    ((9, 6), (6, 6), (6,))\\n\\n    \"\n    if mode not in ['full', 'qr', 'r', 'economic', 'raw']:\n        raise ValueError(\"Mode argument should be one of ['full', 'r','economic', 'raw']\")\n    if check_finite:\n        a1 = numpy.asarray_chkfinite(a)\n    else:\n        a1 = numpy.asarray(a)\n    if len(a1.shape) != 2:\n        raise ValueError('expected a 2-D array')\n    (M, N) = a1.shape\n    overwrite_a = overwrite_a or _datacopied(a1, a)\n    if pivoting:\n        (geqp3,) = get_lapack_funcs(('geqp3',), (a1,))\n        (qr, jpvt, tau) = safecall(geqp3, 'geqp3', a1, overwrite_a=overwrite_a)\n        jpvt -= 1\n    else:\n        (geqrf,) = get_lapack_funcs(('geqrf',), (a1,))\n        (qr, tau) = safecall(geqrf, 'geqrf', a1, lwork=lwork, overwrite_a=overwrite_a)\n    if mode not in ['economic', 'raw'] or M < N:\n        R = numpy.triu(qr)\n    else:\n        R = numpy.triu(qr[:N, :])\n    if pivoting:\n        Rj = (R, jpvt)\n    else:\n        Rj = (R,)\n    if mode == 'r':\n        return Rj\n    elif mode == 'raw':\n        return ((qr, tau),) + Rj\n    (gor_un_gqr,) = get_lapack_funcs(('orgqr',), (qr,))\n    if M < N:\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qr[:, :M], tau, lwork=lwork, overwrite_a=1)\n    elif mode == 'economic':\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qr, tau, lwork=lwork, overwrite_a=1)\n    else:\n        t = qr.dtype.char\n        qqr = numpy.empty((M, M), dtype=t)\n        qqr[:, :N] = qr\n        (Q,) = safecall(gor_un_gqr, 'gorgqr/gungqr', qqr, tau, lwork=lwork, overwrite_a=1)\n    return (Q,) + Rj"
        ]
    },
    {
        "func_name": "qr_multiply",
        "original": "def qr_multiply(a, c, mode='right', pivoting=False, conjugate=False, overwrite_a=False, overwrite_c=False):\n    \"\"\"\n    Calculate the QR decomposition and multiply Q with a matrix.\n\n    Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal\n    and R upper triangular. Multiply Q with a vector or a matrix c.\n\n    Parameters\n    ----------\n    a : (M, N), array_like\n        Input array\n    c : array_like\n        Input array to be multiplied by ``q``.\n    mode : {'left', 'right'}, optional\n        ``Q @ c`` is returned if mode is 'left', ``c @ Q`` is returned if\n        mode is 'right'.\n        The shape of c must be appropriate for the matrix multiplications,\n        if mode is 'left', ``min(a.shape) == c.shape[0]``,\n        if mode is 'right', ``a.shape[0] == c.shape[1]``.\n    pivoting : bool, optional\n        Whether or not factorization should include pivoting for rank-revealing\n        qr decomposition, see the documentation of qr.\n    conjugate : bool, optional\n        Whether Q should be complex-conjugated. This might be faster\n        than explicit conjugation.\n    overwrite_a : bool, optional\n        Whether data in a is overwritten (may improve performance)\n    overwrite_c : bool, optional\n        Whether data in c is overwritten (may improve performance).\n        If this is used, c must be big enough to keep the result,\n        i.e. ``c.shape[0]`` = ``a.shape[0]`` if mode is 'left'.\n\n    Returns\n    -------\n    CQ : ndarray\n        The product of ``Q`` and ``c``.\n    R : (K, N), ndarray\n        R array of the resulting QR factorization where ``K = min(M, N)``.\n    P : (N,) ndarray\n        Integer pivot array. Only returned when ``pivoting=True``.\n\n    Raises\n    ------\n    LinAlgError\n        Raised if QR decomposition fails.\n\n    Notes\n    -----\n    This is an interface to the LAPACK routines ``?GEQRF``, ``?ORMQR``,\n    ``?UNMQR``, and ``?GEQP3``.\n\n    .. versionadded:: 0.11.0\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.linalg import qr_multiply, qr\n    >>> A = np.array([[1, 3, 3], [2, 3, 2], [2, 3, 3], [1, 3, 2]])\n    >>> qc, r1, piv1 = qr_multiply(A, 2*np.eye(4), pivoting=1)\n    >>> qc\n    array([[-1.,  1., -1.],\n           [-1., -1.,  1.],\n           [-1., -1., -1.],\n           [-1.,  1.,  1.]])\n    >>> r1\n    array([[-6., -3., -5.            ],\n           [ 0., -1., -1.11022302e-16],\n           [ 0.,  0., -1.            ]])\n    >>> piv1\n    array([1, 0, 2], dtype=int32)\n    >>> q2, r2, piv2 = qr(A, mode='economic', pivoting=1)\n    >>> np.allclose(2*q2 - qc, np.zeros((4, 3)))\n    True\n\n    \"\"\"\n    if mode not in ['left', 'right']:\n        raise ValueError(\"Mode argument can only be 'left' or 'right' but not '{}'\".format(mode))\n    c = numpy.asarray_chkfinite(c)\n    if c.ndim < 2:\n        onedim = True\n        c = numpy.atleast_2d(c)\n        if mode == 'left':\n            c = c.T\n    else:\n        onedim = False\n    a = numpy.atleast_2d(numpy.asarray(a))\n    (M, N) = a.shape\n    if mode == 'left':\n        if c.shape[0] != min(M, N + overwrite_c * (M - N)):\n            raise ValueError('Array shapes are not compatible for Q @ c operation: {} vs {}'.format(a.shape, c.shape))\n    elif M != c.shape[1]:\n        raise ValueError('Array shapes are not compatible for c @ Q operation: {} vs {}'.format(c.shape, a.shape))\n    raw = qr(a, overwrite_a, None, 'raw', pivoting)\n    (Q, tau) = raw[0]\n    (gor_un_mqr,) = get_lapack_funcs(('ormqr',), (Q,))\n    if gor_un_mqr.typecode in ('s', 'd'):\n        trans = 'T'\n    else:\n        trans = 'C'\n    Q = Q[:, :min(M, N)]\n    if M > N and mode == 'left' and (not overwrite_c):\n        if conjugate:\n            cc = numpy.zeros((c.shape[1], M), dtype=c.dtype, order='F')\n            cc[:, :N] = c.T\n        else:\n            cc = numpy.zeros((M, c.shape[1]), dtype=c.dtype, order='F')\n            cc[:N, :] = c\n            trans = 'N'\n        if conjugate:\n            lr = 'R'\n        else:\n            lr = 'L'\n        overwrite_c = True\n    elif c.flags['C_CONTIGUOUS'] and trans == 'T' or conjugate:\n        cc = c.T\n        if mode == 'left':\n            lr = 'R'\n        else:\n            lr = 'L'\n    else:\n        trans = 'N'\n        cc = c\n        if mode == 'left':\n            lr = 'L'\n        else:\n            lr = 'R'\n    (cQ,) = safecall(gor_un_mqr, 'gormqr/gunmqr', lr, trans, Q, tau, cc, overwrite_c=overwrite_c)\n    if trans != 'N':\n        cQ = cQ.T\n    if mode == 'right':\n        cQ = cQ[:, :min(M, N)]\n    if onedim:\n        cQ = cQ.ravel()\n    return (cQ,) + raw[1:]",
        "mutated": [
            "def qr_multiply(a, c, mode='right', pivoting=False, conjugate=False, overwrite_a=False, overwrite_c=False):\n    if False:\n        i = 10\n    \"\\n    Calculate the QR decomposition and multiply Q with a matrix.\\n\\n    Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal\\n    and R upper triangular. Multiply Q with a vector or a matrix c.\\n\\n    Parameters\\n    ----------\\n    a : (M, N), array_like\\n        Input array\\n    c : array_like\\n        Input array to be multiplied by ``q``.\\n    mode : {'left', 'right'}, optional\\n        ``Q @ c`` is returned if mode is 'left', ``c @ Q`` is returned if\\n        mode is 'right'.\\n        The shape of c must be appropriate for the matrix multiplications,\\n        if mode is 'left', ``min(a.shape) == c.shape[0]``,\\n        if mode is 'right', ``a.shape[0] == c.shape[1]``.\\n    pivoting : bool, optional\\n        Whether or not factorization should include pivoting for rank-revealing\\n        qr decomposition, see the documentation of qr.\\n    conjugate : bool, optional\\n        Whether Q should be complex-conjugated. This might be faster\\n        than explicit conjugation.\\n    overwrite_a : bool, optional\\n        Whether data in a is overwritten (may improve performance)\\n    overwrite_c : bool, optional\\n        Whether data in c is overwritten (may improve performance).\\n        If this is used, c must be big enough to keep the result,\\n        i.e. ``c.shape[0]`` = ``a.shape[0]`` if mode is 'left'.\\n\\n    Returns\\n    -------\\n    CQ : ndarray\\n        The product of ``Q`` and ``c``.\\n    R : (K, N), ndarray\\n        R array of the resulting QR factorization where ``K = min(M, N)``.\\n    P : (N,) ndarray\\n        Integer pivot array. Only returned when ``pivoting=True``.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n        Raised if QR decomposition fails.\\n\\n    Notes\\n    -----\\n    This is an interface to the LAPACK routines ``?GEQRF``, ``?ORMQR``,\\n    ``?UNMQR``, and ``?GEQP3``.\\n\\n    .. versionadded:: 0.11.0\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.linalg import qr_multiply, qr\\n    >>> A = np.array([[1, 3, 3], [2, 3, 2], [2, 3, 3], [1, 3, 2]])\\n    >>> qc, r1, piv1 = qr_multiply(A, 2*np.eye(4), pivoting=1)\\n    >>> qc\\n    array([[-1.,  1., -1.],\\n           [-1., -1.,  1.],\\n           [-1., -1., -1.],\\n           [-1.,  1.,  1.]])\\n    >>> r1\\n    array([[-6., -3., -5.            ],\\n           [ 0., -1., -1.11022302e-16],\\n           [ 0.,  0., -1.            ]])\\n    >>> piv1\\n    array([1, 0, 2], dtype=int32)\\n    >>> q2, r2, piv2 = qr(A, mode='economic', pivoting=1)\\n    >>> np.allclose(2*q2 - qc, np.zeros((4, 3)))\\n    True\\n\\n    \"\n    if mode not in ['left', 'right']:\n        raise ValueError(\"Mode argument can only be 'left' or 'right' but not '{}'\".format(mode))\n    c = numpy.asarray_chkfinite(c)\n    if c.ndim < 2:\n        onedim = True\n        c = numpy.atleast_2d(c)\n        if mode == 'left':\n            c = c.T\n    else:\n        onedim = False\n    a = numpy.atleast_2d(numpy.asarray(a))\n    (M, N) = a.shape\n    if mode == 'left':\n        if c.shape[0] != min(M, N + overwrite_c * (M - N)):\n            raise ValueError('Array shapes are not compatible for Q @ c operation: {} vs {}'.format(a.shape, c.shape))\n    elif M != c.shape[1]:\n        raise ValueError('Array shapes are not compatible for c @ Q operation: {} vs {}'.format(c.shape, a.shape))\n    raw = qr(a, overwrite_a, None, 'raw', pivoting)\n    (Q, tau) = raw[0]\n    (gor_un_mqr,) = get_lapack_funcs(('ormqr',), (Q,))\n    if gor_un_mqr.typecode in ('s', 'd'):\n        trans = 'T'\n    else:\n        trans = 'C'\n    Q = Q[:, :min(M, N)]\n    if M > N and mode == 'left' and (not overwrite_c):\n        if conjugate:\n            cc = numpy.zeros((c.shape[1], M), dtype=c.dtype, order='F')\n            cc[:, :N] = c.T\n        else:\n            cc = numpy.zeros((M, c.shape[1]), dtype=c.dtype, order='F')\n            cc[:N, :] = c\n            trans = 'N'\n        if conjugate:\n            lr = 'R'\n        else:\n            lr = 'L'\n        overwrite_c = True\n    elif c.flags['C_CONTIGUOUS'] and trans == 'T' or conjugate:\n        cc = c.T\n        if mode == 'left':\n            lr = 'R'\n        else:\n            lr = 'L'\n    else:\n        trans = 'N'\n        cc = c\n        if mode == 'left':\n            lr = 'L'\n        else:\n            lr = 'R'\n    (cQ,) = safecall(gor_un_mqr, 'gormqr/gunmqr', lr, trans, Q, tau, cc, overwrite_c=overwrite_c)\n    if trans != 'N':\n        cQ = cQ.T\n    if mode == 'right':\n        cQ = cQ[:, :min(M, N)]\n    if onedim:\n        cQ = cQ.ravel()\n    return (cQ,) + raw[1:]",
            "def qr_multiply(a, c, mode='right', pivoting=False, conjugate=False, overwrite_a=False, overwrite_c=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Calculate the QR decomposition and multiply Q with a matrix.\\n\\n    Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal\\n    and R upper triangular. Multiply Q with a vector or a matrix c.\\n\\n    Parameters\\n    ----------\\n    a : (M, N), array_like\\n        Input array\\n    c : array_like\\n        Input array to be multiplied by ``q``.\\n    mode : {'left', 'right'}, optional\\n        ``Q @ c`` is returned if mode is 'left', ``c @ Q`` is returned if\\n        mode is 'right'.\\n        The shape of c must be appropriate for the matrix multiplications,\\n        if mode is 'left', ``min(a.shape) == c.shape[0]``,\\n        if mode is 'right', ``a.shape[0] == c.shape[1]``.\\n    pivoting : bool, optional\\n        Whether or not factorization should include pivoting for rank-revealing\\n        qr decomposition, see the documentation of qr.\\n    conjugate : bool, optional\\n        Whether Q should be complex-conjugated. This might be faster\\n        than explicit conjugation.\\n    overwrite_a : bool, optional\\n        Whether data in a is overwritten (may improve performance)\\n    overwrite_c : bool, optional\\n        Whether data in c is overwritten (may improve performance).\\n        If this is used, c must be big enough to keep the result,\\n        i.e. ``c.shape[0]`` = ``a.shape[0]`` if mode is 'left'.\\n\\n    Returns\\n    -------\\n    CQ : ndarray\\n        The product of ``Q`` and ``c``.\\n    R : (K, N), ndarray\\n        R array of the resulting QR factorization where ``K = min(M, N)``.\\n    P : (N,) ndarray\\n        Integer pivot array. Only returned when ``pivoting=True``.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n        Raised if QR decomposition fails.\\n\\n    Notes\\n    -----\\n    This is an interface to the LAPACK routines ``?GEQRF``, ``?ORMQR``,\\n    ``?UNMQR``, and ``?GEQP3``.\\n\\n    .. versionadded:: 0.11.0\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.linalg import qr_multiply, qr\\n    >>> A = np.array([[1, 3, 3], [2, 3, 2], [2, 3, 3], [1, 3, 2]])\\n    >>> qc, r1, piv1 = qr_multiply(A, 2*np.eye(4), pivoting=1)\\n    >>> qc\\n    array([[-1.,  1., -1.],\\n           [-1., -1.,  1.],\\n           [-1., -1., -1.],\\n           [-1.,  1.,  1.]])\\n    >>> r1\\n    array([[-6., -3., -5.            ],\\n           [ 0., -1., -1.11022302e-16],\\n           [ 0.,  0., -1.            ]])\\n    >>> piv1\\n    array([1, 0, 2], dtype=int32)\\n    >>> q2, r2, piv2 = qr(A, mode='economic', pivoting=1)\\n    >>> np.allclose(2*q2 - qc, np.zeros((4, 3)))\\n    True\\n\\n    \"\n    if mode not in ['left', 'right']:\n        raise ValueError(\"Mode argument can only be 'left' or 'right' but not '{}'\".format(mode))\n    c = numpy.asarray_chkfinite(c)\n    if c.ndim < 2:\n        onedim = True\n        c = numpy.atleast_2d(c)\n        if mode == 'left':\n            c = c.T\n    else:\n        onedim = False\n    a = numpy.atleast_2d(numpy.asarray(a))\n    (M, N) = a.shape\n    if mode == 'left':\n        if c.shape[0] != min(M, N + overwrite_c * (M - N)):\n            raise ValueError('Array shapes are not compatible for Q @ c operation: {} vs {}'.format(a.shape, c.shape))\n    elif M != c.shape[1]:\n        raise ValueError('Array shapes are not compatible for c @ Q operation: {} vs {}'.format(c.shape, a.shape))\n    raw = qr(a, overwrite_a, None, 'raw', pivoting)\n    (Q, tau) = raw[0]\n    (gor_un_mqr,) = get_lapack_funcs(('ormqr',), (Q,))\n    if gor_un_mqr.typecode in ('s', 'd'):\n        trans = 'T'\n    else:\n        trans = 'C'\n    Q = Q[:, :min(M, N)]\n    if M > N and mode == 'left' and (not overwrite_c):\n        if conjugate:\n            cc = numpy.zeros((c.shape[1], M), dtype=c.dtype, order='F')\n            cc[:, :N] = c.T\n        else:\n            cc = numpy.zeros((M, c.shape[1]), dtype=c.dtype, order='F')\n            cc[:N, :] = c\n            trans = 'N'\n        if conjugate:\n            lr = 'R'\n        else:\n            lr = 'L'\n        overwrite_c = True\n    elif c.flags['C_CONTIGUOUS'] and trans == 'T' or conjugate:\n        cc = c.T\n        if mode == 'left':\n            lr = 'R'\n        else:\n            lr = 'L'\n    else:\n        trans = 'N'\n        cc = c\n        if mode == 'left':\n            lr = 'L'\n        else:\n            lr = 'R'\n    (cQ,) = safecall(gor_un_mqr, 'gormqr/gunmqr', lr, trans, Q, tau, cc, overwrite_c=overwrite_c)\n    if trans != 'N':\n        cQ = cQ.T\n    if mode == 'right':\n        cQ = cQ[:, :min(M, N)]\n    if onedim:\n        cQ = cQ.ravel()\n    return (cQ,) + raw[1:]",
            "def qr_multiply(a, c, mode='right', pivoting=False, conjugate=False, overwrite_a=False, overwrite_c=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Calculate the QR decomposition and multiply Q with a matrix.\\n\\n    Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal\\n    and R upper triangular. Multiply Q with a vector or a matrix c.\\n\\n    Parameters\\n    ----------\\n    a : (M, N), array_like\\n        Input array\\n    c : array_like\\n        Input array to be multiplied by ``q``.\\n    mode : {'left', 'right'}, optional\\n        ``Q @ c`` is returned if mode is 'left', ``c @ Q`` is returned if\\n        mode is 'right'.\\n        The shape of c must be appropriate for the matrix multiplications,\\n        if mode is 'left', ``min(a.shape) == c.shape[0]``,\\n        if mode is 'right', ``a.shape[0] == c.shape[1]``.\\n    pivoting : bool, optional\\n        Whether or not factorization should include pivoting for rank-revealing\\n        qr decomposition, see the documentation of qr.\\n    conjugate : bool, optional\\n        Whether Q should be complex-conjugated. This might be faster\\n        than explicit conjugation.\\n    overwrite_a : bool, optional\\n        Whether data in a is overwritten (may improve performance)\\n    overwrite_c : bool, optional\\n        Whether data in c is overwritten (may improve performance).\\n        If this is used, c must be big enough to keep the result,\\n        i.e. ``c.shape[0]`` = ``a.shape[0]`` if mode is 'left'.\\n\\n    Returns\\n    -------\\n    CQ : ndarray\\n        The product of ``Q`` and ``c``.\\n    R : (K, N), ndarray\\n        R array of the resulting QR factorization where ``K = min(M, N)``.\\n    P : (N,) ndarray\\n        Integer pivot array. Only returned when ``pivoting=True``.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n        Raised if QR decomposition fails.\\n\\n    Notes\\n    -----\\n    This is an interface to the LAPACK routines ``?GEQRF``, ``?ORMQR``,\\n    ``?UNMQR``, and ``?GEQP3``.\\n\\n    .. versionadded:: 0.11.0\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.linalg import qr_multiply, qr\\n    >>> A = np.array([[1, 3, 3], [2, 3, 2], [2, 3, 3], [1, 3, 2]])\\n    >>> qc, r1, piv1 = qr_multiply(A, 2*np.eye(4), pivoting=1)\\n    >>> qc\\n    array([[-1.,  1., -1.],\\n           [-1., -1.,  1.],\\n           [-1., -1., -1.],\\n           [-1.,  1.,  1.]])\\n    >>> r1\\n    array([[-6., -3., -5.            ],\\n           [ 0., -1., -1.11022302e-16],\\n           [ 0.,  0., -1.            ]])\\n    >>> piv1\\n    array([1, 0, 2], dtype=int32)\\n    >>> q2, r2, piv2 = qr(A, mode='economic', pivoting=1)\\n    >>> np.allclose(2*q2 - qc, np.zeros((4, 3)))\\n    True\\n\\n    \"\n    if mode not in ['left', 'right']:\n        raise ValueError(\"Mode argument can only be 'left' or 'right' but not '{}'\".format(mode))\n    c = numpy.asarray_chkfinite(c)\n    if c.ndim < 2:\n        onedim = True\n        c = numpy.atleast_2d(c)\n        if mode == 'left':\n            c = c.T\n    else:\n        onedim = False\n    a = numpy.atleast_2d(numpy.asarray(a))\n    (M, N) = a.shape\n    if mode == 'left':\n        if c.shape[0] != min(M, N + overwrite_c * (M - N)):\n            raise ValueError('Array shapes are not compatible for Q @ c operation: {} vs {}'.format(a.shape, c.shape))\n    elif M != c.shape[1]:\n        raise ValueError('Array shapes are not compatible for c @ Q operation: {} vs {}'.format(c.shape, a.shape))\n    raw = qr(a, overwrite_a, None, 'raw', pivoting)\n    (Q, tau) = raw[0]\n    (gor_un_mqr,) = get_lapack_funcs(('ormqr',), (Q,))\n    if gor_un_mqr.typecode in ('s', 'd'):\n        trans = 'T'\n    else:\n        trans = 'C'\n    Q = Q[:, :min(M, N)]\n    if M > N and mode == 'left' and (not overwrite_c):\n        if conjugate:\n            cc = numpy.zeros((c.shape[1], M), dtype=c.dtype, order='F')\n            cc[:, :N] = c.T\n        else:\n            cc = numpy.zeros((M, c.shape[1]), dtype=c.dtype, order='F')\n            cc[:N, :] = c\n            trans = 'N'\n        if conjugate:\n            lr = 'R'\n        else:\n            lr = 'L'\n        overwrite_c = True\n    elif c.flags['C_CONTIGUOUS'] and trans == 'T' or conjugate:\n        cc = c.T\n        if mode == 'left':\n            lr = 'R'\n        else:\n            lr = 'L'\n    else:\n        trans = 'N'\n        cc = c\n        if mode == 'left':\n            lr = 'L'\n        else:\n            lr = 'R'\n    (cQ,) = safecall(gor_un_mqr, 'gormqr/gunmqr', lr, trans, Q, tau, cc, overwrite_c=overwrite_c)\n    if trans != 'N':\n        cQ = cQ.T\n    if mode == 'right':\n        cQ = cQ[:, :min(M, N)]\n    if onedim:\n        cQ = cQ.ravel()\n    return (cQ,) + raw[1:]",
            "def qr_multiply(a, c, mode='right', pivoting=False, conjugate=False, overwrite_a=False, overwrite_c=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Calculate the QR decomposition and multiply Q with a matrix.\\n\\n    Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal\\n    and R upper triangular. Multiply Q with a vector or a matrix c.\\n\\n    Parameters\\n    ----------\\n    a : (M, N), array_like\\n        Input array\\n    c : array_like\\n        Input array to be multiplied by ``q``.\\n    mode : {'left', 'right'}, optional\\n        ``Q @ c`` is returned if mode is 'left', ``c @ Q`` is returned if\\n        mode is 'right'.\\n        The shape of c must be appropriate for the matrix multiplications,\\n        if mode is 'left', ``min(a.shape) == c.shape[0]``,\\n        if mode is 'right', ``a.shape[0] == c.shape[1]``.\\n    pivoting : bool, optional\\n        Whether or not factorization should include pivoting for rank-revealing\\n        qr decomposition, see the documentation of qr.\\n    conjugate : bool, optional\\n        Whether Q should be complex-conjugated. This might be faster\\n        than explicit conjugation.\\n    overwrite_a : bool, optional\\n        Whether data in a is overwritten (may improve performance)\\n    overwrite_c : bool, optional\\n        Whether data in c is overwritten (may improve performance).\\n        If this is used, c must be big enough to keep the result,\\n        i.e. ``c.shape[0]`` = ``a.shape[0]`` if mode is 'left'.\\n\\n    Returns\\n    -------\\n    CQ : ndarray\\n        The product of ``Q`` and ``c``.\\n    R : (K, N), ndarray\\n        R array of the resulting QR factorization where ``K = min(M, N)``.\\n    P : (N,) ndarray\\n        Integer pivot array. Only returned when ``pivoting=True``.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n        Raised if QR decomposition fails.\\n\\n    Notes\\n    -----\\n    This is an interface to the LAPACK routines ``?GEQRF``, ``?ORMQR``,\\n    ``?UNMQR``, and ``?GEQP3``.\\n\\n    .. versionadded:: 0.11.0\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.linalg import qr_multiply, qr\\n    >>> A = np.array([[1, 3, 3], [2, 3, 2], [2, 3, 3], [1, 3, 2]])\\n    >>> qc, r1, piv1 = qr_multiply(A, 2*np.eye(4), pivoting=1)\\n    >>> qc\\n    array([[-1.,  1., -1.],\\n           [-1., -1.,  1.],\\n           [-1., -1., -1.],\\n           [-1.,  1.,  1.]])\\n    >>> r1\\n    array([[-6., -3., -5.            ],\\n           [ 0., -1., -1.11022302e-16],\\n           [ 0.,  0., -1.            ]])\\n    >>> piv1\\n    array([1, 0, 2], dtype=int32)\\n    >>> q2, r2, piv2 = qr(A, mode='economic', pivoting=1)\\n    >>> np.allclose(2*q2 - qc, np.zeros((4, 3)))\\n    True\\n\\n    \"\n    if mode not in ['left', 'right']:\n        raise ValueError(\"Mode argument can only be 'left' or 'right' but not '{}'\".format(mode))\n    c = numpy.asarray_chkfinite(c)\n    if c.ndim < 2:\n        onedim = True\n        c = numpy.atleast_2d(c)\n        if mode == 'left':\n            c = c.T\n    else:\n        onedim = False\n    a = numpy.atleast_2d(numpy.asarray(a))\n    (M, N) = a.shape\n    if mode == 'left':\n        if c.shape[0] != min(M, N + overwrite_c * (M - N)):\n            raise ValueError('Array shapes are not compatible for Q @ c operation: {} vs {}'.format(a.shape, c.shape))\n    elif M != c.shape[1]:\n        raise ValueError('Array shapes are not compatible for c @ Q operation: {} vs {}'.format(c.shape, a.shape))\n    raw = qr(a, overwrite_a, None, 'raw', pivoting)\n    (Q, tau) = raw[0]\n    (gor_un_mqr,) = get_lapack_funcs(('ormqr',), (Q,))\n    if gor_un_mqr.typecode in ('s', 'd'):\n        trans = 'T'\n    else:\n        trans = 'C'\n    Q = Q[:, :min(M, N)]\n    if M > N and mode == 'left' and (not overwrite_c):\n        if conjugate:\n            cc = numpy.zeros((c.shape[1], M), dtype=c.dtype, order='F')\n            cc[:, :N] = c.T\n        else:\n            cc = numpy.zeros((M, c.shape[1]), dtype=c.dtype, order='F')\n            cc[:N, :] = c\n            trans = 'N'\n        if conjugate:\n            lr = 'R'\n        else:\n            lr = 'L'\n        overwrite_c = True\n    elif c.flags['C_CONTIGUOUS'] and trans == 'T' or conjugate:\n        cc = c.T\n        if mode == 'left':\n            lr = 'R'\n        else:\n            lr = 'L'\n    else:\n        trans = 'N'\n        cc = c\n        if mode == 'left':\n            lr = 'L'\n        else:\n            lr = 'R'\n    (cQ,) = safecall(gor_un_mqr, 'gormqr/gunmqr', lr, trans, Q, tau, cc, overwrite_c=overwrite_c)\n    if trans != 'N':\n        cQ = cQ.T\n    if mode == 'right':\n        cQ = cQ[:, :min(M, N)]\n    if onedim:\n        cQ = cQ.ravel()\n    return (cQ,) + raw[1:]",
            "def qr_multiply(a, c, mode='right', pivoting=False, conjugate=False, overwrite_a=False, overwrite_c=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Calculate the QR decomposition and multiply Q with a matrix.\\n\\n    Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal\\n    and R upper triangular. Multiply Q with a vector or a matrix c.\\n\\n    Parameters\\n    ----------\\n    a : (M, N), array_like\\n        Input array\\n    c : array_like\\n        Input array to be multiplied by ``q``.\\n    mode : {'left', 'right'}, optional\\n        ``Q @ c`` is returned if mode is 'left', ``c @ Q`` is returned if\\n        mode is 'right'.\\n        The shape of c must be appropriate for the matrix multiplications,\\n        if mode is 'left', ``min(a.shape) == c.shape[0]``,\\n        if mode is 'right', ``a.shape[0] == c.shape[1]``.\\n    pivoting : bool, optional\\n        Whether or not factorization should include pivoting for rank-revealing\\n        qr decomposition, see the documentation of qr.\\n    conjugate : bool, optional\\n        Whether Q should be complex-conjugated. This might be faster\\n        than explicit conjugation.\\n    overwrite_a : bool, optional\\n        Whether data in a is overwritten (may improve performance)\\n    overwrite_c : bool, optional\\n        Whether data in c is overwritten (may improve performance).\\n        If this is used, c must be big enough to keep the result,\\n        i.e. ``c.shape[0]`` = ``a.shape[0]`` if mode is 'left'.\\n\\n    Returns\\n    -------\\n    CQ : ndarray\\n        The product of ``Q`` and ``c``.\\n    R : (K, N), ndarray\\n        R array of the resulting QR factorization where ``K = min(M, N)``.\\n    P : (N,) ndarray\\n        Integer pivot array. Only returned when ``pivoting=True``.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n        Raised if QR decomposition fails.\\n\\n    Notes\\n    -----\\n    This is an interface to the LAPACK routines ``?GEQRF``, ``?ORMQR``,\\n    ``?UNMQR``, and ``?GEQP3``.\\n\\n    .. versionadded:: 0.11.0\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.linalg import qr_multiply, qr\\n    >>> A = np.array([[1, 3, 3], [2, 3, 2], [2, 3, 3], [1, 3, 2]])\\n    >>> qc, r1, piv1 = qr_multiply(A, 2*np.eye(4), pivoting=1)\\n    >>> qc\\n    array([[-1.,  1., -1.],\\n           [-1., -1.,  1.],\\n           [-1., -1., -1.],\\n           [-1.,  1.,  1.]])\\n    >>> r1\\n    array([[-6., -3., -5.            ],\\n           [ 0., -1., -1.11022302e-16],\\n           [ 0.,  0., -1.            ]])\\n    >>> piv1\\n    array([1, 0, 2], dtype=int32)\\n    >>> q2, r2, piv2 = qr(A, mode='economic', pivoting=1)\\n    >>> np.allclose(2*q2 - qc, np.zeros((4, 3)))\\n    True\\n\\n    \"\n    if mode not in ['left', 'right']:\n        raise ValueError(\"Mode argument can only be 'left' or 'right' but not '{}'\".format(mode))\n    c = numpy.asarray_chkfinite(c)\n    if c.ndim < 2:\n        onedim = True\n        c = numpy.atleast_2d(c)\n        if mode == 'left':\n            c = c.T\n    else:\n        onedim = False\n    a = numpy.atleast_2d(numpy.asarray(a))\n    (M, N) = a.shape\n    if mode == 'left':\n        if c.shape[0] != min(M, N + overwrite_c * (M - N)):\n            raise ValueError('Array shapes are not compatible for Q @ c operation: {} vs {}'.format(a.shape, c.shape))\n    elif M != c.shape[1]:\n        raise ValueError('Array shapes are not compatible for c @ Q operation: {} vs {}'.format(c.shape, a.shape))\n    raw = qr(a, overwrite_a, None, 'raw', pivoting)\n    (Q, tau) = raw[0]\n    (gor_un_mqr,) = get_lapack_funcs(('ormqr',), (Q,))\n    if gor_un_mqr.typecode in ('s', 'd'):\n        trans = 'T'\n    else:\n        trans = 'C'\n    Q = Q[:, :min(M, N)]\n    if M > N and mode == 'left' and (not overwrite_c):\n        if conjugate:\n            cc = numpy.zeros((c.shape[1], M), dtype=c.dtype, order='F')\n            cc[:, :N] = c.T\n        else:\n            cc = numpy.zeros((M, c.shape[1]), dtype=c.dtype, order='F')\n            cc[:N, :] = c\n            trans = 'N'\n        if conjugate:\n            lr = 'R'\n        else:\n            lr = 'L'\n        overwrite_c = True\n    elif c.flags['C_CONTIGUOUS'] and trans == 'T' or conjugate:\n        cc = c.T\n        if mode == 'left':\n            lr = 'R'\n        else:\n            lr = 'L'\n    else:\n        trans = 'N'\n        cc = c\n        if mode == 'left':\n            lr = 'L'\n        else:\n            lr = 'R'\n    (cQ,) = safecall(gor_un_mqr, 'gormqr/gunmqr', lr, trans, Q, tau, cc, overwrite_c=overwrite_c)\n    if trans != 'N':\n        cQ = cQ.T\n    if mode == 'right':\n        cQ = cQ[:, :min(M, N)]\n    if onedim:\n        cQ = cQ.ravel()\n    return (cQ,) + raw[1:]"
        ]
    },
    {
        "func_name": "rq",
        "original": "def rq(a, overwrite_a=False, lwork=None, mode='full', check_finite=True):\n    \"\"\"\n    Compute RQ decomposition of a matrix.\n\n    Calculate the decomposition ``A = R Q`` where Q is unitary/orthogonal\n    and R upper triangular.\n\n    Parameters\n    ----------\n    a : (M, N) array_like\n        Matrix to be decomposed\n    overwrite_a : bool, optional\n        Whether data in a is overwritten (may improve performance)\n    lwork : int, optional\n        Work array size, lwork >= a.shape[1]. If None or -1, an optimal size\n        is computed.\n    mode : {'full', 'r', 'economic'}, optional\n        Determines what information is to be returned: either both Q and R\n        ('full', default), only R ('r') or both Q and R but computed in\n        economy-size ('economic', see Notes).\n    check_finite : bool, optional\n        Whether to check that the input matrix contains only finite numbers.\n        Disabling may give a performance gain, but may result in problems\n        (crashes, non-termination) if the inputs do contain infinities or NaNs.\n\n    Returns\n    -------\n    R : float or complex ndarray\n        Of shape (M, N) or (M, K) for ``mode='economic'``. ``K = min(M, N)``.\n    Q : float or complex ndarray\n        Of shape (N, N) or (K, N) for ``mode='economic'``. Not returned\n        if ``mode='r'``.\n\n    Raises\n    ------\n    LinAlgError\n        If decomposition fails.\n\n    Notes\n    -----\n    This is an interface to the LAPACK routines sgerqf, dgerqf, cgerqf, zgerqf,\n    sorgrq, dorgrq, cungrq and zungrq.\n\n    If ``mode=economic``, the shapes of Q and R are (K, N) and (M, K) instead\n    of (N,N) and (M,N), with ``K=min(M,N)``.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy import linalg\n    >>> rng = np.random.default_rng()\n    >>> a = rng.standard_normal((6, 9))\n    >>> r, q = linalg.rq(a)\n    >>> np.allclose(a, r @ q)\n    True\n    >>> r.shape, q.shape\n    ((6, 9), (9, 9))\n    >>> r2 = linalg.rq(a, mode='r')\n    >>> np.allclose(r, r2)\n    True\n    >>> r3, q3 = linalg.rq(a, mode='economic')\n    >>> r3.shape, q3.shape\n    ((6, 6), (6, 9))\n\n    \"\"\"\n    if mode not in ['full', 'r', 'economic']:\n        raise ValueError(\"Mode argument should be one of ['full', 'r', 'economic']\")\n    if check_finite:\n        a1 = numpy.asarray_chkfinite(a)\n    else:\n        a1 = numpy.asarray(a)\n    if len(a1.shape) != 2:\n        raise ValueError('expected matrix')\n    (M, N) = a1.shape\n    overwrite_a = overwrite_a or _datacopied(a1, a)\n    (gerqf,) = get_lapack_funcs(('gerqf',), (a1,))\n    (rq, tau) = safecall(gerqf, 'gerqf', a1, lwork=lwork, overwrite_a=overwrite_a)\n    if not mode == 'economic' or N < M:\n        R = numpy.triu(rq, N - M)\n    else:\n        R = numpy.triu(rq[-M:, -M:])\n    if mode == 'r':\n        return R\n    (gor_un_grq,) = get_lapack_funcs(('orgrq',), (rq,))\n    if N < M:\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq[-N:], tau, lwork=lwork, overwrite_a=1)\n    elif mode == 'economic':\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq, tau, lwork=lwork, overwrite_a=1)\n    else:\n        rq1 = numpy.empty((N, N), dtype=rq.dtype)\n        rq1[-M:] = rq\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq1, tau, lwork=lwork, overwrite_a=1)\n    return (R, Q)",
        "mutated": [
            "def rq(a, overwrite_a=False, lwork=None, mode='full', check_finite=True):\n    if False:\n        i = 10\n    \"\\n    Compute RQ decomposition of a matrix.\\n\\n    Calculate the decomposition ``A = R Q`` where Q is unitary/orthogonal\\n    and R upper triangular.\\n\\n    Parameters\\n    ----------\\n    a : (M, N) array_like\\n        Matrix to be decomposed\\n    overwrite_a : bool, optional\\n        Whether data in a is overwritten (may improve performance)\\n    lwork : int, optional\\n        Work array size, lwork >= a.shape[1]. If None or -1, an optimal size\\n        is computed.\\n    mode : {'full', 'r', 'economic'}, optional\\n        Determines what information is to be returned: either both Q and R\\n        ('full', default), only R ('r') or both Q and R but computed in\\n        economy-size ('economic', see Notes).\\n    check_finite : bool, optional\\n        Whether to check that the input matrix contains only finite numbers.\\n        Disabling may give a performance gain, but may result in problems\\n        (crashes, non-termination) if the inputs do contain infinities or NaNs.\\n\\n    Returns\\n    -------\\n    R : float or complex ndarray\\n        Of shape (M, N) or (M, K) for ``mode='economic'``. ``K = min(M, N)``.\\n    Q : float or complex ndarray\\n        Of shape (N, N) or (K, N) for ``mode='economic'``. Not returned\\n        if ``mode='r'``.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n        If decomposition fails.\\n\\n    Notes\\n    -----\\n    This is an interface to the LAPACK routines sgerqf, dgerqf, cgerqf, zgerqf,\\n    sorgrq, dorgrq, cungrq and zungrq.\\n\\n    If ``mode=economic``, the shapes of Q and R are (K, N) and (M, K) instead\\n    of (N,N) and (M,N), with ``K=min(M,N)``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy import linalg\\n    >>> rng = np.random.default_rng()\\n    >>> a = rng.standard_normal((6, 9))\\n    >>> r, q = linalg.rq(a)\\n    >>> np.allclose(a, r @ q)\\n    True\\n    >>> r.shape, q.shape\\n    ((6, 9), (9, 9))\\n    >>> r2 = linalg.rq(a, mode='r')\\n    >>> np.allclose(r, r2)\\n    True\\n    >>> r3, q3 = linalg.rq(a, mode='economic')\\n    >>> r3.shape, q3.shape\\n    ((6, 6), (6, 9))\\n\\n    \"\n    if mode not in ['full', 'r', 'economic']:\n        raise ValueError(\"Mode argument should be one of ['full', 'r', 'economic']\")\n    if check_finite:\n        a1 = numpy.asarray_chkfinite(a)\n    else:\n        a1 = numpy.asarray(a)\n    if len(a1.shape) != 2:\n        raise ValueError('expected matrix')\n    (M, N) = a1.shape\n    overwrite_a = overwrite_a or _datacopied(a1, a)\n    (gerqf,) = get_lapack_funcs(('gerqf',), (a1,))\n    (rq, tau) = safecall(gerqf, 'gerqf', a1, lwork=lwork, overwrite_a=overwrite_a)\n    if not mode == 'economic' or N < M:\n        R = numpy.triu(rq, N - M)\n    else:\n        R = numpy.triu(rq[-M:, -M:])\n    if mode == 'r':\n        return R\n    (gor_un_grq,) = get_lapack_funcs(('orgrq',), (rq,))\n    if N < M:\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq[-N:], tau, lwork=lwork, overwrite_a=1)\n    elif mode == 'economic':\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq, tau, lwork=lwork, overwrite_a=1)\n    else:\n        rq1 = numpy.empty((N, N), dtype=rq.dtype)\n        rq1[-M:] = rq\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq1, tau, lwork=lwork, overwrite_a=1)\n    return (R, Q)",
            "def rq(a, overwrite_a=False, lwork=None, mode='full', check_finite=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Compute RQ decomposition of a matrix.\\n\\n    Calculate the decomposition ``A = R Q`` where Q is unitary/orthogonal\\n    and R upper triangular.\\n\\n    Parameters\\n    ----------\\n    a : (M, N) array_like\\n        Matrix to be decomposed\\n    overwrite_a : bool, optional\\n        Whether data in a is overwritten (may improve performance)\\n    lwork : int, optional\\n        Work array size, lwork >= a.shape[1]. If None or -1, an optimal size\\n        is computed.\\n    mode : {'full', 'r', 'economic'}, optional\\n        Determines what information is to be returned: either both Q and R\\n        ('full', default), only R ('r') or both Q and R but computed in\\n        economy-size ('economic', see Notes).\\n    check_finite : bool, optional\\n        Whether to check that the input matrix contains only finite numbers.\\n        Disabling may give a performance gain, but may result in problems\\n        (crashes, non-termination) if the inputs do contain infinities or NaNs.\\n\\n    Returns\\n    -------\\n    R : float or complex ndarray\\n        Of shape (M, N) or (M, K) for ``mode='economic'``. ``K = min(M, N)``.\\n    Q : float or complex ndarray\\n        Of shape (N, N) or (K, N) for ``mode='economic'``. Not returned\\n        if ``mode='r'``.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n        If decomposition fails.\\n\\n    Notes\\n    -----\\n    This is an interface to the LAPACK routines sgerqf, dgerqf, cgerqf, zgerqf,\\n    sorgrq, dorgrq, cungrq and zungrq.\\n\\n    If ``mode=economic``, the shapes of Q and R are (K, N) and (M, K) instead\\n    of (N,N) and (M,N), with ``K=min(M,N)``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy import linalg\\n    >>> rng = np.random.default_rng()\\n    >>> a = rng.standard_normal((6, 9))\\n    >>> r, q = linalg.rq(a)\\n    >>> np.allclose(a, r @ q)\\n    True\\n    >>> r.shape, q.shape\\n    ((6, 9), (9, 9))\\n    >>> r2 = linalg.rq(a, mode='r')\\n    >>> np.allclose(r, r2)\\n    True\\n    >>> r3, q3 = linalg.rq(a, mode='economic')\\n    >>> r3.shape, q3.shape\\n    ((6, 6), (6, 9))\\n\\n    \"\n    if mode not in ['full', 'r', 'economic']:\n        raise ValueError(\"Mode argument should be one of ['full', 'r', 'economic']\")\n    if check_finite:\n        a1 = numpy.asarray_chkfinite(a)\n    else:\n        a1 = numpy.asarray(a)\n    if len(a1.shape) != 2:\n        raise ValueError('expected matrix')\n    (M, N) = a1.shape\n    overwrite_a = overwrite_a or _datacopied(a1, a)\n    (gerqf,) = get_lapack_funcs(('gerqf',), (a1,))\n    (rq, tau) = safecall(gerqf, 'gerqf', a1, lwork=lwork, overwrite_a=overwrite_a)\n    if not mode == 'economic' or N < M:\n        R = numpy.triu(rq, N - M)\n    else:\n        R = numpy.triu(rq[-M:, -M:])\n    if mode == 'r':\n        return R\n    (gor_un_grq,) = get_lapack_funcs(('orgrq',), (rq,))\n    if N < M:\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq[-N:], tau, lwork=lwork, overwrite_a=1)\n    elif mode == 'economic':\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq, tau, lwork=lwork, overwrite_a=1)\n    else:\n        rq1 = numpy.empty((N, N), dtype=rq.dtype)\n        rq1[-M:] = rq\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq1, tau, lwork=lwork, overwrite_a=1)\n    return (R, Q)",
            "def rq(a, overwrite_a=False, lwork=None, mode='full', check_finite=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Compute RQ decomposition of a matrix.\\n\\n    Calculate the decomposition ``A = R Q`` where Q is unitary/orthogonal\\n    and R upper triangular.\\n\\n    Parameters\\n    ----------\\n    a : (M, N) array_like\\n        Matrix to be decomposed\\n    overwrite_a : bool, optional\\n        Whether data in a is overwritten (may improve performance)\\n    lwork : int, optional\\n        Work array size, lwork >= a.shape[1]. If None or -1, an optimal size\\n        is computed.\\n    mode : {'full', 'r', 'economic'}, optional\\n        Determines what information is to be returned: either both Q and R\\n        ('full', default), only R ('r') or both Q and R but computed in\\n        economy-size ('economic', see Notes).\\n    check_finite : bool, optional\\n        Whether to check that the input matrix contains only finite numbers.\\n        Disabling may give a performance gain, but may result in problems\\n        (crashes, non-termination) if the inputs do contain infinities or NaNs.\\n\\n    Returns\\n    -------\\n    R : float or complex ndarray\\n        Of shape (M, N) or (M, K) for ``mode='economic'``. ``K = min(M, N)``.\\n    Q : float or complex ndarray\\n        Of shape (N, N) or (K, N) for ``mode='economic'``. Not returned\\n        if ``mode='r'``.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n        If decomposition fails.\\n\\n    Notes\\n    -----\\n    This is an interface to the LAPACK routines sgerqf, dgerqf, cgerqf, zgerqf,\\n    sorgrq, dorgrq, cungrq and zungrq.\\n\\n    If ``mode=economic``, the shapes of Q and R are (K, N) and (M, K) instead\\n    of (N,N) and (M,N), with ``K=min(M,N)``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy import linalg\\n    >>> rng = np.random.default_rng()\\n    >>> a = rng.standard_normal((6, 9))\\n    >>> r, q = linalg.rq(a)\\n    >>> np.allclose(a, r @ q)\\n    True\\n    >>> r.shape, q.shape\\n    ((6, 9), (9, 9))\\n    >>> r2 = linalg.rq(a, mode='r')\\n    >>> np.allclose(r, r2)\\n    True\\n    >>> r3, q3 = linalg.rq(a, mode='economic')\\n    >>> r3.shape, q3.shape\\n    ((6, 6), (6, 9))\\n\\n    \"\n    if mode not in ['full', 'r', 'economic']:\n        raise ValueError(\"Mode argument should be one of ['full', 'r', 'economic']\")\n    if check_finite:\n        a1 = numpy.asarray_chkfinite(a)\n    else:\n        a1 = numpy.asarray(a)\n    if len(a1.shape) != 2:\n        raise ValueError('expected matrix')\n    (M, N) = a1.shape\n    overwrite_a = overwrite_a or _datacopied(a1, a)\n    (gerqf,) = get_lapack_funcs(('gerqf',), (a1,))\n    (rq, tau) = safecall(gerqf, 'gerqf', a1, lwork=lwork, overwrite_a=overwrite_a)\n    if not mode == 'economic' or N < M:\n        R = numpy.triu(rq, N - M)\n    else:\n        R = numpy.triu(rq[-M:, -M:])\n    if mode == 'r':\n        return R\n    (gor_un_grq,) = get_lapack_funcs(('orgrq',), (rq,))\n    if N < M:\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq[-N:], tau, lwork=lwork, overwrite_a=1)\n    elif mode == 'economic':\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq, tau, lwork=lwork, overwrite_a=1)\n    else:\n        rq1 = numpy.empty((N, N), dtype=rq.dtype)\n        rq1[-M:] = rq\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq1, tau, lwork=lwork, overwrite_a=1)\n    return (R, Q)",
            "def rq(a, overwrite_a=False, lwork=None, mode='full', check_finite=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Compute RQ decomposition of a matrix.\\n\\n    Calculate the decomposition ``A = R Q`` where Q is unitary/orthogonal\\n    and R upper triangular.\\n\\n    Parameters\\n    ----------\\n    a : (M, N) array_like\\n        Matrix to be decomposed\\n    overwrite_a : bool, optional\\n        Whether data in a is overwritten (may improve performance)\\n    lwork : int, optional\\n        Work array size, lwork >= a.shape[1]. If None or -1, an optimal size\\n        is computed.\\n    mode : {'full', 'r', 'economic'}, optional\\n        Determines what information is to be returned: either both Q and R\\n        ('full', default), only R ('r') or both Q and R but computed in\\n        economy-size ('economic', see Notes).\\n    check_finite : bool, optional\\n        Whether to check that the input matrix contains only finite numbers.\\n        Disabling may give a performance gain, but may result in problems\\n        (crashes, non-termination) if the inputs do contain infinities or NaNs.\\n\\n    Returns\\n    -------\\n    R : float or complex ndarray\\n        Of shape (M, N) or (M, K) for ``mode='economic'``. ``K = min(M, N)``.\\n    Q : float or complex ndarray\\n        Of shape (N, N) or (K, N) for ``mode='economic'``. Not returned\\n        if ``mode='r'``.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n        If decomposition fails.\\n\\n    Notes\\n    -----\\n    This is an interface to the LAPACK routines sgerqf, dgerqf, cgerqf, zgerqf,\\n    sorgrq, dorgrq, cungrq and zungrq.\\n\\n    If ``mode=economic``, the shapes of Q and R are (K, N) and (M, K) instead\\n    of (N,N) and (M,N), with ``K=min(M,N)``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy import linalg\\n    >>> rng = np.random.default_rng()\\n    >>> a = rng.standard_normal((6, 9))\\n    >>> r, q = linalg.rq(a)\\n    >>> np.allclose(a, r @ q)\\n    True\\n    >>> r.shape, q.shape\\n    ((6, 9), (9, 9))\\n    >>> r2 = linalg.rq(a, mode='r')\\n    >>> np.allclose(r, r2)\\n    True\\n    >>> r3, q3 = linalg.rq(a, mode='economic')\\n    >>> r3.shape, q3.shape\\n    ((6, 6), (6, 9))\\n\\n    \"\n    if mode not in ['full', 'r', 'economic']:\n        raise ValueError(\"Mode argument should be one of ['full', 'r', 'economic']\")\n    if check_finite:\n        a1 = numpy.asarray_chkfinite(a)\n    else:\n        a1 = numpy.asarray(a)\n    if len(a1.shape) != 2:\n        raise ValueError('expected matrix')\n    (M, N) = a1.shape\n    overwrite_a = overwrite_a or _datacopied(a1, a)\n    (gerqf,) = get_lapack_funcs(('gerqf',), (a1,))\n    (rq, tau) = safecall(gerqf, 'gerqf', a1, lwork=lwork, overwrite_a=overwrite_a)\n    if not mode == 'economic' or N < M:\n        R = numpy.triu(rq, N - M)\n    else:\n        R = numpy.triu(rq[-M:, -M:])\n    if mode == 'r':\n        return R\n    (gor_un_grq,) = get_lapack_funcs(('orgrq',), (rq,))\n    if N < M:\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq[-N:], tau, lwork=lwork, overwrite_a=1)\n    elif mode == 'economic':\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq, tau, lwork=lwork, overwrite_a=1)\n    else:\n        rq1 = numpy.empty((N, N), dtype=rq.dtype)\n        rq1[-M:] = rq\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq1, tau, lwork=lwork, overwrite_a=1)\n    return (R, Q)",
            "def rq(a, overwrite_a=False, lwork=None, mode='full', check_finite=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Compute RQ decomposition of a matrix.\\n\\n    Calculate the decomposition ``A = R Q`` where Q is unitary/orthogonal\\n    and R upper triangular.\\n\\n    Parameters\\n    ----------\\n    a : (M, N) array_like\\n        Matrix to be decomposed\\n    overwrite_a : bool, optional\\n        Whether data in a is overwritten (may improve performance)\\n    lwork : int, optional\\n        Work array size, lwork >= a.shape[1]. If None or -1, an optimal size\\n        is computed.\\n    mode : {'full', 'r', 'economic'}, optional\\n        Determines what information is to be returned: either both Q and R\\n        ('full', default), only R ('r') or both Q and R but computed in\\n        economy-size ('economic', see Notes).\\n    check_finite : bool, optional\\n        Whether to check that the input matrix contains only finite numbers.\\n        Disabling may give a performance gain, but may result in problems\\n        (crashes, non-termination) if the inputs do contain infinities or NaNs.\\n\\n    Returns\\n    -------\\n    R : float or complex ndarray\\n        Of shape (M, N) or (M, K) for ``mode='economic'``. ``K = min(M, N)``.\\n    Q : float or complex ndarray\\n        Of shape (N, N) or (K, N) for ``mode='economic'``. Not returned\\n        if ``mode='r'``.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n        If decomposition fails.\\n\\n    Notes\\n    -----\\n    This is an interface to the LAPACK routines sgerqf, dgerqf, cgerqf, zgerqf,\\n    sorgrq, dorgrq, cungrq and zungrq.\\n\\n    If ``mode=economic``, the shapes of Q and R are (K, N) and (M, K) instead\\n    of (N,N) and (M,N), with ``K=min(M,N)``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy import linalg\\n    >>> rng = np.random.default_rng()\\n    >>> a = rng.standard_normal((6, 9))\\n    >>> r, q = linalg.rq(a)\\n    >>> np.allclose(a, r @ q)\\n    True\\n    >>> r.shape, q.shape\\n    ((6, 9), (9, 9))\\n    >>> r2 = linalg.rq(a, mode='r')\\n    >>> np.allclose(r, r2)\\n    True\\n    >>> r3, q3 = linalg.rq(a, mode='economic')\\n    >>> r3.shape, q3.shape\\n    ((6, 6), (6, 9))\\n\\n    \"\n    if mode not in ['full', 'r', 'economic']:\n        raise ValueError(\"Mode argument should be one of ['full', 'r', 'economic']\")\n    if check_finite:\n        a1 = numpy.asarray_chkfinite(a)\n    else:\n        a1 = numpy.asarray(a)\n    if len(a1.shape) != 2:\n        raise ValueError('expected matrix')\n    (M, N) = a1.shape\n    overwrite_a = overwrite_a or _datacopied(a1, a)\n    (gerqf,) = get_lapack_funcs(('gerqf',), (a1,))\n    (rq, tau) = safecall(gerqf, 'gerqf', a1, lwork=lwork, overwrite_a=overwrite_a)\n    if not mode == 'economic' or N < M:\n        R = numpy.triu(rq, N - M)\n    else:\n        R = numpy.triu(rq[-M:, -M:])\n    if mode == 'r':\n        return R\n    (gor_un_grq,) = get_lapack_funcs(('orgrq',), (rq,))\n    if N < M:\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq[-N:], tau, lwork=lwork, overwrite_a=1)\n    elif mode == 'economic':\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq, tau, lwork=lwork, overwrite_a=1)\n    else:\n        rq1 = numpy.empty((N, N), dtype=rq.dtype)\n        rq1[-M:] = rq\n        (Q,) = safecall(gor_un_grq, 'gorgrq/gungrq', rq1, tau, lwork=lwork, overwrite_a=1)\n    return (R, Q)"
        ]
    }
]