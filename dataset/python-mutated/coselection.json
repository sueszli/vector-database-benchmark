[
    {
        "func_name": "f_score",
        "original": "def f_score(evaluated_sentences, reference_sentences, weight=1.0):\n    \"\"\"\n    Computation of F-Score measure. It is computed as\n    F(E) = ( (W^2 + 1) * P(E) * R(E) ) / ( W^2 * P(E) + R(E) ), where:\n\n    - P(E) is precision metrics of extract E.\n    - R(E) is recall metrics of extract E.\n    - W is a weighting factor that favours P(E) metrics\n      when W > 1 and favours R(E) metrics when W < 1.\n\n    If W = 1.0 (default value) basic F-Score is computed.\n    It is equivalent to F(E) = (2 * P(E) * R(E)) / (P(E) + R(E)).\n\n    :parameter iterable evaluated_sentences:\n        Sentences of evaluated extract.\n    :parameter iterable reference_sentences:\n        Sentences of reference extract.\n    :returns float:\n        Returns 0.0 <= P(E) <= 1.0\n    \"\"\"\n    p = precision(evaluated_sentences, reference_sentences)\n    r = recall(evaluated_sentences, reference_sentences)\n    weight **= 2\n    denominator = weight * p + r\n    if denominator == 0.0:\n        return 0.0\n    else:\n        return (weight + 1) * p * r / denominator",
        "mutated": [
            "def f_score(evaluated_sentences, reference_sentences, weight=1.0):\n    if False:\n        i = 10\n    '\\n    Computation of F-Score measure. It is computed as\\n    F(E) = ( (W^2 + 1) * P(E) * R(E) ) / ( W^2 * P(E) + R(E) ), where:\\n\\n    - P(E) is precision metrics of extract E.\\n    - R(E) is recall metrics of extract E.\\n    - W is a weighting factor that favours P(E) metrics\\n      when W > 1 and favours R(E) metrics when W < 1.\\n\\n    If W = 1.0 (default value) basic F-Score is computed.\\n    It is equivalent to F(E) = (2 * P(E) * R(E)) / (P(E) + R(E)).\\n\\n    :parameter iterable evaluated_sentences:\\n        Sentences of evaluated extract.\\n    :parameter iterable reference_sentences:\\n        Sentences of reference extract.\\n    :returns float:\\n        Returns 0.0 <= P(E) <= 1.0\\n    '\n    p = precision(evaluated_sentences, reference_sentences)\n    r = recall(evaluated_sentences, reference_sentences)\n    weight **= 2\n    denominator = weight * p + r\n    if denominator == 0.0:\n        return 0.0\n    else:\n        return (weight + 1) * p * r / denominator",
            "def f_score(evaluated_sentences, reference_sentences, weight=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Computation of F-Score measure. It is computed as\\n    F(E) = ( (W^2 + 1) * P(E) * R(E) ) / ( W^2 * P(E) + R(E) ), where:\\n\\n    - P(E) is precision metrics of extract E.\\n    - R(E) is recall metrics of extract E.\\n    - W is a weighting factor that favours P(E) metrics\\n      when W > 1 and favours R(E) metrics when W < 1.\\n\\n    If W = 1.0 (default value) basic F-Score is computed.\\n    It is equivalent to F(E) = (2 * P(E) * R(E)) / (P(E) + R(E)).\\n\\n    :parameter iterable evaluated_sentences:\\n        Sentences of evaluated extract.\\n    :parameter iterable reference_sentences:\\n        Sentences of reference extract.\\n    :returns float:\\n        Returns 0.0 <= P(E) <= 1.0\\n    '\n    p = precision(evaluated_sentences, reference_sentences)\n    r = recall(evaluated_sentences, reference_sentences)\n    weight **= 2\n    denominator = weight * p + r\n    if denominator == 0.0:\n        return 0.0\n    else:\n        return (weight + 1) * p * r / denominator",
            "def f_score(evaluated_sentences, reference_sentences, weight=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Computation of F-Score measure. It is computed as\\n    F(E) = ( (W^2 + 1) * P(E) * R(E) ) / ( W^2 * P(E) + R(E) ), where:\\n\\n    - P(E) is precision metrics of extract E.\\n    - R(E) is recall metrics of extract E.\\n    - W is a weighting factor that favours P(E) metrics\\n      when W > 1 and favours R(E) metrics when W < 1.\\n\\n    If W = 1.0 (default value) basic F-Score is computed.\\n    It is equivalent to F(E) = (2 * P(E) * R(E)) / (P(E) + R(E)).\\n\\n    :parameter iterable evaluated_sentences:\\n        Sentences of evaluated extract.\\n    :parameter iterable reference_sentences:\\n        Sentences of reference extract.\\n    :returns float:\\n        Returns 0.0 <= P(E) <= 1.0\\n    '\n    p = precision(evaluated_sentences, reference_sentences)\n    r = recall(evaluated_sentences, reference_sentences)\n    weight **= 2\n    denominator = weight * p + r\n    if denominator == 0.0:\n        return 0.0\n    else:\n        return (weight + 1) * p * r / denominator",
            "def f_score(evaluated_sentences, reference_sentences, weight=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Computation of F-Score measure. It is computed as\\n    F(E) = ( (W^2 + 1) * P(E) * R(E) ) / ( W^2 * P(E) + R(E) ), where:\\n\\n    - P(E) is precision metrics of extract E.\\n    - R(E) is recall metrics of extract E.\\n    - W is a weighting factor that favours P(E) metrics\\n      when W > 1 and favours R(E) metrics when W < 1.\\n\\n    If W = 1.0 (default value) basic F-Score is computed.\\n    It is equivalent to F(E) = (2 * P(E) * R(E)) / (P(E) + R(E)).\\n\\n    :parameter iterable evaluated_sentences:\\n        Sentences of evaluated extract.\\n    :parameter iterable reference_sentences:\\n        Sentences of reference extract.\\n    :returns float:\\n        Returns 0.0 <= P(E) <= 1.0\\n    '\n    p = precision(evaluated_sentences, reference_sentences)\n    r = recall(evaluated_sentences, reference_sentences)\n    weight **= 2\n    denominator = weight * p + r\n    if denominator == 0.0:\n        return 0.0\n    else:\n        return (weight + 1) * p * r / denominator",
            "def f_score(evaluated_sentences, reference_sentences, weight=1.0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Computation of F-Score measure. It is computed as\\n    F(E) = ( (W^2 + 1) * P(E) * R(E) ) / ( W^2 * P(E) + R(E) ), where:\\n\\n    - P(E) is precision metrics of extract E.\\n    - R(E) is recall metrics of extract E.\\n    - W is a weighting factor that favours P(E) metrics\\n      when W > 1 and favours R(E) metrics when W < 1.\\n\\n    If W = 1.0 (default value) basic F-Score is computed.\\n    It is equivalent to F(E) = (2 * P(E) * R(E)) / (P(E) + R(E)).\\n\\n    :parameter iterable evaluated_sentences:\\n        Sentences of evaluated extract.\\n    :parameter iterable reference_sentences:\\n        Sentences of reference extract.\\n    :returns float:\\n        Returns 0.0 <= P(E) <= 1.0\\n    '\n    p = precision(evaluated_sentences, reference_sentences)\n    r = recall(evaluated_sentences, reference_sentences)\n    weight **= 2\n    denominator = weight * p + r\n    if denominator == 0.0:\n        return 0.0\n    else:\n        return (weight + 1) * p * r / denominator"
        ]
    },
    {
        "func_name": "precision",
        "original": "def precision(evaluated_sentences, reference_sentences):\n    \"\"\"\n    Intrinsic method of evaluation for extracts. It is computed as\n    P(E) = A / B, where:\n\n    - A is count of common sentences occurring in both extracts.\n    - B is count of sentences in evaluated extract.\n\n    :parameter iterable evaluated_sentences:\n        Sentences of evaluated extract.\n    :parameter iterable reference_sentences:\n        Sentences of reference extract.\n    :returns float:\n        Returns 0.0 <= P(E) <= 1.0\n    \"\"\"\n    return _divide_evaluation(reference_sentences, evaluated_sentences)",
        "mutated": [
            "def precision(evaluated_sentences, reference_sentences):\n    if False:\n        i = 10\n    '\\n    Intrinsic method of evaluation for extracts. It is computed as\\n    P(E) = A / B, where:\\n\\n    - A is count of common sentences occurring in both extracts.\\n    - B is count of sentences in evaluated extract.\\n\\n    :parameter iterable evaluated_sentences:\\n        Sentences of evaluated extract.\\n    :parameter iterable reference_sentences:\\n        Sentences of reference extract.\\n    :returns float:\\n        Returns 0.0 <= P(E) <= 1.0\\n    '\n    return _divide_evaluation(reference_sentences, evaluated_sentences)",
            "def precision(evaluated_sentences, reference_sentences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Intrinsic method of evaluation for extracts. It is computed as\\n    P(E) = A / B, where:\\n\\n    - A is count of common sentences occurring in both extracts.\\n    - B is count of sentences in evaluated extract.\\n\\n    :parameter iterable evaluated_sentences:\\n        Sentences of evaluated extract.\\n    :parameter iterable reference_sentences:\\n        Sentences of reference extract.\\n    :returns float:\\n        Returns 0.0 <= P(E) <= 1.0\\n    '\n    return _divide_evaluation(reference_sentences, evaluated_sentences)",
            "def precision(evaluated_sentences, reference_sentences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Intrinsic method of evaluation for extracts. It is computed as\\n    P(E) = A / B, where:\\n\\n    - A is count of common sentences occurring in both extracts.\\n    - B is count of sentences in evaluated extract.\\n\\n    :parameter iterable evaluated_sentences:\\n        Sentences of evaluated extract.\\n    :parameter iterable reference_sentences:\\n        Sentences of reference extract.\\n    :returns float:\\n        Returns 0.0 <= P(E) <= 1.0\\n    '\n    return _divide_evaluation(reference_sentences, evaluated_sentences)",
            "def precision(evaluated_sentences, reference_sentences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Intrinsic method of evaluation for extracts. It is computed as\\n    P(E) = A / B, where:\\n\\n    - A is count of common sentences occurring in both extracts.\\n    - B is count of sentences in evaluated extract.\\n\\n    :parameter iterable evaluated_sentences:\\n        Sentences of evaluated extract.\\n    :parameter iterable reference_sentences:\\n        Sentences of reference extract.\\n    :returns float:\\n        Returns 0.0 <= P(E) <= 1.0\\n    '\n    return _divide_evaluation(reference_sentences, evaluated_sentences)",
            "def precision(evaluated_sentences, reference_sentences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Intrinsic method of evaluation for extracts. It is computed as\\n    P(E) = A / B, where:\\n\\n    - A is count of common sentences occurring in both extracts.\\n    - B is count of sentences in evaluated extract.\\n\\n    :parameter iterable evaluated_sentences:\\n        Sentences of evaluated extract.\\n    :parameter iterable reference_sentences:\\n        Sentences of reference extract.\\n    :returns float:\\n        Returns 0.0 <= P(E) <= 1.0\\n    '\n    return _divide_evaluation(reference_sentences, evaluated_sentences)"
        ]
    },
    {
        "func_name": "recall",
        "original": "def recall(evaluated_sentences, reference_sentences):\n    \"\"\"\n    Intrinsic method of evaluation for extracts. It is computed as\n    R(E) = A / C, where:\n\n    - A is count of common sentences in both extracts.\n    - C is count of sentences in reference extract.\n\n    :parameter iterable evaluated_sentences:\n        Sentences of evaluated extract.\n    :parameter iterable reference_sentences:\n        Sentences of reference extract.\n    :returns float:\n        Returns 0.0 <= R(E) <= 1.0\n    \"\"\"\n    return _divide_evaluation(evaluated_sentences, reference_sentences)",
        "mutated": [
            "def recall(evaluated_sentences, reference_sentences):\n    if False:\n        i = 10\n    '\\n    Intrinsic method of evaluation for extracts. It is computed as\\n    R(E) = A / C, where:\\n\\n    - A is count of common sentences in both extracts.\\n    - C is count of sentences in reference extract.\\n\\n    :parameter iterable evaluated_sentences:\\n        Sentences of evaluated extract.\\n    :parameter iterable reference_sentences:\\n        Sentences of reference extract.\\n    :returns float:\\n        Returns 0.0 <= R(E) <= 1.0\\n    '\n    return _divide_evaluation(evaluated_sentences, reference_sentences)",
            "def recall(evaluated_sentences, reference_sentences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Intrinsic method of evaluation for extracts. It is computed as\\n    R(E) = A / C, where:\\n\\n    - A is count of common sentences in both extracts.\\n    - C is count of sentences in reference extract.\\n\\n    :parameter iterable evaluated_sentences:\\n        Sentences of evaluated extract.\\n    :parameter iterable reference_sentences:\\n        Sentences of reference extract.\\n    :returns float:\\n        Returns 0.0 <= R(E) <= 1.0\\n    '\n    return _divide_evaluation(evaluated_sentences, reference_sentences)",
            "def recall(evaluated_sentences, reference_sentences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Intrinsic method of evaluation for extracts. It is computed as\\n    R(E) = A / C, where:\\n\\n    - A is count of common sentences in both extracts.\\n    - C is count of sentences in reference extract.\\n\\n    :parameter iterable evaluated_sentences:\\n        Sentences of evaluated extract.\\n    :parameter iterable reference_sentences:\\n        Sentences of reference extract.\\n    :returns float:\\n        Returns 0.0 <= R(E) <= 1.0\\n    '\n    return _divide_evaluation(evaluated_sentences, reference_sentences)",
            "def recall(evaluated_sentences, reference_sentences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Intrinsic method of evaluation for extracts. It is computed as\\n    R(E) = A / C, where:\\n\\n    - A is count of common sentences in both extracts.\\n    - C is count of sentences in reference extract.\\n\\n    :parameter iterable evaluated_sentences:\\n        Sentences of evaluated extract.\\n    :parameter iterable reference_sentences:\\n        Sentences of reference extract.\\n    :returns float:\\n        Returns 0.0 <= R(E) <= 1.0\\n    '\n    return _divide_evaluation(evaluated_sentences, reference_sentences)",
            "def recall(evaluated_sentences, reference_sentences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Intrinsic method of evaluation for extracts. It is computed as\\n    R(E) = A / C, where:\\n\\n    - A is count of common sentences in both extracts.\\n    - C is count of sentences in reference extract.\\n\\n    :parameter iterable evaluated_sentences:\\n        Sentences of evaluated extract.\\n    :parameter iterable reference_sentences:\\n        Sentences of reference extract.\\n    :returns float:\\n        Returns 0.0 <= R(E) <= 1.0\\n    '\n    return _divide_evaluation(evaluated_sentences, reference_sentences)"
        ]
    },
    {
        "func_name": "_divide_evaluation",
        "original": "def _divide_evaluation(numerator_sentences, denominator_sentences):\n    denominator_sentences = frozenset(denominator_sentences)\n    numerator_sentences = frozenset(numerator_sentences)\n    if len(numerator_sentences) == 0 or len(denominator_sentences) == 0:\n        raise ValueError('Both collections have to contain at least 1 sentence.')\n    common_count = len(denominator_sentences & numerator_sentences)\n    choosen_count = len(denominator_sentences)\n    assert choosen_count != 0\n    return common_count / choosen_count",
        "mutated": [
            "def _divide_evaluation(numerator_sentences, denominator_sentences):\n    if False:\n        i = 10\n    denominator_sentences = frozenset(denominator_sentences)\n    numerator_sentences = frozenset(numerator_sentences)\n    if len(numerator_sentences) == 0 or len(denominator_sentences) == 0:\n        raise ValueError('Both collections have to contain at least 1 sentence.')\n    common_count = len(denominator_sentences & numerator_sentences)\n    choosen_count = len(denominator_sentences)\n    assert choosen_count != 0\n    return common_count / choosen_count",
            "def _divide_evaluation(numerator_sentences, denominator_sentences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    denominator_sentences = frozenset(denominator_sentences)\n    numerator_sentences = frozenset(numerator_sentences)\n    if len(numerator_sentences) == 0 or len(denominator_sentences) == 0:\n        raise ValueError('Both collections have to contain at least 1 sentence.')\n    common_count = len(denominator_sentences & numerator_sentences)\n    choosen_count = len(denominator_sentences)\n    assert choosen_count != 0\n    return common_count / choosen_count",
            "def _divide_evaluation(numerator_sentences, denominator_sentences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    denominator_sentences = frozenset(denominator_sentences)\n    numerator_sentences = frozenset(numerator_sentences)\n    if len(numerator_sentences) == 0 or len(denominator_sentences) == 0:\n        raise ValueError('Both collections have to contain at least 1 sentence.')\n    common_count = len(denominator_sentences & numerator_sentences)\n    choosen_count = len(denominator_sentences)\n    assert choosen_count != 0\n    return common_count / choosen_count",
            "def _divide_evaluation(numerator_sentences, denominator_sentences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    denominator_sentences = frozenset(denominator_sentences)\n    numerator_sentences = frozenset(numerator_sentences)\n    if len(numerator_sentences) == 0 or len(denominator_sentences) == 0:\n        raise ValueError('Both collections have to contain at least 1 sentence.')\n    common_count = len(denominator_sentences & numerator_sentences)\n    choosen_count = len(denominator_sentences)\n    assert choosen_count != 0\n    return common_count / choosen_count",
            "def _divide_evaluation(numerator_sentences, denominator_sentences):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    denominator_sentences = frozenset(denominator_sentences)\n    numerator_sentences = frozenset(numerator_sentences)\n    if len(numerator_sentences) == 0 or len(denominator_sentences) == 0:\n        raise ValueError('Both collections have to contain at least 1 sentence.')\n    common_count = len(denominator_sentences & numerator_sentences)\n    choosen_count = len(denominator_sentences)\n    assert choosen_count != 0\n    return common_count / choosen_count"
        ]
    }
]