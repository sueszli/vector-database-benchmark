[
    {
        "func_name": "__init__",
        "original": "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, filter_extern=None, bprop=False):\n    super(XpropWinograd_2x2_3x3, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    SMs = _get_sm_count()\n    self.autotune_key = ' '.join((native_str(x) for x in (op + '_2x2_3x3', SMs, dtype.itemsize, N, C, K, H, W, P, Q)))\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)\n    if filter_extern is None:\n        self.init()\n    else:\n        self.initialized = True\n        self.init(autotune=1, filter_extern=filter_extern)\n    lib.set_scratch_size(self.filter_trans.size, self.bsum.size)",
        "mutated": [
            "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, filter_extern=None, bprop=False):\n    if False:\n        i = 10\n    super(XpropWinograd_2x2_3x3, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    SMs = _get_sm_count()\n    self.autotune_key = ' '.join((native_str(x) for x in (op + '_2x2_3x3', SMs, dtype.itemsize, N, C, K, H, W, P, Q)))\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)\n    if filter_extern is None:\n        self.init()\n    else:\n        self.initialized = True\n        self.init(autotune=1, filter_extern=filter_extern)\n    lib.set_scratch_size(self.filter_trans.size, self.bsum.size)",
            "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, filter_extern=None, bprop=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(XpropWinograd_2x2_3x3, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    SMs = _get_sm_count()\n    self.autotune_key = ' '.join((native_str(x) for x in (op + '_2x2_3x3', SMs, dtype.itemsize, N, C, K, H, W, P, Q)))\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)\n    if filter_extern is None:\n        self.init()\n    else:\n        self.initialized = True\n        self.init(autotune=1, filter_extern=filter_extern)\n    lib.set_scratch_size(self.filter_trans.size, self.bsum.size)",
            "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, filter_extern=None, bprop=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(XpropWinograd_2x2_3x3, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    SMs = _get_sm_count()\n    self.autotune_key = ' '.join((native_str(x) for x in (op + '_2x2_3x3', SMs, dtype.itemsize, N, C, K, H, W, P, Q)))\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)\n    if filter_extern is None:\n        self.init()\n    else:\n        self.initialized = True\n        self.init(autotune=1, filter_extern=filter_extern)\n    lib.set_scratch_size(self.filter_trans.size, self.bsum.size)",
            "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, filter_extern=None, bprop=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(XpropWinograd_2x2_3x3, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    SMs = _get_sm_count()\n    self.autotune_key = ' '.join((native_str(x) for x in (op + '_2x2_3x3', SMs, dtype.itemsize, N, C, K, H, W, P, Q)))\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)\n    if filter_extern is None:\n        self.init()\n    else:\n        self.initialized = True\n        self.init(autotune=1, filter_extern=filter_extern)\n    lib.set_scratch_size(self.filter_trans.size, self.bsum.size)",
            "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, filter_extern=None, bprop=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(XpropWinograd_2x2_3x3, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    SMs = _get_sm_count()\n    self.autotune_key = ' '.join((native_str(x) for x in (op + '_2x2_3x3', SMs, dtype.itemsize, N, C, K, H, W, P, Q)))\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)\n    if filter_extern is None:\n        self.init()\n    else:\n        self.initialized = True\n        self.init(autotune=1, filter_extern=filter_extern)\n    lib.set_scratch_size(self.filter_trans.size, self.bsum.size)"
        ]
    },
    {
        "func_name": "init",
        "original": "def init(self, autotune=0, filter_extern=0):\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    itemsize = self.dtype.itemsize\n    if not autotune:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            if self.autotune_key in autotune_db:\n                filter_extern = autotune_db[self.autotune_key]\n                self.initialized = True\n            else:\n                filter_extern = True\n                self.initialized = False\n    self.filter_extern = filter_extern\n    if N == 1:\n        shiftN = 0\n    elif N < 32:\n        shiftN = len(bin(N - 1)) - 2\n    else:\n        shiftN = 5\n    blockN = 1 << shiftN\n    (superP, shiftP, superQ, shiftQ, superN) = {1: (515, 3, 768, 4, 0), 2: (515, 3, 513, 3, 1), 4: (260, 2, 514, 3, 3), 8: (260, 2, 259, 2, 7), 16: (0, 1, 260, 2, 15), 32: (0, 1, 0, 1, 31)}.get(blockN)\n    blockP = 1 << shiftP\n    blockQ = 1 << shiftQ\n    gridP = _ceil_div(P, blockP)\n    gridQ = _ceil_div(Q, blockQ)\n    gridN = _ceil_div(N, blockN)\n    gridK = _ceil_div(K, 32)\n    gridP2 = max(gridP // 2, 1)\n    gridQ2 = gridQ * 2\n    n = _closest_divisor(gridN, 2)\n    k = _closest_divisor(gridK, 4)\n    nk = n * k\n    Qnk = gridQ2 * nk\n    magic_Qnk = _magic64(Qnk)\n    magic_nk = _magic32(Qnk, nk)\n    magic_k = _magic32(nk, k)\n    gridPQ = gridP * gridQ\n    grid = (gridPQ * nk, gridK // k, gridN // n)\n    block = (256, 1, 1)\n    options = list()\n    if filter_extern:\n        options.append('FX')\n    options.append(('K', K))\n    options.append(('W', W))\n    options.append(('Q', Q))\n    options.append(('N', N))\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_2x2_3x3_32x32' % self.clss\n    self.kernel_args = [grid, block, None, None, None, None, None, None, None, None, None]\n    self.kernel_args.extend(_flatten([C, H, P, pad_h, pad_w, H * W * N, W * N, P * Q * N, Q * N, Qnk, nk, n, k, magic_Qnk, magic_nk, magic_k, R * S * K, 4 * R * S * K * itemsize, 4 * H * W * N * itemsize, gridK, gridP2, gridQ, gridN, gridQ * gridN, gridPQ * gridN, superP, superQ, superN, shiftP, shiftQ, shiftN]))\n    self.bsum = BatchNormSum(self.lib, K, gridPQ * gridN)",
        "mutated": [
            "def init(self, autotune=0, filter_extern=0):\n    if False:\n        i = 10\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    itemsize = self.dtype.itemsize\n    if not autotune:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            if self.autotune_key in autotune_db:\n                filter_extern = autotune_db[self.autotune_key]\n                self.initialized = True\n            else:\n                filter_extern = True\n                self.initialized = False\n    self.filter_extern = filter_extern\n    if N == 1:\n        shiftN = 0\n    elif N < 32:\n        shiftN = len(bin(N - 1)) - 2\n    else:\n        shiftN = 5\n    blockN = 1 << shiftN\n    (superP, shiftP, superQ, shiftQ, superN) = {1: (515, 3, 768, 4, 0), 2: (515, 3, 513, 3, 1), 4: (260, 2, 514, 3, 3), 8: (260, 2, 259, 2, 7), 16: (0, 1, 260, 2, 15), 32: (0, 1, 0, 1, 31)}.get(blockN)\n    blockP = 1 << shiftP\n    blockQ = 1 << shiftQ\n    gridP = _ceil_div(P, blockP)\n    gridQ = _ceil_div(Q, blockQ)\n    gridN = _ceil_div(N, blockN)\n    gridK = _ceil_div(K, 32)\n    gridP2 = max(gridP // 2, 1)\n    gridQ2 = gridQ * 2\n    n = _closest_divisor(gridN, 2)\n    k = _closest_divisor(gridK, 4)\n    nk = n * k\n    Qnk = gridQ2 * nk\n    magic_Qnk = _magic64(Qnk)\n    magic_nk = _magic32(Qnk, nk)\n    magic_k = _magic32(nk, k)\n    gridPQ = gridP * gridQ\n    grid = (gridPQ * nk, gridK // k, gridN // n)\n    block = (256, 1, 1)\n    options = list()\n    if filter_extern:\n        options.append('FX')\n    options.append(('K', K))\n    options.append(('W', W))\n    options.append(('Q', Q))\n    options.append(('N', N))\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_2x2_3x3_32x32' % self.clss\n    self.kernel_args = [grid, block, None, None, None, None, None, None, None, None, None]\n    self.kernel_args.extend(_flatten([C, H, P, pad_h, pad_w, H * W * N, W * N, P * Q * N, Q * N, Qnk, nk, n, k, magic_Qnk, magic_nk, magic_k, R * S * K, 4 * R * S * K * itemsize, 4 * H * W * N * itemsize, gridK, gridP2, gridQ, gridN, gridQ * gridN, gridPQ * gridN, superP, superQ, superN, shiftP, shiftQ, shiftN]))\n    self.bsum = BatchNormSum(self.lib, K, gridPQ * gridN)",
            "def init(self, autotune=0, filter_extern=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    itemsize = self.dtype.itemsize\n    if not autotune:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            if self.autotune_key in autotune_db:\n                filter_extern = autotune_db[self.autotune_key]\n                self.initialized = True\n            else:\n                filter_extern = True\n                self.initialized = False\n    self.filter_extern = filter_extern\n    if N == 1:\n        shiftN = 0\n    elif N < 32:\n        shiftN = len(bin(N - 1)) - 2\n    else:\n        shiftN = 5\n    blockN = 1 << shiftN\n    (superP, shiftP, superQ, shiftQ, superN) = {1: (515, 3, 768, 4, 0), 2: (515, 3, 513, 3, 1), 4: (260, 2, 514, 3, 3), 8: (260, 2, 259, 2, 7), 16: (0, 1, 260, 2, 15), 32: (0, 1, 0, 1, 31)}.get(blockN)\n    blockP = 1 << shiftP\n    blockQ = 1 << shiftQ\n    gridP = _ceil_div(P, blockP)\n    gridQ = _ceil_div(Q, blockQ)\n    gridN = _ceil_div(N, blockN)\n    gridK = _ceil_div(K, 32)\n    gridP2 = max(gridP // 2, 1)\n    gridQ2 = gridQ * 2\n    n = _closest_divisor(gridN, 2)\n    k = _closest_divisor(gridK, 4)\n    nk = n * k\n    Qnk = gridQ2 * nk\n    magic_Qnk = _magic64(Qnk)\n    magic_nk = _magic32(Qnk, nk)\n    magic_k = _magic32(nk, k)\n    gridPQ = gridP * gridQ\n    grid = (gridPQ * nk, gridK // k, gridN // n)\n    block = (256, 1, 1)\n    options = list()\n    if filter_extern:\n        options.append('FX')\n    options.append(('K', K))\n    options.append(('W', W))\n    options.append(('Q', Q))\n    options.append(('N', N))\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_2x2_3x3_32x32' % self.clss\n    self.kernel_args = [grid, block, None, None, None, None, None, None, None, None, None]\n    self.kernel_args.extend(_flatten([C, H, P, pad_h, pad_w, H * W * N, W * N, P * Q * N, Q * N, Qnk, nk, n, k, magic_Qnk, magic_nk, magic_k, R * S * K, 4 * R * S * K * itemsize, 4 * H * W * N * itemsize, gridK, gridP2, gridQ, gridN, gridQ * gridN, gridPQ * gridN, superP, superQ, superN, shiftP, shiftQ, shiftN]))\n    self.bsum = BatchNormSum(self.lib, K, gridPQ * gridN)",
            "def init(self, autotune=0, filter_extern=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    itemsize = self.dtype.itemsize\n    if not autotune:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            if self.autotune_key in autotune_db:\n                filter_extern = autotune_db[self.autotune_key]\n                self.initialized = True\n            else:\n                filter_extern = True\n                self.initialized = False\n    self.filter_extern = filter_extern\n    if N == 1:\n        shiftN = 0\n    elif N < 32:\n        shiftN = len(bin(N - 1)) - 2\n    else:\n        shiftN = 5\n    blockN = 1 << shiftN\n    (superP, shiftP, superQ, shiftQ, superN) = {1: (515, 3, 768, 4, 0), 2: (515, 3, 513, 3, 1), 4: (260, 2, 514, 3, 3), 8: (260, 2, 259, 2, 7), 16: (0, 1, 260, 2, 15), 32: (0, 1, 0, 1, 31)}.get(blockN)\n    blockP = 1 << shiftP\n    blockQ = 1 << shiftQ\n    gridP = _ceil_div(P, blockP)\n    gridQ = _ceil_div(Q, blockQ)\n    gridN = _ceil_div(N, blockN)\n    gridK = _ceil_div(K, 32)\n    gridP2 = max(gridP // 2, 1)\n    gridQ2 = gridQ * 2\n    n = _closest_divisor(gridN, 2)\n    k = _closest_divisor(gridK, 4)\n    nk = n * k\n    Qnk = gridQ2 * nk\n    magic_Qnk = _magic64(Qnk)\n    magic_nk = _magic32(Qnk, nk)\n    magic_k = _magic32(nk, k)\n    gridPQ = gridP * gridQ\n    grid = (gridPQ * nk, gridK // k, gridN // n)\n    block = (256, 1, 1)\n    options = list()\n    if filter_extern:\n        options.append('FX')\n    options.append(('K', K))\n    options.append(('W', W))\n    options.append(('Q', Q))\n    options.append(('N', N))\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_2x2_3x3_32x32' % self.clss\n    self.kernel_args = [grid, block, None, None, None, None, None, None, None, None, None]\n    self.kernel_args.extend(_flatten([C, H, P, pad_h, pad_w, H * W * N, W * N, P * Q * N, Q * N, Qnk, nk, n, k, magic_Qnk, magic_nk, magic_k, R * S * K, 4 * R * S * K * itemsize, 4 * H * W * N * itemsize, gridK, gridP2, gridQ, gridN, gridQ * gridN, gridPQ * gridN, superP, superQ, superN, shiftP, shiftQ, shiftN]))\n    self.bsum = BatchNormSum(self.lib, K, gridPQ * gridN)",
            "def init(self, autotune=0, filter_extern=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    itemsize = self.dtype.itemsize\n    if not autotune:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            if self.autotune_key in autotune_db:\n                filter_extern = autotune_db[self.autotune_key]\n                self.initialized = True\n            else:\n                filter_extern = True\n                self.initialized = False\n    self.filter_extern = filter_extern\n    if N == 1:\n        shiftN = 0\n    elif N < 32:\n        shiftN = len(bin(N - 1)) - 2\n    else:\n        shiftN = 5\n    blockN = 1 << shiftN\n    (superP, shiftP, superQ, shiftQ, superN) = {1: (515, 3, 768, 4, 0), 2: (515, 3, 513, 3, 1), 4: (260, 2, 514, 3, 3), 8: (260, 2, 259, 2, 7), 16: (0, 1, 260, 2, 15), 32: (0, 1, 0, 1, 31)}.get(blockN)\n    blockP = 1 << shiftP\n    blockQ = 1 << shiftQ\n    gridP = _ceil_div(P, blockP)\n    gridQ = _ceil_div(Q, blockQ)\n    gridN = _ceil_div(N, blockN)\n    gridK = _ceil_div(K, 32)\n    gridP2 = max(gridP // 2, 1)\n    gridQ2 = gridQ * 2\n    n = _closest_divisor(gridN, 2)\n    k = _closest_divisor(gridK, 4)\n    nk = n * k\n    Qnk = gridQ2 * nk\n    magic_Qnk = _magic64(Qnk)\n    magic_nk = _magic32(Qnk, nk)\n    magic_k = _magic32(nk, k)\n    gridPQ = gridP * gridQ\n    grid = (gridPQ * nk, gridK // k, gridN // n)\n    block = (256, 1, 1)\n    options = list()\n    if filter_extern:\n        options.append('FX')\n    options.append(('K', K))\n    options.append(('W', W))\n    options.append(('Q', Q))\n    options.append(('N', N))\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_2x2_3x3_32x32' % self.clss\n    self.kernel_args = [grid, block, None, None, None, None, None, None, None, None, None]\n    self.kernel_args.extend(_flatten([C, H, P, pad_h, pad_w, H * W * N, W * N, P * Q * N, Q * N, Qnk, nk, n, k, magic_Qnk, magic_nk, magic_k, R * S * K, 4 * R * S * K * itemsize, 4 * H * W * N * itemsize, gridK, gridP2, gridQ, gridN, gridQ * gridN, gridPQ * gridN, superP, superQ, superN, shiftP, shiftQ, shiftN]))\n    self.bsum = BatchNormSum(self.lib, K, gridPQ * gridN)",
            "def init(self, autotune=0, filter_extern=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    itemsize = self.dtype.itemsize\n    if not autotune:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            if self.autotune_key in autotune_db:\n                filter_extern = autotune_db[self.autotune_key]\n                self.initialized = True\n            else:\n                filter_extern = True\n                self.initialized = False\n    self.filter_extern = filter_extern\n    if N == 1:\n        shiftN = 0\n    elif N < 32:\n        shiftN = len(bin(N - 1)) - 2\n    else:\n        shiftN = 5\n    blockN = 1 << shiftN\n    (superP, shiftP, superQ, shiftQ, superN) = {1: (515, 3, 768, 4, 0), 2: (515, 3, 513, 3, 1), 4: (260, 2, 514, 3, 3), 8: (260, 2, 259, 2, 7), 16: (0, 1, 260, 2, 15), 32: (0, 1, 0, 1, 31)}.get(blockN)\n    blockP = 1 << shiftP\n    blockQ = 1 << shiftQ\n    gridP = _ceil_div(P, blockP)\n    gridQ = _ceil_div(Q, blockQ)\n    gridN = _ceil_div(N, blockN)\n    gridK = _ceil_div(K, 32)\n    gridP2 = max(gridP // 2, 1)\n    gridQ2 = gridQ * 2\n    n = _closest_divisor(gridN, 2)\n    k = _closest_divisor(gridK, 4)\n    nk = n * k\n    Qnk = gridQ2 * nk\n    magic_Qnk = _magic64(Qnk)\n    magic_nk = _magic32(Qnk, nk)\n    magic_k = _magic32(nk, k)\n    gridPQ = gridP * gridQ\n    grid = (gridPQ * nk, gridK // k, gridN // n)\n    block = (256, 1, 1)\n    options = list()\n    if filter_extern:\n        options.append('FX')\n    options.append(('K', K))\n    options.append(('W', W))\n    options.append(('Q', Q))\n    options.append(('N', N))\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_2x2_3x3_32x32' % self.clss\n    self.kernel_args = [grid, block, None, None, None, None, None, None, None, None, None]\n    self.kernel_args.extend(_flatten([C, H, P, pad_h, pad_w, H * W * N, W * N, P * Q * N, Q * N, Qnk, nk, n, k, magic_Qnk, magic_nk, magic_k, R * S * K, 4 * R * S * K * itemsize, 4 * H * W * N * itemsize, gridK, gridP2, gridQ, gridN, gridQ * gridN, gridPQ * gridN, superP, superQ, superN, shiftP, shiftQ, shiftN]))\n    self.bsum = BatchNormSum(self.lib, K, gridPQ * gridN)"
        ]
    },
    {
        "func_name": "autotune",
        "original": "def autotune(self, I, F, O):\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=1, filter_extern=1)\n        self.bind_params(I, F, O, no_op=1)\n        self.execute(repeat=self.warmup, unbind=False)\n    results = []\n    for external in (0, 1):\n        self.init(autotune=1, filter_extern=external)\n        self.bind_params(I, F, O, no_op=1)\n        start.record(stream=self.lib.stream)\n        self.execute(repeat=self.warmup, unbind=False)\n        stop.record(stream=self.lib.stream)\n        stop.synchronize()\n        msecs = stop.time_since(start) / self.warmup\n        results.append((msecs, external))\n    results.sort()\n    external = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[self.autotune_key] = external\n    self.init(autotune=0, filter_extern=external)",
        "mutated": [
            "def autotune(self, I, F, O):\n    if False:\n        i = 10\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=1, filter_extern=1)\n        self.bind_params(I, F, O, no_op=1)\n        self.execute(repeat=self.warmup, unbind=False)\n    results = []\n    for external in (0, 1):\n        self.init(autotune=1, filter_extern=external)\n        self.bind_params(I, F, O, no_op=1)\n        start.record(stream=self.lib.stream)\n        self.execute(repeat=self.warmup, unbind=False)\n        stop.record(stream=self.lib.stream)\n        stop.synchronize()\n        msecs = stop.time_since(start) / self.warmup\n        results.append((msecs, external))\n    results.sort()\n    external = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[self.autotune_key] = external\n    self.init(autotune=0, filter_extern=external)",
            "def autotune(self, I, F, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=1, filter_extern=1)\n        self.bind_params(I, F, O, no_op=1)\n        self.execute(repeat=self.warmup, unbind=False)\n    results = []\n    for external in (0, 1):\n        self.init(autotune=1, filter_extern=external)\n        self.bind_params(I, F, O, no_op=1)\n        start.record(stream=self.lib.stream)\n        self.execute(repeat=self.warmup, unbind=False)\n        stop.record(stream=self.lib.stream)\n        stop.synchronize()\n        msecs = stop.time_since(start) / self.warmup\n        results.append((msecs, external))\n    results.sort()\n    external = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[self.autotune_key] = external\n    self.init(autotune=0, filter_extern=external)",
            "def autotune(self, I, F, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=1, filter_extern=1)\n        self.bind_params(I, F, O, no_op=1)\n        self.execute(repeat=self.warmup, unbind=False)\n    results = []\n    for external in (0, 1):\n        self.init(autotune=1, filter_extern=external)\n        self.bind_params(I, F, O, no_op=1)\n        start.record(stream=self.lib.stream)\n        self.execute(repeat=self.warmup, unbind=False)\n        stop.record(stream=self.lib.stream)\n        stop.synchronize()\n        msecs = stop.time_since(start) / self.warmup\n        results.append((msecs, external))\n    results.sort()\n    external = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[self.autotune_key] = external\n    self.init(autotune=0, filter_extern=external)",
            "def autotune(self, I, F, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=1, filter_extern=1)\n        self.bind_params(I, F, O, no_op=1)\n        self.execute(repeat=self.warmup, unbind=False)\n    results = []\n    for external in (0, 1):\n        self.init(autotune=1, filter_extern=external)\n        self.bind_params(I, F, O, no_op=1)\n        start.record(stream=self.lib.stream)\n        self.execute(repeat=self.warmup, unbind=False)\n        stop.record(stream=self.lib.stream)\n        stop.synchronize()\n        msecs = stop.time_since(start) / self.warmup\n        results.append((msecs, external))\n    results.sort()\n    external = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[self.autotune_key] = external\n    self.init(autotune=0, filter_extern=external)",
            "def autotune(self, I, F, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=1, filter_extern=1)\n        self.bind_params(I, F, O, no_op=1)\n        self.execute(repeat=self.warmup, unbind=False)\n    results = []\n    for external in (0, 1):\n        self.init(autotune=1, filter_extern=external)\n        self.bind_params(I, F, O, no_op=1)\n        start.record(stream=self.lib.stream)\n        self.execute(repeat=self.warmup, unbind=False)\n        stop.record(stream=self.lib.stream)\n        stop.synchronize()\n        msecs = stop.time_since(start) / self.warmup\n        results.append((msecs, external))\n    results.sort()\n    external = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[self.autotune_key] = external\n    self.init(autotune=0, filter_extern=external)"
        ]
    },
    {
        "func_name": "bind_params",
        "original": "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    assert I.dtype == O.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, F, O)\n    self.lib.scratch_buffer_init()\n    filter_data = self.filter_trans.bind_params(F)\n    (bsum_data, x_data) = self.xprop_params(O, X, bias, bsum, beta, relu, brelu, slope)\n    self.kernel_args[2:11] = (self.lib.stream, bsum_data, x_data, O.gpudata, I.gpudata, filter_data, alpha, beta or slope, no_op)",
        "mutated": [
            "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    if False:\n        i = 10\n    assert I.dtype == O.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, F, O)\n    self.lib.scratch_buffer_init()\n    filter_data = self.filter_trans.bind_params(F)\n    (bsum_data, x_data) = self.xprop_params(O, X, bias, bsum, beta, relu, brelu, slope)\n    self.kernel_args[2:11] = (self.lib.stream, bsum_data, x_data, O.gpudata, I.gpudata, filter_data, alpha, beta or slope, no_op)",
            "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert I.dtype == O.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, F, O)\n    self.lib.scratch_buffer_init()\n    filter_data = self.filter_trans.bind_params(F)\n    (bsum_data, x_data) = self.xprop_params(O, X, bias, bsum, beta, relu, brelu, slope)\n    self.kernel_args[2:11] = (self.lib.stream, bsum_data, x_data, O.gpudata, I.gpudata, filter_data, alpha, beta or slope, no_op)",
            "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert I.dtype == O.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, F, O)\n    self.lib.scratch_buffer_init()\n    filter_data = self.filter_trans.bind_params(F)\n    (bsum_data, x_data) = self.xprop_params(O, X, bias, bsum, beta, relu, brelu, slope)\n    self.kernel_args[2:11] = (self.lib.stream, bsum_data, x_data, O.gpudata, I.gpudata, filter_data, alpha, beta or slope, no_op)",
            "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert I.dtype == O.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, F, O)\n    self.lib.scratch_buffer_init()\n    filter_data = self.filter_trans.bind_params(F)\n    (bsum_data, x_data) = self.xprop_params(O, X, bias, bsum, beta, relu, brelu, slope)\n    self.kernel_args[2:11] = (self.lib.stream, bsum_data, x_data, O.gpudata, I.gpudata, filter_data, alpha, beta or slope, no_op)",
            "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert I.dtype == O.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, F, O)\n    self.lib.scratch_buffer_init()\n    filter_data = self.filter_trans.bind_params(F)\n    (bsum_data, x_data) = self.xprop_params(O, X, bias, bsum, beta, relu, brelu, slope)\n    self.kernel_args[2:11] = (self.lib.stream, bsum_data, x_data, O.gpudata, I.gpudata, filter_data, alpha, beta or slope, no_op)"
        ]
    },
    {
        "func_name": "execute",
        "original": "def execute(self, repeat=1, unbind=True):\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_options)\n    for r in range(repeat):\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.bsum.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.bsum.unbind()\n        self.kernel_args[2:11] = (None,) * 9",
        "mutated": [
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_options)\n    for r in range(repeat):\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.bsum.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.bsum.unbind()\n        self.kernel_args[2:11] = (None,) * 9",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_options)\n    for r in range(repeat):\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.bsum.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.bsum.unbind()\n        self.kernel_args[2:11] = (None,) * 9",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_options)\n    for r in range(repeat):\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.bsum.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.bsum.unbind()\n        self.kernel_args[2:11] = (None,) * 9",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_options)\n    for r in range(repeat):\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.bsum.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.bsum.unbind()\n        self.kernel_args[2:11] = (None,) * 9",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_options)\n    for r in range(repeat):\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.bsum.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.bsum.unbind()\n        self.kernel_args[2:11] = (None,) * 9"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, filter_extern=None):\n    super(FpropWinograd_2x2_3x3, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, filter_extern)",
        "mutated": [
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, filter_extern=None):\n    if False:\n        i = 10\n    super(FpropWinograd_2x2_3x3, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, filter_extern)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, filter_extern=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(FpropWinograd_2x2_3x3, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, filter_extern)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, filter_extern=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(FpropWinograd_2x2_3x3, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, filter_extern)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, filter_extern=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(FpropWinograd_2x2_3x3, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, filter_extern)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, filter_extern=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(FpropWinograd_2x2_3x3, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, filter_extern)"
        ]
    },
    {
        "func_name": "init",
        "original": "def init(self, autotune=0, filter_extern=0):\n    super(FpropWinograd_2x2_3x3, self).init(autotune, filter_extern)\n    if self.filter_extern:\n        (C, K) = self.params[1:3]\n        self.filter_trans = FpropFilter_2x2_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = NoopTransform()",
        "mutated": [
            "def init(self, autotune=0, filter_extern=0):\n    if False:\n        i = 10\n    super(FpropWinograd_2x2_3x3, self).init(autotune, filter_extern)\n    if self.filter_extern:\n        (C, K) = self.params[1:3]\n        self.filter_trans = FpropFilter_2x2_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = NoopTransform()",
            "def init(self, autotune=0, filter_extern=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(FpropWinograd_2x2_3x3, self).init(autotune, filter_extern)\n    if self.filter_extern:\n        (C, K) = self.params[1:3]\n        self.filter_trans = FpropFilter_2x2_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = NoopTransform()",
            "def init(self, autotune=0, filter_extern=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(FpropWinograd_2x2_3x3, self).init(autotune, filter_extern)\n    if self.filter_extern:\n        (C, K) = self.params[1:3]\n        self.filter_trans = FpropFilter_2x2_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = NoopTransform()",
            "def init(self, autotune=0, filter_extern=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(FpropWinograd_2x2_3x3, self).init(autotune, filter_extern)\n    if self.filter_extern:\n        (C, K) = self.params[1:3]\n        self.filter_trans = FpropFilter_2x2_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = NoopTransform()",
            "def init(self, autotune=0, filter_extern=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(FpropWinograd_2x2_3x3, self).init(autotune, filter_extern)\n    if self.filter_extern:\n        (C, K) = self.params[1:3]\n        self.filter_trans = FpropFilter_2x2_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = NoopTransform()"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, filter_extern=None):\n    super(BpropWinograd_2x2_3x3, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 2 - pad_h, 2 - pad_w, filter_extern, bprop=True)",
        "mutated": [
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, filter_extern=None):\n    if False:\n        i = 10\n    super(BpropWinograd_2x2_3x3, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 2 - pad_h, 2 - pad_w, filter_extern, bprop=True)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, filter_extern=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(BpropWinograd_2x2_3x3, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 2 - pad_h, 2 - pad_w, filter_extern, bprop=True)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, filter_extern=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(BpropWinograd_2x2_3x3, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 2 - pad_h, 2 - pad_w, filter_extern, bprop=True)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, filter_extern=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(BpropWinograd_2x2_3x3, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 2 - pad_h, 2 - pad_w, filter_extern, bprop=True)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, filter_extern=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(BpropWinograd_2x2_3x3, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 2 - pad_h, 2 - pad_w, filter_extern, bprop=True)"
        ]
    },
    {
        "func_name": "init",
        "original": "def init(self, autotune=0, filter_extern=0):\n    super(BpropWinograd_2x2_3x3, self).init(autotune, filter_extern)\n    (K, C) = self.params[1:3]\n    if self.filter_extern:\n        self.filter_trans = BpropFilter_2x2_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = FilterDimShuffle(self.lib, self.dtype, C, 1, 3, 3, K)",
        "mutated": [
            "def init(self, autotune=0, filter_extern=0):\n    if False:\n        i = 10\n    super(BpropWinograd_2x2_3x3, self).init(autotune, filter_extern)\n    (K, C) = self.params[1:3]\n    if self.filter_extern:\n        self.filter_trans = BpropFilter_2x2_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = FilterDimShuffle(self.lib, self.dtype, C, 1, 3, 3, K)",
            "def init(self, autotune=0, filter_extern=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(BpropWinograd_2x2_3x3, self).init(autotune, filter_extern)\n    (K, C) = self.params[1:3]\n    if self.filter_extern:\n        self.filter_trans = BpropFilter_2x2_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = FilterDimShuffle(self.lib, self.dtype, C, 1, 3, 3, K)",
            "def init(self, autotune=0, filter_extern=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(BpropWinograd_2x2_3x3, self).init(autotune, filter_extern)\n    (K, C) = self.params[1:3]\n    if self.filter_extern:\n        self.filter_trans = BpropFilter_2x2_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = FilterDimShuffle(self.lib, self.dtype, C, 1, 3, 3, K)",
            "def init(self, autotune=0, filter_extern=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(BpropWinograd_2x2_3x3, self).init(autotune, filter_extern)\n    (K, C) = self.params[1:3]\n    if self.filter_extern:\n        self.filter_trans = BpropFilter_2x2_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = FilterDimShuffle(self.lib, self.dtype, C, 1, 3, 3, K)",
            "def init(self, autotune=0, filter_extern=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(BpropWinograd_2x2_3x3, self).init(autotune, filter_extern)\n    (K, C) = self.params[1:3]\n    if self.filter_extern:\n        self.filter_trans = BpropFilter_2x2_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = FilterDimShuffle(self.lib, self.dtype, C, 1, 3, 3, K)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    assert N in (1, 2) or N % 4 == 0\n    super(UpdateWinograd_3x3_2x2, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1)\n    SMs = _get_sm_count()\n    self.autotune_key = [native_str(x) for x in ('update_3x3_2x2', SMs, 0, dtype.itemsize, N, C, K, H, W, P, Q)]\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.init()\n    lib.set_scratch_size(self.image_trans.size, self.output_trans.size)\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)",
        "mutated": [
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n    assert N in (1, 2) or N % 4 == 0\n    super(UpdateWinograd_3x3_2x2, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1)\n    SMs = _get_sm_count()\n    self.autotune_key = [native_str(x) for x in ('update_3x3_2x2', SMs, 0, dtype.itemsize, N, C, K, H, W, P, Q)]\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.init()\n    lib.set_scratch_size(self.image_trans.size, self.output_trans.size)\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert N in (1, 2) or N % 4 == 0\n    super(UpdateWinograd_3x3_2x2, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1)\n    SMs = _get_sm_count()\n    self.autotune_key = [native_str(x) for x in ('update_3x3_2x2', SMs, 0, dtype.itemsize, N, C, K, H, W, P, Q)]\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.init()\n    lib.set_scratch_size(self.image_trans.size, self.output_trans.size)\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert N in (1, 2) or N % 4 == 0\n    super(UpdateWinograd_3x3_2x2, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1)\n    SMs = _get_sm_count()\n    self.autotune_key = [native_str(x) for x in ('update_3x3_2x2', SMs, 0, dtype.itemsize, N, C, K, H, W, P, Q)]\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.init()\n    lib.set_scratch_size(self.image_trans.size, self.output_trans.size)\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert N in (1, 2) or N % 4 == 0\n    super(UpdateWinograd_3x3_2x2, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1)\n    SMs = _get_sm_count()\n    self.autotune_key = [native_str(x) for x in ('update_3x3_2x2', SMs, 0, dtype.itemsize, N, C, K, H, W, P, Q)]\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.init()\n    lib.set_scratch_size(self.image_trans.size, self.output_trans.size)\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert N in (1, 2) or N % 4 == 0\n    super(UpdateWinograd_3x3_2x2, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1)\n    SMs = _get_sm_count()\n    self.autotune_key = [native_str(x) for x in ('update_3x3_2x2', SMs, 0, dtype.itemsize, N, C, K, H, W, P, Q)]\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.init()\n    lib.set_scratch_size(self.image_trans.size, self.output_trans.size)\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)"
        ]
    },
    {
        "func_name": "init",
        "original": "def init(self, autotune=False):\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    loopN = 4 if N >= 4 else N\n    blkN = 4 if N >= 3 else N\n    superI = UpdateWinograd_3x3_2x2.external_superblock.get(blkN)\n    superE = UpdateWinograd_3x3_2x2.internal_superblock.get(blkN)\n    blkXI = 1 << superI[1]\n    blkY = 1 << superE[0]\n    blkX = 1 << superE[1]\n    GY = _ceil_div(P, 2)\n    GX = _ceil_div(Q, 2)\n    GYS = self.GYS = _ceil_div(P, blkY)\n    GXS = self.GXS = _ceil_div(Q, blkX)\n    if autotune:\n        (strideY, strideX, external) = autotune\n    else:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            autotune_key = ' '.join(self.autotune_key)\n            if autotune_key in autotune_db:\n                (strideY, strideX, external) = autotune_db[autotune_key]\n                self.initialized = True\n            else:\n                if GYS * GXS > 768:\n                    strideY = 768\n                    strideX = 1\n                else:\n                    strideY = GYS\n                    strideX = GXS\n                external = True\n                self.initialized = False\n    loopXI = N * (strideX * blkXI - 1)\n    loopXE = N * (strideX * blkX - 1)\n    Np = N * self.dtype.itemsize\n    XNp = W * N * self.dtype.itemsize\n    XN2p = W * N * 2 * self.dtype.itemsize\n    QNp = Q * N * self.dtype.itemsize\n    gridK = _ceil_div(K, 32)\n    gridC = _ceil_div(C, 32)\n    k_size = _closest_divisor(gridK, 4)\n    c_size = _closest_divisor(gridC, 4)\n    C_size = gridC // c_size\n    kc = k_size * c_size\n    Qkc = strideX * kc\n    PQkc = strideY * Qkc\n    CPQkc = C_size * PQkc\n    gridPQ = strideY * strideX\n    gridPQKC = gridPQ * gridK * gridC\n    magic_CPQkc = _magic64(CPQkc)\n    magic_PQkc = _magic64(PQkc)\n    magic_Qkc = _magic64(Qkc)\n    magic_kc = _magic32(Qkc, kc)\n    magic_c = _magic32(kc, c_size)\n    CRSK = C * R * S * K\n    self.blocksCK = gridK * gridC\n    options = list()\n    if external:\n        options.append('IX')\n        WN = GX * N\n        HWN = GY * WN\n        self.image_trans = UpdateImage_3x3_2x2(self.lib, self.dtype, N, C, K, H, W, P, Q, pad_h, pad_w)\n    else:\n        WN = W * N\n        HWN = H * WN\n        superI = superE\n        self.image_trans = NoopTransform()\n    if gridPQ == 1 or self.lib.deterministic:\n        self.output_trans = UpdateConvReduce(self.lib, gridPQ, CRSK)\n        self.zero = False\n        options.append('D')\n    else:\n        self.output_trans = UpdateConvReduce(self.lib, 1, CRSK)\n        self.zero = True\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_3x3_2x2_32x32' % self.clss\n    self.kernel_args = [(gridPQKC, 1, 1), (256, 1, 1), None, None, None, None, 1.0]\n    self.kernel_args.extend(_flatten([H, W, P, Q, C, K, N, pad_h, pad_w, GY, GX, GYS, GXS, superI, superE, loopXI, loopXE, loopN, strideY, strideX, WN, HWN, Q * N, P * Q * N, S * K, R * S * K, Np, XNp, XN2p, QNp, CPQkc, PQkc, Qkc, kc, c_size, k_size, magic_CPQkc, magic_PQkc, magic_Qkc, magic_kc, magic_c, CRSK]))",
        "mutated": [
            "def init(self, autotune=False):\n    if False:\n        i = 10\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    loopN = 4 if N >= 4 else N\n    blkN = 4 if N >= 3 else N\n    superI = UpdateWinograd_3x3_2x2.external_superblock.get(blkN)\n    superE = UpdateWinograd_3x3_2x2.internal_superblock.get(blkN)\n    blkXI = 1 << superI[1]\n    blkY = 1 << superE[0]\n    blkX = 1 << superE[1]\n    GY = _ceil_div(P, 2)\n    GX = _ceil_div(Q, 2)\n    GYS = self.GYS = _ceil_div(P, blkY)\n    GXS = self.GXS = _ceil_div(Q, blkX)\n    if autotune:\n        (strideY, strideX, external) = autotune\n    else:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            autotune_key = ' '.join(self.autotune_key)\n            if autotune_key in autotune_db:\n                (strideY, strideX, external) = autotune_db[autotune_key]\n                self.initialized = True\n            else:\n                if GYS * GXS > 768:\n                    strideY = 768\n                    strideX = 1\n                else:\n                    strideY = GYS\n                    strideX = GXS\n                external = True\n                self.initialized = False\n    loopXI = N * (strideX * blkXI - 1)\n    loopXE = N * (strideX * blkX - 1)\n    Np = N * self.dtype.itemsize\n    XNp = W * N * self.dtype.itemsize\n    XN2p = W * N * 2 * self.dtype.itemsize\n    QNp = Q * N * self.dtype.itemsize\n    gridK = _ceil_div(K, 32)\n    gridC = _ceil_div(C, 32)\n    k_size = _closest_divisor(gridK, 4)\n    c_size = _closest_divisor(gridC, 4)\n    C_size = gridC // c_size\n    kc = k_size * c_size\n    Qkc = strideX * kc\n    PQkc = strideY * Qkc\n    CPQkc = C_size * PQkc\n    gridPQ = strideY * strideX\n    gridPQKC = gridPQ * gridK * gridC\n    magic_CPQkc = _magic64(CPQkc)\n    magic_PQkc = _magic64(PQkc)\n    magic_Qkc = _magic64(Qkc)\n    magic_kc = _magic32(Qkc, kc)\n    magic_c = _magic32(kc, c_size)\n    CRSK = C * R * S * K\n    self.blocksCK = gridK * gridC\n    options = list()\n    if external:\n        options.append('IX')\n        WN = GX * N\n        HWN = GY * WN\n        self.image_trans = UpdateImage_3x3_2x2(self.lib, self.dtype, N, C, K, H, W, P, Q, pad_h, pad_w)\n    else:\n        WN = W * N\n        HWN = H * WN\n        superI = superE\n        self.image_trans = NoopTransform()\n    if gridPQ == 1 or self.lib.deterministic:\n        self.output_trans = UpdateConvReduce(self.lib, gridPQ, CRSK)\n        self.zero = False\n        options.append('D')\n    else:\n        self.output_trans = UpdateConvReduce(self.lib, 1, CRSK)\n        self.zero = True\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_3x3_2x2_32x32' % self.clss\n    self.kernel_args = [(gridPQKC, 1, 1), (256, 1, 1), None, None, None, None, 1.0]\n    self.kernel_args.extend(_flatten([H, W, P, Q, C, K, N, pad_h, pad_w, GY, GX, GYS, GXS, superI, superE, loopXI, loopXE, loopN, strideY, strideX, WN, HWN, Q * N, P * Q * N, S * K, R * S * K, Np, XNp, XN2p, QNp, CPQkc, PQkc, Qkc, kc, c_size, k_size, magic_CPQkc, magic_PQkc, magic_Qkc, magic_kc, magic_c, CRSK]))",
            "def init(self, autotune=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    loopN = 4 if N >= 4 else N\n    blkN = 4 if N >= 3 else N\n    superI = UpdateWinograd_3x3_2x2.external_superblock.get(blkN)\n    superE = UpdateWinograd_3x3_2x2.internal_superblock.get(blkN)\n    blkXI = 1 << superI[1]\n    blkY = 1 << superE[0]\n    blkX = 1 << superE[1]\n    GY = _ceil_div(P, 2)\n    GX = _ceil_div(Q, 2)\n    GYS = self.GYS = _ceil_div(P, blkY)\n    GXS = self.GXS = _ceil_div(Q, blkX)\n    if autotune:\n        (strideY, strideX, external) = autotune\n    else:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            autotune_key = ' '.join(self.autotune_key)\n            if autotune_key in autotune_db:\n                (strideY, strideX, external) = autotune_db[autotune_key]\n                self.initialized = True\n            else:\n                if GYS * GXS > 768:\n                    strideY = 768\n                    strideX = 1\n                else:\n                    strideY = GYS\n                    strideX = GXS\n                external = True\n                self.initialized = False\n    loopXI = N * (strideX * blkXI - 1)\n    loopXE = N * (strideX * blkX - 1)\n    Np = N * self.dtype.itemsize\n    XNp = W * N * self.dtype.itemsize\n    XN2p = W * N * 2 * self.dtype.itemsize\n    QNp = Q * N * self.dtype.itemsize\n    gridK = _ceil_div(K, 32)\n    gridC = _ceil_div(C, 32)\n    k_size = _closest_divisor(gridK, 4)\n    c_size = _closest_divisor(gridC, 4)\n    C_size = gridC // c_size\n    kc = k_size * c_size\n    Qkc = strideX * kc\n    PQkc = strideY * Qkc\n    CPQkc = C_size * PQkc\n    gridPQ = strideY * strideX\n    gridPQKC = gridPQ * gridK * gridC\n    magic_CPQkc = _magic64(CPQkc)\n    magic_PQkc = _magic64(PQkc)\n    magic_Qkc = _magic64(Qkc)\n    magic_kc = _magic32(Qkc, kc)\n    magic_c = _magic32(kc, c_size)\n    CRSK = C * R * S * K\n    self.blocksCK = gridK * gridC\n    options = list()\n    if external:\n        options.append('IX')\n        WN = GX * N\n        HWN = GY * WN\n        self.image_trans = UpdateImage_3x3_2x2(self.lib, self.dtype, N, C, K, H, W, P, Q, pad_h, pad_w)\n    else:\n        WN = W * N\n        HWN = H * WN\n        superI = superE\n        self.image_trans = NoopTransform()\n    if gridPQ == 1 or self.lib.deterministic:\n        self.output_trans = UpdateConvReduce(self.lib, gridPQ, CRSK)\n        self.zero = False\n        options.append('D')\n    else:\n        self.output_trans = UpdateConvReduce(self.lib, 1, CRSK)\n        self.zero = True\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_3x3_2x2_32x32' % self.clss\n    self.kernel_args = [(gridPQKC, 1, 1), (256, 1, 1), None, None, None, None, 1.0]\n    self.kernel_args.extend(_flatten([H, W, P, Q, C, K, N, pad_h, pad_w, GY, GX, GYS, GXS, superI, superE, loopXI, loopXE, loopN, strideY, strideX, WN, HWN, Q * N, P * Q * N, S * K, R * S * K, Np, XNp, XN2p, QNp, CPQkc, PQkc, Qkc, kc, c_size, k_size, magic_CPQkc, magic_PQkc, magic_Qkc, magic_kc, magic_c, CRSK]))",
            "def init(self, autotune=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    loopN = 4 if N >= 4 else N\n    blkN = 4 if N >= 3 else N\n    superI = UpdateWinograd_3x3_2x2.external_superblock.get(blkN)\n    superE = UpdateWinograd_3x3_2x2.internal_superblock.get(blkN)\n    blkXI = 1 << superI[1]\n    blkY = 1 << superE[0]\n    blkX = 1 << superE[1]\n    GY = _ceil_div(P, 2)\n    GX = _ceil_div(Q, 2)\n    GYS = self.GYS = _ceil_div(P, blkY)\n    GXS = self.GXS = _ceil_div(Q, blkX)\n    if autotune:\n        (strideY, strideX, external) = autotune\n    else:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            autotune_key = ' '.join(self.autotune_key)\n            if autotune_key in autotune_db:\n                (strideY, strideX, external) = autotune_db[autotune_key]\n                self.initialized = True\n            else:\n                if GYS * GXS > 768:\n                    strideY = 768\n                    strideX = 1\n                else:\n                    strideY = GYS\n                    strideX = GXS\n                external = True\n                self.initialized = False\n    loopXI = N * (strideX * blkXI - 1)\n    loopXE = N * (strideX * blkX - 1)\n    Np = N * self.dtype.itemsize\n    XNp = W * N * self.dtype.itemsize\n    XN2p = W * N * 2 * self.dtype.itemsize\n    QNp = Q * N * self.dtype.itemsize\n    gridK = _ceil_div(K, 32)\n    gridC = _ceil_div(C, 32)\n    k_size = _closest_divisor(gridK, 4)\n    c_size = _closest_divisor(gridC, 4)\n    C_size = gridC // c_size\n    kc = k_size * c_size\n    Qkc = strideX * kc\n    PQkc = strideY * Qkc\n    CPQkc = C_size * PQkc\n    gridPQ = strideY * strideX\n    gridPQKC = gridPQ * gridK * gridC\n    magic_CPQkc = _magic64(CPQkc)\n    magic_PQkc = _magic64(PQkc)\n    magic_Qkc = _magic64(Qkc)\n    magic_kc = _magic32(Qkc, kc)\n    magic_c = _magic32(kc, c_size)\n    CRSK = C * R * S * K\n    self.blocksCK = gridK * gridC\n    options = list()\n    if external:\n        options.append('IX')\n        WN = GX * N\n        HWN = GY * WN\n        self.image_trans = UpdateImage_3x3_2x2(self.lib, self.dtype, N, C, K, H, W, P, Q, pad_h, pad_w)\n    else:\n        WN = W * N\n        HWN = H * WN\n        superI = superE\n        self.image_trans = NoopTransform()\n    if gridPQ == 1 or self.lib.deterministic:\n        self.output_trans = UpdateConvReduce(self.lib, gridPQ, CRSK)\n        self.zero = False\n        options.append('D')\n    else:\n        self.output_trans = UpdateConvReduce(self.lib, 1, CRSK)\n        self.zero = True\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_3x3_2x2_32x32' % self.clss\n    self.kernel_args = [(gridPQKC, 1, 1), (256, 1, 1), None, None, None, None, 1.0]\n    self.kernel_args.extend(_flatten([H, W, P, Q, C, K, N, pad_h, pad_w, GY, GX, GYS, GXS, superI, superE, loopXI, loopXE, loopN, strideY, strideX, WN, HWN, Q * N, P * Q * N, S * K, R * S * K, Np, XNp, XN2p, QNp, CPQkc, PQkc, Qkc, kc, c_size, k_size, magic_CPQkc, magic_PQkc, magic_Qkc, magic_kc, magic_c, CRSK]))",
            "def init(self, autotune=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    loopN = 4 if N >= 4 else N\n    blkN = 4 if N >= 3 else N\n    superI = UpdateWinograd_3x3_2x2.external_superblock.get(blkN)\n    superE = UpdateWinograd_3x3_2x2.internal_superblock.get(blkN)\n    blkXI = 1 << superI[1]\n    blkY = 1 << superE[0]\n    blkX = 1 << superE[1]\n    GY = _ceil_div(P, 2)\n    GX = _ceil_div(Q, 2)\n    GYS = self.GYS = _ceil_div(P, blkY)\n    GXS = self.GXS = _ceil_div(Q, blkX)\n    if autotune:\n        (strideY, strideX, external) = autotune\n    else:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            autotune_key = ' '.join(self.autotune_key)\n            if autotune_key in autotune_db:\n                (strideY, strideX, external) = autotune_db[autotune_key]\n                self.initialized = True\n            else:\n                if GYS * GXS > 768:\n                    strideY = 768\n                    strideX = 1\n                else:\n                    strideY = GYS\n                    strideX = GXS\n                external = True\n                self.initialized = False\n    loopXI = N * (strideX * blkXI - 1)\n    loopXE = N * (strideX * blkX - 1)\n    Np = N * self.dtype.itemsize\n    XNp = W * N * self.dtype.itemsize\n    XN2p = W * N * 2 * self.dtype.itemsize\n    QNp = Q * N * self.dtype.itemsize\n    gridK = _ceil_div(K, 32)\n    gridC = _ceil_div(C, 32)\n    k_size = _closest_divisor(gridK, 4)\n    c_size = _closest_divisor(gridC, 4)\n    C_size = gridC // c_size\n    kc = k_size * c_size\n    Qkc = strideX * kc\n    PQkc = strideY * Qkc\n    CPQkc = C_size * PQkc\n    gridPQ = strideY * strideX\n    gridPQKC = gridPQ * gridK * gridC\n    magic_CPQkc = _magic64(CPQkc)\n    magic_PQkc = _magic64(PQkc)\n    magic_Qkc = _magic64(Qkc)\n    magic_kc = _magic32(Qkc, kc)\n    magic_c = _magic32(kc, c_size)\n    CRSK = C * R * S * K\n    self.blocksCK = gridK * gridC\n    options = list()\n    if external:\n        options.append('IX')\n        WN = GX * N\n        HWN = GY * WN\n        self.image_trans = UpdateImage_3x3_2x2(self.lib, self.dtype, N, C, K, H, W, P, Q, pad_h, pad_w)\n    else:\n        WN = W * N\n        HWN = H * WN\n        superI = superE\n        self.image_trans = NoopTransform()\n    if gridPQ == 1 or self.lib.deterministic:\n        self.output_trans = UpdateConvReduce(self.lib, gridPQ, CRSK)\n        self.zero = False\n        options.append('D')\n    else:\n        self.output_trans = UpdateConvReduce(self.lib, 1, CRSK)\n        self.zero = True\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_3x3_2x2_32x32' % self.clss\n    self.kernel_args = [(gridPQKC, 1, 1), (256, 1, 1), None, None, None, None, 1.0]\n    self.kernel_args.extend(_flatten([H, W, P, Q, C, K, N, pad_h, pad_w, GY, GX, GYS, GXS, superI, superE, loopXI, loopXE, loopN, strideY, strideX, WN, HWN, Q * N, P * Q * N, S * K, R * S * K, Np, XNp, XN2p, QNp, CPQkc, PQkc, Qkc, kc, c_size, k_size, magic_CPQkc, magic_PQkc, magic_Qkc, magic_kc, magic_c, CRSK]))",
            "def init(self, autotune=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    loopN = 4 if N >= 4 else N\n    blkN = 4 if N >= 3 else N\n    superI = UpdateWinograd_3x3_2x2.external_superblock.get(blkN)\n    superE = UpdateWinograd_3x3_2x2.internal_superblock.get(blkN)\n    blkXI = 1 << superI[1]\n    blkY = 1 << superE[0]\n    blkX = 1 << superE[1]\n    GY = _ceil_div(P, 2)\n    GX = _ceil_div(Q, 2)\n    GYS = self.GYS = _ceil_div(P, blkY)\n    GXS = self.GXS = _ceil_div(Q, blkX)\n    if autotune:\n        (strideY, strideX, external) = autotune\n    else:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            autotune_key = ' '.join(self.autotune_key)\n            if autotune_key in autotune_db:\n                (strideY, strideX, external) = autotune_db[autotune_key]\n                self.initialized = True\n            else:\n                if GYS * GXS > 768:\n                    strideY = 768\n                    strideX = 1\n                else:\n                    strideY = GYS\n                    strideX = GXS\n                external = True\n                self.initialized = False\n    loopXI = N * (strideX * blkXI - 1)\n    loopXE = N * (strideX * blkX - 1)\n    Np = N * self.dtype.itemsize\n    XNp = W * N * self.dtype.itemsize\n    XN2p = W * N * 2 * self.dtype.itemsize\n    QNp = Q * N * self.dtype.itemsize\n    gridK = _ceil_div(K, 32)\n    gridC = _ceil_div(C, 32)\n    k_size = _closest_divisor(gridK, 4)\n    c_size = _closest_divisor(gridC, 4)\n    C_size = gridC // c_size\n    kc = k_size * c_size\n    Qkc = strideX * kc\n    PQkc = strideY * Qkc\n    CPQkc = C_size * PQkc\n    gridPQ = strideY * strideX\n    gridPQKC = gridPQ * gridK * gridC\n    magic_CPQkc = _magic64(CPQkc)\n    magic_PQkc = _magic64(PQkc)\n    magic_Qkc = _magic64(Qkc)\n    magic_kc = _magic32(Qkc, kc)\n    magic_c = _magic32(kc, c_size)\n    CRSK = C * R * S * K\n    self.blocksCK = gridK * gridC\n    options = list()\n    if external:\n        options.append('IX')\n        WN = GX * N\n        HWN = GY * WN\n        self.image_trans = UpdateImage_3x3_2x2(self.lib, self.dtype, N, C, K, H, W, P, Q, pad_h, pad_w)\n    else:\n        WN = W * N\n        HWN = H * WN\n        superI = superE\n        self.image_trans = NoopTransform()\n    if gridPQ == 1 or self.lib.deterministic:\n        self.output_trans = UpdateConvReduce(self.lib, gridPQ, CRSK)\n        self.zero = False\n        options.append('D')\n    else:\n        self.output_trans = UpdateConvReduce(self.lib, 1, CRSK)\n        self.zero = True\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_3x3_2x2_32x32' % self.clss\n    self.kernel_args = [(gridPQKC, 1, 1), (256, 1, 1), None, None, None, None, 1.0]\n    self.kernel_args.extend(_flatten([H, W, P, Q, C, K, N, pad_h, pad_w, GY, GX, GYS, GXS, superI, superE, loopXI, loopXE, loopN, strideY, strideX, WN, HWN, Q * N, P * Q * N, S * K, R * S * K, Np, XNp, XN2p, QNp, CPQkc, PQkc, Qkc, kc, c_size, k_size, magic_CPQkc, magic_PQkc, magic_Qkc, magic_kc, magic_c, CRSK]))"
        ]
    },
    {
        "func_name": "autotune",
        "original": "def autotune(self, I, E, O):\n    autotune_key = ' '.join(self.autotune_key)\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=(self.GYS, 1, 1))\n        self.bind_params(I, E, O, no_op=True)\n        self.execute(repeat=self.warmup, unbind=False)\n    block_slots = _get_sm_count()\n    loopsN = max(self.params[0] // 4, 1)\n    modes = (0, 1) if self.params[0] <= 4 else (1,)\n    gys = float(self.GYS)\n    gxs = float(self.GYS)\n    small_set = gys * gxs <= 512\n    results = []\n    sys.stdout.write('Autotune ' + native_str(self))\n    progress = 0\n    for threshold in (True, False):\n        for external in modes:\n            for strideY in range(1, self.GYS + 1):\n                for strideX in range(1, self.GXS + 1):\n                    if progress % 32 == 0:\n                        sys.stdout.write('.')\n                        sys.stdout.flush()\n                    progress += 1\n                    outputs = strideY * strideX\n                    blocks = self.blocksCK * strideY * strideX\n                    depth = gys / strideY * (gxs / strideX) * loopsN\n                    filters = outputs <= 768 and blocks >= block_slots and (depth >= 32.0)\n                    if small_set or (threshold and filters) or (not threshold and (not filters)):\n                        settings = (strideY, strideX, external)\n                        self.init(autotune=settings)\n                        self.bind_params(I, E, O, no_op=True)\n                        start.record(stream=self.lib.stream)\n                        self.execute(repeat=2, unbind=False)\n                        stop.record(stream=self.lib.stream)\n                        stop.synchronize()\n                        msecs = stop.time_since(start) / 2.0\n                        results.append((msecs, settings))\n        if len(results) > 0:\n            break\n    sys.stdout.write('\\n')\n    results.sort()\n    settings = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[autotune_key] = settings\n        if settings[0] * settings[1] <= 8:\n            self.autotune_key[2] = native_str(1 - int(self.autotune_key[2]))\n            autotune_key = ' '.join(self.autotune_key)\n            autotune_db[autotune_key] = settings\n    self.init(autotune=settings)",
        "mutated": [
            "def autotune(self, I, E, O):\n    if False:\n        i = 10\n    autotune_key = ' '.join(self.autotune_key)\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=(self.GYS, 1, 1))\n        self.bind_params(I, E, O, no_op=True)\n        self.execute(repeat=self.warmup, unbind=False)\n    block_slots = _get_sm_count()\n    loopsN = max(self.params[0] // 4, 1)\n    modes = (0, 1) if self.params[0] <= 4 else (1,)\n    gys = float(self.GYS)\n    gxs = float(self.GYS)\n    small_set = gys * gxs <= 512\n    results = []\n    sys.stdout.write('Autotune ' + native_str(self))\n    progress = 0\n    for threshold in (True, False):\n        for external in modes:\n            for strideY in range(1, self.GYS + 1):\n                for strideX in range(1, self.GXS + 1):\n                    if progress % 32 == 0:\n                        sys.stdout.write('.')\n                        sys.stdout.flush()\n                    progress += 1\n                    outputs = strideY * strideX\n                    blocks = self.blocksCK * strideY * strideX\n                    depth = gys / strideY * (gxs / strideX) * loopsN\n                    filters = outputs <= 768 and blocks >= block_slots and (depth >= 32.0)\n                    if small_set or (threshold and filters) or (not threshold and (not filters)):\n                        settings = (strideY, strideX, external)\n                        self.init(autotune=settings)\n                        self.bind_params(I, E, O, no_op=True)\n                        start.record(stream=self.lib.stream)\n                        self.execute(repeat=2, unbind=False)\n                        stop.record(stream=self.lib.stream)\n                        stop.synchronize()\n                        msecs = stop.time_since(start) / 2.0\n                        results.append((msecs, settings))\n        if len(results) > 0:\n            break\n    sys.stdout.write('\\n')\n    results.sort()\n    settings = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[autotune_key] = settings\n        if settings[0] * settings[1] <= 8:\n            self.autotune_key[2] = native_str(1 - int(self.autotune_key[2]))\n            autotune_key = ' '.join(self.autotune_key)\n            autotune_db[autotune_key] = settings\n    self.init(autotune=settings)",
            "def autotune(self, I, E, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    autotune_key = ' '.join(self.autotune_key)\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=(self.GYS, 1, 1))\n        self.bind_params(I, E, O, no_op=True)\n        self.execute(repeat=self.warmup, unbind=False)\n    block_slots = _get_sm_count()\n    loopsN = max(self.params[0] // 4, 1)\n    modes = (0, 1) if self.params[0] <= 4 else (1,)\n    gys = float(self.GYS)\n    gxs = float(self.GYS)\n    small_set = gys * gxs <= 512\n    results = []\n    sys.stdout.write('Autotune ' + native_str(self))\n    progress = 0\n    for threshold in (True, False):\n        for external in modes:\n            for strideY in range(1, self.GYS + 1):\n                for strideX in range(1, self.GXS + 1):\n                    if progress % 32 == 0:\n                        sys.stdout.write('.')\n                        sys.stdout.flush()\n                    progress += 1\n                    outputs = strideY * strideX\n                    blocks = self.blocksCK * strideY * strideX\n                    depth = gys / strideY * (gxs / strideX) * loopsN\n                    filters = outputs <= 768 and blocks >= block_slots and (depth >= 32.0)\n                    if small_set or (threshold and filters) or (not threshold and (not filters)):\n                        settings = (strideY, strideX, external)\n                        self.init(autotune=settings)\n                        self.bind_params(I, E, O, no_op=True)\n                        start.record(stream=self.lib.stream)\n                        self.execute(repeat=2, unbind=False)\n                        stop.record(stream=self.lib.stream)\n                        stop.synchronize()\n                        msecs = stop.time_since(start) / 2.0\n                        results.append((msecs, settings))\n        if len(results) > 0:\n            break\n    sys.stdout.write('\\n')\n    results.sort()\n    settings = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[autotune_key] = settings\n        if settings[0] * settings[1] <= 8:\n            self.autotune_key[2] = native_str(1 - int(self.autotune_key[2]))\n            autotune_key = ' '.join(self.autotune_key)\n            autotune_db[autotune_key] = settings\n    self.init(autotune=settings)",
            "def autotune(self, I, E, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    autotune_key = ' '.join(self.autotune_key)\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=(self.GYS, 1, 1))\n        self.bind_params(I, E, O, no_op=True)\n        self.execute(repeat=self.warmup, unbind=False)\n    block_slots = _get_sm_count()\n    loopsN = max(self.params[0] // 4, 1)\n    modes = (0, 1) if self.params[0] <= 4 else (1,)\n    gys = float(self.GYS)\n    gxs = float(self.GYS)\n    small_set = gys * gxs <= 512\n    results = []\n    sys.stdout.write('Autotune ' + native_str(self))\n    progress = 0\n    for threshold in (True, False):\n        for external in modes:\n            for strideY in range(1, self.GYS + 1):\n                for strideX in range(1, self.GXS + 1):\n                    if progress % 32 == 0:\n                        sys.stdout.write('.')\n                        sys.stdout.flush()\n                    progress += 1\n                    outputs = strideY * strideX\n                    blocks = self.blocksCK * strideY * strideX\n                    depth = gys / strideY * (gxs / strideX) * loopsN\n                    filters = outputs <= 768 and blocks >= block_slots and (depth >= 32.0)\n                    if small_set or (threshold and filters) or (not threshold and (not filters)):\n                        settings = (strideY, strideX, external)\n                        self.init(autotune=settings)\n                        self.bind_params(I, E, O, no_op=True)\n                        start.record(stream=self.lib.stream)\n                        self.execute(repeat=2, unbind=False)\n                        stop.record(stream=self.lib.stream)\n                        stop.synchronize()\n                        msecs = stop.time_since(start) / 2.0\n                        results.append((msecs, settings))\n        if len(results) > 0:\n            break\n    sys.stdout.write('\\n')\n    results.sort()\n    settings = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[autotune_key] = settings\n        if settings[0] * settings[1] <= 8:\n            self.autotune_key[2] = native_str(1 - int(self.autotune_key[2]))\n            autotune_key = ' '.join(self.autotune_key)\n            autotune_db[autotune_key] = settings\n    self.init(autotune=settings)",
            "def autotune(self, I, E, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    autotune_key = ' '.join(self.autotune_key)\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=(self.GYS, 1, 1))\n        self.bind_params(I, E, O, no_op=True)\n        self.execute(repeat=self.warmup, unbind=False)\n    block_slots = _get_sm_count()\n    loopsN = max(self.params[0] // 4, 1)\n    modes = (0, 1) if self.params[0] <= 4 else (1,)\n    gys = float(self.GYS)\n    gxs = float(self.GYS)\n    small_set = gys * gxs <= 512\n    results = []\n    sys.stdout.write('Autotune ' + native_str(self))\n    progress = 0\n    for threshold in (True, False):\n        for external in modes:\n            for strideY in range(1, self.GYS + 1):\n                for strideX in range(1, self.GXS + 1):\n                    if progress % 32 == 0:\n                        sys.stdout.write('.')\n                        sys.stdout.flush()\n                    progress += 1\n                    outputs = strideY * strideX\n                    blocks = self.blocksCK * strideY * strideX\n                    depth = gys / strideY * (gxs / strideX) * loopsN\n                    filters = outputs <= 768 and blocks >= block_slots and (depth >= 32.0)\n                    if small_set or (threshold and filters) or (not threshold and (not filters)):\n                        settings = (strideY, strideX, external)\n                        self.init(autotune=settings)\n                        self.bind_params(I, E, O, no_op=True)\n                        start.record(stream=self.lib.stream)\n                        self.execute(repeat=2, unbind=False)\n                        stop.record(stream=self.lib.stream)\n                        stop.synchronize()\n                        msecs = stop.time_since(start) / 2.0\n                        results.append((msecs, settings))\n        if len(results) > 0:\n            break\n    sys.stdout.write('\\n')\n    results.sort()\n    settings = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[autotune_key] = settings\n        if settings[0] * settings[1] <= 8:\n            self.autotune_key[2] = native_str(1 - int(self.autotune_key[2]))\n            autotune_key = ' '.join(self.autotune_key)\n            autotune_db[autotune_key] = settings\n    self.init(autotune=settings)",
            "def autotune(self, I, E, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    autotune_key = ' '.join(self.autotune_key)\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=(self.GYS, 1, 1))\n        self.bind_params(I, E, O, no_op=True)\n        self.execute(repeat=self.warmup, unbind=False)\n    block_slots = _get_sm_count()\n    loopsN = max(self.params[0] // 4, 1)\n    modes = (0, 1) if self.params[0] <= 4 else (1,)\n    gys = float(self.GYS)\n    gxs = float(self.GYS)\n    small_set = gys * gxs <= 512\n    results = []\n    sys.stdout.write('Autotune ' + native_str(self))\n    progress = 0\n    for threshold in (True, False):\n        for external in modes:\n            for strideY in range(1, self.GYS + 1):\n                for strideX in range(1, self.GXS + 1):\n                    if progress % 32 == 0:\n                        sys.stdout.write('.')\n                        sys.stdout.flush()\n                    progress += 1\n                    outputs = strideY * strideX\n                    blocks = self.blocksCK * strideY * strideX\n                    depth = gys / strideY * (gxs / strideX) * loopsN\n                    filters = outputs <= 768 and blocks >= block_slots and (depth >= 32.0)\n                    if small_set or (threshold and filters) or (not threshold and (not filters)):\n                        settings = (strideY, strideX, external)\n                        self.init(autotune=settings)\n                        self.bind_params(I, E, O, no_op=True)\n                        start.record(stream=self.lib.stream)\n                        self.execute(repeat=2, unbind=False)\n                        stop.record(stream=self.lib.stream)\n                        stop.synchronize()\n                        msecs = stop.time_since(start) / 2.0\n                        results.append((msecs, settings))\n        if len(results) > 0:\n            break\n    sys.stdout.write('\\n')\n    results.sort()\n    settings = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[autotune_key] = settings\n        if settings[0] * settings[1] <= 8:\n            self.autotune_key[2] = native_str(1 - int(self.autotune_key[2]))\n            autotune_key = ' '.join(self.autotune_key)\n            autotune_db[autotune_key] = settings\n    self.init(autotune=settings)"
        ]
    },
    {
        "func_name": "bind_params",
        "original": "def bind_params(self, I, E, O, alpha=1.0, beta=0.0, no_op=False):\n    assert I.dtype == E.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, E, O)\n    self.lib.scratch_buffer_init()\n    image_data = self.image_trans.bind_params(I)\n    output_data = self.output_trans.bind_params(O, alpha, beta, no_op)\n    if self.zero:\n        self.zero_args = (output_data, 0, O.size, self.lib.stream)\n    self.kernel_args[2:6] = (self.lib.stream, output_data, image_data, E.gpudata)",
        "mutated": [
            "def bind_params(self, I, E, O, alpha=1.0, beta=0.0, no_op=False):\n    if False:\n        i = 10\n    assert I.dtype == E.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, E, O)\n    self.lib.scratch_buffer_init()\n    image_data = self.image_trans.bind_params(I)\n    output_data = self.output_trans.bind_params(O, alpha, beta, no_op)\n    if self.zero:\n        self.zero_args = (output_data, 0, O.size, self.lib.stream)\n    self.kernel_args[2:6] = (self.lib.stream, output_data, image_data, E.gpudata)",
            "def bind_params(self, I, E, O, alpha=1.0, beta=0.0, no_op=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert I.dtype == E.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, E, O)\n    self.lib.scratch_buffer_init()\n    image_data = self.image_trans.bind_params(I)\n    output_data = self.output_trans.bind_params(O, alpha, beta, no_op)\n    if self.zero:\n        self.zero_args = (output_data, 0, O.size, self.lib.stream)\n    self.kernel_args[2:6] = (self.lib.stream, output_data, image_data, E.gpudata)",
            "def bind_params(self, I, E, O, alpha=1.0, beta=0.0, no_op=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert I.dtype == E.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, E, O)\n    self.lib.scratch_buffer_init()\n    image_data = self.image_trans.bind_params(I)\n    output_data = self.output_trans.bind_params(O, alpha, beta, no_op)\n    if self.zero:\n        self.zero_args = (output_data, 0, O.size, self.lib.stream)\n    self.kernel_args[2:6] = (self.lib.stream, output_data, image_data, E.gpudata)",
            "def bind_params(self, I, E, O, alpha=1.0, beta=0.0, no_op=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert I.dtype == E.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, E, O)\n    self.lib.scratch_buffer_init()\n    image_data = self.image_trans.bind_params(I)\n    output_data = self.output_trans.bind_params(O, alpha, beta, no_op)\n    if self.zero:\n        self.zero_args = (output_data, 0, O.size, self.lib.stream)\n    self.kernel_args[2:6] = (self.lib.stream, output_data, image_data, E.gpudata)",
            "def bind_params(self, I, E, O, alpha=1.0, beta=0.0, no_op=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert I.dtype == E.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, E, O)\n    self.lib.scratch_buffer_init()\n    image_data = self.image_trans.bind_params(I)\n    output_data = self.output_trans.bind_params(O, alpha, beta, no_op)\n    if self.zero:\n        self.zero_args = (output_data, 0, O.size, self.lib.stream)\n    self.kernel_args[2:6] = (self.lib.stream, output_data, image_data, E.gpudata)"
        ]
    },
    {
        "func_name": "execute",
        "original": "def execute(self, repeat=1, unbind=True):\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    for r in range(repeat):\n        if self.zero:\n            drv.memset_d32_async(*self.zero_args)\n        self.image_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.image_trans.unbind()\n        self.output_trans.unbind()\n        self.zero_args = None\n        self.kernel_args[2:6] = (None,) * 4",
        "mutated": [
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    for r in range(repeat):\n        if self.zero:\n            drv.memset_d32_async(*self.zero_args)\n        self.image_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.image_trans.unbind()\n        self.output_trans.unbind()\n        self.zero_args = None\n        self.kernel_args[2:6] = (None,) * 4",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    for r in range(repeat):\n        if self.zero:\n            drv.memset_d32_async(*self.zero_args)\n        self.image_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.image_trans.unbind()\n        self.output_trans.unbind()\n        self.zero_args = None\n        self.kernel_args[2:6] = (None,) * 4",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    for r in range(repeat):\n        if self.zero:\n            drv.memset_d32_async(*self.zero_args)\n        self.image_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.image_trans.unbind()\n        self.output_trans.unbind()\n        self.zero_args = None\n        self.kernel_args[2:6] = (None,) * 4",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    for r in range(repeat):\n        if self.zero:\n            drv.memset_d32_async(*self.zero_args)\n        self.image_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.image_trans.unbind()\n        self.output_trans.unbind()\n        self.zero_args = None\n        self.kernel_args[2:6] = (None,) * 4",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    for r in range(repeat):\n        if self.zero:\n            drv.memset_d32_async(*self.zero_args)\n        self.image_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.image_trans.unbind()\n        self.output_trans.unbind()\n        self.zero_args = None\n        self.kernel_args[2:6] = (None,) * 4"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, external=None, bprop=False):\n    super(XpropWinograd_4x4_3x3, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    SMs = _get_sm_count()\n    self.autotune_key = ' '.join((native_str(x) for x in (op + '_4x4_3x3', SMs, dtype.itemsize, N, C, K, H, W, P, Q)))\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)\n    if external is None:\n        self.init()\n    else:\n        self.initialized = True\n        self.init(autotune=1, external=external)\n    lib.set_scratch_size(self.image_size, self.filter_trans.size, self.bsum.size)",
        "mutated": [
            "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, external=None, bprop=False):\n    if False:\n        i = 10\n    super(XpropWinograd_4x4_3x3, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    SMs = _get_sm_count()\n    self.autotune_key = ' '.join((native_str(x) for x in (op + '_4x4_3x3', SMs, dtype.itemsize, N, C, K, H, W, P, Q)))\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)\n    if external is None:\n        self.init()\n    else:\n        self.initialized = True\n        self.init(autotune=1, external=external)\n    lib.set_scratch_size(self.image_size, self.filter_trans.size, self.bsum.size)",
            "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, external=None, bprop=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(XpropWinograd_4x4_3x3, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    SMs = _get_sm_count()\n    self.autotune_key = ' '.join((native_str(x) for x in (op + '_4x4_3x3', SMs, dtype.itemsize, N, C, K, H, W, P, Q)))\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)\n    if external is None:\n        self.init()\n    else:\n        self.initialized = True\n        self.init(autotune=1, external=external)\n    lib.set_scratch_size(self.image_size, self.filter_trans.size, self.bsum.size)",
            "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, external=None, bprop=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(XpropWinograd_4x4_3x3, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    SMs = _get_sm_count()\n    self.autotune_key = ' '.join((native_str(x) for x in (op + '_4x4_3x3', SMs, dtype.itemsize, N, C, K, H, W, P, Q)))\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)\n    if external is None:\n        self.init()\n    else:\n        self.initialized = True\n        self.init(autotune=1, external=external)\n    lib.set_scratch_size(self.image_size, self.filter_trans.size, self.bsum.size)",
            "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, external=None, bprop=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(XpropWinograd_4x4_3x3, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    SMs = _get_sm_count()\n    self.autotune_key = ' '.join((native_str(x) for x in (op + '_4x4_3x3', SMs, dtype.itemsize, N, C, K, H, W, P, Q)))\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)\n    if external is None:\n        self.init()\n    else:\n        self.initialized = True\n        self.init(autotune=1, external=external)\n    lib.set_scratch_size(self.image_size, self.filter_trans.size, self.bsum.size)",
            "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, external=None, bprop=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(XpropWinograd_4x4_3x3, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    SMs = _get_sm_count()\n    self.autotune_key = ' '.join((native_str(x) for x in (op + '_4x4_3x3', SMs, dtype.itemsize, N, C, K, H, W, P, Q)))\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)\n    if external is None:\n        self.init()\n    else:\n        self.initialized = True\n        self.init(autotune=1, external=external)\n    lib.set_scratch_size(self.image_size, self.filter_trans.size, self.bsum.size)"
        ]
    },
    {
        "func_name": "init",
        "original": "def init(self, autotune=0, external=1):\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    if not autotune:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            if self.autotune_key in autotune_db:\n                external = autotune_db[self.autotune_key]\n                self.initialized = True\n            else:\n                external = True\n                self.initialized = False\n    external = True\n    self.initialized = True\n    self.external = external\n    if N == 1:\n        shlN = 0\n    elif N < 32:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 5\n    (shlY, shlX, maskY, shrY, maskX, shrX, maskN, supY, supX) = {0: (4, 5, 24, 3, 7, 0, 0, 515, 768), 1: (4, 4, 24, 3, 6, 1, 1, 515, 513), 2: (3, 4, 16, 4, 12, 2, 3, 260, 514), 3: (3, 3, 16, 4, 8, 3, 7, 260, 259), 4: (2, 3, 0, 0, 16, 4, 15, 0, 260), 5: (2, 2, 0, 0, 0, 0, 31, 0, 0)}.get(shlN)\n    itemsize = self.dtype.itemsize\n    GYS = _ceil_div(P, 1 << shlY)\n    GXS = _ceil_div(Q, 1 << shlX)\n    GN = _ceil_div(N, 1 << shlN)\n    GK = _ceil_div(K, 32)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    k = _closest_divisor(GK, 4)\n    self.kernel_args = [(GYS * GXS * k, GK // k, GN), (640, 1, 1), None, None, None, None, None, None, None, None, None]\n    options = list()\n    if external:\n        self.kernel_name = '%s_winograd_4x4_3x3_32x32_X' % self.clss\n        options.append(('Q', Q))\n        options.append(('N', N))\n        Xk = GXS * k\n        magic_GXS2 = _magic64(GXS2)\n        magic_Xk = _magic64(Xk)\n        magic_k = _magic32(Xk, k)\n        self.image_size = itemsize * 1152 * C * GXS * GYS * GN\n        self.image_args = [(GN, GYS * GXS, C), (32, 1, 1), None, None, None, H, W, N, pad_h, pad_w, GXS, GYS2, GXS2, magic_GXS2[0], magic_GXS2[1], shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GYS * GXS * C * 1152, GXS * C * 1152, C * 1152]\n        self.kernel_args.extend(_flatten([C, K, N, Xk, k, magic_Xk, magic_k, C * 1152, GXS * C * 1152, GYS * GXS * C * 1152, P, Q, Q * N, P * Q * N, P * Q * N * 15, maskN, shlX, shlY, supX, supY, GN, GXS * GN, GYS * GXS * GN]))\n    else:\n        self.kernel_name = '%s_winograd_4x4_3x3_32x32' % self.clss\n        options.append(('K', K))\n        options.append(('W', W))\n        options.append(('Q', Q))\n        options.append(('N', N))\n        self.image_size = 0\n        Xk = GXS2 * k\n        magic_Xk = _magic64(Xk)\n        magic_k = _magic32(Xk, k)\n        self.kernel_args.extend(_flatten([C, K, N, H, W, H * W * N, W * N, GYS2, GXS, Xk, k, magic_Xk, magic_k, P, Q, Q * N, P * Q * N, P * Q * N * 15, maskN, shlX, shlY, supX, supY, pad_w, pad_h, R * S * K, R * S * K * 2 * itemsize, H * W * N * 2 * itemsize, GN, GXS * GN, GYS * GXS * GN]))\n    self.kernel_opts = tuple(options)\n    self.bsum = BatchNormSum(self.lib, K, GYS * GXS * GN)",
        "mutated": [
            "def init(self, autotune=0, external=1):\n    if False:\n        i = 10\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    if not autotune:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            if self.autotune_key in autotune_db:\n                external = autotune_db[self.autotune_key]\n                self.initialized = True\n            else:\n                external = True\n                self.initialized = False\n    external = True\n    self.initialized = True\n    self.external = external\n    if N == 1:\n        shlN = 0\n    elif N < 32:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 5\n    (shlY, shlX, maskY, shrY, maskX, shrX, maskN, supY, supX) = {0: (4, 5, 24, 3, 7, 0, 0, 515, 768), 1: (4, 4, 24, 3, 6, 1, 1, 515, 513), 2: (3, 4, 16, 4, 12, 2, 3, 260, 514), 3: (3, 3, 16, 4, 8, 3, 7, 260, 259), 4: (2, 3, 0, 0, 16, 4, 15, 0, 260), 5: (2, 2, 0, 0, 0, 0, 31, 0, 0)}.get(shlN)\n    itemsize = self.dtype.itemsize\n    GYS = _ceil_div(P, 1 << shlY)\n    GXS = _ceil_div(Q, 1 << shlX)\n    GN = _ceil_div(N, 1 << shlN)\n    GK = _ceil_div(K, 32)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    k = _closest_divisor(GK, 4)\n    self.kernel_args = [(GYS * GXS * k, GK // k, GN), (640, 1, 1), None, None, None, None, None, None, None, None, None]\n    options = list()\n    if external:\n        self.kernel_name = '%s_winograd_4x4_3x3_32x32_X' % self.clss\n        options.append(('Q', Q))\n        options.append(('N', N))\n        Xk = GXS * k\n        magic_GXS2 = _magic64(GXS2)\n        magic_Xk = _magic64(Xk)\n        magic_k = _magic32(Xk, k)\n        self.image_size = itemsize * 1152 * C * GXS * GYS * GN\n        self.image_args = [(GN, GYS * GXS, C), (32, 1, 1), None, None, None, H, W, N, pad_h, pad_w, GXS, GYS2, GXS2, magic_GXS2[0], magic_GXS2[1], shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GYS * GXS * C * 1152, GXS * C * 1152, C * 1152]\n        self.kernel_args.extend(_flatten([C, K, N, Xk, k, magic_Xk, magic_k, C * 1152, GXS * C * 1152, GYS * GXS * C * 1152, P, Q, Q * N, P * Q * N, P * Q * N * 15, maskN, shlX, shlY, supX, supY, GN, GXS * GN, GYS * GXS * GN]))\n    else:\n        self.kernel_name = '%s_winograd_4x4_3x3_32x32' % self.clss\n        options.append(('K', K))\n        options.append(('W', W))\n        options.append(('Q', Q))\n        options.append(('N', N))\n        self.image_size = 0\n        Xk = GXS2 * k\n        magic_Xk = _magic64(Xk)\n        magic_k = _magic32(Xk, k)\n        self.kernel_args.extend(_flatten([C, K, N, H, W, H * W * N, W * N, GYS2, GXS, Xk, k, magic_Xk, magic_k, P, Q, Q * N, P * Q * N, P * Q * N * 15, maskN, shlX, shlY, supX, supY, pad_w, pad_h, R * S * K, R * S * K * 2 * itemsize, H * W * N * 2 * itemsize, GN, GXS * GN, GYS * GXS * GN]))\n    self.kernel_opts = tuple(options)\n    self.bsum = BatchNormSum(self.lib, K, GYS * GXS * GN)",
            "def init(self, autotune=0, external=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    if not autotune:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            if self.autotune_key in autotune_db:\n                external = autotune_db[self.autotune_key]\n                self.initialized = True\n            else:\n                external = True\n                self.initialized = False\n    external = True\n    self.initialized = True\n    self.external = external\n    if N == 1:\n        shlN = 0\n    elif N < 32:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 5\n    (shlY, shlX, maskY, shrY, maskX, shrX, maskN, supY, supX) = {0: (4, 5, 24, 3, 7, 0, 0, 515, 768), 1: (4, 4, 24, 3, 6, 1, 1, 515, 513), 2: (3, 4, 16, 4, 12, 2, 3, 260, 514), 3: (3, 3, 16, 4, 8, 3, 7, 260, 259), 4: (2, 3, 0, 0, 16, 4, 15, 0, 260), 5: (2, 2, 0, 0, 0, 0, 31, 0, 0)}.get(shlN)\n    itemsize = self.dtype.itemsize\n    GYS = _ceil_div(P, 1 << shlY)\n    GXS = _ceil_div(Q, 1 << shlX)\n    GN = _ceil_div(N, 1 << shlN)\n    GK = _ceil_div(K, 32)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    k = _closest_divisor(GK, 4)\n    self.kernel_args = [(GYS * GXS * k, GK // k, GN), (640, 1, 1), None, None, None, None, None, None, None, None, None]\n    options = list()\n    if external:\n        self.kernel_name = '%s_winograd_4x4_3x3_32x32_X' % self.clss\n        options.append(('Q', Q))\n        options.append(('N', N))\n        Xk = GXS * k\n        magic_GXS2 = _magic64(GXS2)\n        magic_Xk = _magic64(Xk)\n        magic_k = _magic32(Xk, k)\n        self.image_size = itemsize * 1152 * C * GXS * GYS * GN\n        self.image_args = [(GN, GYS * GXS, C), (32, 1, 1), None, None, None, H, W, N, pad_h, pad_w, GXS, GYS2, GXS2, magic_GXS2[0], magic_GXS2[1], shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GYS * GXS * C * 1152, GXS * C * 1152, C * 1152]\n        self.kernel_args.extend(_flatten([C, K, N, Xk, k, magic_Xk, magic_k, C * 1152, GXS * C * 1152, GYS * GXS * C * 1152, P, Q, Q * N, P * Q * N, P * Q * N * 15, maskN, shlX, shlY, supX, supY, GN, GXS * GN, GYS * GXS * GN]))\n    else:\n        self.kernel_name = '%s_winograd_4x4_3x3_32x32' % self.clss\n        options.append(('K', K))\n        options.append(('W', W))\n        options.append(('Q', Q))\n        options.append(('N', N))\n        self.image_size = 0\n        Xk = GXS2 * k\n        magic_Xk = _magic64(Xk)\n        magic_k = _magic32(Xk, k)\n        self.kernel_args.extend(_flatten([C, K, N, H, W, H * W * N, W * N, GYS2, GXS, Xk, k, magic_Xk, magic_k, P, Q, Q * N, P * Q * N, P * Q * N * 15, maskN, shlX, shlY, supX, supY, pad_w, pad_h, R * S * K, R * S * K * 2 * itemsize, H * W * N * 2 * itemsize, GN, GXS * GN, GYS * GXS * GN]))\n    self.kernel_opts = tuple(options)\n    self.bsum = BatchNormSum(self.lib, K, GYS * GXS * GN)",
            "def init(self, autotune=0, external=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    if not autotune:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            if self.autotune_key in autotune_db:\n                external = autotune_db[self.autotune_key]\n                self.initialized = True\n            else:\n                external = True\n                self.initialized = False\n    external = True\n    self.initialized = True\n    self.external = external\n    if N == 1:\n        shlN = 0\n    elif N < 32:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 5\n    (shlY, shlX, maskY, shrY, maskX, shrX, maskN, supY, supX) = {0: (4, 5, 24, 3, 7, 0, 0, 515, 768), 1: (4, 4, 24, 3, 6, 1, 1, 515, 513), 2: (3, 4, 16, 4, 12, 2, 3, 260, 514), 3: (3, 3, 16, 4, 8, 3, 7, 260, 259), 4: (2, 3, 0, 0, 16, 4, 15, 0, 260), 5: (2, 2, 0, 0, 0, 0, 31, 0, 0)}.get(shlN)\n    itemsize = self.dtype.itemsize\n    GYS = _ceil_div(P, 1 << shlY)\n    GXS = _ceil_div(Q, 1 << shlX)\n    GN = _ceil_div(N, 1 << shlN)\n    GK = _ceil_div(K, 32)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    k = _closest_divisor(GK, 4)\n    self.kernel_args = [(GYS * GXS * k, GK // k, GN), (640, 1, 1), None, None, None, None, None, None, None, None, None]\n    options = list()\n    if external:\n        self.kernel_name = '%s_winograd_4x4_3x3_32x32_X' % self.clss\n        options.append(('Q', Q))\n        options.append(('N', N))\n        Xk = GXS * k\n        magic_GXS2 = _magic64(GXS2)\n        magic_Xk = _magic64(Xk)\n        magic_k = _magic32(Xk, k)\n        self.image_size = itemsize * 1152 * C * GXS * GYS * GN\n        self.image_args = [(GN, GYS * GXS, C), (32, 1, 1), None, None, None, H, W, N, pad_h, pad_w, GXS, GYS2, GXS2, magic_GXS2[0], magic_GXS2[1], shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GYS * GXS * C * 1152, GXS * C * 1152, C * 1152]\n        self.kernel_args.extend(_flatten([C, K, N, Xk, k, magic_Xk, magic_k, C * 1152, GXS * C * 1152, GYS * GXS * C * 1152, P, Q, Q * N, P * Q * N, P * Q * N * 15, maskN, shlX, shlY, supX, supY, GN, GXS * GN, GYS * GXS * GN]))\n    else:\n        self.kernel_name = '%s_winograd_4x4_3x3_32x32' % self.clss\n        options.append(('K', K))\n        options.append(('W', W))\n        options.append(('Q', Q))\n        options.append(('N', N))\n        self.image_size = 0\n        Xk = GXS2 * k\n        magic_Xk = _magic64(Xk)\n        magic_k = _magic32(Xk, k)\n        self.kernel_args.extend(_flatten([C, K, N, H, W, H * W * N, W * N, GYS2, GXS, Xk, k, magic_Xk, magic_k, P, Q, Q * N, P * Q * N, P * Q * N * 15, maskN, shlX, shlY, supX, supY, pad_w, pad_h, R * S * K, R * S * K * 2 * itemsize, H * W * N * 2 * itemsize, GN, GXS * GN, GYS * GXS * GN]))\n    self.kernel_opts = tuple(options)\n    self.bsum = BatchNormSum(self.lib, K, GYS * GXS * GN)",
            "def init(self, autotune=0, external=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    if not autotune:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            if self.autotune_key in autotune_db:\n                external = autotune_db[self.autotune_key]\n                self.initialized = True\n            else:\n                external = True\n                self.initialized = False\n    external = True\n    self.initialized = True\n    self.external = external\n    if N == 1:\n        shlN = 0\n    elif N < 32:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 5\n    (shlY, shlX, maskY, shrY, maskX, shrX, maskN, supY, supX) = {0: (4, 5, 24, 3, 7, 0, 0, 515, 768), 1: (4, 4, 24, 3, 6, 1, 1, 515, 513), 2: (3, 4, 16, 4, 12, 2, 3, 260, 514), 3: (3, 3, 16, 4, 8, 3, 7, 260, 259), 4: (2, 3, 0, 0, 16, 4, 15, 0, 260), 5: (2, 2, 0, 0, 0, 0, 31, 0, 0)}.get(shlN)\n    itemsize = self.dtype.itemsize\n    GYS = _ceil_div(P, 1 << shlY)\n    GXS = _ceil_div(Q, 1 << shlX)\n    GN = _ceil_div(N, 1 << shlN)\n    GK = _ceil_div(K, 32)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    k = _closest_divisor(GK, 4)\n    self.kernel_args = [(GYS * GXS * k, GK // k, GN), (640, 1, 1), None, None, None, None, None, None, None, None, None]\n    options = list()\n    if external:\n        self.kernel_name = '%s_winograd_4x4_3x3_32x32_X' % self.clss\n        options.append(('Q', Q))\n        options.append(('N', N))\n        Xk = GXS * k\n        magic_GXS2 = _magic64(GXS2)\n        magic_Xk = _magic64(Xk)\n        magic_k = _magic32(Xk, k)\n        self.image_size = itemsize * 1152 * C * GXS * GYS * GN\n        self.image_args = [(GN, GYS * GXS, C), (32, 1, 1), None, None, None, H, W, N, pad_h, pad_w, GXS, GYS2, GXS2, magic_GXS2[0], magic_GXS2[1], shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GYS * GXS * C * 1152, GXS * C * 1152, C * 1152]\n        self.kernel_args.extend(_flatten([C, K, N, Xk, k, magic_Xk, magic_k, C * 1152, GXS * C * 1152, GYS * GXS * C * 1152, P, Q, Q * N, P * Q * N, P * Q * N * 15, maskN, shlX, shlY, supX, supY, GN, GXS * GN, GYS * GXS * GN]))\n    else:\n        self.kernel_name = '%s_winograd_4x4_3x3_32x32' % self.clss\n        options.append(('K', K))\n        options.append(('W', W))\n        options.append(('Q', Q))\n        options.append(('N', N))\n        self.image_size = 0\n        Xk = GXS2 * k\n        magic_Xk = _magic64(Xk)\n        magic_k = _magic32(Xk, k)\n        self.kernel_args.extend(_flatten([C, K, N, H, W, H * W * N, W * N, GYS2, GXS, Xk, k, magic_Xk, magic_k, P, Q, Q * N, P * Q * N, P * Q * N * 15, maskN, shlX, shlY, supX, supY, pad_w, pad_h, R * S * K, R * S * K * 2 * itemsize, H * W * N * 2 * itemsize, GN, GXS * GN, GYS * GXS * GN]))\n    self.kernel_opts = tuple(options)\n    self.bsum = BatchNormSum(self.lib, K, GYS * GXS * GN)",
            "def init(self, autotune=0, external=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    if not autotune:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            if self.autotune_key in autotune_db:\n                external = autotune_db[self.autotune_key]\n                self.initialized = True\n            else:\n                external = True\n                self.initialized = False\n    external = True\n    self.initialized = True\n    self.external = external\n    if N == 1:\n        shlN = 0\n    elif N < 32:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 5\n    (shlY, shlX, maskY, shrY, maskX, shrX, maskN, supY, supX) = {0: (4, 5, 24, 3, 7, 0, 0, 515, 768), 1: (4, 4, 24, 3, 6, 1, 1, 515, 513), 2: (3, 4, 16, 4, 12, 2, 3, 260, 514), 3: (3, 3, 16, 4, 8, 3, 7, 260, 259), 4: (2, 3, 0, 0, 16, 4, 15, 0, 260), 5: (2, 2, 0, 0, 0, 0, 31, 0, 0)}.get(shlN)\n    itemsize = self.dtype.itemsize\n    GYS = _ceil_div(P, 1 << shlY)\n    GXS = _ceil_div(Q, 1 << shlX)\n    GN = _ceil_div(N, 1 << shlN)\n    GK = _ceil_div(K, 32)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    k = _closest_divisor(GK, 4)\n    self.kernel_args = [(GYS * GXS * k, GK // k, GN), (640, 1, 1), None, None, None, None, None, None, None, None, None]\n    options = list()\n    if external:\n        self.kernel_name = '%s_winograd_4x4_3x3_32x32_X' % self.clss\n        options.append(('Q', Q))\n        options.append(('N', N))\n        Xk = GXS * k\n        magic_GXS2 = _magic64(GXS2)\n        magic_Xk = _magic64(Xk)\n        magic_k = _magic32(Xk, k)\n        self.image_size = itemsize * 1152 * C * GXS * GYS * GN\n        self.image_args = [(GN, GYS * GXS, C), (32, 1, 1), None, None, None, H, W, N, pad_h, pad_w, GXS, GYS2, GXS2, magic_GXS2[0], magic_GXS2[1], shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GYS * GXS * C * 1152, GXS * C * 1152, C * 1152]\n        self.kernel_args.extend(_flatten([C, K, N, Xk, k, magic_Xk, magic_k, C * 1152, GXS * C * 1152, GYS * GXS * C * 1152, P, Q, Q * N, P * Q * N, P * Q * N * 15, maskN, shlX, shlY, supX, supY, GN, GXS * GN, GYS * GXS * GN]))\n    else:\n        self.kernel_name = '%s_winograd_4x4_3x3_32x32' % self.clss\n        options.append(('K', K))\n        options.append(('W', W))\n        options.append(('Q', Q))\n        options.append(('N', N))\n        self.image_size = 0\n        Xk = GXS2 * k\n        magic_Xk = _magic64(Xk)\n        magic_k = _magic32(Xk, k)\n        self.kernel_args.extend(_flatten([C, K, N, H, W, H * W * N, W * N, GYS2, GXS, Xk, k, magic_Xk, magic_k, P, Q, Q * N, P * Q * N, P * Q * N * 15, maskN, shlX, shlY, supX, supY, pad_w, pad_h, R * S * K, R * S * K * 2 * itemsize, H * W * N * 2 * itemsize, GN, GXS * GN, GYS * GXS * GN]))\n    self.kernel_opts = tuple(options)\n    self.bsum = BatchNormSum(self.lib, K, GYS * GXS * GN)"
        ]
    },
    {
        "func_name": "autotune",
        "original": "def autotune(self, I, F, O):\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=1, external=1)\n        self.bind_params(I, F, O, no_op=1)\n        self.execute(repeat=self.warmup, unbind=False)\n    results = []\n    for external in (0, 1):\n        self.init(autotune=1, external=external)\n        self.bind_params(I, F, O, no_op=1)\n        start.record(stream=self.lib.stream)\n        self.execute(repeat=self.warmup, unbind=False)\n        stop.record(stream=self.lib.stream)\n        stop.synchronize()\n        msecs = stop.time_since(start) / self.warmup\n        results.append((msecs, external))\n    results.sort()\n    external = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[self.autotune_key] = external\n    self.init(autotune=0, external=external)",
        "mutated": [
            "def autotune(self, I, F, O):\n    if False:\n        i = 10\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=1, external=1)\n        self.bind_params(I, F, O, no_op=1)\n        self.execute(repeat=self.warmup, unbind=False)\n    results = []\n    for external in (0, 1):\n        self.init(autotune=1, external=external)\n        self.bind_params(I, F, O, no_op=1)\n        start.record(stream=self.lib.stream)\n        self.execute(repeat=self.warmup, unbind=False)\n        stop.record(stream=self.lib.stream)\n        stop.synchronize()\n        msecs = stop.time_since(start) / self.warmup\n        results.append((msecs, external))\n    results.sort()\n    external = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[self.autotune_key] = external\n    self.init(autotune=0, external=external)",
            "def autotune(self, I, F, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=1, external=1)\n        self.bind_params(I, F, O, no_op=1)\n        self.execute(repeat=self.warmup, unbind=False)\n    results = []\n    for external in (0, 1):\n        self.init(autotune=1, external=external)\n        self.bind_params(I, F, O, no_op=1)\n        start.record(stream=self.lib.stream)\n        self.execute(repeat=self.warmup, unbind=False)\n        stop.record(stream=self.lib.stream)\n        stop.synchronize()\n        msecs = stop.time_since(start) / self.warmup\n        results.append((msecs, external))\n    results.sort()\n    external = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[self.autotune_key] = external\n    self.init(autotune=0, external=external)",
            "def autotune(self, I, F, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=1, external=1)\n        self.bind_params(I, F, O, no_op=1)\n        self.execute(repeat=self.warmup, unbind=False)\n    results = []\n    for external in (0, 1):\n        self.init(autotune=1, external=external)\n        self.bind_params(I, F, O, no_op=1)\n        start.record(stream=self.lib.stream)\n        self.execute(repeat=self.warmup, unbind=False)\n        stop.record(stream=self.lib.stream)\n        stop.synchronize()\n        msecs = stop.time_since(start) / self.warmup\n        results.append((msecs, external))\n    results.sort()\n    external = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[self.autotune_key] = external\n    self.init(autotune=0, external=external)",
            "def autotune(self, I, F, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=1, external=1)\n        self.bind_params(I, F, O, no_op=1)\n        self.execute(repeat=self.warmup, unbind=False)\n    results = []\n    for external in (0, 1):\n        self.init(autotune=1, external=external)\n        self.bind_params(I, F, O, no_op=1)\n        start.record(stream=self.lib.stream)\n        self.execute(repeat=self.warmup, unbind=False)\n        stop.record(stream=self.lib.stream)\n        stop.synchronize()\n        msecs = stop.time_since(start) / self.warmup\n        results.append((msecs, external))\n    results.sort()\n    external = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[self.autotune_key] = external\n    self.init(autotune=0, external=external)",
            "def autotune(self, I, F, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (start, stop) = self.lib.get_events()\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=1, external=1)\n        self.bind_params(I, F, O, no_op=1)\n        self.execute(repeat=self.warmup, unbind=False)\n    results = []\n    for external in (0, 1):\n        self.init(autotune=1, external=external)\n        self.bind_params(I, F, O, no_op=1)\n        start.record(stream=self.lib.stream)\n        self.execute(repeat=self.warmup, unbind=False)\n        stop.record(stream=self.lib.stream)\n        stop.synchronize()\n        msecs = stop.time_since(start) / self.warmup\n        results.append((msecs, external))\n    results.sort()\n    external = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[self.autotune_key] = external\n    self.init(autotune=0, external=external)"
        ]
    },
    {
        "func_name": "bind_params",
        "original": "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    assert I.dtype == O.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, F, O)\n    self.lib.scratch_buffer_init()\n    if self.image_size:\n        image_data = self.lib.scratch_buffer_offset(self.image_size)\n        self.image_args[2:5] = (self.lib.stream, image_data, I.gpudata)\n    else:\n        image_data = I.gpudata\n    filter_data = self.filter_trans.bind_params(F)\n    (bsum_data, x_data) = self.xprop_params(O, X, bias, bsum, beta, relu, brelu, slope)\n    self.kernel_args[2:11] = (self.lib.stream, bsum_data, x_data, O.gpudata, image_data, filter_data, alpha, beta or slope, no_op)",
        "mutated": [
            "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    if False:\n        i = 10\n    assert I.dtype == O.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, F, O)\n    self.lib.scratch_buffer_init()\n    if self.image_size:\n        image_data = self.lib.scratch_buffer_offset(self.image_size)\n        self.image_args[2:5] = (self.lib.stream, image_data, I.gpudata)\n    else:\n        image_data = I.gpudata\n    filter_data = self.filter_trans.bind_params(F)\n    (bsum_data, x_data) = self.xprop_params(O, X, bias, bsum, beta, relu, brelu, slope)\n    self.kernel_args[2:11] = (self.lib.stream, bsum_data, x_data, O.gpudata, image_data, filter_data, alpha, beta or slope, no_op)",
            "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert I.dtype == O.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, F, O)\n    self.lib.scratch_buffer_init()\n    if self.image_size:\n        image_data = self.lib.scratch_buffer_offset(self.image_size)\n        self.image_args[2:5] = (self.lib.stream, image_data, I.gpudata)\n    else:\n        image_data = I.gpudata\n    filter_data = self.filter_trans.bind_params(F)\n    (bsum_data, x_data) = self.xprop_params(O, X, bias, bsum, beta, relu, brelu, slope)\n    self.kernel_args[2:11] = (self.lib.stream, bsum_data, x_data, O.gpudata, image_data, filter_data, alpha, beta or slope, no_op)",
            "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert I.dtype == O.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, F, O)\n    self.lib.scratch_buffer_init()\n    if self.image_size:\n        image_data = self.lib.scratch_buffer_offset(self.image_size)\n        self.image_args[2:5] = (self.lib.stream, image_data, I.gpudata)\n    else:\n        image_data = I.gpudata\n    filter_data = self.filter_trans.bind_params(F)\n    (bsum_data, x_data) = self.xprop_params(O, X, bias, bsum, beta, relu, brelu, slope)\n    self.kernel_args[2:11] = (self.lib.stream, bsum_data, x_data, O.gpudata, image_data, filter_data, alpha, beta or slope, no_op)",
            "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert I.dtype == O.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, F, O)\n    self.lib.scratch_buffer_init()\n    if self.image_size:\n        image_data = self.lib.scratch_buffer_offset(self.image_size)\n        self.image_args[2:5] = (self.lib.stream, image_data, I.gpudata)\n    else:\n        image_data = I.gpudata\n    filter_data = self.filter_trans.bind_params(F)\n    (bsum_data, x_data) = self.xprop_params(O, X, bias, bsum, beta, relu, brelu, slope)\n    self.kernel_args[2:11] = (self.lib.stream, bsum_data, x_data, O.gpudata, image_data, filter_data, alpha, beta or slope, no_op)",
            "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert I.dtype == O.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, F, O)\n    self.lib.scratch_buffer_init()\n    if self.image_size:\n        image_data = self.lib.scratch_buffer_offset(self.image_size)\n        self.image_args[2:5] = (self.lib.stream, image_data, I.gpudata)\n    else:\n        image_data = I.gpudata\n    filter_data = self.filter_trans.bind_params(F)\n    (bsum_data, x_data) = self.xprop_params(O, X, bias, bsum, beta, relu, brelu, slope)\n    self.kernel_args[2:11] = (self.lib.stream, bsum_data, x_data, O.gpudata, image_data, filter_data, alpha, beta or slope, no_op)"
        ]
    },
    {
        "func_name": "execute",
        "original": "def execute(self, repeat=1, unbind=True):\n    if self.image_size:\n        image_kernel = _get_xprop_image_4x4_3x3_kernel(self.dtype_str)\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_options)\n    for r in range(repeat):\n        if self.image_size:\n            image_kernel.prepared_async_call(*self.image_args)\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.bsum.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.bsum.unbind()\n        self.kernel_args[2:11] = (None,) * 9\n        if self.image_size:\n            self.image_args[2:5] = (None,) * 3",
        "mutated": [
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n    if self.image_size:\n        image_kernel = _get_xprop_image_4x4_3x3_kernel(self.dtype_str)\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_options)\n    for r in range(repeat):\n        if self.image_size:\n            image_kernel.prepared_async_call(*self.image_args)\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.bsum.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.bsum.unbind()\n        self.kernel_args[2:11] = (None,) * 9\n        if self.image_size:\n            self.image_args[2:5] = (None,) * 3",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.image_size:\n        image_kernel = _get_xprop_image_4x4_3x3_kernel(self.dtype_str)\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_options)\n    for r in range(repeat):\n        if self.image_size:\n            image_kernel.prepared_async_call(*self.image_args)\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.bsum.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.bsum.unbind()\n        self.kernel_args[2:11] = (None,) * 9\n        if self.image_size:\n            self.image_args[2:5] = (None,) * 3",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.image_size:\n        image_kernel = _get_xprop_image_4x4_3x3_kernel(self.dtype_str)\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_options)\n    for r in range(repeat):\n        if self.image_size:\n            image_kernel.prepared_async_call(*self.image_args)\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.bsum.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.bsum.unbind()\n        self.kernel_args[2:11] = (None,) * 9\n        if self.image_size:\n            self.image_args[2:5] = (None,) * 3",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.image_size:\n        image_kernel = _get_xprop_image_4x4_3x3_kernel(self.dtype_str)\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_options)\n    for r in range(repeat):\n        if self.image_size:\n            image_kernel.prepared_async_call(*self.image_args)\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.bsum.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.bsum.unbind()\n        self.kernel_args[2:11] = (None,) * 9\n        if self.image_size:\n            self.image_args[2:5] = (None,) * 3",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.image_size:\n        image_kernel = _get_xprop_image_4x4_3x3_kernel(self.dtype_str)\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_options)\n    for r in range(repeat):\n        if self.image_size:\n            image_kernel.prepared_async_call(*self.image_args)\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.bsum.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.bsum.unbind()\n        self.kernel_args[2:11] = (None,) * 9\n        if self.image_size:\n            self.image_args[2:5] = (None,) * 3"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, external=None):\n    super(FpropWinograd_4x4_3x3, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, external)",
        "mutated": [
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, external=None):\n    if False:\n        i = 10\n    super(FpropWinograd_4x4_3x3, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, external)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, external=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(FpropWinograd_4x4_3x3, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, external)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, external=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(FpropWinograd_4x4_3x3, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, external)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, external=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(FpropWinograd_4x4_3x3, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, external)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, external=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(FpropWinograd_4x4_3x3, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, external)"
        ]
    },
    {
        "func_name": "init",
        "original": "def init(self, autotune=0, external=1):\n    super(FpropWinograd_4x4_3x3, self).init(autotune, external)\n    (C, K) = self.params[1:3]\n    if self.external:\n        self.filter_trans = FpropFilter_4x4_3x3(self.lib, self.dtype, C, K)\n    elif self.dtype.itemsize != 4:\n        self.filter_trans = ConvertDataType(self.lib, self.dtype, C * 9 * K, out_mode=False)\n    else:\n        self.filter_trans = NoopTransform()",
        "mutated": [
            "def init(self, autotune=0, external=1):\n    if False:\n        i = 10\n    super(FpropWinograd_4x4_3x3, self).init(autotune, external)\n    (C, K) = self.params[1:3]\n    if self.external:\n        self.filter_trans = FpropFilter_4x4_3x3(self.lib, self.dtype, C, K)\n    elif self.dtype.itemsize != 4:\n        self.filter_trans = ConvertDataType(self.lib, self.dtype, C * 9 * K, out_mode=False)\n    else:\n        self.filter_trans = NoopTransform()",
            "def init(self, autotune=0, external=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(FpropWinograd_4x4_3x3, self).init(autotune, external)\n    (C, K) = self.params[1:3]\n    if self.external:\n        self.filter_trans = FpropFilter_4x4_3x3(self.lib, self.dtype, C, K)\n    elif self.dtype.itemsize != 4:\n        self.filter_trans = ConvertDataType(self.lib, self.dtype, C * 9 * K, out_mode=False)\n    else:\n        self.filter_trans = NoopTransform()",
            "def init(self, autotune=0, external=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(FpropWinograd_4x4_3x3, self).init(autotune, external)\n    (C, K) = self.params[1:3]\n    if self.external:\n        self.filter_trans = FpropFilter_4x4_3x3(self.lib, self.dtype, C, K)\n    elif self.dtype.itemsize != 4:\n        self.filter_trans = ConvertDataType(self.lib, self.dtype, C * 9 * K, out_mode=False)\n    else:\n        self.filter_trans = NoopTransform()",
            "def init(self, autotune=0, external=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(FpropWinograd_4x4_3x3, self).init(autotune, external)\n    (C, K) = self.params[1:3]\n    if self.external:\n        self.filter_trans = FpropFilter_4x4_3x3(self.lib, self.dtype, C, K)\n    elif self.dtype.itemsize != 4:\n        self.filter_trans = ConvertDataType(self.lib, self.dtype, C * 9 * K, out_mode=False)\n    else:\n        self.filter_trans = NoopTransform()",
            "def init(self, autotune=0, external=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(FpropWinograd_4x4_3x3, self).init(autotune, external)\n    (C, K) = self.params[1:3]\n    if self.external:\n        self.filter_trans = FpropFilter_4x4_3x3(self.lib, self.dtype, C, K)\n    elif self.dtype.itemsize != 4:\n        self.filter_trans = ConvertDataType(self.lib, self.dtype, C * 9 * K, out_mode=False)\n    else:\n        self.filter_trans = NoopTransform()"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, external=None):\n    super(BpropWinograd_4x4_3x3, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 2 - pad_h, 2 - pad_w, external, bprop=True)",
        "mutated": [
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, external=None):\n    if False:\n        i = 10\n    super(BpropWinograd_4x4_3x3, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 2 - pad_h, 2 - pad_w, external, bprop=True)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, external=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(BpropWinograd_4x4_3x3, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 2 - pad_h, 2 - pad_w, external, bprop=True)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, external=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(BpropWinograd_4x4_3x3, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 2 - pad_h, 2 - pad_w, external, bprop=True)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, external=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(BpropWinograd_4x4_3x3, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 2 - pad_h, 2 - pad_w, external, bprop=True)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w, external=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(BpropWinograd_4x4_3x3, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 2 - pad_h, 2 - pad_w, external, bprop=True)"
        ]
    },
    {
        "func_name": "init",
        "original": "def init(self, autotune=0, external=1):\n    super(BpropWinograd_4x4_3x3, self).init(autotune, external)\n    (K, C) = self.params[1:3]\n    if self.external:\n        self.filter_trans = BpropFilter_4x4_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = FilterDimShuffle(self.lib, self.dtype, C, 1, 3, 3, K)",
        "mutated": [
            "def init(self, autotune=0, external=1):\n    if False:\n        i = 10\n    super(BpropWinograd_4x4_3x3, self).init(autotune, external)\n    (K, C) = self.params[1:3]\n    if self.external:\n        self.filter_trans = BpropFilter_4x4_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = FilterDimShuffle(self.lib, self.dtype, C, 1, 3, 3, K)",
            "def init(self, autotune=0, external=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(BpropWinograd_4x4_3x3, self).init(autotune, external)\n    (K, C) = self.params[1:3]\n    if self.external:\n        self.filter_trans = BpropFilter_4x4_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = FilterDimShuffle(self.lib, self.dtype, C, 1, 3, 3, K)",
            "def init(self, autotune=0, external=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(BpropWinograd_4x4_3x3, self).init(autotune, external)\n    (K, C) = self.params[1:3]\n    if self.external:\n        self.filter_trans = BpropFilter_4x4_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = FilterDimShuffle(self.lib, self.dtype, C, 1, 3, 3, K)",
            "def init(self, autotune=0, external=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(BpropWinograd_4x4_3x3, self).init(autotune, external)\n    (K, C) = self.params[1:3]\n    if self.external:\n        self.filter_trans = BpropFilter_4x4_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = FilterDimShuffle(self.lib, self.dtype, C, 1, 3, 3, K)",
            "def init(self, autotune=0, external=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(BpropWinograd_4x4_3x3, self).init(autotune, external)\n    (K, C) = self.params[1:3]\n    if self.external:\n        self.filter_trans = BpropFilter_4x4_3x3(self.lib, self.dtype, C, K)\n    else:\n        self.filter_trans = FilterDimShuffle(self.lib, self.dtype, C, 1, 3, 3, K)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    super(UpdateWinograd_3x3_4x4, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1)\n    SMs = _get_sm_count()\n    self.autotune_key = [native_str(x) for x in ('update_3x3_4x4', SMs, 0, dtype.itemsize, N, C, K, H, W, P, Q)]\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.init()\n    lib.set_scratch_size(self.image_size, self.delta_size, self.output_trans.size)\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)",
        "mutated": [
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n    super(UpdateWinograd_3x3_4x4, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1)\n    SMs = _get_sm_count()\n    self.autotune_key = [native_str(x) for x in ('update_3x3_4x4', SMs, 0, dtype.itemsize, N, C, K, H, W, P, Q)]\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.init()\n    lib.set_scratch_size(self.image_size, self.delta_size, self.output_trans.size)\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(UpdateWinograd_3x3_4x4, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1)\n    SMs = _get_sm_count()\n    self.autotune_key = [native_str(x) for x in ('update_3x3_4x4', SMs, 0, dtype.itemsize, N, C, K, H, W, P, Q)]\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.init()\n    lib.set_scratch_size(self.image_size, self.delta_size, self.output_trans.size)\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(UpdateWinograd_3x3_4x4, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1)\n    SMs = _get_sm_count()\n    self.autotune_key = [native_str(x) for x in ('update_3x3_4x4', SMs, 0, dtype.itemsize, N, C, K, H, W, P, Q)]\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.init()\n    lib.set_scratch_size(self.image_size, self.delta_size, self.output_trans.size)\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(UpdateWinograd_3x3_4x4, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1)\n    SMs = _get_sm_count()\n    self.autotune_key = [native_str(x) for x in ('update_3x3_4x4', SMs, 0, dtype.itemsize, N, C, K, H, W, P, Q)]\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.init()\n    lib.set_scratch_size(self.image_size, self.delta_size, self.output_trans.size)\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(UpdateWinograd_3x3_4x4, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 3, 3, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1)\n    SMs = _get_sm_count()\n    self.autotune_key = [native_str(x) for x in ('update_3x3_4x4', SMs, 0, dtype.itemsize, N, C, K, H, W, P, Q)]\n    self.autotune_db_file = os.path.join(lib.cache_dir, 'autotune%d.db' % sys.version_info[0])\n    self.init()\n    lib.set_scratch_size(self.image_size, self.delta_size, self.output_trans.size)\n    self.warmup = min(max(int(5000000000000.0 / (P * Q * K * N * C * 9 * 2.0) * (SMs / 24.0)), 1), 1000)"
        ]
    },
    {
        "func_name": "init",
        "original": "def init(self, autotune=False):\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    itemsize = self.dtype.itemsize\n    if N == 1:\n        shlN = 0\n    elif N < 16:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 4\n    GC32 = _ceil_div(C, 32)\n    GK32 = _ceil_div(K, 32)\n    GC16 = _ceil_div(GC32 * 32, 16)\n    GK16 = _ceil_div(GK32 * 32, 16)\n    GY = _ceil_div(P, 4)\n    GX = _ceil_div(Q, 4)\n    if shlN > 1 or GX >= 32:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (2, 6, 0, 0, 15, 0, 0), 1: (2, 5, 0, 0, 14, 1, 1), 2: (2, 4, 0, 0, 12, 2, 3), 3: (2, 3, 0, 0, 8, 3, 7), 4: (2, 2, 0, 0, 0, 0, 15)}.get(shlN)\n    elif shlN > 0 or GX >= 16:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (3, 5, 8, 3, 7, 0, 0), 1: (3, 4, 8, 3, 6, 1, 1)}.get(shlN)\n    else:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (4, 4, 12, 2, 3, 0, 0)}.get(shlN)\n    GYS = _ceil_div(P, 1 << shlY)\n    GXS = _ceil_div(Q, 1 << shlX)\n    GN16 = _ceil_div(N, 1 << shlN)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    groupC = 2\n    groupK = 2\n    groupN = 1 if GN16 & 1 else 2\n    shift_c = groupC - 1\n    shift_k = groupK - 1\n    shift_n = groupN - 1\n    X2cn = GXS2 * groupC * groupN\n    Xkn = GXS * groupK * groupN\n    magic_X2cn = _magic64(X2cn)\n    magic_Xkn = _magic64(Xkn)\n    self.image_size = GC32 * GY * GX * N * 1152 * itemsize\n    self.image_args = [(GYS * GXS * groupC * groupN, GN16 // groupN, GC16 // groupC), (256, 1, 1), None, None, None, C, H, W, N, pad_h, pad_w, GY, GX, GXS, GYS2, X2cn, magic_X2cn[0], magic_X2cn[1], shift_c, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GY * GX * N * 1152, GX * N * 1152, N * 1152]\n    self.delta_size = GK32 * GY * GX * N * 1152 * itemsize\n    self.delta_args = [(GYS * GXS * groupK * groupN, GN16 // groupN, GK16 // groupK), (256, 1, 1), None, None, None, K, P, Q, N, GY, GX, Xkn, magic_Xkn[0], magic_Xkn[1], shift_k, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, P * Q * N, Q * N, GY * GX * N * 1152, GX * N * 1152, N * 1152]\n    Gc = _closest_divisor(GC32, 4)\n    Gk = _closest_divisor(GK32, 4)\n    GC = GC32 // Gc\n    GK = GK32 // Gk\n    kc = Gk * Gc\n    YXN = GY * GX * N\n    YXN2 = self.YXN2 = _ceil_div(YXN, 2)\n    self.maxYXN2 = max(1, YXN2 // N)\n    if autotune:\n        strideYXN = autotune\n    else:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            autotune_key = ' '.join(self.autotune_key)\n            if autotune_key in autotune_db:\n                strideYXN = autotune_db[autotune_key]\n                self.initialized = True\n            else:\n                strideYXN = self.maxYXN2\n                self.initialized = False\n    self.blocksCK = GC32 * GK32\n    magic_sYXN = _magic64(strideYXN)\n    magic_kc = _magic64(kc)\n    magic_c = _magic32(kc, Gc)\n    CRSK = C * R * S * K\n    options = list()\n    if strideYXN == 1 or self.lib.deterministic:\n        self.output_trans = UpdateConvReduce(self.lib, strideYXN, CRSK)\n        self.zero = False\n        options.append('D')\n    else:\n        self.output_trans = UpdateConvReduce(self.lib, 1, CRSK)\n        self.zero = True\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_3x3_4x4_32x32' % self.clss\n    self.kernel_args = [(strideYXN * Gk * Gc, GC, GK), (640, 1, 1), None, None, None, None, 1.0]\n    self.kernel_args.extend(_flatten([K, C, Gk, Gc, kc, magic_kc, magic_c, YXN2, strideYXN, magic_sYXN, strideYXN * 2 * 1152 * itemsize, YXN, YXN * 1152, R * S * K, CRSK, K * 4, S * K * 4, (R * S * K * 15 - S * K * 2) * 4]))",
        "mutated": [
            "def init(self, autotune=False):\n    if False:\n        i = 10\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    itemsize = self.dtype.itemsize\n    if N == 1:\n        shlN = 0\n    elif N < 16:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 4\n    GC32 = _ceil_div(C, 32)\n    GK32 = _ceil_div(K, 32)\n    GC16 = _ceil_div(GC32 * 32, 16)\n    GK16 = _ceil_div(GK32 * 32, 16)\n    GY = _ceil_div(P, 4)\n    GX = _ceil_div(Q, 4)\n    if shlN > 1 or GX >= 32:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (2, 6, 0, 0, 15, 0, 0), 1: (2, 5, 0, 0, 14, 1, 1), 2: (2, 4, 0, 0, 12, 2, 3), 3: (2, 3, 0, 0, 8, 3, 7), 4: (2, 2, 0, 0, 0, 0, 15)}.get(shlN)\n    elif shlN > 0 or GX >= 16:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (3, 5, 8, 3, 7, 0, 0), 1: (3, 4, 8, 3, 6, 1, 1)}.get(shlN)\n    else:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (4, 4, 12, 2, 3, 0, 0)}.get(shlN)\n    GYS = _ceil_div(P, 1 << shlY)\n    GXS = _ceil_div(Q, 1 << shlX)\n    GN16 = _ceil_div(N, 1 << shlN)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    groupC = 2\n    groupK = 2\n    groupN = 1 if GN16 & 1 else 2\n    shift_c = groupC - 1\n    shift_k = groupK - 1\n    shift_n = groupN - 1\n    X2cn = GXS2 * groupC * groupN\n    Xkn = GXS * groupK * groupN\n    magic_X2cn = _magic64(X2cn)\n    magic_Xkn = _magic64(Xkn)\n    self.image_size = GC32 * GY * GX * N * 1152 * itemsize\n    self.image_args = [(GYS * GXS * groupC * groupN, GN16 // groupN, GC16 // groupC), (256, 1, 1), None, None, None, C, H, W, N, pad_h, pad_w, GY, GX, GXS, GYS2, X2cn, magic_X2cn[0], magic_X2cn[1], shift_c, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GY * GX * N * 1152, GX * N * 1152, N * 1152]\n    self.delta_size = GK32 * GY * GX * N * 1152 * itemsize\n    self.delta_args = [(GYS * GXS * groupK * groupN, GN16 // groupN, GK16 // groupK), (256, 1, 1), None, None, None, K, P, Q, N, GY, GX, Xkn, magic_Xkn[0], magic_Xkn[1], shift_k, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, P * Q * N, Q * N, GY * GX * N * 1152, GX * N * 1152, N * 1152]\n    Gc = _closest_divisor(GC32, 4)\n    Gk = _closest_divisor(GK32, 4)\n    GC = GC32 // Gc\n    GK = GK32 // Gk\n    kc = Gk * Gc\n    YXN = GY * GX * N\n    YXN2 = self.YXN2 = _ceil_div(YXN, 2)\n    self.maxYXN2 = max(1, YXN2 // N)\n    if autotune:\n        strideYXN = autotune\n    else:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            autotune_key = ' '.join(self.autotune_key)\n            if autotune_key in autotune_db:\n                strideYXN = autotune_db[autotune_key]\n                self.initialized = True\n            else:\n                strideYXN = self.maxYXN2\n                self.initialized = False\n    self.blocksCK = GC32 * GK32\n    magic_sYXN = _magic64(strideYXN)\n    magic_kc = _magic64(kc)\n    magic_c = _magic32(kc, Gc)\n    CRSK = C * R * S * K\n    options = list()\n    if strideYXN == 1 or self.lib.deterministic:\n        self.output_trans = UpdateConvReduce(self.lib, strideYXN, CRSK)\n        self.zero = False\n        options.append('D')\n    else:\n        self.output_trans = UpdateConvReduce(self.lib, 1, CRSK)\n        self.zero = True\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_3x3_4x4_32x32' % self.clss\n    self.kernel_args = [(strideYXN * Gk * Gc, GC, GK), (640, 1, 1), None, None, None, None, 1.0]\n    self.kernel_args.extend(_flatten([K, C, Gk, Gc, kc, magic_kc, magic_c, YXN2, strideYXN, magic_sYXN, strideYXN * 2 * 1152 * itemsize, YXN, YXN * 1152, R * S * K, CRSK, K * 4, S * K * 4, (R * S * K * 15 - S * K * 2) * 4]))",
            "def init(self, autotune=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    itemsize = self.dtype.itemsize\n    if N == 1:\n        shlN = 0\n    elif N < 16:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 4\n    GC32 = _ceil_div(C, 32)\n    GK32 = _ceil_div(K, 32)\n    GC16 = _ceil_div(GC32 * 32, 16)\n    GK16 = _ceil_div(GK32 * 32, 16)\n    GY = _ceil_div(P, 4)\n    GX = _ceil_div(Q, 4)\n    if shlN > 1 or GX >= 32:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (2, 6, 0, 0, 15, 0, 0), 1: (2, 5, 0, 0, 14, 1, 1), 2: (2, 4, 0, 0, 12, 2, 3), 3: (2, 3, 0, 0, 8, 3, 7), 4: (2, 2, 0, 0, 0, 0, 15)}.get(shlN)\n    elif shlN > 0 or GX >= 16:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (3, 5, 8, 3, 7, 0, 0), 1: (3, 4, 8, 3, 6, 1, 1)}.get(shlN)\n    else:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (4, 4, 12, 2, 3, 0, 0)}.get(shlN)\n    GYS = _ceil_div(P, 1 << shlY)\n    GXS = _ceil_div(Q, 1 << shlX)\n    GN16 = _ceil_div(N, 1 << shlN)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    groupC = 2\n    groupK = 2\n    groupN = 1 if GN16 & 1 else 2\n    shift_c = groupC - 1\n    shift_k = groupK - 1\n    shift_n = groupN - 1\n    X2cn = GXS2 * groupC * groupN\n    Xkn = GXS * groupK * groupN\n    magic_X2cn = _magic64(X2cn)\n    magic_Xkn = _magic64(Xkn)\n    self.image_size = GC32 * GY * GX * N * 1152 * itemsize\n    self.image_args = [(GYS * GXS * groupC * groupN, GN16 // groupN, GC16 // groupC), (256, 1, 1), None, None, None, C, H, W, N, pad_h, pad_w, GY, GX, GXS, GYS2, X2cn, magic_X2cn[0], magic_X2cn[1], shift_c, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GY * GX * N * 1152, GX * N * 1152, N * 1152]\n    self.delta_size = GK32 * GY * GX * N * 1152 * itemsize\n    self.delta_args = [(GYS * GXS * groupK * groupN, GN16 // groupN, GK16 // groupK), (256, 1, 1), None, None, None, K, P, Q, N, GY, GX, Xkn, magic_Xkn[0], magic_Xkn[1], shift_k, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, P * Q * N, Q * N, GY * GX * N * 1152, GX * N * 1152, N * 1152]\n    Gc = _closest_divisor(GC32, 4)\n    Gk = _closest_divisor(GK32, 4)\n    GC = GC32 // Gc\n    GK = GK32 // Gk\n    kc = Gk * Gc\n    YXN = GY * GX * N\n    YXN2 = self.YXN2 = _ceil_div(YXN, 2)\n    self.maxYXN2 = max(1, YXN2 // N)\n    if autotune:\n        strideYXN = autotune\n    else:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            autotune_key = ' '.join(self.autotune_key)\n            if autotune_key in autotune_db:\n                strideYXN = autotune_db[autotune_key]\n                self.initialized = True\n            else:\n                strideYXN = self.maxYXN2\n                self.initialized = False\n    self.blocksCK = GC32 * GK32\n    magic_sYXN = _magic64(strideYXN)\n    magic_kc = _magic64(kc)\n    magic_c = _magic32(kc, Gc)\n    CRSK = C * R * S * K\n    options = list()\n    if strideYXN == 1 or self.lib.deterministic:\n        self.output_trans = UpdateConvReduce(self.lib, strideYXN, CRSK)\n        self.zero = False\n        options.append('D')\n    else:\n        self.output_trans = UpdateConvReduce(self.lib, 1, CRSK)\n        self.zero = True\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_3x3_4x4_32x32' % self.clss\n    self.kernel_args = [(strideYXN * Gk * Gc, GC, GK), (640, 1, 1), None, None, None, None, 1.0]\n    self.kernel_args.extend(_flatten([K, C, Gk, Gc, kc, magic_kc, magic_c, YXN2, strideYXN, magic_sYXN, strideYXN * 2 * 1152 * itemsize, YXN, YXN * 1152, R * S * K, CRSK, K * 4, S * K * 4, (R * S * K * 15 - S * K * 2) * 4]))",
            "def init(self, autotune=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    itemsize = self.dtype.itemsize\n    if N == 1:\n        shlN = 0\n    elif N < 16:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 4\n    GC32 = _ceil_div(C, 32)\n    GK32 = _ceil_div(K, 32)\n    GC16 = _ceil_div(GC32 * 32, 16)\n    GK16 = _ceil_div(GK32 * 32, 16)\n    GY = _ceil_div(P, 4)\n    GX = _ceil_div(Q, 4)\n    if shlN > 1 or GX >= 32:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (2, 6, 0, 0, 15, 0, 0), 1: (2, 5, 0, 0, 14, 1, 1), 2: (2, 4, 0, 0, 12, 2, 3), 3: (2, 3, 0, 0, 8, 3, 7), 4: (2, 2, 0, 0, 0, 0, 15)}.get(shlN)\n    elif shlN > 0 or GX >= 16:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (3, 5, 8, 3, 7, 0, 0), 1: (3, 4, 8, 3, 6, 1, 1)}.get(shlN)\n    else:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (4, 4, 12, 2, 3, 0, 0)}.get(shlN)\n    GYS = _ceil_div(P, 1 << shlY)\n    GXS = _ceil_div(Q, 1 << shlX)\n    GN16 = _ceil_div(N, 1 << shlN)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    groupC = 2\n    groupK = 2\n    groupN = 1 if GN16 & 1 else 2\n    shift_c = groupC - 1\n    shift_k = groupK - 1\n    shift_n = groupN - 1\n    X2cn = GXS2 * groupC * groupN\n    Xkn = GXS * groupK * groupN\n    magic_X2cn = _magic64(X2cn)\n    magic_Xkn = _magic64(Xkn)\n    self.image_size = GC32 * GY * GX * N * 1152 * itemsize\n    self.image_args = [(GYS * GXS * groupC * groupN, GN16 // groupN, GC16 // groupC), (256, 1, 1), None, None, None, C, H, W, N, pad_h, pad_w, GY, GX, GXS, GYS2, X2cn, magic_X2cn[0], magic_X2cn[1], shift_c, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GY * GX * N * 1152, GX * N * 1152, N * 1152]\n    self.delta_size = GK32 * GY * GX * N * 1152 * itemsize\n    self.delta_args = [(GYS * GXS * groupK * groupN, GN16 // groupN, GK16 // groupK), (256, 1, 1), None, None, None, K, P, Q, N, GY, GX, Xkn, magic_Xkn[0], magic_Xkn[1], shift_k, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, P * Q * N, Q * N, GY * GX * N * 1152, GX * N * 1152, N * 1152]\n    Gc = _closest_divisor(GC32, 4)\n    Gk = _closest_divisor(GK32, 4)\n    GC = GC32 // Gc\n    GK = GK32 // Gk\n    kc = Gk * Gc\n    YXN = GY * GX * N\n    YXN2 = self.YXN2 = _ceil_div(YXN, 2)\n    self.maxYXN2 = max(1, YXN2 // N)\n    if autotune:\n        strideYXN = autotune\n    else:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            autotune_key = ' '.join(self.autotune_key)\n            if autotune_key in autotune_db:\n                strideYXN = autotune_db[autotune_key]\n                self.initialized = True\n            else:\n                strideYXN = self.maxYXN2\n                self.initialized = False\n    self.blocksCK = GC32 * GK32\n    magic_sYXN = _magic64(strideYXN)\n    magic_kc = _magic64(kc)\n    magic_c = _magic32(kc, Gc)\n    CRSK = C * R * S * K\n    options = list()\n    if strideYXN == 1 or self.lib.deterministic:\n        self.output_trans = UpdateConvReduce(self.lib, strideYXN, CRSK)\n        self.zero = False\n        options.append('D')\n    else:\n        self.output_trans = UpdateConvReduce(self.lib, 1, CRSK)\n        self.zero = True\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_3x3_4x4_32x32' % self.clss\n    self.kernel_args = [(strideYXN * Gk * Gc, GC, GK), (640, 1, 1), None, None, None, None, 1.0]\n    self.kernel_args.extend(_flatten([K, C, Gk, Gc, kc, magic_kc, magic_c, YXN2, strideYXN, magic_sYXN, strideYXN * 2 * 1152 * itemsize, YXN, YXN * 1152, R * S * K, CRSK, K * 4, S * K * 4, (R * S * K * 15 - S * K * 2) * 4]))",
            "def init(self, autotune=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    itemsize = self.dtype.itemsize\n    if N == 1:\n        shlN = 0\n    elif N < 16:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 4\n    GC32 = _ceil_div(C, 32)\n    GK32 = _ceil_div(K, 32)\n    GC16 = _ceil_div(GC32 * 32, 16)\n    GK16 = _ceil_div(GK32 * 32, 16)\n    GY = _ceil_div(P, 4)\n    GX = _ceil_div(Q, 4)\n    if shlN > 1 or GX >= 32:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (2, 6, 0, 0, 15, 0, 0), 1: (2, 5, 0, 0, 14, 1, 1), 2: (2, 4, 0, 0, 12, 2, 3), 3: (2, 3, 0, 0, 8, 3, 7), 4: (2, 2, 0, 0, 0, 0, 15)}.get(shlN)\n    elif shlN > 0 or GX >= 16:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (3, 5, 8, 3, 7, 0, 0), 1: (3, 4, 8, 3, 6, 1, 1)}.get(shlN)\n    else:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (4, 4, 12, 2, 3, 0, 0)}.get(shlN)\n    GYS = _ceil_div(P, 1 << shlY)\n    GXS = _ceil_div(Q, 1 << shlX)\n    GN16 = _ceil_div(N, 1 << shlN)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    groupC = 2\n    groupK = 2\n    groupN = 1 if GN16 & 1 else 2\n    shift_c = groupC - 1\n    shift_k = groupK - 1\n    shift_n = groupN - 1\n    X2cn = GXS2 * groupC * groupN\n    Xkn = GXS * groupK * groupN\n    magic_X2cn = _magic64(X2cn)\n    magic_Xkn = _magic64(Xkn)\n    self.image_size = GC32 * GY * GX * N * 1152 * itemsize\n    self.image_args = [(GYS * GXS * groupC * groupN, GN16 // groupN, GC16 // groupC), (256, 1, 1), None, None, None, C, H, W, N, pad_h, pad_w, GY, GX, GXS, GYS2, X2cn, magic_X2cn[0], magic_X2cn[1], shift_c, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GY * GX * N * 1152, GX * N * 1152, N * 1152]\n    self.delta_size = GK32 * GY * GX * N * 1152 * itemsize\n    self.delta_args = [(GYS * GXS * groupK * groupN, GN16 // groupN, GK16 // groupK), (256, 1, 1), None, None, None, K, P, Q, N, GY, GX, Xkn, magic_Xkn[0], magic_Xkn[1], shift_k, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, P * Q * N, Q * N, GY * GX * N * 1152, GX * N * 1152, N * 1152]\n    Gc = _closest_divisor(GC32, 4)\n    Gk = _closest_divisor(GK32, 4)\n    GC = GC32 // Gc\n    GK = GK32 // Gk\n    kc = Gk * Gc\n    YXN = GY * GX * N\n    YXN2 = self.YXN2 = _ceil_div(YXN, 2)\n    self.maxYXN2 = max(1, YXN2 // N)\n    if autotune:\n        strideYXN = autotune\n    else:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            autotune_key = ' '.join(self.autotune_key)\n            if autotune_key in autotune_db:\n                strideYXN = autotune_db[autotune_key]\n                self.initialized = True\n            else:\n                strideYXN = self.maxYXN2\n                self.initialized = False\n    self.blocksCK = GC32 * GK32\n    magic_sYXN = _magic64(strideYXN)\n    magic_kc = _magic64(kc)\n    magic_c = _magic32(kc, Gc)\n    CRSK = C * R * S * K\n    options = list()\n    if strideYXN == 1 or self.lib.deterministic:\n        self.output_trans = UpdateConvReduce(self.lib, strideYXN, CRSK)\n        self.zero = False\n        options.append('D')\n    else:\n        self.output_trans = UpdateConvReduce(self.lib, 1, CRSK)\n        self.zero = True\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_3x3_4x4_32x32' % self.clss\n    self.kernel_args = [(strideYXN * Gk * Gc, GC, GK), (640, 1, 1), None, None, None, None, 1.0]\n    self.kernel_args.extend(_flatten([K, C, Gk, Gc, kc, magic_kc, magic_c, YXN2, strideYXN, magic_sYXN, strideYXN * 2 * 1152 * itemsize, YXN, YXN * 1152, R * S * K, CRSK, K * 4, S * K * 4, (R * S * K * 15 - S * K * 2) * 4]))",
            "def init(self, autotune=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    itemsize = self.dtype.itemsize\n    if N == 1:\n        shlN = 0\n    elif N < 16:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 4\n    GC32 = _ceil_div(C, 32)\n    GK32 = _ceil_div(K, 32)\n    GC16 = _ceil_div(GC32 * 32, 16)\n    GK16 = _ceil_div(GK32 * 32, 16)\n    GY = _ceil_div(P, 4)\n    GX = _ceil_div(Q, 4)\n    if shlN > 1 or GX >= 32:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (2, 6, 0, 0, 15, 0, 0), 1: (2, 5, 0, 0, 14, 1, 1), 2: (2, 4, 0, 0, 12, 2, 3), 3: (2, 3, 0, 0, 8, 3, 7), 4: (2, 2, 0, 0, 0, 0, 15)}.get(shlN)\n    elif shlN > 0 or GX >= 16:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (3, 5, 8, 3, 7, 0, 0), 1: (3, 4, 8, 3, 6, 1, 1)}.get(shlN)\n    else:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (4, 4, 12, 2, 3, 0, 0)}.get(shlN)\n    GYS = _ceil_div(P, 1 << shlY)\n    GXS = _ceil_div(Q, 1 << shlX)\n    GN16 = _ceil_div(N, 1 << shlN)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    groupC = 2\n    groupK = 2\n    groupN = 1 if GN16 & 1 else 2\n    shift_c = groupC - 1\n    shift_k = groupK - 1\n    shift_n = groupN - 1\n    X2cn = GXS2 * groupC * groupN\n    Xkn = GXS * groupK * groupN\n    magic_X2cn = _magic64(X2cn)\n    magic_Xkn = _magic64(Xkn)\n    self.image_size = GC32 * GY * GX * N * 1152 * itemsize\n    self.image_args = [(GYS * GXS * groupC * groupN, GN16 // groupN, GC16 // groupC), (256, 1, 1), None, None, None, C, H, W, N, pad_h, pad_w, GY, GX, GXS, GYS2, X2cn, magic_X2cn[0], magic_X2cn[1], shift_c, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GY * GX * N * 1152, GX * N * 1152, N * 1152]\n    self.delta_size = GK32 * GY * GX * N * 1152 * itemsize\n    self.delta_args = [(GYS * GXS * groupK * groupN, GN16 // groupN, GK16 // groupK), (256, 1, 1), None, None, None, K, P, Q, N, GY, GX, Xkn, magic_Xkn[0], magic_Xkn[1], shift_k, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, P * Q * N, Q * N, GY * GX * N * 1152, GX * N * 1152, N * 1152]\n    Gc = _closest_divisor(GC32, 4)\n    Gk = _closest_divisor(GK32, 4)\n    GC = GC32 // Gc\n    GK = GK32 // Gk\n    kc = Gk * Gc\n    YXN = GY * GX * N\n    YXN2 = self.YXN2 = _ceil_div(YXN, 2)\n    self.maxYXN2 = max(1, YXN2 // N)\n    if autotune:\n        strideYXN = autotune\n    else:\n        with atomic_shelve(self.autotune_db_file) as autotune_db:\n            autotune_key = ' '.join(self.autotune_key)\n            if autotune_key in autotune_db:\n                strideYXN = autotune_db[autotune_key]\n                self.initialized = True\n            else:\n                strideYXN = self.maxYXN2\n                self.initialized = False\n    self.blocksCK = GC32 * GK32\n    magic_sYXN = _magic64(strideYXN)\n    magic_kc = _magic64(kc)\n    magic_c = _magic32(kc, Gc)\n    CRSK = C * R * S * K\n    options = list()\n    if strideYXN == 1 or self.lib.deterministic:\n        self.output_trans = UpdateConvReduce(self.lib, strideYXN, CRSK)\n        self.zero = False\n        options.append('D')\n    else:\n        self.output_trans = UpdateConvReduce(self.lib, 1, CRSK)\n        self.zero = True\n    self.kernel_opts = tuple(options)\n    self.kernel_name = '%s_winograd_3x3_4x4_32x32' % self.clss\n    self.kernel_args = [(strideYXN * Gk * Gc, GC, GK), (640, 1, 1), None, None, None, None, 1.0]\n    self.kernel_args.extend(_flatten([K, C, Gk, Gc, kc, magic_kc, magic_c, YXN2, strideYXN, magic_sYXN, strideYXN * 2 * 1152 * itemsize, YXN, YXN * 1152, R * S * K, CRSK, K * 4, S * K * 4, (R * S * K * 15 - S * K * 2) * 4]))"
        ]
    },
    {
        "func_name": "autotune",
        "original": "def autotune(self, I, E, O):\n    autotune_key = ' '.join(self.autotune_key)\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=self.maxYXN2)\n        self.bind_params(I, E, O, no_op=True)\n        self.execute(repeat=self.warmup, unbind=False)\n    (start, stop) = self.lib.get_events()\n    block_slots = _get_sm_count()\n    small_set = self.YXN2 < 512\n    YXN2 = float(self.YXN2)\n    results = []\n    sys.stdout.write('Autotune ' + native_str(self))\n    progress = 0\n    for threshold in (True, False):\n        for strideYXN in range(1, self.maxYXN2 + 1):\n            if progress % 32 == 0:\n                sys.stdout.write('.')\n                sys.stdout.flush()\n            progress += 1\n            blocks = self.blocksCK * strideYXN\n            depth = YXN2 / strideYXN\n            filters = blocks >= block_slots and blocks <= 24 * block_slots and (depth >= 32.0)\n            if small_set or (threshold and filters) or (not threshold and (not filters)):\n                self.init(autotune=strideYXN)\n                self.bind_params(I, E, O, no_op=True)\n                start.record(stream=self.lib.stream)\n                self.execute(repeat=2, unbind=False)\n                stop.record(stream=self.lib.stream)\n                stop.synchronize()\n                msecs = stop.time_since(start) / 2.0\n                results.append((msecs, strideYXN))\n        if len(results) > 0:\n            break\n    sys.stdout.write('\\n')\n    results.sort()\n    strideYXN = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[autotune_key] = strideYXN\n        if strideYXN <= 8:\n            self.autotune_key[2] = native_str(1 - int(self.autotune_key[2]))\n            autotune_key = ' '.join(self.autotune_key)\n            autotune_db[autotune_key] = strideYXN\n    self.init(autotune=strideYXN)",
        "mutated": [
            "def autotune(self, I, E, O):\n    if False:\n        i = 10\n    autotune_key = ' '.join(self.autotune_key)\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=self.maxYXN2)\n        self.bind_params(I, E, O, no_op=True)\n        self.execute(repeat=self.warmup, unbind=False)\n    (start, stop) = self.lib.get_events()\n    block_slots = _get_sm_count()\n    small_set = self.YXN2 < 512\n    YXN2 = float(self.YXN2)\n    results = []\n    sys.stdout.write('Autotune ' + native_str(self))\n    progress = 0\n    for threshold in (True, False):\n        for strideYXN in range(1, self.maxYXN2 + 1):\n            if progress % 32 == 0:\n                sys.stdout.write('.')\n                sys.stdout.flush()\n            progress += 1\n            blocks = self.blocksCK * strideYXN\n            depth = YXN2 / strideYXN\n            filters = blocks >= block_slots and blocks <= 24 * block_slots and (depth >= 32.0)\n            if small_set or (threshold and filters) or (not threshold and (not filters)):\n                self.init(autotune=strideYXN)\n                self.bind_params(I, E, O, no_op=True)\n                start.record(stream=self.lib.stream)\n                self.execute(repeat=2, unbind=False)\n                stop.record(stream=self.lib.stream)\n                stop.synchronize()\n                msecs = stop.time_since(start) / 2.0\n                results.append((msecs, strideYXN))\n        if len(results) > 0:\n            break\n    sys.stdout.write('\\n')\n    results.sort()\n    strideYXN = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[autotune_key] = strideYXN\n        if strideYXN <= 8:\n            self.autotune_key[2] = native_str(1 - int(self.autotune_key[2]))\n            autotune_key = ' '.join(self.autotune_key)\n            autotune_db[autotune_key] = strideYXN\n    self.init(autotune=strideYXN)",
            "def autotune(self, I, E, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    autotune_key = ' '.join(self.autotune_key)\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=self.maxYXN2)\n        self.bind_params(I, E, O, no_op=True)\n        self.execute(repeat=self.warmup, unbind=False)\n    (start, stop) = self.lib.get_events()\n    block_slots = _get_sm_count()\n    small_set = self.YXN2 < 512\n    YXN2 = float(self.YXN2)\n    results = []\n    sys.stdout.write('Autotune ' + native_str(self))\n    progress = 0\n    for threshold in (True, False):\n        for strideYXN in range(1, self.maxYXN2 + 1):\n            if progress % 32 == 0:\n                sys.stdout.write('.')\n                sys.stdout.flush()\n            progress += 1\n            blocks = self.blocksCK * strideYXN\n            depth = YXN2 / strideYXN\n            filters = blocks >= block_slots and blocks <= 24 * block_slots and (depth >= 32.0)\n            if small_set or (threshold and filters) or (not threshold and (not filters)):\n                self.init(autotune=strideYXN)\n                self.bind_params(I, E, O, no_op=True)\n                start.record(stream=self.lib.stream)\n                self.execute(repeat=2, unbind=False)\n                stop.record(stream=self.lib.stream)\n                stop.synchronize()\n                msecs = stop.time_since(start) / 2.0\n                results.append((msecs, strideYXN))\n        if len(results) > 0:\n            break\n    sys.stdout.write('\\n')\n    results.sort()\n    strideYXN = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[autotune_key] = strideYXN\n        if strideYXN <= 8:\n            self.autotune_key[2] = native_str(1 - int(self.autotune_key[2]))\n            autotune_key = ' '.join(self.autotune_key)\n            autotune_db[autotune_key] = strideYXN\n    self.init(autotune=strideYXN)",
            "def autotune(self, I, E, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    autotune_key = ' '.join(self.autotune_key)\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=self.maxYXN2)\n        self.bind_params(I, E, O, no_op=True)\n        self.execute(repeat=self.warmup, unbind=False)\n    (start, stop) = self.lib.get_events()\n    block_slots = _get_sm_count()\n    small_set = self.YXN2 < 512\n    YXN2 = float(self.YXN2)\n    results = []\n    sys.stdout.write('Autotune ' + native_str(self))\n    progress = 0\n    for threshold in (True, False):\n        for strideYXN in range(1, self.maxYXN2 + 1):\n            if progress % 32 == 0:\n                sys.stdout.write('.')\n                sys.stdout.flush()\n            progress += 1\n            blocks = self.blocksCK * strideYXN\n            depth = YXN2 / strideYXN\n            filters = blocks >= block_slots and blocks <= 24 * block_slots and (depth >= 32.0)\n            if small_set or (threshold and filters) or (not threshold and (not filters)):\n                self.init(autotune=strideYXN)\n                self.bind_params(I, E, O, no_op=True)\n                start.record(stream=self.lib.stream)\n                self.execute(repeat=2, unbind=False)\n                stop.record(stream=self.lib.stream)\n                stop.synchronize()\n                msecs = stop.time_since(start) / 2.0\n                results.append((msecs, strideYXN))\n        if len(results) > 0:\n            break\n    sys.stdout.write('\\n')\n    results.sort()\n    strideYXN = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[autotune_key] = strideYXN\n        if strideYXN <= 8:\n            self.autotune_key[2] = native_str(1 - int(self.autotune_key[2]))\n            autotune_key = ' '.join(self.autotune_key)\n            autotune_db[autotune_key] = strideYXN\n    self.init(autotune=strideYXN)",
            "def autotune(self, I, E, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    autotune_key = ' '.join(self.autotune_key)\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=self.maxYXN2)\n        self.bind_params(I, E, O, no_op=True)\n        self.execute(repeat=self.warmup, unbind=False)\n    (start, stop) = self.lib.get_events()\n    block_slots = _get_sm_count()\n    small_set = self.YXN2 < 512\n    YXN2 = float(self.YXN2)\n    results = []\n    sys.stdout.write('Autotune ' + native_str(self))\n    progress = 0\n    for threshold in (True, False):\n        for strideYXN in range(1, self.maxYXN2 + 1):\n            if progress % 32 == 0:\n                sys.stdout.write('.')\n                sys.stdout.flush()\n            progress += 1\n            blocks = self.blocksCK * strideYXN\n            depth = YXN2 / strideYXN\n            filters = blocks >= block_slots and blocks <= 24 * block_slots and (depth >= 32.0)\n            if small_set or (threshold and filters) or (not threshold and (not filters)):\n                self.init(autotune=strideYXN)\n                self.bind_params(I, E, O, no_op=True)\n                start.record(stream=self.lib.stream)\n                self.execute(repeat=2, unbind=False)\n                stop.record(stream=self.lib.stream)\n                stop.synchronize()\n                msecs = stop.time_since(start) / 2.0\n                results.append((msecs, strideYXN))\n        if len(results) > 0:\n            break\n    sys.stdout.write('\\n')\n    results.sort()\n    strideYXN = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[autotune_key] = strideYXN\n        if strideYXN <= 8:\n            self.autotune_key[2] = native_str(1 - int(self.autotune_key[2]))\n            autotune_key = ' '.join(self.autotune_key)\n            autotune_db[autotune_key] = strideYXN\n    self.init(autotune=strideYXN)",
            "def autotune(self, I, E, O):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    autotune_key = ' '.join(self.autotune_key)\n    if not self.lib.warmup:\n        self.lib.warmup = True\n        self.init(autotune=self.maxYXN2)\n        self.bind_params(I, E, O, no_op=True)\n        self.execute(repeat=self.warmup, unbind=False)\n    (start, stop) = self.lib.get_events()\n    block_slots = _get_sm_count()\n    small_set = self.YXN2 < 512\n    YXN2 = float(self.YXN2)\n    results = []\n    sys.stdout.write('Autotune ' + native_str(self))\n    progress = 0\n    for threshold in (True, False):\n        for strideYXN in range(1, self.maxYXN2 + 1):\n            if progress % 32 == 0:\n                sys.stdout.write('.')\n                sys.stdout.flush()\n            progress += 1\n            blocks = self.blocksCK * strideYXN\n            depth = YXN2 / strideYXN\n            filters = blocks >= block_slots and blocks <= 24 * block_slots and (depth >= 32.0)\n            if small_set or (threshold and filters) or (not threshold and (not filters)):\n                self.init(autotune=strideYXN)\n                self.bind_params(I, E, O, no_op=True)\n                start.record(stream=self.lib.stream)\n                self.execute(repeat=2, unbind=False)\n                stop.record(stream=self.lib.stream)\n                stop.synchronize()\n                msecs = stop.time_since(start) / 2.0\n                results.append((msecs, strideYXN))\n        if len(results) > 0:\n            break\n    sys.stdout.write('\\n')\n    results.sort()\n    strideYXN = results[0][1]\n    with atomic_shelve(self.autotune_db_file) as autotune_db:\n        autotune_db[autotune_key] = strideYXN\n        if strideYXN <= 8:\n            self.autotune_key[2] = native_str(1 - int(self.autotune_key[2]))\n            autotune_key = ' '.join(self.autotune_key)\n            autotune_db[autotune_key] = strideYXN\n    self.init(autotune=strideYXN)"
        ]
    },
    {
        "func_name": "bind_params",
        "original": "def bind_params(self, I, E, O, alpha=1.0, beta=0.0, no_op=False):\n    assert I.dtype == E.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, E, O)\n    self.lib.scratch_buffer_init()\n    image_data = self.lib.scratch_buffer_offset(self.image_size)\n    delta_data = self.lib.scratch_buffer_offset(self.delta_size)\n    output_data = self.output_trans.bind_params(O, alpha, beta, no_op)\n    self.image_args[2:5] = (self.lib.stream, image_data, I.gpudata)\n    self.delta_args[2:5] = (self.lib.stream, delta_data, E.gpudata)\n    if self.zero:\n        self.zero_args = [output_data, 0, O.size, self.lib.stream]\n    self.kernel_args[2:6] = (self.lib.stream, output_data, image_data, delta_data)",
        "mutated": [
            "def bind_params(self, I, E, O, alpha=1.0, beta=0.0, no_op=False):\n    if False:\n        i = 10\n    assert I.dtype == E.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, E, O)\n    self.lib.scratch_buffer_init()\n    image_data = self.lib.scratch_buffer_offset(self.image_size)\n    delta_data = self.lib.scratch_buffer_offset(self.delta_size)\n    output_data = self.output_trans.bind_params(O, alpha, beta, no_op)\n    self.image_args[2:5] = (self.lib.stream, image_data, I.gpudata)\n    self.delta_args[2:5] = (self.lib.stream, delta_data, E.gpudata)\n    if self.zero:\n        self.zero_args = [output_data, 0, O.size, self.lib.stream]\n    self.kernel_args[2:6] = (self.lib.stream, output_data, image_data, delta_data)",
            "def bind_params(self, I, E, O, alpha=1.0, beta=0.0, no_op=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert I.dtype == E.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, E, O)\n    self.lib.scratch_buffer_init()\n    image_data = self.lib.scratch_buffer_offset(self.image_size)\n    delta_data = self.lib.scratch_buffer_offset(self.delta_size)\n    output_data = self.output_trans.bind_params(O, alpha, beta, no_op)\n    self.image_args[2:5] = (self.lib.stream, image_data, I.gpudata)\n    self.delta_args[2:5] = (self.lib.stream, delta_data, E.gpudata)\n    if self.zero:\n        self.zero_args = [output_data, 0, O.size, self.lib.stream]\n    self.kernel_args[2:6] = (self.lib.stream, output_data, image_data, delta_data)",
            "def bind_params(self, I, E, O, alpha=1.0, beta=0.0, no_op=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert I.dtype == E.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, E, O)\n    self.lib.scratch_buffer_init()\n    image_data = self.lib.scratch_buffer_offset(self.image_size)\n    delta_data = self.lib.scratch_buffer_offset(self.delta_size)\n    output_data = self.output_trans.bind_params(O, alpha, beta, no_op)\n    self.image_args[2:5] = (self.lib.stream, image_data, I.gpudata)\n    self.delta_args[2:5] = (self.lib.stream, delta_data, E.gpudata)\n    if self.zero:\n        self.zero_args = [output_data, 0, O.size, self.lib.stream]\n    self.kernel_args[2:6] = (self.lib.stream, output_data, image_data, delta_data)",
            "def bind_params(self, I, E, O, alpha=1.0, beta=0.0, no_op=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert I.dtype == E.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, E, O)\n    self.lib.scratch_buffer_init()\n    image_data = self.lib.scratch_buffer_offset(self.image_size)\n    delta_data = self.lib.scratch_buffer_offset(self.delta_size)\n    output_data = self.output_trans.bind_params(O, alpha, beta, no_op)\n    self.image_args[2:5] = (self.lib.stream, image_data, I.gpudata)\n    self.delta_args[2:5] = (self.lib.stream, delta_data, E.gpudata)\n    if self.zero:\n        self.zero_args = [output_data, 0, O.size, self.lib.stream]\n    self.kernel_args[2:6] = (self.lib.stream, output_data, image_data, delta_data)",
            "def bind_params(self, I, E, O, alpha=1.0, beta=0.0, no_op=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert I.dtype == E.dtype == self.dtype\n    if not self.initialized:\n        self.initialized = True\n        self.autotune(I, E, O)\n    self.lib.scratch_buffer_init()\n    image_data = self.lib.scratch_buffer_offset(self.image_size)\n    delta_data = self.lib.scratch_buffer_offset(self.delta_size)\n    output_data = self.output_trans.bind_params(O, alpha, beta, no_op)\n    self.image_args[2:5] = (self.lib.stream, image_data, I.gpudata)\n    self.delta_args[2:5] = (self.lib.stream, delta_data, E.gpudata)\n    if self.zero:\n        self.zero_args = [output_data, 0, O.size, self.lib.stream]\n    self.kernel_args[2:6] = (self.lib.stream, output_data, image_data, delta_data)"
        ]
    },
    {
        "func_name": "execute",
        "original": "def execute(self, repeat=1, unbind=True):\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    image_kernel = _get_update_image_3x3_4x4_kernel(self.dtype_str)\n    delta_kernel = _get_update_delta_3x3_4x4_kernel(self.dtype_str)\n    for r in range(repeat):\n        if self.zero:\n            drv.memset_d32_async(*self.zero_args)\n        image_kernel.prepared_async_call(*self.image_args)\n        delta_kernel.prepared_async_call(*self.delta_args)\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.output_trans.unbind()\n        self.zero_args = None\n        self.kernel_args[2:6] = (None,) * 4\n        self.image_args[2:5] = (None,) * 3\n        self.delta_args[2:5] = (None,) * 3",
        "mutated": [
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    image_kernel = _get_update_image_3x3_4x4_kernel(self.dtype_str)\n    delta_kernel = _get_update_delta_3x3_4x4_kernel(self.dtype_str)\n    for r in range(repeat):\n        if self.zero:\n            drv.memset_d32_async(*self.zero_args)\n        image_kernel.prepared_async_call(*self.image_args)\n        delta_kernel.prepared_async_call(*self.delta_args)\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.output_trans.unbind()\n        self.zero_args = None\n        self.kernel_args[2:6] = (None,) * 4\n        self.image_args[2:5] = (None,) * 3\n        self.delta_args[2:5] = (None,) * 3",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    image_kernel = _get_update_image_3x3_4x4_kernel(self.dtype_str)\n    delta_kernel = _get_update_delta_3x3_4x4_kernel(self.dtype_str)\n    for r in range(repeat):\n        if self.zero:\n            drv.memset_d32_async(*self.zero_args)\n        image_kernel.prepared_async_call(*self.image_args)\n        delta_kernel.prepared_async_call(*self.delta_args)\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.output_trans.unbind()\n        self.zero_args = None\n        self.kernel_args[2:6] = (None,) * 4\n        self.image_args[2:5] = (None,) * 3\n        self.delta_args[2:5] = (None,) * 3",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    image_kernel = _get_update_image_3x3_4x4_kernel(self.dtype_str)\n    delta_kernel = _get_update_delta_3x3_4x4_kernel(self.dtype_str)\n    for r in range(repeat):\n        if self.zero:\n            drv.memset_d32_async(*self.zero_args)\n        image_kernel.prepared_async_call(*self.image_args)\n        delta_kernel.prepared_async_call(*self.delta_args)\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.output_trans.unbind()\n        self.zero_args = None\n        self.kernel_args[2:6] = (None,) * 4\n        self.image_args[2:5] = (None,) * 3\n        self.delta_args[2:5] = (None,) * 3",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    image_kernel = _get_update_image_3x3_4x4_kernel(self.dtype_str)\n    delta_kernel = _get_update_delta_3x3_4x4_kernel(self.dtype_str)\n    for r in range(repeat):\n        if self.zero:\n            drv.memset_d32_async(*self.zero_args)\n        image_kernel.prepared_async_call(*self.image_args)\n        delta_kernel.prepared_async_call(*self.delta_args)\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.output_trans.unbind()\n        self.zero_args = None\n        self.kernel_args[2:6] = (None,) * 4\n        self.image_args[2:5] = (None,) * 3\n        self.delta_args[2:5] = (None,) * 3",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    image_kernel = _get_update_image_3x3_4x4_kernel(self.dtype_str)\n    delta_kernel = _get_update_delta_3x3_4x4_kernel(self.dtype_str)\n    for r in range(repeat):\n        if self.zero:\n            drv.memset_d32_async(*self.zero_args)\n        image_kernel.prepared_async_call(*self.image_args)\n        delta_kernel.prepared_async_call(*self.delta_args)\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.output_trans.unbind()\n        self.zero_args = None\n        self.kernel_args[2:6] = (None,) * 4\n        self.image_args[2:5] = (None,) * 3\n        self.delta_args[2:5] = (None,) * 3"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, bprop=False):\n    super(XpropWinograd_2x2_5x5, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 5, 5, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    self.init()\n    lib.set_scratch_size(self.filter_trans.size, self.output_trans.size)",
        "mutated": [
            "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, bprop=False):\n    if False:\n        i = 10\n    super(XpropWinograd_2x2_5x5, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 5, 5, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    self.init()\n    lib.set_scratch_size(self.filter_trans.size, self.output_trans.size)",
            "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, bprop=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(XpropWinograd_2x2_5x5, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 5, 5, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    self.init()\n    lib.set_scratch_size(self.filter_trans.size, self.output_trans.size)",
            "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, bprop=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(XpropWinograd_2x2_5x5, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 5, 5, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    self.init()\n    lib.set_scratch_size(self.filter_trans.size, self.output_trans.size)",
            "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, bprop=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(XpropWinograd_2x2_5x5, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 5, 5, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    self.init()\n    lib.set_scratch_size(self.filter_trans.size, self.output_trans.size)",
            "def __init__(self, op, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w, bprop=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(XpropWinograd_2x2_5x5, self).__init__(lib, dtype, N, C, K, 1, H, W, 1, 5, 5, 1, P, Q, 0, pad_h, pad_w, 1, 1, 1, 1, 1, 1, bprop)\n    self.init()\n    lib.set_scratch_size(self.filter_trans.size, self.output_trans.size)"
        ]
    },
    {
        "func_name": "init",
        "original": "def init(self):\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    if N == 1:\n        shlN = 0\n    elif N < 32:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 5\n    itemsize = self.dtype.itemsize\n    if itemsize == 4:\n        (shlY, shlX, supY, supX, supN, SupY, SupX, SupN) = {0: (3, 4, 515, 768, 0, 515, 768, 0), 1: (3, 3, 515, 513, 1, 515, 513, 1), 2: (2, 3, 260, 514, 3, 260, 514, 3), 3: (2, 2, 260, 259, 7, 260, 259, 7), 4: (1, 2, 0, 260, 15, 0, 260, 15), 5: (1, 1, 0, 0, 31, 0, 0, 31)}.get(shlN)\n    else:\n        (shlY, shlX, supY, supX, supN, SupY, SupX, SupN) = {0: (3, 4, 515, 768, 0, 514, 512, 0), 1: (3, 3, 515, 513, 1, 514, 512, 0), 2: (2, 3, 260, 514, 3, 259, 513, 1), 3: (2, 2, 260, 259, 7, 259, 258, 3), 4: (1, 2, 0, 260, 15, 0, 259, 7), 5: (1, 1, 0, 0, 31, 0, 0, 15)}.get(shlN)\n    GYS = _ceil_div(H, 1 << shlY)\n    GXS = _ceil_div(W, 1 << shlX)\n    GN = _ceil_div(N, 1 << shlN)\n    GK = _ceil_div(K, 32)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    k = _closest_divisor(GK, 2)\n    Xk = GXS2 * k\n    magic_Xk = _magic64(Xk)\n    magic_k = _magic32(Xk, k)\n    options = list()\n    options.append(('W', W))\n    options.append(('Q', Q))\n    options.append(('N', N))\n    self.kernel_args = [(GYS * GXS * k, GK // k, GN), (640, 1, 1), None, None, None, None, None, None]\n    self.kernel_name = '%s_winograd_2x2_5x5_32x32' % self.clss\n    self.kernel_opts = tuple(options)\n    self.zero_args = None\n    self.kernel_args.extend(_flatten([C, K, N, H, W, H * W * N, W * N, GYS2, GXS, Xk, k, magic_Xk, magic_k, P, Q, Q * N, P * Q * N, P * Q * N * itemsize, P * Q * N * 15 * itemsize, shlY, shlX, shlN, supY, supX, supN, SupY, SupX, SupN, pad_w, pad_h, H * W * N * 2 * itemsize, C * 1152]))\n    self.output_trans = CompoundOps(self.lib, self.dtype, K, P * Q * N)",
        "mutated": [
            "def init(self):\n    if False:\n        i = 10\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    if N == 1:\n        shlN = 0\n    elif N < 32:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 5\n    itemsize = self.dtype.itemsize\n    if itemsize == 4:\n        (shlY, shlX, supY, supX, supN, SupY, SupX, SupN) = {0: (3, 4, 515, 768, 0, 515, 768, 0), 1: (3, 3, 515, 513, 1, 515, 513, 1), 2: (2, 3, 260, 514, 3, 260, 514, 3), 3: (2, 2, 260, 259, 7, 260, 259, 7), 4: (1, 2, 0, 260, 15, 0, 260, 15), 5: (1, 1, 0, 0, 31, 0, 0, 31)}.get(shlN)\n    else:\n        (shlY, shlX, supY, supX, supN, SupY, SupX, SupN) = {0: (3, 4, 515, 768, 0, 514, 512, 0), 1: (3, 3, 515, 513, 1, 514, 512, 0), 2: (2, 3, 260, 514, 3, 259, 513, 1), 3: (2, 2, 260, 259, 7, 259, 258, 3), 4: (1, 2, 0, 260, 15, 0, 259, 7), 5: (1, 1, 0, 0, 31, 0, 0, 15)}.get(shlN)\n    GYS = _ceil_div(H, 1 << shlY)\n    GXS = _ceil_div(W, 1 << shlX)\n    GN = _ceil_div(N, 1 << shlN)\n    GK = _ceil_div(K, 32)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    k = _closest_divisor(GK, 2)\n    Xk = GXS2 * k\n    magic_Xk = _magic64(Xk)\n    magic_k = _magic32(Xk, k)\n    options = list()\n    options.append(('W', W))\n    options.append(('Q', Q))\n    options.append(('N', N))\n    self.kernel_args = [(GYS * GXS * k, GK // k, GN), (640, 1, 1), None, None, None, None, None, None]\n    self.kernel_name = '%s_winograd_2x2_5x5_32x32' % self.clss\n    self.kernel_opts = tuple(options)\n    self.zero_args = None\n    self.kernel_args.extend(_flatten([C, K, N, H, W, H * W * N, W * N, GYS2, GXS, Xk, k, magic_Xk, magic_k, P, Q, Q * N, P * Q * N, P * Q * N * itemsize, P * Q * N * 15 * itemsize, shlY, shlX, shlN, supY, supX, supN, SupY, SupX, SupN, pad_w, pad_h, H * W * N * 2 * itemsize, C * 1152]))\n    self.output_trans = CompoundOps(self.lib, self.dtype, K, P * Q * N)",
            "def init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    if N == 1:\n        shlN = 0\n    elif N < 32:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 5\n    itemsize = self.dtype.itemsize\n    if itemsize == 4:\n        (shlY, shlX, supY, supX, supN, SupY, SupX, SupN) = {0: (3, 4, 515, 768, 0, 515, 768, 0), 1: (3, 3, 515, 513, 1, 515, 513, 1), 2: (2, 3, 260, 514, 3, 260, 514, 3), 3: (2, 2, 260, 259, 7, 260, 259, 7), 4: (1, 2, 0, 260, 15, 0, 260, 15), 5: (1, 1, 0, 0, 31, 0, 0, 31)}.get(shlN)\n    else:\n        (shlY, shlX, supY, supX, supN, SupY, SupX, SupN) = {0: (3, 4, 515, 768, 0, 514, 512, 0), 1: (3, 3, 515, 513, 1, 514, 512, 0), 2: (2, 3, 260, 514, 3, 259, 513, 1), 3: (2, 2, 260, 259, 7, 259, 258, 3), 4: (1, 2, 0, 260, 15, 0, 259, 7), 5: (1, 1, 0, 0, 31, 0, 0, 15)}.get(shlN)\n    GYS = _ceil_div(H, 1 << shlY)\n    GXS = _ceil_div(W, 1 << shlX)\n    GN = _ceil_div(N, 1 << shlN)\n    GK = _ceil_div(K, 32)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    k = _closest_divisor(GK, 2)\n    Xk = GXS2 * k\n    magic_Xk = _magic64(Xk)\n    magic_k = _magic32(Xk, k)\n    options = list()\n    options.append(('W', W))\n    options.append(('Q', Q))\n    options.append(('N', N))\n    self.kernel_args = [(GYS * GXS * k, GK // k, GN), (640, 1, 1), None, None, None, None, None, None]\n    self.kernel_name = '%s_winograd_2x2_5x5_32x32' % self.clss\n    self.kernel_opts = tuple(options)\n    self.zero_args = None\n    self.kernel_args.extend(_flatten([C, K, N, H, W, H * W * N, W * N, GYS2, GXS, Xk, k, magic_Xk, magic_k, P, Q, Q * N, P * Q * N, P * Q * N * itemsize, P * Q * N * 15 * itemsize, shlY, shlX, shlN, supY, supX, supN, SupY, SupX, SupN, pad_w, pad_h, H * W * N * 2 * itemsize, C * 1152]))\n    self.output_trans = CompoundOps(self.lib, self.dtype, K, P * Q * N)",
            "def init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    if N == 1:\n        shlN = 0\n    elif N < 32:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 5\n    itemsize = self.dtype.itemsize\n    if itemsize == 4:\n        (shlY, shlX, supY, supX, supN, SupY, SupX, SupN) = {0: (3, 4, 515, 768, 0, 515, 768, 0), 1: (3, 3, 515, 513, 1, 515, 513, 1), 2: (2, 3, 260, 514, 3, 260, 514, 3), 3: (2, 2, 260, 259, 7, 260, 259, 7), 4: (1, 2, 0, 260, 15, 0, 260, 15), 5: (1, 1, 0, 0, 31, 0, 0, 31)}.get(shlN)\n    else:\n        (shlY, shlX, supY, supX, supN, SupY, SupX, SupN) = {0: (3, 4, 515, 768, 0, 514, 512, 0), 1: (3, 3, 515, 513, 1, 514, 512, 0), 2: (2, 3, 260, 514, 3, 259, 513, 1), 3: (2, 2, 260, 259, 7, 259, 258, 3), 4: (1, 2, 0, 260, 15, 0, 259, 7), 5: (1, 1, 0, 0, 31, 0, 0, 15)}.get(shlN)\n    GYS = _ceil_div(H, 1 << shlY)\n    GXS = _ceil_div(W, 1 << shlX)\n    GN = _ceil_div(N, 1 << shlN)\n    GK = _ceil_div(K, 32)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    k = _closest_divisor(GK, 2)\n    Xk = GXS2 * k\n    magic_Xk = _magic64(Xk)\n    magic_k = _magic32(Xk, k)\n    options = list()\n    options.append(('W', W))\n    options.append(('Q', Q))\n    options.append(('N', N))\n    self.kernel_args = [(GYS * GXS * k, GK // k, GN), (640, 1, 1), None, None, None, None, None, None]\n    self.kernel_name = '%s_winograd_2x2_5x5_32x32' % self.clss\n    self.kernel_opts = tuple(options)\n    self.zero_args = None\n    self.kernel_args.extend(_flatten([C, K, N, H, W, H * W * N, W * N, GYS2, GXS, Xk, k, magic_Xk, magic_k, P, Q, Q * N, P * Q * N, P * Q * N * itemsize, P * Q * N * 15 * itemsize, shlY, shlX, shlN, supY, supX, supN, SupY, SupX, SupN, pad_w, pad_h, H * W * N * 2 * itemsize, C * 1152]))\n    self.output_trans = CompoundOps(self.lib, self.dtype, K, P * Q * N)",
            "def init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    if N == 1:\n        shlN = 0\n    elif N < 32:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 5\n    itemsize = self.dtype.itemsize\n    if itemsize == 4:\n        (shlY, shlX, supY, supX, supN, SupY, SupX, SupN) = {0: (3, 4, 515, 768, 0, 515, 768, 0), 1: (3, 3, 515, 513, 1, 515, 513, 1), 2: (2, 3, 260, 514, 3, 260, 514, 3), 3: (2, 2, 260, 259, 7, 260, 259, 7), 4: (1, 2, 0, 260, 15, 0, 260, 15), 5: (1, 1, 0, 0, 31, 0, 0, 31)}.get(shlN)\n    else:\n        (shlY, shlX, supY, supX, supN, SupY, SupX, SupN) = {0: (3, 4, 515, 768, 0, 514, 512, 0), 1: (3, 3, 515, 513, 1, 514, 512, 0), 2: (2, 3, 260, 514, 3, 259, 513, 1), 3: (2, 2, 260, 259, 7, 259, 258, 3), 4: (1, 2, 0, 260, 15, 0, 259, 7), 5: (1, 1, 0, 0, 31, 0, 0, 15)}.get(shlN)\n    GYS = _ceil_div(H, 1 << shlY)\n    GXS = _ceil_div(W, 1 << shlX)\n    GN = _ceil_div(N, 1 << shlN)\n    GK = _ceil_div(K, 32)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    k = _closest_divisor(GK, 2)\n    Xk = GXS2 * k\n    magic_Xk = _magic64(Xk)\n    magic_k = _magic32(Xk, k)\n    options = list()\n    options.append(('W', W))\n    options.append(('Q', Q))\n    options.append(('N', N))\n    self.kernel_args = [(GYS * GXS * k, GK // k, GN), (640, 1, 1), None, None, None, None, None, None]\n    self.kernel_name = '%s_winograd_2x2_5x5_32x32' % self.clss\n    self.kernel_opts = tuple(options)\n    self.zero_args = None\n    self.kernel_args.extend(_flatten([C, K, N, H, W, H * W * N, W * N, GYS2, GXS, Xk, k, magic_Xk, magic_k, P, Q, Q * N, P * Q * N, P * Q * N * itemsize, P * Q * N * 15 * itemsize, shlY, shlX, shlN, supY, supX, supN, SupY, SupX, SupN, pad_w, pad_h, H * W * N * 2 * itemsize, C * 1152]))\n    self.output_trans = CompoundOps(self.lib, self.dtype, K, P * Q * N)",
            "def init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w) = self.params\n    if N == 1:\n        shlN = 0\n    elif N < 32:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 5\n    itemsize = self.dtype.itemsize\n    if itemsize == 4:\n        (shlY, shlX, supY, supX, supN, SupY, SupX, SupN) = {0: (3, 4, 515, 768, 0, 515, 768, 0), 1: (3, 3, 515, 513, 1, 515, 513, 1), 2: (2, 3, 260, 514, 3, 260, 514, 3), 3: (2, 2, 260, 259, 7, 260, 259, 7), 4: (1, 2, 0, 260, 15, 0, 260, 15), 5: (1, 1, 0, 0, 31, 0, 0, 31)}.get(shlN)\n    else:\n        (shlY, shlX, supY, supX, supN, SupY, SupX, SupN) = {0: (3, 4, 515, 768, 0, 514, 512, 0), 1: (3, 3, 515, 513, 1, 514, 512, 0), 2: (2, 3, 260, 514, 3, 259, 513, 1), 3: (2, 2, 260, 259, 7, 259, 258, 3), 4: (1, 2, 0, 260, 15, 0, 259, 7), 5: (1, 1, 0, 0, 31, 0, 0, 15)}.get(shlN)\n    GYS = _ceil_div(H, 1 << shlY)\n    GXS = _ceil_div(W, 1 << shlX)\n    GN = _ceil_div(N, 1 << shlN)\n    GK = _ceil_div(K, 32)\n    GYS2 = max(GYS // 2, 1)\n    GXS2 = GXS * 2\n    k = _closest_divisor(GK, 2)\n    Xk = GXS2 * k\n    magic_Xk = _magic64(Xk)\n    magic_k = _magic32(Xk, k)\n    options = list()\n    options.append(('W', W))\n    options.append(('Q', Q))\n    options.append(('N', N))\n    self.kernel_args = [(GYS * GXS * k, GK // k, GN), (640, 1, 1), None, None, None, None, None, None]\n    self.kernel_name = '%s_winograd_2x2_5x5_32x32' % self.clss\n    self.kernel_opts = tuple(options)\n    self.zero_args = None\n    self.kernel_args.extend(_flatten([C, K, N, H, W, H * W * N, W * N, GYS2, GXS, Xk, k, magic_Xk, magic_k, P, Q, Q * N, P * Q * N, P * Q * N * itemsize, P * Q * N * 15 * itemsize, shlY, shlX, shlN, supY, supX, supN, SupY, SupX, SupN, pad_w, pad_h, H * W * N * 2 * itemsize, C * 1152]))\n    self.output_trans = CompoundOps(self.lib, self.dtype, K, P * Q * N)"
        ]
    },
    {
        "func_name": "bind_params",
        "original": "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    assert I.dtype == O.dtype == self.dtype\n    self.lib.scratch_buffer_init()\n    filter_data = self.filter_trans.bind_params(F)\n    if beta == 1.0 and X is None:\n        self.zero_args = None\n        self.kernel_args[2:8] = (self.lib.stream, O.gpudata, I.gpudata, filter_data, alpha, no_op)\n        self.output_trans.kernel = None\n    else:\n        output_data = self.output_trans.bind_params(O, X, bias, bsum, alpha, beta or slope, relu, brelu)\n        self.zero_args = (output_data, 0, O.nbytes, self.lib.stream)\n        self.kernel_args[2:8] = (self.lib.stream, output_data, I.gpudata, filter_data, 1.0, no_op)",
        "mutated": [
            "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    if False:\n        i = 10\n    assert I.dtype == O.dtype == self.dtype\n    self.lib.scratch_buffer_init()\n    filter_data = self.filter_trans.bind_params(F)\n    if beta == 1.0 and X is None:\n        self.zero_args = None\n        self.kernel_args[2:8] = (self.lib.stream, O.gpudata, I.gpudata, filter_data, alpha, no_op)\n        self.output_trans.kernel = None\n    else:\n        output_data = self.output_trans.bind_params(O, X, bias, bsum, alpha, beta or slope, relu, brelu)\n        self.zero_args = (output_data, 0, O.nbytes, self.lib.stream)\n        self.kernel_args[2:8] = (self.lib.stream, output_data, I.gpudata, filter_data, 1.0, no_op)",
            "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert I.dtype == O.dtype == self.dtype\n    self.lib.scratch_buffer_init()\n    filter_data = self.filter_trans.bind_params(F)\n    if beta == 1.0 and X is None:\n        self.zero_args = None\n        self.kernel_args[2:8] = (self.lib.stream, O.gpudata, I.gpudata, filter_data, alpha, no_op)\n        self.output_trans.kernel = None\n    else:\n        output_data = self.output_trans.bind_params(O, X, bias, bsum, alpha, beta or slope, relu, brelu)\n        self.zero_args = (output_data, 0, O.nbytes, self.lib.stream)\n        self.kernel_args[2:8] = (self.lib.stream, output_data, I.gpudata, filter_data, 1.0, no_op)",
            "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert I.dtype == O.dtype == self.dtype\n    self.lib.scratch_buffer_init()\n    filter_data = self.filter_trans.bind_params(F)\n    if beta == 1.0 and X is None:\n        self.zero_args = None\n        self.kernel_args[2:8] = (self.lib.stream, O.gpudata, I.gpudata, filter_data, alpha, no_op)\n        self.output_trans.kernel = None\n    else:\n        output_data = self.output_trans.bind_params(O, X, bias, bsum, alpha, beta or slope, relu, brelu)\n        self.zero_args = (output_data, 0, O.nbytes, self.lib.stream)\n        self.kernel_args[2:8] = (self.lib.stream, output_data, I.gpudata, filter_data, 1.0, no_op)",
            "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert I.dtype == O.dtype == self.dtype\n    self.lib.scratch_buffer_init()\n    filter_data = self.filter_trans.bind_params(F)\n    if beta == 1.0 and X is None:\n        self.zero_args = None\n        self.kernel_args[2:8] = (self.lib.stream, O.gpudata, I.gpudata, filter_data, alpha, no_op)\n        self.output_trans.kernel = None\n    else:\n        output_data = self.output_trans.bind_params(O, X, bias, bsum, alpha, beta or slope, relu, brelu)\n        self.zero_args = (output_data, 0, O.nbytes, self.lib.stream)\n        self.kernel_args[2:8] = (self.lib.stream, output_data, I.gpudata, filter_data, 1.0, no_op)",
            "def bind_params(self, I, F, O, X=None, bias=None, bsum=None, alpha=1.0, beta=0.0, relu=False, brelu=False, slope=0.0, no_op=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert I.dtype == O.dtype == self.dtype\n    self.lib.scratch_buffer_init()\n    filter_data = self.filter_trans.bind_params(F)\n    if beta == 1.0 and X is None:\n        self.zero_args = None\n        self.kernel_args[2:8] = (self.lib.stream, O.gpudata, I.gpudata, filter_data, alpha, no_op)\n        self.output_trans.kernel = None\n    else:\n        output_data = self.output_trans.bind_params(O, X, bias, bsum, alpha, beta or slope, relu, brelu)\n        self.zero_args = (output_data, 0, O.nbytes, self.lib.stream)\n        self.kernel_args[2:8] = (self.lib.stream, output_data, I.gpudata, filter_data, 1.0, no_op)"
        ]
    },
    {
        "func_name": "execute",
        "original": "def execute(self, repeat=1, unbind=True):\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    for r in range(repeat):\n        if self.zero_args is not None:\n            drv.memset_d8_async(*self.zero_args)\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.output_trans.unbind()\n        self.kernel_args[2:8] = (None,) * 6",
        "mutated": [
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    for r in range(repeat):\n        if self.zero_args is not None:\n            drv.memset_d8_async(*self.zero_args)\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.output_trans.unbind()\n        self.kernel_args[2:8] = (None,) * 6",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    for r in range(repeat):\n        if self.zero_args is not None:\n            drv.memset_d8_async(*self.zero_args)\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.output_trans.unbind()\n        self.kernel_args[2:8] = (None,) * 6",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    for r in range(repeat):\n        if self.zero_args is not None:\n            drv.memset_d8_async(*self.zero_args)\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.output_trans.unbind()\n        self.kernel_args[2:8] = (None,) * 6",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    for r in range(repeat):\n        if self.zero_args is not None:\n            drv.memset_d8_async(*self.zero_args)\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.output_trans.unbind()\n        self.kernel_args[2:8] = (None,) * 6",
            "def execute(self, repeat=1, unbind=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    kernel = kernel_specs.get_kernel(self.kernel_name, self.kernel_opts)\n    for r in range(repeat):\n        if self.zero_args is not None:\n            drv.memset_d8_async(*self.zero_args)\n        self.filter_trans.execute()\n        kernel.prepared_async_call(*self.kernel_args)\n        self.output_trans.execute()\n    if unbind:\n        self.filter_trans.unbind()\n        self.output_trans.unbind()\n        self.kernel_args[2:8] = (None,) * 6"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    super(FpropWinograd_2x2_5x5, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w)",
        "mutated": [
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n    super(FpropWinograd_2x2_5x5, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(FpropWinograd_2x2_5x5, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(FpropWinograd_2x2_5x5, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(FpropWinograd_2x2_5x5, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(FpropWinograd_2x2_5x5, self).__init__('fprop', lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w)"
        ]
    },
    {
        "func_name": "init",
        "original": "def init(self):\n    super(FpropWinograd_2x2_5x5, self).init()\n    (C, K) = self.params[1:3]\n    self.filter_trans = FpropFilter_2x2_5x5(self.lib, self.dtype, C, K)",
        "mutated": [
            "def init(self):\n    if False:\n        i = 10\n    super(FpropWinograd_2x2_5x5, self).init()\n    (C, K) = self.params[1:3]\n    self.filter_trans = FpropFilter_2x2_5x5(self.lib, self.dtype, C, K)",
            "def init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(FpropWinograd_2x2_5x5, self).init()\n    (C, K) = self.params[1:3]\n    self.filter_trans = FpropFilter_2x2_5x5(self.lib, self.dtype, C, K)",
            "def init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(FpropWinograd_2x2_5x5, self).init()\n    (C, K) = self.params[1:3]\n    self.filter_trans = FpropFilter_2x2_5x5(self.lib, self.dtype, C, K)",
            "def init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(FpropWinograd_2x2_5x5, self).init()\n    (C, K) = self.params[1:3]\n    self.filter_trans = FpropFilter_2x2_5x5(self.lib, self.dtype, C, K)",
            "def init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(FpropWinograd_2x2_5x5, self).init()\n    (C, K) = self.params[1:3]\n    self.filter_trans = FpropFilter_2x2_5x5(self.lib, self.dtype, C, K)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    super(BpropWinograd_2x2_5x5, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 4 - pad_h, 4 - pad_w, bprop=True)",
        "mutated": [
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n    super(BpropWinograd_2x2_5x5, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 4 - pad_h, 4 - pad_w, bprop=True)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(BpropWinograd_2x2_5x5, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 4 - pad_h, 4 - pad_w, bprop=True)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(BpropWinograd_2x2_5x5, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 4 - pad_h, 4 - pad_w, bprop=True)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(BpropWinograd_2x2_5x5, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 4 - pad_h, 4 - pad_w, bprop=True)",
            "def __init__(self, lib, dtype, N, C, K, D, H, W, T, R, S, M, P, Q, pad_d, pad_h, pad_w, str_d, str_h, str_w, dil_d, dil_h, dil_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(BpropWinograd_2x2_5x5, self).__init__('bprop', lib, dtype, N, K, C, P, Q, H, W, 4 - pad_h, 4 - pad_w, bprop=True)"
        ]
    },
    {
        "func_name": "init",
        "original": "def init(self):\n    super(BpropWinograd_2x2_5x5, self).init()\n    (K, C) = self.params[1:3]\n    self.filter_trans = BpropFilter_2x2_5x5(self.lib, self.dtype, C, K)",
        "mutated": [
            "def init(self):\n    if False:\n        i = 10\n    super(BpropWinograd_2x2_5x5, self).init()\n    (K, C) = self.params[1:3]\n    self.filter_trans = BpropFilter_2x2_5x5(self.lib, self.dtype, C, K)",
            "def init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(BpropWinograd_2x2_5x5, self).init()\n    (K, C) = self.params[1:3]\n    self.filter_trans = BpropFilter_2x2_5x5(self.lib, self.dtype, C, K)",
            "def init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(BpropWinograd_2x2_5x5, self).init()\n    (K, C) = self.params[1:3]\n    self.filter_trans = BpropFilter_2x2_5x5(self.lib, self.dtype, C, K)",
            "def init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(BpropWinograd_2x2_5x5, self).init()\n    (K, C) = self.params[1:3]\n    self.filter_trans = BpropFilter_2x2_5x5(self.lib, self.dtype, C, K)",
            "def init(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(BpropWinograd_2x2_5x5, self).init()\n    (K, C) = self.params[1:3]\n    self.filter_trans = BpropFilter_2x2_5x5(self.lib, self.dtype, C, K)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w):\n    if N == 1:\n        shlN = 0\n    elif N < 16:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 4\n    GY = _ceil_div(P, 2)\n    GX = _ceil_div(Q, 2)\n    if shlN > 1 or GX >= 32:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (1, 5, 0, 0, 15, 0, 0), 1: (1, 4, 0, 0, 14, 1, 1), 2: (1, 3, 0, 0, 12, 2, 3), 3: (1, 2, 0, 0, 8, 3, 7), 4: (1, 1, 0, 0, 0, 0, 15)}.get(shlN)\n    elif shlN > 0 or GX >= 16:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (2, 4, 8, 3, 7, 0, 0), 1: (2, 3, 8, 3, 6, 1, 1)}.get(shlN)\n    else:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (3, 3, 12, 2, 3, 0, 0)}.get(shlN)\n    blkN = 1 << shlN\n    blkY = 1 << shlY\n    blkX = 1 << shlX\n    gridC = _ceil_div(C, 32)\n    GC = _ceil_div(gridC * 32, 16)\n    GYS = _ceil_div(P, blkY)\n    GXS = _ceil_div(Q, blkX)\n    GN = _ceil_div(N, blkN)\n    GYS2 = GYS // 2\n    GXS2 = GXS * 2\n    groupC = 2\n    groupN = 1 if GN & 1 else 2\n    shift_c = groupC - 1\n    shift_n = groupN - 1\n    X2cn = GXS2 * groupC * groupN\n    magic_X2cn = _magic64(X2cn)\n    self.lib = lib\n    self.dtype = dtype.str[1:]\n    self.dim = (gridC, GY, GX, N, 4, 4, 32)\n    self.size = int(np.prod(self.dim)) * dtype.itemsize\n    self.args = [(GYS * GXS * groupC * groupN, GN // groupN, GC // groupC), (256, 1, 1), None, None, None, C, H, W, N, pad_h, pad_w, GY, GX, GXS, GYS2, X2cn, magic_X2cn[0], magic_X2cn[1], shift_c, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GY * GX * N * 512, GX * N * 512, N * 512]",
        "mutated": [
            "def __init__(self, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w):\n    if False:\n        i = 10\n    if N == 1:\n        shlN = 0\n    elif N < 16:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 4\n    GY = _ceil_div(P, 2)\n    GX = _ceil_div(Q, 2)\n    if shlN > 1 or GX >= 32:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (1, 5, 0, 0, 15, 0, 0), 1: (1, 4, 0, 0, 14, 1, 1), 2: (1, 3, 0, 0, 12, 2, 3), 3: (1, 2, 0, 0, 8, 3, 7), 4: (1, 1, 0, 0, 0, 0, 15)}.get(shlN)\n    elif shlN > 0 or GX >= 16:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (2, 4, 8, 3, 7, 0, 0), 1: (2, 3, 8, 3, 6, 1, 1)}.get(shlN)\n    else:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (3, 3, 12, 2, 3, 0, 0)}.get(shlN)\n    blkN = 1 << shlN\n    blkY = 1 << shlY\n    blkX = 1 << shlX\n    gridC = _ceil_div(C, 32)\n    GC = _ceil_div(gridC * 32, 16)\n    GYS = _ceil_div(P, blkY)\n    GXS = _ceil_div(Q, blkX)\n    GN = _ceil_div(N, blkN)\n    GYS2 = GYS // 2\n    GXS2 = GXS * 2\n    groupC = 2\n    groupN = 1 if GN & 1 else 2\n    shift_c = groupC - 1\n    shift_n = groupN - 1\n    X2cn = GXS2 * groupC * groupN\n    magic_X2cn = _magic64(X2cn)\n    self.lib = lib\n    self.dtype = dtype.str[1:]\n    self.dim = (gridC, GY, GX, N, 4, 4, 32)\n    self.size = int(np.prod(self.dim)) * dtype.itemsize\n    self.args = [(GYS * GXS * groupC * groupN, GN // groupN, GC // groupC), (256, 1, 1), None, None, None, C, H, W, N, pad_h, pad_w, GY, GX, GXS, GYS2, X2cn, magic_X2cn[0], magic_X2cn[1], shift_c, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GY * GX * N * 512, GX * N * 512, N * 512]",
            "def __init__(self, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if N == 1:\n        shlN = 0\n    elif N < 16:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 4\n    GY = _ceil_div(P, 2)\n    GX = _ceil_div(Q, 2)\n    if shlN > 1 or GX >= 32:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (1, 5, 0, 0, 15, 0, 0), 1: (1, 4, 0, 0, 14, 1, 1), 2: (1, 3, 0, 0, 12, 2, 3), 3: (1, 2, 0, 0, 8, 3, 7), 4: (1, 1, 0, 0, 0, 0, 15)}.get(shlN)\n    elif shlN > 0 or GX >= 16:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (2, 4, 8, 3, 7, 0, 0), 1: (2, 3, 8, 3, 6, 1, 1)}.get(shlN)\n    else:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (3, 3, 12, 2, 3, 0, 0)}.get(shlN)\n    blkN = 1 << shlN\n    blkY = 1 << shlY\n    blkX = 1 << shlX\n    gridC = _ceil_div(C, 32)\n    GC = _ceil_div(gridC * 32, 16)\n    GYS = _ceil_div(P, blkY)\n    GXS = _ceil_div(Q, blkX)\n    GN = _ceil_div(N, blkN)\n    GYS2 = GYS // 2\n    GXS2 = GXS * 2\n    groupC = 2\n    groupN = 1 if GN & 1 else 2\n    shift_c = groupC - 1\n    shift_n = groupN - 1\n    X2cn = GXS2 * groupC * groupN\n    magic_X2cn = _magic64(X2cn)\n    self.lib = lib\n    self.dtype = dtype.str[1:]\n    self.dim = (gridC, GY, GX, N, 4, 4, 32)\n    self.size = int(np.prod(self.dim)) * dtype.itemsize\n    self.args = [(GYS * GXS * groupC * groupN, GN // groupN, GC // groupC), (256, 1, 1), None, None, None, C, H, W, N, pad_h, pad_w, GY, GX, GXS, GYS2, X2cn, magic_X2cn[0], magic_X2cn[1], shift_c, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GY * GX * N * 512, GX * N * 512, N * 512]",
            "def __init__(self, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if N == 1:\n        shlN = 0\n    elif N < 16:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 4\n    GY = _ceil_div(P, 2)\n    GX = _ceil_div(Q, 2)\n    if shlN > 1 or GX >= 32:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (1, 5, 0, 0, 15, 0, 0), 1: (1, 4, 0, 0, 14, 1, 1), 2: (1, 3, 0, 0, 12, 2, 3), 3: (1, 2, 0, 0, 8, 3, 7), 4: (1, 1, 0, 0, 0, 0, 15)}.get(shlN)\n    elif shlN > 0 or GX >= 16:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (2, 4, 8, 3, 7, 0, 0), 1: (2, 3, 8, 3, 6, 1, 1)}.get(shlN)\n    else:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (3, 3, 12, 2, 3, 0, 0)}.get(shlN)\n    blkN = 1 << shlN\n    blkY = 1 << shlY\n    blkX = 1 << shlX\n    gridC = _ceil_div(C, 32)\n    GC = _ceil_div(gridC * 32, 16)\n    GYS = _ceil_div(P, blkY)\n    GXS = _ceil_div(Q, blkX)\n    GN = _ceil_div(N, blkN)\n    GYS2 = GYS // 2\n    GXS2 = GXS * 2\n    groupC = 2\n    groupN = 1 if GN & 1 else 2\n    shift_c = groupC - 1\n    shift_n = groupN - 1\n    X2cn = GXS2 * groupC * groupN\n    magic_X2cn = _magic64(X2cn)\n    self.lib = lib\n    self.dtype = dtype.str[1:]\n    self.dim = (gridC, GY, GX, N, 4, 4, 32)\n    self.size = int(np.prod(self.dim)) * dtype.itemsize\n    self.args = [(GYS * GXS * groupC * groupN, GN // groupN, GC // groupC), (256, 1, 1), None, None, None, C, H, W, N, pad_h, pad_w, GY, GX, GXS, GYS2, X2cn, magic_X2cn[0], magic_X2cn[1], shift_c, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GY * GX * N * 512, GX * N * 512, N * 512]",
            "def __init__(self, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if N == 1:\n        shlN = 0\n    elif N < 16:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 4\n    GY = _ceil_div(P, 2)\n    GX = _ceil_div(Q, 2)\n    if shlN > 1 or GX >= 32:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (1, 5, 0, 0, 15, 0, 0), 1: (1, 4, 0, 0, 14, 1, 1), 2: (1, 3, 0, 0, 12, 2, 3), 3: (1, 2, 0, 0, 8, 3, 7), 4: (1, 1, 0, 0, 0, 0, 15)}.get(shlN)\n    elif shlN > 0 or GX >= 16:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (2, 4, 8, 3, 7, 0, 0), 1: (2, 3, 8, 3, 6, 1, 1)}.get(shlN)\n    else:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (3, 3, 12, 2, 3, 0, 0)}.get(shlN)\n    blkN = 1 << shlN\n    blkY = 1 << shlY\n    blkX = 1 << shlX\n    gridC = _ceil_div(C, 32)\n    GC = _ceil_div(gridC * 32, 16)\n    GYS = _ceil_div(P, blkY)\n    GXS = _ceil_div(Q, blkX)\n    GN = _ceil_div(N, blkN)\n    GYS2 = GYS // 2\n    GXS2 = GXS * 2\n    groupC = 2\n    groupN = 1 if GN & 1 else 2\n    shift_c = groupC - 1\n    shift_n = groupN - 1\n    X2cn = GXS2 * groupC * groupN\n    magic_X2cn = _magic64(X2cn)\n    self.lib = lib\n    self.dtype = dtype.str[1:]\n    self.dim = (gridC, GY, GX, N, 4, 4, 32)\n    self.size = int(np.prod(self.dim)) * dtype.itemsize\n    self.args = [(GYS * GXS * groupC * groupN, GN // groupN, GC // groupC), (256, 1, 1), None, None, None, C, H, W, N, pad_h, pad_w, GY, GX, GXS, GYS2, X2cn, magic_X2cn[0], magic_X2cn[1], shift_c, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GY * GX * N * 512, GX * N * 512, N * 512]",
            "def __init__(self, lib, dtype, N, C, K, H, W, P, Q, pad_h, pad_w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if N == 1:\n        shlN = 0\n    elif N < 16:\n        shlN = len(bin(N - 1)) - 2\n    else:\n        shlN = 4\n    GY = _ceil_div(P, 2)\n    GX = _ceil_div(Q, 2)\n    if shlN > 1 or GX >= 32:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (1, 5, 0, 0, 15, 0, 0), 1: (1, 4, 0, 0, 14, 1, 1), 2: (1, 3, 0, 0, 12, 2, 3), 3: (1, 2, 0, 0, 8, 3, 7), 4: (1, 1, 0, 0, 0, 0, 15)}.get(shlN)\n    elif shlN > 0 or GX >= 16:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (2, 4, 8, 3, 7, 0, 0), 1: (2, 3, 8, 3, 6, 1, 1)}.get(shlN)\n    else:\n        (shlY, shlX, maskY, shrY, maskX, shrX, maskN) = {0: (3, 3, 12, 2, 3, 0, 0)}.get(shlN)\n    blkN = 1 << shlN\n    blkY = 1 << shlY\n    blkX = 1 << shlX\n    gridC = _ceil_div(C, 32)\n    GC = _ceil_div(gridC * 32, 16)\n    GYS = _ceil_div(P, blkY)\n    GXS = _ceil_div(Q, blkX)\n    GN = _ceil_div(N, blkN)\n    GYS2 = GYS // 2\n    GXS2 = GXS * 2\n    groupC = 2\n    groupN = 1 if GN & 1 else 2\n    shift_c = groupC - 1\n    shift_n = groupN - 1\n    X2cn = GXS2 * groupC * groupN\n    magic_X2cn = _magic64(X2cn)\n    self.lib = lib\n    self.dtype = dtype.str[1:]\n    self.dim = (gridC, GY, GX, N, 4, 4, 32)\n    self.size = int(np.prod(self.dim)) * dtype.itemsize\n    self.args = [(GYS * GXS * groupC * groupN, GN // groupN, GC // groupC), (256, 1, 1), None, None, None, C, H, W, N, pad_h, pad_w, GY, GX, GXS, GYS2, X2cn, magic_X2cn[0], magic_X2cn[1], shift_c, shift_n, shlY, shlX, maskY, shrY, maskX, shrX, shlN, maskN, H * W * N, W * N, GY * GX * N * 512, GX * N * 512, N * 512]"
        ]
    },
    {
        "func_name": "bind_params",
        "original": "def bind_params(self, I):\n    self.data = self.lib.scratch_buffer_offset(self.size)\n    self.args[2:5] = (self.lib.stream, self.data, I.gpudata)\n    self.kernel = _get_update_image_3x3_2x2_kernel(self.dtype)\n    return self.data",
        "mutated": [
            "def bind_params(self, I):\n    if False:\n        i = 10\n    self.data = self.lib.scratch_buffer_offset(self.size)\n    self.args[2:5] = (self.lib.stream, self.data, I.gpudata)\n    self.kernel = _get_update_image_3x3_2x2_kernel(self.dtype)\n    return self.data",
            "def bind_params(self, I):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.data = self.lib.scratch_buffer_offset(self.size)\n    self.args[2:5] = (self.lib.stream, self.data, I.gpudata)\n    self.kernel = _get_update_image_3x3_2x2_kernel(self.dtype)\n    return self.data",
            "def bind_params(self, I):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.data = self.lib.scratch_buffer_offset(self.size)\n    self.args[2:5] = (self.lib.stream, self.data, I.gpudata)\n    self.kernel = _get_update_image_3x3_2x2_kernel(self.dtype)\n    return self.data",
            "def bind_params(self, I):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.data = self.lib.scratch_buffer_offset(self.size)\n    self.args[2:5] = (self.lib.stream, self.data, I.gpudata)\n    self.kernel = _get_update_image_3x3_2x2_kernel(self.dtype)\n    return self.data",
            "def bind_params(self, I):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.data = self.lib.scratch_buffer_offset(self.size)\n    self.args[2:5] = (self.lib.stream, self.data, I.gpudata)\n    self.kernel = _get_update_image_3x3_2x2_kernel(self.dtype)\n    return self.data"
        ]
    },
    {
        "func_name": "execute",
        "original": "def execute(self):\n    self.kernel.prepared_async_call(*self.args)",
        "mutated": [
            "def execute(self):\n    if False:\n        i = 10\n    self.kernel.prepared_async_call(*self.args)",
            "def execute(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.kernel.prepared_async_call(*self.args)",
            "def execute(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.kernel.prepared_async_call(*self.args)",
            "def execute(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.kernel.prepared_async_call(*self.args)",
            "def execute(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.kernel.prepared_async_call(*self.args)"
        ]
    },
    {
        "func_name": "unbind",
        "original": "def unbind(self):\n    self.kernel = None\n    self.args[2:5] = (None,) * 3",
        "mutated": [
            "def unbind(self):\n    if False:\n        i = 10\n    self.kernel = None\n    self.args[2:5] = (None,) * 3",
            "def unbind(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.kernel = None\n    self.args[2:5] = (None,) * 3",
            "def unbind(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.kernel = None\n    self.args[2:5] = (None,) * 3",
            "def unbind(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.kernel = None\n    self.args[2:5] = (None,) * 3",
            "def unbind(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.kernel = None\n    self.args[2:5] = (None,) * 3"
        ]
    },
    {
        "func_name": "_get_update_image_3x3_2x2_kernel",
        "original": "@context_dependent_memoize\ndef _get_update_image_3x3_2x2_kernel(dtype):\n    code = \"\\n%(common)s\\n\\n__global__ void update_image_3x3_2x2(\\n    %(type)s* Out, const %(type)s* In,\\n    int C, int Y, int X, int N, int pad_y, int pad_x,\\n    int GY, int GX, int GXS, int GYS2,\\n    int X2cn, int magic_X2cn, int shift_X2cn, int shift_c, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN512, int GXN512, int N512)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*16 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXcn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_C      = blockIdx.z;\\n\\n    // unpack y,x,c,n from blockIdx.x\\n    int gy2     = div64(blk_YXcn, magic_X2cn, shift_X2cn);\\n    int blk_Xcn = blk_YXcn - gy2*X2cn;\\n\\n    int shift_cn = shift_c + shift_n;\\n\\n    int gx2    = blk_Xcn >> shift_cn;\\n    int blk_cn = blk_Xcn - (gx2 << shift_cn);\\n\\n    int blk_c = blk_cn >> shift_n;\\n    int blk_n = blk_cn - (blk_c << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkC = (blk_C << shift_c) + blk_c;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    int ns = tid & 15;\\n    int cs = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 1) - pad_y;\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 1) - pad_x;\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int c  = (blkC << 4) + cs;\\n\\n    bool valid = c < C && n < N;\\n\\n    bool xin[4], yin[4];\\n    float I[4][4], T[4][4];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 4; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 4; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + x*N + offset);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        T[0][i] = I[0][i] - I[2][i];\\n        T[1][i] = I[1][i] + I[2][i];\\n        T[2][i] = I[2][i] - I[1][i];\\n        T[3][i] = I[3][i] - I[1][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        share[ns][cs + 16*(i*4 + 0)] = %(cvt_out)s(T[i][0] - T[i][2]);\\n        share[ns][cs + 16*(i*4 + 1)] = %(cvt_out)s(T[i][1] + T[i][2]);\\n        share[ns][cs + 16*(i*4 + 2)] = %(cvt_out)s(T[i][2] - T[i][1]);\\n        share[ns][cs + 16*(i*4 + 3)] = %(cvt_out)s(T[i][3] - T[i][1]);\\n    }\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-1)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-1)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (C32,GY,GX,N,c32)\\n        // where c32 is the 512 element transform data for 32 values of c\\n        // We group two blkC's to form each transform row\\n\\n        Out += (blkC >> 1)*GYGXN512 + gy*GXN512 + gx*N512 + n*512 + (blkC & 1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 16; i++)\\n            Out[32*i] = share[ns][cs + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_image_3x3_2x2')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
        "mutated": [
            "@context_dependent_memoize\ndef _get_update_image_3x3_2x2_kernel(dtype):\n    if False:\n        i = 10\n    code = \"\\n%(common)s\\n\\n__global__ void update_image_3x3_2x2(\\n    %(type)s* Out, const %(type)s* In,\\n    int C, int Y, int X, int N, int pad_y, int pad_x,\\n    int GY, int GX, int GXS, int GYS2,\\n    int X2cn, int magic_X2cn, int shift_X2cn, int shift_c, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN512, int GXN512, int N512)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*16 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXcn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_C      = blockIdx.z;\\n\\n    // unpack y,x,c,n from blockIdx.x\\n    int gy2     = div64(blk_YXcn, magic_X2cn, shift_X2cn);\\n    int blk_Xcn = blk_YXcn - gy2*X2cn;\\n\\n    int shift_cn = shift_c + shift_n;\\n\\n    int gx2    = blk_Xcn >> shift_cn;\\n    int blk_cn = blk_Xcn - (gx2 << shift_cn);\\n\\n    int blk_c = blk_cn >> shift_n;\\n    int blk_n = blk_cn - (blk_c << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkC = (blk_C << shift_c) + blk_c;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    int ns = tid & 15;\\n    int cs = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 1) - pad_y;\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 1) - pad_x;\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int c  = (blkC << 4) + cs;\\n\\n    bool valid = c < C && n < N;\\n\\n    bool xin[4], yin[4];\\n    float I[4][4], T[4][4];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 4; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 4; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + x*N + offset);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        T[0][i] = I[0][i] - I[2][i];\\n        T[1][i] = I[1][i] + I[2][i];\\n        T[2][i] = I[2][i] - I[1][i];\\n        T[3][i] = I[3][i] - I[1][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        share[ns][cs + 16*(i*4 + 0)] = %(cvt_out)s(T[i][0] - T[i][2]);\\n        share[ns][cs + 16*(i*4 + 1)] = %(cvt_out)s(T[i][1] + T[i][2]);\\n        share[ns][cs + 16*(i*4 + 2)] = %(cvt_out)s(T[i][2] - T[i][1]);\\n        share[ns][cs + 16*(i*4 + 3)] = %(cvt_out)s(T[i][3] - T[i][1]);\\n    }\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-1)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-1)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (C32,GY,GX,N,c32)\\n        // where c32 is the 512 element transform data for 32 values of c\\n        // We group two blkC's to form each transform row\\n\\n        Out += (blkC >> 1)*GYGXN512 + gy*GXN512 + gx*N512 + n*512 + (blkC & 1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 16; i++)\\n            Out[32*i] = share[ns][cs + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_image_3x3_2x2')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_update_image_3x3_2x2_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    code = \"\\n%(common)s\\n\\n__global__ void update_image_3x3_2x2(\\n    %(type)s* Out, const %(type)s* In,\\n    int C, int Y, int X, int N, int pad_y, int pad_x,\\n    int GY, int GX, int GXS, int GYS2,\\n    int X2cn, int magic_X2cn, int shift_X2cn, int shift_c, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN512, int GXN512, int N512)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*16 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXcn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_C      = blockIdx.z;\\n\\n    // unpack y,x,c,n from blockIdx.x\\n    int gy2     = div64(blk_YXcn, magic_X2cn, shift_X2cn);\\n    int blk_Xcn = blk_YXcn - gy2*X2cn;\\n\\n    int shift_cn = shift_c + shift_n;\\n\\n    int gx2    = blk_Xcn >> shift_cn;\\n    int blk_cn = blk_Xcn - (gx2 << shift_cn);\\n\\n    int blk_c = blk_cn >> shift_n;\\n    int blk_n = blk_cn - (blk_c << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkC = (blk_C << shift_c) + blk_c;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    int ns = tid & 15;\\n    int cs = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 1) - pad_y;\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 1) - pad_x;\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int c  = (blkC << 4) + cs;\\n\\n    bool valid = c < C && n < N;\\n\\n    bool xin[4], yin[4];\\n    float I[4][4], T[4][4];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 4; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 4; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + x*N + offset);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        T[0][i] = I[0][i] - I[2][i];\\n        T[1][i] = I[1][i] + I[2][i];\\n        T[2][i] = I[2][i] - I[1][i];\\n        T[3][i] = I[3][i] - I[1][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        share[ns][cs + 16*(i*4 + 0)] = %(cvt_out)s(T[i][0] - T[i][2]);\\n        share[ns][cs + 16*(i*4 + 1)] = %(cvt_out)s(T[i][1] + T[i][2]);\\n        share[ns][cs + 16*(i*4 + 2)] = %(cvt_out)s(T[i][2] - T[i][1]);\\n        share[ns][cs + 16*(i*4 + 3)] = %(cvt_out)s(T[i][3] - T[i][1]);\\n    }\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-1)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-1)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (C32,GY,GX,N,c32)\\n        // where c32 is the 512 element transform data for 32 values of c\\n        // We group two blkC's to form each transform row\\n\\n        Out += (blkC >> 1)*GYGXN512 + gy*GXN512 + gx*N512 + n*512 + (blkC & 1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 16; i++)\\n            Out[32*i] = share[ns][cs + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_image_3x3_2x2')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_update_image_3x3_2x2_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    code = \"\\n%(common)s\\n\\n__global__ void update_image_3x3_2x2(\\n    %(type)s* Out, const %(type)s* In,\\n    int C, int Y, int X, int N, int pad_y, int pad_x,\\n    int GY, int GX, int GXS, int GYS2,\\n    int X2cn, int magic_X2cn, int shift_X2cn, int shift_c, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN512, int GXN512, int N512)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*16 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXcn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_C      = blockIdx.z;\\n\\n    // unpack y,x,c,n from blockIdx.x\\n    int gy2     = div64(blk_YXcn, magic_X2cn, shift_X2cn);\\n    int blk_Xcn = blk_YXcn - gy2*X2cn;\\n\\n    int shift_cn = shift_c + shift_n;\\n\\n    int gx2    = blk_Xcn >> shift_cn;\\n    int blk_cn = blk_Xcn - (gx2 << shift_cn);\\n\\n    int blk_c = blk_cn >> shift_n;\\n    int blk_n = blk_cn - (blk_c << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkC = (blk_C << shift_c) + blk_c;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    int ns = tid & 15;\\n    int cs = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 1) - pad_y;\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 1) - pad_x;\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int c  = (blkC << 4) + cs;\\n\\n    bool valid = c < C && n < N;\\n\\n    bool xin[4], yin[4];\\n    float I[4][4], T[4][4];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 4; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 4; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + x*N + offset);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        T[0][i] = I[0][i] - I[2][i];\\n        T[1][i] = I[1][i] + I[2][i];\\n        T[2][i] = I[2][i] - I[1][i];\\n        T[3][i] = I[3][i] - I[1][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        share[ns][cs + 16*(i*4 + 0)] = %(cvt_out)s(T[i][0] - T[i][2]);\\n        share[ns][cs + 16*(i*4 + 1)] = %(cvt_out)s(T[i][1] + T[i][2]);\\n        share[ns][cs + 16*(i*4 + 2)] = %(cvt_out)s(T[i][2] - T[i][1]);\\n        share[ns][cs + 16*(i*4 + 3)] = %(cvt_out)s(T[i][3] - T[i][1]);\\n    }\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-1)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-1)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (C32,GY,GX,N,c32)\\n        // where c32 is the 512 element transform data for 32 values of c\\n        // We group two blkC's to form each transform row\\n\\n        Out += (blkC >> 1)*GYGXN512 + gy*GXN512 + gx*N512 + n*512 + (blkC & 1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 16; i++)\\n            Out[32*i] = share[ns][cs + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_image_3x3_2x2')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_update_image_3x3_2x2_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    code = \"\\n%(common)s\\n\\n__global__ void update_image_3x3_2x2(\\n    %(type)s* Out, const %(type)s* In,\\n    int C, int Y, int X, int N, int pad_y, int pad_x,\\n    int GY, int GX, int GXS, int GYS2,\\n    int X2cn, int magic_X2cn, int shift_X2cn, int shift_c, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN512, int GXN512, int N512)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*16 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXcn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_C      = blockIdx.z;\\n\\n    // unpack y,x,c,n from blockIdx.x\\n    int gy2     = div64(blk_YXcn, magic_X2cn, shift_X2cn);\\n    int blk_Xcn = blk_YXcn - gy2*X2cn;\\n\\n    int shift_cn = shift_c + shift_n;\\n\\n    int gx2    = blk_Xcn >> shift_cn;\\n    int blk_cn = blk_Xcn - (gx2 << shift_cn);\\n\\n    int blk_c = blk_cn >> shift_n;\\n    int blk_n = blk_cn - (blk_c << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkC = (blk_C << shift_c) + blk_c;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    int ns = tid & 15;\\n    int cs = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 1) - pad_y;\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 1) - pad_x;\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int c  = (blkC << 4) + cs;\\n\\n    bool valid = c < C && n < N;\\n\\n    bool xin[4], yin[4];\\n    float I[4][4], T[4][4];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 4; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 4; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + x*N + offset);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        T[0][i] = I[0][i] - I[2][i];\\n        T[1][i] = I[1][i] + I[2][i];\\n        T[2][i] = I[2][i] - I[1][i];\\n        T[3][i] = I[3][i] - I[1][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        share[ns][cs + 16*(i*4 + 0)] = %(cvt_out)s(T[i][0] - T[i][2]);\\n        share[ns][cs + 16*(i*4 + 1)] = %(cvt_out)s(T[i][1] + T[i][2]);\\n        share[ns][cs + 16*(i*4 + 2)] = %(cvt_out)s(T[i][2] - T[i][1]);\\n        share[ns][cs + 16*(i*4 + 3)] = %(cvt_out)s(T[i][3] - T[i][1]);\\n    }\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-1)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-1)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (C32,GY,GX,N,c32)\\n        // where c32 is the 512 element transform data for 32 values of c\\n        // We group two blkC's to form each transform row\\n\\n        Out += (blkC >> 1)*GYGXN512 + gy*GXN512 + gx*N512 + n*512 + (blkC & 1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 16; i++)\\n            Out[32*i] = share[ns][cs + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_image_3x3_2x2')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_update_image_3x3_2x2_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    code = \"\\n%(common)s\\n\\n__global__ void update_image_3x3_2x2(\\n    %(type)s* Out, const %(type)s* In,\\n    int C, int Y, int X, int N, int pad_y, int pad_x,\\n    int GY, int GX, int GXS, int GYS2,\\n    int X2cn, int magic_X2cn, int shift_X2cn, int shift_c, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN512, int GXN512, int N512)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*16 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXcn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_C      = blockIdx.z;\\n\\n    // unpack y,x,c,n from blockIdx.x\\n    int gy2     = div64(blk_YXcn, magic_X2cn, shift_X2cn);\\n    int blk_Xcn = blk_YXcn - gy2*X2cn;\\n\\n    int shift_cn = shift_c + shift_n;\\n\\n    int gx2    = blk_Xcn >> shift_cn;\\n    int blk_cn = blk_Xcn - (gx2 << shift_cn);\\n\\n    int blk_c = blk_cn >> shift_n;\\n    int blk_n = blk_cn - (blk_c << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkC = (blk_C << shift_c) + blk_c;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    int ns = tid & 15;\\n    int cs = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 1) - pad_y;\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 1) - pad_x;\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int c  = (blkC << 4) + cs;\\n\\n    bool valid = c < C && n < N;\\n\\n    bool xin[4], yin[4];\\n    float I[4][4], T[4][4];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 4; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 4; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + x*N + offset);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        T[0][i] = I[0][i] - I[2][i];\\n        T[1][i] = I[1][i] + I[2][i];\\n        T[2][i] = I[2][i] - I[1][i];\\n        T[3][i] = I[3][i] - I[1][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        share[ns][cs + 16*(i*4 + 0)] = %(cvt_out)s(T[i][0] - T[i][2]);\\n        share[ns][cs + 16*(i*4 + 1)] = %(cvt_out)s(T[i][1] + T[i][2]);\\n        share[ns][cs + 16*(i*4 + 2)] = %(cvt_out)s(T[i][2] - T[i][1]);\\n        share[ns][cs + 16*(i*4 + 3)] = %(cvt_out)s(T[i][3] - T[i][1]);\\n    }\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-1)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-1)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (C32,GY,GX,N,c32)\\n        // where c32 is the 512 element transform data for 32 values of c\\n        // We group two blkC's to form each transform row\\n\\n        Out += (blkC >> 1)*GYGXN512 + gy*GXN512 + gx*N512 + n*512 + (blkC & 1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 16; i++)\\n            Out[32*i] = share[ns][cs + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_image_3x3_2x2')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel"
        ]
    },
    {
        "func_name": "_get_xprop_image_4x4_3x3_kernel",
        "original": "@context_dependent_memoize\ndef _get_xprop_image_4x4_3x3_kernel(dtype):\n    code = '\\n%(common)s\\n\\n__global__ void xprop_image_4x4_3x3(\\n    %(type)s* Out, const %(type)s* In,\\n    int Y, int X, int N, int pad_y, int pad_x,\\n    int GXS, int GYS2, int GXS2, int magic_GXS2, int shift_GXS2,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYS_GXS_C_1152, int GXS_C_1152, int C_1152)\\n{\\n    int tid   = threadIdx.x;\\n    int blkN  = gridDim.x - blockIdx.x - 1;\\n    int blkYX = gridDim.y - blockIdx.y - 1;\\n    int c     = gridDim.z - blockIdx.z - 1;\\n\\n    // unpack y,x from blockIdx.x\\n    int gy2 = div64(blkYX, magic_GXS2, shift_GXS2);\\n    int gx2 = blkYX - gy2*GXS2;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((tid & maskY) >> shrY) << 2) - pad_y;\\n    int x0 = (gx << shlX) + (((tid & maskX) >> shrX) << 2) - pad_x;\\n    int n  = (blkN << shlN) + (tid & maskN);\\n\\n    Out += blkN*GYS_GXS_C_1152 + gy*GXS_C_1152 + gx*C_1152 + c*1152 + tid;\\n\\n    bool valid = n < N;\\n\\n    bool xin[6], yin[6];\\n    float I[6][6];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 6; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 6; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + x*N + offset);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    float f1_1025 = 1.1025f;\\n    float f2_74   = 2.7400f;\\n    float f0_70   = 0.7000f;\\n    float f0_49   = 0.4900f;\\n    float T[6][6];\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(I[2][i], -2.25f, I[4][i]);\\n        float t1 = __fmaf_rn(I[1][i], -2.25f, I[3][i]);\\n        float t2 = __fmaf_rn(I[2][i], -f0_49, I[4][i]);\\n        float t3 = __fmaf_rn(I[1][i], -f0_49, I[3][i]);\\n        float t4 = __fmaf_rn(I[2][i], -f2_74, I[4][i]);\\n        float t5 = __fmaf_rn(I[3][i], -f2_74, I[5][i]);\\n\\n        T[0][i] = __fmaf_rn(I[0][i], f1_1025, t4);\\n        T[1][i] = __fmaf_rn(t1,  f0_70, t0);\\n        T[2][i] = __fmaf_rn(t1, -f0_70, t0);\\n        T[3][i] = __fmaf_rn(t3,  1.5f,  t2);\\n        T[4][i] = __fmaf_rn(t3, -1.5f,  t2);\\n        T[5][i] = __fmaf_rn(I[1][i], f1_1025, t5);\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(T[i][2], -2.25f, T[i][4]);\\n        float t1 = __fmaf_rn(T[i][1], -2.25f, T[i][3]);\\n        float t2 = __fmaf_rn(T[i][2], -f0_49, T[i][4]);\\n        float t3 = __fmaf_rn(T[i][1], -f0_49, T[i][3]);\\n        float t4 = __fmaf_rn(T[i][2], -f2_74, T[i][4]);\\n        float t5 = __fmaf_rn(T[i][3], -f2_74, T[i][5]);\\n\\n        Out[32*(i*6 + 0)] = %(cvt_out)s(__fmaf_rn(T[i][0], f1_1025, t4));\\n        Out[32*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(t1,  f0_70, t0));\\n        Out[32*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(t1, -f0_70, t0));\\n        Out[32*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(t3,  1.5f, t2));\\n        Out[32*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(t3, -1.5f, t2));\\n        Out[32*(i*6 + 5)] = %(cvt_out)s(__fmaf_rn(T[i][1], f1_1025, t5));\\n    }\\n}\\n'\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'type4': _ew_types[dtype]['type4'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('xprop_image_4x4_3x3')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
        "mutated": [
            "@context_dependent_memoize\ndef _get_xprop_image_4x4_3x3_kernel(dtype):\n    if False:\n        i = 10\n    code = '\\n%(common)s\\n\\n__global__ void xprop_image_4x4_3x3(\\n    %(type)s* Out, const %(type)s* In,\\n    int Y, int X, int N, int pad_y, int pad_x,\\n    int GXS, int GYS2, int GXS2, int magic_GXS2, int shift_GXS2,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYS_GXS_C_1152, int GXS_C_1152, int C_1152)\\n{\\n    int tid   = threadIdx.x;\\n    int blkN  = gridDim.x - blockIdx.x - 1;\\n    int blkYX = gridDim.y - blockIdx.y - 1;\\n    int c     = gridDim.z - blockIdx.z - 1;\\n\\n    // unpack y,x from blockIdx.x\\n    int gy2 = div64(blkYX, magic_GXS2, shift_GXS2);\\n    int gx2 = blkYX - gy2*GXS2;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((tid & maskY) >> shrY) << 2) - pad_y;\\n    int x0 = (gx << shlX) + (((tid & maskX) >> shrX) << 2) - pad_x;\\n    int n  = (blkN << shlN) + (tid & maskN);\\n\\n    Out += blkN*GYS_GXS_C_1152 + gy*GXS_C_1152 + gx*C_1152 + c*1152 + tid;\\n\\n    bool valid = n < N;\\n\\n    bool xin[6], yin[6];\\n    float I[6][6];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 6; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 6; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + x*N + offset);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    float f1_1025 = 1.1025f;\\n    float f2_74   = 2.7400f;\\n    float f0_70   = 0.7000f;\\n    float f0_49   = 0.4900f;\\n    float T[6][6];\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(I[2][i], -2.25f, I[4][i]);\\n        float t1 = __fmaf_rn(I[1][i], -2.25f, I[3][i]);\\n        float t2 = __fmaf_rn(I[2][i], -f0_49, I[4][i]);\\n        float t3 = __fmaf_rn(I[1][i], -f0_49, I[3][i]);\\n        float t4 = __fmaf_rn(I[2][i], -f2_74, I[4][i]);\\n        float t5 = __fmaf_rn(I[3][i], -f2_74, I[5][i]);\\n\\n        T[0][i] = __fmaf_rn(I[0][i], f1_1025, t4);\\n        T[1][i] = __fmaf_rn(t1,  f0_70, t0);\\n        T[2][i] = __fmaf_rn(t1, -f0_70, t0);\\n        T[3][i] = __fmaf_rn(t3,  1.5f,  t2);\\n        T[4][i] = __fmaf_rn(t3, -1.5f,  t2);\\n        T[5][i] = __fmaf_rn(I[1][i], f1_1025, t5);\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(T[i][2], -2.25f, T[i][4]);\\n        float t1 = __fmaf_rn(T[i][1], -2.25f, T[i][3]);\\n        float t2 = __fmaf_rn(T[i][2], -f0_49, T[i][4]);\\n        float t3 = __fmaf_rn(T[i][1], -f0_49, T[i][3]);\\n        float t4 = __fmaf_rn(T[i][2], -f2_74, T[i][4]);\\n        float t5 = __fmaf_rn(T[i][3], -f2_74, T[i][5]);\\n\\n        Out[32*(i*6 + 0)] = %(cvt_out)s(__fmaf_rn(T[i][0], f1_1025, t4));\\n        Out[32*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(t1,  f0_70, t0));\\n        Out[32*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(t1, -f0_70, t0));\\n        Out[32*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(t3,  1.5f, t2));\\n        Out[32*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(t3, -1.5f, t2));\\n        Out[32*(i*6 + 5)] = %(cvt_out)s(__fmaf_rn(T[i][1], f1_1025, t5));\\n    }\\n}\\n'\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'type4': _ew_types[dtype]['type4'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('xprop_image_4x4_3x3')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_xprop_image_4x4_3x3_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    code = '\\n%(common)s\\n\\n__global__ void xprop_image_4x4_3x3(\\n    %(type)s* Out, const %(type)s* In,\\n    int Y, int X, int N, int pad_y, int pad_x,\\n    int GXS, int GYS2, int GXS2, int magic_GXS2, int shift_GXS2,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYS_GXS_C_1152, int GXS_C_1152, int C_1152)\\n{\\n    int tid   = threadIdx.x;\\n    int blkN  = gridDim.x - blockIdx.x - 1;\\n    int blkYX = gridDim.y - blockIdx.y - 1;\\n    int c     = gridDim.z - blockIdx.z - 1;\\n\\n    // unpack y,x from blockIdx.x\\n    int gy2 = div64(blkYX, magic_GXS2, shift_GXS2);\\n    int gx2 = blkYX - gy2*GXS2;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((tid & maskY) >> shrY) << 2) - pad_y;\\n    int x0 = (gx << shlX) + (((tid & maskX) >> shrX) << 2) - pad_x;\\n    int n  = (blkN << shlN) + (tid & maskN);\\n\\n    Out += blkN*GYS_GXS_C_1152 + gy*GXS_C_1152 + gx*C_1152 + c*1152 + tid;\\n\\n    bool valid = n < N;\\n\\n    bool xin[6], yin[6];\\n    float I[6][6];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 6; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 6; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + x*N + offset);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    float f1_1025 = 1.1025f;\\n    float f2_74   = 2.7400f;\\n    float f0_70   = 0.7000f;\\n    float f0_49   = 0.4900f;\\n    float T[6][6];\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(I[2][i], -2.25f, I[4][i]);\\n        float t1 = __fmaf_rn(I[1][i], -2.25f, I[3][i]);\\n        float t2 = __fmaf_rn(I[2][i], -f0_49, I[4][i]);\\n        float t3 = __fmaf_rn(I[1][i], -f0_49, I[3][i]);\\n        float t4 = __fmaf_rn(I[2][i], -f2_74, I[4][i]);\\n        float t5 = __fmaf_rn(I[3][i], -f2_74, I[5][i]);\\n\\n        T[0][i] = __fmaf_rn(I[0][i], f1_1025, t4);\\n        T[1][i] = __fmaf_rn(t1,  f0_70, t0);\\n        T[2][i] = __fmaf_rn(t1, -f0_70, t0);\\n        T[3][i] = __fmaf_rn(t3,  1.5f,  t2);\\n        T[4][i] = __fmaf_rn(t3, -1.5f,  t2);\\n        T[5][i] = __fmaf_rn(I[1][i], f1_1025, t5);\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(T[i][2], -2.25f, T[i][4]);\\n        float t1 = __fmaf_rn(T[i][1], -2.25f, T[i][3]);\\n        float t2 = __fmaf_rn(T[i][2], -f0_49, T[i][4]);\\n        float t3 = __fmaf_rn(T[i][1], -f0_49, T[i][3]);\\n        float t4 = __fmaf_rn(T[i][2], -f2_74, T[i][4]);\\n        float t5 = __fmaf_rn(T[i][3], -f2_74, T[i][5]);\\n\\n        Out[32*(i*6 + 0)] = %(cvt_out)s(__fmaf_rn(T[i][0], f1_1025, t4));\\n        Out[32*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(t1,  f0_70, t0));\\n        Out[32*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(t1, -f0_70, t0));\\n        Out[32*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(t3,  1.5f, t2));\\n        Out[32*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(t3, -1.5f, t2));\\n        Out[32*(i*6 + 5)] = %(cvt_out)s(__fmaf_rn(T[i][1], f1_1025, t5));\\n    }\\n}\\n'\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'type4': _ew_types[dtype]['type4'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('xprop_image_4x4_3x3')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_xprop_image_4x4_3x3_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    code = '\\n%(common)s\\n\\n__global__ void xprop_image_4x4_3x3(\\n    %(type)s* Out, const %(type)s* In,\\n    int Y, int X, int N, int pad_y, int pad_x,\\n    int GXS, int GYS2, int GXS2, int magic_GXS2, int shift_GXS2,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYS_GXS_C_1152, int GXS_C_1152, int C_1152)\\n{\\n    int tid   = threadIdx.x;\\n    int blkN  = gridDim.x - blockIdx.x - 1;\\n    int blkYX = gridDim.y - blockIdx.y - 1;\\n    int c     = gridDim.z - blockIdx.z - 1;\\n\\n    // unpack y,x from blockIdx.x\\n    int gy2 = div64(blkYX, magic_GXS2, shift_GXS2);\\n    int gx2 = blkYX - gy2*GXS2;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((tid & maskY) >> shrY) << 2) - pad_y;\\n    int x0 = (gx << shlX) + (((tid & maskX) >> shrX) << 2) - pad_x;\\n    int n  = (blkN << shlN) + (tid & maskN);\\n\\n    Out += blkN*GYS_GXS_C_1152 + gy*GXS_C_1152 + gx*C_1152 + c*1152 + tid;\\n\\n    bool valid = n < N;\\n\\n    bool xin[6], yin[6];\\n    float I[6][6];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 6; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 6; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + x*N + offset);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    float f1_1025 = 1.1025f;\\n    float f2_74   = 2.7400f;\\n    float f0_70   = 0.7000f;\\n    float f0_49   = 0.4900f;\\n    float T[6][6];\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(I[2][i], -2.25f, I[4][i]);\\n        float t1 = __fmaf_rn(I[1][i], -2.25f, I[3][i]);\\n        float t2 = __fmaf_rn(I[2][i], -f0_49, I[4][i]);\\n        float t3 = __fmaf_rn(I[1][i], -f0_49, I[3][i]);\\n        float t4 = __fmaf_rn(I[2][i], -f2_74, I[4][i]);\\n        float t5 = __fmaf_rn(I[3][i], -f2_74, I[5][i]);\\n\\n        T[0][i] = __fmaf_rn(I[0][i], f1_1025, t4);\\n        T[1][i] = __fmaf_rn(t1,  f0_70, t0);\\n        T[2][i] = __fmaf_rn(t1, -f0_70, t0);\\n        T[3][i] = __fmaf_rn(t3,  1.5f,  t2);\\n        T[4][i] = __fmaf_rn(t3, -1.5f,  t2);\\n        T[5][i] = __fmaf_rn(I[1][i], f1_1025, t5);\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(T[i][2], -2.25f, T[i][4]);\\n        float t1 = __fmaf_rn(T[i][1], -2.25f, T[i][3]);\\n        float t2 = __fmaf_rn(T[i][2], -f0_49, T[i][4]);\\n        float t3 = __fmaf_rn(T[i][1], -f0_49, T[i][3]);\\n        float t4 = __fmaf_rn(T[i][2], -f2_74, T[i][4]);\\n        float t5 = __fmaf_rn(T[i][3], -f2_74, T[i][5]);\\n\\n        Out[32*(i*6 + 0)] = %(cvt_out)s(__fmaf_rn(T[i][0], f1_1025, t4));\\n        Out[32*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(t1,  f0_70, t0));\\n        Out[32*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(t1, -f0_70, t0));\\n        Out[32*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(t3,  1.5f, t2));\\n        Out[32*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(t3, -1.5f, t2));\\n        Out[32*(i*6 + 5)] = %(cvt_out)s(__fmaf_rn(T[i][1], f1_1025, t5));\\n    }\\n}\\n'\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'type4': _ew_types[dtype]['type4'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('xprop_image_4x4_3x3')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_xprop_image_4x4_3x3_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    code = '\\n%(common)s\\n\\n__global__ void xprop_image_4x4_3x3(\\n    %(type)s* Out, const %(type)s* In,\\n    int Y, int X, int N, int pad_y, int pad_x,\\n    int GXS, int GYS2, int GXS2, int magic_GXS2, int shift_GXS2,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYS_GXS_C_1152, int GXS_C_1152, int C_1152)\\n{\\n    int tid   = threadIdx.x;\\n    int blkN  = gridDim.x - blockIdx.x - 1;\\n    int blkYX = gridDim.y - blockIdx.y - 1;\\n    int c     = gridDim.z - blockIdx.z - 1;\\n\\n    // unpack y,x from blockIdx.x\\n    int gy2 = div64(blkYX, magic_GXS2, shift_GXS2);\\n    int gx2 = blkYX - gy2*GXS2;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((tid & maskY) >> shrY) << 2) - pad_y;\\n    int x0 = (gx << shlX) + (((tid & maskX) >> shrX) << 2) - pad_x;\\n    int n  = (blkN << shlN) + (tid & maskN);\\n\\n    Out += blkN*GYS_GXS_C_1152 + gy*GXS_C_1152 + gx*C_1152 + c*1152 + tid;\\n\\n    bool valid = n < N;\\n\\n    bool xin[6], yin[6];\\n    float I[6][6];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 6; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 6; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + x*N + offset);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    float f1_1025 = 1.1025f;\\n    float f2_74   = 2.7400f;\\n    float f0_70   = 0.7000f;\\n    float f0_49   = 0.4900f;\\n    float T[6][6];\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(I[2][i], -2.25f, I[4][i]);\\n        float t1 = __fmaf_rn(I[1][i], -2.25f, I[3][i]);\\n        float t2 = __fmaf_rn(I[2][i], -f0_49, I[4][i]);\\n        float t3 = __fmaf_rn(I[1][i], -f0_49, I[3][i]);\\n        float t4 = __fmaf_rn(I[2][i], -f2_74, I[4][i]);\\n        float t5 = __fmaf_rn(I[3][i], -f2_74, I[5][i]);\\n\\n        T[0][i] = __fmaf_rn(I[0][i], f1_1025, t4);\\n        T[1][i] = __fmaf_rn(t1,  f0_70, t0);\\n        T[2][i] = __fmaf_rn(t1, -f0_70, t0);\\n        T[3][i] = __fmaf_rn(t3,  1.5f,  t2);\\n        T[4][i] = __fmaf_rn(t3, -1.5f,  t2);\\n        T[5][i] = __fmaf_rn(I[1][i], f1_1025, t5);\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(T[i][2], -2.25f, T[i][4]);\\n        float t1 = __fmaf_rn(T[i][1], -2.25f, T[i][3]);\\n        float t2 = __fmaf_rn(T[i][2], -f0_49, T[i][4]);\\n        float t3 = __fmaf_rn(T[i][1], -f0_49, T[i][3]);\\n        float t4 = __fmaf_rn(T[i][2], -f2_74, T[i][4]);\\n        float t5 = __fmaf_rn(T[i][3], -f2_74, T[i][5]);\\n\\n        Out[32*(i*6 + 0)] = %(cvt_out)s(__fmaf_rn(T[i][0], f1_1025, t4));\\n        Out[32*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(t1,  f0_70, t0));\\n        Out[32*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(t1, -f0_70, t0));\\n        Out[32*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(t3,  1.5f, t2));\\n        Out[32*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(t3, -1.5f, t2));\\n        Out[32*(i*6 + 5)] = %(cvt_out)s(__fmaf_rn(T[i][1], f1_1025, t5));\\n    }\\n}\\n'\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'type4': _ew_types[dtype]['type4'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('xprop_image_4x4_3x3')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_xprop_image_4x4_3x3_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    code = '\\n%(common)s\\n\\n__global__ void xprop_image_4x4_3x3(\\n    %(type)s* Out, const %(type)s* In,\\n    int Y, int X, int N, int pad_y, int pad_x,\\n    int GXS, int GYS2, int GXS2, int magic_GXS2, int shift_GXS2,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYS_GXS_C_1152, int GXS_C_1152, int C_1152)\\n{\\n    int tid   = threadIdx.x;\\n    int blkN  = gridDim.x - blockIdx.x - 1;\\n    int blkYX = gridDim.y - blockIdx.y - 1;\\n    int c     = gridDim.z - blockIdx.z - 1;\\n\\n    // unpack y,x from blockIdx.x\\n    int gy2 = div64(blkYX, magic_GXS2, shift_GXS2);\\n    int gx2 = blkYX - gy2*GXS2;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((tid & maskY) >> shrY) << 2) - pad_y;\\n    int x0 = (gx << shlX) + (((tid & maskX) >> shrX) << 2) - pad_x;\\n    int n  = (blkN << shlN) + (tid & maskN);\\n\\n    Out += blkN*GYS_GXS_C_1152 + gy*GXS_C_1152 + gx*C_1152 + c*1152 + tid;\\n\\n    bool valid = n < N;\\n\\n    bool xin[6], yin[6];\\n    float I[6][6];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 6; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 6; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + x*N + offset);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    float f1_1025 = 1.1025f;\\n    float f2_74   = 2.7400f;\\n    float f0_70   = 0.7000f;\\n    float f0_49   = 0.4900f;\\n    float T[6][6];\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(I[2][i], -2.25f, I[4][i]);\\n        float t1 = __fmaf_rn(I[1][i], -2.25f, I[3][i]);\\n        float t2 = __fmaf_rn(I[2][i], -f0_49, I[4][i]);\\n        float t3 = __fmaf_rn(I[1][i], -f0_49, I[3][i]);\\n        float t4 = __fmaf_rn(I[2][i], -f2_74, I[4][i]);\\n        float t5 = __fmaf_rn(I[3][i], -f2_74, I[5][i]);\\n\\n        T[0][i] = __fmaf_rn(I[0][i], f1_1025, t4);\\n        T[1][i] = __fmaf_rn(t1,  f0_70, t0);\\n        T[2][i] = __fmaf_rn(t1, -f0_70, t0);\\n        T[3][i] = __fmaf_rn(t3,  1.5f,  t2);\\n        T[4][i] = __fmaf_rn(t3, -1.5f,  t2);\\n        T[5][i] = __fmaf_rn(I[1][i], f1_1025, t5);\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(T[i][2], -2.25f, T[i][4]);\\n        float t1 = __fmaf_rn(T[i][1], -2.25f, T[i][3]);\\n        float t2 = __fmaf_rn(T[i][2], -f0_49, T[i][4]);\\n        float t3 = __fmaf_rn(T[i][1], -f0_49, T[i][3]);\\n        float t4 = __fmaf_rn(T[i][2], -f2_74, T[i][4]);\\n        float t5 = __fmaf_rn(T[i][3], -f2_74, T[i][5]);\\n\\n        Out[32*(i*6 + 0)] = %(cvt_out)s(__fmaf_rn(T[i][0], f1_1025, t4));\\n        Out[32*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(t1,  f0_70, t0));\\n        Out[32*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(t1, -f0_70, t0));\\n        Out[32*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(t3,  1.5f, t2));\\n        Out[32*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(t3, -1.5f, t2));\\n        Out[32*(i*6 + 5)] = %(cvt_out)s(__fmaf_rn(T[i][1], f1_1025, t5));\\n    }\\n}\\n'\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'type4': _ew_types[dtype]['type4'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('xprop_image_4x4_3x3')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel"
        ]
    },
    {
        "func_name": "_get_update_image_3x3_4x4_kernel",
        "original": "@context_dependent_memoize\ndef _get_update_image_3x3_4x4_kernel(dtype):\n    code = \"\\n%(common)s\\n\\n__global__ void update_image_3x3_4x4(\\n    %(type)s* O, const %(type)s* In,\\n    int C, int Y, int X, int N, int pad_y, int pad_x,\\n    int GY, int GX, int GXS, int GYS2,\\n    int X2cn, int magic_X2cn, int shift_X2cn, int shift_c, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN1152, int GXN1152, int N1152)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*36 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXcn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_C      = blockIdx.z;\\n\\n    // unpack y,x,c,n from blockIdx.x\\n    int gy2     = div64(blk_YXcn, magic_X2cn, shift_X2cn);\\n    int blk_Xcn = blk_YXcn - gy2*X2cn;\\n\\n    int shift_cn = shift_c + shift_n;\\n\\n    int gx2    = blk_Xcn >> shift_cn;\\n    int blk_cn = blk_Xcn - (gx2 << shift_cn);\\n\\n    int blk_c = blk_cn >> shift_n;\\n    int blk_n = blk_cn - (blk_c << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkC = (blk_C << shift_c) + blk_c;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    int ns = tid & 15;\\n    int cs = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 2) - pad_y;\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 2) - pad_x;\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int c  = (blkC << 4) + cs;\\n\\n    bool valid = c < C && n < N;\\n\\n    bool xin[6], yin[6];\\n    float I[6][6], T[6][6];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 6; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 6; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + offset + x*N);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(I[2][i], -2.250000f, I[4][i]);\\n        float t1 = __fmaf_rn(I[1][i], -2.250000f, I[3][i]);\\n        float t2 = __fmaf_rn(I[2][i], -0.390625f, I[4][i]);\\n        float t3 = __fmaf_rn(I[1][i], -0.390625f, I[3][i]);\\n        float t4 = __fmaf_rn(I[2][i], -2.640625f, I[4][i]);\\n        float t5 = __fmaf_rn(I[3][i], -2.640625f, I[5][i]);\\n\\n        T[0][i] = __fmaf_rn(I[0][i], 0.87890625f, t4);\\n        T[1][i] = __fmaf_rn(t1,  0.625f, t0);\\n        T[2][i] = __fmaf_rn(t1, -0.625f, t0);\\n        T[3][i] = __fmaf_rn(t3,  1.500f, t2);\\n        T[4][i] = __fmaf_rn(t3, -1.500f, t2);\\n        T[5][i] = __fmaf_rn(I[1][i], 0.87890625f, t5);\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(T[i][2], -2.250000f, T[i][4]);\\n        float t1 = __fmaf_rn(T[i][1], -2.250000f, T[i][3]);\\n        float t2 = __fmaf_rn(T[i][2], -0.390625f, T[i][4]);\\n        float t3 = __fmaf_rn(T[i][1], -0.390625f, T[i][3]);\\n        float t4 = __fmaf_rn(T[i][2], -2.640625f, T[i][4]);\\n        float t5 = __fmaf_rn(T[i][3], -2.640625f, T[i][5]);\\n\\n        share[ns][cs + 16*(i*6 + 0)] = %(cvt_out)s(__fmaf_rn(T[i][0], 0.87890625f, t4));\\n        share[ns][cs + 16*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(t1,  0.625f, t0));\\n        share[ns][cs + 16*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(t1, -0.625f, t0));\\n        share[ns][cs + 16*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(t3,  1.500f, t2));\\n        share[ns][cs + 16*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(t3, -1.500f, t2));\\n        share[ns][cs + 16*(i*6 + 5)] = %(cvt_out)s(__fmaf_rn(T[i][1], 0.87890625f, t5));\\n    }\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-2)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-2)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (C32,GY,GX,N,c32)\\n        // where c32 is the 1152 element transform data for 32 values of c\\n        // We group two blkC's to form each transform row\\n\\n        O += (blkC >> 1)*GYGXN1152 + gy*GXN1152 + gx*N1152 + n*1152 + (blkC & 1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 36; i++)\\n            O[32*i] = share[ns][cs + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_image_3x3_4x4')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
        "mutated": [
            "@context_dependent_memoize\ndef _get_update_image_3x3_4x4_kernel(dtype):\n    if False:\n        i = 10\n    code = \"\\n%(common)s\\n\\n__global__ void update_image_3x3_4x4(\\n    %(type)s* O, const %(type)s* In,\\n    int C, int Y, int X, int N, int pad_y, int pad_x,\\n    int GY, int GX, int GXS, int GYS2,\\n    int X2cn, int magic_X2cn, int shift_X2cn, int shift_c, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN1152, int GXN1152, int N1152)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*36 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXcn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_C      = blockIdx.z;\\n\\n    // unpack y,x,c,n from blockIdx.x\\n    int gy2     = div64(blk_YXcn, magic_X2cn, shift_X2cn);\\n    int blk_Xcn = blk_YXcn - gy2*X2cn;\\n\\n    int shift_cn = shift_c + shift_n;\\n\\n    int gx2    = blk_Xcn >> shift_cn;\\n    int blk_cn = blk_Xcn - (gx2 << shift_cn);\\n\\n    int blk_c = blk_cn >> shift_n;\\n    int blk_n = blk_cn - (blk_c << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkC = (blk_C << shift_c) + blk_c;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    int ns = tid & 15;\\n    int cs = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 2) - pad_y;\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 2) - pad_x;\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int c  = (blkC << 4) + cs;\\n\\n    bool valid = c < C && n < N;\\n\\n    bool xin[6], yin[6];\\n    float I[6][6], T[6][6];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 6; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 6; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + offset + x*N);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(I[2][i], -2.250000f, I[4][i]);\\n        float t1 = __fmaf_rn(I[1][i], -2.250000f, I[3][i]);\\n        float t2 = __fmaf_rn(I[2][i], -0.390625f, I[4][i]);\\n        float t3 = __fmaf_rn(I[1][i], -0.390625f, I[3][i]);\\n        float t4 = __fmaf_rn(I[2][i], -2.640625f, I[4][i]);\\n        float t5 = __fmaf_rn(I[3][i], -2.640625f, I[5][i]);\\n\\n        T[0][i] = __fmaf_rn(I[0][i], 0.87890625f, t4);\\n        T[1][i] = __fmaf_rn(t1,  0.625f, t0);\\n        T[2][i] = __fmaf_rn(t1, -0.625f, t0);\\n        T[3][i] = __fmaf_rn(t3,  1.500f, t2);\\n        T[4][i] = __fmaf_rn(t3, -1.500f, t2);\\n        T[5][i] = __fmaf_rn(I[1][i], 0.87890625f, t5);\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(T[i][2], -2.250000f, T[i][4]);\\n        float t1 = __fmaf_rn(T[i][1], -2.250000f, T[i][3]);\\n        float t2 = __fmaf_rn(T[i][2], -0.390625f, T[i][4]);\\n        float t3 = __fmaf_rn(T[i][1], -0.390625f, T[i][3]);\\n        float t4 = __fmaf_rn(T[i][2], -2.640625f, T[i][4]);\\n        float t5 = __fmaf_rn(T[i][3], -2.640625f, T[i][5]);\\n\\n        share[ns][cs + 16*(i*6 + 0)] = %(cvt_out)s(__fmaf_rn(T[i][0], 0.87890625f, t4));\\n        share[ns][cs + 16*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(t1,  0.625f, t0));\\n        share[ns][cs + 16*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(t1, -0.625f, t0));\\n        share[ns][cs + 16*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(t3,  1.500f, t2));\\n        share[ns][cs + 16*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(t3, -1.500f, t2));\\n        share[ns][cs + 16*(i*6 + 5)] = %(cvt_out)s(__fmaf_rn(T[i][1], 0.87890625f, t5));\\n    }\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-2)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-2)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (C32,GY,GX,N,c32)\\n        // where c32 is the 1152 element transform data for 32 values of c\\n        // We group two blkC's to form each transform row\\n\\n        O += (blkC >> 1)*GYGXN1152 + gy*GXN1152 + gx*N1152 + n*1152 + (blkC & 1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 36; i++)\\n            O[32*i] = share[ns][cs + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_image_3x3_4x4')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_update_image_3x3_4x4_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    code = \"\\n%(common)s\\n\\n__global__ void update_image_3x3_4x4(\\n    %(type)s* O, const %(type)s* In,\\n    int C, int Y, int X, int N, int pad_y, int pad_x,\\n    int GY, int GX, int GXS, int GYS2,\\n    int X2cn, int magic_X2cn, int shift_X2cn, int shift_c, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN1152, int GXN1152, int N1152)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*36 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXcn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_C      = blockIdx.z;\\n\\n    // unpack y,x,c,n from blockIdx.x\\n    int gy2     = div64(blk_YXcn, magic_X2cn, shift_X2cn);\\n    int blk_Xcn = blk_YXcn - gy2*X2cn;\\n\\n    int shift_cn = shift_c + shift_n;\\n\\n    int gx2    = blk_Xcn >> shift_cn;\\n    int blk_cn = blk_Xcn - (gx2 << shift_cn);\\n\\n    int blk_c = blk_cn >> shift_n;\\n    int blk_n = blk_cn - (blk_c << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkC = (blk_C << shift_c) + blk_c;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    int ns = tid & 15;\\n    int cs = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 2) - pad_y;\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 2) - pad_x;\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int c  = (blkC << 4) + cs;\\n\\n    bool valid = c < C && n < N;\\n\\n    bool xin[6], yin[6];\\n    float I[6][6], T[6][6];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 6; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 6; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + offset + x*N);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(I[2][i], -2.250000f, I[4][i]);\\n        float t1 = __fmaf_rn(I[1][i], -2.250000f, I[3][i]);\\n        float t2 = __fmaf_rn(I[2][i], -0.390625f, I[4][i]);\\n        float t3 = __fmaf_rn(I[1][i], -0.390625f, I[3][i]);\\n        float t4 = __fmaf_rn(I[2][i], -2.640625f, I[4][i]);\\n        float t5 = __fmaf_rn(I[3][i], -2.640625f, I[5][i]);\\n\\n        T[0][i] = __fmaf_rn(I[0][i], 0.87890625f, t4);\\n        T[1][i] = __fmaf_rn(t1,  0.625f, t0);\\n        T[2][i] = __fmaf_rn(t1, -0.625f, t0);\\n        T[3][i] = __fmaf_rn(t3,  1.500f, t2);\\n        T[4][i] = __fmaf_rn(t3, -1.500f, t2);\\n        T[5][i] = __fmaf_rn(I[1][i], 0.87890625f, t5);\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(T[i][2], -2.250000f, T[i][4]);\\n        float t1 = __fmaf_rn(T[i][1], -2.250000f, T[i][3]);\\n        float t2 = __fmaf_rn(T[i][2], -0.390625f, T[i][4]);\\n        float t3 = __fmaf_rn(T[i][1], -0.390625f, T[i][3]);\\n        float t4 = __fmaf_rn(T[i][2], -2.640625f, T[i][4]);\\n        float t5 = __fmaf_rn(T[i][3], -2.640625f, T[i][5]);\\n\\n        share[ns][cs + 16*(i*6 + 0)] = %(cvt_out)s(__fmaf_rn(T[i][0], 0.87890625f, t4));\\n        share[ns][cs + 16*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(t1,  0.625f, t0));\\n        share[ns][cs + 16*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(t1, -0.625f, t0));\\n        share[ns][cs + 16*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(t3,  1.500f, t2));\\n        share[ns][cs + 16*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(t3, -1.500f, t2));\\n        share[ns][cs + 16*(i*6 + 5)] = %(cvt_out)s(__fmaf_rn(T[i][1], 0.87890625f, t5));\\n    }\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-2)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-2)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (C32,GY,GX,N,c32)\\n        // where c32 is the 1152 element transform data for 32 values of c\\n        // We group two blkC's to form each transform row\\n\\n        O += (blkC >> 1)*GYGXN1152 + gy*GXN1152 + gx*N1152 + n*1152 + (blkC & 1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 36; i++)\\n            O[32*i] = share[ns][cs + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_image_3x3_4x4')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_update_image_3x3_4x4_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    code = \"\\n%(common)s\\n\\n__global__ void update_image_3x3_4x4(\\n    %(type)s* O, const %(type)s* In,\\n    int C, int Y, int X, int N, int pad_y, int pad_x,\\n    int GY, int GX, int GXS, int GYS2,\\n    int X2cn, int magic_X2cn, int shift_X2cn, int shift_c, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN1152, int GXN1152, int N1152)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*36 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXcn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_C      = blockIdx.z;\\n\\n    // unpack y,x,c,n from blockIdx.x\\n    int gy2     = div64(blk_YXcn, magic_X2cn, shift_X2cn);\\n    int blk_Xcn = blk_YXcn - gy2*X2cn;\\n\\n    int shift_cn = shift_c + shift_n;\\n\\n    int gx2    = blk_Xcn >> shift_cn;\\n    int blk_cn = blk_Xcn - (gx2 << shift_cn);\\n\\n    int blk_c = blk_cn >> shift_n;\\n    int blk_n = blk_cn - (blk_c << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkC = (blk_C << shift_c) + blk_c;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    int ns = tid & 15;\\n    int cs = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 2) - pad_y;\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 2) - pad_x;\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int c  = (blkC << 4) + cs;\\n\\n    bool valid = c < C && n < N;\\n\\n    bool xin[6], yin[6];\\n    float I[6][6], T[6][6];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 6; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 6; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + offset + x*N);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(I[2][i], -2.250000f, I[4][i]);\\n        float t1 = __fmaf_rn(I[1][i], -2.250000f, I[3][i]);\\n        float t2 = __fmaf_rn(I[2][i], -0.390625f, I[4][i]);\\n        float t3 = __fmaf_rn(I[1][i], -0.390625f, I[3][i]);\\n        float t4 = __fmaf_rn(I[2][i], -2.640625f, I[4][i]);\\n        float t5 = __fmaf_rn(I[3][i], -2.640625f, I[5][i]);\\n\\n        T[0][i] = __fmaf_rn(I[0][i], 0.87890625f, t4);\\n        T[1][i] = __fmaf_rn(t1,  0.625f, t0);\\n        T[2][i] = __fmaf_rn(t1, -0.625f, t0);\\n        T[3][i] = __fmaf_rn(t3,  1.500f, t2);\\n        T[4][i] = __fmaf_rn(t3, -1.500f, t2);\\n        T[5][i] = __fmaf_rn(I[1][i], 0.87890625f, t5);\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(T[i][2], -2.250000f, T[i][4]);\\n        float t1 = __fmaf_rn(T[i][1], -2.250000f, T[i][3]);\\n        float t2 = __fmaf_rn(T[i][2], -0.390625f, T[i][4]);\\n        float t3 = __fmaf_rn(T[i][1], -0.390625f, T[i][3]);\\n        float t4 = __fmaf_rn(T[i][2], -2.640625f, T[i][4]);\\n        float t5 = __fmaf_rn(T[i][3], -2.640625f, T[i][5]);\\n\\n        share[ns][cs + 16*(i*6 + 0)] = %(cvt_out)s(__fmaf_rn(T[i][0], 0.87890625f, t4));\\n        share[ns][cs + 16*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(t1,  0.625f, t0));\\n        share[ns][cs + 16*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(t1, -0.625f, t0));\\n        share[ns][cs + 16*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(t3,  1.500f, t2));\\n        share[ns][cs + 16*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(t3, -1.500f, t2));\\n        share[ns][cs + 16*(i*6 + 5)] = %(cvt_out)s(__fmaf_rn(T[i][1], 0.87890625f, t5));\\n    }\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-2)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-2)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (C32,GY,GX,N,c32)\\n        // where c32 is the 1152 element transform data for 32 values of c\\n        // We group two blkC's to form each transform row\\n\\n        O += (blkC >> 1)*GYGXN1152 + gy*GXN1152 + gx*N1152 + n*1152 + (blkC & 1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 36; i++)\\n            O[32*i] = share[ns][cs + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_image_3x3_4x4')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_update_image_3x3_4x4_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    code = \"\\n%(common)s\\n\\n__global__ void update_image_3x3_4x4(\\n    %(type)s* O, const %(type)s* In,\\n    int C, int Y, int X, int N, int pad_y, int pad_x,\\n    int GY, int GX, int GXS, int GYS2,\\n    int X2cn, int magic_X2cn, int shift_X2cn, int shift_c, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN1152, int GXN1152, int N1152)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*36 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXcn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_C      = blockIdx.z;\\n\\n    // unpack y,x,c,n from blockIdx.x\\n    int gy2     = div64(blk_YXcn, magic_X2cn, shift_X2cn);\\n    int blk_Xcn = blk_YXcn - gy2*X2cn;\\n\\n    int shift_cn = shift_c + shift_n;\\n\\n    int gx2    = blk_Xcn >> shift_cn;\\n    int blk_cn = blk_Xcn - (gx2 << shift_cn);\\n\\n    int blk_c = blk_cn >> shift_n;\\n    int blk_n = blk_cn - (blk_c << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkC = (blk_C << shift_c) + blk_c;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    int ns = tid & 15;\\n    int cs = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 2) - pad_y;\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 2) - pad_x;\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int c  = (blkC << 4) + cs;\\n\\n    bool valid = c < C && n < N;\\n\\n    bool xin[6], yin[6];\\n    float I[6][6], T[6][6];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 6; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 6; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + offset + x*N);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(I[2][i], -2.250000f, I[4][i]);\\n        float t1 = __fmaf_rn(I[1][i], -2.250000f, I[3][i]);\\n        float t2 = __fmaf_rn(I[2][i], -0.390625f, I[4][i]);\\n        float t3 = __fmaf_rn(I[1][i], -0.390625f, I[3][i]);\\n        float t4 = __fmaf_rn(I[2][i], -2.640625f, I[4][i]);\\n        float t5 = __fmaf_rn(I[3][i], -2.640625f, I[5][i]);\\n\\n        T[0][i] = __fmaf_rn(I[0][i], 0.87890625f, t4);\\n        T[1][i] = __fmaf_rn(t1,  0.625f, t0);\\n        T[2][i] = __fmaf_rn(t1, -0.625f, t0);\\n        T[3][i] = __fmaf_rn(t3,  1.500f, t2);\\n        T[4][i] = __fmaf_rn(t3, -1.500f, t2);\\n        T[5][i] = __fmaf_rn(I[1][i], 0.87890625f, t5);\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(T[i][2], -2.250000f, T[i][4]);\\n        float t1 = __fmaf_rn(T[i][1], -2.250000f, T[i][3]);\\n        float t2 = __fmaf_rn(T[i][2], -0.390625f, T[i][4]);\\n        float t3 = __fmaf_rn(T[i][1], -0.390625f, T[i][3]);\\n        float t4 = __fmaf_rn(T[i][2], -2.640625f, T[i][4]);\\n        float t5 = __fmaf_rn(T[i][3], -2.640625f, T[i][5]);\\n\\n        share[ns][cs + 16*(i*6 + 0)] = %(cvt_out)s(__fmaf_rn(T[i][0], 0.87890625f, t4));\\n        share[ns][cs + 16*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(t1,  0.625f, t0));\\n        share[ns][cs + 16*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(t1, -0.625f, t0));\\n        share[ns][cs + 16*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(t3,  1.500f, t2));\\n        share[ns][cs + 16*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(t3, -1.500f, t2));\\n        share[ns][cs + 16*(i*6 + 5)] = %(cvt_out)s(__fmaf_rn(T[i][1], 0.87890625f, t5));\\n    }\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-2)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-2)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (C32,GY,GX,N,c32)\\n        // where c32 is the 1152 element transform data for 32 values of c\\n        // We group two blkC's to form each transform row\\n\\n        O += (blkC >> 1)*GYGXN1152 + gy*GXN1152 + gx*N1152 + n*1152 + (blkC & 1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 36; i++)\\n            O[32*i] = share[ns][cs + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_image_3x3_4x4')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_update_image_3x3_4x4_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    code = \"\\n%(common)s\\n\\n__global__ void update_image_3x3_4x4(\\n    %(type)s* O, const %(type)s* In,\\n    int C, int Y, int X, int N, int pad_y, int pad_x,\\n    int GY, int GX, int GXS, int GYS2,\\n    int X2cn, int magic_X2cn, int shift_X2cn, int shift_c, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN1152, int GXN1152, int N1152)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*36 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXcn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_C      = blockIdx.z;\\n\\n    // unpack y,x,c,n from blockIdx.x\\n    int gy2     = div64(blk_YXcn, magic_X2cn, shift_X2cn);\\n    int blk_Xcn = blk_YXcn - gy2*X2cn;\\n\\n    int shift_cn = shift_c + shift_n;\\n\\n    int gx2    = blk_Xcn >> shift_cn;\\n    int blk_cn = blk_Xcn - (gx2 << shift_cn);\\n\\n    int blk_c = blk_cn >> shift_n;\\n    int blk_n = blk_cn - (blk_c << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkC = (blk_C << shift_c) + blk_c;\\n\\n    // Implement a square wave block id remapping\\n    // (for all but last row (if odd number of rows))\\n    int gy = gy2 << 1;\\n    int gx = gx2;\\n    if (gy2 != GYS2)\\n    {\\n        gy += (gx2 & 1) ^ ((gx2 & 2) >> 1);\\n        gx  = gx2 >> 1;\\n    }\\n    // Scan backwards on odd rows\\n    if (gy2 & 1)\\n        gx = GXS - gx - 1;\\n\\n    int ns = tid & 15;\\n    int cs = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 2) - pad_y;\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 2) - pad_x;\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int c  = (blkC << 4) + cs;\\n\\n    bool valid = c < C && n < N;\\n\\n    bool xin[6], yin[6];\\n    float I[6][6], T[6][6];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    int offset = c*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 6; y++)\\n    {\\n        if (y) offset += XN;\\n\\n        #pragma unroll\\n        for (int x = 0; x < 6; x++)\\n        {\\n            %(type)s val = 0;\\n            if (yin[y] && xin[x])\\n                val = __ldg(In + offset + x*N);\\n            I[y][x] = %(cvt_in)s(val);\\n        }\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(I[2][i], -2.250000f, I[4][i]);\\n        float t1 = __fmaf_rn(I[1][i], -2.250000f, I[3][i]);\\n        float t2 = __fmaf_rn(I[2][i], -0.390625f, I[4][i]);\\n        float t3 = __fmaf_rn(I[1][i], -0.390625f, I[3][i]);\\n        float t4 = __fmaf_rn(I[2][i], -2.640625f, I[4][i]);\\n        float t5 = __fmaf_rn(I[3][i], -2.640625f, I[5][i]);\\n\\n        T[0][i] = __fmaf_rn(I[0][i], 0.87890625f, t4);\\n        T[1][i] = __fmaf_rn(t1,  0.625f, t0);\\n        T[2][i] = __fmaf_rn(t1, -0.625f, t0);\\n        T[3][i] = __fmaf_rn(t3,  1.500f, t2);\\n        T[4][i] = __fmaf_rn(t3, -1.500f, t2);\\n        T[5][i] = __fmaf_rn(I[1][i], 0.87890625f, t5);\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = __fmaf_rn(T[i][2], -2.250000f, T[i][4]);\\n        float t1 = __fmaf_rn(T[i][1], -2.250000f, T[i][3]);\\n        float t2 = __fmaf_rn(T[i][2], -0.390625f, T[i][4]);\\n        float t3 = __fmaf_rn(T[i][1], -0.390625f, T[i][3]);\\n        float t4 = __fmaf_rn(T[i][2], -2.640625f, T[i][4]);\\n        float t5 = __fmaf_rn(T[i][3], -2.640625f, T[i][5]);\\n\\n        share[ns][cs + 16*(i*6 + 0)] = %(cvt_out)s(__fmaf_rn(T[i][0], 0.87890625f, t4));\\n        share[ns][cs + 16*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(t1,  0.625f, t0));\\n        share[ns][cs + 16*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(t1, -0.625f, t0));\\n        share[ns][cs + 16*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(t3,  1.500f, t2));\\n        share[ns][cs + 16*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(t3, -1.500f, t2));\\n        share[ns][cs + 16*(i*6 + 5)] = %(cvt_out)s(__fmaf_rn(T[i][1], 0.87890625f, t5));\\n    }\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-2)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-2)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (C32,GY,GX,N,c32)\\n        // where c32 is the 1152 element transform data for 32 values of c\\n        // We group two blkC's to form each transform row\\n\\n        O += (blkC >> 1)*GYGXN1152 + gy*GXN1152 + gx*N1152 + n*1152 + (blkC & 1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 36; i++)\\n            O[32*i] = share[ns][cs + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_image_3x3_4x4')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel"
        ]
    },
    {
        "func_name": "_get_update_delta_3x3_4x4_kernel",
        "original": "@context_dependent_memoize\ndef _get_update_delta_3x3_4x4_kernel(dtype):\n    code = \"\\n%(common)s\\n\\n__global__ void update_delta_3x3_4x4(\\n    %(type)s* O, const %(type)s* In,\\n    int K, int Y, int X, int N, int GY, int GX,\\n    int Xkn, int magic_Xkn, int shift_Xkn, int shift_k, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN1152, int GXN1152, int N1152)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*36 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXkn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_K      = blockIdx.z;\\n\\n    // unpack y,x,k,n from blockIdx.x\\n    int gy      = div64(blk_YXkn, magic_Xkn, shift_Xkn);\\n    int blk_Xkn = blk_YXkn - gy*Xkn;\\n\\n    int shift_kn = shift_k + shift_n;\\n\\n    int gx     = blk_Xkn >> shift_kn;\\n    int blk_kn = blk_Xkn - (gx << shift_kn);\\n\\n    int blk_k = blk_kn >> shift_n;\\n    int blk_n = blk_kn - (blk_k << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkK = (blk_K << shift_k) + blk_k;\\n\\n    int ns = tid & 15;\\n    int ks = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 2);\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 2);\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int k  = (blkK << 4) + ks;\\n\\n    bool valid = k < K && n < N;\\n\\n    bool xin[4], yin[4];\\n    float I[4][4];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    const %(type)s* In0 = In + k*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 4; y++)\\n    {\\n        if (y)\\n            In0 += XN;\\n        const %(type)s* In1 = In0 + N;\\n        const %(type)s* In2 = In1 + N;\\n        const %(type)s* In3 = In2 + N;\\n\\n        I[y][0] = yin[y] && xin[0] ? %(cvt_in)s(__ldg(In0)) : 0.0f;\\n        I[y][1] = yin[y] && xin[1] ? %(cvt_in)s(__ldg(In1)) : 0.0f;\\n        I[y][2] = yin[y] && xin[2] ? %(cvt_in)s(__ldg(In2)) : 0.0f;\\n        I[y][3] = yin[y] && xin[3] ? %(cvt_in)s(__ldg(In3)) : 0.0f;\\n    }\\n\\n    float T[6][4];\\n    float coeff0  =  0.26890756302521f;\\n    float coeff1  = -0.688403361344538f;\\n    float coeff2  =  0.119514472455649f;\\n    float coeff3  =  0.430252100840336f;\\n    float coeff4  =  0.179271708683473f;\\n    float coeff5  =  0.168067226890756f;\\n    float coeff6  =  0.403361344537815f;\\n    float coeff7  =  1.13777777777778f;\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        float t0 = I[2][i] * coeff0;\\n        float t1 = __fmaf_rn(I[0][i], coeff1, -t0);\\n        float t2 = __fmaf_rn(I[0][i], coeff2,  t0);\\n        float t3 = __fmaf_rn(I[1][i], coeff3,  I[3][i] * coeff5);\\n        float t4 = __fmaf_rn(I[1][i], coeff4,  I[3][i] * coeff6);\\n\\n        T[0][i] = I[0][i]*coeff7;\\n        T[1][i] = t1 - t3;\\n        T[2][i] = t1 + t3;\\n        T[3][i] = t2 + t4;\\n        T[4][i] = t2 - t4;\\n        T[5][i] = I[3][i];\\n    }\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = T[i][2] * coeff0;\\n        float t1 = __fmaf_rn(T[i][0], coeff1, -t0);\\n        float t2 = __fmaf_rn(T[i][0], coeff2,  t0);\\n        float t3 = __fmaf_rn(T[i][1], coeff3,  T[i][3] * coeff5);\\n        float t4 = __fmaf_rn(T[i][1], coeff4,  T[i][3] * coeff6);\\n\\n        share[ns][ks + 16*(i*6 + 0)] = %(cvt_out)s(T[i][0]*coeff7);\\n        share[ns][ks + 16*(i*6 + 1)] = %(cvt_out)s(t1 - t3);\\n        share[ns][ks + 16*(i*6 + 2)] = %(cvt_out)s(t1 + t3);\\n        share[ns][ks + 16*(i*6 + 3)] = %(cvt_out)s(t2 + t4);\\n        share[ns][ks + 16*(i*6 + 4)] = %(cvt_out)s(t2 - t4);\\n        share[ns][ks + 16*(i*6 + 5)] = %(cvt_out)s(T[i][3]);\\n    }\\n    __syncthreads();\\n\\n    // now make k contiguous\\n    ks = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-2)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-2)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (K32,GY,GX,N,k32)\\n        // where k32 is the 1152 element transform data for 32 values of k\\n        // We group two blkK's to form each transform row\\n\\n        O += (blkK >> 1)*GYGXN1152 + gy*GXN1152 + gx*N1152 + n*1152 + (blkK & 1)*16 + ks;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 36; i++)\\n            O[32*i] = share[ns][ks + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_delta_3x3_4x4')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
        "mutated": [
            "@context_dependent_memoize\ndef _get_update_delta_3x3_4x4_kernel(dtype):\n    if False:\n        i = 10\n    code = \"\\n%(common)s\\n\\n__global__ void update_delta_3x3_4x4(\\n    %(type)s* O, const %(type)s* In,\\n    int K, int Y, int X, int N, int GY, int GX,\\n    int Xkn, int magic_Xkn, int shift_Xkn, int shift_k, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN1152, int GXN1152, int N1152)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*36 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXkn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_K      = blockIdx.z;\\n\\n    // unpack y,x,k,n from blockIdx.x\\n    int gy      = div64(blk_YXkn, magic_Xkn, shift_Xkn);\\n    int blk_Xkn = blk_YXkn - gy*Xkn;\\n\\n    int shift_kn = shift_k + shift_n;\\n\\n    int gx     = blk_Xkn >> shift_kn;\\n    int blk_kn = blk_Xkn - (gx << shift_kn);\\n\\n    int blk_k = blk_kn >> shift_n;\\n    int blk_n = blk_kn - (blk_k << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkK = (blk_K << shift_k) + blk_k;\\n\\n    int ns = tid & 15;\\n    int ks = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 2);\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 2);\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int k  = (blkK << 4) + ks;\\n\\n    bool valid = k < K && n < N;\\n\\n    bool xin[4], yin[4];\\n    float I[4][4];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    const %(type)s* In0 = In + k*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 4; y++)\\n    {\\n        if (y)\\n            In0 += XN;\\n        const %(type)s* In1 = In0 + N;\\n        const %(type)s* In2 = In1 + N;\\n        const %(type)s* In3 = In2 + N;\\n\\n        I[y][0] = yin[y] && xin[0] ? %(cvt_in)s(__ldg(In0)) : 0.0f;\\n        I[y][1] = yin[y] && xin[1] ? %(cvt_in)s(__ldg(In1)) : 0.0f;\\n        I[y][2] = yin[y] && xin[2] ? %(cvt_in)s(__ldg(In2)) : 0.0f;\\n        I[y][3] = yin[y] && xin[3] ? %(cvt_in)s(__ldg(In3)) : 0.0f;\\n    }\\n\\n    float T[6][4];\\n    float coeff0  =  0.26890756302521f;\\n    float coeff1  = -0.688403361344538f;\\n    float coeff2  =  0.119514472455649f;\\n    float coeff3  =  0.430252100840336f;\\n    float coeff4  =  0.179271708683473f;\\n    float coeff5  =  0.168067226890756f;\\n    float coeff6  =  0.403361344537815f;\\n    float coeff7  =  1.13777777777778f;\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        float t0 = I[2][i] * coeff0;\\n        float t1 = __fmaf_rn(I[0][i], coeff1, -t0);\\n        float t2 = __fmaf_rn(I[0][i], coeff2,  t0);\\n        float t3 = __fmaf_rn(I[1][i], coeff3,  I[3][i] * coeff5);\\n        float t4 = __fmaf_rn(I[1][i], coeff4,  I[3][i] * coeff6);\\n\\n        T[0][i] = I[0][i]*coeff7;\\n        T[1][i] = t1 - t3;\\n        T[2][i] = t1 + t3;\\n        T[3][i] = t2 + t4;\\n        T[4][i] = t2 - t4;\\n        T[5][i] = I[3][i];\\n    }\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = T[i][2] * coeff0;\\n        float t1 = __fmaf_rn(T[i][0], coeff1, -t0);\\n        float t2 = __fmaf_rn(T[i][0], coeff2,  t0);\\n        float t3 = __fmaf_rn(T[i][1], coeff3,  T[i][3] * coeff5);\\n        float t4 = __fmaf_rn(T[i][1], coeff4,  T[i][3] * coeff6);\\n\\n        share[ns][ks + 16*(i*6 + 0)] = %(cvt_out)s(T[i][0]*coeff7);\\n        share[ns][ks + 16*(i*6 + 1)] = %(cvt_out)s(t1 - t3);\\n        share[ns][ks + 16*(i*6 + 2)] = %(cvt_out)s(t1 + t3);\\n        share[ns][ks + 16*(i*6 + 3)] = %(cvt_out)s(t2 + t4);\\n        share[ns][ks + 16*(i*6 + 4)] = %(cvt_out)s(t2 - t4);\\n        share[ns][ks + 16*(i*6 + 5)] = %(cvt_out)s(T[i][3]);\\n    }\\n    __syncthreads();\\n\\n    // now make k contiguous\\n    ks = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-2)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-2)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (K32,GY,GX,N,k32)\\n        // where k32 is the 1152 element transform data for 32 values of k\\n        // We group two blkK's to form each transform row\\n\\n        O += (blkK >> 1)*GYGXN1152 + gy*GXN1152 + gx*N1152 + n*1152 + (blkK & 1)*16 + ks;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 36; i++)\\n            O[32*i] = share[ns][ks + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_delta_3x3_4x4')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_update_delta_3x3_4x4_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    code = \"\\n%(common)s\\n\\n__global__ void update_delta_3x3_4x4(\\n    %(type)s* O, const %(type)s* In,\\n    int K, int Y, int X, int N, int GY, int GX,\\n    int Xkn, int magic_Xkn, int shift_Xkn, int shift_k, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN1152, int GXN1152, int N1152)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*36 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXkn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_K      = blockIdx.z;\\n\\n    // unpack y,x,k,n from blockIdx.x\\n    int gy      = div64(blk_YXkn, magic_Xkn, shift_Xkn);\\n    int blk_Xkn = blk_YXkn - gy*Xkn;\\n\\n    int shift_kn = shift_k + shift_n;\\n\\n    int gx     = blk_Xkn >> shift_kn;\\n    int blk_kn = blk_Xkn - (gx << shift_kn);\\n\\n    int blk_k = blk_kn >> shift_n;\\n    int blk_n = blk_kn - (blk_k << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkK = (blk_K << shift_k) + blk_k;\\n\\n    int ns = tid & 15;\\n    int ks = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 2);\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 2);\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int k  = (blkK << 4) + ks;\\n\\n    bool valid = k < K && n < N;\\n\\n    bool xin[4], yin[4];\\n    float I[4][4];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    const %(type)s* In0 = In + k*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 4; y++)\\n    {\\n        if (y)\\n            In0 += XN;\\n        const %(type)s* In1 = In0 + N;\\n        const %(type)s* In2 = In1 + N;\\n        const %(type)s* In3 = In2 + N;\\n\\n        I[y][0] = yin[y] && xin[0] ? %(cvt_in)s(__ldg(In0)) : 0.0f;\\n        I[y][1] = yin[y] && xin[1] ? %(cvt_in)s(__ldg(In1)) : 0.0f;\\n        I[y][2] = yin[y] && xin[2] ? %(cvt_in)s(__ldg(In2)) : 0.0f;\\n        I[y][3] = yin[y] && xin[3] ? %(cvt_in)s(__ldg(In3)) : 0.0f;\\n    }\\n\\n    float T[6][4];\\n    float coeff0  =  0.26890756302521f;\\n    float coeff1  = -0.688403361344538f;\\n    float coeff2  =  0.119514472455649f;\\n    float coeff3  =  0.430252100840336f;\\n    float coeff4  =  0.179271708683473f;\\n    float coeff5  =  0.168067226890756f;\\n    float coeff6  =  0.403361344537815f;\\n    float coeff7  =  1.13777777777778f;\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        float t0 = I[2][i] * coeff0;\\n        float t1 = __fmaf_rn(I[0][i], coeff1, -t0);\\n        float t2 = __fmaf_rn(I[0][i], coeff2,  t0);\\n        float t3 = __fmaf_rn(I[1][i], coeff3,  I[3][i] * coeff5);\\n        float t4 = __fmaf_rn(I[1][i], coeff4,  I[3][i] * coeff6);\\n\\n        T[0][i] = I[0][i]*coeff7;\\n        T[1][i] = t1 - t3;\\n        T[2][i] = t1 + t3;\\n        T[3][i] = t2 + t4;\\n        T[4][i] = t2 - t4;\\n        T[5][i] = I[3][i];\\n    }\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = T[i][2] * coeff0;\\n        float t1 = __fmaf_rn(T[i][0], coeff1, -t0);\\n        float t2 = __fmaf_rn(T[i][0], coeff2,  t0);\\n        float t3 = __fmaf_rn(T[i][1], coeff3,  T[i][3] * coeff5);\\n        float t4 = __fmaf_rn(T[i][1], coeff4,  T[i][3] * coeff6);\\n\\n        share[ns][ks + 16*(i*6 + 0)] = %(cvt_out)s(T[i][0]*coeff7);\\n        share[ns][ks + 16*(i*6 + 1)] = %(cvt_out)s(t1 - t3);\\n        share[ns][ks + 16*(i*6 + 2)] = %(cvt_out)s(t1 + t3);\\n        share[ns][ks + 16*(i*6 + 3)] = %(cvt_out)s(t2 + t4);\\n        share[ns][ks + 16*(i*6 + 4)] = %(cvt_out)s(t2 - t4);\\n        share[ns][ks + 16*(i*6 + 5)] = %(cvt_out)s(T[i][3]);\\n    }\\n    __syncthreads();\\n\\n    // now make k contiguous\\n    ks = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-2)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-2)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (K32,GY,GX,N,k32)\\n        // where k32 is the 1152 element transform data for 32 values of k\\n        // We group two blkK's to form each transform row\\n\\n        O += (blkK >> 1)*GYGXN1152 + gy*GXN1152 + gx*N1152 + n*1152 + (blkK & 1)*16 + ks;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 36; i++)\\n            O[32*i] = share[ns][ks + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_delta_3x3_4x4')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_update_delta_3x3_4x4_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    code = \"\\n%(common)s\\n\\n__global__ void update_delta_3x3_4x4(\\n    %(type)s* O, const %(type)s* In,\\n    int K, int Y, int X, int N, int GY, int GX,\\n    int Xkn, int magic_Xkn, int shift_Xkn, int shift_k, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN1152, int GXN1152, int N1152)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*36 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXkn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_K      = blockIdx.z;\\n\\n    // unpack y,x,k,n from blockIdx.x\\n    int gy      = div64(blk_YXkn, magic_Xkn, shift_Xkn);\\n    int blk_Xkn = blk_YXkn - gy*Xkn;\\n\\n    int shift_kn = shift_k + shift_n;\\n\\n    int gx     = blk_Xkn >> shift_kn;\\n    int blk_kn = blk_Xkn - (gx << shift_kn);\\n\\n    int blk_k = blk_kn >> shift_n;\\n    int blk_n = blk_kn - (blk_k << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkK = (blk_K << shift_k) + blk_k;\\n\\n    int ns = tid & 15;\\n    int ks = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 2);\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 2);\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int k  = (blkK << 4) + ks;\\n\\n    bool valid = k < K && n < N;\\n\\n    bool xin[4], yin[4];\\n    float I[4][4];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    const %(type)s* In0 = In + k*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 4; y++)\\n    {\\n        if (y)\\n            In0 += XN;\\n        const %(type)s* In1 = In0 + N;\\n        const %(type)s* In2 = In1 + N;\\n        const %(type)s* In3 = In2 + N;\\n\\n        I[y][0] = yin[y] && xin[0] ? %(cvt_in)s(__ldg(In0)) : 0.0f;\\n        I[y][1] = yin[y] && xin[1] ? %(cvt_in)s(__ldg(In1)) : 0.0f;\\n        I[y][2] = yin[y] && xin[2] ? %(cvt_in)s(__ldg(In2)) : 0.0f;\\n        I[y][3] = yin[y] && xin[3] ? %(cvt_in)s(__ldg(In3)) : 0.0f;\\n    }\\n\\n    float T[6][4];\\n    float coeff0  =  0.26890756302521f;\\n    float coeff1  = -0.688403361344538f;\\n    float coeff2  =  0.119514472455649f;\\n    float coeff3  =  0.430252100840336f;\\n    float coeff4  =  0.179271708683473f;\\n    float coeff5  =  0.168067226890756f;\\n    float coeff6  =  0.403361344537815f;\\n    float coeff7  =  1.13777777777778f;\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        float t0 = I[2][i] * coeff0;\\n        float t1 = __fmaf_rn(I[0][i], coeff1, -t0);\\n        float t2 = __fmaf_rn(I[0][i], coeff2,  t0);\\n        float t3 = __fmaf_rn(I[1][i], coeff3,  I[3][i] * coeff5);\\n        float t4 = __fmaf_rn(I[1][i], coeff4,  I[3][i] * coeff6);\\n\\n        T[0][i] = I[0][i]*coeff7;\\n        T[1][i] = t1 - t3;\\n        T[2][i] = t1 + t3;\\n        T[3][i] = t2 + t4;\\n        T[4][i] = t2 - t4;\\n        T[5][i] = I[3][i];\\n    }\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = T[i][2] * coeff0;\\n        float t1 = __fmaf_rn(T[i][0], coeff1, -t0);\\n        float t2 = __fmaf_rn(T[i][0], coeff2,  t0);\\n        float t3 = __fmaf_rn(T[i][1], coeff3,  T[i][3] * coeff5);\\n        float t4 = __fmaf_rn(T[i][1], coeff4,  T[i][3] * coeff6);\\n\\n        share[ns][ks + 16*(i*6 + 0)] = %(cvt_out)s(T[i][0]*coeff7);\\n        share[ns][ks + 16*(i*6 + 1)] = %(cvt_out)s(t1 - t3);\\n        share[ns][ks + 16*(i*6 + 2)] = %(cvt_out)s(t1 + t3);\\n        share[ns][ks + 16*(i*6 + 3)] = %(cvt_out)s(t2 + t4);\\n        share[ns][ks + 16*(i*6 + 4)] = %(cvt_out)s(t2 - t4);\\n        share[ns][ks + 16*(i*6 + 5)] = %(cvt_out)s(T[i][3]);\\n    }\\n    __syncthreads();\\n\\n    // now make k contiguous\\n    ks = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-2)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-2)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (K32,GY,GX,N,k32)\\n        // where k32 is the 1152 element transform data for 32 values of k\\n        // We group two blkK's to form each transform row\\n\\n        O += (blkK >> 1)*GYGXN1152 + gy*GXN1152 + gx*N1152 + n*1152 + (blkK & 1)*16 + ks;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 36; i++)\\n            O[32*i] = share[ns][ks + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_delta_3x3_4x4')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_update_delta_3x3_4x4_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    code = \"\\n%(common)s\\n\\n__global__ void update_delta_3x3_4x4(\\n    %(type)s* O, const %(type)s* In,\\n    int K, int Y, int X, int N, int GY, int GX,\\n    int Xkn, int magic_Xkn, int shift_Xkn, int shift_k, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN1152, int GXN1152, int N1152)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*36 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXkn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_K      = blockIdx.z;\\n\\n    // unpack y,x,k,n from blockIdx.x\\n    int gy      = div64(blk_YXkn, magic_Xkn, shift_Xkn);\\n    int blk_Xkn = blk_YXkn - gy*Xkn;\\n\\n    int shift_kn = shift_k + shift_n;\\n\\n    int gx     = blk_Xkn >> shift_kn;\\n    int blk_kn = blk_Xkn - (gx << shift_kn);\\n\\n    int blk_k = blk_kn >> shift_n;\\n    int blk_n = blk_kn - (blk_k << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkK = (blk_K << shift_k) + blk_k;\\n\\n    int ns = tid & 15;\\n    int ks = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 2);\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 2);\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int k  = (blkK << 4) + ks;\\n\\n    bool valid = k < K && n < N;\\n\\n    bool xin[4], yin[4];\\n    float I[4][4];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    const %(type)s* In0 = In + k*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 4; y++)\\n    {\\n        if (y)\\n            In0 += XN;\\n        const %(type)s* In1 = In0 + N;\\n        const %(type)s* In2 = In1 + N;\\n        const %(type)s* In3 = In2 + N;\\n\\n        I[y][0] = yin[y] && xin[0] ? %(cvt_in)s(__ldg(In0)) : 0.0f;\\n        I[y][1] = yin[y] && xin[1] ? %(cvt_in)s(__ldg(In1)) : 0.0f;\\n        I[y][2] = yin[y] && xin[2] ? %(cvt_in)s(__ldg(In2)) : 0.0f;\\n        I[y][3] = yin[y] && xin[3] ? %(cvt_in)s(__ldg(In3)) : 0.0f;\\n    }\\n\\n    float T[6][4];\\n    float coeff0  =  0.26890756302521f;\\n    float coeff1  = -0.688403361344538f;\\n    float coeff2  =  0.119514472455649f;\\n    float coeff3  =  0.430252100840336f;\\n    float coeff4  =  0.179271708683473f;\\n    float coeff5  =  0.168067226890756f;\\n    float coeff6  =  0.403361344537815f;\\n    float coeff7  =  1.13777777777778f;\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        float t0 = I[2][i] * coeff0;\\n        float t1 = __fmaf_rn(I[0][i], coeff1, -t0);\\n        float t2 = __fmaf_rn(I[0][i], coeff2,  t0);\\n        float t3 = __fmaf_rn(I[1][i], coeff3,  I[3][i] * coeff5);\\n        float t4 = __fmaf_rn(I[1][i], coeff4,  I[3][i] * coeff6);\\n\\n        T[0][i] = I[0][i]*coeff7;\\n        T[1][i] = t1 - t3;\\n        T[2][i] = t1 + t3;\\n        T[3][i] = t2 + t4;\\n        T[4][i] = t2 - t4;\\n        T[5][i] = I[3][i];\\n    }\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = T[i][2] * coeff0;\\n        float t1 = __fmaf_rn(T[i][0], coeff1, -t0);\\n        float t2 = __fmaf_rn(T[i][0], coeff2,  t0);\\n        float t3 = __fmaf_rn(T[i][1], coeff3,  T[i][3] * coeff5);\\n        float t4 = __fmaf_rn(T[i][1], coeff4,  T[i][3] * coeff6);\\n\\n        share[ns][ks + 16*(i*6 + 0)] = %(cvt_out)s(T[i][0]*coeff7);\\n        share[ns][ks + 16*(i*6 + 1)] = %(cvt_out)s(t1 - t3);\\n        share[ns][ks + 16*(i*6 + 2)] = %(cvt_out)s(t1 + t3);\\n        share[ns][ks + 16*(i*6 + 3)] = %(cvt_out)s(t2 + t4);\\n        share[ns][ks + 16*(i*6 + 4)] = %(cvt_out)s(t2 - t4);\\n        share[ns][ks + 16*(i*6 + 5)] = %(cvt_out)s(T[i][3]);\\n    }\\n    __syncthreads();\\n\\n    // now make k contiguous\\n    ks = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-2)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-2)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (K32,GY,GX,N,k32)\\n        // where k32 is the 1152 element transform data for 32 values of k\\n        // We group two blkK's to form each transform row\\n\\n        O += (blkK >> 1)*GYGXN1152 + gy*GXN1152 + gx*N1152 + n*1152 + (blkK & 1)*16 + ks;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 36; i++)\\n            O[32*i] = share[ns][ks + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_delta_3x3_4x4')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_update_delta_3x3_4x4_kernel(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    code = \"\\n%(common)s\\n\\n__global__ void update_delta_3x3_4x4(\\n    %(type)s* O, const %(type)s* In,\\n    int K, int Y, int X, int N, int GY, int GX,\\n    int Xkn, int magic_Xkn, int shift_Xkn, int shift_k, int shift_n,\\n    int shlY, int shlX, int maskY, int shrY, int maskX, int shrX, int shlN, int maskN,\\n    int YXN, int XN, int GYGXN1152, int GXN1152, int N1152)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type)s __shared__ share[16][16*36 + 2];\\n\\n    int tid        = threadIdx.x;\\n    int blk_YXkn   = blockIdx.x;\\n    int blk_N      = blockIdx.y;\\n    int blk_K      = blockIdx.z;\\n\\n    // unpack y,x,k,n from blockIdx.x\\n    int gy      = div64(blk_YXkn, magic_Xkn, shift_Xkn);\\n    int blk_Xkn = blk_YXkn - gy*Xkn;\\n\\n    int shift_kn = shift_k + shift_n;\\n\\n    int gx     = blk_Xkn >> shift_kn;\\n    int blk_kn = blk_Xkn - (gx << shift_kn);\\n\\n    int blk_k = blk_kn >> shift_n;\\n    int blk_n = blk_kn - (blk_k << shift_n);\\n\\n    int blkN = (blk_N << shift_n) + blk_n;\\n    int blkK = (blk_K << shift_k) + blk_k;\\n\\n    int ns = tid & 15;\\n    int ks = tid >> 4;\\n\\n    // Super block YXN coordinates\\n    int y0 = (gy << shlY) + (((ns & maskY) >> shrY) << 2);\\n    int x0 = (gx << shlX) + (((ns & maskX) >> shrX) << 2);\\n    int n  = (blkN << shlN) + (ns & maskN);\\n    int k  = (blkK << 4) + ks;\\n\\n    bool valid = k < K && n < N;\\n\\n    bool xin[4], yin[4];\\n    float I[4][4];\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        xin[i] = x0 + i >= 0 && x0 + i < X && valid;\\n        yin[i] = y0 + i >= 0 && y0 + i < Y;\\n    }\\n\\n    const %(type)s* In0 = In + k*YXN + y0*XN + x0*N + n;\\n\\n    #pragma unroll\\n    for (int y = 0; y < 4; y++)\\n    {\\n        if (y)\\n            In0 += XN;\\n        const %(type)s* In1 = In0 + N;\\n        const %(type)s* In2 = In1 + N;\\n        const %(type)s* In3 = In2 + N;\\n\\n        I[y][0] = yin[y] && xin[0] ? %(cvt_in)s(__ldg(In0)) : 0.0f;\\n        I[y][1] = yin[y] && xin[1] ? %(cvt_in)s(__ldg(In1)) : 0.0f;\\n        I[y][2] = yin[y] && xin[2] ? %(cvt_in)s(__ldg(In2)) : 0.0f;\\n        I[y][3] = yin[y] && xin[3] ? %(cvt_in)s(__ldg(In3)) : 0.0f;\\n    }\\n\\n    float T[6][4];\\n    float coeff0  =  0.26890756302521f;\\n    float coeff1  = -0.688403361344538f;\\n    float coeff2  =  0.119514472455649f;\\n    float coeff3  =  0.430252100840336f;\\n    float coeff4  =  0.179271708683473f;\\n    float coeff5  =  0.168067226890756f;\\n    float coeff6  =  0.403361344537815f;\\n    float coeff7  =  1.13777777777778f;\\n\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        float t0 = I[2][i] * coeff0;\\n        float t1 = __fmaf_rn(I[0][i], coeff1, -t0);\\n        float t2 = __fmaf_rn(I[0][i], coeff2,  t0);\\n        float t3 = __fmaf_rn(I[1][i], coeff3,  I[3][i] * coeff5);\\n        float t4 = __fmaf_rn(I[1][i], coeff4,  I[3][i] * coeff6);\\n\\n        T[0][i] = I[0][i]*coeff7;\\n        T[1][i] = t1 - t3;\\n        T[2][i] = t1 + t3;\\n        T[3][i] = t2 + t4;\\n        T[4][i] = t2 - t4;\\n        T[5][i] = I[3][i];\\n    }\\n\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = T[i][2] * coeff0;\\n        float t1 = __fmaf_rn(T[i][0], coeff1, -t0);\\n        float t2 = __fmaf_rn(T[i][0], coeff2,  t0);\\n        float t3 = __fmaf_rn(T[i][1], coeff3,  T[i][3] * coeff5);\\n        float t4 = __fmaf_rn(T[i][1], coeff4,  T[i][3] * coeff6);\\n\\n        share[ns][ks + 16*(i*6 + 0)] = %(cvt_out)s(T[i][0]*coeff7);\\n        share[ns][ks + 16*(i*6 + 1)] = %(cvt_out)s(t1 - t3);\\n        share[ns][ks + 16*(i*6 + 2)] = %(cvt_out)s(t1 + t3);\\n        share[ns][ks + 16*(i*6 + 3)] = %(cvt_out)s(t2 + t4);\\n        share[ns][ks + 16*(i*6 + 4)] = %(cvt_out)s(t2 - t4);\\n        share[ns][ks + 16*(i*6 + 5)] = %(cvt_out)s(T[i][3]);\\n    }\\n    __syncthreads();\\n\\n    // now make k contiguous\\n    ks = tid & 15;\\n    ns = tid >> 4;\\n\\n    // apply the super block to just grid coordinates this time\\n    gy = (gy << (shlY-2)) + ((ns & maskY) >> shrY);\\n    gx = (gx << (shlX-2)) + ((ns & maskX) >> shrX);\\n    n  = (blkN << shlN)   + (ns  & maskN);\\n\\n    if (n < N && gy < GY && gx < GX)\\n    {\\n        // output dim: (K32,GY,GX,N,k32)\\n        // where k32 is the 1152 element transform data for 32 values of k\\n        // We group two blkK's to form each transform row\\n\\n        O += (blkK >> 1)*GYGXN1152 + gy*GXN1152 + gx*N1152 + n*1152 + (blkK & 1)*16 + ks;\\n\\n        #pragma unroll\\n        for (int i = 0; i < 36; i++)\\n            O[32*i] = share[ns][ks + 16*i];\\n    }\\n}\\n\"\n    common = _common_round['nearest'].get(dtype, '') + _div64\n    if dtype == 'f2':\n        common += _common_fp16_to_fp32\n    code = code % {'common': common, 'type': _ew_types[dtype]['type'], 'cvt_in': _ew_types[dtype]['cvt'], 'cvt_out': _ew_types[dtype]['cvt_out']}\n    module = SourceModule(code)\n    kernel = module.get_function('update_delta_3x3_4x4')\n    kernel.prepare('PPIIIIIIIIIIIIIIIIIIIIIIII')\n    return kernel"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, prop, Rt, St, R, S, mode):\n    self.lib = lib\n    self.size = int(np.prod(self.dim)) * dtype.itemsize\n    self.kargs = [dtype.str[1:], None, prop, Rt, St, R, S, mode]",
        "mutated": [
            "def __init__(self, lib, dtype, prop, Rt, St, R, S, mode):\n    if False:\n        i = 10\n    self.lib = lib\n    self.size = int(np.prod(self.dim)) * dtype.itemsize\n    self.kargs = [dtype.str[1:], None, prop, Rt, St, R, S, mode]",
            "def __init__(self, lib, dtype, prop, Rt, St, R, S, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.lib = lib\n    self.size = int(np.prod(self.dim)) * dtype.itemsize\n    self.kargs = [dtype.str[1:], None, prop, Rt, St, R, S, mode]",
            "def __init__(self, lib, dtype, prop, Rt, St, R, S, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.lib = lib\n    self.size = int(np.prod(self.dim)) * dtype.itemsize\n    self.kargs = [dtype.str[1:], None, prop, Rt, St, R, S, mode]",
            "def __init__(self, lib, dtype, prop, Rt, St, R, S, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.lib = lib\n    self.size = int(np.prod(self.dim)) * dtype.itemsize\n    self.kargs = [dtype.str[1:], None, prop, Rt, St, R, S, mode]",
            "def __init__(self, lib, dtype, prop, Rt, St, R, S, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.lib = lib\n    self.size = int(np.prod(self.dim)) * dtype.itemsize\n    self.kargs = [dtype.str[1:], None, prop, Rt, St, R, S, mode]"
        ]
    },
    {
        "func_name": "bind_params",
        "original": "def bind_params(self, F):\n    self.data = self.lib.scratch_buffer_offset(self.size)\n    self.args[2:5] = (self.lib.stream, self.data, F.gpudata)\n    self.kargs[1] = F.dtype.str[1:]\n    self.kernel = _get_filter_kernel(*self.kargs)\n    return self.data",
        "mutated": [
            "def bind_params(self, F):\n    if False:\n        i = 10\n    self.data = self.lib.scratch_buffer_offset(self.size)\n    self.args[2:5] = (self.lib.stream, self.data, F.gpudata)\n    self.kargs[1] = F.dtype.str[1:]\n    self.kernel = _get_filter_kernel(*self.kargs)\n    return self.data",
            "def bind_params(self, F):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.data = self.lib.scratch_buffer_offset(self.size)\n    self.args[2:5] = (self.lib.stream, self.data, F.gpudata)\n    self.kargs[1] = F.dtype.str[1:]\n    self.kernel = _get_filter_kernel(*self.kargs)\n    return self.data",
            "def bind_params(self, F):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.data = self.lib.scratch_buffer_offset(self.size)\n    self.args[2:5] = (self.lib.stream, self.data, F.gpudata)\n    self.kargs[1] = F.dtype.str[1:]\n    self.kernel = _get_filter_kernel(*self.kargs)\n    return self.data",
            "def bind_params(self, F):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.data = self.lib.scratch_buffer_offset(self.size)\n    self.args[2:5] = (self.lib.stream, self.data, F.gpudata)\n    self.kargs[1] = F.dtype.str[1:]\n    self.kernel = _get_filter_kernel(*self.kargs)\n    return self.data",
            "def bind_params(self, F):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.data = self.lib.scratch_buffer_offset(self.size)\n    self.args[2:5] = (self.lib.stream, self.data, F.gpudata)\n    self.kargs[1] = F.dtype.str[1:]\n    self.kernel = _get_filter_kernel(*self.kargs)\n    return self.data"
        ]
    },
    {
        "func_name": "execute",
        "original": "def execute(self):\n    self.kernel.prepared_async_call(*self.args)",
        "mutated": [
            "def execute(self):\n    if False:\n        i = 10\n    self.kernel.prepared_async_call(*self.args)",
            "def execute(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.kernel.prepared_async_call(*self.args)",
            "def execute(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.kernel.prepared_async_call(*self.args)",
            "def execute(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.kernel.prepared_async_call(*self.args)",
            "def execute(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.kernel.prepared_async_call(*self.args)"
        ]
    },
    {
        "func_name": "unbind",
        "original": "def unbind(self):\n    self.kernel = None\n    self.args[2:5] = (None,) * 3",
        "mutated": [
            "def unbind(self):\n    if False:\n        i = 10\n    self.kernel = None\n    self.args[2:5] = (None,) * 3",
            "def unbind(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.kernel = None\n    self.args[2:5] = (None,) * 3",
            "def unbind(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.kernel = None\n    self.args[2:5] = (None,) * 3",
            "def unbind(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.kernel = None\n    self.args[2:5] = (None,) * 3",
            "def unbind(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.kernel = None\n    self.args[2:5] = (None,) * 3"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, C, K, Rt, St, R, S, mode):\n    GK32 = _ceil_div(K, 32)\n    self.dim = (GK32, C, R + Rt - 1, S + St - 1, 32)\n    self.args = [(GK32, C, 1), (32, 1, 1), None, None, None, R * S * K, S * K, K, C]\n    super(FpropFilterTransform, self).__init__(lib, dtype, 'fprop', Rt, St, R, S, mode)",
        "mutated": [
            "def __init__(self, lib, dtype, C, K, Rt, St, R, S, mode):\n    if False:\n        i = 10\n    GK32 = _ceil_div(K, 32)\n    self.dim = (GK32, C, R + Rt - 1, S + St - 1, 32)\n    self.args = [(GK32, C, 1), (32, 1, 1), None, None, None, R * S * K, S * K, K, C]\n    super(FpropFilterTransform, self).__init__(lib, dtype, 'fprop', Rt, St, R, S, mode)",
            "def __init__(self, lib, dtype, C, K, Rt, St, R, S, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    GK32 = _ceil_div(K, 32)\n    self.dim = (GK32, C, R + Rt - 1, S + St - 1, 32)\n    self.args = [(GK32, C, 1), (32, 1, 1), None, None, None, R * S * K, S * K, K, C]\n    super(FpropFilterTransform, self).__init__(lib, dtype, 'fprop', Rt, St, R, S, mode)",
            "def __init__(self, lib, dtype, C, K, Rt, St, R, S, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    GK32 = _ceil_div(K, 32)\n    self.dim = (GK32, C, R + Rt - 1, S + St - 1, 32)\n    self.args = [(GK32, C, 1), (32, 1, 1), None, None, None, R * S * K, S * K, K, C]\n    super(FpropFilterTransform, self).__init__(lib, dtype, 'fprop', Rt, St, R, S, mode)",
            "def __init__(self, lib, dtype, C, K, Rt, St, R, S, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    GK32 = _ceil_div(K, 32)\n    self.dim = (GK32, C, R + Rt - 1, S + St - 1, 32)\n    self.args = [(GK32, C, 1), (32, 1, 1), None, None, None, R * S * K, S * K, K, C]\n    super(FpropFilterTransform, self).__init__(lib, dtype, 'fprop', Rt, St, R, S, mode)",
            "def __init__(self, lib, dtype, C, K, Rt, St, R, S, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    GK32 = _ceil_div(K, 32)\n    self.dim = (GK32, C, R + Rt - 1, S + St - 1, 32)\n    self.args = [(GK32, C, 1), (32, 1, 1), None, None, None, R * S * K, S * K, K, C]\n    super(FpropFilterTransform, self).__init__(lib, dtype, 'fprop', Rt, St, R, S, mode)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, C, K, Rt, St, R, S, mode):\n    GC32 = _ceil_div(C, 32)\n    GK32 = _ceil_div(K, 32)\n    GC16 = _ceil_div(GC32 * 32, 16)\n    GK16 = _ceil_div(K, 16)\n    self.dim = (GC32, K, R + Rt - 1, S + St - 1, 32)\n    self.args = [(GK16, GC16, 1), (256, 1, 1), None, None, None, R * S * K, S * K, K, C]\n    super(BpropFilterTransform, self).__init__(lib, dtype, 'bprop', Rt, St, R, S, mode)",
        "mutated": [
            "def __init__(self, lib, dtype, C, K, Rt, St, R, S, mode):\n    if False:\n        i = 10\n    GC32 = _ceil_div(C, 32)\n    GK32 = _ceil_div(K, 32)\n    GC16 = _ceil_div(GC32 * 32, 16)\n    GK16 = _ceil_div(K, 16)\n    self.dim = (GC32, K, R + Rt - 1, S + St - 1, 32)\n    self.args = [(GK16, GC16, 1), (256, 1, 1), None, None, None, R * S * K, S * K, K, C]\n    super(BpropFilterTransform, self).__init__(lib, dtype, 'bprop', Rt, St, R, S, mode)",
            "def __init__(self, lib, dtype, C, K, Rt, St, R, S, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    GC32 = _ceil_div(C, 32)\n    GK32 = _ceil_div(K, 32)\n    GC16 = _ceil_div(GC32 * 32, 16)\n    GK16 = _ceil_div(K, 16)\n    self.dim = (GC32, K, R + Rt - 1, S + St - 1, 32)\n    self.args = [(GK16, GC16, 1), (256, 1, 1), None, None, None, R * S * K, S * K, K, C]\n    super(BpropFilterTransform, self).__init__(lib, dtype, 'bprop', Rt, St, R, S, mode)",
            "def __init__(self, lib, dtype, C, K, Rt, St, R, S, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    GC32 = _ceil_div(C, 32)\n    GK32 = _ceil_div(K, 32)\n    GC16 = _ceil_div(GC32 * 32, 16)\n    GK16 = _ceil_div(K, 16)\n    self.dim = (GC32, K, R + Rt - 1, S + St - 1, 32)\n    self.args = [(GK16, GC16, 1), (256, 1, 1), None, None, None, R * S * K, S * K, K, C]\n    super(BpropFilterTransform, self).__init__(lib, dtype, 'bprop', Rt, St, R, S, mode)",
            "def __init__(self, lib, dtype, C, K, Rt, St, R, S, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    GC32 = _ceil_div(C, 32)\n    GK32 = _ceil_div(K, 32)\n    GC16 = _ceil_div(GC32 * 32, 16)\n    GK16 = _ceil_div(K, 16)\n    self.dim = (GC32, K, R + Rt - 1, S + St - 1, 32)\n    self.args = [(GK16, GC16, 1), (256, 1, 1), None, None, None, R * S * K, S * K, K, C]\n    super(BpropFilterTransform, self).__init__(lib, dtype, 'bprop', Rt, St, R, S, mode)",
            "def __init__(self, lib, dtype, C, K, Rt, St, R, S, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    GC32 = _ceil_div(C, 32)\n    GK32 = _ceil_div(K, 32)\n    GC16 = _ceil_div(GC32 * 32, 16)\n    GK16 = _ceil_div(K, 16)\n    self.dim = (GC32, K, R + Rt - 1, S + St - 1, 32)\n    self.args = [(GK16, GC16, 1), (256, 1, 1), None, None, None, R * S * K, S * K, K, C]\n    super(BpropFilterTransform, self).__init__(lib, dtype, 'bprop', Rt, St, R, S, mode)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, C, K):\n    super(FpropFilter_2x2_3x3, self).__init__(lib, dtype, C, K, 2, 2, 3, 3, 'cyclic')",
        "mutated": [
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n    super(FpropFilter_2x2_3x3, self).__init__(lib, dtype, C, K, 2, 2, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(FpropFilter_2x2_3x3, self).__init__(lib, dtype, C, K, 2, 2, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(FpropFilter_2x2_3x3, self).__init__(lib, dtype, C, K, 2, 2, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(FpropFilter_2x2_3x3, self).__init__(lib, dtype, C, K, 2, 2, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(FpropFilter_2x2_3x3, self).__init__(lib, dtype, C, K, 2, 2, 3, 3, 'cyclic')"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, C, K):\n    super(BpropFilter_2x2_3x3, self).__init__(lib, dtype, C, K, 2, 2, 3, 3, 'cyclic')",
        "mutated": [
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n    super(BpropFilter_2x2_3x3, self).__init__(lib, dtype, C, K, 2, 2, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(BpropFilter_2x2_3x3, self).__init__(lib, dtype, C, K, 2, 2, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(BpropFilter_2x2_3x3, self).__init__(lib, dtype, C, K, 2, 2, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(BpropFilter_2x2_3x3, self).__init__(lib, dtype, C, K, 2, 2, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(BpropFilter_2x2_3x3, self).__init__(lib, dtype, C, K, 2, 2, 3, 3, 'cyclic')"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, C, K):\n    super(FpropFilter_4x4_3x3, self).__init__(lib, dtype, C, K, 4, 4, 3, 3, 'cyclic')",
        "mutated": [
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n    super(FpropFilter_4x4_3x3, self).__init__(lib, dtype, C, K, 4, 4, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(FpropFilter_4x4_3x3, self).__init__(lib, dtype, C, K, 4, 4, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(FpropFilter_4x4_3x3, self).__init__(lib, dtype, C, K, 4, 4, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(FpropFilter_4x4_3x3, self).__init__(lib, dtype, C, K, 4, 4, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(FpropFilter_4x4_3x3, self).__init__(lib, dtype, C, K, 4, 4, 3, 3, 'cyclic')"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, C, K):\n    super(BpropFilter_4x4_3x3, self).__init__(lib, dtype, C, K, 4, 4, 3, 3, 'cyclic')",
        "mutated": [
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n    super(BpropFilter_4x4_3x3, self).__init__(lib, dtype, C, K, 4, 4, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(BpropFilter_4x4_3x3, self).__init__(lib, dtype, C, K, 4, 4, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(BpropFilter_4x4_3x3, self).__init__(lib, dtype, C, K, 4, 4, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(BpropFilter_4x4_3x3, self).__init__(lib, dtype, C, K, 4, 4, 3, 3, 'cyclic')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(BpropFilter_4x4_3x3, self).__init__(lib, dtype, C, K, 4, 4, 3, 3, 'cyclic')"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, C, K):\n    super(FpropFilter_2x2_5x5, self).__init__(lib, dtype, C, K, 2, 2, 5, 5, 'linear')",
        "mutated": [
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n    super(FpropFilter_2x2_5x5, self).__init__(lib, dtype, C, K, 2, 2, 5, 5, 'linear')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(FpropFilter_2x2_5x5, self).__init__(lib, dtype, C, K, 2, 2, 5, 5, 'linear')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(FpropFilter_2x2_5x5, self).__init__(lib, dtype, C, K, 2, 2, 5, 5, 'linear')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(FpropFilter_2x2_5x5, self).__init__(lib, dtype, C, K, 2, 2, 5, 5, 'linear')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(FpropFilter_2x2_5x5, self).__init__(lib, dtype, C, K, 2, 2, 5, 5, 'linear')"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, lib, dtype, C, K):\n    super(BpropFilter_2x2_5x5, self).__init__(lib, dtype, C, K, 2, 2, 5, 5, 'linear')",
        "mutated": [
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n    super(BpropFilter_2x2_5x5, self).__init__(lib, dtype, C, K, 2, 2, 5, 5, 'linear')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(BpropFilter_2x2_5x5, self).__init__(lib, dtype, C, K, 2, 2, 5, 5, 'linear')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(BpropFilter_2x2_5x5, self).__init__(lib, dtype, C, K, 2, 2, 5, 5, 'linear')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(BpropFilter_2x2_5x5, self).__init__(lib, dtype, C, K, 2, 2, 5, 5, 'linear')",
            "def __init__(self, lib, dtype, C, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(BpropFilter_2x2_5x5, self).__init__(lib, dtype, C, K, 2, 2, 5, 5, 'linear')"
        ]
    },
    {
        "func_name": "_get_filter_kernel",
        "original": "@context_dependent_memoize\ndef _get_filter_kernel(type_out, type_in, prop, Rt, St, R, S, conv_mode):\n    transforms = {'2x2_3x3': '\\n\\n    float T[4][3];\\n    #pragma unroll\\n    for (int i = 0; i < 3; i++)\\n    {\\n        float t0 = (I[0][i] + I[2][i]) * 0.5f;\\n        T[0][i] = I[0][i];\\n        T[1][i] = __fmaf_rn(I[1][i],  0.5f, t0);\\n        T[2][i] = __fmaf_rn(I[1][i], -0.5f, t0);\\n        T[3][i] = I[2][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        float t0 = (T[i][0] + T[i][2]) * 0.5f;\\n        %(output)s*(i*4 + 0)] = %(cvt_out)s(T[i][0]);\\n        %(output)s*(i*4 + 1)] = %(cvt_out)s(__fmaf_rn(T[i][1],  0.5f, t0));\\n        %(output)s*(i*4 + 2)] = %(cvt_out)s(__fmaf_rn(T[i][1], -0.5f, t0));\\n        %(output)s*(i*4 + 3)] = %(cvt_out)s(T[i][2]);\\n    }\\n', '4x4_3x3': '\\n\\n    float f25_88    =  25.0f /   88.0f;\\n    float f25_132   =  25.0f /  132.0f;\\n    float f25_198   =  25.0f /  198.0f;\\n    float f125_308  = 125.0f /  308.0f;\\n    float f400_441  = 400.0f /  441.0f;\\n    float f625_1078 = 625.0f / 1078.0f;\\n    float T[6][3];\\n    #pragma unroll\\n    for (int i = 0; i < 3; i++)\\n    {\\n        float t0 = f25_88 * I[2][i];\\n        float t1 = __fmaf_rn(I[0][i], -f625_1078, -t0);\\n        float t2 = __fmaf_rn(I[0][i],  f25_198,    t0);\\n        T[0][i] = f400_441 * I[0][i];\\n        T[1][i] = __fmaf_rn(I[1][i], -f125_308, t1);\\n        T[2][i] = __fmaf_rn(I[1][i],  f125_308, t1);\\n        T[3][i] = __fmaf_rn(I[1][i],  f25_132,  t2);\\n        T[4][i] = __fmaf_rn(I[1][i], -f25_132,  t2);\\n        T[5][i] = I[2][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = f25_88 *  T[i][2];\\n        float t1 = __fmaf_rn(T[i][0], -f625_1078, -t0);\\n        float t2 = __fmaf_rn(T[i][0],  f25_198,    t0);\\n        %(output)s*(i*6 + 0)] = %(cvt_out)s(f400_441 * T[i][0]);\\n        %(output)s*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(T[i][1], -f125_308, t1));\\n        %(output)s*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(T[i][1],  f125_308, t1));\\n        %(output)s*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(T[i][1],  f25_132,  t2));\\n        %(output)s*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(T[i][1], -f25_132,  t2));\\n        %(output)s*(i*6 + 5)] = %(cvt_out)s(T[i][2]);\\n    }\\n', '2x2_5x5': '\\n\\n    float f64_81   =   64.0f /  81.0f;\\n    float f128_243 = -128.0f / 243.0f;\\n    float f32_243  =   32.0f / 243.0f;\\n    float f32_81   =   32.0f /  81.0f;\\n    float f16_81   =   16.0f /  81.0f;\\n    float f8_27    =    8.0f /  27.0f;\\n    float f2_9     =    2.0f /   9.0f;\\n    float f4_9     =    4.0f /   9.0f;\\n    float f1_6     =   -1.0f /   6.0f;\\n    float f2_3     =    2.0f /   3.0f;\\n\\n    float T[6][5];\\n    #pragma unroll\\n    for (int i = 0; i < 5; i++)\\n    {\\n        float t0 = I[2][i] * f8_27;\\n        float t1 = __fmaf_rn(I[1][i], f32_81, I[3][i] * f2_9);\\n        float t2 = __fmaf_rn(I[1][i], f16_81, I[3][i] * f4_9);\\n        float t3 = __fmaf_rn(I[0][i], f128_243, __fmaf_rn(I[4][i], f1_6, -t0));\\n        float t4 = __fmaf_rn(I[0][i], f32_243,  __fmaf_rn(I[4][i], f2_3,  t0));\\n        T[0][i]  = I[0][i] * f64_81;\\n        T[1][i]  = t3 - t1;\\n        T[2][i]  = t3 + t1;\\n        T[3][i]  = t4 + t2;\\n        T[4][i]  = t4 - t2;\\n        T[5][i]  = I[4][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = T[i][2] * f8_27;\\n        float t1 = __fmaf_rn(T[i][1], f32_81,   T[i][3] * f2_9);\\n        float t2 = __fmaf_rn(T[i][1], f16_81,   T[i][3] * f4_9);\\n        float t3 = __fmaf_rn(T[i][0], f128_243, __fmaf_rn(T[i][4], f1_6, -t0));\\n        float t4 = __fmaf_rn(T[i][0], f32_243,  __fmaf_rn(T[i][4], f2_3,  t0));\\n        %(output)s*(i*6 + 0)] = %(cvt_out)s(T[i][0] * f64_81);\\n        %(output)s*(i*6 + 1)] = %(cvt_out)s(t3 - t1);\\n        %(output)s*(i*6 + 2)] = %(cvt_out)s(t3 + t1);\\n        %(output)s*(i*6 + 3)] = %(cvt_out)s(t4 + t2);\\n        %(output)s*(i*6 + 4)] = %(cvt_out)s(t4 - t2);\\n        %(output)s*(i*6 + 5)] = %(cvt_out)s(T[i][4]);\\n    }\\n'}\n    outputs = {'fprop': 'Out[32', 'bprop': 'share[ks][cs + 16'}\n    kernels = {'fprop': '\\n%(common)s\\n\\n__global__ void %(prop)s_filter_%(trans_name)s(\\n    %(type_out)s* Out, const %(type_in)s* In, int RSK, int SK, int K, int C)\\n{\\n    int tid  = threadIdx.x;\\n    int blkK = gridDim.x - blockIdx.x - 1;\\n    int c    = gridDim.y - blockIdx.y - 1;\\n    int k    = (blkK<<5) + tid;\\n\\n    bool valid_k = k < K;\\n\\n    int offset = c*RSK + k;\\n\\n    Out += blkK*C*32*%(RSt)s + c*32*%(RSt)s + tid;\\n\\n    float I[%(R)s][%(S)s];\\n    #pragma unroll\\n    for (int r = 0; r < %(R)s; r++)\\n    {\\n        if (r > 0) offset += SK;\\n\\n        #pragma unroll\\n        for (int s = 0; s < %(S)s; s++)\\n        {\\n            %(type_in)s val = 0;\\n            if (valid_k)\\n                val = __ldg(In + K*s + offset);\\n            %(conv_mode)s = %(cvt_in)s(val);\\n        }\\n    }\\n    %(trans_code)s\\n}\\n', 'bprop': '\\n%(common)s\\n\\n__global__ void %(prop)s_filter_%(trans_name)s(\\n    %(type_out)s* Out, const %(type_in)s* In, int RSK, int SK, int K, int C)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type_out)s __shared__ share[16][16*%(RSt)s + 2];\\n\\n    int tid  = threadIdx.x;\\n    int blkK = gridDim.x - blockIdx.x - 1;\\n    int blkC = gridDim.y - blockIdx.y - 1;\\n\\n    int cs = tid >> 4;\\n    int ks = tid & 15;\\n\\n    int c = blkC * 16 + cs;\\n    int k = blkK * 16 + ks;\\n\\n    bool valid_ck = c < C && k < K;\\n\\n    int offset = c*RSK + k;\\n\\n    float I[%(R)s][%(S)s];\\n    #pragma unroll\\n    for (int r = 0; r < %(R)s; r++)\\n    {\\n        if (r > 0) offset += SK;\\n\\n        #pragma unroll\\n        for (int s = 0; s < %(S)s; s++)\\n        {\\n            %(type_in)s val = 0;\\n            if (valid_ck)\\n                val = __ldg(In + K*s + offset);\\n            %(conv_mode)s = %(cvt_in)s(val);\\n        }\\n    }\\n    %(trans_code)s\\n\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ks = tid >> 4;\\n\\n    k = blkK*16 + ks;\\n\\n    if (k < K)\\n    {\\n        Out += (blkC>>1)*K*32*%(RSt)s + k*32*%(RSt)s + (blkC&1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < %(RSt)s; i++)\\n            Out[32*i] = share[ks][cs + 16*i];\\n    }\\n}\\n'}\n    filter_map = {'cyclic': {'fprop': 'I[r][s]', 'bprop': 'I[%d-r-1][%d-s-1]' % (R, S)}, 'linear': {'bprop': 'I[r][s]', 'fprop': 'I[%d-r-1][%d-s-1]' % (R, S)}}\n    common = _common_round['nearest'].get(type_out, '')\n    if type_in == 'f2':\n        common += _common_fp16_to_fp32\n    trans_name = '%sx%s_%sx%s' % (Rt, St, R, S)\n    trans_code = transforms[trans_name] % {'output': outputs[prop], 'cvt_out': _ew_types[type_out]['cvt_out']}\n    code = kernels[prop] % {'common': common, 'type_in': _ew_types[type_in]['type'], 'type_out': _ew_types[type_out]['type'], 'cvt_in': _ew_types[type_in]['cvt'], 'conv_mode': filter_map[conv_mode][prop], 'trans_name': trans_name, 'trans_code': trans_code, 'prop': prop, 'RSt': (R + Rt - 1) * (S + St - 1), 'R': R, 'S': S}\n    module = SourceModule(code)\n    kernel = module.get_function(prop + '_filter_' + trans_name)\n    kernel.prepare('PPIIII')\n    return kernel",
        "mutated": [
            "@context_dependent_memoize\ndef _get_filter_kernel(type_out, type_in, prop, Rt, St, R, S, conv_mode):\n    if False:\n        i = 10\n    transforms = {'2x2_3x3': '\\n\\n    float T[4][3];\\n    #pragma unroll\\n    for (int i = 0; i < 3; i++)\\n    {\\n        float t0 = (I[0][i] + I[2][i]) * 0.5f;\\n        T[0][i] = I[0][i];\\n        T[1][i] = __fmaf_rn(I[1][i],  0.5f, t0);\\n        T[2][i] = __fmaf_rn(I[1][i], -0.5f, t0);\\n        T[3][i] = I[2][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        float t0 = (T[i][0] + T[i][2]) * 0.5f;\\n        %(output)s*(i*4 + 0)] = %(cvt_out)s(T[i][0]);\\n        %(output)s*(i*4 + 1)] = %(cvt_out)s(__fmaf_rn(T[i][1],  0.5f, t0));\\n        %(output)s*(i*4 + 2)] = %(cvt_out)s(__fmaf_rn(T[i][1], -0.5f, t0));\\n        %(output)s*(i*4 + 3)] = %(cvt_out)s(T[i][2]);\\n    }\\n', '4x4_3x3': '\\n\\n    float f25_88    =  25.0f /   88.0f;\\n    float f25_132   =  25.0f /  132.0f;\\n    float f25_198   =  25.0f /  198.0f;\\n    float f125_308  = 125.0f /  308.0f;\\n    float f400_441  = 400.0f /  441.0f;\\n    float f625_1078 = 625.0f / 1078.0f;\\n    float T[6][3];\\n    #pragma unroll\\n    for (int i = 0; i < 3; i++)\\n    {\\n        float t0 = f25_88 * I[2][i];\\n        float t1 = __fmaf_rn(I[0][i], -f625_1078, -t0);\\n        float t2 = __fmaf_rn(I[0][i],  f25_198,    t0);\\n        T[0][i] = f400_441 * I[0][i];\\n        T[1][i] = __fmaf_rn(I[1][i], -f125_308, t1);\\n        T[2][i] = __fmaf_rn(I[1][i],  f125_308, t1);\\n        T[3][i] = __fmaf_rn(I[1][i],  f25_132,  t2);\\n        T[4][i] = __fmaf_rn(I[1][i], -f25_132,  t2);\\n        T[5][i] = I[2][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = f25_88 *  T[i][2];\\n        float t1 = __fmaf_rn(T[i][0], -f625_1078, -t0);\\n        float t2 = __fmaf_rn(T[i][0],  f25_198,    t0);\\n        %(output)s*(i*6 + 0)] = %(cvt_out)s(f400_441 * T[i][0]);\\n        %(output)s*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(T[i][1], -f125_308, t1));\\n        %(output)s*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(T[i][1],  f125_308, t1));\\n        %(output)s*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(T[i][1],  f25_132,  t2));\\n        %(output)s*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(T[i][1], -f25_132,  t2));\\n        %(output)s*(i*6 + 5)] = %(cvt_out)s(T[i][2]);\\n    }\\n', '2x2_5x5': '\\n\\n    float f64_81   =   64.0f /  81.0f;\\n    float f128_243 = -128.0f / 243.0f;\\n    float f32_243  =   32.0f / 243.0f;\\n    float f32_81   =   32.0f /  81.0f;\\n    float f16_81   =   16.0f /  81.0f;\\n    float f8_27    =    8.0f /  27.0f;\\n    float f2_9     =    2.0f /   9.0f;\\n    float f4_9     =    4.0f /   9.0f;\\n    float f1_6     =   -1.0f /   6.0f;\\n    float f2_3     =    2.0f /   3.0f;\\n\\n    float T[6][5];\\n    #pragma unroll\\n    for (int i = 0; i < 5; i++)\\n    {\\n        float t0 = I[2][i] * f8_27;\\n        float t1 = __fmaf_rn(I[1][i], f32_81, I[3][i] * f2_9);\\n        float t2 = __fmaf_rn(I[1][i], f16_81, I[3][i] * f4_9);\\n        float t3 = __fmaf_rn(I[0][i], f128_243, __fmaf_rn(I[4][i], f1_6, -t0));\\n        float t4 = __fmaf_rn(I[0][i], f32_243,  __fmaf_rn(I[4][i], f2_3,  t0));\\n        T[0][i]  = I[0][i] * f64_81;\\n        T[1][i]  = t3 - t1;\\n        T[2][i]  = t3 + t1;\\n        T[3][i]  = t4 + t2;\\n        T[4][i]  = t4 - t2;\\n        T[5][i]  = I[4][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = T[i][2] * f8_27;\\n        float t1 = __fmaf_rn(T[i][1], f32_81,   T[i][3] * f2_9);\\n        float t2 = __fmaf_rn(T[i][1], f16_81,   T[i][3] * f4_9);\\n        float t3 = __fmaf_rn(T[i][0], f128_243, __fmaf_rn(T[i][4], f1_6, -t0));\\n        float t4 = __fmaf_rn(T[i][0], f32_243,  __fmaf_rn(T[i][4], f2_3,  t0));\\n        %(output)s*(i*6 + 0)] = %(cvt_out)s(T[i][0] * f64_81);\\n        %(output)s*(i*6 + 1)] = %(cvt_out)s(t3 - t1);\\n        %(output)s*(i*6 + 2)] = %(cvt_out)s(t3 + t1);\\n        %(output)s*(i*6 + 3)] = %(cvt_out)s(t4 + t2);\\n        %(output)s*(i*6 + 4)] = %(cvt_out)s(t4 - t2);\\n        %(output)s*(i*6 + 5)] = %(cvt_out)s(T[i][4]);\\n    }\\n'}\n    outputs = {'fprop': 'Out[32', 'bprop': 'share[ks][cs + 16'}\n    kernels = {'fprop': '\\n%(common)s\\n\\n__global__ void %(prop)s_filter_%(trans_name)s(\\n    %(type_out)s* Out, const %(type_in)s* In, int RSK, int SK, int K, int C)\\n{\\n    int tid  = threadIdx.x;\\n    int blkK = gridDim.x - blockIdx.x - 1;\\n    int c    = gridDim.y - blockIdx.y - 1;\\n    int k    = (blkK<<5) + tid;\\n\\n    bool valid_k = k < K;\\n\\n    int offset = c*RSK + k;\\n\\n    Out += blkK*C*32*%(RSt)s + c*32*%(RSt)s + tid;\\n\\n    float I[%(R)s][%(S)s];\\n    #pragma unroll\\n    for (int r = 0; r < %(R)s; r++)\\n    {\\n        if (r > 0) offset += SK;\\n\\n        #pragma unroll\\n        for (int s = 0; s < %(S)s; s++)\\n        {\\n            %(type_in)s val = 0;\\n            if (valid_k)\\n                val = __ldg(In + K*s + offset);\\n            %(conv_mode)s = %(cvt_in)s(val);\\n        }\\n    }\\n    %(trans_code)s\\n}\\n', 'bprop': '\\n%(common)s\\n\\n__global__ void %(prop)s_filter_%(trans_name)s(\\n    %(type_out)s* Out, const %(type_in)s* In, int RSK, int SK, int K, int C)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type_out)s __shared__ share[16][16*%(RSt)s + 2];\\n\\n    int tid  = threadIdx.x;\\n    int blkK = gridDim.x - blockIdx.x - 1;\\n    int blkC = gridDim.y - blockIdx.y - 1;\\n\\n    int cs = tid >> 4;\\n    int ks = tid & 15;\\n\\n    int c = blkC * 16 + cs;\\n    int k = blkK * 16 + ks;\\n\\n    bool valid_ck = c < C && k < K;\\n\\n    int offset = c*RSK + k;\\n\\n    float I[%(R)s][%(S)s];\\n    #pragma unroll\\n    for (int r = 0; r < %(R)s; r++)\\n    {\\n        if (r > 0) offset += SK;\\n\\n        #pragma unroll\\n        for (int s = 0; s < %(S)s; s++)\\n        {\\n            %(type_in)s val = 0;\\n            if (valid_ck)\\n                val = __ldg(In + K*s + offset);\\n            %(conv_mode)s = %(cvt_in)s(val);\\n        }\\n    }\\n    %(trans_code)s\\n\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ks = tid >> 4;\\n\\n    k = blkK*16 + ks;\\n\\n    if (k < K)\\n    {\\n        Out += (blkC>>1)*K*32*%(RSt)s + k*32*%(RSt)s + (blkC&1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < %(RSt)s; i++)\\n            Out[32*i] = share[ks][cs + 16*i];\\n    }\\n}\\n'}\n    filter_map = {'cyclic': {'fprop': 'I[r][s]', 'bprop': 'I[%d-r-1][%d-s-1]' % (R, S)}, 'linear': {'bprop': 'I[r][s]', 'fprop': 'I[%d-r-1][%d-s-1]' % (R, S)}}\n    common = _common_round['nearest'].get(type_out, '')\n    if type_in == 'f2':\n        common += _common_fp16_to_fp32\n    trans_name = '%sx%s_%sx%s' % (Rt, St, R, S)\n    trans_code = transforms[trans_name] % {'output': outputs[prop], 'cvt_out': _ew_types[type_out]['cvt_out']}\n    code = kernels[prop] % {'common': common, 'type_in': _ew_types[type_in]['type'], 'type_out': _ew_types[type_out]['type'], 'cvt_in': _ew_types[type_in]['cvt'], 'conv_mode': filter_map[conv_mode][prop], 'trans_name': trans_name, 'trans_code': trans_code, 'prop': prop, 'RSt': (R + Rt - 1) * (S + St - 1), 'R': R, 'S': S}\n    module = SourceModule(code)\n    kernel = module.get_function(prop + '_filter_' + trans_name)\n    kernel.prepare('PPIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_filter_kernel(type_out, type_in, prop, Rt, St, R, S, conv_mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    transforms = {'2x2_3x3': '\\n\\n    float T[4][3];\\n    #pragma unroll\\n    for (int i = 0; i < 3; i++)\\n    {\\n        float t0 = (I[0][i] + I[2][i]) * 0.5f;\\n        T[0][i] = I[0][i];\\n        T[1][i] = __fmaf_rn(I[1][i],  0.5f, t0);\\n        T[2][i] = __fmaf_rn(I[1][i], -0.5f, t0);\\n        T[3][i] = I[2][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        float t0 = (T[i][0] + T[i][2]) * 0.5f;\\n        %(output)s*(i*4 + 0)] = %(cvt_out)s(T[i][0]);\\n        %(output)s*(i*4 + 1)] = %(cvt_out)s(__fmaf_rn(T[i][1],  0.5f, t0));\\n        %(output)s*(i*4 + 2)] = %(cvt_out)s(__fmaf_rn(T[i][1], -0.5f, t0));\\n        %(output)s*(i*4 + 3)] = %(cvt_out)s(T[i][2]);\\n    }\\n', '4x4_3x3': '\\n\\n    float f25_88    =  25.0f /   88.0f;\\n    float f25_132   =  25.0f /  132.0f;\\n    float f25_198   =  25.0f /  198.0f;\\n    float f125_308  = 125.0f /  308.0f;\\n    float f400_441  = 400.0f /  441.0f;\\n    float f625_1078 = 625.0f / 1078.0f;\\n    float T[6][3];\\n    #pragma unroll\\n    for (int i = 0; i < 3; i++)\\n    {\\n        float t0 = f25_88 * I[2][i];\\n        float t1 = __fmaf_rn(I[0][i], -f625_1078, -t0);\\n        float t2 = __fmaf_rn(I[0][i],  f25_198,    t0);\\n        T[0][i] = f400_441 * I[0][i];\\n        T[1][i] = __fmaf_rn(I[1][i], -f125_308, t1);\\n        T[2][i] = __fmaf_rn(I[1][i],  f125_308, t1);\\n        T[3][i] = __fmaf_rn(I[1][i],  f25_132,  t2);\\n        T[4][i] = __fmaf_rn(I[1][i], -f25_132,  t2);\\n        T[5][i] = I[2][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = f25_88 *  T[i][2];\\n        float t1 = __fmaf_rn(T[i][0], -f625_1078, -t0);\\n        float t2 = __fmaf_rn(T[i][0],  f25_198,    t0);\\n        %(output)s*(i*6 + 0)] = %(cvt_out)s(f400_441 * T[i][0]);\\n        %(output)s*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(T[i][1], -f125_308, t1));\\n        %(output)s*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(T[i][1],  f125_308, t1));\\n        %(output)s*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(T[i][1],  f25_132,  t2));\\n        %(output)s*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(T[i][1], -f25_132,  t2));\\n        %(output)s*(i*6 + 5)] = %(cvt_out)s(T[i][2]);\\n    }\\n', '2x2_5x5': '\\n\\n    float f64_81   =   64.0f /  81.0f;\\n    float f128_243 = -128.0f / 243.0f;\\n    float f32_243  =   32.0f / 243.0f;\\n    float f32_81   =   32.0f /  81.0f;\\n    float f16_81   =   16.0f /  81.0f;\\n    float f8_27    =    8.0f /  27.0f;\\n    float f2_9     =    2.0f /   9.0f;\\n    float f4_9     =    4.0f /   9.0f;\\n    float f1_6     =   -1.0f /   6.0f;\\n    float f2_3     =    2.0f /   3.0f;\\n\\n    float T[6][5];\\n    #pragma unroll\\n    for (int i = 0; i < 5; i++)\\n    {\\n        float t0 = I[2][i] * f8_27;\\n        float t1 = __fmaf_rn(I[1][i], f32_81, I[3][i] * f2_9);\\n        float t2 = __fmaf_rn(I[1][i], f16_81, I[3][i] * f4_9);\\n        float t3 = __fmaf_rn(I[0][i], f128_243, __fmaf_rn(I[4][i], f1_6, -t0));\\n        float t4 = __fmaf_rn(I[0][i], f32_243,  __fmaf_rn(I[4][i], f2_3,  t0));\\n        T[0][i]  = I[0][i] * f64_81;\\n        T[1][i]  = t3 - t1;\\n        T[2][i]  = t3 + t1;\\n        T[3][i]  = t4 + t2;\\n        T[4][i]  = t4 - t2;\\n        T[5][i]  = I[4][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = T[i][2] * f8_27;\\n        float t1 = __fmaf_rn(T[i][1], f32_81,   T[i][3] * f2_9);\\n        float t2 = __fmaf_rn(T[i][1], f16_81,   T[i][3] * f4_9);\\n        float t3 = __fmaf_rn(T[i][0], f128_243, __fmaf_rn(T[i][4], f1_6, -t0));\\n        float t4 = __fmaf_rn(T[i][0], f32_243,  __fmaf_rn(T[i][4], f2_3,  t0));\\n        %(output)s*(i*6 + 0)] = %(cvt_out)s(T[i][0] * f64_81);\\n        %(output)s*(i*6 + 1)] = %(cvt_out)s(t3 - t1);\\n        %(output)s*(i*6 + 2)] = %(cvt_out)s(t3 + t1);\\n        %(output)s*(i*6 + 3)] = %(cvt_out)s(t4 + t2);\\n        %(output)s*(i*6 + 4)] = %(cvt_out)s(t4 - t2);\\n        %(output)s*(i*6 + 5)] = %(cvt_out)s(T[i][4]);\\n    }\\n'}\n    outputs = {'fprop': 'Out[32', 'bprop': 'share[ks][cs + 16'}\n    kernels = {'fprop': '\\n%(common)s\\n\\n__global__ void %(prop)s_filter_%(trans_name)s(\\n    %(type_out)s* Out, const %(type_in)s* In, int RSK, int SK, int K, int C)\\n{\\n    int tid  = threadIdx.x;\\n    int blkK = gridDim.x - blockIdx.x - 1;\\n    int c    = gridDim.y - blockIdx.y - 1;\\n    int k    = (blkK<<5) + tid;\\n\\n    bool valid_k = k < K;\\n\\n    int offset = c*RSK + k;\\n\\n    Out += blkK*C*32*%(RSt)s + c*32*%(RSt)s + tid;\\n\\n    float I[%(R)s][%(S)s];\\n    #pragma unroll\\n    for (int r = 0; r < %(R)s; r++)\\n    {\\n        if (r > 0) offset += SK;\\n\\n        #pragma unroll\\n        for (int s = 0; s < %(S)s; s++)\\n        {\\n            %(type_in)s val = 0;\\n            if (valid_k)\\n                val = __ldg(In + K*s + offset);\\n            %(conv_mode)s = %(cvt_in)s(val);\\n        }\\n    }\\n    %(trans_code)s\\n}\\n', 'bprop': '\\n%(common)s\\n\\n__global__ void %(prop)s_filter_%(trans_name)s(\\n    %(type_out)s* Out, const %(type_in)s* In, int RSK, int SK, int K, int C)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type_out)s __shared__ share[16][16*%(RSt)s + 2];\\n\\n    int tid  = threadIdx.x;\\n    int blkK = gridDim.x - blockIdx.x - 1;\\n    int blkC = gridDim.y - blockIdx.y - 1;\\n\\n    int cs = tid >> 4;\\n    int ks = tid & 15;\\n\\n    int c = blkC * 16 + cs;\\n    int k = blkK * 16 + ks;\\n\\n    bool valid_ck = c < C && k < K;\\n\\n    int offset = c*RSK + k;\\n\\n    float I[%(R)s][%(S)s];\\n    #pragma unroll\\n    for (int r = 0; r < %(R)s; r++)\\n    {\\n        if (r > 0) offset += SK;\\n\\n        #pragma unroll\\n        for (int s = 0; s < %(S)s; s++)\\n        {\\n            %(type_in)s val = 0;\\n            if (valid_ck)\\n                val = __ldg(In + K*s + offset);\\n            %(conv_mode)s = %(cvt_in)s(val);\\n        }\\n    }\\n    %(trans_code)s\\n\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ks = tid >> 4;\\n\\n    k = blkK*16 + ks;\\n\\n    if (k < K)\\n    {\\n        Out += (blkC>>1)*K*32*%(RSt)s + k*32*%(RSt)s + (blkC&1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < %(RSt)s; i++)\\n            Out[32*i] = share[ks][cs + 16*i];\\n    }\\n}\\n'}\n    filter_map = {'cyclic': {'fprop': 'I[r][s]', 'bprop': 'I[%d-r-1][%d-s-1]' % (R, S)}, 'linear': {'bprop': 'I[r][s]', 'fprop': 'I[%d-r-1][%d-s-1]' % (R, S)}}\n    common = _common_round['nearest'].get(type_out, '')\n    if type_in == 'f2':\n        common += _common_fp16_to_fp32\n    trans_name = '%sx%s_%sx%s' % (Rt, St, R, S)\n    trans_code = transforms[trans_name] % {'output': outputs[prop], 'cvt_out': _ew_types[type_out]['cvt_out']}\n    code = kernels[prop] % {'common': common, 'type_in': _ew_types[type_in]['type'], 'type_out': _ew_types[type_out]['type'], 'cvt_in': _ew_types[type_in]['cvt'], 'conv_mode': filter_map[conv_mode][prop], 'trans_name': trans_name, 'trans_code': trans_code, 'prop': prop, 'RSt': (R + Rt - 1) * (S + St - 1), 'R': R, 'S': S}\n    module = SourceModule(code)\n    kernel = module.get_function(prop + '_filter_' + trans_name)\n    kernel.prepare('PPIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_filter_kernel(type_out, type_in, prop, Rt, St, R, S, conv_mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    transforms = {'2x2_3x3': '\\n\\n    float T[4][3];\\n    #pragma unroll\\n    for (int i = 0; i < 3; i++)\\n    {\\n        float t0 = (I[0][i] + I[2][i]) * 0.5f;\\n        T[0][i] = I[0][i];\\n        T[1][i] = __fmaf_rn(I[1][i],  0.5f, t0);\\n        T[2][i] = __fmaf_rn(I[1][i], -0.5f, t0);\\n        T[3][i] = I[2][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        float t0 = (T[i][0] + T[i][2]) * 0.5f;\\n        %(output)s*(i*4 + 0)] = %(cvt_out)s(T[i][0]);\\n        %(output)s*(i*4 + 1)] = %(cvt_out)s(__fmaf_rn(T[i][1],  0.5f, t0));\\n        %(output)s*(i*4 + 2)] = %(cvt_out)s(__fmaf_rn(T[i][1], -0.5f, t0));\\n        %(output)s*(i*4 + 3)] = %(cvt_out)s(T[i][2]);\\n    }\\n', '4x4_3x3': '\\n\\n    float f25_88    =  25.0f /   88.0f;\\n    float f25_132   =  25.0f /  132.0f;\\n    float f25_198   =  25.0f /  198.0f;\\n    float f125_308  = 125.0f /  308.0f;\\n    float f400_441  = 400.0f /  441.0f;\\n    float f625_1078 = 625.0f / 1078.0f;\\n    float T[6][3];\\n    #pragma unroll\\n    for (int i = 0; i < 3; i++)\\n    {\\n        float t0 = f25_88 * I[2][i];\\n        float t1 = __fmaf_rn(I[0][i], -f625_1078, -t0);\\n        float t2 = __fmaf_rn(I[0][i],  f25_198,    t0);\\n        T[0][i] = f400_441 * I[0][i];\\n        T[1][i] = __fmaf_rn(I[1][i], -f125_308, t1);\\n        T[2][i] = __fmaf_rn(I[1][i],  f125_308, t1);\\n        T[3][i] = __fmaf_rn(I[1][i],  f25_132,  t2);\\n        T[4][i] = __fmaf_rn(I[1][i], -f25_132,  t2);\\n        T[5][i] = I[2][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = f25_88 *  T[i][2];\\n        float t1 = __fmaf_rn(T[i][0], -f625_1078, -t0);\\n        float t2 = __fmaf_rn(T[i][0],  f25_198,    t0);\\n        %(output)s*(i*6 + 0)] = %(cvt_out)s(f400_441 * T[i][0]);\\n        %(output)s*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(T[i][1], -f125_308, t1));\\n        %(output)s*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(T[i][1],  f125_308, t1));\\n        %(output)s*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(T[i][1],  f25_132,  t2));\\n        %(output)s*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(T[i][1], -f25_132,  t2));\\n        %(output)s*(i*6 + 5)] = %(cvt_out)s(T[i][2]);\\n    }\\n', '2x2_5x5': '\\n\\n    float f64_81   =   64.0f /  81.0f;\\n    float f128_243 = -128.0f / 243.0f;\\n    float f32_243  =   32.0f / 243.0f;\\n    float f32_81   =   32.0f /  81.0f;\\n    float f16_81   =   16.0f /  81.0f;\\n    float f8_27    =    8.0f /  27.0f;\\n    float f2_9     =    2.0f /   9.0f;\\n    float f4_9     =    4.0f /   9.0f;\\n    float f1_6     =   -1.0f /   6.0f;\\n    float f2_3     =    2.0f /   3.0f;\\n\\n    float T[6][5];\\n    #pragma unroll\\n    for (int i = 0; i < 5; i++)\\n    {\\n        float t0 = I[2][i] * f8_27;\\n        float t1 = __fmaf_rn(I[1][i], f32_81, I[3][i] * f2_9);\\n        float t2 = __fmaf_rn(I[1][i], f16_81, I[3][i] * f4_9);\\n        float t3 = __fmaf_rn(I[0][i], f128_243, __fmaf_rn(I[4][i], f1_6, -t0));\\n        float t4 = __fmaf_rn(I[0][i], f32_243,  __fmaf_rn(I[4][i], f2_3,  t0));\\n        T[0][i]  = I[0][i] * f64_81;\\n        T[1][i]  = t3 - t1;\\n        T[2][i]  = t3 + t1;\\n        T[3][i]  = t4 + t2;\\n        T[4][i]  = t4 - t2;\\n        T[5][i]  = I[4][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = T[i][2] * f8_27;\\n        float t1 = __fmaf_rn(T[i][1], f32_81,   T[i][3] * f2_9);\\n        float t2 = __fmaf_rn(T[i][1], f16_81,   T[i][3] * f4_9);\\n        float t3 = __fmaf_rn(T[i][0], f128_243, __fmaf_rn(T[i][4], f1_6, -t0));\\n        float t4 = __fmaf_rn(T[i][0], f32_243,  __fmaf_rn(T[i][4], f2_3,  t0));\\n        %(output)s*(i*6 + 0)] = %(cvt_out)s(T[i][0] * f64_81);\\n        %(output)s*(i*6 + 1)] = %(cvt_out)s(t3 - t1);\\n        %(output)s*(i*6 + 2)] = %(cvt_out)s(t3 + t1);\\n        %(output)s*(i*6 + 3)] = %(cvt_out)s(t4 + t2);\\n        %(output)s*(i*6 + 4)] = %(cvt_out)s(t4 - t2);\\n        %(output)s*(i*6 + 5)] = %(cvt_out)s(T[i][4]);\\n    }\\n'}\n    outputs = {'fprop': 'Out[32', 'bprop': 'share[ks][cs + 16'}\n    kernels = {'fprop': '\\n%(common)s\\n\\n__global__ void %(prop)s_filter_%(trans_name)s(\\n    %(type_out)s* Out, const %(type_in)s* In, int RSK, int SK, int K, int C)\\n{\\n    int tid  = threadIdx.x;\\n    int blkK = gridDim.x - blockIdx.x - 1;\\n    int c    = gridDim.y - blockIdx.y - 1;\\n    int k    = (blkK<<5) + tid;\\n\\n    bool valid_k = k < K;\\n\\n    int offset = c*RSK + k;\\n\\n    Out += blkK*C*32*%(RSt)s + c*32*%(RSt)s + tid;\\n\\n    float I[%(R)s][%(S)s];\\n    #pragma unroll\\n    for (int r = 0; r < %(R)s; r++)\\n    {\\n        if (r > 0) offset += SK;\\n\\n        #pragma unroll\\n        for (int s = 0; s < %(S)s; s++)\\n        {\\n            %(type_in)s val = 0;\\n            if (valid_k)\\n                val = __ldg(In + K*s + offset);\\n            %(conv_mode)s = %(cvt_in)s(val);\\n        }\\n    }\\n    %(trans_code)s\\n}\\n', 'bprop': '\\n%(common)s\\n\\n__global__ void %(prop)s_filter_%(trans_name)s(\\n    %(type_out)s* Out, const %(type_in)s* In, int RSK, int SK, int K, int C)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type_out)s __shared__ share[16][16*%(RSt)s + 2];\\n\\n    int tid  = threadIdx.x;\\n    int blkK = gridDim.x - blockIdx.x - 1;\\n    int blkC = gridDim.y - blockIdx.y - 1;\\n\\n    int cs = tid >> 4;\\n    int ks = tid & 15;\\n\\n    int c = blkC * 16 + cs;\\n    int k = blkK * 16 + ks;\\n\\n    bool valid_ck = c < C && k < K;\\n\\n    int offset = c*RSK + k;\\n\\n    float I[%(R)s][%(S)s];\\n    #pragma unroll\\n    for (int r = 0; r < %(R)s; r++)\\n    {\\n        if (r > 0) offset += SK;\\n\\n        #pragma unroll\\n        for (int s = 0; s < %(S)s; s++)\\n        {\\n            %(type_in)s val = 0;\\n            if (valid_ck)\\n                val = __ldg(In + K*s + offset);\\n            %(conv_mode)s = %(cvt_in)s(val);\\n        }\\n    }\\n    %(trans_code)s\\n\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ks = tid >> 4;\\n\\n    k = blkK*16 + ks;\\n\\n    if (k < K)\\n    {\\n        Out += (blkC>>1)*K*32*%(RSt)s + k*32*%(RSt)s + (blkC&1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < %(RSt)s; i++)\\n            Out[32*i] = share[ks][cs + 16*i];\\n    }\\n}\\n'}\n    filter_map = {'cyclic': {'fprop': 'I[r][s]', 'bprop': 'I[%d-r-1][%d-s-1]' % (R, S)}, 'linear': {'bprop': 'I[r][s]', 'fprop': 'I[%d-r-1][%d-s-1]' % (R, S)}}\n    common = _common_round['nearest'].get(type_out, '')\n    if type_in == 'f2':\n        common += _common_fp16_to_fp32\n    trans_name = '%sx%s_%sx%s' % (Rt, St, R, S)\n    trans_code = transforms[trans_name] % {'output': outputs[prop], 'cvt_out': _ew_types[type_out]['cvt_out']}\n    code = kernels[prop] % {'common': common, 'type_in': _ew_types[type_in]['type'], 'type_out': _ew_types[type_out]['type'], 'cvt_in': _ew_types[type_in]['cvt'], 'conv_mode': filter_map[conv_mode][prop], 'trans_name': trans_name, 'trans_code': trans_code, 'prop': prop, 'RSt': (R + Rt - 1) * (S + St - 1), 'R': R, 'S': S}\n    module = SourceModule(code)\n    kernel = module.get_function(prop + '_filter_' + trans_name)\n    kernel.prepare('PPIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_filter_kernel(type_out, type_in, prop, Rt, St, R, S, conv_mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    transforms = {'2x2_3x3': '\\n\\n    float T[4][3];\\n    #pragma unroll\\n    for (int i = 0; i < 3; i++)\\n    {\\n        float t0 = (I[0][i] + I[2][i]) * 0.5f;\\n        T[0][i] = I[0][i];\\n        T[1][i] = __fmaf_rn(I[1][i],  0.5f, t0);\\n        T[2][i] = __fmaf_rn(I[1][i], -0.5f, t0);\\n        T[3][i] = I[2][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        float t0 = (T[i][0] + T[i][2]) * 0.5f;\\n        %(output)s*(i*4 + 0)] = %(cvt_out)s(T[i][0]);\\n        %(output)s*(i*4 + 1)] = %(cvt_out)s(__fmaf_rn(T[i][1],  0.5f, t0));\\n        %(output)s*(i*4 + 2)] = %(cvt_out)s(__fmaf_rn(T[i][1], -0.5f, t0));\\n        %(output)s*(i*4 + 3)] = %(cvt_out)s(T[i][2]);\\n    }\\n', '4x4_3x3': '\\n\\n    float f25_88    =  25.0f /   88.0f;\\n    float f25_132   =  25.0f /  132.0f;\\n    float f25_198   =  25.0f /  198.0f;\\n    float f125_308  = 125.0f /  308.0f;\\n    float f400_441  = 400.0f /  441.0f;\\n    float f625_1078 = 625.0f / 1078.0f;\\n    float T[6][3];\\n    #pragma unroll\\n    for (int i = 0; i < 3; i++)\\n    {\\n        float t0 = f25_88 * I[2][i];\\n        float t1 = __fmaf_rn(I[0][i], -f625_1078, -t0);\\n        float t2 = __fmaf_rn(I[0][i],  f25_198,    t0);\\n        T[0][i] = f400_441 * I[0][i];\\n        T[1][i] = __fmaf_rn(I[1][i], -f125_308, t1);\\n        T[2][i] = __fmaf_rn(I[1][i],  f125_308, t1);\\n        T[3][i] = __fmaf_rn(I[1][i],  f25_132,  t2);\\n        T[4][i] = __fmaf_rn(I[1][i], -f25_132,  t2);\\n        T[5][i] = I[2][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = f25_88 *  T[i][2];\\n        float t1 = __fmaf_rn(T[i][0], -f625_1078, -t0);\\n        float t2 = __fmaf_rn(T[i][0],  f25_198,    t0);\\n        %(output)s*(i*6 + 0)] = %(cvt_out)s(f400_441 * T[i][0]);\\n        %(output)s*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(T[i][1], -f125_308, t1));\\n        %(output)s*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(T[i][1],  f125_308, t1));\\n        %(output)s*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(T[i][1],  f25_132,  t2));\\n        %(output)s*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(T[i][1], -f25_132,  t2));\\n        %(output)s*(i*6 + 5)] = %(cvt_out)s(T[i][2]);\\n    }\\n', '2x2_5x5': '\\n\\n    float f64_81   =   64.0f /  81.0f;\\n    float f128_243 = -128.0f / 243.0f;\\n    float f32_243  =   32.0f / 243.0f;\\n    float f32_81   =   32.0f /  81.0f;\\n    float f16_81   =   16.0f /  81.0f;\\n    float f8_27    =    8.0f /  27.0f;\\n    float f2_9     =    2.0f /   9.0f;\\n    float f4_9     =    4.0f /   9.0f;\\n    float f1_6     =   -1.0f /   6.0f;\\n    float f2_3     =    2.0f /   3.0f;\\n\\n    float T[6][5];\\n    #pragma unroll\\n    for (int i = 0; i < 5; i++)\\n    {\\n        float t0 = I[2][i] * f8_27;\\n        float t1 = __fmaf_rn(I[1][i], f32_81, I[3][i] * f2_9);\\n        float t2 = __fmaf_rn(I[1][i], f16_81, I[3][i] * f4_9);\\n        float t3 = __fmaf_rn(I[0][i], f128_243, __fmaf_rn(I[4][i], f1_6, -t0));\\n        float t4 = __fmaf_rn(I[0][i], f32_243,  __fmaf_rn(I[4][i], f2_3,  t0));\\n        T[0][i]  = I[0][i] * f64_81;\\n        T[1][i]  = t3 - t1;\\n        T[2][i]  = t3 + t1;\\n        T[3][i]  = t4 + t2;\\n        T[4][i]  = t4 - t2;\\n        T[5][i]  = I[4][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = T[i][2] * f8_27;\\n        float t1 = __fmaf_rn(T[i][1], f32_81,   T[i][3] * f2_9);\\n        float t2 = __fmaf_rn(T[i][1], f16_81,   T[i][3] * f4_9);\\n        float t3 = __fmaf_rn(T[i][0], f128_243, __fmaf_rn(T[i][4], f1_6, -t0));\\n        float t4 = __fmaf_rn(T[i][0], f32_243,  __fmaf_rn(T[i][4], f2_3,  t0));\\n        %(output)s*(i*6 + 0)] = %(cvt_out)s(T[i][0] * f64_81);\\n        %(output)s*(i*6 + 1)] = %(cvt_out)s(t3 - t1);\\n        %(output)s*(i*6 + 2)] = %(cvt_out)s(t3 + t1);\\n        %(output)s*(i*6 + 3)] = %(cvt_out)s(t4 + t2);\\n        %(output)s*(i*6 + 4)] = %(cvt_out)s(t4 - t2);\\n        %(output)s*(i*6 + 5)] = %(cvt_out)s(T[i][4]);\\n    }\\n'}\n    outputs = {'fprop': 'Out[32', 'bprop': 'share[ks][cs + 16'}\n    kernels = {'fprop': '\\n%(common)s\\n\\n__global__ void %(prop)s_filter_%(trans_name)s(\\n    %(type_out)s* Out, const %(type_in)s* In, int RSK, int SK, int K, int C)\\n{\\n    int tid  = threadIdx.x;\\n    int blkK = gridDim.x - blockIdx.x - 1;\\n    int c    = gridDim.y - blockIdx.y - 1;\\n    int k    = (blkK<<5) + tid;\\n\\n    bool valid_k = k < K;\\n\\n    int offset = c*RSK + k;\\n\\n    Out += blkK*C*32*%(RSt)s + c*32*%(RSt)s + tid;\\n\\n    float I[%(R)s][%(S)s];\\n    #pragma unroll\\n    for (int r = 0; r < %(R)s; r++)\\n    {\\n        if (r > 0) offset += SK;\\n\\n        #pragma unroll\\n        for (int s = 0; s < %(S)s; s++)\\n        {\\n            %(type_in)s val = 0;\\n            if (valid_k)\\n                val = __ldg(In + K*s + offset);\\n            %(conv_mode)s = %(cvt_in)s(val);\\n        }\\n    }\\n    %(trans_code)s\\n}\\n', 'bprop': '\\n%(common)s\\n\\n__global__ void %(prop)s_filter_%(trans_name)s(\\n    %(type_out)s* Out, const %(type_in)s* In, int RSK, int SK, int K, int C)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type_out)s __shared__ share[16][16*%(RSt)s + 2];\\n\\n    int tid  = threadIdx.x;\\n    int blkK = gridDim.x - blockIdx.x - 1;\\n    int blkC = gridDim.y - blockIdx.y - 1;\\n\\n    int cs = tid >> 4;\\n    int ks = tid & 15;\\n\\n    int c = blkC * 16 + cs;\\n    int k = blkK * 16 + ks;\\n\\n    bool valid_ck = c < C && k < K;\\n\\n    int offset = c*RSK + k;\\n\\n    float I[%(R)s][%(S)s];\\n    #pragma unroll\\n    for (int r = 0; r < %(R)s; r++)\\n    {\\n        if (r > 0) offset += SK;\\n\\n        #pragma unroll\\n        for (int s = 0; s < %(S)s; s++)\\n        {\\n            %(type_in)s val = 0;\\n            if (valid_ck)\\n                val = __ldg(In + K*s + offset);\\n            %(conv_mode)s = %(cvt_in)s(val);\\n        }\\n    }\\n    %(trans_code)s\\n\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ks = tid >> 4;\\n\\n    k = blkK*16 + ks;\\n\\n    if (k < K)\\n    {\\n        Out += (blkC>>1)*K*32*%(RSt)s + k*32*%(RSt)s + (blkC&1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < %(RSt)s; i++)\\n            Out[32*i] = share[ks][cs + 16*i];\\n    }\\n}\\n'}\n    filter_map = {'cyclic': {'fprop': 'I[r][s]', 'bprop': 'I[%d-r-1][%d-s-1]' % (R, S)}, 'linear': {'bprop': 'I[r][s]', 'fprop': 'I[%d-r-1][%d-s-1]' % (R, S)}}\n    common = _common_round['nearest'].get(type_out, '')\n    if type_in == 'f2':\n        common += _common_fp16_to_fp32\n    trans_name = '%sx%s_%sx%s' % (Rt, St, R, S)\n    trans_code = transforms[trans_name] % {'output': outputs[prop], 'cvt_out': _ew_types[type_out]['cvt_out']}\n    code = kernels[prop] % {'common': common, 'type_in': _ew_types[type_in]['type'], 'type_out': _ew_types[type_out]['type'], 'cvt_in': _ew_types[type_in]['cvt'], 'conv_mode': filter_map[conv_mode][prop], 'trans_name': trans_name, 'trans_code': trans_code, 'prop': prop, 'RSt': (R + Rt - 1) * (S + St - 1), 'R': R, 'S': S}\n    module = SourceModule(code)\n    kernel = module.get_function(prop + '_filter_' + trans_name)\n    kernel.prepare('PPIIII')\n    return kernel",
            "@context_dependent_memoize\ndef _get_filter_kernel(type_out, type_in, prop, Rt, St, R, S, conv_mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    transforms = {'2x2_3x3': '\\n\\n    float T[4][3];\\n    #pragma unroll\\n    for (int i = 0; i < 3; i++)\\n    {\\n        float t0 = (I[0][i] + I[2][i]) * 0.5f;\\n        T[0][i] = I[0][i];\\n        T[1][i] = __fmaf_rn(I[1][i],  0.5f, t0);\\n        T[2][i] = __fmaf_rn(I[1][i], -0.5f, t0);\\n        T[3][i] = I[2][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 4; i++)\\n    {\\n        float t0 = (T[i][0] + T[i][2]) * 0.5f;\\n        %(output)s*(i*4 + 0)] = %(cvt_out)s(T[i][0]);\\n        %(output)s*(i*4 + 1)] = %(cvt_out)s(__fmaf_rn(T[i][1],  0.5f, t0));\\n        %(output)s*(i*4 + 2)] = %(cvt_out)s(__fmaf_rn(T[i][1], -0.5f, t0));\\n        %(output)s*(i*4 + 3)] = %(cvt_out)s(T[i][2]);\\n    }\\n', '4x4_3x3': '\\n\\n    float f25_88    =  25.0f /   88.0f;\\n    float f25_132   =  25.0f /  132.0f;\\n    float f25_198   =  25.0f /  198.0f;\\n    float f125_308  = 125.0f /  308.0f;\\n    float f400_441  = 400.0f /  441.0f;\\n    float f625_1078 = 625.0f / 1078.0f;\\n    float T[6][3];\\n    #pragma unroll\\n    for (int i = 0; i < 3; i++)\\n    {\\n        float t0 = f25_88 * I[2][i];\\n        float t1 = __fmaf_rn(I[0][i], -f625_1078, -t0);\\n        float t2 = __fmaf_rn(I[0][i],  f25_198,    t0);\\n        T[0][i] = f400_441 * I[0][i];\\n        T[1][i] = __fmaf_rn(I[1][i], -f125_308, t1);\\n        T[2][i] = __fmaf_rn(I[1][i],  f125_308, t1);\\n        T[3][i] = __fmaf_rn(I[1][i],  f25_132,  t2);\\n        T[4][i] = __fmaf_rn(I[1][i], -f25_132,  t2);\\n        T[5][i] = I[2][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = f25_88 *  T[i][2];\\n        float t1 = __fmaf_rn(T[i][0], -f625_1078, -t0);\\n        float t2 = __fmaf_rn(T[i][0],  f25_198,    t0);\\n        %(output)s*(i*6 + 0)] = %(cvt_out)s(f400_441 * T[i][0]);\\n        %(output)s*(i*6 + 1)] = %(cvt_out)s(__fmaf_rn(T[i][1], -f125_308, t1));\\n        %(output)s*(i*6 + 2)] = %(cvt_out)s(__fmaf_rn(T[i][1],  f125_308, t1));\\n        %(output)s*(i*6 + 3)] = %(cvt_out)s(__fmaf_rn(T[i][1],  f25_132,  t2));\\n        %(output)s*(i*6 + 4)] = %(cvt_out)s(__fmaf_rn(T[i][1], -f25_132,  t2));\\n        %(output)s*(i*6 + 5)] = %(cvt_out)s(T[i][2]);\\n    }\\n', '2x2_5x5': '\\n\\n    float f64_81   =   64.0f /  81.0f;\\n    float f128_243 = -128.0f / 243.0f;\\n    float f32_243  =   32.0f / 243.0f;\\n    float f32_81   =   32.0f /  81.0f;\\n    float f16_81   =   16.0f /  81.0f;\\n    float f8_27    =    8.0f /  27.0f;\\n    float f2_9     =    2.0f /   9.0f;\\n    float f4_9     =    4.0f /   9.0f;\\n    float f1_6     =   -1.0f /   6.0f;\\n    float f2_3     =    2.0f /   3.0f;\\n\\n    float T[6][5];\\n    #pragma unroll\\n    for (int i = 0; i < 5; i++)\\n    {\\n        float t0 = I[2][i] * f8_27;\\n        float t1 = __fmaf_rn(I[1][i], f32_81, I[3][i] * f2_9);\\n        float t2 = __fmaf_rn(I[1][i], f16_81, I[3][i] * f4_9);\\n        float t3 = __fmaf_rn(I[0][i], f128_243, __fmaf_rn(I[4][i], f1_6, -t0));\\n        float t4 = __fmaf_rn(I[0][i], f32_243,  __fmaf_rn(I[4][i], f2_3,  t0));\\n        T[0][i]  = I[0][i] * f64_81;\\n        T[1][i]  = t3 - t1;\\n        T[2][i]  = t3 + t1;\\n        T[3][i]  = t4 + t2;\\n        T[4][i]  = t4 - t2;\\n        T[5][i]  = I[4][i];\\n    }\\n    #pragma unroll\\n    for (int i = 0; i < 6; i++)\\n    {\\n        float t0 = T[i][2] * f8_27;\\n        float t1 = __fmaf_rn(T[i][1], f32_81,   T[i][3] * f2_9);\\n        float t2 = __fmaf_rn(T[i][1], f16_81,   T[i][3] * f4_9);\\n        float t3 = __fmaf_rn(T[i][0], f128_243, __fmaf_rn(T[i][4], f1_6, -t0));\\n        float t4 = __fmaf_rn(T[i][0], f32_243,  __fmaf_rn(T[i][4], f2_3,  t0));\\n        %(output)s*(i*6 + 0)] = %(cvt_out)s(T[i][0] * f64_81);\\n        %(output)s*(i*6 + 1)] = %(cvt_out)s(t3 - t1);\\n        %(output)s*(i*6 + 2)] = %(cvt_out)s(t3 + t1);\\n        %(output)s*(i*6 + 3)] = %(cvt_out)s(t4 + t2);\\n        %(output)s*(i*6 + 4)] = %(cvt_out)s(t4 - t2);\\n        %(output)s*(i*6 + 5)] = %(cvt_out)s(T[i][4]);\\n    }\\n'}\n    outputs = {'fprop': 'Out[32', 'bprop': 'share[ks][cs + 16'}\n    kernels = {'fprop': '\\n%(common)s\\n\\n__global__ void %(prop)s_filter_%(trans_name)s(\\n    %(type_out)s* Out, const %(type_in)s* In, int RSK, int SK, int K, int C)\\n{\\n    int tid  = threadIdx.x;\\n    int blkK = gridDim.x - blockIdx.x - 1;\\n    int c    = gridDim.y - blockIdx.y - 1;\\n    int k    = (blkK<<5) + tid;\\n\\n    bool valid_k = k < K;\\n\\n    int offset = c*RSK + k;\\n\\n    Out += blkK*C*32*%(RSt)s + c*32*%(RSt)s + tid;\\n\\n    float I[%(R)s][%(S)s];\\n    #pragma unroll\\n    for (int r = 0; r < %(R)s; r++)\\n    {\\n        if (r > 0) offset += SK;\\n\\n        #pragma unroll\\n        for (int s = 0; s < %(S)s; s++)\\n        {\\n            %(type_in)s val = 0;\\n            if (valid_k)\\n                val = __ldg(In + K*s + offset);\\n            %(conv_mode)s = %(cvt_in)s(val);\\n        }\\n    }\\n    %(trans_code)s\\n}\\n', 'bprop': '\\n%(common)s\\n\\n__global__ void %(prop)s_filter_%(trans_name)s(\\n    %(type_out)s* Out, const %(type_in)s* In, int RSK, int SK, int K, int C)\\n{\\n    // Add padding to avoid all but 1 shared bank conflict on loads\\n    %(type_out)s __shared__ share[16][16*%(RSt)s + 2];\\n\\n    int tid  = threadIdx.x;\\n    int blkK = gridDim.x - blockIdx.x - 1;\\n    int blkC = gridDim.y - blockIdx.y - 1;\\n\\n    int cs = tid >> 4;\\n    int ks = tid & 15;\\n\\n    int c = blkC * 16 + cs;\\n    int k = blkK * 16 + ks;\\n\\n    bool valid_ck = c < C && k < K;\\n\\n    int offset = c*RSK + k;\\n\\n    float I[%(R)s][%(S)s];\\n    #pragma unroll\\n    for (int r = 0; r < %(R)s; r++)\\n    {\\n        if (r > 0) offset += SK;\\n\\n        #pragma unroll\\n        for (int s = 0; s < %(S)s; s++)\\n        {\\n            %(type_in)s val = 0;\\n            if (valid_ck)\\n                val = __ldg(In + K*s + offset);\\n            %(conv_mode)s = %(cvt_in)s(val);\\n        }\\n    }\\n    %(trans_code)s\\n\\n    __syncthreads();\\n\\n    // now make c contiguous\\n    cs = tid & 15;\\n    ks = tid >> 4;\\n\\n    k = blkK*16 + ks;\\n\\n    if (k < K)\\n    {\\n        Out += (blkC>>1)*K*32*%(RSt)s + k*32*%(RSt)s + (blkC&1)*16 + cs;\\n\\n        #pragma unroll\\n        for (int i = 0; i < %(RSt)s; i++)\\n            Out[32*i] = share[ks][cs + 16*i];\\n    }\\n}\\n'}\n    filter_map = {'cyclic': {'fprop': 'I[r][s]', 'bprop': 'I[%d-r-1][%d-s-1]' % (R, S)}, 'linear': {'bprop': 'I[r][s]', 'fprop': 'I[%d-r-1][%d-s-1]' % (R, S)}}\n    common = _common_round['nearest'].get(type_out, '')\n    if type_in == 'f2':\n        common += _common_fp16_to_fp32\n    trans_name = '%sx%s_%sx%s' % (Rt, St, R, S)\n    trans_code = transforms[trans_name] % {'output': outputs[prop], 'cvt_out': _ew_types[type_out]['cvt_out']}\n    code = kernels[prop] % {'common': common, 'type_in': _ew_types[type_in]['type'], 'type_out': _ew_types[type_out]['type'], 'cvt_in': _ew_types[type_in]['cvt'], 'conv_mode': filter_map[conv_mode][prop], 'trans_name': trans_name, 'trans_code': trans_code, 'prop': prop, 'RSt': (R + Rt - 1) * (S + St - 1), 'R': R, 'S': S}\n    module = SourceModule(code)\n    kernel = module.get_function(prop + '_filter_' + trans_name)\n    kernel.prepare('PPIIII')\n    return kernel"
        ]
    }
]