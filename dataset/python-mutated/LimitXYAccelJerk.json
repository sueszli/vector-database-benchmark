[
    {
        "func_name": "initialize",
        "original": "def initialize(self) -> None:\n    super().initialize()\n    mycura = CuraApplication.getInstance().getGlobalContainerStack()\n    extruder = mycura.extruderList\n    accel_print = extruder[0].getProperty('acceleration_print', 'value')\n    accel_travel = extruder[0].getProperty('acceleration_travel', 'value')\n    jerk_print_old = extruder[0].getProperty('jerk_print', 'value')\n    jerk_travel_old = extruder[0].getProperty('jerk_travel', 'value')\n    self._instance.setProperty('x_accel_limit', 'value', round(accel_print))\n    self._instance.setProperty('y_accel_limit', 'value', round(accel_print))\n    self._instance.setProperty('x_jerk', 'value', jerk_print_old)\n    self._instance.setProperty('y_jerk', 'value', jerk_print_old)\n    ext_count = int(mycura.getProperty('machine_extruder_count', 'value'))\n    machine_name = str(mycura.getProperty('machine_name', 'value'))\n    if str(mycura.getProperty('machine_gcode_flavor', 'value')) == 'RepRap (RepRap)':\n        self._instance.setProperty('jerk_cmd', 'value', 'reprap_flavor')\n    else:\n        self._instance.setProperty('jerk_cmd', 'value', 'marlin_flavor')\n    firmware_flavor = str(mycura.getProperty('machine_gcode_flavor', 'value'))\n    if 'Ultimaker' in machine_name or 'UltiGCode' in firmware_flavor or 'Griffin' in firmware_flavor:\n        Message(text=\"<NOTICE> [Limit the X-Y Accel/Jerk] DID NOT RUN because Ultimaker printers don't have sliding beds.\").show()\n    if ext_count > 1:\n        Message(text=\"<NOTICE> 'Limit the X-Y Accel/Jerk': The post processor treats all extruders the same.  If you have multiple extruders they will all be subject to the same Accel and Jerk limits imposed.  If you have different Travel and Print Accel they will also be subject to the same limits.  If that is not acceptable then you should not use this Post Processor.\").show()",
        "mutated": [
            "def initialize(self) -> None:\n    if False:\n        i = 10\n    super().initialize()\n    mycura = CuraApplication.getInstance().getGlobalContainerStack()\n    extruder = mycura.extruderList\n    accel_print = extruder[0].getProperty('acceleration_print', 'value')\n    accel_travel = extruder[0].getProperty('acceleration_travel', 'value')\n    jerk_print_old = extruder[0].getProperty('jerk_print', 'value')\n    jerk_travel_old = extruder[0].getProperty('jerk_travel', 'value')\n    self._instance.setProperty('x_accel_limit', 'value', round(accel_print))\n    self._instance.setProperty('y_accel_limit', 'value', round(accel_print))\n    self._instance.setProperty('x_jerk', 'value', jerk_print_old)\n    self._instance.setProperty('y_jerk', 'value', jerk_print_old)\n    ext_count = int(mycura.getProperty('machine_extruder_count', 'value'))\n    machine_name = str(mycura.getProperty('machine_name', 'value'))\n    if str(mycura.getProperty('machine_gcode_flavor', 'value')) == 'RepRap (RepRap)':\n        self._instance.setProperty('jerk_cmd', 'value', 'reprap_flavor')\n    else:\n        self._instance.setProperty('jerk_cmd', 'value', 'marlin_flavor')\n    firmware_flavor = str(mycura.getProperty('machine_gcode_flavor', 'value'))\n    if 'Ultimaker' in machine_name or 'UltiGCode' in firmware_flavor or 'Griffin' in firmware_flavor:\n        Message(text=\"<NOTICE> [Limit the X-Y Accel/Jerk] DID NOT RUN because Ultimaker printers don't have sliding beds.\").show()\n    if ext_count > 1:\n        Message(text=\"<NOTICE> 'Limit the X-Y Accel/Jerk': The post processor treats all extruders the same.  If you have multiple extruders they will all be subject to the same Accel and Jerk limits imposed.  If you have different Travel and Print Accel they will also be subject to the same limits.  If that is not acceptable then you should not use this Post Processor.\").show()",
            "def initialize(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().initialize()\n    mycura = CuraApplication.getInstance().getGlobalContainerStack()\n    extruder = mycura.extruderList\n    accel_print = extruder[0].getProperty('acceleration_print', 'value')\n    accel_travel = extruder[0].getProperty('acceleration_travel', 'value')\n    jerk_print_old = extruder[0].getProperty('jerk_print', 'value')\n    jerk_travel_old = extruder[0].getProperty('jerk_travel', 'value')\n    self._instance.setProperty('x_accel_limit', 'value', round(accel_print))\n    self._instance.setProperty('y_accel_limit', 'value', round(accel_print))\n    self._instance.setProperty('x_jerk', 'value', jerk_print_old)\n    self._instance.setProperty('y_jerk', 'value', jerk_print_old)\n    ext_count = int(mycura.getProperty('machine_extruder_count', 'value'))\n    machine_name = str(mycura.getProperty('machine_name', 'value'))\n    if str(mycura.getProperty('machine_gcode_flavor', 'value')) == 'RepRap (RepRap)':\n        self._instance.setProperty('jerk_cmd', 'value', 'reprap_flavor')\n    else:\n        self._instance.setProperty('jerk_cmd', 'value', 'marlin_flavor')\n    firmware_flavor = str(mycura.getProperty('machine_gcode_flavor', 'value'))\n    if 'Ultimaker' in machine_name or 'UltiGCode' in firmware_flavor or 'Griffin' in firmware_flavor:\n        Message(text=\"<NOTICE> [Limit the X-Y Accel/Jerk] DID NOT RUN because Ultimaker printers don't have sliding beds.\").show()\n    if ext_count > 1:\n        Message(text=\"<NOTICE> 'Limit the X-Y Accel/Jerk': The post processor treats all extruders the same.  If you have multiple extruders they will all be subject to the same Accel and Jerk limits imposed.  If you have different Travel and Print Accel they will also be subject to the same limits.  If that is not acceptable then you should not use this Post Processor.\").show()",
            "def initialize(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().initialize()\n    mycura = CuraApplication.getInstance().getGlobalContainerStack()\n    extruder = mycura.extruderList\n    accel_print = extruder[0].getProperty('acceleration_print', 'value')\n    accel_travel = extruder[0].getProperty('acceleration_travel', 'value')\n    jerk_print_old = extruder[0].getProperty('jerk_print', 'value')\n    jerk_travel_old = extruder[0].getProperty('jerk_travel', 'value')\n    self._instance.setProperty('x_accel_limit', 'value', round(accel_print))\n    self._instance.setProperty('y_accel_limit', 'value', round(accel_print))\n    self._instance.setProperty('x_jerk', 'value', jerk_print_old)\n    self._instance.setProperty('y_jerk', 'value', jerk_print_old)\n    ext_count = int(mycura.getProperty('machine_extruder_count', 'value'))\n    machine_name = str(mycura.getProperty('machine_name', 'value'))\n    if str(mycura.getProperty('machine_gcode_flavor', 'value')) == 'RepRap (RepRap)':\n        self._instance.setProperty('jerk_cmd', 'value', 'reprap_flavor')\n    else:\n        self._instance.setProperty('jerk_cmd', 'value', 'marlin_flavor')\n    firmware_flavor = str(mycura.getProperty('machine_gcode_flavor', 'value'))\n    if 'Ultimaker' in machine_name or 'UltiGCode' in firmware_flavor or 'Griffin' in firmware_flavor:\n        Message(text=\"<NOTICE> [Limit the X-Y Accel/Jerk] DID NOT RUN because Ultimaker printers don't have sliding beds.\").show()\n    if ext_count > 1:\n        Message(text=\"<NOTICE> 'Limit the X-Y Accel/Jerk': The post processor treats all extruders the same.  If you have multiple extruders they will all be subject to the same Accel and Jerk limits imposed.  If you have different Travel and Print Accel they will also be subject to the same limits.  If that is not acceptable then you should not use this Post Processor.\").show()",
            "def initialize(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().initialize()\n    mycura = CuraApplication.getInstance().getGlobalContainerStack()\n    extruder = mycura.extruderList\n    accel_print = extruder[0].getProperty('acceleration_print', 'value')\n    accel_travel = extruder[0].getProperty('acceleration_travel', 'value')\n    jerk_print_old = extruder[0].getProperty('jerk_print', 'value')\n    jerk_travel_old = extruder[0].getProperty('jerk_travel', 'value')\n    self._instance.setProperty('x_accel_limit', 'value', round(accel_print))\n    self._instance.setProperty('y_accel_limit', 'value', round(accel_print))\n    self._instance.setProperty('x_jerk', 'value', jerk_print_old)\n    self._instance.setProperty('y_jerk', 'value', jerk_print_old)\n    ext_count = int(mycura.getProperty('machine_extruder_count', 'value'))\n    machine_name = str(mycura.getProperty('machine_name', 'value'))\n    if str(mycura.getProperty('machine_gcode_flavor', 'value')) == 'RepRap (RepRap)':\n        self._instance.setProperty('jerk_cmd', 'value', 'reprap_flavor')\n    else:\n        self._instance.setProperty('jerk_cmd', 'value', 'marlin_flavor')\n    firmware_flavor = str(mycura.getProperty('machine_gcode_flavor', 'value'))\n    if 'Ultimaker' in machine_name or 'UltiGCode' in firmware_flavor or 'Griffin' in firmware_flavor:\n        Message(text=\"<NOTICE> [Limit the X-Y Accel/Jerk] DID NOT RUN because Ultimaker printers don't have sliding beds.\").show()\n    if ext_count > 1:\n        Message(text=\"<NOTICE> 'Limit the X-Y Accel/Jerk': The post processor treats all extruders the same.  If you have multiple extruders they will all be subject to the same Accel and Jerk limits imposed.  If you have different Travel and Print Accel they will also be subject to the same limits.  If that is not acceptable then you should not use this Post Processor.\").show()",
            "def initialize(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().initialize()\n    mycura = CuraApplication.getInstance().getGlobalContainerStack()\n    extruder = mycura.extruderList\n    accel_print = extruder[0].getProperty('acceleration_print', 'value')\n    accel_travel = extruder[0].getProperty('acceleration_travel', 'value')\n    jerk_print_old = extruder[0].getProperty('jerk_print', 'value')\n    jerk_travel_old = extruder[0].getProperty('jerk_travel', 'value')\n    self._instance.setProperty('x_accel_limit', 'value', round(accel_print))\n    self._instance.setProperty('y_accel_limit', 'value', round(accel_print))\n    self._instance.setProperty('x_jerk', 'value', jerk_print_old)\n    self._instance.setProperty('y_jerk', 'value', jerk_print_old)\n    ext_count = int(mycura.getProperty('machine_extruder_count', 'value'))\n    machine_name = str(mycura.getProperty('machine_name', 'value'))\n    if str(mycura.getProperty('machine_gcode_flavor', 'value')) == 'RepRap (RepRap)':\n        self._instance.setProperty('jerk_cmd', 'value', 'reprap_flavor')\n    else:\n        self._instance.setProperty('jerk_cmd', 'value', 'marlin_flavor')\n    firmware_flavor = str(mycura.getProperty('machine_gcode_flavor', 'value'))\n    if 'Ultimaker' in machine_name or 'UltiGCode' in firmware_flavor or 'Griffin' in firmware_flavor:\n        Message(text=\"<NOTICE> [Limit the X-Y Accel/Jerk] DID NOT RUN because Ultimaker printers don't have sliding beds.\").show()\n    if ext_count > 1:\n        Message(text=\"<NOTICE> 'Limit the X-Y Accel/Jerk': The post processor treats all extruders the same.  If you have multiple extruders they will all be subject to the same Accel and Jerk limits imposed.  If you have different Travel and Print Accel they will also be subject to the same limits.  If that is not acceptable then you should not use this Post Processor.\").show()"
        ]
    },
    {
        "func_name": "getSettingDataString",
        "original": "def getSettingDataString(self):\n    return '{\\n            \"name\": \"Limit the X-Y Accel/Jerk (all extruders equal)\",\\n            \"key\": \"LimitXYAccelJerk\",\\n            \"metadata\": {},\\n            \"version\": 2,\\n            \"settings\":\\n            {\\n                \"type_of_change\":\\n                {\\n                    \"label\": \"Immediate or Gradual change\",\\n                    \"description\": \"An \\'Immediate\\' change will insert the new numbers immediately at the Start Layer.  A \\'Gradual\\' change will transition from the starting Accel to the new Accel limit across a range of layers.\",\\n                    \"type\": \"enum\",\\n                    \"options\": {\\n                        \"immediate_change\": \"Immediate\",\\n                        \"gradual_change\": \"Gradual\"},\\n                    \"default_value\": \"immediate_change\"\\n                },\\n                \"x_accel_limit\":\\n                {\\n                    \"label\": \"X MAX Acceleration\",\\n                    \"description\": \"If this number is lower than the \\'X Print Accel\\' in Cura then this will limit the Accel on the X axis.  Enter the Maximum Acceleration value for the X axis.  This will affect both Print and Travel Accel.  If you enable an End Layer then at the end of that layer the Accel Limit will be reset (unless you choose \\'Gradual\\' in which case the new limit goes to the top layer).\",\\n                    \"type\": \"int\",\\n                    \"enabled\": true,\\n                    \"minimum_value\": 50,\\n                    \"unit\": \"mm/sec\u00b2 \",\\n                    \"default_value\": 500\\n                },\\n                \"y_accel_limit\":\\n                {\\n                    \"label\": \"Y MAX Acceleration\",\\n                    \"description\": \"If this number is lower than the Y accel in Cura then this will limit the Accel on the Y axis.  Enter the Maximum Acceleration value for the Y axis.  This will affect both Print and Travel Accel.  If you enable an End Layer then at the end of that layer the Accel Limit will be reset (unless you choose \\'Gradual\\' in which case the new limit goes to the top layer).\",\\n                    \"type\": \"int\",\\n                    \"enabled\": true,\\n                    \"minimum_value\": 50,\\n                    \"unit\": \"mm/sec\u00b2 \",\\n                    \"default_value\": 500\\n                },\\n                \"jerk_enable\":\\n                {\\n                    \"label\": \"Change the Jerk\",\\n                    \"description\": \"Whether to change the Jerk values.\",\\n                    \"type\": \"bool\",\\n                    \"enabled\": true,\\n                    \"default_value\": false\\n                },\\n                \"jerk_cmd\":\\n                {\\n                    \"label\": \"G-Code Jerk Command\",\\n                    \"description\": \"Marlin uses M205.  RepRap might use M566.\",\\n                    \"type\": \"enum\",\\n                    \"options\": {\\n                        \"marlin_flavor\": \"M205\",\\n                        \"reprap_flavor\": \"M566\"},\\n                    \"default_value\": \"marlin_flavor\",\\n                    \"enabled\":  \"jerk_enable\"\\n                },\\n                \"x_jerk\":\\n                {\\n                    \"label\": \"    X jerk\",\\n                    \"description\": \"Enter the Jerk value for the X axis.  Enter \\'0\\' to use the existing X Jerk.  This setting will affect both the Print and Travel jerk.\",\\n                    \"type\": \"int\",\\n                    \"enabled\": \"jerk_enable\",\\n                    \"unit\": \"mm/sec \",\\n                    \"default_value\": 8\\n                },\\n                \"y_jerk\":\\n                {\\n                    \"label\": \"    Y jerk\",\\n                    \"description\": \"Enter the Jerk value for the Y axis. Enter \\'0\\' to use the existing Y Jerk.    This setting will affect both the Print and Travel jerk.\",\\n                    \"type\": \"int\",\\n                    \"enabled\": \"jerk_enable\",\\n                    \"unit\": \"mm/sec \",\\n                    \"default_value\": 8\\n                },\\n                \"start_layer\":\\n                {\\n                    \"label\": \"From Start of Layer:\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter the Layer to start the changes at. The minimum is Layer 1.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": 1,\\n                    \"minimum_value\": 1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'immediate_change\\'\"\\n                },\\n                \"end_layer\":\\n                {\\n                    \"label\": \"To End of Layer\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter \\'-1\\' for the entire file or enter a layer number.  The changes will end at your \\'End Layer\\' and revert back to the original numbers.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": -1,\\n                    \"minimum_value\": -1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'immediate_change\\'\"\\n                },\\n                \"gradient_start_layer\":\\n                {\\n                    \"label\": \"     Gradual From Layer:\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter the Layer to start the changes at. The minimum is Layer 1.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": 1,\\n                    \"minimum_value\": 1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'gradual_change\\'\"\\n                },\\n                \"gradient_end_layer\":\\n                {\\n                    \"label\": \"     Gradual To Layer\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter \\'-1\\' for the top layer or enter a layer number.  The last \\'Gradual\\' change will continue to the end of the file.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": -1,\\n                    \"minimum_value\": -1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'gradual_change\\'\"\\n                }\\n            }\\n        }'",
        "mutated": [
            "def getSettingDataString(self):\n    if False:\n        i = 10\n    return '{\\n            \"name\": \"Limit the X-Y Accel/Jerk (all extruders equal)\",\\n            \"key\": \"LimitXYAccelJerk\",\\n            \"metadata\": {},\\n            \"version\": 2,\\n            \"settings\":\\n            {\\n                \"type_of_change\":\\n                {\\n                    \"label\": \"Immediate or Gradual change\",\\n                    \"description\": \"An \\'Immediate\\' change will insert the new numbers immediately at the Start Layer.  A \\'Gradual\\' change will transition from the starting Accel to the new Accel limit across a range of layers.\",\\n                    \"type\": \"enum\",\\n                    \"options\": {\\n                        \"immediate_change\": \"Immediate\",\\n                        \"gradual_change\": \"Gradual\"},\\n                    \"default_value\": \"immediate_change\"\\n                },\\n                \"x_accel_limit\":\\n                {\\n                    \"label\": \"X MAX Acceleration\",\\n                    \"description\": \"If this number is lower than the \\'X Print Accel\\' in Cura then this will limit the Accel on the X axis.  Enter the Maximum Acceleration value for the X axis.  This will affect both Print and Travel Accel.  If you enable an End Layer then at the end of that layer the Accel Limit will be reset (unless you choose \\'Gradual\\' in which case the new limit goes to the top layer).\",\\n                    \"type\": \"int\",\\n                    \"enabled\": true,\\n                    \"minimum_value\": 50,\\n                    \"unit\": \"mm/sec\u00b2 \",\\n                    \"default_value\": 500\\n                },\\n                \"y_accel_limit\":\\n                {\\n                    \"label\": \"Y MAX Acceleration\",\\n                    \"description\": \"If this number is lower than the Y accel in Cura then this will limit the Accel on the Y axis.  Enter the Maximum Acceleration value for the Y axis.  This will affect both Print and Travel Accel.  If you enable an End Layer then at the end of that layer the Accel Limit will be reset (unless you choose \\'Gradual\\' in which case the new limit goes to the top layer).\",\\n                    \"type\": \"int\",\\n                    \"enabled\": true,\\n                    \"minimum_value\": 50,\\n                    \"unit\": \"mm/sec\u00b2 \",\\n                    \"default_value\": 500\\n                },\\n                \"jerk_enable\":\\n                {\\n                    \"label\": \"Change the Jerk\",\\n                    \"description\": \"Whether to change the Jerk values.\",\\n                    \"type\": \"bool\",\\n                    \"enabled\": true,\\n                    \"default_value\": false\\n                },\\n                \"jerk_cmd\":\\n                {\\n                    \"label\": \"G-Code Jerk Command\",\\n                    \"description\": \"Marlin uses M205.  RepRap might use M566.\",\\n                    \"type\": \"enum\",\\n                    \"options\": {\\n                        \"marlin_flavor\": \"M205\",\\n                        \"reprap_flavor\": \"M566\"},\\n                    \"default_value\": \"marlin_flavor\",\\n                    \"enabled\":  \"jerk_enable\"\\n                },\\n                \"x_jerk\":\\n                {\\n                    \"label\": \"    X jerk\",\\n                    \"description\": \"Enter the Jerk value for the X axis.  Enter \\'0\\' to use the existing X Jerk.  This setting will affect both the Print and Travel jerk.\",\\n                    \"type\": \"int\",\\n                    \"enabled\": \"jerk_enable\",\\n                    \"unit\": \"mm/sec \",\\n                    \"default_value\": 8\\n                },\\n                \"y_jerk\":\\n                {\\n                    \"label\": \"    Y jerk\",\\n                    \"description\": \"Enter the Jerk value for the Y axis. Enter \\'0\\' to use the existing Y Jerk.    This setting will affect both the Print and Travel jerk.\",\\n                    \"type\": \"int\",\\n                    \"enabled\": \"jerk_enable\",\\n                    \"unit\": \"mm/sec \",\\n                    \"default_value\": 8\\n                },\\n                \"start_layer\":\\n                {\\n                    \"label\": \"From Start of Layer:\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter the Layer to start the changes at. The minimum is Layer 1.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": 1,\\n                    \"minimum_value\": 1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'immediate_change\\'\"\\n                },\\n                \"end_layer\":\\n                {\\n                    \"label\": \"To End of Layer\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter \\'-1\\' for the entire file or enter a layer number.  The changes will end at your \\'End Layer\\' and revert back to the original numbers.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": -1,\\n                    \"minimum_value\": -1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'immediate_change\\'\"\\n                },\\n                \"gradient_start_layer\":\\n                {\\n                    \"label\": \"     Gradual From Layer:\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter the Layer to start the changes at. The minimum is Layer 1.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": 1,\\n                    \"minimum_value\": 1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'gradual_change\\'\"\\n                },\\n                \"gradient_end_layer\":\\n                {\\n                    \"label\": \"     Gradual To Layer\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter \\'-1\\' for the top layer or enter a layer number.  The last \\'Gradual\\' change will continue to the end of the file.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": -1,\\n                    \"minimum_value\": -1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'gradual_change\\'\"\\n                }\\n            }\\n        }'",
            "def getSettingDataString(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return '{\\n            \"name\": \"Limit the X-Y Accel/Jerk (all extruders equal)\",\\n            \"key\": \"LimitXYAccelJerk\",\\n            \"metadata\": {},\\n            \"version\": 2,\\n            \"settings\":\\n            {\\n                \"type_of_change\":\\n                {\\n                    \"label\": \"Immediate or Gradual change\",\\n                    \"description\": \"An \\'Immediate\\' change will insert the new numbers immediately at the Start Layer.  A \\'Gradual\\' change will transition from the starting Accel to the new Accel limit across a range of layers.\",\\n                    \"type\": \"enum\",\\n                    \"options\": {\\n                        \"immediate_change\": \"Immediate\",\\n                        \"gradual_change\": \"Gradual\"},\\n                    \"default_value\": \"immediate_change\"\\n                },\\n                \"x_accel_limit\":\\n                {\\n                    \"label\": \"X MAX Acceleration\",\\n                    \"description\": \"If this number is lower than the \\'X Print Accel\\' in Cura then this will limit the Accel on the X axis.  Enter the Maximum Acceleration value for the X axis.  This will affect both Print and Travel Accel.  If you enable an End Layer then at the end of that layer the Accel Limit will be reset (unless you choose \\'Gradual\\' in which case the new limit goes to the top layer).\",\\n                    \"type\": \"int\",\\n                    \"enabled\": true,\\n                    \"minimum_value\": 50,\\n                    \"unit\": \"mm/sec\u00b2 \",\\n                    \"default_value\": 500\\n                },\\n                \"y_accel_limit\":\\n                {\\n                    \"label\": \"Y MAX Acceleration\",\\n                    \"description\": \"If this number is lower than the Y accel in Cura then this will limit the Accel on the Y axis.  Enter the Maximum Acceleration value for the Y axis.  This will affect both Print and Travel Accel.  If you enable an End Layer then at the end of that layer the Accel Limit will be reset (unless you choose \\'Gradual\\' in which case the new limit goes to the top layer).\",\\n                    \"type\": \"int\",\\n                    \"enabled\": true,\\n                    \"minimum_value\": 50,\\n                    \"unit\": \"mm/sec\u00b2 \",\\n                    \"default_value\": 500\\n                },\\n                \"jerk_enable\":\\n                {\\n                    \"label\": \"Change the Jerk\",\\n                    \"description\": \"Whether to change the Jerk values.\",\\n                    \"type\": \"bool\",\\n                    \"enabled\": true,\\n                    \"default_value\": false\\n                },\\n                \"jerk_cmd\":\\n                {\\n                    \"label\": \"G-Code Jerk Command\",\\n                    \"description\": \"Marlin uses M205.  RepRap might use M566.\",\\n                    \"type\": \"enum\",\\n                    \"options\": {\\n                        \"marlin_flavor\": \"M205\",\\n                        \"reprap_flavor\": \"M566\"},\\n                    \"default_value\": \"marlin_flavor\",\\n                    \"enabled\":  \"jerk_enable\"\\n                },\\n                \"x_jerk\":\\n                {\\n                    \"label\": \"    X jerk\",\\n                    \"description\": \"Enter the Jerk value for the X axis.  Enter \\'0\\' to use the existing X Jerk.  This setting will affect both the Print and Travel jerk.\",\\n                    \"type\": \"int\",\\n                    \"enabled\": \"jerk_enable\",\\n                    \"unit\": \"mm/sec \",\\n                    \"default_value\": 8\\n                },\\n                \"y_jerk\":\\n                {\\n                    \"label\": \"    Y jerk\",\\n                    \"description\": \"Enter the Jerk value for the Y axis. Enter \\'0\\' to use the existing Y Jerk.    This setting will affect both the Print and Travel jerk.\",\\n                    \"type\": \"int\",\\n                    \"enabled\": \"jerk_enable\",\\n                    \"unit\": \"mm/sec \",\\n                    \"default_value\": 8\\n                },\\n                \"start_layer\":\\n                {\\n                    \"label\": \"From Start of Layer:\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter the Layer to start the changes at. The minimum is Layer 1.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": 1,\\n                    \"minimum_value\": 1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'immediate_change\\'\"\\n                },\\n                \"end_layer\":\\n                {\\n                    \"label\": \"To End of Layer\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter \\'-1\\' for the entire file or enter a layer number.  The changes will end at your \\'End Layer\\' and revert back to the original numbers.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": -1,\\n                    \"minimum_value\": -1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'immediate_change\\'\"\\n                },\\n                \"gradient_start_layer\":\\n                {\\n                    \"label\": \"     Gradual From Layer:\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter the Layer to start the changes at. The minimum is Layer 1.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": 1,\\n                    \"minimum_value\": 1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'gradual_change\\'\"\\n                },\\n                \"gradient_end_layer\":\\n                {\\n                    \"label\": \"     Gradual To Layer\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter \\'-1\\' for the top layer or enter a layer number.  The last \\'Gradual\\' change will continue to the end of the file.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": -1,\\n                    \"minimum_value\": -1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'gradual_change\\'\"\\n                }\\n            }\\n        }'",
            "def getSettingDataString(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return '{\\n            \"name\": \"Limit the X-Y Accel/Jerk (all extruders equal)\",\\n            \"key\": \"LimitXYAccelJerk\",\\n            \"metadata\": {},\\n            \"version\": 2,\\n            \"settings\":\\n            {\\n                \"type_of_change\":\\n                {\\n                    \"label\": \"Immediate or Gradual change\",\\n                    \"description\": \"An \\'Immediate\\' change will insert the new numbers immediately at the Start Layer.  A \\'Gradual\\' change will transition from the starting Accel to the new Accel limit across a range of layers.\",\\n                    \"type\": \"enum\",\\n                    \"options\": {\\n                        \"immediate_change\": \"Immediate\",\\n                        \"gradual_change\": \"Gradual\"},\\n                    \"default_value\": \"immediate_change\"\\n                },\\n                \"x_accel_limit\":\\n                {\\n                    \"label\": \"X MAX Acceleration\",\\n                    \"description\": \"If this number is lower than the \\'X Print Accel\\' in Cura then this will limit the Accel on the X axis.  Enter the Maximum Acceleration value for the X axis.  This will affect both Print and Travel Accel.  If you enable an End Layer then at the end of that layer the Accel Limit will be reset (unless you choose \\'Gradual\\' in which case the new limit goes to the top layer).\",\\n                    \"type\": \"int\",\\n                    \"enabled\": true,\\n                    \"minimum_value\": 50,\\n                    \"unit\": \"mm/sec\u00b2 \",\\n                    \"default_value\": 500\\n                },\\n                \"y_accel_limit\":\\n                {\\n                    \"label\": \"Y MAX Acceleration\",\\n                    \"description\": \"If this number is lower than the Y accel in Cura then this will limit the Accel on the Y axis.  Enter the Maximum Acceleration value for the Y axis.  This will affect both Print and Travel Accel.  If you enable an End Layer then at the end of that layer the Accel Limit will be reset (unless you choose \\'Gradual\\' in which case the new limit goes to the top layer).\",\\n                    \"type\": \"int\",\\n                    \"enabled\": true,\\n                    \"minimum_value\": 50,\\n                    \"unit\": \"mm/sec\u00b2 \",\\n                    \"default_value\": 500\\n                },\\n                \"jerk_enable\":\\n                {\\n                    \"label\": \"Change the Jerk\",\\n                    \"description\": \"Whether to change the Jerk values.\",\\n                    \"type\": \"bool\",\\n                    \"enabled\": true,\\n                    \"default_value\": false\\n                },\\n                \"jerk_cmd\":\\n                {\\n                    \"label\": \"G-Code Jerk Command\",\\n                    \"description\": \"Marlin uses M205.  RepRap might use M566.\",\\n                    \"type\": \"enum\",\\n                    \"options\": {\\n                        \"marlin_flavor\": \"M205\",\\n                        \"reprap_flavor\": \"M566\"},\\n                    \"default_value\": \"marlin_flavor\",\\n                    \"enabled\":  \"jerk_enable\"\\n                },\\n                \"x_jerk\":\\n                {\\n                    \"label\": \"    X jerk\",\\n                    \"description\": \"Enter the Jerk value for the X axis.  Enter \\'0\\' to use the existing X Jerk.  This setting will affect both the Print and Travel jerk.\",\\n                    \"type\": \"int\",\\n                    \"enabled\": \"jerk_enable\",\\n                    \"unit\": \"mm/sec \",\\n                    \"default_value\": 8\\n                },\\n                \"y_jerk\":\\n                {\\n                    \"label\": \"    Y jerk\",\\n                    \"description\": \"Enter the Jerk value for the Y axis. Enter \\'0\\' to use the existing Y Jerk.    This setting will affect both the Print and Travel jerk.\",\\n                    \"type\": \"int\",\\n                    \"enabled\": \"jerk_enable\",\\n                    \"unit\": \"mm/sec \",\\n                    \"default_value\": 8\\n                },\\n                \"start_layer\":\\n                {\\n                    \"label\": \"From Start of Layer:\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter the Layer to start the changes at. The minimum is Layer 1.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": 1,\\n                    \"minimum_value\": 1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'immediate_change\\'\"\\n                },\\n                \"end_layer\":\\n                {\\n                    \"label\": \"To End of Layer\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter \\'-1\\' for the entire file or enter a layer number.  The changes will end at your \\'End Layer\\' and revert back to the original numbers.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": -1,\\n                    \"minimum_value\": -1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'immediate_change\\'\"\\n                },\\n                \"gradient_start_layer\":\\n                {\\n                    \"label\": \"     Gradual From Layer:\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter the Layer to start the changes at. The minimum is Layer 1.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": 1,\\n                    \"minimum_value\": 1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'gradual_change\\'\"\\n                },\\n                \"gradient_end_layer\":\\n                {\\n                    \"label\": \"     Gradual To Layer\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter \\'-1\\' for the top layer or enter a layer number.  The last \\'Gradual\\' change will continue to the end of the file.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": -1,\\n                    \"minimum_value\": -1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'gradual_change\\'\"\\n                }\\n            }\\n        }'",
            "def getSettingDataString(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return '{\\n            \"name\": \"Limit the X-Y Accel/Jerk (all extruders equal)\",\\n            \"key\": \"LimitXYAccelJerk\",\\n            \"metadata\": {},\\n            \"version\": 2,\\n            \"settings\":\\n            {\\n                \"type_of_change\":\\n                {\\n                    \"label\": \"Immediate or Gradual change\",\\n                    \"description\": \"An \\'Immediate\\' change will insert the new numbers immediately at the Start Layer.  A \\'Gradual\\' change will transition from the starting Accel to the new Accel limit across a range of layers.\",\\n                    \"type\": \"enum\",\\n                    \"options\": {\\n                        \"immediate_change\": \"Immediate\",\\n                        \"gradual_change\": \"Gradual\"},\\n                    \"default_value\": \"immediate_change\"\\n                },\\n                \"x_accel_limit\":\\n                {\\n                    \"label\": \"X MAX Acceleration\",\\n                    \"description\": \"If this number is lower than the \\'X Print Accel\\' in Cura then this will limit the Accel on the X axis.  Enter the Maximum Acceleration value for the X axis.  This will affect both Print and Travel Accel.  If you enable an End Layer then at the end of that layer the Accel Limit will be reset (unless you choose \\'Gradual\\' in which case the new limit goes to the top layer).\",\\n                    \"type\": \"int\",\\n                    \"enabled\": true,\\n                    \"minimum_value\": 50,\\n                    \"unit\": \"mm/sec\u00b2 \",\\n                    \"default_value\": 500\\n                },\\n                \"y_accel_limit\":\\n                {\\n                    \"label\": \"Y MAX Acceleration\",\\n                    \"description\": \"If this number is lower than the Y accel in Cura then this will limit the Accel on the Y axis.  Enter the Maximum Acceleration value for the Y axis.  This will affect both Print and Travel Accel.  If you enable an End Layer then at the end of that layer the Accel Limit will be reset (unless you choose \\'Gradual\\' in which case the new limit goes to the top layer).\",\\n                    \"type\": \"int\",\\n                    \"enabled\": true,\\n                    \"minimum_value\": 50,\\n                    \"unit\": \"mm/sec\u00b2 \",\\n                    \"default_value\": 500\\n                },\\n                \"jerk_enable\":\\n                {\\n                    \"label\": \"Change the Jerk\",\\n                    \"description\": \"Whether to change the Jerk values.\",\\n                    \"type\": \"bool\",\\n                    \"enabled\": true,\\n                    \"default_value\": false\\n                },\\n                \"jerk_cmd\":\\n                {\\n                    \"label\": \"G-Code Jerk Command\",\\n                    \"description\": \"Marlin uses M205.  RepRap might use M566.\",\\n                    \"type\": \"enum\",\\n                    \"options\": {\\n                        \"marlin_flavor\": \"M205\",\\n                        \"reprap_flavor\": \"M566\"},\\n                    \"default_value\": \"marlin_flavor\",\\n                    \"enabled\":  \"jerk_enable\"\\n                },\\n                \"x_jerk\":\\n                {\\n                    \"label\": \"    X jerk\",\\n                    \"description\": \"Enter the Jerk value for the X axis.  Enter \\'0\\' to use the existing X Jerk.  This setting will affect both the Print and Travel jerk.\",\\n                    \"type\": \"int\",\\n                    \"enabled\": \"jerk_enable\",\\n                    \"unit\": \"mm/sec \",\\n                    \"default_value\": 8\\n                },\\n                \"y_jerk\":\\n                {\\n                    \"label\": \"    Y jerk\",\\n                    \"description\": \"Enter the Jerk value for the Y axis. Enter \\'0\\' to use the existing Y Jerk.    This setting will affect both the Print and Travel jerk.\",\\n                    \"type\": \"int\",\\n                    \"enabled\": \"jerk_enable\",\\n                    \"unit\": \"mm/sec \",\\n                    \"default_value\": 8\\n                },\\n                \"start_layer\":\\n                {\\n                    \"label\": \"From Start of Layer:\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter the Layer to start the changes at. The minimum is Layer 1.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": 1,\\n                    \"minimum_value\": 1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'immediate_change\\'\"\\n                },\\n                \"end_layer\":\\n                {\\n                    \"label\": \"To End of Layer\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter \\'-1\\' for the entire file or enter a layer number.  The changes will end at your \\'End Layer\\' and revert back to the original numbers.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": -1,\\n                    \"minimum_value\": -1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'immediate_change\\'\"\\n                },\\n                \"gradient_start_layer\":\\n                {\\n                    \"label\": \"     Gradual From Layer:\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter the Layer to start the changes at. The minimum is Layer 1.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": 1,\\n                    \"minimum_value\": 1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'gradual_change\\'\"\\n                },\\n                \"gradient_end_layer\":\\n                {\\n                    \"label\": \"     Gradual To Layer\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter \\'-1\\' for the top layer or enter a layer number.  The last \\'Gradual\\' change will continue to the end of the file.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": -1,\\n                    \"minimum_value\": -1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'gradual_change\\'\"\\n                }\\n            }\\n        }'",
            "def getSettingDataString(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return '{\\n            \"name\": \"Limit the X-Y Accel/Jerk (all extruders equal)\",\\n            \"key\": \"LimitXYAccelJerk\",\\n            \"metadata\": {},\\n            \"version\": 2,\\n            \"settings\":\\n            {\\n                \"type_of_change\":\\n                {\\n                    \"label\": \"Immediate or Gradual change\",\\n                    \"description\": \"An \\'Immediate\\' change will insert the new numbers immediately at the Start Layer.  A \\'Gradual\\' change will transition from the starting Accel to the new Accel limit across a range of layers.\",\\n                    \"type\": \"enum\",\\n                    \"options\": {\\n                        \"immediate_change\": \"Immediate\",\\n                        \"gradual_change\": \"Gradual\"},\\n                    \"default_value\": \"immediate_change\"\\n                },\\n                \"x_accel_limit\":\\n                {\\n                    \"label\": \"X MAX Acceleration\",\\n                    \"description\": \"If this number is lower than the \\'X Print Accel\\' in Cura then this will limit the Accel on the X axis.  Enter the Maximum Acceleration value for the X axis.  This will affect both Print and Travel Accel.  If you enable an End Layer then at the end of that layer the Accel Limit will be reset (unless you choose \\'Gradual\\' in which case the new limit goes to the top layer).\",\\n                    \"type\": \"int\",\\n                    \"enabled\": true,\\n                    \"minimum_value\": 50,\\n                    \"unit\": \"mm/sec\u00b2 \",\\n                    \"default_value\": 500\\n                },\\n                \"y_accel_limit\":\\n                {\\n                    \"label\": \"Y MAX Acceleration\",\\n                    \"description\": \"If this number is lower than the Y accel in Cura then this will limit the Accel on the Y axis.  Enter the Maximum Acceleration value for the Y axis.  This will affect both Print and Travel Accel.  If you enable an End Layer then at the end of that layer the Accel Limit will be reset (unless you choose \\'Gradual\\' in which case the new limit goes to the top layer).\",\\n                    \"type\": \"int\",\\n                    \"enabled\": true,\\n                    \"minimum_value\": 50,\\n                    \"unit\": \"mm/sec\u00b2 \",\\n                    \"default_value\": 500\\n                },\\n                \"jerk_enable\":\\n                {\\n                    \"label\": \"Change the Jerk\",\\n                    \"description\": \"Whether to change the Jerk values.\",\\n                    \"type\": \"bool\",\\n                    \"enabled\": true,\\n                    \"default_value\": false\\n                },\\n                \"jerk_cmd\":\\n                {\\n                    \"label\": \"G-Code Jerk Command\",\\n                    \"description\": \"Marlin uses M205.  RepRap might use M566.\",\\n                    \"type\": \"enum\",\\n                    \"options\": {\\n                        \"marlin_flavor\": \"M205\",\\n                        \"reprap_flavor\": \"M566\"},\\n                    \"default_value\": \"marlin_flavor\",\\n                    \"enabled\":  \"jerk_enable\"\\n                },\\n                \"x_jerk\":\\n                {\\n                    \"label\": \"    X jerk\",\\n                    \"description\": \"Enter the Jerk value for the X axis.  Enter \\'0\\' to use the existing X Jerk.  This setting will affect both the Print and Travel jerk.\",\\n                    \"type\": \"int\",\\n                    \"enabled\": \"jerk_enable\",\\n                    \"unit\": \"mm/sec \",\\n                    \"default_value\": 8\\n                },\\n                \"y_jerk\":\\n                {\\n                    \"label\": \"    Y jerk\",\\n                    \"description\": \"Enter the Jerk value for the Y axis. Enter \\'0\\' to use the existing Y Jerk.    This setting will affect both the Print and Travel jerk.\",\\n                    \"type\": \"int\",\\n                    \"enabled\": \"jerk_enable\",\\n                    \"unit\": \"mm/sec \",\\n                    \"default_value\": 8\\n                },\\n                \"start_layer\":\\n                {\\n                    \"label\": \"From Start of Layer:\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter the Layer to start the changes at. The minimum is Layer 1.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": 1,\\n                    \"minimum_value\": 1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'immediate_change\\'\"\\n                },\\n                \"end_layer\":\\n                {\\n                    \"label\": \"To End of Layer\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter \\'-1\\' for the entire file or enter a layer number.  The changes will end at your \\'End Layer\\' and revert back to the original numbers.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": -1,\\n                    \"minimum_value\": -1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'immediate_change\\'\"\\n                },\\n                \"gradient_start_layer\":\\n                {\\n                    \"label\": \"     Gradual From Layer:\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter the Layer to start the changes at. The minimum is Layer 1.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": 1,\\n                    \"minimum_value\": 1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'gradual_change\\'\"\\n                },\\n                \"gradient_end_layer\":\\n                {\\n                    \"label\": \"     Gradual To Layer\",\\n                    \"description\": \"Use the Cura Preview numbers. Enter \\'-1\\' for the top layer or enter a layer number.  The last \\'Gradual\\' change will continue to the end of the file.\",\\n                    \"type\": \"int\",\\n                    \"default_value\": -1,\\n                    \"minimum_value\": -1,\\n                    \"unit\": \"Lay# \",\\n                    \"enabled\": \"type_of_change == \\'gradual_change\\'\"\\n                }\\n            }\\n        }'"
        ]
    },
    {
        "func_name": "execute",
        "original": "def execute(self, data):\n    mycura = CuraApplication.getInstance().getGlobalContainerStack()\n    extruder = mycura.extruderList\n    machine_name = str(mycura.getProperty('machine_name', 'value'))\n    print_sequence = str(mycura.getProperty('print_sequence', 'value'))\n    if print_sequence == 'one_at_a_time':\n        Message(text=\"<NOTICE> [Limit the X-Y Accel/Jerk]  DID NOT RUN.  This post processor is not compatible with 'One-at-a-Time' mode.\").show()\n        data[0] += \";  [LimitXYAccelJerk] DID NOT RUN because Cura is set to 'One-at-a-Time' mode.\\n\"\n        return data\n    if 'Ultimaker' in machine_name:\n        Message(text='<NOTICE> [Limit the X-Y Accel/Jerk]  DID NOT RUN.  This post processor is for bed slinger printers only.').show()\n        data[0] += \";  [LimitXYAccelJerk] DID NOT RUN because the printer doesn't have a sliding bed.\\n\"\n        return data\n    type_of_change = str(self.getSettingValueByKey('type_of_change'))\n    accel_print_enabled = bool(extruder[0].getProperty('acceleration_enabled', 'value'))\n    accel_travel_enabled = bool(extruder[0].getProperty('acceleration_travel_enabled', 'value'))\n    accel_print = extruder[0].getProperty('acceleration_print', 'value')\n    accel_travel = extruder[0].getProperty('acceleration_travel', 'value')\n    jerk_print_enabled = str(extruder[0].getProperty('jerk_enabled', 'value'))\n    jerk_travel_enabled = str(extruder[0].getProperty('jerk_travel_enabled', 'value'))\n    jerk_print_old = extruder[0].getProperty('jerk_print', 'value')\n    jerk_travel_old = extruder[0].getProperty('jerk_travel', 'value')\n    if int(accel_print) >= int(accel_travel):\n        accel_old = accel_print\n    else:\n        accel_old = accel_travel\n    jerk_travel = str(extruder[0].getProperty('jerk_travel', 'value'))\n    if int(jerk_print_old) >= int(jerk_travel_old):\n        jerk_old = jerk_print_old\n    else:\n        jerk_old = jerk_travel_old\n    x_accel = str(self.getSettingValueByKey('x_accel_limit'))\n    y_accel = str(self.getSettingValueByKey('y_accel_limit'))\n    x_jerk = int(self.getSettingValueByKey('x_jerk'))\n    y_jerk = int(self.getSettingValueByKey('y_jerk'))\n    if str(self.getSettingValueByKey('jerk_cmd')) == 'reprap_flavor':\n        jerk_cmd = 'M566'\n        x_jerk *= 60\n        y_jerk *= 60\n        jerk_old *= 60\n    else:\n        jerk_cmd = 'M205'\n    m201_limit_new = f'M201 X{x_accel} Y{y_accel}'\n    m201_limit_old = f'M201 X{round(accel_old)} Y{round(accel_old)}'\n    if x_jerk == 0:\n        m205_jerk_pattern = 'Y(\\\\d*)'\n        m205_jerk_new = f'Y{y_jerk}'\n    if y_jerk == 0:\n        m205_jerk_pattern = 'X(\\\\d*)'\n        m205_jerk_new = f'X{x_jerk}'\n    if x_jerk != 0 and y_jerk != 0:\n        m205_jerk_pattern = jerk_cmd + ' X(\\\\d*) Y(\\\\d*)'\n        m205_jerk_new = jerk_cmd + f' X{x_jerk} Y{y_jerk}'\n    m205_jerk_old = jerk_cmd + f' X{jerk_old} Y{jerk_old}'\n    type_of_change = self.getSettingValueByKey('type_of_change')\n    if type_of_change == 'immediate_change':\n        start_layer = int(self.getSettingValueByKey('start_layer')) - 1\n        end_layer = int(self.getSettingValueByKey('end_layer'))\n    else:\n        start_layer = int(self.getSettingValueByKey('gradient_start_layer')) - 1\n        end_layer = int(self.getSettingValueByKey('gradient_end_layer'))\n    start_index = 2\n    end_index = len(data) - 2\n    for num in range(2, len(data) - 1):\n        if ';LAYER:' + str(start_layer) + '\\n' in data[num]:\n            start_index = num\n            break\n    if int(end_layer) > 0:\n        for num in range(3, len(data) - 1):\n            try:\n                if ';LAYER:' + str(end_layer) + '\\n' in data[num]:\n                    end_index = num\n                    break\n            except:\n                end_index = len(data) - 2\n    if type_of_change == 'immediate_change':\n        layer = data[start_index]\n        lines = layer.split('\\n')\n        for (index, line) in enumerate(lines):\n            if lines[index].startswith(';LAYER:'):\n                lines.insert(index + 1, m201_limit_new)\n                if self.getSettingValueByKey('jerk_enable'):\n                    lines.insert(index + 2, m205_jerk_new)\n                data[start_index] = '\\n'.join(lines)\n                break\n        for num in range(start_index, end_index, 1):\n            layer = data[num]\n            lines = layer.split('\\n')\n            for (index, line) in enumerate(lines):\n                if line.startswith('M205') or line.startswith('M566'):\n                    lines[index] = re.sub(m205_jerk_pattern, m205_jerk_new, line)\n            data[num] = '\\n'.join(lines)\n        if end_layer != -1:\n            try:\n                layer = data[end_index - 1]\n                lines = layer.split('\\n')\n                lines.insert(len(lines) - 2, m201_limit_old)\n                lines.insert(len(lines) - 2, m205_jerk_old)\n                data[end_index - 1] = '\\n'.join(lines)\n            except:\n                pass\n        else:\n            data[len(data) - 1] = m201_limit_old + '\\n' + m205_jerk_old + '\\n' + data[len(data) - 1]\n        return data\n    elif type_of_change == 'gradual_change':\n        layer_spread = end_index - start_index\n        if accel_old >= int(x_accel):\n            x_accel_hyst = round((accel_old - int(x_accel)) / layer_spread)\n        else:\n            x_accel_hyst = round((int(x_accel) - accel_old) / layer_spread)\n        if accel_old >= int(y_accel):\n            y_accel_hyst = round((accel_old - int(y_accel)) / layer_spread)\n        else:\n            y_accel_hyst = round((int(y_accel) - accel_old) / layer_spread)\n        if accel_old >= int(x_accel):\n            x_accel_start = round(round((accel_old - x_accel_hyst) / 25) * 25)\n        else:\n            x_accel_start = round(round((x_accel_hyst + accel_old) / 25) * 25)\n        if accel_old >= int(y_accel):\n            y_accel_start = round(round((accel_old - y_accel_hyst) / 25) * 25)\n        else:\n            y_accel_start = round(round((y_accel_hyst + accel_old) / 25) * 25)\n        m201_limit_new = 'M201 X' + str(x_accel_start) + ' Y' + str(y_accel_start)\n        layer = data[start_index]\n        lines = layer.split('\\n')\n        for (index, line) in enumerate(lines):\n            if lines[index].startswith(';LAYER:'):\n                lines.insert(index + 1, m201_limit_new)\n                if self.getSettingValueByKey('jerk_enable'):\n                    lines.insert(index + 2, m205_jerk_new)\n                data[start_index] = '\\n'.join(lines)\n                break\n        for num in range(start_index + 1, end_index, 1):\n            layer = data[num]\n            lines = layer.split('\\n')\n            if accel_old >= int(x_accel):\n                x_accel_start -= x_accel_hyst\n                if x_accel_start < int(x_accel):\n                    x_accel_start = int(x_accel)\n            else:\n                x_accel_start += x_accel_hyst\n                if x_accel_start > int(x_accel):\n                    x_accel_start = int(x_accel)\n            if accel_old >= int(y_accel):\n                y_accel_start -= y_accel_hyst\n                if y_accel_start < int(y_accel):\n                    y_accel_start = int(y_accel)\n            else:\n                y_accel_start += y_accel_hyst\n                if y_accel_start > int(y_accel):\n                    y_accel_start = int(y_accel)\n            m201_limit_new = 'M201 X' + str(round(round(x_accel_start / 25) * 25)) + ' Y' + str(round(round(y_accel_start / 25) * 25))\n            for (index, line) in enumerate(lines):\n                if line.startswith(';LAYER:'):\n                    lines.insert(index + 1, m201_limit_new)\n                    continue\n            data[num] = '\\n'.join(lines)\n        if self.getSettingValueByKey('jerk_enable'):\n            for num in range(start_index, len(data) - 1, 1):\n                layer = data[num]\n                lines = layer.split('\\n')\n                for (index, line) in enumerate(lines):\n                    if line.startswith('M205') or line.startswith('M566'):\n                        lines[index] = re.sub(m205_jerk_pattern, m205_jerk_new, line)\n                data[num] = '\\n'.join(lines)\n            data[len(data) - 1] = m201_limit_old + '\\n' + m205_jerk_old + '\\n' + data[len(data) - 1]\n        return data",
        "mutated": [
            "def execute(self, data):\n    if False:\n        i = 10\n    mycura = CuraApplication.getInstance().getGlobalContainerStack()\n    extruder = mycura.extruderList\n    machine_name = str(mycura.getProperty('machine_name', 'value'))\n    print_sequence = str(mycura.getProperty('print_sequence', 'value'))\n    if print_sequence == 'one_at_a_time':\n        Message(text=\"<NOTICE> [Limit the X-Y Accel/Jerk]  DID NOT RUN.  This post processor is not compatible with 'One-at-a-Time' mode.\").show()\n        data[0] += \";  [LimitXYAccelJerk] DID NOT RUN because Cura is set to 'One-at-a-Time' mode.\\n\"\n        return data\n    if 'Ultimaker' in machine_name:\n        Message(text='<NOTICE> [Limit the X-Y Accel/Jerk]  DID NOT RUN.  This post processor is for bed slinger printers only.').show()\n        data[0] += \";  [LimitXYAccelJerk] DID NOT RUN because the printer doesn't have a sliding bed.\\n\"\n        return data\n    type_of_change = str(self.getSettingValueByKey('type_of_change'))\n    accel_print_enabled = bool(extruder[0].getProperty('acceleration_enabled', 'value'))\n    accel_travel_enabled = bool(extruder[0].getProperty('acceleration_travel_enabled', 'value'))\n    accel_print = extruder[0].getProperty('acceleration_print', 'value')\n    accel_travel = extruder[0].getProperty('acceleration_travel', 'value')\n    jerk_print_enabled = str(extruder[0].getProperty('jerk_enabled', 'value'))\n    jerk_travel_enabled = str(extruder[0].getProperty('jerk_travel_enabled', 'value'))\n    jerk_print_old = extruder[0].getProperty('jerk_print', 'value')\n    jerk_travel_old = extruder[0].getProperty('jerk_travel', 'value')\n    if int(accel_print) >= int(accel_travel):\n        accel_old = accel_print\n    else:\n        accel_old = accel_travel\n    jerk_travel = str(extruder[0].getProperty('jerk_travel', 'value'))\n    if int(jerk_print_old) >= int(jerk_travel_old):\n        jerk_old = jerk_print_old\n    else:\n        jerk_old = jerk_travel_old\n    x_accel = str(self.getSettingValueByKey('x_accel_limit'))\n    y_accel = str(self.getSettingValueByKey('y_accel_limit'))\n    x_jerk = int(self.getSettingValueByKey('x_jerk'))\n    y_jerk = int(self.getSettingValueByKey('y_jerk'))\n    if str(self.getSettingValueByKey('jerk_cmd')) == 'reprap_flavor':\n        jerk_cmd = 'M566'\n        x_jerk *= 60\n        y_jerk *= 60\n        jerk_old *= 60\n    else:\n        jerk_cmd = 'M205'\n    m201_limit_new = f'M201 X{x_accel} Y{y_accel}'\n    m201_limit_old = f'M201 X{round(accel_old)} Y{round(accel_old)}'\n    if x_jerk == 0:\n        m205_jerk_pattern = 'Y(\\\\d*)'\n        m205_jerk_new = f'Y{y_jerk}'\n    if y_jerk == 0:\n        m205_jerk_pattern = 'X(\\\\d*)'\n        m205_jerk_new = f'X{x_jerk}'\n    if x_jerk != 0 and y_jerk != 0:\n        m205_jerk_pattern = jerk_cmd + ' X(\\\\d*) Y(\\\\d*)'\n        m205_jerk_new = jerk_cmd + f' X{x_jerk} Y{y_jerk}'\n    m205_jerk_old = jerk_cmd + f' X{jerk_old} Y{jerk_old}'\n    type_of_change = self.getSettingValueByKey('type_of_change')\n    if type_of_change == 'immediate_change':\n        start_layer = int(self.getSettingValueByKey('start_layer')) - 1\n        end_layer = int(self.getSettingValueByKey('end_layer'))\n    else:\n        start_layer = int(self.getSettingValueByKey('gradient_start_layer')) - 1\n        end_layer = int(self.getSettingValueByKey('gradient_end_layer'))\n    start_index = 2\n    end_index = len(data) - 2\n    for num in range(2, len(data) - 1):\n        if ';LAYER:' + str(start_layer) + '\\n' in data[num]:\n            start_index = num\n            break\n    if int(end_layer) > 0:\n        for num in range(3, len(data) - 1):\n            try:\n                if ';LAYER:' + str(end_layer) + '\\n' in data[num]:\n                    end_index = num\n                    break\n            except:\n                end_index = len(data) - 2\n    if type_of_change == 'immediate_change':\n        layer = data[start_index]\n        lines = layer.split('\\n')\n        for (index, line) in enumerate(lines):\n            if lines[index].startswith(';LAYER:'):\n                lines.insert(index + 1, m201_limit_new)\n                if self.getSettingValueByKey('jerk_enable'):\n                    lines.insert(index + 2, m205_jerk_new)\n                data[start_index] = '\\n'.join(lines)\n                break\n        for num in range(start_index, end_index, 1):\n            layer = data[num]\n            lines = layer.split('\\n')\n            for (index, line) in enumerate(lines):\n                if line.startswith('M205') or line.startswith('M566'):\n                    lines[index] = re.sub(m205_jerk_pattern, m205_jerk_new, line)\n            data[num] = '\\n'.join(lines)\n        if end_layer != -1:\n            try:\n                layer = data[end_index - 1]\n                lines = layer.split('\\n')\n                lines.insert(len(lines) - 2, m201_limit_old)\n                lines.insert(len(lines) - 2, m205_jerk_old)\n                data[end_index - 1] = '\\n'.join(lines)\n            except:\n                pass\n        else:\n            data[len(data) - 1] = m201_limit_old + '\\n' + m205_jerk_old + '\\n' + data[len(data) - 1]\n        return data\n    elif type_of_change == 'gradual_change':\n        layer_spread = end_index - start_index\n        if accel_old >= int(x_accel):\n            x_accel_hyst = round((accel_old - int(x_accel)) / layer_spread)\n        else:\n            x_accel_hyst = round((int(x_accel) - accel_old) / layer_spread)\n        if accel_old >= int(y_accel):\n            y_accel_hyst = round((accel_old - int(y_accel)) / layer_spread)\n        else:\n            y_accel_hyst = round((int(y_accel) - accel_old) / layer_spread)\n        if accel_old >= int(x_accel):\n            x_accel_start = round(round((accel_old - x_accel_hyst) / 25) * 25)\n        else:\n            x_accel_start = round(round((x_accel_hyst + accel_old) / 25) * 25)\n        if accel_old >= int(y_accel):\n            y_accel_start = round(round((accel_old - y_accel_hyst) / 25) * 25)\n        else:\n            y_accel_start = round(round((y_accel_hyst + accel_old) / 25) * 25)\n        m201_limit_new = 'M201 X' + str(x_accel_start) + ' Y' + str(y_accel_start)\n        layer = data[start_index]\n        lines = layer.split('\\n')\n        for (index, line) in enumerate(lines):\n            if lines[index].startswith(';LAYER:'):\n                lines.insert(index + 1, m201_limit_new)\n                if self.getSettingValueByKey('jerk_enable'):\n                    lines.insert(index + 2, m205_jerk_new)\n                data[start_index] = '\\n'.join(lines)\n                break\n        for num in range(start_index + 1, end_index, 1):\n            layer = data[num]\n            lines = layer.split('\\n')\n            if accel_old >= int(x_accel):\n                x_accel_start -= x_accel_hyst\n                if x_accel_start < int(x_accel):\n                    x_accel_start = int(x_accel)\n            else:\n                x_accel_start += x_accel_hyst\n                if x_accel_start > int(x_accel):\n                    x_accel_start = int(x_accel)\n            if accel_old >= int(y_accel):\n                y_accel_start -= y_accel_hyst\n                if y_accel_start < int(y_accel):\n                    y_accel_start = int(y_accel)\n            else:\n                y_accel_start += y_accel_hyst\n                if y_accel_start > int(y_accel):\n                    y_accel_start = int(y_accel)\n            m201_limit_new = 'M201 X' + str(round(round(x_accel_start / 25) * 25)) + ' Y' + str(round(round(y_accel_start / 25) * 25))\n            for (index, line) in enumerate(lines):\n                if line.startswith(';LAYER:'):\n                    lines.insert(index + 1, m201_limit_new)\n                    continue\n            data[num] = '\\n'.join(lines)\n        if self.getSettingValueByKey('jerk_enable'):\n            for num in range(start_index, len(data) - 1, 1):\n                layer = data[num]\n                lines = layer.split('\\n')\n                for (index, line) in enumerate(lines):\n                    if line.startswith('M205') or line.startswith('M566'):\n                        lines[index] = re.sub(m205_jerk_pattern, m205_jerk_new, line)\n                data[num] = '\\n'.join(lines)\n            data[len(data) - 1] = m201_limit_old + '\\n' + m205_jerk_old + '\\n' + data[len(data) - 1]\n        return data",
            "def execute(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mycura = CuraApplication.getInstance().getGlobalContainerStack()\n    extruder = mycura.extruderList\n    machine_name = str(mycura.getProperty('machine_name', 'value'))\n    print_sequence = str(mycura.getProperty('print_sequence', 'value'))\n    if print_sequence == 'one_at_a_time':\n        Message(text=\"<NOTICE> [Limit the X-Y Accel/Jerk]  DID NOT RUN.  This post processor is not compatible with 'One-at-a-Time' mode.\").show()\n        data[0] += \";  [LimitXYAccelJerk] DID NOT RUN because Cura is set to 'One-at-a-Time' mode.\\n\"\n        return data\n    if 'Ultimaker' in machine_name:\n        Message(text='<NOTICE> [Limit the X-Y Accel/Jerk]  DID NOT RUN.  This post processor is for bed slinger printers only.').show()\n        data[0] += \";  [LimitXYAccelJerk] DID NOT RUN because the printer doesn't have a sliding bed.\\n\"\n        return data\n    type_of_change = str(self.getSettingValueByKey('type_of_change'))\n    accel_print_enabled = bool(extruder[0].getProperty('acceleration_enabled', 'value'))\n    accel_travel_enabled = bool(extruder[0].getProperty('acceleration_travel_enabled', 'value'))\n    accel_print = extruder[0].getProperty('acceleration_print', 'value')\n    accel_travel = extruder[0].getProperty('acceleration_travel', 'value')\n    jerk_print_enabled = str(extruder[0].getProperty('jerk_enabled', 'value'))\n    jerk_travel_enabled = str(extruder[0].getProperty('jerk_travel_enabled', 'value'))\n    jerk_print_old = extruder[0].getProperty('jerk_print', 'value')\n    jerk_travel_old = extruder[0].getProperty('jerk_travel', 'value')\n    if int(accel_print) >= int(accel_travel):\n        accel_old = accel_print\n    else:\n        accel_old = accel_travel\n    jerk_travel = str(extruder[0].getProperty('jerk_travel', 'value'))\n    if int(jerk_print_old) >= int(jerk_travel_old):\n        jerk_old = jerk_print_old\n    else:\n        jerk_old = jerk_travel_old\n    x_accel = str(self.getSettingValueByKey('x_accel_limit'))\n    y_accel = str(self.getSettingValueByKey('y_accel_limit'))\n    x_jerk = int(self.getSettingValueByKey('x_jerk'))\n    y_jerk = int(self.getSettingValueByKey('y_jerk'))\n    if str(self.getSettingValueByKey('jerk_cmd')) == 'reprap_flavor':\n        jerk_cmd = 'M566'\n        x_jerk *= 60\n        y_jerk *= 60\n        jerk_old *= 60\n    else:\n        jerk_cmd = 'M205'\n    m201_limit_new = f'M201 X{x_accel} Y{y_accel}'\n    m201_limit_old = f'M201 X{round(accel_old)} Y{round(accel_old)}'\n    if x_jerk == 0:\n        m205_jerk_pattern = 'Y(\\\\d*)'\n        m205_jerk_new = f'Y{y_jerk}'\n    if y_jerk == 0:\n        m205_jerk_pattern = 'X(\\\\d*)'\n        m205_jerk_new = f'X{x_jerk}'\n    if x_jerk != 0 and y_jerk != 0:\n        m205_jerk_pattern = jerk_cmd + ' X(\\\\d*) Y(\\\\d*)'\n        m205_jerk_new = jerk_cmd + f' X{x_jerk} Y{y_jerk}'\n    m205_jerk_old = jerk_cmd + f' X{jerk_old} Y{jerk_old}'\n    type_of_change = self.getSettingValueByKey('type_of_change')\n    if type_of_change == 'immediate_change':\n        start_layer = int(self.getSettingValueByKey('start_layer')) - 1\n        end_layer = int(self.getSettingValueByKey('end_layer'))\n    else:\n        start_layer = int(self.getSettingValueByKey('gradient_start_layer')) - 1\n        end_layer = int(self.getSettingValueByKey('gradient_end_layer'))\n    start_index = 2\n    end_index = len(data) - 2\n    for num in range(2, len(data) - 1):\n        if ';LAYER:' + str(start_layer) + '\\n' in data[num]:\n            start_index = num\n            break\n    if int(end_layer) > 0:\n        for num in range(3, len(data) - 1):\n            try:\n                if ';LAYER:' + str(end_layer) + '\\n' in data[num]:\n                    end_index = num\n                    break\n            except:\n                end_index = len(data) - 2\n    if type_of_change == 'immediate_change':\n        layer = data[start_index]\n        lines = layer.split('\\n')\n        for (index, line) in enumerate(lines):\n            if lines[index].startswith(';LAYER:'):\n                lines.insert(index + 1, m201_limit_new)\n                if self.getSettingValueByKey('jerk_enable'):\n                    lines.insert(index + 2, m205_jerk_new)\n                data[start_index] = '\\n'.join(lines)\n                break\n        for num in range(start_index, end_index, 1):\n            layer = data[num]\n            lines = layer.split('\\n')\n            for (index, line) in enumerate(lines):\n                if line.startswith('M205') or line.startswith('M566'):\n                    lines[index] = re.sub(m205_jerk_pattern, m205_jerk_new, line)\n            data[num] = '\\n'.join(lines)\n        if end_layer != -1:\n            try:\n                layer = data[end_index - 1]\n                lines = layer.split('\\n')\n                lines.insert(len(lines) - 2, m201_limit_old)\n                lines.insert(len(lines) - 2, m205_jerk_old)\n                data[end_index - 1] = '\\n'.join(lines)\n            except:\n                pass\n        else:\n            data[len(data) - 1] = m201_limit_old + '\\n' + m205_jerk_old + '\\n' + data[len(data) - 1]\n        return data\n    elif type_of_change == 'gradual_change':\n        layer_spread = end_index - start_index\n        if accel_old >= int(x_accel):\n            x_accel_hyst = round((accel_old - int(x_accel)) / layer_spread)\n        else:\n            x_accel_hyst = round((int(x_accel) - accel_old) / layer_spread)\n        if accel_old >= int(y_accel):\n            y_accel_hyst = round((accel_old - int(y_accel)) / layer_spread)\n        else:\n            y_accel_hyst = round((int(y_accel) - accel_old) / layer_spread)\n        if accel_old >= int(x_accel):\n            x_accel_start = round(round((accel_old - x_accel_hyst) / 25) * 25)\n        else:\n            x_accel_start = round(round((x_accel_hyst + accel_old) / 25) * 25)\n        if accel_old >= int(y_accel):\n            y_accel_start = round(round((accel_old - y_accel_hyst) / 25) * 25)\n        else:\n            y_accel_start = round(round((y_accel_hyst + accel_old) / 25) * 25)\n        m201_limit_new = 'M201 X' + str(x_accel_start) + ' Y' + str(y_accel_start)\n        layer = data[start_index]\n        lines = layer.split('\\n')\n        for (index, line) in enumerate(lines):\n            if lines[index].startswith(';LAYER:'):\n                lines.insert(index + 1, m201_limit_new)\n                if self.getSettingValueByKey('jerk_enable'):\n                    lines.insert(index + 2, m205_jerk_new)\n                data[start_index] = '\\n'.join(lines)\n                break\n        for num in range(start_index + 1, end_index, 1):\n            layer = data[num]\n            lines = layer.split('\\n')\n            if accel_old >= int(x_accel):\n                x_accel_start -= x_accel_hyst\n                if x_accel_start < int(x_accel):\n                    x_accel_start = int(x_accel)\n            else:\n                x_accel_start += x_accel_hyst\n                if x_accel_start > int(x_accel):\n                    x_accel_start = int(x_accel)\n            if accel_old >= int(y_accel):\n                y_accel_start -= y_accel_hyst\n                if y_accel_start < int(y_accel):\n                    y_accel_start = int(y_accel)\n            else:\n                y_accel_start += y_accel_hyst\n                if y_accel_start > int(y_accel):\n                    y_accel_start = int(y_accel)\n            m201_limit_new = 'M201 X' + str(round(round(x_accel_start / 25) * 25)) + ' Y' + str(round(round(y_accel_start / 25) * 25))\n            for (index, line) in enumerate(lines):\n                if line.startswith(';LAYER:'):\n                    lines.insert(index + 1, m201_limit_new)\n                    continue\n            data[num] = '\\n'.join(lines)\n        if self.getSettingValueByKey('jerk_enable'):\n            for num in range(start_index, len(data) - 1, 1):\n                layer = data[num]\n                lines = layer.split('\\n')\n                for (index, line) in enumerate(lines):\n                    if line.startswith('M205') or line.startswith('M566'):\n                        lines[index] = re.sub(m205_jerk_pattern, m205_jerk_new, line)\n                data[num] = '\\n'.join(lines)\n            data[len(data) - 1] = m201_limit_old + '\\n' + m205_jerk_old + '\\n' + data[len(data) - 1]\n        return data",
            "def execute(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mycura = CuraApplication.getInstance().getGlobalContainerStack()\n    extruder = mycura.extruderList\n    machine_name = str(mycura.getProperty('machine_name', 'value'))\n    print_sequence = str(mycura.getProperty('print_sequence', 'value'))\n    if print_sequence == 'one_at_a_time':\n        Message(text=\"<NOTICE> [Limit the X-Y Accel/Jerk]  DID NOT RUN.  This post processor is not compatible with 'One-at-a-Time' mode.\").show()\n        data[0] += \";  [LimitXYAccelJerk] DID NOT RUN because Cura is set to 'One-at-a-Time' mode.\\n\"\n        return data\n    if 'Ultimaker' in machine_name:\n        Message(text='<NOTICE> [Limit the X-Y Accel/Jerk]  DID NOT RUN.  This post processor is for bed slinger printers only.').show()\n        data[0] += \";  [LimitXYAccelJerk] DID NOT RUN because the printer doesn't have a sliding bed.\\n\"\n        return data\n    type_of_change = str(self.getSettingValueByKey('type_of_change'))\n    accel_print_enabled = bool(extruder[0].getProperty('acceleration_enabled', 'value'))\n    accel_travel_enabled = bool(extruder[0].getProperty('acceleration_travel_enabled', 'value'))\n    accel_print = extruder[0].getProperty('acceleration_print', 'value')\n    accel_travel = extruder[0].getProperty('acceleration_travel', 'value')\n    jerk_print_enabled = str(extruder[0].getProperty('jerk_enabled', 'value'))\n    jerk_travel_enabled = str(extruder[0].getProperty('jerk_travel_enabled', 'value'))\n    jerk_print_old = extruder[0].getProperty('jerk_print', 'value')\n    jerk_travel_old = extruder[0].getProperty('jerk_travel', 'value')\n    if int(accel_print) >= int(accel_travel):\n        accel_old = accel_print\n    else:\n        accel_old = accel_travel\n    jerk_travel = str(extruder[0].getProperty('jerk_travel', 'value'))\n    if int(jerk_print_old) >= int(jerk_travel_old):\n        jerk_old = jerk_print_old\n    else:\n        jerk_old = jerk_travel_old\n    x_accel = str(self.getSettingValueByKey('x_accel_limit'))\n    y_accel = str(self.getSettingValueByKey('y_accel_limit'))\n    x_jerk = int(self.getSettingValueByKey('x_jerk'))\n    y_jerk = int(self.getSettingValueByKey('y_jerk'))\n    if str(self.getSettingValueByKey('jerk_cmd')) == 'reprap_flavor':\n        jerk_cmd = 'M566'\n        x_jerk *= 60\n        y_jerk *= 60\n        jerk_old *= 60\n    else:\n        jerk_cmd = 'M205'\n    m201_limit_new = f'M201 X{x_accel} Y{y_accel}'\n    m201_limit_old = f'M201 X{round(accel_old)} Y{round(accel_old)}'\n    if x_jerk == 0:\n        m205_jerk_pattern = 'Y(\\\\d*)'\n        m205_jerk_new = f'Y{y_jerk}'\n    if y_jerk == 0:\n        m205_jerk_pattern = 'X(\\\\d*)'\n        m205_jerk_new = f'X{x_jerk}'\n    if x_jerk != 0 and y_jerk != 0:\n        m205_jerk_pattern = jerk_cmd + ' X(\\\\d*) Y(\\\\d*)'\n        m205_jerk_new = jerk_cmd + f' X{x_jerk} Y{y_jerk}'\n    m205_jerk_old = jerk_cmd + f' X{jerk_old} Y{jerk_old}'\n    type_of_change = self.getSettingValueByKey('type_of_change')\n    if type_of_change == 'immediate_change':\n        start_layer = int(self.getSettingValueByKey('start_layer')) - 1\n        end_layer = int(self.getSettingValueByKey('end_layer'))\n    else:\n        start_layer = int(self.getSettingValueByKey('gradient_start_layer')) - 1\n        end_layer = int(self.getSettingValueByKey('gradient_end_layer'))\n    start_index = 2\n    end_index = len(data) - 2\n    for num in range(2, len(data) - 1):\n        if ';LAYER:' + str(start_layer) + '\\n' in data[num]:\n            start_index = num\n            break\n    if int(end_layer) > 0:\n        for num in range(3, len(data) - 1):\n            try:\n                if ';LAYER:' + str(end_layer) + '\\n' in data[num]:\n                    end_index = num\n                    break\n            except:\n                end_index = len(data) - 2\n    if type_of_change == 'immediate_change':\n        layer = data[start_index]\n        lines = layer.split('\\n')\n        for (index, line) in enumerate(lines):\n            if lines[index].startswith(';LAYER:'):\n                lines.insert(index + 1, m201_limit_new)\n                if self.getSettingValueByKey('jerk_enable'):\n                    lines.insert(index + 2, m205_jerk_new)\n                data[start_index] = '\\n'.join(lines)\n                break\n        for num in range(start_index, end_index, 1):\n            layer = data[num]\n            lines = layer.split('\\n')\n            for (index, line) in enumerate(lines):\n                if line.startswith('M205') or line.startswith('M566'):\n                    lines[index] = re.sub(m205_jerk_pattern, m205_jerk_new, line)\n            data[num] = '\\n'.join(lines)\n        if end_layer != -1:\n            try:\n                layer = data[end_index - 1]\n                lines = layer.split('\\n')\n                lines.insert(len(lines) - 2, m201_limit_old)\n                lines.insert(len(lines) - 2, m205_jerk_old)\n                data[end_index - 1] = '\\n'.join(lines)\n            except:\n                pass\n        else:\n            data[len(data) - 1] = m201_limit_old + '\\n' + m205_jerk_old + '\\n' + data[len(data) - 1]\n        return data\n    elif type_of_change == 'gradual_change':\n        layer_spread = end_index - start_index\n        if accel_old >= int(x_accel):\n            x_accel_hyst = round((accel_old - int(x_accel)) / layer_spread)\n        else:\n            x_accel_hyst = round((int(x_accel) - accel_old) / layer_spread)\n        if accel_old >= int(y_accel):\n            y_accel_hyst = round((accel_old - int(y_accel)) / layer_spread)\n        else:\n            y_accel_hyst = round((int(y_accel) - accel_old) / layer_spread)\n        if accel_old >= int(x_accel):\n            x_accel_start = round(round((accel_old - x_accel_hyst) / 25) * 25)\n        else:\n            x_accel_start = round(round((x_accel_hyst + accel_old) / 25) * 25)\n        if accel_old >= int(y_accel):\n            y_accel_start = round(round((accel_old - y_accel_hyst) / 25) * 25)\n        else:\n            y_accel_start = round(round((y_accel_hyst + accel_old) / 25) * 25)\n        m201_limit_new = 'M201 X' + str(x_accel_start) + ' Y' + str(y_accel_start)\n        layer = data[start_index]\n        lines = layer.split('\\n')\n        for (index, line) in enumerate(lines):\n            if lines[index].startswith(';LAYER:'):\n                lines.insert(index + 1, m201_limit_new)\n                if self.getSettingValueByKey('jerk_enable'):\n                    lines.insert(index + 2, m205_jerk_new)\n                data[start_index] = '\\n'.join(lines)\n                break\n        for num in range(start_index + 1, end_index, 1):\n            layer = data[num]\n            lines = layer.split('\\n')\n            if accel_old >= int(x_accel):\n                x_accel_start -= x_accel_hyst\n                if x_accel_start < int(x_accel):\n                    x_accel_start = int(x_accel)\n            else:\n                x_accel_start += x_accel_hyst\n                if x_accel_start > int(x_accel):\n                    x_accel_start = int(x_accel)\n            if accel_old >= int(y_accel):\n                y_accel_start -= y_accel_hyst\n                if y_accel_start < int(y_accel):\n                    y_accel_start = int(y_accel)\n            else:\n                y_accel_start += y_accel_hyst\n                if y_accel_start > int(y_accel):\n                    y_accel_start = int(y_accel)\n            m201_limit_new = 'M201 X' + str(round(round(x_accel_start / 25) * 25)) + ' Y' + str(round(round(y_accel_start / 25) * 25))\n            for (index, line) in enumerate(lines):\n                if line.startswith(';LAYER:'):\n                    lines.insert(index + 1, m201_limit_new)\n                    continue\n            data[num] = '\\n'.join(lines)\n        if self.getSettingValueByKey('jerk_enable'):\n            for num in range(start_index, len(data) - 1, 1):\n                layer = data[num]\n                lines = layer.split('\\n')\n                for (index, line) in enumerate(lines):\n                    if line.startswith('M205') or line.startswith('M566'):\n                        lines[index] = re.sub(m205_jerk_pattern, m205_jerk_new, line)\n                data[num] = '\\n'.join(lines)\n            data[len(data) - 1] = m201_limit_old + '\\n' + m205_jerk_old + '\\n' + data[len(data) - 1]\n        return data",
            "def execute(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mycura = CuraApplication.getInstance().getGlobalContainerStack()\n    extruder = mycura.extruderList\n    machine_name = str(mycura.getProperty('machine_name', 'value'))\n    print_sequence = str(mycura.getProperty('print_sequence', 'value'))\n    if print_sequence == 'one_at_a_time':\n        Message(text=\"<NOTICE> [Limit the X-Y Accel/Jerk]  DID NOT RUN.  This post processor is not compatible with 'One-at-a-Time' mode.\").show()\n        data[0] += \";  [LimitXYAccelJerk] DID NOT RUN because Cura is set to 'One-at-a-Time' mode.\\n\"\n        return data\n    if 'Ultimaker' in machine_name:\n        Message(text='<NOTICE> [Limit the X-Y Accel/Jerk]  DID NOT RUN.  This post processor is for bed slinger printers only.').show()\n        data[0] += \";  [LimitXYAccelJerk] DID NOT RUN because the printer doesn't have a sliding bed.\\n\"\n        return data\n    type_of_change = str(self.getSettingValueByKey('type_of_change'))\n    accel_print_enabled = bool(extruder[0].getProperty('acceleration_enabled', 'value'))\n    accel_travel_enabled = bool(extruder[0].getProperty('acceleration_travel_enabled', 'value'))\n    accel_print = extruder[0].getProperty('acceleration_print', 'value')\n    accel_travel = extruder[0].getProperty('acceleration_travel', 'value')\n    jerk_print_enabled = str(extruder[0].getProperty('jerk_enabled', 'value'))\n    jerk_travel_enabled = str(extruder[0].getProperty('jerk_travel_enabled', 'value'))\n    jerk_print_old = extruder[0].getProperty('jerk_print', 'value')\n    jerk_travel_old = extruder[0].getProperty('jerk_travel', 'value')\n    if int(accel_print) >= int(accel_travel):\n        accel_old = accel_print\n    else:\n        accel_old = accel_travel\n    jerk_travel = str(extruder[0].getProperty('jerk_travel', 'value'))\n    if int(jerk_print_old) >= int(jerk_travel_old):\n        jerk_old = jerk_print_old\n    else:\n        jerk_old = jerk_travel_old\n    x_accel = str(self.getSettingValueByKey('x_accel_limit'))\n    y_accel = str(self.getSettingValueByKey('y_accel_limit'))\n    x_jerk = int(self.getSettingValueByKey('x_jerk'))\n    y_jerk = int(self.getSettingValueByKey('y_jerk'))\n    if str(self.getSettingValueByKey('jerk_cmd')) == 'reprap_flavor':\n        jerk_cmd = 'M566'\n        x_jerk *= 60\n        y_jerk *= 60\n        jerk_old *= 60\n    else:\n        jerk_cmd = 'M205'\n    m201_limit_new = f'M201 X{x_accel} Y{y_accel}'\n    m201_limit_old = f'M201 X{round(accel_old)} Y{round(accel_old)}'\n    if x_jerk == 0:\n        m205_jerk_pattern = 'Y(\\\\d*)'\n        m205_jerk_new = f'Y{y_jerk}'\n    if y_jerk == 0:\n        m205_jerk_pattern = 'X(\\\\d*)'\n        m205_jerk_new = f'X{x_jerk}'\n    if x_jerk != 0 and y_jerk != 0:\n        m205_jerk_pattern = jerk_cmd + ' X(\\\\d*) Y(\\\\d*)'\n        m205_jerk_new = jerk_cmd + f' X{x_jerk} Y{y_jerk}'\n    m205_jerk_old = jerk_cmd + f' X{jerk_old} Y{jerk_old}'\n    type_of_change = self.getSettingValueByKey('type_of_change')\n    if type_of_change == 'immediate_change':\n        start_layer = int(self.getSettingValueByKey('start_layer')) - 1\n        end_layer = int(self.getSettingValueByKey('end_layer'))\n    else:\n        start_layer = int(self.getSettingValueByKey('gradient_start_layer')) - 1\n        end_layer = int(self.getSettingValueByKey('gradient_end_layer'))\n    start_index = 2\n    end_index = len(data) - 2\n    for num in range(2, len(data) - 1):\n        if ';LAYER:' + str(start_layer) + '\\n' in data[num]:\n            start_index = num\n            break\n    if int(end_layer) > 0:\n        for num in range(3, len(data) - 1):\n            try:\n                if ';LAYER:' + str(end_layer) + '\\n' in data[num]:\n                    end_index = num\n                    break\n            except:\n                end_index = len(data) - 2\n    if type_of_change == 'immediate_change':\n        layer = data[start_index]\n        lines = layer.split('\\n')\n        for (index, line) in enumerate(lines):\n            if lines[index].startswith(';LAYER:'):\n                lines.insert(index + 1, m201_limit_new)\n                if self.getSettingValueByKey('jerk_enable'):\n                    lines.insert(index + 2, m205_jerk_new)\n                data[start_index] = '\\n'.join(lines)\n                break\n        for num in range(start_index, end_index, 1):\n            layer = data[num]\n            lines = layer.split('\\n')\n            for (index, line) in enumerate(lines):\n                if line.startswith('M205') or line.startswith('M566'):\n                    lines[index] = re.sub(m205_jerk_pattern, m205_jerk_new, line)\n            data[num] = '\\n'.join(lines)\n        if end_layer != -1:\n            try:\n                layer = data[end_index - 1]\n                lines = layer.split('\\n')\n                lines.insert(len(lines) - 2, m201_limit_old)\n                lines.insert(len(lines) - 2, m205_jerk_old)\n                data[end_index - 1] = '\\n'.join(lines)\n            except:\n                pass\n        else:\n            data[len(data) - 1] = m201_limit_old + '\\n' + m205_jerk_old + '\\n' + data[len(data) - 1]\n        return data\n    elif type_of_change == 'gradual_change':\n        layer_spread = end_index - start_index\n        if accel_old >= int(x_accel):\n            x_accel_hyst = round((accel_old - int(x_accel)) / layer_spread)\n        else:\n            x_accel_hyst = round((int(x_accel) - accel_old) / layer_spread)\n        if accel_old >= int(y_accel):\n            y_accel_hyst = round((accel_old - int(y_accel)) / layer_spread)\n        else:\n            y_accel_hyst = round((int(y_accel) - accel_old) / layer_spread)\n        if accel_old >= int(x_accel):\n            x_accel_start = round(round((accel_old - x_accel_hyst) / 25) * 25)\n        else:\n            x_accel_start = round(round((x_accel_hyst + accel_old) / 25) * 25)\n        if accel_old >= int(y_accel):\n            y_accel_start = round(round((accel_old - y_accel_hyst) / 25) * 25)\n        else:\n            y_accel_start = round(round((y_accel_hyst + accel_old) / 25) * 25)\n        m201_limit_new = 'M201 X' + str(x_accel_start) + ' Y' + str(y_accel_start)\n        layer = data[start_index]\n        lines = layer.split('\\n')\n        for (index, line) in enumerate(lines):\n            if lines[index].startswith(';LAYER:'):\n                lines.insert(index + 1, m201_limit_new)\n                if self.getSettingValueByKey('jerk_enable'):\n                    lines.insert(index + 2, m205_jerk_new)\n                data[start_index] = '\\n'.join(lines)\n                break\n        for num in range(start_index + 1, end_index, 1):\n            layer = data[num]\n            lines = layer.split('\\n')\n            if accel_old >= int(x_accel):\n                x_accel_start -= x_accel_hyst\n                if x_accel_start < int(x_accel):\n                    x_accel_start = int(x_accel)\n            else:\n                x_accel_start += x_accel_hyst\n                if x_accel_start > int(x_accel):\n                    x_accel_start = int(x_accel)\n            if accel_old >= int(y_accel):\n                y_accel_start -= y_accel_hyst\n                if y_accel_start < int(y_accel):\n                    y_accel_start = int(y_accel)\n            else:\n                y_accel_start += y_accel_hyst\n                if y_accel_start > int(y_accel):\n                    y_accel_start = int(y_accel)\n            m201_limit_new = 'M201 X' + str(round(round(x_accel_start / 25) * 25)) + ' Y' + str(round(round(y_accel_start / 25) * 25))\n            for (index, line) in enumerate(lines):\n                if line.startswith(';LAYER:'):\n                    lines.insert(index + 1, m201_limit_new)\n                    continue\n            data[num] = '\\n'.join(lines)\n        if self.getSettingValueByKey('jerk_enable'):\n            for num in range(start_index, len(data) - 1, 1):\n                layer = data[num]\n                lines = layer.split('\\n')\n                for (index, line) in enumerate(lines):\n                    if line.startswith('M205') or line.startswith('M566'):\n                        lines[index] = re.sub(m205_jerk_pattern, m205_jerk_new, line)\n                data[num] = '\\n'.join(lines)\n            data[len(data) - 1] = m201_limit_old + '\\n' + m205_jerk_old + '\\n' + data[len(data) - 1]\n        return data",
            "def execute(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mycura = CuraApplication.getInstance().getGlobalContainerStack()\n    extruder = mycura.extruderList\n    machine_name = str(mycura.getProperty('machine_name', 'value'))\n    print_sequence = str(mycura.getProperty('print_sequence', 'value'))\n    if print_sequence == 'one_at_a_time':\n        Message(text=\"<NOTICE> [Limit the X-Y Accel/Jerk]  DID NOT RUN.  This post processor is not compatible with 'One-at-a-Time' mode.\").show()\n        data[0] += \";  [LimitXYAccelJerk] DID NOT RUN because Cura is set to 'One-at-a-Time' mode.\\n\"\n        return data\n    if 'Ultimaker' in machine_name:\n        Message(text='<NOTICE> [Limit the X-Y Accel/Jerk]  DID NOT RUN.  This post processor is for bed slinger printers only.').show()\n        data[0] += \";  [LimitXYAccelJerk] DID NOT RUN because the printer doesn't have a sliding bed.\\n\"\n        return data\n    type_of_change = str(self.getSettingValueByKey('type_of_change'))\n    accel_print_enabled = bool(extruder[0].getProperty('acceleration_enabled', 'value'))\n    accel_travel_enabled = bool(extruder[0].getProperty('acceleration_travel_enabled', 'value'))\n    accel_print = extruder[0].getProperty('acceleration_print', 'value')\n    accel_travel = extruder[0].getProperty('acceleration_travel', 'value')\n    jerk_print_enabled = str(extruder[0].getProperty('jerk_enabled', 'value'))\n    jerk_travel_enabled = str(extruder[0].getProperty('jerk_travel_enabled', 'value'))\n    jerk_print_old = extruder[0].getProperty('jerk_print', 'value')\n    jerk_travel_old = extruder[0].getProperty('jerk_travel', 'value')\n    if int(accel_print) >= int(accel_travel):\n        accel_old = accel_print\n    else:\n        accel_old = accel_travel\n    jerk_travel = str(extruder[0].getProperty('jerk_travel', 'value'))\n    if int(jerk_print_old) >= int(jerk_travel_old):\n        jerk_old = jerk_print_old\n    else:\n        jerk_old = jerk_travel_old\n    x_accel = str(self.getSettingValueByKey('x_accel_limit'))\n    y_accel = str(self.getSettingValueByKey('y_accel_limit'))\n    x_jerk = int(self.getSettingValueByKey('x_jerk'))\n    y_jerk = int(self.getSettingValueByKey('y_jerk'))\n    if str(self.getSettingValueByKey('jerk_cmd')) == 'reprap_flavor':\n        jerk_cmd = 'M566'\n        x_jerk *= 60\n        y_jerk *= 60\n        jerk_old *= 60\n    else:\n        jerk_cmd = 'M205'\n    m201_limit_new = f'M201 X{x_accel} Y{y_accel}'\n    m201_limit_old = f'M201 X{round(accel_old)} Y{round(accel_old)}'\n    if x_jerk == 0:\n        m205_jerk_pattern = 'Y(\\\\d*)'\n        m205_jerk_new = f'Y{y_jerk}'\n    if y_jerk == 0:\n        m205_jerk_pattern = 'X(\\\\d*)'\n        m205_jerk_new = f'X{x_jerk}'\n    if x_jerk != 0 and y_jerk != 0:\n        m205_jerk_pattern = jerk_cmd + ' X(\\\\d*) Y(\\\\d*)'\n        m205_jerk_new = jerk_cmd + f' X{x_jerk} Y{y_jerk}'\n    m205_jerk_old = jerk_cmd + f' X{jerk_old} Y{jerk_old}'\n    type_of_change = self.getSettingValueByKey('type_of_change')\n    if type_of_change == 'immediate_change':\n        start_layer = int(self.getSettingValueByKey('start_layer')) - 1\n        end_layer = int(self.getSettingValueByKey('end_layer'))\n    else:\n        start_layer = int(self.getSettingValueByKey('gradient_start_layer')) - 1\n        end_layer = int(self.getSettingValueByKey('gradient_end_layer'))\n    start_index = 2\n    end_index = len(data) - 2\n    for num in range(2, len(data) - 1):\n        if ';LAYER:' + str(start_layer) + '\\n' in data[num]:\n            start_index = num\n            break\n    if int(end_layer) > 0:\n        for num in range(3, len(data) - 1):\n            try:\n                if ';LAYER:' + str(end_layer) + '\\n' in data[num]:\n                    end_index = num\n                    break\n            except:\n                end_index = len(data) - 2\n    if type_of_change == 'immediate_change':\n        layer = data[start_index]\n        lines = layer.split('\\n')\n        for (index, line) in enumerate(lines):\n            if lines[index].startswith(';LAYER:'):\n                lines.insert(index + 1, m201_limit_new)\n                if self.getSettingValueByKey('jerk_enable'):\n                    lines.insert(index + 2, m205_jerk_new)\n                data[start_index] = '\\n'.join(lines)\n                break\n        for num in range(start_index, end_index, 1):\n            layer = data[num]\n            lines = layer.split('\\n')\n            for (index, line) in enumerate(lines):\n                if line.startswith('M205') or line.startswith('M566'):\n                    lines[index] = re.sub(m205_jerk_pattern, m205_jerk_new, line)\n            data[num] = '\\n'.join(lines)\n        if end_layer != -1:\n            try:\n                layer = data[end_index - 1]\n                lines = layer.split('\\n')\n                lines.insert(len(lines) - 2, m201_limit_old)\n                lines.insert(len(lines) - 2, m205_jerk_old)\n                data[end_index - 1] = '\\n'.join(lines)\n            except:\n                pass\n        else:\n            data[len(data) - 1] = m201_limit_old + '\\n' + m205_jerk_old + '\\n' + data[len(data) - 1]\n        return data\n    elif type_of_change == 'gradual_change':\n        layer_spread = end_index - start_index\n        if accel_old >= int(x_accel):\n            x_accel_hyst = round((accel_old - int(x_accel)) / layer_spread)\n        else:\n            x_accel_hyst = round((int(x_accel) - accel_old) / layer_spread)\n        if accel_old >= int(y_accel):\n            y_accel_hyst = round((accel_old - int(y_accel)) / layer_spread)\n        else:\n            y_accel_hyst = round((int(y_accel) - accel_old) / layer_spread)\n        if accel_old >= int(x_accel):\n            x_accel_start = round(round((accel_old - x_accel_hyst) / 25) * 25)\n        else:\n            x_accel_start = round(round((x_accel_hyst + accel_old) / 25) * 25)\n        if accel_old >= int(y_accel):\n            y_accel_start = round(round((accel_old - y_accel_hyst) / 25) * 25)\n        else:\n            y_accel_start = round(round((y_accel_hyst + accel_old) / 25) * 25)\n        m201_limit_new = 'M201 X' + str(x_accel_start) + ' Y' + str(y_accel_start)\n        layer = data[start_index]\n        lines = layer.split('\\n')\n        for (index, line) in enumerate(lines):\n            if lines[index].startswith(';LAYER:'):\n                lines.insert(index + 1, m201_limit_new)\n                if self.getSettingValueByKey('jerk_enable'):\n                    lines.insert(index + 2, m205_jerk_new)\n                data[start_index] = '\\n'.join(lines)\n                break\n        for num in range(start_index + 1, end_index, 1):\n            layer = data[num]\n            lines = layer.split('\\n')\n            if accel_old >= int(x_accel):\n                x_accel_start -= x_accel_hyst\n                if x_accel_start < int(x_accel):\n                    x_accel_start = int(x_accel)\n            else:\n                x_accel_start += x_accel_hyst\n                if x_accel_start > int(x_accel):\n                    x_accel_start = int(x_accel)\n            if accel_old >= int(y_accel):\n                y_accel_start -= y_accel_hyst\n                if y_accel_start < int(y_accel):\n                    y_accel_start = int(y_accel)\n            else:\n                y_accel_start += y_accel_hyst\n                if y_accel_start > int(y_accel):\n                    y_accel_start = int(y_accel)\n            m201_limit_new = 'M201 X' + str(round(round(x_accel_start / 25) * 25)) + ' Y' + str(round(round(y_accel_start / 25) * 25))\n            for (index, line) in enumerate(lines):\n                if line.startswith(';LAYER:'):\n                    lines.insert(index + 1, m201_limit_new)\n                    continue\n            data[num] = '\\n'.join(lines)\n        if self.getSettingValueByKey('jerk_enable'):\n            for num in range(start_index, len(data) - 1, 1):\n                layer = data[num]\n                lines = layer.split('\\n')\n                for (index, line) in enumerate(lines):\n                    if line.startswith('M205') or line.startswith('M566'):\n                        lines[index] = re.sub(m205_jerk_pattern, m205_jerk_new, line)\n                data[num] = '\\n'.join(lines)\n            data[len(data) - 1] = m201_limit_old + '\\n' + m205_jerk_old + '\\n' + data[len(data) - 1]\n        return data"
        ]
    }
]