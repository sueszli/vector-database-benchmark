[
    {
        "func_name": "test_volatility",
        "original": "def test_volatility(self):\n    \"\"\"Tests volatility stays close to its mean for small vol of vol.\"\"\"\n    theta = 0.05\n    process = HestonModel(mean_reversion=1.0, theta=theta, volvol=1e-05, rho=-0.0, dtype=np.float64)\n    years = 1.0\n    times = np.linspace(0.0, years, int(365 * years))\n    num_samples = 2\n    paths = process.sample_paths(times, time_step=0.01, num_samples=num_samples, initial_state=np.array([np.log(100), 0.045]), seed=None)\n    volatility_trace = self.evaluate(paths)[..., 1]\n    max_deviation = np.max(abs(volatility_trace[:, 50:] - theta))\n    self.assertAlmostEqual(max_deviation, 0.0, places=2)",
        "mutated": [
            "def test_volatility(self):\n    if False:\n        i = 10\n    'Tests volatility stays close to its mean for small vol of vol.'\n    theta = 0.05\n    process = HestonModel(mean_reversion=1.0, theta=theta, volvol=1e-05, rho=-0.0, dtype=np.float64)\n    years = 1.0\n    times = np.linspace(0.0, years, int(365 * years))\n    num_samples = 2\n    paths = process.sample_paths(times, time_step=0.01, num_samples=num_samples, initial_state=np.array([np.log(100), 0.045]), seed=None)\n    volatility_trace = self.evaluate(paths)[..., 1]\n    max_deviation = np.max(abs(volatility_trace[:, 50:] - theta))\n    self.assertAlmostEqual(max_deviation, 0.0, places=2)",
            "def test_volatility(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests volatility stays close to its mean for small vol of vol.'\n    theta = 0.05\n    process = HestonModel(mean_reversion=1.0, theta=theta, volvol=1e-05, rho=-0.0, dtype=np.float64)\n    years = 1.0\n    times = np.linspace(0.0, years, int(365 * years))\n    num_samples = 2\n    paths = process.sample_paths(times, time_step=0.01, num_samples=num_samples, initial_state=np.array([np.log(100), 0.045]), seed=None)\n    volatility_trace = self.evaluate(paths)[..., 1]\n    max_deviation = np.max(abs(volatility_trace[:, 50:] - theta))\n    self.assertAlmostEqual(max_deviation, 0.0, places=2)",
            "def test_volatility(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests volatility stays close to its mean for small vol of vol.'\n    theta = 0.05\n    process = HestonModel(mean_reversion=1.0, theta=theta, volvol=1e-05, rho=-0.0, dtype=np.float64)\n    years = 1.0\n    times = np.linspace(0.0, years, int(365 * years))\n    num_samples = 2\n    paths = process.sample_paths(times, time_step=0.01, num_samples=num_samples, initial_state=np.array([np.log(100), 0.045]), seed=None)\n    volatility_trace = self.evaluate(paths)[..., 1]\n    max_deviation = np.max(abs(volatility_trace[:, 50:] - theta))\n    self.assertAlmostEqual(max_deviation, 0.0, places=2)",
            "def test_volatility(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests volatility stays close to its mean for small vol of vol.'\n    theta = 0.05\n    process = HestonModel(mean_reversion=1.0, theta=theta, volvol=1e-05, rho=-0.0, dtype=np.float64)\n    years = 1.0\n    times = np.linspace(0.0, years, int(365 * years))\n    num_samples = 2\n    paths = process.sample_paths(times, time_step=0.01, num_samples=num_samples, initial_state=np.array([np.log(100), 0.045]), seed=None)\n    volatility_trace = self.evaluate(paths)[..., 1]\n    max_deviation = np.max(abs(volatility_trace[:, 50:] - theta))\n    self.assertAlmostEqual(max_deviation, 0.0, places=2)",
            "def test_volatility(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests volatility stays close to its mean for small vol of vol.'\n    theta = 0.05\n    process = HestonModel(mean_reversion=1.0, theta=theta, volvol=1e-05, rho=-0.0, dtype=np.float64)\n    years = 1.0\n    times = np.linspace(0.0, years, int(365 * years))\n    num_samples = 2\n    paths = process.sample_paths(times, time_step=0.01, num_samples=num_samples, initial_state=np.array([np.log(100), 0.045]), seed=None)\n    volatility_trace = self.evaluate(paths)[..., 1]\n    max_deviation = np.max(abs(volatility_trace[:, 50:] - theta))\n    self.assertAlmostEqual(max_deviation, 0.0, places=2)"
        ]
    },
    {
        "func_name": "test_state",
        "original": "def test_state(self):\n    \"\"\"Tests state behaves like GBM for small vol of vol.\"\"\"\n    theta = 1.0\n    process = HestonModel(mean_reversion=1.0, theta=theta, volvol=1e-05, rho=-0.0, dtype=np.float64)\n    times = [0.0, 0.5, 1.0]\n    num_samples = 1000\n    start_value = 100\n    paths = process.sample_paths(times, time_step=0.001, num_samples=num_samples, initial_state=np.array([np.log(start_value), 1.0]), seed=None)\n    state_trace = self.evaluate(paths)[..., 0]\n    np.testing.assert_allclose(state_trace[:, 0], np.log(100), 1e-08)\n    for i in (1, 2):\n        gbm_mean = start_value\n        gbm_std = start_value * np.sqrt(np.exp(times[i]) - 1)\n        np.testing.assert_allclose(np.mean(np.exp(state_trace[:, i])), gbm_mean, 1.0)\n        np.testing.assert_allclose(np.std(np.exp(state_trace[:, 1])), gbm_std, 2.0)",
        "mutated": [
            "def test_state(self):\n    if False:\n        i = 10\n    'Tests state behaves like GBM for small vol of vol.'\n    theta = 1.0\n    process = HestonModel(mean_reversion=1.0, theta=theta, volvol=1e-05, rho=-0.0, dtype=np.float64)\n    times = [0.0, 0.5, 1.0]\n    num_samples = 1000\n    start_value = 100\n    paths = process.sample_paths(times, time_step=0.001, num_samples=num_samples, initial_state=np.array([np.log(start_value), 1.0]), seed=None)\n    state_trace = self.evaluate(paths)[..., 0]\n    np.testing.assert_allclose(state_trace[:, 0], np.log(100), 1e-08)\n    for i in (1, 2):\n        gbm_mean = start_value\n        gbm_std = start_value * np.sqrt(np.exp(times[i]) - 1)\n        np.testing.assert_allclose(np.mean(np.exp(state_trace[:, i])), gbm_mean, 1.0)\n        np.testing.assert_allclose(np.std(np.exp(state_trace[:, 1])), gbm_std, 2.0)",
            "def test_state(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests state behaves like GBM for small vol of vol.'\n    theta = 1.0\n    process = HestonModel(mean_reversion=1.0, theta=theta, volvol=1e-05, rho=-0.0, dtype=np.float64)\n    times = [0.0, 0.5, 1.0]\n    num_samples = 1000\n    start_value = 100\n    paths = process.sample_paths(times, time_step=0.001, num_samples=num_samples, initial_state=np.array([np.log(start_value), 1.0]), seed=None)\n    state_trace = self.evaluate(paths)[..., 0]\n    np.testing.assert_allclose(state_trace[:, 0], np.log(100), 1e-08)\n    for i in (1, 2):\n        gbm_mean = start_value\n        gbm_std = start_value * np.sqrt(np.exp(times[i]) - 1)\n        np.testing.assert_allclose(np.mean(np.exp(state_trace[:, i])), gbm_mean, 1.0)\n        np.testing.assert_allclose(np.std(np.exp(state_trace[:, 1])), gbm_std, 2.0)",
            "def test_state(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests state behaves like GBM for small vol of vol.'\n    theta = 1.0\n    process = HestonModel(mean_reversion=1.0, theta=theta, volvol=1e-05, rho=-0.0, dtype=np.float64)\n    times = [0.0, 0.5, 1.0]\n    num_samples = 1000\n    start_value = 100\n    paths = process.sample_paths(times, time_step=0.001, num_samples=num_samples, initial_state=np.array([np.log(start_value), 1.0]), seed=None)\n    state_trace = self.evaluate(paths)[..., 0]\n    np.testing.assert_allclose(state_trace[:, 0], np.log(100), 1e-08)\n    for i in (1, 2):\n        gbm_mean = start_value\n        gbm_std = start_value * np.sqrt(np.exp(times[i]) - 1)\n        np.testing.assert_allclose(np.mean(np.exp(state_trace[:, i])), gbm_mean, 1.0)\n        np.testing.assert_allclose(np.std(np.exp(state_trace[:, 1])), gbm_std, 2.0)",
            "def test_state(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests state behaves like GBM for small vol of vol.'\n    theta = 1.0\n    process = HestonModel(mean_reversion=1.0, theta=theta, volvol=1e-05, rho=-0.0, dtype=np.float64)\n    times = [0.0, 0.5, 1.0]\n    num_samples = 1000\n    start_value = 100\n    paths = process.sample_paths(times, time_step=0.001, num_samples=num_samples, initial_state=np.array([np.log(start_value), 1.0]), seed=None)\n    state_trace = self.evaluate(paths)[..., 0]\n    np.testing.assert_allclose(state_trace[:, 0], np.log(100), 1e-08)\n    for i in (1, 2):\n        gbm_mean = start_value\n        gbm_std = start_value * np.sqrt(np.exp(times[i]) - 1)\n        np.testing.assert_allclose(np.mean(np.exp(state_trace[:, i])), gbm_mean, 1.0)\n        np.testing.assert_allclose(np.std(np.exp(state_trace[:, 1])), gbm_std, 2.0)",
            "def test_state(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests state behaves like GBM for small vol of vol.'\n    theta = 1.0\n    process = HestonModel(mean_reversion=1.0, theta=theta, volvol=1e-05, rho=-0.0, dtype=np.float64)\n    times = [0.0, 0.5, 1.0]\n    num_samples = 1000\n    start_value = 100\n    paths = process.sample_paths(times, time_step=0.001, num_samples=num_samples, initial_state=np.array([np.log(start_value), 1.0]), seed=None)\n    state_trace = self.evaluate(paths)[..., 0]\n    np.testing.assert_allclose(state_trace[:, 0], np.log(100), 1e-08)\n    for i in (1, 2):\n        gbm_mean = start_value\n        gbm_std = start_value * np.sqrt(np.exp(times[i]) - 1)\n        np.testing.assert_allclose(np.mean(np.exp(state_trace[:, i])), gbm_mean, 1.0)\n        np.testing.assert_allclose(np.std(np.exp(state_trace[:, 1])), gbm_std, 2.0)"
        ]
    },
    {
        "func_name": "test_expected_total_variance_scalar",
        "original": "def test_expected_total_variance_scalar(self):\n    \"\"\"Tests the expected total variance calculation.\"\"\"\n    mean_reversion = 1.3\n    theta = 0.2\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=0.01, rho=0.1, dtype=np.float64)\n    future_time = 1.2\n    initial_var = 0.3\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    ground_var = (initial_var - theta) * (1 - np.exp(-mean_reversion * future_time)) / mean_reversion + theta * future_time\n    np.testing.assert_allclose(expected_var, ground_var)",
        "mutated": [
            "def test_expected_total_variance_scalar(self):\n    if False:\n        i = 10\n    'Tests the expected total variance calculation.'\n    mean_reversion = 1.3\n    theta = 0.2\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=0.01, rho=0.1, dtype=np.float64)\n    future_time = 1.2\n    initial_var = 0.3\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    ground_var = (initial_var - theta) * (1 - np.exp(-mean_reversion * future_time)) / mean_reversion + theta * future_time\n    np.testing.assert_allclose(expected_var, ground_var)",
            "def test_expected_total_variance_scalar(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests the expected total variance calculation.'\n    mean_reversion = 1.3\n    theta = 0.2\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=0.01, rho=0.1, dtype=np.float64)\n    future_time = 1.2\n    initial_var = 0.3\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    ground_var = (initial_var - theta) * (1 - np.exp(-mean_reversion * future_time)) / mean_reversion + theta * future_time\n    np.testing.assert_allclose(expected_var, ground_var)",
            "def test_expected_total_variance_scalar(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests the expected total variance calculation.'\n    mean_reversion = 1.3\n    theta = 0.2\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=0.01, rho=0.1, dtype=np.float64)\n    future_time = 1.2\n    initial_var = 0.3\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    ground_var = (initial_var - theta) * (1 - np.exp(-mean_reversion * future_time)) / mean_reversion + theta * future_time\n    np.testing.assert_allclose(expected_var, ground_var)",
            "def test_expected_total_variance_scalar(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests the expected total variance calculation.'\n    mean_reversion = 1.3\n    theta = 0.2\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=0.01, rho=0.1, dtype=np.float64)\n    future_time = 1.2\n    initial_var = 0.3\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    ground_var = (initial_var - theta) * (1 - np.exp(-mean_reversion * future_time)) / mean_reversion + theta * future_time\n    np.testing.assert_allclose(expected_var, ground_var)",
            "def test_expected_total_variance_scalar(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests the expected total variance calculation.'\n    mean_reversion = 1.3\n    theta = 0.2\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=0.01, rho=0.1, dtype=np.float64)\n    future_time = 1.2\n    initial_var = 0.3\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    ground_var = (initial_var - theta) * (1 - np.exp(-mean_reversion * future_time)) / mean_reversion + theta * future_time\n    np.testing.assert_allclose(expected_var, ground_var)"
        ]
    },
    {
        "func_name": "test_expected_var_mc",
        "original": "def test_expected_var_mc(self):\n    \"\"\"Tests the expected total var calculation matches Monte Carlo results.\"\"\"\n    initial_var = 0.1\n    rho = -0.5\n    volvol = 1.0\n    mean_reversion = 10.0\n    theta = 0.04\n    dtype = tf.float64\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    num_samples = 10000\n    num_times = 252\n    initial_state = tf.constant([1.0, initial_var], dtype=dtype)\n    future_time = 1.0\n    times = tf.constant(np.linspace(0, future_time, num_times), dtype=dtype)\n    time_step = 0.1\n    paths = process.sample_paths(times, initial_state, time_step=time_step, num_samples=num_samples, seed=123)\n    mc_estimate_var = self.evaluate(tf.math.reduce_mean(tf.math.reduce_sum(tff.math.diff(times) * paths[:, :, 1], axis=1)))\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    np.testing.assert_allclose(expected_var, mc_estimate_var, rtol=0.01)",
        "mutated": [
            "def test_expected_var_mc(self):\n    if False:\n        i = 10\n    'Tests the expected total var calculation matches Monte Carlo results.'\n    initial_var = 0.1\n    rho = -0.5\n    volvol = 1.0\n    mean_reversion = 10.0\n    theta = 0.04\n    dtype = tf.float64\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    num_samples = 10000\n    num_times = 252\n    initial_state = tf.constant([1.0, initial_var], dtype=dtype)\n    future_time = 1.0\n    times = tf.constant(np.linspace(0, future_time, num_times), dtype=dtype)\n    time_step = 0.1\n    paths = process.sample_paths(times, initial_state, time_step=time_step, num_samples=num_samples, seed=123)\n    mc_estimate_var = self.evaluate(tf.math.reduce_mean(tf.math.reduce_sum(tff.math.diff(times) * paths[:, :, 1], axis=1)))\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    np.testing.assert_allclose(expected_var, mc_estimate_var, rtol=0.01)",
            "def test_expected_var_mc(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests the expected total var calculation matches Monte Carlo results.'\n    initial_var = 0.1\n    rho = -0.5\n    volvol = 1.0\n    mean_reversion = 10.0\n    theta = 0.04\n    dtype = tf.float64\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    num_samples = 10000\n    num_times = 252\n    initial_state = tf.constant([1.0, initial_var], dtype=dtype)\n    future_time = 1.0\n    times = tf.constant(np.linspace(0, future_time, num_times), dtype=dtype)\n    time_step = 0.1\n    paths = process.sample_paths(times, initial_state, time_step=time_step, num_samples=num_samples, seed=123)\n    mc_estimate_var = self.evaluate(tf.math.reduce_mean(tf.math.reduce_sum(tff.math.diff(times) * paths[:, :, 1], axis=1)))\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    np.testing.assert_allclose(expected_var, mc_estimate_var, rtol=0.01)",
            "def test_expected_var_mc(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests the expected total var calculation matches Monte Carlo results.'\n    initial_var = 0.1\n    rho = -0.5\n    volvol = 1.0\n    mean_reversion = 10.0\n    theta = 0.04\n    dtype = tf.float64\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    num_samples = 10000\n    num_times = 252\n    initial_state = tf.constant([1.0, initial_var], dtype=dtype)\n    future_time = 1.0\n    times = tf.constant(np.linspace(0, future_time, num_times), dtype=dtype)\n    time_step = 0.1\n    paths = process.sample_paths(times, initial_state, time_step=time_step, num_samples=num_samples, seed=123)\n    mc_estimate_var = self.evaluate(tf.math.reduce_mean(tf.math.reduce_sum(tff.math.diff(times) * paths[:, :, 1], axis=1)))\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    np.testing.assert_allclose(expected_var, mc_estimate_var, rtol=0.01)",
            "def test_expected_var_mc(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests the expected total var calculation matches Monte Carlo results.'\n    initial_var = 0.1\n    rho = -0.5\n    volvol = 1.0\n    mean_reversion = 10.0\n    theta = 0.04\n    dtype = tf.float64\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    num_samples = 10000\n    num_times = 252\n    initial_state = tf.constant([1.0, initial_var], dtype=dtype)\n    future_time = 1.0\n    times = tf.constant(np.linspace(0, future_time, num_times), dtype=dtype)\n    time_step = 0.1\n    paths = process.sample_paths(times, initial_state, time_step=time_step, num_samples=num_samples, seed=123)\n    mc_estimate_var = self.evaluate(tf.math.reduce_mean(tf.math.reduce_sum(tff.math.diff(times) * paths[:, :, 1], axis=1)))\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    np.testing.assert_allclose(expected_var, mc_estimate_var, rtol=0.01)",
            "def test_expected_var_mc(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests the expected total var calculation matches Monte Carlo results.'\n    initial_var = 0.1\n    rho = -0.5\n    volvol = 1.0\n    mean_reversion = 10.0\n    theta = 0.04\n    dtype = tf.float64\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    num_samples = 10000\n    num_times = 252\n    initial_state = tf.constant([1.0, initial_var], dtype=dtype)\n    future_time = 1.0\n    times = tf.constant(np.linspace(0, future_time, num_times), dtype=dtype)\n    time_step = 0.1\n    paths = process.sample_paths(times, initial_state, time_step=time_step, num_samples=num_samples, seed=123)\n    mc_estimate_var = self.evaluate(tf.math.reduce_mean(tf.math.reduce_sum(tff.math.diff(times) * paths[:, :, 1], axis=1)))\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    np.testing.assert_allclose(expected_var, mc_estimate_var, rtol=0.01)"
        ]
    },
    {
        "func_name": "test_expected_total_variance_batch",
        "original": "def test_expected_total_variance_batch(self):\n    \"\"\"Tests the expected total variance calculation.\"\"\"\n    mean_reversion = 1.3\n    theta = 0.2\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=0.01, rho=-0.0, dtype=np.float64)\n    future_time = np.array([0.1, 1.0, 2.0])\n    initial_var = np.array([0.1, 0.2, 0.3])\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    ground_var = (initial_var - theta) * (1 - np.exp(-mean_reversion * future_time)) / mean_reversion + theta * future_time\n    np.testing.assert_allclose(expected_var, ground_var)",
        "mutated": [
            "def test_expected_total_variance_batch(self):\n    if False:\n        i = 10\n    'Tests the expected total variance calculation.'\n    mean_reversion = 1.3\n    theta = 0.2\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=0.01, rho=-0.0, dtype=np.float64)\n    future_time = np.array([0.1, 1.0, 2.0])\n    initial_var = np.array([0.1, 0.2, 0.3])\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    ground_var = (initial_var - theta) * (1 - np.exp(-mean_reversion * future_time)) / mean_reversion + theta * future_time\n    np.testing.assert_allclose(expected_var, ground_var)",
            "def test_expected_total_variance_batch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests the expected total variance calculation.'\n    mean_reversion = 1.3\n    theta = 0.2\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=0.01, rho=-0.0, dtype=np.float64)\n    future_time = np.array([0.1, 1.0, 2.0])\n    initial_var = np.array([0.1, 0.2, 0.3])\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    ground_var = (initial_var - theta) * (1 - np.exp(-mean_reversion * future_time)) / mean_reversion + theta * future_time\n    np.testing.assert_allclose(expected_var, ground_var)",
            "def test_expected_total_variance_batch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests the expected total variance calculation.'\n    mean_reversion = 1.3\n    theta = 0.2\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=0.01, rho=-0.0, dtype=np.float64)\n    future_time = np.array([0.1, 1.0, 2.0])\n    initial_var = np.array([0.1, 0.2, 0.3])\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    ground_var = (initial_var - theta) * (1 - np.exp(-mean_reversion * future_time)) / mean_reversion + theta * future_time\n    np.testing.assert_allclose(expected_var, ground_var)",
            "def test_expected_total_variance_batch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests the expected total variance calculation.'\n    mean_reversion = 1.3\n    theta = 0.2\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=0.01, rho=-0.0, dtype=np.float64)\n    future_time = np.array([0.1, 1.0, 2.0])\n    initial_var = np.array([0.1, 0.2, 0.3])\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    ground_var = (initial_var - theta) * (1 - np.exp(-mean_reversion * future_time)) / mean_reversion + theta * future_time\n    np.testing.assert_allclose(expected_var, ground_var)",
            "def test_expected_total_variance_batch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests the expected total variance calculation.'\n    mean_reversion = 1.3\n    theta = 0.2\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=0.01, rho=-0.0, dtype=np.float64)\n    future_time = np.array([0.1, 1.0, 2.0])\n    initial_var = np.array([0.1, 0.2, 0.3])\n    expected_var = self.evaluate(process.expected_total_variance(future_time, initial_var))\n    ground_var = (initial_var - theta) * (1 - np.exp(-mean_reversion * future_time)) / mean_reversion + theta * future_time\n    np.testing.assert_allclose(expected_var, ground_var)"
        ]
    },
    {
        "func_name": "test_expected_var_raises_on_piecewise_params",
        "original": "def test_expected_var_raises_on_piecewise_params(self):\n    \"\"\"Tests the claimed error is raised for piecewise params.\"\"\"\n    dtype = tf.float64\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 1.1], dtype=dtype)\n    theta = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 0.9], dtype=dtype)\n    volvol = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.3], values=[0.1, 0.2], dtype=dtype)\n    rho = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.4, 0.6], dtype=dtype)\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    with self.assertRaises(ValueError):\n        process.expected_total_variance(1.0, 1.0)",
        "mutated": [
            "def test_expected_var_raises_on_piecewise_params(self):\n    if False:\n        i = 10\n    'Tests the claimed error is raised for piecewise params.'\n    dtype = tf.float64\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 1.1], dtype=dtype)\n    theta = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 0.9], dtype=dtype)\n    volvol = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.3], values=[0.1, 0.2], dtype=dtype)\n    rho = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.4, 0.6], dtype=dtype)\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    with self.assertRaises(ValueError):\n        process.expected_total_variance(1.0, 1.0)",
            "def test_expected_var_raises_on_piecewise_params(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests the claimed error is raised for piecewise params.'\n    dtype = tf.float64\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 1.1], dtype=dtype)\n    theta = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 0.9], dtype=dtype)\n    volvol = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.3], values=[0.1, 0.2], dtype=dtype)\n    rho = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.4, 0.6], dtype=dtype)\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    with self.assertRaises(ValueError):\n        process.expected_total_variance(1.0, 1.0)",
            "def test_expected_var_raises_on_piecewise_params(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests the claimed error is raised for piecewise params.'\n    dtype = tf.float64\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 1.1], dtype=dtype)\n    theta = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 0.9], dtype=dtype)\n    volvol = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.3], values=[0.1, 0.2], dtype=dtype)\n    rho = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.4, 0.6], dtype=dtype)\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    with self.assertRaises(ValueError):\n        process.expected_total_variance(1.0, 1.0)",
            "def test_expected_var_raises_on_piecewise_params(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests the claimed error is raised for piecewise params.'\n    dtype = tf.float64\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 1.1], dtype=dtype)\n    theta = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 0.9], dtype=dtype)\n    volvol = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.3], values=[0.1, 0.2], dtype=dtype)\n    rho = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.4, 0.6], dtype=dtype)\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    with self.assertRaises(ValueError):\n        process.expected_total_variance(1.0, 1.0)",
            "def test_expected_var_raises_on_piecewise_params(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests the claimed error is raised for piecewise params.'\n    dtype = tf.float64\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 1.1], dtype=dtype)\n    theta = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 0.9], dtype=dtype)\n    volvol = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.3], values=[0.1, 0.2], dtype=dtype)\n    rho = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.4, 0.6], dtype=dtype)\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    with self.assertRaises(ValueError):\n        process.expected_total_variance(1.0, 1.0)"
        ]
    },
    {
        "func_name": "test_piecewise_and_dtype",
        "original": "@parameterized.named_parameters(('SinglePrecision', np.float32), ('DoublePrecision', np.float64), ('AutoDtype', None))\ndef test_piecewise_and_dtype(self, dtype):\n    \"\"\"Tests that piecewise constant coefficients can be handled.\"\"\"\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 1.1], dtype=dtype)\n    theta = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 0.9], dtype=dtype)\n    volvol = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.3], values=[0.1, 0.2], dtype=dtype)\n    rho = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.4, 0.6], dtype=dtype)\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    times = [0.1, 1.0]\n    num_samples = 100\n    initial_state = np.array([np.log(100), 0.045], dtype=dtype)\n    paths = process.sample_paths(times, time_step=0.1, num_samples=num_samples, initial_state=initial_state, seed=None)\n    paths = self.evaluate(paths)\n    (state_trace, volatility_trace) = (paths[..., 0], paths[..., 0])\n    if dtype is not None:\n        with self.subTest('VolatilityDtype'):\n            self.assertEqual(volatility_trace.dtype, dtype)\n        with self.subTest('StateDtype'):\n            self.assertEqual(state_trace.dtype, dtype)\n    dtype = paths.dtype\n    initial_state = tf.convert_to_tensor(initial_state, dtype=dtype)\n    with self.subTest('Drift'):\n        self.assertAllClose(process.drift_fn()(times[0], initial_state), np.array([-0.0225, 0.955]))\n    with self.subTest('Volatility'):\n        self.assertAllClose(process.volatility_fn()(times[0], initial_state), np.array([[0.21213203, 0.0], [0.00848528, 0.01944222]]))",
        "mutated": [
            "@parameterized.named_parameters(('SinglePrecision', np.float32), ('DoublePrecision', np.float64), ('AutoDtype', None))\ndef test_piecewise_and_dtype(self, dtype):\n    if False:\n        i = 10\n    'Tests that piecewise constant coefficients can be handled.'\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 1.1], dtype=dtype)\n    theta = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 0.9], dtype=dtype)\n    volvol = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.3], values=[0.1, 0.2], dtype=dtype)\n    rho = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.4, 0.6], dtype=dtype)\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    times = [0.1, 1.0]\n    num_samples = 100\n    initial_state = np.array([np.log(100), 0.045], dtype=dtype)\n    paths = process.sample_paths(times, time_step=0.1, num_samples=num_samples, initial_state=initial_state, seed=None)\n    paths = self.evaluate(paths)\n    (state_trace, volatility_trace) = (paths[..., 0], paths[..., 0])\n    if dtype is not None:\n        with self.subTest('VolatilityDtype'):\n            self.assertEqual(volatility_trace.dtype, dtype)\n        with self.subTest('StateDtype'):\n            self.assertEqual(state_trace.dtype, dtype)\n    dtype = paths.dtype\n    initial_state = tf.convert_to_tensor(initial_state, dtype=dtype)\n    with self.subTest('Drift'):\n        self.assertAllClose(process.drift_fn()(times[0], initial_state), np.array([-0.0225, 0.955]))\n    with self.subTest('Volatility'):\n        self.assertAllClose(process.volatility_fn()(times[0], initial_state), np.array([[0.21213203, 0.0], [0.00848528, 0.01944222]]))",
            "@parameterized.named_parameters(('SinglePrecision', np.float32), ('DoublePrecision', np.float64), ('AutoDtype', None))\ndef test_piecewise_and_dtype(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that piecewise constant coefficients can be handled.'\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 1.1], dtype=dtype)\n    theta = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 0.9], dtype=dtype)\n    volvol = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.3], values=[0.1, 0.2], dtype=dtype)\n    rho = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.4, 0.6], dtype=dtype)\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    times = [0.1, 1.0]\n    num_samples = 100\n    initial_state = np.array([np.log(100), 0.045], dtype=dtype)\n    paths = process.sample_paths(times, time_step=0.1, num_samples=num_samples, initial_state=initial_state, seed=None)\n    paths = self.evaluate(paths)\n    (state_trace, volatility_trace) = (paths[..., 0], paths[..., 0])\n    if dtype is not None:\n        with self.subTest('VolatilityDtype'):\n            self.assertEqual(volatility_trace.dtype, dtype)\n        with self.subTest('StateDtype'):\n            self.assertEqual(state_trace.dtype, dtype)\n    dtype = paths.dtype\n    initial_state = tf.convert_to_tensor(initial_state, dtype=dtype)\n    with self.subTest('Drift'):\n        self.assertAllClose(process.drift_fn()(times[0], initial_state), np.array([-0.0225, 0.955]))\n    with self.subTest('Volatility'):\n        self.assertAllClose(process.volatility_fn()(times[0], initial_state), np.array([[0.21213203, 0.0], [0.00848528, 0.01944222]]))",
            "@parameterized.named_parameters(('SinglePrecision', np.float32), ('DoublePrecision', np.float64), ('AutoDtype', None))\ndef test_piecewise_and_dtype(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that piecewise constant coefficients can be handled.'\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 1.1], dtype=dtype)\n    theta = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 0.9], dtype=dtype)\n    volvol = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.3], values=[0.1, 0.2], dtype=dtype)\n    rho = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.4, 0.6], dtype=dtype)\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    times = [0.1, 1.0]\n    num_samples = 100\n    initial_state = np.array([np.log(100), 0.045], dtype=dtype)\n    paths = process.sample_paths(times, time_step=0.1, num_samples=num_samples, initial_state=initial_state, seed=None)\n    paths = self.evaluate(paths)\n    (state_trace, volatility_trace) = (paths[..., 0], paths[..., 0])\n    if dtype is not None:\n        with self.subTest('VolatilityDtype'):\n            self.assertEqual(volatility_trace.dtype, dtype)\n        with self.subTest('StateDtype'):\n            self.assertEqual(state_trace.dtype, dtype)\n    dtype = paths.dtype\n    initial_state = tf.convert_to_tensor(initial_state, dtype=dtype)\n    with self.subTest('Drift'):\n        self.assertAllClose(process.drift_fn()(times[0], initial_state), np.array([-0.0225, 0.955]))\n    with self.subTest('Volatility'):\n        self.assertAllClose(process.volatility_fn()(times[0], initial_state), np.array([[0.21213203, 0.0], [0.00848528, 0.01944222]]))",
            "@parameterized.named_parameters(('SinglePrecision', np.float32), ('DoublePrecision', np.float64), ('AutoDtype', None))\ndef test_piecewise_and_dtype(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that piecewise constant coefficients can be handled.'\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 1.1], dtype=dtype)\n    theta = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 0.9], dtype=dtype)\n    volvol = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.3], values=[0.1, 0.2], dtype=dtype)\n    rho = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.4, 0.6], dtype=dtype)\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    times = [0.1, 1.0]\n    num_samples = 100\n    initial_state = np.array([np.log(100), 0.045], dtype=dtype)\n    paths = process.sample_paths(times, time_step=0.1, num_samples=num_samples, initial_state=initial_state, seed=None)\n    paths = self.evaluate(paths)\n    (state_trace, volatility_trace) = (paths[..., 0], paths[..., 0])\n    if dtype is not None:\n        with self.subTest('VolatilityDtype'):\n            self.assertEqual(volatility_trace.dtype, dtype)\n        with self.subTest('StateDtype'):\n            self.assertEqual(state_trace.dtype, dtype)\n    dtype = paths.dtype\n    initial_state = tf.convert_to_tensor(initial_state, dtype=dtype)\n    with self.subTest('Drift'):\n        self.assertAllClose(process.drift_fn()(times[0], initial_state), np.array([-0.0225, 0.955]))\n    with self.subTest('Volatility'):\n        self.assertAllClose(process.volatility_fn()(times[0], initial_state), np.array([[0.21213203, 0.0], [0.00848528, 0.01944222]]))",
            "@parameterized.named_parameters(('SinglePrecision', np.float32), ('DoublePrecision', np.float64), ('AutoDtype', None))\ndef test_piecewise_and_dtype(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that piecewise constant coefficients can be handled.'\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 1.1], dtype=dtype)\n    theta = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[1, 0.9], dtype=dtype)\n    volvol = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.3], values=[0.1, 0.2], dtype=dtype)\n    rho = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.5], values=[0.4, 0.6], dtype=dtype)\n    process = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    times = [0.1, 1.0]\n    num_samples = 100\n    initial_state = np.array([np.log(100), 0.045], dtype=dtype)\n    paths = process.sample_paths(times, time_step=0.1, num_samples=num_samples, initial_state=initial_state, seed=None)\n    paths = self.evaluate(paths)\n    (state_trace, volatility_trace) = (paths[..., 0], paths[..., 0])\n    if dtype is not None:\n        with self.subTest('VolatilityDtype'):\n            self.assertEqual(volatility_trace.dtype, dtype)\n        with self.subTest('StateDtype'):\n            self.assertEqual(state_trace.dtype, dtype)\n    dtype = paths.dtype\n    initial_state = tf.convert_to_tensor(initial_state, dtype=dtype)\n    with self.subTest('Drift'):\n        self.assertAllClose(process.drift_fn()(times[0], initial_state), np.array([-0.0225, 0.955]))\n    with self.subTest('Volatility'):\n        self.assertAllClose(process.volatility_fn()(times[0], initial_state), np.array([[0.21213203, 0.0], [0.00848528, 0.01944222]]))"
        ]
    },
    {
        "func_name": "test_compare_monte_carlo_to_backward_pde",
        "original": "def test_compare_monte_carlo_to_backward_pde(self):\n    dtype = tf.float64\n    mean_reversion = 0.3\n    theta = 0.05\n    volvol = 0.02\n    rho = 0.1\n    maturity_time = 1.0\n    initial_log_spot = 3.0\n    initial_vol = 0.05\n    strike = 15\n    discounting = 0.5\n    heston = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    initial_state = np.array([initial_log_spot, initial_vol])\n    samples = heston.sample_paths(times=[maturity_time / 2, maturity_time], initial_state=initial_state, time_step=0.01, num_samples=1000, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 42])\n    self.assertEqual(samples.shape, [1000, 2, 2])\n    log_spots = samples[:, -1, 0]\n    monte_carlo_price = tf.constant(np.exp(-discounting * maturity_time), dtype=dtype) * tf.math.reduce_mean(tf.nn.relu(tf.math.exp(log_spots) - strike))\n    (s_min, s_max) = (2, 4)\n    (v_min, v_max) = (0.03, 0.07)\n    (grid_size_s, grid_size_v) = (101, 101)\n    time_step = 0.01\n    grid = grids.uniform_grid(minimums=[s_min, v_min], maximums=[s_max, v_max], sizes=[grid_size_s, grid_size_v], dtype=dtype)\n    (s_mesh, _) = tf.meshgrid(grid[0], grid[1], indexing='ij')\n    final_value_grid = tf.nn.relu(tf.math.exp(s_mesh) - strike)\n    value_grid = heston.fd_solver_backward(start_time=1.0, end_time=0.0, coord_grid=grid, values_grid=final_value_grid, time_step=time_step, discounting=lambda *args: discounting)[0]\n    pde_price = value_grid[int(grid_size_s / 2), int(grid_size_v / 2)]\n    self.assertAllClose(monte_carlo_price, pde_price, atol=0.1, rtol=0.1)",
        "mutated": [
            "def test_compare_monte_carlo_to_backward_pde(self):\n    if False:\n        i = 10\n    dtype = tf.float64\n    mean_reversion = 0.3\n    theta = 0.05\n    volvol = 0.02\n    rho = 0.1\n    maturity_time = 1.0\n    initial_log_spot = 3.0\n    initial_vol = 0.05\n    strike = 15\n    discounting = 0.5\n    heston = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    initial_state = np.array([initial_log_spot, initial_vol])\n    samples = heston.sample_paths(times=[maturity_time / 2, maturity_time], initial_state=initial_state, time_step=0.01, num_samples=1000, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 42])\n    self.assertEqual(samples.shape, [1000, 2, 2])\n    log_spots = samples[:, -1, 0]\n    monte_carlo_price = tf.constant(np.exp(-discounting * maturity_time), dtype=dtype) * tf.math.reduce_mean(tf.nn.relu(tf.math.exp(log_spots) - strike))\n    (s_min, s_max) = (2, 4)\n    (v_min, v_max) = (0.03, 0.07)\n    (grid_size_s, grid_size_v) = (101, 101)\n    time_step = 0.01\n    grid = grids.uniform_grid(minimums=[s_min, v_min], maximums=[s_max, v_max], sizes=[grid_size_s, grid_size_v], dtype=dtype)\n    (s_mesh, _) = tf.meshgrid(grid[0], grid[1], indexing='ij')\n    final_value_grid = tf.nn.relu(tf.math.exp(s_mesh) - strike)\n    value_grid = heston.fd_solver_backward(start_time=1.0, end_time=0.0, coord_grid=grid, values_grid=final_value_grid, time_step=time_step, discounting=lambda *args: discounting)[0]\n    pde_price = value_grid[int(grid_size_s / 2), int(grid_size_v / 2)]\n    self.assertAllClose(monte_carlo_price, pde_price, atol=0.1, rtol=0.1)",
            "def test_compare_monte_carlo_to_backward_pde(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dtype = tf.float64\n    mean_reversion = 0.3\n    theta = 0.05\n    volvol = 0.02\n    rho = 0.1\n    maturity_time = 1.0\n    initial_log_spot = 3.0\n    initial_vol = 0.05\n    strike = 15\n    discounting = 0.5\n    heston = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    initial_state = np.array([initial_log_spot, initial_vol])\n    samples = heston.sample_paths(times=[maturity_time / 2, maturity_time], initial_state=initial_state, time_step=0.01, num_samples=1000, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 42])\n    self.assertEqual(samples.shape, [1000, 2, 2])\n    log_spots = samples[:, -1, 0]\n    monte_carlo_price = tf.constant(np.exp(-discounting * maturity_time), dtype=dtype) * tf.math.reduce_mean(tf.nn.relu(tf.math.exp(log_spots) - strike))\n    (s_min, s_max) = (2, 4)\n    (v_min, v_max) = (0.03, 0.07)\n    (grid_size_s, grid_size_v) = (101, 101)\n    time_step = 0.01\n    grid = grids.uniform_grid(minimums=[s_min, v_min], maximums=[s_max, v_max], sizes=[grid_size_s, grid_size_v], dtype=dtype)\n    (s_mesh, _) = tf.meshgrid(grid[0], grid[1], indexing='ij')\n    final_value_grid = tf.nn.relu(tf.math.exp(s_mesh) - strike)\n    value_grid = heston.fd_solver_backward(start_time=1.0, end_time=0.0, coord_grid=grid, values_grid=final_value_grid, time_step=time_step, discounting=lambda *args: discounting)[0]\n    pde_price = value_grid[int(grid_size_s / 2), int(grid_size_v / 2)]\n    self.assertAllClose(monte_carlo_price, pde_price, atol=0.1, rtol=0.1)",
            "def test_compare_monte_carlo_to_backward_pde(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dtype = tf.float64\n    mean_reversion = 0.3\n    theta = 0.05\n    volvol = 0.02\n    rho = 0.1\n    maturity_time = 1.0\n    initial_log_spot = 3.0\n    initial_vol = 0.05\n    strike = 15\n    discounting = 0.5\n    heston = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    initial_state = np.array([initial_log_spot, initial_vol])\n    samples = heston.sample_paths(times=[maturity_time / 2, maturity_time], initial_state=initial_state, time_step=0.01, num_samples=1000, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 42])\n    self.assertEqual(samples.shape, [1000, 2, 2])\n    log_spots = samples[:, -1, 0]\n    monte_carlo_price = tf.constant(np.exp(-discounting * maturity_time), dtype=dtype) * tf.math.reduce_mean(tf.nn.relu(tf.math.exp(log_spots) - strike))\n    (s_min, s_max) = (2, 4)\n    (v_min, v_max) = (0.03, 0.07)\n    (grid_size_s, grid_size_v) = (101, 101)\n    time_step = 0.01\n    grid = grids.uniform_grid(minimums=[s_min, v_min], maximums=[s_max, v_max], sizes=[grid_size_s, grid_size_v], dtype=dtype)\n    (s_mesh, _) = tf.meshgrid(grid[0], grid[1], indexing='ij')\n    final_value_grid = tf.nn.relu(tf.math.exp(s_mesh) - strike)\n    value_grid = heston.fd_solver_backward(start_time=1.0, end_time=0.0, coord_grid=grid, values_grid=final_value_grid, time_step=time_step, discounting=lambda *args: discounting)[0]\n    pde_price = value_grid[int(grid_size_s / 2), int(grid_size_v / 2)]\n    self.assertAllClose(monte_carlo_price, pde_price, atol=0.1, rtol=0.1)",
            "def test_compare_monte_carlo_to_backward_pde(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dtype = tf.float64\n    mean_reversion = 0.3\n    theta = 0.05\n    volvol = 0.02\n    rho = 0.1\n    maturity_time = 1.0\n    initial_log_spot = 3.0\n    initial_vol = 0.05\n    strike = 15\n    discounting = 0.5\n    heston = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    initial_state = np.array([initial_log_spot, initial_vol])\n    samples = heston.sample_paths(times=[maturity_time / 2, maturity_time], initial_state=initial_state, time_step=0.01, num_samples=1000, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 42])\n    self.assertEqual(samples.shape, [1000, 2, 2])\n    log_spots = samples[:, -1, 0]\n    monte_carlo_price = tf.constant(np.exp(-discounting * maturity_time), dtype=dtype) * tf.math.reduce_mean(tf.nn.relu(tf.math.exp(log_spots) - strike))\n    (s_min, s_max) = (2, 4)\n    (v_min, v_max) = (0.03, 0.07)\n    (grid_size_s, grid_size_v) = (101, 101)\n    time_step = 0.01\n    grid = grids.uniform_grid(minimums=[s_min, v_min], maximums=[s_max, v_max], sizes=[grid_size_s, grid_size_v], dtype=dtype)\n    (s_mesh, _) = tf.meshgrid(grid[0], grid[1], indexing='ij')\n    final_value_grid = tf.nn.relu(tf.math.exp(s_mesh) - strike)\n    value_grid = heston.fd_solver_backward(start_time=1.0, end_time=0.0, coord_grid=grid, values_grid=final_value_grid, time_step=time_step, discounting=lambda *args: discounting)[0]\n    pde_price = value_grid[int(grid_size_s / 2), int(grid_size_v / 2)]\n    self.assertAllClose(monte_carlo_price, pde_price, atol=0.1, rtol=0.1)",
            "def test_compare_monte_carlo_to_backward_pde(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dtype = tf.float64\n    mean_reversion = 0.3\n    theta = 0.05\n    volvol = 0.02\n    rho = 0.1\n    maturity_time = 1.0\n    initial_log_spot = 3.0\n    initial_vol = 0.05\n    strike = 15\n    discounting = 0.5\n    heston = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    initial_state = np.array([initial_log_spot, initial_vol])\n    samples = heston.sample_paths(times=[maturity_time / 2, maturity_time], initial_state=initial_state, time_step=0.01, num_samples=1000, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=[1, 42])\n    self.assertEqual(samples.shape, [1000, 2, 2])\n    log_spots = samples[:, -1, 0]\n    monte_carlo_price = tf.constant(np.exp(-discounting * maturity_time), dtype=dtype) * tf.math.reduce_mean(tf.nn.relu(tf.math.exp(log_spots) - strike))\n    (s_min, s_max) = (2, 4)\n    (v_min, v_max) = (0.03, 0.07)\n    (grid_size_s, grid_size_v) = (101, 101)\n    time_step = 0.01\n    grid = grids.uniform_grid(minimums=[s_min, v_min], maximums=[s_max, v_max], sizes=[grid_size_s, grid_size_v], dtype=dtype)\n    (s_mesh, _) = tf.meshgrid(grid[0], grid[1], indexing='ij')\n    final_value_grid = tf.nn.relu(tf.math.exp(s_mesh) - strike)\n    value_grid = heston.fd_solver_backward(start_time=1.0, end_time=0.0, coord_grid=grid, values_grid=final_value_grid, time_step=time_step, discounting=lambda *args: discounting)[0]\n    pde_price = value_grid[int(grid_size_s / 2), int(grid_size_v / 2)]\n    self.assertAllClose(monte_carlo_price, pde_price, atol=0.1, rtol=0.1)"
        ]
    },
    {
        "func_name": "test_compare_monte_carlo_to_european_option",
        "original": "@parameterized.named_parameters({'testcase_name': 'SamplePathsWithNumTimeStep', 'use_num_time_step': True, 'use_time_grid': False, 'supply_normal_draws': False}, {'testcase_name': 'SamplePathsWithGrid', 'use_num_time_step': False, 'use_time_grid': True, 'supply_normal_draws': False}, {'testcase_name': 'SamplePathsWithGridAndDraws', 'use_num_time_step': False, 'use_time_grid': True, 'supply_normal_draws': True})\ndef test_compare_monte_carlo_to_european_option(self, use_num_time_step, use_time_grid, supply_normal_draws):\n    dtype = tf.float64\n    mean_reversion_value = 0.3\n    theta = 0.05\n    volvol = 0.02\n    rho = 0.1\n    maturity_time = 1.0\n    initial_log_spot = 3.0\n    initial_vol = 0.05\n    strike = 15\n    discounting = 0.5\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.1, 0.2], values=[mean_reversion_value, mean_reversion_value, mean_reversion_value], dtype=dtype)\n    heston = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    times = [maturity_time / 2, maturity_time]\n    num_samples = 10000\n    time_step = None\n    times_grid = None\n    num_time_steps = None\n    normal_draws = None\n    seed = [1, 42]\n    if use_num_time_step:\n        num_time_steps = 100\n    else:\n        time_step = 0.01\n    if use_time_grid:\n        times_grid = tf.constant(np.linspace(0.0, 1.0, 101), dtype=dtype)\n    if supply_normal_draws:\n        num_samples = 1\n        normal_draws = tf.random.stateless_normal(shape=[5000, 100, 2], seed=seed, dtype=dtype)\n        normal_draws = tf.concat([normal_draws, -normal_draws], axis=0)\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    initial_state = np.array([initial_log_spot, initial_vol])\n    samples = heston.sample_paths(times=times, initial_state=initial_state, time_step=time_step, num_samples=num_samples, random_type=random_type, seed=seed, num_time_steps=num_time_steps, normal_draws=normal_draws, times_grid=times_grid)\n    self.assertEqual(samples.shape, [10000, 2, 2])\n    log_spots = samples[:, -1, 0]\n    monte_carlo_price = np.exp(-discounting * maturity_time) * tf.math.reduce_mean(tf.nn.relu(tf.math.exp(log_spots) * np.exp(discounting * maturity_time) - strike))\n    dtype = np.float64\n    variances = initial_vol\n    discount_rates = discounting\n    expiries = maturity_time\n    mean_reversion = mean_reversion_value\n    spots = np.exp(initial_log_spot)\n    forwards = None\n    european_option_price = self.evaluate(tff.models.heston.approximations.european_option_price(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, variances=variances, forwards=forwards, spots=spots, expiries=expiries, strikes=strike, discount_rates=discount_rates, dtype=dtype))\n    self.assertAllClose(monte_carlo_price, european_option_price, atol=0.1, rtol=0.1)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'SamplePathsWithNumTimeStep', 'use_num_time_step': True, 'use_time_grid': False, 'supply_normal_draws': False}, {'testcase_name': 'SamplePathsWithGrid', 'use_num_time_step': False, 'use_time_grid': True, 'supply_normal_draws': False}, {'testcase_name': 'SamplePathsWithGridAndDraws', 'use_num_time_step': False, 'use_time_grid': True, 'supply_normal_draws': True})\ndef test_compare_monte_carlo_to_european_option(self, use_num_time_step, use_time_grid, supply_normal_draws):\n    if False:\n        i = 10\n    dtype = tf.float64\n    mean_reversion_value = 0.3\n    theta = 0.05\n    volvol = 0.02\n    rho = 0.1\n    maturity_time = 1.0\n    initial_log_spot = 3.0\n    initial_vol = 0.05\n    strike = 15\n    discounting = 0.5\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.1, 0.2], values=[mean_reversion_value, mean_reversion_value, mean_reversion_value], dtype=dtype)\n    heston = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    times = [maturity_time / 2, maturity_time]\n    num_samples = 10000\n    time_step = None\n    times_grid = None\n    num_time_steps = None\n    normal_draws = None\n    seed = [1, 42]\n    if use_num_time_step:\n        num_time_steps = 100\n    else:\n        time_step = 0.01\n    if use_time_grid:\n        times_grid = tf.constant(np.linspace(0.0, 1.0, 101), dtype=dtype)\n    if supply_normal_draws:\n        num_samples = 1\n        normal_draws = tf.random.stateless_normal(shape=[5000, 100, 2], seed=seed, dtype=dtype)\n        normal_draws = tf.concat([normal_draws, -normal_draws], axis=0)\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    initial_state = np.array([initial_log_spot, initial_vol])\n    samples = heston.sample_paths(times=times, initial_state=initial_state, time_step=time_step, num_samples=num_samples, random_type=random_type, seed=seed, num_time_steps=num_time_steps, normal_draws=normal_draws, times_grid=times_grid)\n    self.assertEqual(samples.shape, [10000, 2, 2])\n    log_spots = samples[:, -1, 0]\n    monte_carlo_price = np.exp(-discounting * maturity_time) * tf.math.reduce_mean(tf.nn.relu(tf.math.exp(log_spots) * np.exp(discounting * maturity_time) - strike))\n    dtype = np.float64\n    variances = initial_vol\n    discount_rates = discounting\n    expiries = maturity_time\n    mean_reversion = mean_reversion_value\n    spots = np.exp(initial_log_spot)\n    forwards = None\n    european_option_price = self.evaluate(tff.models.heston.approximations.european_option_price(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, variances=variances, forwards=forwards, spots=spots, expiries=expiries, strikes=strike, discount_rates=discount_rates, dtype=dtype))\n    self.assertAllClose(monte_carlo_price, european_option_price, atol=0.1, rtol=0.1)",
            "@parameterized.named_parameters({'testcase_name': 'SamplePathsWithNumTimeStep', 'use_num_time_step': True, 'use_time_grid': False, 'supply_normal_draws': False}, {'testcase_name': 'SamplePathsWithGrid', 'use_num_time_step': False, 'use_time_grid': True, 'supply_normal_draws': False}, {'testcase_name': 'SamplePathsWithGridAndDraws', 'use_num_time_step': False, 'use_time_grid': True, 'supply_normal_draws': True})\ndef test_compare_monte_carlo_to_european_option(self, use_num_time_step, use_time_grid, supply_normal_draws):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dtype = tf.float64\n    mean_reversion_value = 0.3\n    theta = 0.05\n    volvol = 0.02\n    rho = 0.1\n    maturity_time = 1.0\n    initial_log_spot = 3.0\n    initial_vol = 0.05\n    strike = 15\n    discounting = 0.5\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.1, 0.2], values=[mean_reversion_value, mean_reversion_value, mean_reversion_value], dtype=dtype)\n    heston = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    times = [maturity_time / 2, maturity_time]\n    num_samples = 10000\n    time_step = None\n    times_grid = None\n    num_time_steps = None\n    normal_draws = None\n    seed = [1, 42]\n    if use_num_time_step:\n        num_time_steps = 100\n    else:\n        time_step = 0.01\n    if use_time_grid:\n        times_grid = tf.constant(np.linspace(0.0, 1.0, 101), dtype=dtype)\n    if supply_normal_draws:\n        num_samples = 1\n        normal_draws = tf.random.stateless_normal(shape=[5000, 100, 2], seed=seed, dtype=dtype)\n        normal_draws = tf.concat([normal_draws, -normal_draws], axis=0)\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    initial_state = np.array([initial_log_spot, initial_vol])\n    samples = heston.sample_paths(times=times, initial_state=initial_state, time_step=time_step, num_samples=num_samples, random_type=random_type, seed=seed, num_time_steps=num_time_steps, normal_draws=normal_draws, times_grid=times_grid)\n    self.assertEqual(samples.shape, [10000, 2, 2])\n    log_spots = samples[:, -1, 0]\n    monte_carlo_price = np.exp(-discounting * maturity_time) * tf.math.reduce_mean(tf.nn.relu(tf.math.exp(log_spots) * np.exp(discounting * maturity_time) - strike))\n    dtype = np.float64\n    variances = initial_vol\n    discount_rates = discounting\n    expiries = maturity_time\n    mean_reversion = mean_reversion_value\n    spots = np.exp(initial_log_spot)\n    forwards = None\n    european_option_price = self.evaluate(tff.models.heston.approximations.european_option_price(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, variances=variances, forwards=forwards, spots=spots, expiries=expiries, strikes=strike, discount_rates=discount_rates, dtype=dtype))\n    self.assertAllClose(monte_carlo_price, european_option_price, atol=0.1, rtol=0.1)",
            "@parameterized.named_parameters({'testcase_name': 'SamplePathsWithNumTimeStep', 'use_num_time_step': True, 'use_time_grid': False, 'supply_normal_draws': False}, {'testcase_name': 'SamplePathsWithGrid', 'use_num_time_step': False, 'use_time_grid': True, 'supply_normal_draws': False}, {'testcase_name': 'SamplePathsWithGridAndDraws', 'use_num_time_step': False, 'use_time_grid': True, 'supply_normal_draws': True})\ndef test_compare_monte_carlo_to_european_option(self, use_num_time_step, use_time_grid, supply_normal_draws):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dtype = tf.float64\n    mean_reversion_value = 0.3\n    theta = 0.05\n    volvol = 0.02\n    rho = 0.1\n    maturity_time = 1.0\n    initial_log_spot = 3.0\n    initial_vol = 0.05\n    strike = 15\n    discounting = 0.5\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.1, 0.2], values=[mean_reversion_value, mean_reversion_value, mean_reversion_value], dtype=dtype)\n    heston = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    times = [maturity_time / 2, maturity_time]\n    num_samples = 10000\n    time_step = None\n    times_grid = None\n    num_time_steps = None\n    normal_draws = None\n    seed = [1, 42]\n    if use_num_time_step:\n        num_time_steps = 100\n    else:\n        time_step = 0.01\n    if use_time_grid:\n        times_grid = tf.constant(np.linspace(0.0, 1.0, 101), dtype=dtype)\n    if supply_normal_draws:\n        num_samples = 1\n        normal_draws = tf.random.stateless_normal(shape=[5000, 100, 2], seed=seed, dtype=dtype)\n        normal_draws = tf.concat([normal_draws, -normal_draws], axis=0)\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    initial_state = np.array([initial_log_spot, initial_vol])\n    samples = heston.sample_paths(times=times, initial_state=initial_state, time_step=time_step, num_samples=num_samples, random_type=random_type, seed=seed, num_time_steps=num_time_steps, normal_draws=normal_draws, times_grid=times_grid)\n    self.assertEqual(samples.shape, [10000, 2, 2])\n    log_spots = samples[:, -1, 0]\n    monte_carlo_price = np.exp(-discounting * maturity_time) * tf.math.reduce_mean(tf.nn.relu(tf.math.exp(log_spots) * np.exp(discounting * maturity_time) - strike))\n    dtype = np.float64\n    variances = initial_vol\n    discount_rates = discounting\n    expiries = maturity_time\n    mean_reversion = mean_reversion_value\n    spots = np.exp(initial_log_spot)\n    forwards = None\n    european_option_price = self.evaluate(tff.models.heston.approximations.european_option_price(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, variances=variances, forwards=forwards, spots=spots, expiries=expiries, strikes=strike, discount_rates=discount_rates, dtype=dtype))\n    self.assertAllClose(monte_carlo_price, european_option_price, atol=0.1, rtol=0.1)",
            "@parameterized.named_parameters({'testcase_name': 'SamplePathsWithNumTimeStep', 'use_num_time_step': True, 'use_time_grid': False, 'supply_normal_draws': False}, {'testcase_name': 'SamplePathsWithGrid', 'use_num_time_step': False, 'use_time_grid': True, 'supply_normal_draws': False}, {'testcase_name': 'SamplePathsWithGridAndDraws', 'use_num_time_step': False, 'use_time_grid': True, 'supply_normal_draws': True})\ndef test_compare_monte_carlo_to_european_option(self, use_num_time_step, use_time_grid, supply_normal_draws):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dtype = tf.float64\n    mean_reversion_value = 0.3\n    theta = 0.05\n    volvol = 0.02\n    rho = 0.1\n    maturity_time = 1.0\n    initial_log_spot = 3.0\n    initial_vol = 0.05\n    strike = 15\n    discounting = 0.5\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.1, 0.2], values=[mean_reversion_value, mean_reversion_value, mean_reversion_value], dtype=dtype)\n    heston = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    times = [maturity_time / 2, maturity_time]\n    num_samples = 10000\n    time_step = None\n    times_grid = None\n    num_time_steps = None\n    normal_draws = None\n    seed = [1, 42]\n    if use_num_time_step:\n        num_time_steps = 100\n    else:\n        time_step = 0.01\n    if use_time_grid:\n        times_grid = tf.constant(np.linspace(0.0, 1.0, 101), dtype=dtype)\n    if supply_normal_draws:\n        num_samples = 1\n        normal_draws = tf.random.stateless_normal(shape=[5000, 100, 2], seed=seed, dtype=dtype)\n        normal_draws = tf.concat([normal_draws, -normal_draws], axis=0)\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    initial_state = np.array([initial_log_spot, initial_vol])\n    samples = heston.sample_paths(times=times, initial_state=initial_state, time_step=time_step, num_samples=num_samples, random_type=random_type, seed=seed, num_time_steps=num_time_steps, normal_draws=normal_draws, times_grid=times_grid)\n    self.assertEqual(samples.shape, [10000, 2, 2])\n    log_spots = samples[:, -1, 0]\n    monte_carlo_price = np.exp(-discounting * maturity_time) * tf.math.reduce_mean(tf.nn.relu(tf.math.exp(log_spots) * np.exp(discounting * maturity_time) - strike))\n    dtype = np.float64\n    variances = initial_vol\n    discount_rates = discounting\n    expiries = maturity_time\n    mean_reversion = mean_reversion_value\n    spots = np.exp(initial_log_spot)\n    forwards = None\n    european_option_price = self.evaluate(tff.models.heston.approximations.european_option_price(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, variances=variances, forwards=forwards, spots=spots, expiries=expiries, strikes=strike, discount_rates=discount_rates, dtype=dtype))\n    self.assertAllClose(monte_carlo_price, european_option_price, atol=0.1, rtol=0.1)",
            "@parameterized.named_parameters({'testcase_name': 'SamplePathsWithNumTimeStep', 'use_num_time_step': True, 'use_time_grid': False, 'supply_normal_draws': False}, {'testcase_name': 'SamplePathsWithGrid', 'use_num_time_step': False, 'use_time_grid': True, 'supply_normal_draws': False}, {'testcase_name': 'SamplePathsWithGridAndDraws', 'use_num_time_step': False, 'use_time_grid': True, 'supply_normal_draws': True})\ndef test_compare_monte_carlo_to_european_option(self, use_num_time_step, use_time_grid, supply_normal_draws):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dtype = tf.float64\n    mean_reversion_value = 0.3\n    theta = 0.05\n    volvol = 0.02\n    rho = 0.1\n    maturity_time = 1.0\n    initial_log_spot = 3.0\n    initial_vol = 0.05\n    strike = 15\n    discounting = 0.5\n    mean_reversion = tff.math.piecewise.PiecewiseConstantFunc(jump_locations=[0.1, 0.2], values=[mean_reversion_value, mean_reversion_value, mean_reversion_value], dtype=dtype)\n    heston = HestonModel(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, dtype=dtype)\n    times = [maturity_time / 2, maturity_time]\n    num_samples = 10000\n    time_step = None\n    times_grid = None\n    num_time_steps = None\n    normal_draws = None\n    seed = [1, 42]\n    if use_num_time_step:\n        num_time_steps = 100\n    else:\n        time_step = 0.01\n    if use_time_grid:\n        times_grid = tf.constant(np.linspace(0.0, 1.0, 101), dtype=dtype)\n    if supply_normal_draws:\n        num_samples = 1\n        normal_draws = tf.random.stateless_normal(shape=[5000, 100, 2], seed=seed, dtype=dtype)\n        normal_draws = tf.concat([normal_draws, -normal_draws], axis=0)\n    random_type = tff.math.random.RandomType.STATELESS_ANTITHETIC\n    initial_state = np.array([initial_log_spot, initial_vol])\n    samples = heston.sample_paths(times=times, initial_state=initial_state, time_step=time_step, num_samples=num_samples, random_type=random_type, seed=seed, num_time_steps=num_time_steps, normal_draws=normal_draws, times_grid=times_grid)\n    self.assertEqual(samples.shape, [10000, 2, 2])\n    log_spots = samples[:, -1, 0]\n    monte_carlo_price = np.exp(-discounting * maturity_time) * tf.math.reduce_mean(tf.nn.relu(tf.math.exp(log_spots) * np.exp(discounting * maturity_time) - strike))\n    dtype = np.float64\n    variances = initial_vol\n    discount_rates = discounting\n    expiries = maturity_time\n    mean_reversion = mean_reversion_value\n    spots = np.exp(initial_log_spot)\n    forwards = None\n    european_option_price = self.evaluate(tff.models.heston.approximations.european_option_price(mean_reversion=mean_reversion, theta=theta, volvol=volvol, rho=rho, variances=variances, forwards=forwards, spots=spots, expiries=expiries, strikes=strike, discount_rates=discount_rates, dtype=dtype))\n    self.assertAllClose(monte_carlo_price, european_option_price, atol=0.1, rtol=0.1)"
        ]
    }
]