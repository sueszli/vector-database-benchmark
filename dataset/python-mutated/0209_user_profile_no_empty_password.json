[
    {
        "func_name": "write_realm_audit_log_entry",
        "original": "def write_realm_audit_log_entry(user_profile: Any, event_time: Any, event_type: Any, affected_user_type: str) -> None:\n    RealmAuditLog.objects.create(realm=user_profile.realm, modified_user=user_profile, event_type=event_type, event_time=event_time, extra_data=orjson.dumps({'migration_id': MIGRATION_ID, 'affected_user_type': affected_user_type}).decode())",
        "mutated": [
            "def write_realm_audit_log_entry(user_profile: Any, event_time: Any, event_type: Any, affected_user_type: str) -> None:\n    if False:\n        i = 10\n    RealmAuditLog.objects.create(realm=user_profile.realm, modified_user=user_profile, event_type=event_type, event_time=event_time, extra_data=orjson.dumps({'migration_id': MIGRATION_ID, 'affected_user_type': affected_user_type}).decode())",
            "def write_realm_audit_log_entry(user_profile: Any, event_time: Any, event_type: Any, affected_user_type: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    RealmAuditLog.objects.create(realm=user_profile.realm, modified_user=user_profile, event_type=event_type, event_time=event_time, extra_data=orjson.dumps({'migration_id': MIGRATION_ID, 'affected_user_type': affected_user_type}).decode())",
            "def write_realm_audit_log_entry(user_profile: Any, event_time: Any, event_type: Any, affected_user_type: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    RealmAuditLog.objects.create(realm=user_profile.realm, modified_user=user_profile, event_type=event_type, event_time=event_time, extra_data=orjson.dumps({'migration_id': MIGRATION_ID, 'affected_user_type': affected_user_type}).decode())",
            "def write_realm_audit_log_entry(user_profile: Any, event_time: Any, event_type: Any, affected_user_type: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    RealmAuditLog.objects.create(realm=user_profile.realm, modified_user=user_profile, event_type=event_type, event_time=event_time, extra_data=orjson.dumps({'migration_id': MIGRATION_ID, 'affected_user_type': affected_user_type}).decode())",
            "def write_realm_audit_log_entry(user_profile: Any, event_time: Any, event_type: Any, affected_user_type: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    RealmAuditLog.objects.create(realm=user_profile.realm, modified_user=user_profile, event_type=event_type, event_time=event_time, extra_data=orjson.dumps({'migration_id': MIGRATION_ID, 'affected_user_type': affected_user_type}).decode())"
        ]
    },
    {
        "func_name": "ensure_no_empty_passwords",
        "original": "def ensure_no_empty_passwords(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:\n    \"\"\"With CVE-2019-18933, it was possible for certain users created\n    using social login (e.g. Google/GitHub auth) to have the empty\n    string as their password in the Zulip database, rather than\n    Django's \"unusable password\" (i.e. no password at all).  This was a\n    serious security issue for organizations with both password and\n    Google/GitHub authentication enabled.\n\n    Combined with the code changes to prevent new users from entering\n    this buggy state, this migration sets the intended \"no password\"\n    state for any users who are in this buggy state, as had been\n    intended.\n\n    While this bug was discovered by our own development team and we\n    believe it hasn't been exploited in the wild, out of an abundance\n    of caution, this migration also resets the personal API keys for\n    all users where Zulip's database-level logging cannot **prove**\n    that user's current personal API key was never accessed using this\n    bug.\n\n    There are a few ways this can be proven: (1) the user's password\n    has never been changed and is not the empty string,\n    or (2) the user's personal API key has changed since that user last\n    changed their password (which is not ''). Both constitute proof\n    because this bug cannot be used to gain the access required to change\n    or reset a user's password.\n\n    Resetting those API keys has the effect of logging many users out\n    of the Zulip mobile and terminal apps unnecessarily (e.g. because\n    the user changed their password at any point in the past, even\n    though the user never was affected by the bug), but we're\n    comfortable with that cost for ensuring that this bug is\n    completely fixed.\n\n    To avoid this inconvenience for self-hosted servers which don't\n    even have EmailAuthBackend enabled, we skip resetting any API keys\n    if the server doesn't have EmailAuthBackend configured.\n    \"\"\"\n    UserProfile = apps.get_model('zerver', 'UserProfile')\n    RealmAuditLog = apps.get_model('zerver', 'RealmAuditLog')\n    event_type_class = RealmAuditLog._meta.get_field('event_type').get_internal_type()\n    if event_type_class == 'CharField':\n        USER_PASSWORD_CHANGED: Union[int, str] = 'user_password_changed'\n        USER_API_KEY_CHANGED: Union[int, str] = 'user_api_key_changed'\n    else:\n        USER_PASSWORD_CHANGED = 122\n        USER_API_KEY_CHANGED = 127\n    password_change_user_ids = set(RealmAuditLog.objects.filter(event_type=USER_PASSWORD_CHANGED).values_list('modified_user_id', flat=True))\n    password_change_user_ids_api_key_reset_needed: Set[int] = set()\n    password_change_user_ids_no_reset_needed: Set[int] = set()\n    for user_id in password_change_user_ids:\n        query = RealmAuditLog.objects.filter(modified_user=user_id, event_type__in=[USER_PASSWORD_CHANGED, USER_API_KEY_CHANGED]).order_by('event_time')\n        earliest_password_change = query.filter(event_type=USER_PASSWORD_CHANGED).first()\n        assert earliest_password_change is not None\n        latest_api_key_change = query.filter(event_type=USER_API_KEY_CHANGED).last()\n        if latest_api_key_change is None:\n            password_change_user_ids_api_key_reset_needed.add(user_id)\n        elif earliest_password_change.event_time <= latest_api_key_change.event_time:\n            password_change_user_ids_no_reset_needed.add(user_id)\n        else:\n            password_change_user_ids_api_key_reset_needed.add(user_id)\n    if password_change_user_ids_no_reset_needed and settings.PRODUCTION:\n        with open('/var/log/zulip/0209_password_migration.log', 'w') as log_file:\n            line = 'No reset needed, but changed password: {}\\n'\n            log_file.write(line.format(password_change_user_ids_no_reset_needed))\n    AFFECTED_USER_TYPE_EMPTY_PASSWORD = 'empty_password'\n    AFFECTED_USER_TYPE_CHANGED_PASSWORD = 'changed_password'\n    MIGRATION_ID = '0209_user_profile_no_empty_password'\n\n    def write_realm_audit_log_entry(user_profile: Any, event_time: Any, event_type: Any, affected_user_type: str) -> None:\n        RealmAuditLog.objects.create(realm=user_profile.realm, modified_user=user_profile, event_type=event_type, event_time=event_time, extra_data=orjson.dumps({'migration_id': MIGRATION_ID, 'affected_user_type': affected_user_type}).decode())\n    email_auth_enabled = 'zproject.backends.EmailAuthBackend' in settings.AUTHENTICATION_BACKENDS\n    for user_profile in UserProfile.objects.all():\n        event_time = timezone_now()\n        if check_password('', user_profile.password):\n            user_profile.password = make_password(None)\n            update_fields = ['password']\n            write_realm_audit_log_entry(user_profile, event_time, USER_PASSWORD_CHANGED, AFFECTED_USER_TYPE_EMPTY_PASSWORD)\n            if email_auth_enabled and (not user_profile.is_bot):\n                reset_user_api_key(user_profile)\n                update_fields.append('api_key')\n                event_time = timezone_now()\n                write_realm_audit_log_entry(user_profile, event_time, USER_API_KEY_CHANGED, AFFECTED_USER_TYPE_EMPTY_PASSWORD)\n            user_profile.save(update_fields=update_fields)\n            continue\n        elif email_auth_enabled and user_profile.id in password_change_user_ids_api_key_reset_needed:\n            reset_user_api_key(user_profile)\n            user_profile.save(update_fields=['api_key'])\n            write_realm_audit_log_entry(user_profile, event_time, USER_API_KEY_CHANGED, AFFECTED_USER_TYPE_CHANGED_PASSWORD)",
        "mutated": [
            "def ensure_no_empty_passwords(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:\n    if False:\n        i = 10\n    'With CVE-2019-18933, it was possible for certain users created\\n    using social login (e.g. Google/GitHub auth) to have the empty\\n    string as their password in the Zulip database, rather than\\n    Django\\'s \"unusable password\" (i.e. no password at all).  This was a\\n    serious security issue for organizations with both password and\\n    Google/GitHub authentication enabled.\\n\\n    Combined with the code changes to prevent new users from entering\\n    this buggy state, this migration sets the intended \"no password\"\\n    state for any users who are in this buggy state, as had been\\n    intended.\\n\\n    While this bug was discovered by our own development team and we\\n    believe it hasn\\'t been exploited in the wild, out of an abundance\\n    of caution, this migration also resets the personal API keys for\\n    all users where Zulip\\'s database-level logging cannot **prove**\\n    that user\\'s current personal API key was never accessed using this\\n    bug.\\n\\n    There are a few ways this can be proven: (1) the user\\'s password\\n    has never been changed and is not the empty string,\\n    or (2) the user\\'s personal API key has changed since that user last\\n    changed their password (which is not \\'\\'). Both constitute proof\\n    because this bug cannot be used to gain the access required to change\\n    or reset a user\\'s password.\\n\\n    Resetting those API keys has the effect of logging many users out\\n    of the Zulip mobile and terminal apps unnecessarily (e.g. because\\n    the user changed their password at any point in the past, even\\n    though the user never was affected by the bug), but we\\'re\\n    comfortable with that cost for ensuring that this bug is\\n    completely fixed.\\n\\n    To avoid this inconvenience for self-hosted servers which don\\'t\\n    even have EmailAuthBackend enabled, we skip resetting any API keys\\n    if the server doesn\\'t have EmailAuthBackend configured.\\n    '\n    UserProfile = apps.get_model('zerver', 'UserProfile')\n    RealmAuditLog = apps.get_model('zerver', 'RealmAuditLog')\n    event_type_class = RealmAuditLog._meta.get_field('event_type').get_internal_type()\n    if event_type_class == 'CharField':\n        USER_PASSWORD_CHANGED: Union[int, str] = 'user_password_changed'\n        USER_API_KEY_CHANGED: Union[int, str] = 'user_api_key_changed'\n    else:\n        USER_PASSWORD_CHANGED = 122\n        USER_API_KEY_CHANGED = 127\n    password_change_user_ids = set(RealmAuditLog.objects.filter(event_type=USER_PASSWORD_CHANGED).values_list('modified_user_id', flat=True))\n    password_change_user_ids_api_key_reset_needed: Set[int] = set()\n    password_change_user_ids_no_reset_needed: Set[int] = set()\n    for user_id in password_change_user_ids:\n        query = RealmAuditLog.objects.filter(modified_user=user_id, event_type__in=[USER_PASSWORD_CHANGED, USER_API_KEY_CHANGED]).order_by('event_time')\n        earliest_password_change = query.filter(event_type=USER_PASSWORD_CHANGED).first()\n        assert earliest_password_change is not None\n        latest_api_key_change = query.filter(event_type=USER_API_KEY_CHANGED).last()\n        if latest_api_key_change is None:\n            password_change_user_ids_api_key_reset_needed.add(user_id)\n        elif earliest_password_change.event_time <= latest_api_key_change.event_time:\n            password_change_user_ids_no_reset_needed.add(user_id)\n        else:\n            password_change_user_ids_api_key_reset_needed.add(user_id)\n    if password_change_user_ids_no_reset_needed and settings.PRODUCTION:\n        with open('/var/log/zulip/0209_password_migration.log', 'w') as log_file:\n            line = 'No reset needed, but changed password: {}\\n'\n            log_file.write(line.format(password_change_user_ids_no_reset_needed))\n    AFFECTED_USER_TYPE_EMPTY_PASSWORD = 'empty_password'\n    AFFECTED_USER_TYPE_CHANGED_PASSWORD = 'changed_password'\n    MIGRATION_ID = '0209_user_profile_no_empty_password'\n\n    def write_realm_audit_log_entry(user_profile: Any, event_time: Any, event_type: Any, affected_user_type: str) -> None:\n        RealmAuditLog.objects.create(realm=user_profile.realm, modified_user=user_profile, event_type=event_type, event_time=event_time, extra_data=orjson.dumps({'migration_id': MIGRATION_ID, 'affected_user_type': affected_user_type}).decode())\n    email_auth_enabled = 'zproject.backends.EmailAuthBackend' in settings.AUTHENTICATION_BACKENDS\n    for user_profile in UserProfile.objects.all():\n        event_time = timezone_now()\n        if check_password('', user_profile.password):\n            user_profile.password = make_password(None)\n            update_fields = ['password']\n            write_realm_audit_log_entry(user_profile, event_time, USER_PASSWORD_CHANGED, AFFECTED_USER_TYPE_EMPTY_PASSWORD)\n            if email_auth_enabled and (not user_profile.is_bot):\n                reset_user_api_key(user_profile)\n                update_fields.append('api_key')\n                event_time = timezone_now()\n                write_realm_audit_log_entry(user_profile, event_time, USER_API_KEY_CHANGED, AFFECTED_USER_TYPE_EMPTY_PASSWORD)\n            user_profile.save(update_fields=update_fields)\n            continue\n        elif email_auth_enabled and user_profile.id in password_change_user_ids_api_key_reset_needed:\n            reset_user_api_key(user_profile)\n            user_profile.save(update_fields=['api_key'])\n            write_realm_audit_log_entry(user_profile, event_time, USER_API_KEY_CHANGED, AFFECTED_USER_TYPE_CHANGED_PASSWORD)",
            "def ensure_no_empty_passwords(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'With CVE-2019-18933, it was possible for certain users created\\n    using social login (e.g. Google/GitHub auth) to have the empty\\n    string as their password in the Zulip database, rather than\\n    Django\\'s \"unusable password\" (i.e. no password at all).  This was a\\n    serious security issue for organizations with both password and\\n    Google/GitHub authentication enabled.\\n\\n    Combined with the code changes to prevent new users from entering\\n    this buggy state, this migration sets the intended \"no password\"\\n    state for any users who are in this buggy state, as had been\\n    intended.\\n\\n    While this bug was discovered by our own development team and we\\n    believe it hasn\\'t been exploited in the wild, out of an abundance\\n    of caution, this migration also resets the personal API keys for\\n    all users where Zulip\\'s database-level logging cannot **prove**\\n    that user\\'s current personal API key was never accessed using this\\n    bug.\\n\\n    There are a few ways this can be proven: (1) the user\\'s password\\n    has never been changed and is not the empty string,\\n    or (2) the user\\'s personal API key has changed since that user last\\n    changed their password (which is not \\'\\'). Both constitute proof\\n    because this bug cannot be used to gain the access required to change\\n    or reset a user\\'s password.\\n\\n    Resetting those API keys has the effect of logging many users out\\n    of the Zulip mobile and terminal apps unnecessarily (e.g. because\\n    the user changed their password at any point in the past, even\\n    though the user never was affected by the bug), but we\\'re\\n    comfortable with that cost for ensuring that this bug is\\n    completely fixed.\\n\\n    To avoid this inconvenience for self-hosted servers which don\\'t\\n    even have EmailAuthBackend enabled, we skip resetting any API keys\\n    if the server doesn\\'t have EmailAuthBackend configured.\\n    '\n    UserProfile = apps.get_model('zerver', 'UserProfile')\n    RealmAuditLog = apps.get_model('zerver', 'RealmAuditLog')\n    event_type_class = RealmAuditLog._meta.get_field('event_type').get_internal_type()\n    if event_type_class == 'CharField':\n        USER_PASSWORD_CHANGED: Union[int, str] = 'user_password_changed'\n        USER_API_KEY_CHANGED: Union[int, str] = 'user_api_key_changed'\n    else:\n        USER_PASSWORD_CHANGED = 122\n        USER_API_KEY_CHANGED = 127\n    password_change_user_ids = set(RealmAuditLog.objects.filter(event_type=USER_PASSWORD_CHANGED).values_list('modified_user_id', flat=True))\n    password_change_user_ids_api_key_reset_needed: Set[int] = set()\n    password_change_user_ids_no_reset_needed: Set[int] = set()\n    for user_id in password_change_user_ids:\n        query = RealmAuditLog.objects.filter(modified_user=user_id, event_type__in=[USER_PASSWORD_CHANGED, USER_API_KEY_CHANGED]).order_by('event_time')\n        earliest_password_change = query.filter(event_type=USER_PASSWORD_CHANGED).first()\n        assert earliest_password_change is not None\n        latest_api_key_change = query.filter(event_type=USER_API_KEY_CHANGED).last()\n        if latest_api_key_change is None:\n            password_change_user_ids_api_key_reset_needed.add(user_id)\n        elif earliest_password_change.event_time <= latest_api_key_change.event_time:\n            password_change_user_ids_no_reset_needed.add(user_id)\n        else:\n            password_change_user_ids_api_key_reset_needed.add(user_id)\n    if password_change_user_ids_no_reset_needed and settings.PRODUCTION:\n        with open('/var/log/zulip/0209_password_migration.log', 'w') as log_file:\n            line = 'No reset needed, but changed password: {}\\n'\n            log_file.write(line.format(password_change_user_ids_no_reset_needed))\n    AFFECTED_USER_TYPE_EMPTY_PASSWORD = 'empty_password'\n    AFFECTED_USER_TYPE_CHANGED_PASSWORD = 'changed_password'\n    MIGRATION_ID = '0209_user_profile_no_empty_password'\n\n    def write_realm_audit_log_entry(user_profile: Any, event_time: Any, event_type: Any, affected_user_type: str) -> None:\n        RealmAuditLog.objects.create(realm=user_profile.realm, modified_user=user_profile, event_type=event_type, event_time=event_time, extra_data=orjson.dumps({'migration_id': MIGRATION_ID, 'affected_user_type': affected_user_type}).decode())\n    email_auth_enabled = 'zproject.backends.EmailAuthBackend' in settings.AUTHENTICATION_BACKENDS\n    for user_profile in UserProfile.objects.all():\n        event_time = timezone_now()\n        if check_password('', user_profile.password):\n            user_profile.password = make_password(None)\n            update_fields = ['password']\n            write_realm_audit_log_entry(user_profile, event_time, USER_PASSWORD_CHANGED, AFFECTED_USER_TYPE_EMPTY_PASSWORD)\n            if email_auth_enabled and (not user_profile.is_bot):\n                reset_user_api_key(user_profile)\n                update_fields.append('api_key')\n                event_time = timezone_now()\n                write_realm_audit_log_entry(user_profile, event_time, USER_API_KEY_CHANGED, AFFECTED_USER_TYPE_EMPTY_PASSWORD)\n            user_profile.save(update_fields=update_fields)\n            continue\n        elif email_auth_enabled and user_profile.id in password_change_user_ids_api_key_reset_needed:\n            reset_user_api_key(user_profile)\n            user_profile.save(update_fields=['api_key'])\n            write_realm_audit_log_entry(user_profile, event_time, USER_API_KEY_CHANGED, AFFECTED_USER_TYPE_CHANGED_PASSWORD)",
            "def ensure_no_empty_passwords(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'With CVE-2019-18933, it was possible for certain users created\\n    using social login (e.g. Google/GitHub auth) to have the empty\\n    string as their password in the Zulip database, rather than\\n    Django\\'s \"unusable password\" (i.e. no password at all).  This was a\\n    serious security issue for organizations with both password and\\n    Google/GitHub authentication enabled.\\n\\n    Combined with the code changes to prevent new users from entering\\n    this buggy state, this migration sets the intended \"no password\"\\n    state for any users who are in this buggy state, as had been\\n    intended.\\n\\n    While this bug was discovered by our own development team and we\\n    believe it hasn\\'t been exploited in the wild, out of an abundance\\n    of caution, this migration also resets the personal API keys for\\n    all users where Zulip\\'s database-level logging cannot **prove**\\n    that user\\'s current personal API key was never accessed using this\\n    bug.\\n\\n    There are a few ways this can be proven: (1) the user\\'s password\\n    has never been changed and is not the empty string,\\n    or (2) the user\\'s personal API key has changed since that user last\\n    changed their password (which is not \\'\\'). Both constitute proof\\n    because this bug cannot be used to gain the access required to change\\n    or reset a user\\'s password.\\n\\n    Resetting those API keys has the effect of logging many users out\\n    of the Zulip mobile and terminal apps unnecessarily (e.g. because\\n    the user changed their password at any point in the past, even\\n    though the user never was affected by the bug), but we\\'re\\n    comfortable with that cost for ensuring that this bug is\\n    completely fixed.\\n\\n    To avoid this inconvenience for self-hosted servers which don\\'t\\n    even have EmailAuthBackend enabled, we skip resetting any API keys\\n    if the server doesn\\'t have EmailAuthBackend configured.\\n    '\n    UserProfile = apps.get_model('zerver', 'UserProfile')\n    RealmAuditLog = apps.get_model('zerver', 'RealmAuditLog')\n    event_type_class = RealmAuditLog._meta.get_field('event_type').get_internal_type()\n    if event_type_class == 'CharField':\n        USER_PASSWORD_CHANGED: Union[int, str] = 'user_password_changed'\n        USER_API_KEY_CHANGED: Union[int, str] = 'user_api_key_changed'\n    else:\n        USER_PASSWORD_CHANGED = 122\n        USER_API_KEY_CHANGED = 127\n    password_change_user_ids = set(RealmAuditLog.objects.filter(event_type=USER_PASSWORD_CHANGED).values_list('modified_user_id', flat=True))\n    password_change_user_ids_api_key_reset_needed: Set[int] = set()\n    password_change_user_ids_no_reset_needed: Set[int] = set()\n    for user_id in password_change_user_ids:\n        query = RealmAuditLog.objects.filter(modified_user=user_id, event_type__in=[USER_PASSWORD_CHANGED, USER_API_KEY_CHANGED]).order_by('event_time')\n        earliest_password_change = query.filter(event_type=USER_PASSWORD_CHANGED).first()\n        assert earliest_password_change is not None\n        latest_api_key_change = query.filter(event_type=USER_API_KEY_CHANGED).last()\n        if latest_api_key_change is None:\n            password_change_user_ids_api_key_reset_needed.add(user_id)\n        elif earliest_password_change.event_time <= latest_api_key_change.event_time:\n            password_change_user_ids_no_reset_needed.add(user_id)\n        else:\n            password_change_user_ids_api_key_reset_needed.add(user_id)\n    if password_change_user_ids_no_reset_needed and settings.PRODUCTION:\n        with open('/var/log/zulip/0209_password_migration.log', 'w') as log_file:\n            line = 'No reset needed, but changed password: {}\\n'\n            log_file.write(line.format(password_change_user_ids_no_reset_needed))\n    AFFECTED_USER_TYPE_EMPTY_PASSWORD = 'empty_password'\n    AFFECTED_USER_TYPE_CHANGED_PASSWORD = 'changed_password'\n    MIGRATION_ID = '0209_user_profile_no_empty_password'\n\n    def write_realm_audit_log_entry(user_profile: Any, event_time: Any, event_type: Any, affected_user_type: str) -> None:\n        RealmAuditLog.objects.create(realm=user_profile.realm, modified_user=user_profile, event_type=event_type, event_time=event_time, extra_data=orjson.dumps({'migration_id': MIGRATION_ID, 'affected_user_type': affected_user_type}).decode())\n    email_auth_enabled = 'zproject.backends.EmailAuthBackend' in settings.AUTHENTICATION_BACKENDS\n    for user_profile in UserProfile.objects.all():\n        event_time = timezone_now()\n        if check_password('', user_profile.password):\n            user_profile.password = make_password(None)\n            update_fields = ['password']\n            write_realm_audit_log_entry(user_profile, event_time, USER_PASSWORD_CHANGED, AFFECTED_USER_TYPE_EMPTY_PASSWORD)\n            if email_auth_enabled and (not user_profile.is_bot):\n                reset_user_api_key(user_profile)\n                update_fields.append('api_key')\n                event_time = timezone_now()\n                write_realm_audit_log_entry(user_profile, event_time, USER_API_KEY_CHANGED, AFFECTED_USER_TYPE_EMPTY_PASSWORD)\n            user_profile.save(update_fields=update_fields)\n            continue\n        elif email_auth_enabled and user_profile.id in password_change_user_ids_api_key_reset_needed:\n            reset_user_api_key(user_profile)\n            user_profile.save(update_fields=['api_key'])\n            write_realm_audit_log_entry(user_profile, event_time, USER_API_KEY_CHANGED, AFFECTED_USER_TYPE_CHANGED_PASSWORD)",
            "def ensure_no_empty_passwords(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'With CVE-2019-18933, it was possible for certain users created\\n    using social login (e.g. Google/GitHub auth) to have the empty\\n    string as their password in the Zulip database, rather than\\n    Django\\'s \"unusable password\" (i.e. no password at all).  This was a\\n    serious security issue for organizations with both password and\\n    Google/GitHub authentication enabled.\\n\\n    Combined with the code changes to prevent new users from entering\\n    this buggy state, this migration sets the intended \"no password\"\\n    state for any users who are in this buggy state, as had been\\n    intended.\\n\\n    While this bug was discovered by our own development team and we\\n    believe it hasn\\'t been exploited in the wild, out of an abundance\\n    of caution, this migration also resets the personal API keys for\\n    all users where Zulip\\'s database-level logging cannot **prove**\\n    that user\\'s current personal API key was never accessed using this\\n    bug.\\n\\n    There are a few ways this can be proven: (1) the user\\'s password\\n    has never been changed and is not the empty string,\\n    or (2) the user\\'s personal API key has changed since that user last\\n    changed their password (which is not \\'\\'). Both constitute proof\\n    because this bug cannot be used to gain the access required to change\\n    or reset a user\\'s password.\\n\\n    Resetting those API keys has the effect of logging many users out\\n    of the Zulip mobile and terminal apps unnecessarily (e.g. because\\n    the user changed their password at any point in the past, even\\n    though the user never was affected by the bug), but we\\'re\\n    comfortable with that cost for ensuring that this bug is\\n    completely fixed.\\n\\n    To avoid this inconvenience for self-hosted servers which don\\'t\\n    even have EmailAuthBackend enabled, we skip resetting any API keys\\n    if the server doesn\\'t have EmailAuthBackend configured.\\n    '\n    UserProfile = apps.get_model('zerver', 'UserProfile')\n    RealmAuditLog = apps.get_model('zerver', 'RealmAuditLog')\n    event_type_class = RealmAuditLog._meta.get_field('event_type').get_internal_type()\n    if event_type_class == 'CharField':\n        USER_PASSWORD_CHANGED: Union[int, str] = 'user_password_changed'\n        USER_API_KEY_CHANGED: Union[int, str] = 'user_api_key_changed'\n    else:\n        USER_PASSWORD_CHANGED = 122\n        USER_API_KEY_CHANGED = 127\n    password_change_user_ids = set(RealmAuditLog.objects.filter(event_type=USER_PASSWORD_CHANGED).values_list('modified_user_id', flat=True))\n    password_change_user_ids_api_key_reset_needed: Set[int] = set()\n    password_change_user_ids_no_reset_needed: Set[int] = set()\n    for user_id in password_change_user_ids:\n        query = RealmAuditLog.objects.filter(modified_user=user_id, event_type__in=[USER_PASSWORD_CHANGED, USER_API_KEY_CHANGED]).order_by('event_time')\n        earliest_password_change = query.filter(event_type=USER_PASSWORD_CHANGED).first()\n        assert earliest_password_change is not None\n        latest_api_key_change = query.filter(event_type=USER_API_KEY_CHANGED).last()\n        if latest_api_key_change is None:\n            password_change_user_ids_api_key_reset_needed.add(user_id)\n        elif earliest_password_change.event_time <= latest_api_key_change.event_time:\n            password_change_user_ids_no_reset_needed.add(user_id)\n        else:\n            password_change_user_ids_api_key_reset_needed.add(user_id)\n    if password_change_user_ids_no_reset_needed and settings.PRODUCTION:\n        with open('/var/log/zulip/0209_password_migration.log', 'w') as log_file:\n            line = 'No reset needed, but changed password: {}\\n'\n            log_file.write(line.format(password_change_user_ids_no_reset_needed))\n    AFFECTED_USER_TYPE_EMPTY_PASSWORD = 'empty_password'\n    AFFECTED_USER_TYPE_CHANGED_PASSWORD = 'changed_password'\n    MIGRATION_ID = '0209_user_profile_no_empty_password'\n\n    def write_realm_audit_log_entry(user_profile: Any, event_time: Any, event_type: Any, affected_user_type: str) -> None:\n        RealmAuditLog.objects.create(realm=user_profile.realm, modified_user=user_profile, event_type=event_type, event_time=event_time, extra_data=orjson.dumps({'migration_id': MIGRATION_ID, 'affected_user_type': affected_user_type}).decode())\n    email_auth_enabled = 'zproject.backends.EmailAuthBackend' in settings.AUTHENTICATION_BACKENDS\n    for user_profile in UserProfile.objects.all():\n        event_time = timezone_now()\n        if check_password('', user_profile.password):\n            user_profile.password = make_password(None)\n            update_fields = ['password']\n            write_realm_audit_log_entry(user_profile, event_time, USER_PASSWORD_CHANGED, AFFECTED_USER_TYPE_EMPTY_PASSWORD)\n            if email_auth_enabled and (not user_profile.is_bot):\n                reset_user_api_key(user_profile)\n                update_fields.append('api_key')\n                event_time = timezone_now()\n                write_realm_audit_log_entry(user_profile, event_time, USER_API_KEY_CHANGED, AFFECTED_USER_TYPE_EMPTY_PASSWORD)\n            user_profile.save(update_fields=update_fields)\n            continue\n        elif email_auth_enabled and user_profile.id in password_change_user_ids_api_key_reset_needed:\n            reset_user_api_key(user_profile)\n            user_profile.save(update_fields=['api_key'])\n            write_realm_audit_log_entry(user_profile, event_time, USER_API_KEY_CHANGED, AFFECTED_USER_TYPE_CHANGED_PASSWORD)",
            "def ensure_no_empty_passwords(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'With CVE-2019-18933, it was possible for certain users created\\n    using social login (e.g. Google/GitHub auth) to have the empty\\n    string as their password in the Zulip database, rather than\\n    Django\\'s \"unusable password\" (i.e. no password at all).  This was a\\n    serious security issue for organizations with both password and\\n    Google/GitHub authentication enabled.\\n\\n    Combined with the code changes to prevent new users from entering\\n    this buggy state, this migration sets the intended \"no password\"\\n    state for any users who are in this buggy state, as had been\\n    intended.\\n\\n    While this bug was discovered by our own development team and we\\n    believe it hasn\\'t been exploited in the wild, out of an abundance\\n    of caution, this migration also resets the personal API keys for\\n    all users where Zulip\\'s database-level logging cannot **prove**\\n    that user\\'s current personal API key was never accessed using this\\n    bug.\\n\\n    There are a few ways this can be proven: (1) the user\\'s password\\n    has never been changed and is not the empty string,\\n    or (2) the user\\'s personal API key has changed since that user last\\n    changed their password (which is not \\'\\'). Both constitute proof\\n    because this bug cannot be used to gain the access required to change\\n    or reset a user\\'s password.\\n\\n    Resetting those API keys has the effect of logging many users out\\n    of the Zulip mobile and terminal apps unnecessarily (e.g. because\\n    the user changed their password at any point in the past, even\\n    though the user never was affected by the bug), but we\\'re\\n    comfortable with that cost for ensuring that this bug is\\n    completely fixed.\\n\\n    To avoid this inconvenience for self-hosted servers which don\\'t\\n    even have EmailAuthBackend enabled, we skip resetting any API keys\\n    if the server doesn\\'t have EmailAuthBackend configured.\\n    '\n    UserProfile = apps.get_model('zerver', 'UserProfile')\n    RealmAuditLog = apps.get_model('zerver', 'RealmAuditLog')\n    event_type_class = RealmAuditLog._meta.get_field('event_type').get_internal_type()\n    if event_type_class == 'CharField':\n        USER_PASSWORD_CHANGED: Union[int, str] = 'user_password_changed'\n        USER_API_KEY_CHANGED: Union[int, str] = 'user_api_key_changed'\n    else:\n        USER_PASSWORD_CHANGED = 122\n        USER_API_KEY_CHANGED = 127\n    password_change_user_ids = set(RealmAuditLog.objects.filter(event_type=USER_PASSWORD_CHANGED).values_list('modified_user_id', flat=True))\n    password_change_user_ids_api_key_reset_needed: Set[int] = set()\n    password_change_user_ids_no_reset_needed: Set[int] = set()\n    for user_id in password_change_user_ids:\n        query = RealmAuditLog.objects.filter(modified_user=user_id, event_type__in=[USER_PASSWORD_CHANGED, USER_API_KEY_CHANGED]).order_by('event_time')\n        earliest_password_change = query.filter(event_type=USER_PASSWORD_CHANGED).first()\n        assert earliest_password_change is not None\n        latest_api_key_change = query.filter(event_type=USER_API_KEY_CHANGED).last()\n        if latest_api_key_change is None:\n            password_change_user_ids_api_key_reset_needed.add(user_id)\n        elif earliest_password_change.event_time <= latest_api_key_change.event_time:\n            password_change_user_ids_no_reset_needed.add(user_id)\n        else:\n            password_change_user_ids_api_key_reset_needed.add(user_id)\n    if password_change_user_ids_no_reset_needed and settings.PRODUCTION:\n        with open('/var/log/zulip/0209_password_migration.log', 'w') as log_file:\n            line = 'No reset needed, but changed password: {}\\n'\n            log_file.write(line.format(password_change_user_ids_no_reset_needed))\n    AFFECTED_USER_TYPE_EMPTY_PASSWORD = 'empty_password'\n    AFFECTED_USER_TYPE_CHANGED_PASSWORD = 'changed_password'\n    MIGRATION_ID = '0209_user_profile_no_empty_password'\n\n    def write_realm_audit_log_entry(user_profile: Any, event_time: Any, event_type: Any, affected_user_type: str) -> None:\n        RealmAuditLog.objects.create(realm=user_profile.realm, modified_user=user_profile, event_type=event_type, event_time=event_time, extra_data=orjson.dumps({'migration_id': MIGRATION_ID, 'affected_user_type': affected_user_type}).decode())\n    email_auth_enabled = 'zproject.backends.EmailAuthBackend' in settings.AUTHENTICATION_BACKENDS\n    for user_profile in UserProfile.objects.all():\n        event_time = timezone_now()\n        if check_password('', user_profile.password):\n            user_profile.password = make_password(None)\n            update_fields = ['password']\n            write_realm_audit_log_entry(user_profile, event_time, USER_PASSWORD_CHANGED, AFFECTED_USER_TYPE_EMPTY_PASSWORD)\n            if email_auth_enabled and (not user_profile.is_bot):\n                reset_user_api_key(user_profile)\n                update_fields.append('api_key')\n                event_time = timezone_now()\n                write_realm_audit_log_entry(user_profile, event_time, USER_API_KEY_CHANGED, AFFECTED_USER_TYPE_EMPTY_PASSWORD)\n            user_profile.save(update_fields=update_fields)\n            continue\n        elif email_auth_enabled and user_profile.id in password_change_user_ids_api_key_reset_needed:\n            reset_user_api_key(user_profile)\n            user_profile.save(update_fields=['api_key'])\n            write_realm_audit_log_entry(user_profile, event_time, USER_API_KEY_CHANGED, AFFECTED_USER_TYPE_CHANGED_PASSWORD)"
        ]
    },
    {
        "func_name": "reset_user_api_key",
        "original": "def reset_user_api_key(user_profile: Any) -> None:\n    old_api_key = user_profile.api_key\n    user_profile.api_key = generate_api_key()\n    cache_delete(user_profile_by_api_key_cache_key(old_api_key))\n    event = {'type': 'clear_push_device_tokens', 'user_profile_id': user_profile.id}\n    queue_json_publish('deferred_work', event)",
        "mutated": [
            "def reset_user_api_key(user_profile: Any) -> None:\n    if False:\n        i = 10\n    old_api_key = user_profile.api_key\n    user_profile.api_key = generate_api_key()\n    cache_delete(user_profile_by_api_key_cache_key(old_api_key))\n    event = {'type': 'clear_push_device_tokens', 'user_profile_id': user_profile.id}\n    queue_json_publish('deferred_work', event)",
            "def reset_user_api_key(user_profile: Any) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    old_api_key = user_profile.api_key\n    user_profile.api_key = generate_api_key()\n    cache_delete(user_profile_by_api_key_cache_key(old_api_key))\n    event = {'type': 'clear_push_device_tokens', 'user_profile_id': user_profile.id}\n    queue_json_publish('deferred_work', event)",
            "def reset_user_api_key(user_profile: Any) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    old_api_key = user_profile.api_key\n    user_profile.api_key = generate_api_key()\n    cache_delete(user_profile_by_api_key_cache_key(old_api_key))\n    event = {'type': 'clear_push_device_tokens', 'user_profile_id': user_profile.id}\n    queue_json_publish('deferred_work', event)",
            "def reset_user_api_key(user_profile: Any) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    old_api_key = user_profile.api_key\n    user_profile.api_key = generate_api_key()\n    cache_delete(user_profile_by_api_key_cache_key(old_api_key))\n    event = {'type': 'clear_push_device_tokens', 'user_profile_id': user_profile.id}\n    queue_json_publish('deferred_work', event)",
            "def reset_user_api_key(user_profile: Any) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    old_api_key = user_profile.api_key\n    user_profile.api_key = generate_api_key()\n    cache_delete(user_profile_by_api_key_cache_key(old_api_key))\n    event = {'type': 'clear_push_device_tokens', 'user_profile_id': user_profile.id}\n    queue_json_publish('deferred_work', event)"
        ]
    }
]