[
    {
        "func_name": "apart",
        "original": "@xthreaded\n@public\ndef apart(f, x=None, full=False, **options):\n    \"\"\"\n    Compute partial fraction decomposition of a rational function.\n\n    Given a rational function ``f``, computes the partial fraction\n    decomposition of ``f``. Two algorithms are available: One is based on the\n    undertermined coefficients method, the other is Bronstein's full partial\n    fraction decomposition algorithm.\n\n    The undetermined coefficients method (selected by ``full=False``) uses\n    polynomial factorization (and therefore accepts the same options as\n    factor) for the denominator. Per default it works over the rational\n    numbers, therefore decomposition of denominators with non-rational roots\n    (e.g. irrational, complex roots) is not supported by default (see options\n    of factor).\n\n    Bronstein's algorithm can be selected by using ``full=True`` and allows a\n    decomposition of denominators with non-rational roots. A human-readable\n    result can be obtained via ``doit()`` (see examples below).\n\n    Examples\n    ========\n\n    >>> from sympy.polys.partfrac import apart\n    >>> from sympy.abc import x, y\n\n    By default, using the undetermined coefficients method:\n\n    >>> apart(y/(x + 2)/(x + 1), x)\n    -y/(x + 2) + y/(x + 1)\n\n    The undetermined coefficients method does not provide a result when the\n    denominators roots are not rational:\n\n    >>> apart(y/(x**2 + x + 1), x)\n    y/(x**2 + x + 1)\n\n    You can choose Bronstein's algorithm by setting ``full=True``:\n\n    >>> apart(y/(x**2 + x + 1), x, full=True)\n    RootSum(_w**2 + _w + 1, Lambda(_a, (-2*_a*y/3 - y/3)/(-_a + x)))\n\n    Calling ``doit()`` yields a human-readable result:\n\n    >>> apart(y/(x**2 + x + 1), x, full=True).doit()\n    (-y/3 - 2*y*(-1/2 - sqrt(3)*I/2)/3)/(x + 1/2 + sqrt(3)*I/2) + (-y/3 -\n        2*y*(-1/2 + sqrt(3)*I/2)/3)/(x + 1/2 - sqrt(3)*I/2)\n\n\n    See Also\n    ========\n\n    apart_list, assemble_partfrac_list\n    \"\"\"\n    allowed_flags(options, [])\n    f = sympify(f)\n    if f.is_Atom:\n        return f\n    else:\n        (P, Q) = f.as_numer_denom()\n    _options = options.copy()\n    options = set_defaults(options, extension=True)\n    try:\n        ((P, Q), opt) = parallel_poly_from_expr((P, Q), x, **options)\n    except PolynomialError as msg:\n        if f.is_commutative:\n            raise PolynomialError(msg)\n        if f.is_Mul:\n            (c, nc) = f.args_cnc(split_1=False)\n            nc = f.func(*nc)\n            if c:\n                c = apart(f.func._from_args(c), x=x, full=full, **_options)\n                return c * nc\n            else:\n                return nc\n        elif f.is_Add:\n            c = []\n            nc = []\n            for i in f.args:\n                if i.is_commutative:\n                    c.append(i)\n                else:\n                    try:\n                        nc.append(apart(i, x=x, full=full, **_options))\n                    except NotImplementedError:\n                        nc.append(i)\n            return apart(f.func(*c), x=x, full=full, **_options) + f.func(*nc)\n        else:\n            reps = []\n            pot = preorder_traversal(f)\n            next(pot)\n            for e in pot:\n                try:\n                    reps.append((e, apart(e, x=x, full=full, **_options)))\n                    pot.skip()\n                except NotImplementedError:\n                    pass\n            return f.xreplace(dict(reps))\n    if P.is_multivariate:\n        fc = f.cancel()\n        if fc != f:\n            return apart(fc, x=x, full=full, **_options)\n        raise NotImplementedError('multivariate partial fraction decomposition')\n    (common, P, Q) = P.cancel(Q)\n    (poly, P) = P.div(Q, auto=True)\n    (P, Q) = P.rat_clear_denoms(Q)\n    if Q.degree() <= 1:\n        partial = P / Q\n    elif not full:\n        partial = apart_undetermined_coeffs(P, Q)\n    else:\n        partial = apart_full_decomposition(P, Q)\n    terms = S.Zero\n    for term in Add.make_args(partial):\n        if term.has(RootSum):\n            terms += term\n        else:\n            terms += factor(term)\n    return common * (poly.as_expr() + terms)",
        "mutated": [
            "@xthreaded\n@public\ndef apart(f, x=None, full=False, **options):\n    if False:\n        i = 10\n    \"\\n    Compute partial fraction decomposition of a rational function.\\n\\n    Given a rational function ``f``, computes the partial fraction\\n    decomposition of ``f``. Two algorithms are available: One is based on the\\n    undertermined coefficients method, the other is Bronstein's full partial\\n    fraction decomposition algorithm.\\n\\n    The undetermined coefficients method (selected by ``full=False``) uses\\n    polynomial factorization (and therefore accepts the same options as\\n    factor) for the denominator. Per default it works over the rational\\n    numbers, therefore decomposition of denominators with non-rational roots\\n    (e.g. irrational, complex roots) is not supported by default (see options\\n    of factor).\\n\\n    Bronstein's algorithm can be selected by using ``full=True`` and allows a\\n    decomposition of denominators with non-rational roots. A human-readable\\n    result can be obtained via ``doit()`` (see examples below).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.partfrac import apart\\n    >>> from sympy.abc import x, y\\n\\n    By default, using the undetermined coefficients method:\\n\\n    >>> apart(y/(x + 2)/(x + 1), x)\\n    -y/(x + 2) + y/(x + 1)\\n\\n    The undetermined coefficients method does not provide a result when the\\n    denominators roots are not rational:\\n\\n    >>> apart(y/(x**2 + x + 1), x)\\n    y/(x**2 + x + 1)\\n\\n    You can choose Bronstein's algorithm by setting ``full=True``:\\n\\n    >>> apart(y/(x**2 + x + 1), x, full=True)\\n    RootSum(_w**2 + _w + 1, Lambda(_a, (-2*_a*y/3 - y/3)/(-_a + x)))\\n\\n    Calling ``doit()`` yields a human-readable result:\\n\\n    >>> apart(y/(x**2 + x + 1), x, full=True).doit()\\n    (-y/3 - 2*y*(-1/2 - sqrt(3)*I/2)/3)/(x + 1/2 + sqrt(3)*I/2) + (-y/3 -\\n        2*y*(-1/2 + sqrt(3)*I/2)/3)/(x + 1/2 - sqrt(3)*I/2)\\n\\n\\n    See Also\\n    ========\\n\\n    apart_list, assemble_partfrac_list\\n    \"\n    allowed_flags(options, [])\n    f = sympify(f)\n    if f.is_Atom:\n        return f\n    else:\n        (P, Q) = f.as_numer_denom()\n    _options = options.copy()\n    options = set_defaults(options, extension=True)\n    try:\n        ((P, Q), opt) = parallel_poly_from_expr((P, Q), x, **options)\n    except PolynomialError as msg:\n        if f.is_commutative:\n            raise PolynomialError(msg)\n        if f.is_Mul:\n            (c, nc) = f.args_cnc(split_1=False)\n            nc = f.func(*nc)\n            if c:\n                c = apart(f.func._from_args(c), x=x, full=full, **_options)\n                return c * nc\n            else:\n                return nc\n        elif f.is_Add:\n            c = []\n            nc = []\n            for i in f.args:\n                if i.is_commutative:\n                    c.append(i)\n                else:\n                    try:\n                        nc.append(apart(i, x=x, full=full, **_options))\n                    except NotImplementedError:\n                        nc.append(i)\n            return apart(f.func(*c), x=x, full=full, **_options) + f.func(*nc)\n        else:\n            reps = []\n            pot = preorder_traversal(f)\n            next(pot)\n            for e in pot:\n                try:\n                    reps.append((e, apart(e, x=x, full=full, **_options)))\n                    pot.skip()\n                except NotImplementedError:\n                    pass\n            return f.xreplace(dict(reps))\n    if P.is_multivariate:\n        fc = f.cancel()\n        if fc != f:\n            return apart(fc, x=x, full=full, **_options)\n        raise NotImplementedError('multivariate partial fraction decomposition')\n    (common, P, Q) = P.cancel(Q)\n    (poly, P) = P.div(Q, auto=True)\n    (P, Q) = P.rat_clear_denoms(Q)\n    if Q.degree() <= 1:\n        partial = P / Q\n    elif not full:\n        partial = apart_undetermined_coeffs(P, Q)\n    else:\n        partial = apart_full_decomposition(P, Q)\n    terms = S.Zero\n    for term in Add.make_args(partial):\n        if term.has(RootSum):\n            terms += term\n        else:\n            terms += factor(term)\n    return common * (poly.as_expr() + terms)",
            "@xthreaded\n@public\ndef apart(f, x=None, full=False, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Compute partial fraction decomposition of a rational function.\\n\\n    Given a rational function ``f``, computes the partial fraction\\n    decomposition of ``f``. Two algorithms are available: One is based on the\\n    undertermined coefficients method, the other is Bronstein's full partial\\n    fraction decomposition algorithm.\\n\\n    The undetermined coefficients method (selected by ``full=False``) uses\\n    polynomial factorization (and therefore accepts the same options as\\n    factor) for the denominator. Per default it works over the rational\\n    numbers, therefore decomposition of denominators with non-rational roots\\n    (e.g. irrational, complex roots) is not supported by default (see options\\n    of factor).\\n\\n    Bronstein's algorithm can be selected by using ``full=True`` and allows a\\n    decomposition of denominators with non-rational roots. A human-readable\\n    result can be obtained via ``doit()`` (see examples below).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.partfrac import apart\\n    >>> from sympy.abc import x, y\\n\\n    By default, using the undetermined coefficients method:\\n\\n    >>> apart(y/(x + 2)/(x + 1), x)\\n    -y/(x + 2) + y/(x + 1)\\n\\n    The undetermined coefficients method does not provide a result when the\\n    denominators roots are not rational:\\n\\n    >>> apart(y/(x**2 + x + 1), x)\\n    y/(x**2 + x + 1)\\n\\n    You can choose Bronstein's algorithm by setting ``full=True``:\\n\\n    >>> apart(y/(x**2 + x + 1), x, full=True)\\n    RootSum(_w**2 + _w + 1, Lambda(_a, (-2*_a*y/3 - y/3)/(-_a + x)))\\n\\n    Calling ``doit()`` yields a human-readable result:\\n\\n    >>> apart(y/(x**2 + x + 1), x, full=True).doit()\\n    (-y/3 - 2*y*(-1/2 - sqrt(3)*I/2)/3)/(x + 1/2 + sqrt(3)*I/2) + (-y/3 -\\n        2*y*(-1/2 + sqrt(3)*I/2)/3)/(x + 1/2 - sqrt(3)*I/2)\\n\\n\\n    See Also\\n    ========\\n\\n    apart_list, assemble_partfrac_list\\n    \"\n    allowed_flags(options, [])\n    f = sympify(f)\n    if f.is_Atom:\n        return f\n    else:\n        (P, Q) = f.as_numer_denom()\n    _options = options.copy()\n    options = set_defaults(options, extension=True)\n    try:\n        ((P, Q), opt) = parallel_poly_from_expr((P, Q), x, **options)\n    except PolynomialError as msg:\n        if f.is_commutative:\n            raise PolynomialError(msg)\n        if f.is_Mul:\n            (c, nc) = f.args_cnc(split_1=False)\n            nc = f.func(*nc)\n            if c:\n                c = apart(f.func._from_args(c), x=x, full=full, **_options)\n                return c * nc\n            else:\n                return nc\n        elif f.is_Add:\n            c = []\n            nc = []\n            for i in f.args:\n                if i.is_commutative:\n                    c.append(i)\n                else:\n                    try:\n                        nc.append(apart(i, x=x, full=full, **_options))\n                    except NotImplementedError:\n                        nc.append(i)\n            return apart(f.func(*c), x=x, full=full, **_options) + f.func(*nc)\n        else:\n            reps = []\n            pot = preorder_traversal(f)\n            next(pot)\n            for e in pot:\n                try:\n                    reps.append((e, apart(e, x=x, full=full, **_options)))\n                    pot.skip()\n                except NotImplementedError:\n                    pass\n            return f.xreplace(dict(reps))\n    if P.is_multivariate:\n        fc = f.cancel()\n        if fc != f:\n            return apart(fc, x=x, full=full, **_options)\n        raise NotImplementedError('multivariate partial fraction decomposition')\n    (common, P, Q) = P.cancel(Q)\n    (poly, P) = P.div(Q, auto=True)\n    (P, Q) = P.rat_clear_denoms(Q)\n    if Q.degree() <= 1:\n        partial = P / Q\n    elif not full:\n        partial = apart_undetermined_coeffs(P, Q)\n    else:\n        partial = apart_full_decomposition(P, Q)\n    terms = S.Zero\n    for term in Add.make_args(partial):\n        if term.has(RootSum):\n            terms += term\n        else:\n            terms += factor(term)\n    return common * (poly.as_expr() + terms)",
            "@xthreaded\n@public\ndef apart(f, x=None, full=False, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Compute partial fraction decomposition of a rational function.\\n\\n    Given a rational function ``f``, computes the partial fraction\\n    decomposition of ``f``. Two algorithms are available: One is based on the\\n    undertermined coefficients method, the other is Bronstein's full partial\\n    fraction decomposition algorithm.\\n\\n    The undetermined coefficients method (selected by ``full=False``) uses\\n    polynomial factorization (and therefore accepts the same options as\\n    factor) for the denominator. Per default it works over the rational\\n    numbers, therefore decomposition of denominators with non-rational roots\\n    (e.g. irrational, complex roots) is not supported by default (see options\\n    of factor).\\n\\n    Bronstein's algorithm can be selected by using ``full=True`` and allows a\\n    decomposition of denominators with non-rational roots. A human-readable\\n    result can be obtained via ``doit()`` (see examples below).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.partfrac import apart\\n    >>> from sympy.abc import x, y\\n\\n    By default, using the undetermined coefficients method:\\n\\n    >>> apart(y/(x + 2)/(x + 1), x)\\n    -y/(x + 2) + y/(x + 1)\\n\\n    The undetermined coefficients method does not provide a result when the\\n    denominators roots are not rational:\\n\\n    >>> apart(y/(x**2 + x + 1), x)\\n    y/(x**2 + x + 1)\\n\\n    You can choose Bronstein's algorithm by setting ``full=True``:\\n\\n    >>> apart(y/(x**2 + x + 1), x, full=True)\\n    RootSum(_w**2 + _w + 1, Lambda(_a, (-2*_a*y/3 - y/3)/(-_a + x)))\\n\\n    Calling ``doit()`` yields a human-readable result:\\n\\n    >>> apart(y/(x**2 + x + 1), x, full=True).doit()\\n    (-y/3 - 2*y*(-1/2 - sqrt(3)*I/2)/3)/(x + 1/2 + sqrt(3)*I/2) + (-y/3 -\\n        2*y*(-1/2 + sqrt(3)*I/2)/3)/(x + 1/2 - sqrt(3)*I/2)\\n\\n\\n    See Also\\n    ========\\n\\n    apart_list, assemble_partfrac_list\\n    \"\n    allowed_flags(options, [])\n    f = sympify(f)\n    if f.is_Atom:\n        return f\n    else:\n        (P, Q) = f.as_numer_denom()\n    _options = options.copy()\n    options = set_defaults(options, extension=True)\n    try:\n        ((P, Q), opt) = parallel_poly_from_expr((P, Q), x, **options)\n    except PolynomialError as msg:\n        if f.is_commutative:\n            raise PolynomialError(msg)\n        if f.is_Mul:\n            (c, nc) = f.args_cnc(split_1=False)\n            nc = f.func(*nc)\n            if c:\n                c = apart(f.func._from_args(c), x=x, full=full, **_options)\n                return c * nc\n            else:\n                return nc\n        elif f.is_Add:\n            c = []\n            nc = []\n            for i in f.args:\n                if i.is_commutative:\n                    c.append(i)\n                else:\n                    try:\n                        nc.append(apart(i, x=x, full=full, **_options))\n                    except NotImplementedError:\n                        nc.append(i)\n            return apart(f.func(*c), x=x, full=full, **_options) + f.func(*nc)\n        else:\n            reps = []\n            pot = preorder_traversal(f)\n            next(pot)\n            for e in pot:\n                try:\n                    reps.append((e, apart(e, x=x, full=full, **_options)))\n                    pot.skip()\n                except NotImplementedError:\n                    pass\n            return f.xreplace(dict(reps))\n    if P.is_multivariate:\n        fc = f.cancel()\n        if fc != f:\n            return apart(fc, x=x, full=full, **_options)\n        raise NotImplementedError('multivariate partial fraction decomposition')\n    (common, P, Q) = P.cancel(Q)\n    (poly, P) = P.div(Q, auto=True)\n    (P, Q) = P.rat_clear_denoms(Q)\n    if Q.degree() <= 1:\n        partial = P / Q\n    elif not full:\n        partial = apart_undetermined_coeffs(P, Q)\n    else:\n        partial = apart_full_decomposition(P, Q)\n    terms = S.Zero\n    for term in Add.make_args(partial):\n        if term.has(RootSum):\n            terms += term\n        else:\n            terms += factor(term)\n    return common * (poly.as_expr() + terms)",
            "@xthreaded\n@public\ndef apart(f, x=None, full=False, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Compute partial fraction decomposition of a rational function.\\n\\n    Given a rational function ``f``, computes the partial fraction\\n    decomposition of ``f``. Two algorithms are available: One is based on the\\n    undertermined coefficients method, the other is Bronstein's full partial\\n    fraction decomposition algorithm.\\n\\n    The undetermined coefficients method (selected by ``full=False``) uses\\n    polynomial factorization (and therefore accepts the same options as\\n    factor) for the denominator. Per default it works over the rational\\n    numbers, therefore decomposition of denominators with non-rational roots\\n    (e.g. irrational, complex roots) is not supported by default (see options\\n    of factor).\\n\\n    Bronstein's algorithm can be selected by using ``full=True`` and allows a\\n    decomposition of denominators with non-rational roots. A human-readable\\n    result can be obtained via ``doit()`` (see examples below).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.partfrac import apart\\n    >>> from sympy.abc import x, y\\n\\n    By default, using the undetermined coefficients method:\\n\\n    >>> apart(y/(x + 2)/(x + 1), x)\\n    -y/(x + 2) + y/(x + 1)\\n\\n    The undetermined coefficients method does not provide a result when the\\n    denominators roots are not rational:\\n\\n    >>> apart(y/(x**2 + x + 1), x)\\n    y/(x**2 + x + 1)\\n\\n    You can choose Bronstein's algorithm by setting ``full=True``:\\n\\n    >>> apart(y/(x**2 + x + 1), x, full=True)\\n    RootSum(_w**2 + _w + 1, Lambda(_a, (-2*_a*y/3 - y/3)/(-_a + x)))\\n\\n    Calling ``doit()`` yields a human-readable result:\\n\\n    >>> apart(y/(x**2 + x + 1), x, full=True).doit()\\n    (-y/3 - 2*y*(-1/2 - sqrt(3)*I/2)/3)/(x + 1/2 + sqrt(3)*I/2) + (-y/3 -\\n        2*y*(-1/2 + sqrt(3)*I/2)/3)/(x + 1/2 - sqrt(3)*I/2)\\n\\n\\n    See Also\\n    ========\\n\\n    apart_list, assemble_partfrac_list\\n    \"\n    allowed_flags(options, [])\n    f = sympify(f)\n    if f.is_Atom:\n        return f\n    else:\n        (P, Q) = f.as_numer_denom()\n    _options = options.copy()\n    options = set_defaults(options, extension=True)\n    try:\n        ((P, Q), opt) = parallel_poly_from_expr((P, Q), x, **options)\n    except PolynomialError as msg:\n        if f.is_commutative:\n            raise PolynomialError(msg)\n        if f.is_Mul:\n            (c, nc) = f.args_cnc(split_1=False)\n            nc = f.func(*nc)\n            if c:\n                c = apart(f.func._from_args(c), x=x, full=full, **_options)\n                return c * nc\n            else:\n                return nc\n        elif f.is_Add:\n            c = []\n            nc = []\n            for i in f.args:\n                if i.is_commutative:\n                    c.append(i)\n                else:\n                    try:\n                        nc.append(apart(i, x=x, full=full, **_options))\n                    except NotImplementedError:\n                        nc.append(i)\n            return apart(f.func(*c), x=x, full=full, **_options) + f.func(*nc)\n        else:\n            reps = []\n            pot = preorder_traversal(f)\n            next(pot)\n            for e in pot:\n                try:\n                    reps.append((e, apart(e, x=x, full=full, **_options)))\n                    pot.skip()\n                except NotImplementedError:\n                    pass\n            return f.xreplace(dict(reps))\n    if P.is_multivariate:\n        fc = f.cancel()\n        if fc != f:\n            return apart(fc, x=x, full=full, **_options)\n        raise NotImplementedError('multivariate partial fraction decomposition')\n    (common, P, Q) = P.cancel(Q)\n    (poly, P) = P.div(Q, auto=True)\n    (P, Q) = P.rat_clear_denoms(Q)\n    if Q.degree() <= 1:\n        partial = P / Q\n    elif not full:\n        partial = apart_undetermined_coeffs(P, Q)\n    else:\n        partial = apart_full_decomposition(P, Q)\n    terms = S.Zero\n    for term in Add.make_args(partial):\n        if term.has(RootSum):\n            terms += term\n        else:\n            terms += factor(term)\n    return common * (poly.as_expr() + terms)",
            "@xthreaded\n@public\ndef apart(f, x=None, full=False, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Compute partial fraction decomposition of a rational function.\\n\\n    Given a rational function ``f``, computes the partial fraction\\n    decomposition of ``f``. Two algorithms are available: One is based on the\\n    undertermined coefficients method, the other is Bronstein's full partial\\n    fraction decomposition algorithm.\\n\\n    The undetermined coefficients method (selected by ``full=False``) uses\\n    polynomial factorization (and therefore accepts the same options as\\n    factor) for the denominator. Per default it works over the rational\\n    numbers, therefore decomposition of denominators with non-rational roots\\n    (e.g. irrational, complex roots) is not supported by default (see options\\n    of factor).\\n\\n    Bronstein's algorithm can be selected by using ``full=True`` and allows a\\n    decomposition of denominators with non-rational roots. A human-readable\\n    result can be obtained via ``doit()`` (see examples below).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.partfrac import apart\\n    >>> from sympy.abc import x, y\\n\\n    By default, using the undetermined coefficients method:\\n\\n    >>> apart(y/(x + 2)/(x + 1), x)\\n    -y/(x + 2) + y/(x + 1)\\n\\n    The undetermined coefficients method does not provide a result when the\\n    denominators roots are not rational:\\n\\n    >>> apart(y/(x**2 + x + 1), x)\\n    y/(x**2 + x + 1)\\n\\n    You can choose Bronstein's algorithm by setting ``full=True``:\\n\\n    >>> apart(y/(x**2 + x + 1), x, full=True)\\n    RootSum(_w**2 + _w + 1, Lambda(_a, (-2*_a*y/3 - y/3)/(-_a + x)))\\n\\n    Calling ``doit()`` yields a human-readable result:\\n\\n    >>> apart(y/(x**2 + x + 1), x, full=True).doit()\\n    (-y/3 - 2*y*(-1/2 - sqrt(3)*I/2)/3)/(x + 1/2 + sqrt(3)*I/2) + (-y/3 -\\n        2*y*(-1/2 + sqrt(3)*I/2)/3)/(x + 1/2 - sqrt(3)*I/2)\\n\\n\\n    See Also\\n    ========\\n\\n    apart_list, assemble_partfrac_list\\n    \"\n    allowed_flags(options, [])\n    f = sympify(f)\n    if f.is_Atom:\n        return f\n    else:\n        (P, Q) = f.as_numer_denom()\n    _options = options.copy()\n    options = set_defaults(options, extension=True)\n    try:\n        ((P, Q), opt) = parallel_poly_from_expr((P, Q), x, **options)\n    except PolynomialError as msg:\n        if f.is_commutative:\n            raise PolynomialError(msg)\n        if f.is_Mul:\n            (c, nc) = f.args_cnc(split_1=False)\n            nc = f.func(*nc)\n            if c:\n                c = apart(f.func._from_args(c), x=x, full=full, **_options)\n                return c * nc\n            else:\n                return nc\n        elif f.is_Add:\n            c = []\n            nc = []\n            for i in f.args:\n                if i.is_commutative:\n                    c.append(i)\n                else:\n                    try:\n                        nc.append(apart(i, x=x, full=full, **_options))\n                    except NotImplementedError:\n                        nc.append(i)\n            return apart(f.func(*c), x=x, full=full, **_options) + f.func(*nc)\n        else:\n            reps = []\n            pot = preorder_traversal(f)\n            next(pot)\n            for e in pot:\n                try:\n                    reps.append((e, apart(e, x=x, full=full, **_options)))\n                    pot.skip()\n                except NotImplementedError:\n                    pass\n            return f.xreplace(dict(reps))\n    if P.is_multivariate:\n        fc = f.cancel()\n        if fc != f:\n            return apart(fc, x=x, full=full, **_options)\n        raise NotImplementedError('multivariate partial fraction decomposition')\n    (common, P, Q) = P.cancel(Q)\n    (poly, P) = P.div(Q, auto=True)\n    (P, Q) = P.rat_clear_denoms(Q)\n    if Q.degree() <= 1:\n        partial = P / Q\n    elif not full:\n        partial = apart_undetermined_coeffs(P, Q)\n    else:\n        partial = apart_full_decomposition(P, Q)\n    terms = S.Zero\n    for term in Add.make_args(partial):\n        if term.has(RootSum):\n            terms += term\n        else:\n            terms += factor(term)\n    return common * (poly.as_expr() + terms)"
        ]
    },
    {
        "func_name": "apart_undetermined_coeffs",
        "original": "def apart_undetermined_coeffs(P, Q):\n    \"\"\"Partial fractions via method of undetermined coefficients. \"\"\"\n    X = numbered_symbols(cls=Dummy)\n    (partial, symbols) = ([], [])\n    (_, factors) = Q.factor_list()\n    for (f, k) in factors:\n        (n, q) = (f.degree(), Q)\n        for i in range(1, k + 1):\n            (coeffs, q) = (take(X, n), q.quo(f))\n            partial.append((coeffs, q, f, i))\n            symbols.extend(coeffs)\n    dom = Q.get_domain().inject(*symbols)\n    F = Poly(0, Q.gen, domain=dom)\n    for (i, (coeffs, q, f, k)) in enumerate(partial):\n        h = Poly(coeffs, Q.gen, domain=dom)\n        partial[i] = (h, f, k)\n        q = q.set_domain(dom)\n        F += h * q\n    (system, result) = ([], S.Zero)\n    for ((k,), coeff) in F.terms():\n        system.append(coeff - P.nth(k))\n    from sympy.solvers import solve\n    solution = solve(system, symbols)\n    for (h, f, k) in partial:\n        h = h.as_expr().subs(solution)\n        result += h / f.as_expr() ** k\n    return result",
        "mutated": [
            "def apart_undetermined_coeffs(P, Q):\n    if False:\n        i = 10\n    'Partial fractions via method of undetermined coefficients. '\n    X = numbered_symbols(cls=Dummy)\n    (partial, symbols) = ([], [])\n    (_, factors) = Q.factor_list()\n    for (f, k) in factors:\n        (n, q) = (f.degree(), Q)\n        for i in range(1, k + 1):\n            (coeffs, q) = (take(X, n), q.quo(f))\n            partial.append((coeffs, q, f, i))\n            symbols.extend(coeffs)\n    dom = Q.get_domain().inject(*symbols)\n    F = Poly(0, Q.gen, domain=dom)\n    for (i, (coeffs, q, f, k)) in enumerate(partial):\n        h = Poly(coeffs, Q.gen, domain=dom)\n        partial[i] = (h, f, k)\n        q = q.set_domain(dom)\n        F += h * q\n    (system, result) = ([], S.Zero)\n    for ((k,), coeff) in F.terms():\n        system.append(coeff - P.nth(k))\n    from sympy.solvers import solve\n    solution = solve(system, symbols)\n    for (h, f, k) in partial:\n        h = h.as_expr().subs(solution)\n        result += h / f.as_expr() ** k\n    return result",
            "def apart_undetermined_coeffs(P, Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Partial fractions via method of undetermined coefficients. '\n    X = numbered_symbols(cls=Dummy)\n    (partial, symbols) = ([], [])\n    (_, factors) = Q.factor_list()\n    for (f, k) in factors:\n        (n, q) = (f.degree(), Q)\n        for i in range(1, k + 1):\n            (coeffs, q) = (take(X, n), q.quo(f))\n            partial.append((coeffs, q, f, i))\n            symbols.extend(coeffs)\n    dom = Q.get_domain().inject(*symbols)\n    F = Poly(0, Q.gen, domain=dom)\n    for (i, (coeffs, q, f, k)) in enumerate(partial):\n        h = Poly(coeffs, Q.gen, domain=dom)\n        partial[i] = (h, f, k)\n        q = q.set_domain(dom)\n        F += h * q\n    (system, result) = ([], S.Zero)\n    for ((k,), coeff) in F.terms():\n        system.append(coeff - P.nth(k))\n    from sympy.solvers import solve\n    solution = solve(system, symbols)\n    for (h, f, k) in partial:\n        h = h.as_expr().subs(solution)\n        result += h / f.as_expr() ** k\n    return result",
            "def apart_undetermined_coeffs(P, Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Partial fractions via method of undetermined coefficients. '\n    X = numbered_symbols(cls=Dummy)\n    (partial, symbols) = ([], [])\n    (_, factors) = Q.factor_list()\n    for (f, k) in factors:\n        (n, q) = (f.degree(), Q)\n        for i in range(1, k + 1):\n            (coeffs, q) = (take(X, n), q.quo(f))\n            partial.append((coeffs, q, f, i))\n            symbols.extend(coeffs)\n    dom = Q.get_domain().inject(*symbols)\n    F = Poly(0, Q.gen, domain=dom)\n    for (i, (coeffs, q, f, k)) in enumerate(partial):\n        h = Poly(coeffs, Q.gen, domain=dom)\n        partial[i] = (h, f, k)\n        q = q.set_domain(dom)\n        F += h * q\n    (system, result) = ([], S.Zero)\n    for ((k,), coeff) in F.terms():\n        system.append(coeff - P.nth(k))\n    from sympy.solvers import solve\n    solution = solve(system, symbols)\n    for (h, f, k) in partial:\n        h = h.as_expr().subs(solution)\n        result += h / f.as_expr() ** k\n    return result",
            "def apart_undetermined_coeffs(P, Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Partial fractions via method of undetermined coefficients. '\n    X = numbered_symbols(cls=Dummy)\n    (partial, symbols) = ([], [])\n    (_, factors) = Q.factor_list()\n    for (f, k) in factors:\n        (n, q) = (f.degree(), Q)\n        for i in range(1, k + 1):\n            (coeffs, q) = (take(X, n), q.quo(f))\n            partial.append((coeffs, q, f, i))\n            symbols.extend(coeffs)\n    dom = Q.get_domain().inject(*symbols)\n    F = Poly(0, Q.gen, domain=dom)\n    for (i, (coeffs, q, f, k)) in enumerate(partial):\n        h = Poly(coeffs, Q.gen, domain=dom)\n        partial[i] = (h, f, k)\n        q = q.set_domain(dom)\n        F += h * q\n    (system, result) = ([], S.Zero)\n    for ((k,), coeff) in F.terms():\n        system.append(coeff - P.nth(k))\n    from sympy.solvers import solve\n    solution = solve(system, symbols)\n    for (h, f, k) in partial:\n        h = h.as_expr().subs(solution)\n        result += h / f.as_expr() ** k\n    return result",
            "def apart_undetermined_coeffs(P, Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Partial fractions via method of undetermined coefficients. '\n    X = numbered_symbols(cls=Dummy)\n    (partial, symbols) = ([], [])\n    (_, factors) = Q.factor_list()\n    for (f, k) in factors:\n        (n, q) = (f.degree(), Q)\n        for i in range(1, k + 1):\n            (coeffs, q) = (take(X, n), q.quo(f))\n            partial.append((coeffs, q, f, i))\n            symbols.extend(coeffs)\n    dom = Q.get_domain().inject(*symbols)\n    F = Poly(0, Q.gen, domain=dom)\n    for (i, (coeffs, q, f, k)) in enumerate(partial):\n        h = Poly(coeffs, Q.gen, domain=dom)\n        partial[i] = (h, f, k)\n        q = q.set_domain(dom)\n        F += h * q\n    (system, result) = ([], S.Zero)\n    for ((k,), coeff) in F.terms():\n        system.append(coeff - P.nth(k))\n    from sympy.solvers import solve\n    solution = solve(system, symbols)\n    for (h, f, k) in partial:\n        h = h.as_expr().subs(solution)\n        result += h / f.as_expr() ** k\n    return result"
        ]
    },
    {
        "func_name": "apart_full_decomposition",
        "original": "def apart_full_decomposition(P, Q):\n    \"\"\"\n    Bronstein's full partial fraction decomposition algorithm.\n\n    Given a univariate rational function ``f``, performing only GCD\n    operations over the algebraic closure of the initial ground domain\n    of definition, compute full partial fraction decomposition with\n    fractions having linear denominators.\n\n    Note that no factorization of the initial denominator of ``f`` is\n    performed. The final decomposition is formed in terms of a sum of\n    :class:`RootSum` instances.\n\n    References\n    ==========\n\n    .. [1] [Bronstein93]_\n\n    \"\"\"\n    return assemble_partfrac_list(apart_list(P / Q, P.gens[0]))",
        "mutated": [
            "def apart_full_decomposition(P, Q):\n    if False:\n        i = 10\n    \"\\n    Bronstein's full partial fraction decomposition algorithm.\\n\\n    Given a univariate rational function ``f``, performing only GCD\\n    operations over the algebraic closure of the initial ground domain\\n    of definition, compute full partial fraction decomposition with\\n    fractions having linear denominators.\\n\\n    Note that no factorization of the initial denominator of ``f`` is\\n    performed. The final decomposition is formed in terms of a sum of\\n    :class:`RootSum` instances.\\n\\n    References\\n    ==========\\n\\n    .. [1] [Bronstein93]_\\n\\n    \"\n    return assemble_partfrac_list(apart_list(P / Q, P.gens[0]))",
            "def apart_full_decomposition(P, Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Bronstein's full partial fraction decomposition algorithm.\\n\\n    Given a univariate rational function ``f``, performing only GCD\\n    operations over the algebraic closure of the initial ground domain\\n    of definition, compute full partial fraction decomposition with\\n    fractions having linear denominators.\\n\\n    Note that no factorization of the initial denominator of ``f`` is\\n    performed. The final decomposition is formed in terms of a sum of\\n    :class:`RootSum` instances.\\n\\n    References\\n    ==========\\n\\n    .. [1] [Bronstein93]_\\n\\n    \"\n    return assemble_partfrac_list(apart_list(P / Q, P.gens[0]))",
            "def apart_full_decomposition(P, Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Bronstein's full partial fraction decomposition algorithm.\\n\\n    Given a univariate rational function ``f``, performing only GCD\\n    operations over the algebraic closure of the initial ground domain\\n    of definition, compute full partial fraction decomposition with\\n    fractions having linear denominators.\\n\\n    Note that no factorization of the initial denominator of ``f`` is\\n    performed. The final decomposition is formed in terms of a sum of\\n    :class:`RootSum` instances.\\n\\n    References\\n    ==========\\n\\n    .. [1] [Bronstein93]_\\n\\n    \"\n    return assemble_partfrac_list(apart_list(P / Q, P.gens[0]))",
            "def apart_full_decomposition(P, Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Bronstein's full partial fraction decomposition algorithm.\\n\\n    Given a univariate rational function ``f``, performing only GCD\\n    operations over the algebraic closure of the initial ground domain\\n    of definition, compute full partial fraction decomposition with\\n    fractions having linear denominators.\\n\\n    Note that no factorization of the initial denominator of ``f`` is\\n    performed. The final decomposition is formed in terms of a sum of\\n    :class:`RootSum` instances.\\n\\n    References\\n    ==========\\n\\n    .. [1] [Bronstein93]_\\n\\n    \"\n    return assemble_partfrac_list(apart_list(P / Q, P.gens[0]))",
            "def apart_full_decomposition(P, Q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Bronstein's full partial fraction decomposition algorithm.\\n\\n    Given a univariate rational function ``f``, performing only GCD\\n    operations over the algebraic closure of the initial ground domain\\n    of definition, compute full partial fraction decomposition with\\n    fractions having linear denominators.\\n\\n    Note that no factorization of the initial denominator of ``f`` is\\n    performed. The final decomposition is formed in terms of a sum of\\n    :class:`RootSum` instances.\\n\\n    References\\n    ==========\\n\\n    .. [1] [Bronstein93]_\\n\\n    \"\n    return assemble_partfrac_list(apart_list(P / Q, P.gens[0]))"
        ]
    },
    {
        "func_name": "dummies",
        "original": "def dummies(name):\n    d = Dummy(name)\n    while True:\n        yield d",
        "mutated": [
            "def dummies(name):\n    if False:\n        i = 10\n    d = Dummy(name)\n    while True:\n        yield d",
            "def dummies(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    d = Dummy(name)\n    while True:\n        yield d",
            "def dummies(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    d = Dummy(name)\n    while True:\n        yield d",
            "def dummies(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    d = Dummy(name)\n    while True:\n        yield d",
            "def dummies(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    d = Dummy(name)\n    while True:\n        yield d"
        ]
    },
    {
        "func_name": "apart_list",
        "original": "@public\ndef apart_list(f, x=None, dummies=None, **options):\n    \"\"\"\n    Compute partial fraction decomposition of a rational function\n    and return the result in structured form.\n\n    Given a rational function ``f`` compute the partial fraction decomposition\n    of ``f``. Only Bronstein's full partial fraction decomposition algorithm\n    is supported by this method. The return value is highly structured and\n    perfectly suited for further algorithmic treatment rather than being\n    human-readable. The function returns a tuple holding three elements:\n\n    * The first item is the common coefficient, free of the variable `x` used\n      for decomposition. (It is an element of the base field `K`.)\n\n    * The second item is the polynomial part of the decomposition. This can be\n      the zero polynomial. (It is an element of `K[x]`.)\n\n    * The third part itself is a list of quadruples. Each quadruple\n      has the following elements in this order:\n\n      - The (not necessarily irreducible) polynomial `D` whose roots `w_i` appear\n        in the linear denominator of a bunch of related fraction terms. (This item\n        can also be a list of explicit roots. However, at the moment ``apart_list``\n        never returns a result this way, but the related ``assemble_partfrac_list``\n        function accepts this format as input.)\n\n      - The numerator of the fraction, written as a function of the root `w`\n\n      - The linear denominator of the fraction *excluding its power exponent*,\n        written as a function of the root `w`.\n\n      - The power to which the denominator has to be raised.\n\n    On can always rebuild a plain expression by using the function ``assemble_partfrac_list``.\n\n    Examples\n    ========\n\n    A first example:\n\n    >>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list\n    >>> from sympy.abc import x, t\n\n    >>> f = (2*x**3 - 2*x) / (x**2 - 2*x + 1)\n    >>> pfd = apart_list(f)\n    >>> pfd\n    (1,\n    Poly(2*x + 4, x, domain='ZZ'),\n    [(Poly(_w - 1, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1)])\n\n    >>> assemble_partfrac_list(pfd)\n    2*x + 4 + 4/(x - 1)\n\n    Second example:\n\n    >>> f = (-2*x - 2*x**2) / (3*x**2 - 6*x)\n    >>> pfd = apart_list(f)\n    >>> pfd\n    (-1,\n    Poly(2/3, x, domain='QQ'),\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 2), Lambda(_a, -_a + x), 1)])\n\n    >>> assemble_partfrac_list(pfd)\n    -2/3 - 2/(x - 2)\n\n    Another example, showing symbolic parameters:\n\n    >>> pfd = apart_list(t/(x**2 + x + t), x)\n    >>> pfd\n    (1,\n    Poly(0, x, domain='ZZ[t]'),\n    [(Poly(_w**2 + _w + t, _w, domain='ZZ[t]'),\n    Lambda(_a, -2*_a*t/(4*t - 1) - t/(4*t - 1)),\n    Lambda(_a, -_a + x),\n    1)])\n\n    >>> assemble_partfrac_list(pfd)\n    RootSum(_w**2 + _w + t, Lambda(_a, (-2*_a*t/(4*t - 1) - t/(4*t - 1))/(-_a + x)))\n\n    This example is taken from Bronstein's original paper:\n\n    >>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)\n    >>> pfd = apart_list(f)\n    >>> pfd\n    (1,\n    Poly(0, x, domain='ZZ'),\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),\n    (Poly(_w**2 - 1, _w, domain='ZZ'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),\n    (Poly(_w + 1, _w, domain='ZZ'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)])\n\n    >>> assemble_partfrac_list(pfd)\n    -4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2)\n\n    See also\n    ========\n\n    apart, assemble_partfrac_list\n\n    References\n    ==========\n\n    .. [1] [Bronstein93]_\n\n    \"\"\"\n    allowed_flags(options, [])\n    f = sympify(f)\n    if f.is_Atom:\n        return f\n    else:\n        (P, Q) = f.as_numer_denom()\n    options = set_defaults(options, extension=True)\n    ((P, Q), opt) = parallel_poly_from_expr((P, Q), x, **options)\n    if P.is_multivariate:\n        raise NotImplementedError('multivariate partial fraction decomposition')\n    (common, P, Q) = P.cancel(Q)\n    (poly, P) = P.div(Q, auto=True)\n    (P, Q) = P.rat_clear_denoms(Q)\n    polypart = poly\n    if dummies is None:\n\n        def dummies(name):\n            d = Dummy(name)\n            while True:\n                yield d\n        dummies = dummies('w')\n    rationalpart = apart_list_full_decomposition(P, Q, dummies)\n    return (common, polypart, rationalpart)",
        "mutated": [
            "@public\ndef apart_list(f, x=None, dummies=None, **options):\n    if False:\n        i = 10\n    \"\\n    Compute partial fraction decomposition of a rational function\\n    and return the result in structured form.\\n\\n    Given a rational function ``f`` compute the partial fraction decomposition\\n    of ``f``. Only Bronstein's full partial fraction decomposition algorithm\\n    is supported by this method. The return value is highly structured and\\n    perfectly suited for further algorithmic treatment rather than being\\n    human-readable. The function returns a tuple holding three elements:\\n\\n    * The first item is the common coefficient, free of the variable `x` used\\n      for decomposition. (It is an element of the base field `K`.)\\n\\n    * The second item is the polynomial part of the decomposition. This can be\\n      the zero polynomial. (It is an element of `K[x]`.)\\n\\n    * The third part itself is a list of quadruples. Each quadruple\\n      has the following elements in this order:\\n\\n      - The (not necessarily irreducible) polynomial `D` whose roots `w_i` appear\\n        in the linear denominator of a bunch of related fraction terms. (This item\\n        can also be a list of explicit roots. However, at the moment ``apart_list``\\n        never returns a result this way, but the related ``assemble_partfrac_list``\\n        function accepts this format as input.)\\n\\n      - The numerator of the fraction, written as a function of the root `w`\\n\\n      - The linear denominator of the fraction *excluding its power exponent*,\\n        written as a function of the root `w`.\\n\\n      - The power to which the denominator has to be raised.\\n\\n    On can always rebuild a plain expression by using the function ``assemble_partfrac_list``.\\n\\n    Examples\\n    ========\\n\\n    A first example:\\n\\n    >>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list\\n    >>> from sympy.abc import x, t\\n\\n    >>> f = (2*x**3 - 2*x) / (x**2 - 2*x + 1)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (1,\\n    Poly(2*x + 4, x, domain='ZZ'),\\n    [(Poly(_w - 1, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    2*x + 4 + 4/(x - 1)\\n\\n    Second example:\\n\\n    >>> f = (-2*x - 2*x**2) / (3*x**2 - 6*x)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (-1,\\n    Poly(2/3, x, domain='QQ'),\\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 2), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -2/3 - 2/(x - 2)\\n\\n    Another example, showing symbolic parameters:\\n\\n    >>> pfd = apart_list(t/(x**2 + x + t), x)\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain='ZZ[t]'),\\n    [(Poly(_w**2 + _w + t, _w, domain='ZZ[t]'),\\n    Lambda(_a, -2*_a*t/(4*t - 1) - t/(4*t - 1)),\\n    Lambda(_a, -_a + x),\\n    1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    RootSum(_w**2 + _w + t, Lambda(_a, (-2*_a*t/(4*t - 1) - t/(4*t - 1))/(-_a + x)))\\n\\n    This example is taken from Bronstein's original paper:\\n\\n    >>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain='ZZ'),\\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),\\n    (Poly(_w**2 - 1, _w, domain='ZZ'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),\\n    (Poly(_w + 1, _w, domain='ZZ'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2)\\n\\n    See also\\n    ========\\n\\n    apart, assemble_partfrac_list\\n\\n    References\\n    ==========\\n\\n    .. [1] [Bronstein93]_\\n\\n    \"\n    allowed_flags(options, [])\n    f = sympify(f)\n    if f.is_Atom:\n        return f\n    else:\n        (P, Q) = f.as_numer_denom()\n    options = set_defaults(options, extension=True)\n    ((P, Q), opt) = parallel_poly_from_expr((P, Q), x, **options)\n    if P.is_multivariate:\n        raise NotImplementedError('multivariate partial fraction decomposition')\n    (common, P, Q) = P.cancel(Q)\n    (poly, P) = P.div(Q, auto=True)\n    (P, Q) = P.rat_clear_denoms(Q)\n    polypart = poly\n    if dummies is None:\n\n        def dummies(name):\n            d = Dummy(name)\n            while True:\n                yield d\n        dummies = dummies('w')\n    rationalpart = apart_list_full_decomposition(P, Q, dummies)\n    return (common, polypart, rationalpart)",
            "@public\ndef apart_list(f, x=None, dummies=None, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Compute partial fraction decomposition of a rational function\\n    and return the result in structured form.\\n\\n    Given a rational function ``f`` compute the partial fraction decomposition\\n    of ``f``. Only Bronstein's full partial fraction decomposition algorithm\\n    is supported by this method. The return value is highly structured and\\n    perfectly suited for further algorithmic treatment rather than being\\n    human-readable. The function returns a tuple holding three elements:\\n\\n    * The first item is the common coefficient, free of the variable `x` used\\n      for decomposition. (It is an element of the base field `K`.)\\n\\n    * The second item is the polynomial part of the decomposition. This can be\\n      the zero polynomial. (It is an element of `K[x]`.)\\n\\n    * The third part itself is a list of quadruples. Each quadruple\\n      has the following elements in this order:\\n\\n      - The (not necessarily irreducible) polynomial `D` whose roots `w_i` appear\\n        in the linear denominator of a bunch of related fraction terms. (This item\\n        can also be a list of explicit roots. However, at the moment ``apart_list``\\n        never returns a result this way, but the related ``assemble_partfrac_list``\\n        function accepts this format as input.)\\n\\n      - The numerator of the fraction, written as a function of the root `w`\\n\\n      - The linear denominator of the fraction *excluding its power exponent*,\\n        written as a function of the root `w`.\\n\\n      - The power to which the denominator has to be raised.\\n\\n    On can always rebuild a plain expression by using the function ``assemble_partfrac_list``.\\n\\n    Examples\\n    ========\\n\\n    A first example:\\n\\n    >>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list\\n    >>> from sympy.abc import x, t\\n\\n    >>> f = (2*x**3 - 2*x) / (x**2 - 2*x + 1)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (1,\\n    Poly(2*x + 4, x, domain='ZZ'),\\n    [(Poly(_w - 1, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    2*x + 4 + 4/(x - 1)\\n\\n    Second example:\\n\\n    >>> f = (-2*x - 2*x**2) / (3*x**2 - 6*x)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (-1,\\n    Poly(2/3, x, domain='QQ'),\\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 2), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -2/3 - 2/(x - 2)\\n\\n    Another example, showing symbolic parameters:\\n\\n    >>> pfd = apart_list(t/(x**2 + x + t), x)\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain='ZZ[t]'),\\n    [(Poly(_w**2 + _w + t, _w, domain='ZZ[t]'),\\n    Lambda(_a, -2*_a*t/(4*t - 1) - t/(4*t - 1)),\\n    Lambda(_a, -_a + x),\\n    1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    RootSum(_w**2 + _w + t, Lambda(_a, (-2*_a*t/(4*t - 1) - t/(4*t - 1))/(-_a + x)))\\n\\n    This example is taken from Bronstein's original paper:\\n\\n    >>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain='ZZ'),\\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),\\n    (Poly(_w**2 - 1, _w, domain='ZZ'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),\\n    (Poly(_w + 1, _w, domain='ZZ'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2)\\n\\n    See also\\n    ========\\n\\n    apart, assemble_partfrac_list\\n\\n    References\\n    ==========\\n\\n    .. [1] [Bronstein93]_\\n\\n    \"\n    allowed_flags(options, [])\n    f = sympify(f)\n    if f.is_Atom:\n        return f\n    else:\n        (P, Q) = f.as_numer_denom()\n    options = set_defaults(options, extension=True)\n    ((P, Q), opt) = parallel_poly_from_expr((P, Q), x, **options)\n    if P.is_multivariate:\n        raise NotImplementedError('multivariate partial fraction decomposition')\n    (common, P, Q) = P.cancel(Q)\n    (poly, P) = P.div(Q, auto=True)\n    (P, Q) = P.rat_clear_denoms(Q)\n    polypart = poly\n    if dummies is None:\n\n        def dummies(name):\n            d = Dummy(name)\n            while True:\n                yield d\n        dummies = dummies('w')\n    rationalpart = apart_list_full_decomposition(P, Q, dummies)\n    return (common, polypart, rationalpart)",
            "@public\ndef apart_list(f, x=None, dummies=None, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Compute partial fraction decomposition of a rational function\\n    and return the result in structured form.\\n\\n    Given a rational function ``f`` compute the partial fraction decomposition\\n    of ``f``. Only Bronstein's full partial fraction decomposition algorithm\\n    is supported by this method. The return value is highly structured and\\n    perfectly suited for further algorithmic treatment rather than being\\n    human-readable. The function returns a tuple holding three elements:\\n\\n    * The first item is the common coefficient, free of the variable `x` used\\n      for decomposition. (It is an element of the base field `K`.)\\n\\n    * The second item is the polynomial part of the decomposition. This can be\\n      the zero polynomial. (It is an element of `K[x]`.)\\n\\n    * The third part itself is a list of quadruples. Each quadruple\\n      has the following elements in this order:\\n\\n      - The (not necessarily irreducible) polynomial `D` whose roots `w_i` appear\\n        in the linear denominator of a bunch of related fraction terms. (This item\\n        can also be a list of explicit roots. However, at the moment ``apart_list``\\n        never returns a result this way, but the related ``assemble_partfrac_list``\\n        function accepts this format as input.)\\n\\n      - The numerator of the fraction, written as a function of the root `w`\\n\\n      - The linear denominator of the fraction *excluding its power exponent*,\\n        written as a function of the root `w`.\\n\\n      - The power to which the denominator has to be raised.\\n\\n    On can always rebuild a plain expression by using the function ``assemble_partfrac_list``.\\n\\n    Examples\\n    ========\\n\\n    A first example:\\n\\n    >>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list\\n    >>> from sympy.abc import x, t\\n\\n    >>> f = (2*x**3 - 2*x) / (x**2 - 2*x + 1)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (1,\\n    Poly(2*x + 4, x, domain='ZZ'),\\n    [(Poly(_w - 1, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    2*x + 4 + 4/(x - 1)\\n\\n    Second example:\\n\\n    >>> f = (-2*x - 2*x**2) / (3*x**2 - 6*x)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (-1,\\n    Poly(2/3, x, domain='QQ'),\\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 2), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -2/3 - 2/(x - 2)\\n\\n    Another example, showing symbolic parameters:\\n\\n    >>> pfd = apart_list(t/(x**2 + x + t), x)\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain='ZZ[t]'),\\n    [(Poly(_w**2 + _w + t, _w, domain='ZZ[t]'),\\n    Lambda(_a, -2*_a*t/(4*t - 1) - t/(4*t - 1)),\\n    Lambda(_a, -_a + x),\\n    1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    RootSum(_w**2 + _w + t, Lambda(_a, (-2*_a*t/(4*t - 1) - t/(4*t - 1))/(-_a + x)))\\n\\n    This example is taken from Bronstein's original paper:\\n\\n    >>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain='ZZ'),\\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),\\n    (Poly(_w**2 - 1, _w, domain='ZZ'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),\\n    (Poly(_w + 1, _w, domain='ZZ'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2)\\n\\n    See also\\n    ========\\n\\n    apart, assemble_partfrac_list\\n\\n    References\\n    ==========\\n\\n    .. [1] [Bronstein93]_\\n\\n    \"\n    allowed_flags(options, [])\n    f = sympify(f)\n    if f.is_Atom:\n        return f\n    else:\n        (P, Q) = f.as_numer_denom()\n    options = set_defaults(options, extension=True)\n    ((P, Q), opt) = parallel_poly_from_expr((P, Q), x, **options)\n    if P.is_multivariate:\n        raise NotImplementedError('multivariate partial fraction decomposition')\n    (common, P, Q) = P.cancel(Q)\n    (poly, P) = P.div(Q, auto=True)\n    (P, Q) = P.rat_clear_denoms(Q)\n    polypart = poly\n    if dummies is None:\n\n        def dummies(name):\n            d = Dummy(name)\n            while True:\n                yield d\n        dummies = dummies('w')\n    rationalpart = apart_list_full_decomposition(P, Q, dummies)\n    return (common, polypart, rationalpart)",
            "@public\ndef apart_list(f, x=None, dummies=None, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Compute partial fraction decomposition of a rational function\\n    and return the result in structured form.\\n\\n    Given a rational function ``f`` compute the partial fraction decomposition\\n    of ``f``. Only Bronstein's full partial fraction decomposition algorithm\\n    is supported by this method. The return value is highly structured and\\n    perfectly suited for further algorithmic treatment rather than being\\n    human-readable. The function returns a tuple holding three elements:\\n\\n    * The first item is the common coefficient, free of the variable `x` used\\n      for decomposition. (It is an element of the base field `K`.)\\n\\n    * The second item is the polynomial part of the decomposition. This can be\\n      the zero polynomial. (It is an element of `K[x]`.)\\n\\n    * The third part itself is a list of quadruples. Each quadruple\\n      has the following elements in this order:\\n\\n      - The (not necessarily irreducible) polynomial `D` whose roots `w_i` appear\\n        in the linear denominator of a bunch of related fraction terms. (This item\\n        can also be a list of explicit roots. However, at the moment ``apart_list``\\n        never returns a result this way, but the related ``assemble_partfrac_list``\\n        function accepts this format as input.)\\n\\n      - The numerator of the fraction, written as a function of the root `w`\\n\\n      - The linear denominator of the fraction *excluding its power exponent*,\\n        written as a function of the root `w`.\\n\\n      - The power to which the denominator has to be raised.\\n\\n    On can always rebuild a plain expression by using the function ``assemble_partfrac_list``.\\n\\n    Examples\\n    ========\\n\\n    A first example:\\n\\n    >>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list\\n    >>> from sympy.abc import x, t\\n\\n    >>> f = (2*x**3 - 2*x) / (x**2 - 2*x + 1)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (1,\\n    Poly(2*x + 4, x, domain='ZZ'),\\n    [(Poly(_w - 1, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    2*x + 4 + 4/(x - 1)\\n\\n    Second example:\\n\\n    >>> f = (-2*x - 2*x**2) / (3*x**2 - 6*x)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (-1,\\n    Poly(2/3, x, domain='QQ'),\\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 2), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -2/3 - 2/(x - 2)\\n\\n    Another example, showing symbolic parameters:\\n\\n    >>> pfd = apart_list(t/(x**2 + x + t), x)\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain='ZZ[t]'),\\n    [(Poly(_w**2 + _w + t, _w, domain='ZZ[t]'),\\n    Lambda(_a, -2*_a*t/(4*t - 1) - t/(4*t - 1)),\\n    Lambda(_a, -_a + x),\\n    1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    RootSum(_w**2 + _w + t, Lambda(_a, (-2*_a*t/(4*t - 1) - t/(4*t - 1))/(-_a + x)))\\n\\n    This example is taken from Bronstein's original paper:\\n\\n    >>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain='ZZ'),\\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),\\n    (Poly(_w**2 - 1, _w, domain='ZZ'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),\\n    (Poly(_w + 1, _w, domain='ZZ'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2)\\n\\n    See also\\n    ========\\n\\n    apart, assemble_partfrac_list\\n\\n    References\\n    ==========\\n\\n    .. [1] [Bronstein93]_\\n\\n    \"\n    allowed_flags(options, [])\n    f = sympify(f)\n    if f.is_Atom:\n        return f\n    else:\n        (P, Q) = f.as_numer_denom()\n    options = set_defaults(options, extension=True)\n    ((P, Q), opt) = parallel_poly_from_expr((P, Q), x, **options)\n    if P.is_multivariate:\n        raise NotImplementedError('multivariate partial fraction decomposition')\n    (common, P, Q) = P.cancel(Q)\n    (poly, P) = P.div(Q, auto=True)\n    (P, Q) = P.rat_clear_denoms(Q)\n    polypart = poly\n    if dummies is None:\n\n        def dummies(name):\n            d = Dummy(name)\n            while True:\n                yield d\n        dummies = dummies('w')\n    rationalpart = apart_list_full_decomposition(P, Q, dummies)\n    return (common, polypart, rationalpart)",
            "@public\ndef apart_list(f, x=None, dummies=None, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Compute partial fraction decomposition of a rational function\\n    and return the result in structured form.\\n\\n    Given a rational function ``f`` compute the partial fraction decomposition\\n    of ``f``. Only Bronstein's full partial fraction decomposition algorithm\\n    is supported by this method. The return value is highly structured and\\n    perfectly suited for further algorithmic treatment rather than being\\n    human-readable. The function returns a tuple holding three elements:\\n\\n    * The first item is the common coefficient, free of the variable `x` used\\n      for decomposition. (It is an element of the base field `K`.)\\n\\n    * The second item is the polynomial part of the decomposition. This can be\\n      the zero polynomial. (It is an element of `K[x]`.)\\n\\n    * The third part itself is a list of quadruples. Each quadruple\\n      has the following elements in this order:\\n\\n      - The (not necessarily irreducible) polynomial `D` whose roots `w_i` appear\\n        in the linear denominator of a bunch of related fraction terms. (This item\\n        can also be a list of explicit roots. However, at the moment ``apart_list``\\n        never returns a result this way, but the related ``assemble_partfrac_list``\\n        function accepts this format as input.)\\n\\n      - The numerator of the fraction, written as a function of the root `w`\\n\\n      - The linear denominator of the fraction *excluding its power exponent*,\\n        written as a function of the root `w`.\\n\\n      - The power to which the denominator has to be raised.\\n\\n    On can always rebuild a plain expression by using the function ``assemble_partfrac_list``.\\n\\n    Examples\\n    ========\\n\\n    A first example:\\n\\n    >>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list\\n    >>> from sympy.abc import x, t\\n\\n    >>> f = (2*x**3 - 2*x) / (x**2 - 2*x + 1)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (1,\\n    Poly(2*x + 4, x, domain='ZZ'),\\n    [(Poly(_w - 1, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    2*x + 4 + 4/(x - 1)\\n\\n    Second example:\\n\\n    >>> f = (-2*x - 2*x**2) / (3*x**2 - 6*x)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (-1,\\n    Poly(2/3, x, domain='QQ'),\\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 2), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -2/3 - 2/(x - 2)\\n\\n    Another example, showing symbolic parameters:\\n\\n    >>> pfd = apart_list(t/(x**2 + x + t), x)\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain='ZZ[t]'),\\n    [(Poly(_w**2 + _w + t, _w, domain='ZZ[t]'),\\n    Lambda(_a, -2*_a*t/(4*t - 1) - t/(4*t - 1)),\\n    Lambda(_a, -_a + x),\\n    1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    RootSum(_w**2 + _w + t, Lambda(_a, (-2*_a*t/(4*t - 1) - t/(4*t - 1))/(-_a + x)))\\n\\n    This example is taken from Bronstein's original paper:\\n\\n    >>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain='ZZ'),\\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),\\n    (Poly(_w**2 - 1, _w, domain='ZZ'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),\\n    (Poly(_w + 1, _w, domain='ZZ'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2)\\n\\n    See also\\n    ========\\n\\n    apart, assemble_partfrac_list\\n\\n    References\\n    ==========\\n\\n    .. [1] [Bronstein93]_\\n\\n    \"\n    allowed_flags(options, [])\n    f = sympify(f)\n    if f.is_Atom:\n        return f\n    else:\n        (P, Q) = f.as_numer_denom()\n    options = set_defaults(options, extension=True)\n    ((P, Q), opt) = parallel_poly_from_expr((P, Q), x, **options)\n    if P.is_multivariate:\n        raise NotImplementedError('multivariate partial fraction decomposition')\n    (common, P, Q) = P.cancel(Q)\n    (poly, P) = P.div(Q, auto=True)\n    (P, Q) = P.rat_clear_denoms(Q)\n    polypart = poly\n    if dummies is None:\n\n        def dummies(name):\n            d = Dummy(name)\n            while True:\n                yield d\n        dummies = dummies('w')\n    rationalpart = apart_list_full_decomposition(P, Q, dummies)\n    return (common, polypart, rationalpart)"
        ]
    },
    {
        "func_name": "apart_list_full_decomposition",
        "original": "def apart_list_full_decomposition(P, Q, dummygen):\n    \"\"\"\n    Bronstein's full partial fraction decomposition algorithm.\n\n    Given a univariate rational function ``f``, performing only GCD\n    operations over the algebraic closure of the initial ground domain\n    of definition, compute full partial fraction decomposition with\n    fractions having linear denominators.\n\n    Note that no factorization of the initial denominator of ``f`` is\n    performed. The final decomposition is formed in terms of a sum of\n    :class:`RootSum` instances.\n\n    References\n    ==========\n\n    .. [1] [Bronstein93]_\n\n    \"\"\"\n    (f, x, U) = (P / Q, P.gen, [])\n    u = Function('u')(x)\n    a = Dummy('a')\n    partial = []\n    for (d, n) in Q.sqf_list_include(all=True):\n        b = d.as_expr()\n        U += [u.diff(x, n - 1)]\n        h = cancel(f * b ** n) / u ** n\n        (H, subs) = ([h], [])\n        for j in range(1, n):\n            H += [H[-1].diff(x) / j]\n        for j in range(1, n + 1):\n            subs += [(U[j - 1], b.diff(x, j) / j)]\n        for j in range(0, n):\n            (P, Q) = cancel(H[j]).as_numer_denom()\n            for i in range(0, j + 1):\n                P = P.subs(*subs[j - i])\n            Q = Q.subs(*subs[0])\n            P = Poly(P, x)\n            Q = Poly(Q, x)\n            G = P.gcd(d)\n            D = d.quo(G)\n            (B, g) = Q.half_gcdex(D)\n            b = (P * B.quo(g)).rem(D)\n            Dw = D.subs(x, next(dummygen))\n            numer = Lambda(a, b.as_expr().subs(x, a))\n            denom = Lambda(a, x - a)\n            exponent = n - j\n            partial.append((Dw, numer, denom, exponent))\n    return partial",
        "mutated": [
            "def apart_list_full_decomposition(P, Q, dummygen):\n    if False:\n        i = 10\n    \"\\n    Bronstein's full partial fraction decomposition algorithm.\\n\\n    Given a univariate rational function ``f``, performing only GCD\\n    operations over the algebraic closure of the initial ground domain\\n    of definition, compute full partial fraction decomposition with\\n    fractions having linear denominators.\\n\\n    Note that no factorization of the initial denominator of ``f`` is\\n    performed. The final decomposition is formed in terms of a sum of\\n    :class:`RootSum` instances.\\n\\n    References\\n    ==========\\n\\n    .. [1] [Bronstein93]_\\n\\n    \"\n    (f, x, U) = (P / Q, P.gen, [])\n    u = Function('u')(x)\n    a = Dummy('a')\n    partial = []\n    for (d, n) in Q.sqf_list_include(all=True):\n        b = d.as_expr()\n        U += [u.diff(x, n - 1)]\n        h = cancel(f * b ** n) / u ** n\n        (H, subs) = ([h], [])\n        for j in range(1, n):\n            H += [H[-1].diff(x) / j]\n        for j in range(1, n + 1):\n            subs += [(U[j - 1], b.diff(x, j) / j)]\n        for j in range(0, n):\n            (P, Q) = cancel(H[j]).as_numer_denom()\n            for i in range(0, j + 1):\n                P = P.subs(*subs[j - i])\n            Q = Q.subs(*subs[0])\n            P = Poly(P, x)\n            Q = Poly(Q, x)\n            G = P.gcd(d)\n            D = d.quo(G)\n            (B, g) = Q.half_gcdex(D)\n            b = (P * B.quo(g)).rem(D)\n            Dw = D.subs(x, next(dummygen))\n            numer = Lambda(a, b.as_expr().subs(x, a))\n            denom = Lambda(a, x - a)\n            exponent = n - j\n            partial.append((Dw, numer, denom, exponent))\n    return partial",
            "def apart_list_full_decomposition(P, Q, dummygen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Bronstein's full partial fraction decomposition algorithm.\\n\\n    Given a univariate rational function ``f``, performing only GCD\\n    operations over the algebraic closure of the initial ground domain\\n    of definition, compute full partial fraction decomposition with\\n    fractions having linear denominators.\\n\\n    Note that no factorization of the initial denominator of ``f`` is\\n    performed. The final decomposition is formed in terms of a sum of\\n    :class:`RootSum` instances.\\n\\n    References\\n    ==========\\n\\n    .. [1] [Bronstein93]_\\n\\n    \"\n    (f, x, U) = (P / Q, P.gen, [])\n    u = Function('u')(x)\n    a = Dummy('a')\n    partial = []\n    for (d, n) in Q.sqf_list_include(all=True):\n        b = d.as_expr()\n        U += [u.diff(x, n - 1)]\n        h = cancel(f * b ** n) / u ** n\n        (H, subs) = ([h], [])\n        for j in range(1, n):\n            H += [H[-1].diff(x) / j]\n        for j in range(1, n + 1):\n            subs += [(U[j - 1], b.diff(x, j) / j)]\n        for j in range(0, n):\n            (P, Q) = cancel(H[j]).as_numer_denom()\n            for i in range(0, j + 1):\n                P = P.subs(*subs[j - i])\n            Q = Q.subs(*subs[0])\n            P = Poly(P, x)\n            Q = Poly(Q, x)\n            G = P.gcd(d)\n            D = d.quo(G)\n            (B, g) = Q.half_gcdex(D)\n            b = (P * B.quo(g)).rem(D)\n            Dw = D.subs(x, next(dummygen))\n            numer = Lambda(a, b.as_expr().subs(x, a))\n            denom = Lambda(a, x - a)\n            exponent = n - j\n            partial.append((Dw, numer, denom, exponent))\n    return partial",
            "def apart_list_full_decomposition(P, Q, dummygen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Bronstein's full partial fraction decomposition algorithm.\\n\\n    Given a univariate rational function ``f``, performing only GCD\\n    operations over the algebraic closure of the initial ground domain\\n    of definition, compute full partial fraction decomposition with\\n    fractions having linear denominators.\\n\\n    Note that no factorization of the initial denominator of ``f`` is\\n    performed. The final decomposition is formed in terms of a sum of\\n    :class:`RootSum` instances.\\n\\n    References\\n    ==========\\n\\n    .. [1] [Bronstein93]_\\n\\n    \"\n    (f, x, U) = (P / Q, P.gen, [])\n    u = Function('u')(x)\n    a = Dummy('a')\n    partial = []\n    for (d, n) in Q.sqf_list_include(all=True):\n        b = d.as_expr()\n        U += [u.diff(x, n - 1)]\n        h = cancel(f * b ** n) / u ** n\n        (H, subs) = ([h], [])\n        for j in range(1, n):\n            H += [H[-1].diff(x) / j]\n        for j in range(1, n + 1):\n            subs += [(U[j - 1], b.diff(x, j) / j)]\n        for j in range(0, n):\n            (P, Q) = cancel(H[j]).as_numer_denom()\n            for i in range(0, j + 1):\n                P = P.subs(*subs[j - i])\n            Q = Q.subs(*subs[0])\n            P = Poly(P, x)\n            Q = Poly(Q, x)\n            G = P.gcd(d)\n            D = d.quo(G)\n            (B, g) = Q.half_gcdex(D)\n            b = (P * B.quo(g)).rem(D)\n            Dw = D.subs(x, next(dummygen))\n            numer = Lambda(a, b.as_expr().subs(x, a))\n            denom = Lambda(a, x - a)\n            exponent = n - j\n            partial.append((Dw, numer, denom, exponent))\n    return partial",
            "def apart_list_full_decomposition(P, Q, dummygen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Bronstein's full partial fraction decomposition algorithm.\\n\\n    Given a univariate rational function ``f``, performing only GCD\\n    operations over the algebraic closure of the initial ground domain\\n    of definition, compute full partial fraction decomposition with\\n    fractions having linear denominators.\\n\\n    Note that no factorization of the initial denominator of ``f`` is\\n    performed. The final decomposition is formed in terms of a sum of\\n    :class:`RootSum` instances.\\n\\n    References\\n    ==========\\n\\n    .. [1] [Bronstein93]_\\n\\n    \"\n    (f, x, U) = (P / Q, P.gen, [])\n    u = Function('u')(x)\n    a = Dummy('a')\n    partial = []\n    for (d, n) in Q.sqf_list_include(all=True):\n        b = d.as_expr()\n        U += [u.diff(x, n - 1)]\n        h = cancel(f * b ** n) / u ** n\n        (H, subs) = ([h], [])\n        for j in range(1, n):\n            H += [H[-1].diff(x) / j]\n        for j in range(1, n + 1):\n            subs += [(U[j - 1], b.diff(x, j) / j)]\n        for j in range(0, n):\n            (P, Q) = cancel(H[j]).as_numer_denom()\n            for i in range(0, j + 1):\n                P = P.subs(*subs[j - i])\n            Q = Q.subs(*subs[0])\n            P = Poly(P, x)\n            Q = Poly(Q, x)\n            G = P.gcd(d)\n            D = d.quo(G)\n            (B, g) = Q.half_gcdex(D)\n            b = (P * B.quo(g)).rem(D)\n            Dw = D.subs(x, next(dummygen))\n            numer = Lambda(a, b.as_expr().subs(x, a))\n            denom = Lambda(a, x - a)\n            exponent = n - j\n            partial.append((Dw, numer, denom, exponent))\n    return partial",
            "def apart_list_full_decomposition(P, Q, dummygen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Bronstein's full partial fraction decomposition algorithm.\\n\\n    Given a univariate rational function ``f``, performing only GCD\\n    operations over the algebraic closure of the initial ground domain\\n    of definition, compute full partial fraction decomposition with\\n    fractions having linear denominators.\\n\\n    Note that no factorization of the initial denominator of ``f`` is\\n    performed. The final decomposition is formed in terms of a sum of\\n    :class:`RootSum` instances.\\n\\n    References\\n    ==========\\n\\n    .. [1] [Bronstein93]_\\n\\n    \"\n    (f, x, U) = (P / Q, P.gen, [])\n    u = Function('u')(x)\n    a = Dummy('a')\n    partial = []\n    for (d, n) in Q.sqf_list_include(all=True):\n        b = d.as_expr()\n        U += [u.diff(x, n - 1)]\n        h = cancel(f * b ** n) / u ** n\n        (H, subs) = ([h], [])\n        for j in range(1, n):\n            H += [H[-1].diff(x) / j]\n        for j in range(1, n + 1):\n            subs += [(U[j - 1], b.diff(x, j) / j)]\n        for j in range(0, n):\n            (P, Q) = cancel(H[j]).as_numer_denom()\n            for i in range(0, j + 1):\n                P = P.subs(*subs[j - i])\n            Q = Q.subs(*subs[0])\n            P = Poly(P, x)\n            Q = Poly(Q, x)\n            G = P.gcd(d)\n            D = d.quo(G)\n            (B, g) = Q.half_gcdex(D)\n            b = (P * B.quo(g)).rem(D)\n            Dw = D.subs(x, next(dummygen))\n            numer = Lambda(a, b.as_expr().subs(x, a))\n            denom = Lambda(a, x - a)\n            exponent = n - j\n            partial.append((Dw, numer, denom, exponent))\n    return partial"
        ]
    },
    {
        "func_name": "assemble_partfrac_list",
        "original": "@public\ndef assemble_partfrac_list(partial_list):\n    \"\"\"Reassemble a full partial fraction decomposition\n    from a structured result obtained by the function ``apart_list``.\n\n    Examples\n    ========\n\n    This example is taken from Bronstein's original paper:\n\n    >>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list\n    >>> from sympy.abc import x\n\n    >>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)\n    >>> pfd = apart_list(f)\n    >>> pfd\n    (1,\n    Poly(0, x, domain='ZZ'),\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),\n    (Poly(_w**2 - 1, _w, domain='ZZ'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),\n    (Poly(_w + 1, _w, domain='ZZ'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)])\n\n    >>> assemble_partfrac_list(pfd)\n    -4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2)\n\n    If we happen to know some roots we can provide them easily inside the structure:\n\n    >>> pfd = apart_list(2/(x**2-2))\n    >>> pfd\n    (1,\n    Poly(0, x, domain='ZZ'),\n    [(Poly(_w**2 - 2, _w, domain='ZZ'),\n    Lambda(_a, _a/2),\n    Lambda(_a, -_a + x),\n    1)])\n\n    >>> pfda = assemble_partfrac_list(pfd)\n    >>> pfda\n    RootSum(_w**2 - 2, Lambda(_a, _a/(-_a + x)))/2\n\n    >>> pfda.doit()\n    -sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2)))\n\n    >>> from sympy import Dummy, Poly, Lambda, sqrt\n    >>> a = Dummy(\"a\")\n    >>> pfd = (1, Poly(0, x, domain='ZZ'), [([sqrt(2),-sqrt(2)], Lambda(a, a/2), Lambda(a, -a + x), 1)])\n\n    >>> assemble_partfrac_list(pfd)\n    -sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2)))\n\n    See Also\n    ========\n\n    apart, apart_list\n    \"\"\"\n    common = partial_list[0]\n    polypart = partial_list[1]\n    pfd = polypart.as_expr()\n    for (r, nf, df, ex) in partial_list[2]:\n        if isinstance(r, Poly):\n            (an, nu) = (nf.variables, nf.expr)\n            (ad, de) = (df.variables, df.expr)\n            de = de.subs(ad[0], an[0])\n            func = Lambda(tuple(an), nu / de ** ex)\n            pfd += RootSum(r, func, auto=False, quadratic=False)\n        else:\n            for root in r:\n                pfd += nf(root) / df(root) ** ex\n    return common * pfd",
        "mutated": [
            "@public\ndef assemble_partfrac_list(partial_list):\n    if False:\n        i = 10\n    'Reassemble a full partial fraction decomposition\\n    from a structured result obtained by the function ``apart_list``.\\n\\n    Examples\\n    ========\\n\\n    This example is taken from Bronstein\\'s original paper:\\n\\n    >>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list\\n    >>> from sympy.abc import x\\n\\n    >>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain=\\'ZZ\\'),\\n    [(Poly(_w - 2, _w, domain=\\'ZZ\\'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),\\n    (Poly(_w**2 - 1, _w, domain=\\'ZZ\\'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),\\n    (Poly(_w + 1, _w, domain=\\'ZZ\\'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2)\\n\\n    If we happen to know some roots we can provide them easily inside the structure:\\n\\n    >>> pfd = apart_list(2/(x**2-2))\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain=\\'ZZ\\'),\\n    [(Poly(_w**2 - 2, _w, domain=\\'ZZ\\'),\\n    Lambda(_a, _a/2),\\n    Lambda(_a, -_a + x),\\n    1)])\\n\\n    >>> pfda = assemble_partfrac_list(pfd)\\n    >>> pfda\\n    RootSum(_w**2 - 2, Lambda(_a, _a/(-_a + x)))/2\\n\\n    >>> pfda.doit()\\n    -sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2)))\\n\\n    >>> from sympy import Dummy, Poly, Lambda, sqrt\\n    >>> a = Dummy(\"a\")\\n    >>> pfd = (1, Poly(0, x, domain=\\'ZZ\\'), [([sqrt(2),-sqrt(2)], Lambda(a, a/2), Lambda(a, -a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2)))\\n\\n    See Also\\n    ========\\n\\n    apart, apart_list\\n    '\n    common = partial_list[0]\n    polypart = partial_list[1]\n    pfd = polypart.as_expr()\n    for (r, nf, df, ex) in partial_list[2]:\n        if isinstance(r, Poly):\n            (an, nu) = (nf.variables, nf.expr)\n            (ad, de) = (df.variables, df.expr)\n            de = de.subs(ad[0], an[0])\n            func = Lambda(tuple(an), nu / de ** ex)\n            pfd += RootSum(r, func, auto=False, quadratic=False)\n        else:\n            for root in r:\n                pfd += nf(root) / df(root) ** ex\n    return common * pfd",
            "@public\ndef assemble_partfrac_list(partial_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Reassemble a full partial fraction decomposition\\n    from a structured result obtained by the function ``apart_list``.\\n\\n    Examples\\n    ========\\n\\n    This example is taken from Bronstein\\'s original paper:\\n\\n    >>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list\\n    >>> from sympy.abc import x\\n\\n    >>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain=\\'ZZ\\'),\\n    [(Poly(_w - 2, _w, domain=\\'ZZ\\'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),\\n    (Poly(_w**2 - 1, _w, domain=\\'ZZ\\'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),\\n    (Poly(_w + 1, _w, domain=\\'ZZ\\'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2)\\n\\n    If we happen to know some roots we can provide them easily inside the structure:\\n\\n    >>> pfd = apart_list(2/(x**2-2))\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain=\\'ZZ\\'),\\n    [(Poly(_w**2 - 2, _w, domain=\\'ZZ\\'),\\n    Lambda(_a, _a/2),\\n    Lambda(_a, -_a + x),\\n    1)])\\n\\n    >>> pfda = assemble_partfrac_list(pfd)\\n    >>> pfda\\n    RootSum(_w**2 - 2, Lambda(_a, _a/(-_a + x)))/2\\n\\n    >>> pfda.doit()\\n    -sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2)))\\n\\n    >>> from sympy import Dummy, Poly, Lambda, sqrt\\n    >>> a = Dummy(\"a\")\\n    >>> pfd = (1, Poly(0, x, domain=\\'ZZ\\'), [([sqrt(2),-sqrt(2)], Lambda(a, a/2), Lambda(a, -a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2)))\\n\\n    See Also\\n    ========\\n\\n    apart, apart_list\\n    '\n    common = partial_list[0]\n    polypart = partial_list[1]\n    pfd = polypart.as_expr()\n    for (r, nf, df, ex) in partial_list[2]:\n        if isinstance(r, Poly):\n            (an, nu) = (nf.variables, nf.expr)\n            (ad, de) = (df.variables, df.expr)\n            de = de.subs(ad[0], an[0])\n            func = Lambda(tuple(an), nu / de ** ex)\n            pfd += RootSum(r, func, auto=False, quadratic=False)\n        else:\n            for root in r:\n                pfd += nf(root) / df(root) ** ex\n    return common * pfd",
            "@public\ndef assemble_partfrac_list(partial_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Reassemble a full partial fraction decomposition\\n    from a structured result obtained by the function ``apart_list``.\\n\\n    Examples\\n    ========\\n\\n    This example is taken from Bronstein\\'s original paper:\\n\\n    >>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list\\n    >>> from sympy.abc import x\\n\\n    >>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain=\\'ZZ\\'),\\n    [(Poly(_w - 2, _w, domain=\\'ZZ\\'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),\\n    (Poly(_w**2 - 1, _w, domain=\\'ZZ\\'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),\\n    (Poly(_w + 1, _w, domain=\\'ZZ\\'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2)\\n\\n    If we happen to know some roots we can provide them easily inside the structure:\\n\\n    >>> pfd = apart_list(2/(x**2-2))\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain=\\'ZZ\\'),\\n    [(Poly(_w**2 - 2, _w, domain=\\'ZZ\\'),\\n    Lambda(_a, _a/2),\\n    Lambda(_a, -_a + x),\\n    1)])\\n\\n    >>> pfda = assemble_partfrac_list(pfd)\\n    >>> pfda\\n    RootSum(_w**2 - 2, Lambda(_a, _a/(-_a + x)))/2\\n\\n    >>> pfda.doit()\\n    -sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2)))\\n\\n    >>> from sympy import Dummy, Poly, Lambda, sqrt\\n    >>> a = Dummy(\"a\")\\n    >>> pfd = (1, Poly(0, x, domain=\\'ZZ\\'), [([sqrt(2),-sqrt(2)], Lambda(a, a/2), Lambda(a, -a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2)))\\n\\n    See Also\\n    ========\\n\\n    apart, apart_list\\n    '\n    common = partial_list[0]\n    polypart = partial_list[1]\n    pfd = polypart.as_expr()\n    for (r, nf, df, ex) in partial_list[2]:\n        if isinstance(r, Poly):\n            (an, nu) = (nf.variables, nf.expr)\n            (ad, de) = (df.variables, df.expr)\n            de = de.subs(ad[0], an[0])\n            func = Lambda(tuple(an), nu / de ** ex)\n            pfd += RootSum(r, func, auto=False, quadratic=False)\n        else:\n            for root in r:\n                pfd += nf(root) / df(root) ** ex\n    return common * pfd",
            "@public\ndef assemble_partfrac_list(partial_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Reassemble a full partial fraction decomposition\\n    from a structured result obtained by the function ``apart_list``.\\n\\n    Examples\\n    ========\\n\\n    This example is taken from Bronstein\\'s original paper:\\n\\n    >>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list\\n    >>> from sympy.abc import x\\n\\n    >>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain=\\'ZZ\\'),\\n    [(Poly(_w - 2, _w, domain=\\'ZZ\\'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),\\n    (Poly(_w**2 - 1, _w, domain=\\'ZZ\\'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),\\n    (Poly(_w + 1, _w, domain=\\'ZZ\\'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2)\\n\\n    If we happen to know some roots we can provide them easily inside the structure:\\n\\n    >>> pfd = apart_list(2/(x**2-2))\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain=\\'ZZ\\'),\\n    [(Poly(_w**2 - 2, _w, domain=\\'ZZ\\'),\\n    Lambda(_a, _a/2),\\n    Lambda(_a, -_a + x),\\n    1)])\\n\\n    >>> pfda = assemble_partfrac_list(pfd)\\n    >>> pfda\\n    RootSum(_w**2 - 2, Lambda(_a, _a/(-_a + x)))/2\\n\\n    >>> pfda.doit()\\n    -sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2)))\\n\\n    >>> from sympy import Dummy, Poly, Lambda, sqrt\\n    >>> a = Dummy(\"a\")\\n    >>> pfd = (1, Poly(0, x, domain=\\'ZZ\\'), [([sqrt(2),-sqrt(2)], Lambda(a, a/2), Lambda(a, -a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2)))\\n\\n    See Also\\n    ========\\n\\n    apart, apart_list\\n    '\n    common = partial_list[0]\n    polypart = partial_list[1]\n    pfd = polypart.as_expr()\n    for (r, nf, df, ex) in partial_list[2]:\n        if isinstance(r, Poly):\n            (an, nu) = (nf.variables, nf.expr)\n            (ad, de) = (df.variables, df.expr)\n            de = de.subs(ad[0], an[0])\n            func = Lambda(tuple(an), nu / de ** ex)\n            pfd += RootSum(r, func, auto=False, quadratic=False)\n        else:\n            for root in r:\n                pfd += nf(root) / df(root) ** ex\n    return common * pfd",
            "@public\ndef assemble_partfrac_list(partial_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Reassemble a full partial fraction decomposition\\n    from a structured result obtained by the function ``apart_list``.\\n\\n    Examples\\n    ========\\n\\n    This example is taken from Bronstein\\'s original paper:\\n\\n    >>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list\\n    >>> from sympy.abc import x\\n\\n    >>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)\\n    >>> pfd = apart_list(f)\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain=\\'ZZ\\'),\\n    [(Poly(_w - 2, _w, domain=\\'ZZ\\'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),\\n    (Poly(_w**2 - 1, _w, domain=\\'ZZ\\'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),\\n    (Poly(_w + 1, _w, domain=\\'ZZ\\'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2)\\n\\n    If we happen to know some roots we can provide them easily inside the structure:\\n\\n    >>> pfd = apart_list(2/(x**2-2))\\n    >>> pfd\\n    (1,\\n    Poly(0, x, domain=\\'ZZ\\'),\\n    [(Poly(_w**2 - 2, _w, domain=\\'ZZ\\'),\\n    Lambda(_a, _a/2),\\n    Lambda(_a, -_a + x),\\n    1)])\\n\\n    >>> pfda = assemble_partfrac_list(pfd)\\n    >>> pfda\\n    RootSum(_w**2 - 2, Lambda(_a, _a/(-_a + x)))/2\\n\\n    >>> pfda.doit()\\n    -sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2)))\\n\\n    >>> from sympy import Dummy, Poly, Lambda, sqrt\\n    >>> a = Dummy(\"a\")\\n    >>> pfd = (1, Poly(0, x, domain=\\'ZZ\\'), [([sqrt(2),-sqrt(2)], Lambda(a, a/2), Lambda(a, -a + x), 1)])\\n\\n    >>> assemble_partfrac_list(pfd)\\n    -sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2)))\\n\\n    See Also\\n    ========\\n\\n    apart, apart_list\\n    '\n    common = partial_list[0]\n    polypart = partial_list[1]\n    pfd = polypart.as_expr()\n    for (r, nf, df, ex) in partial_list[2]:\n        if isinstance(r, Poly):\n            (an, nu) = (nf.variables, nf.expr)\n            (ad, de) = (df.variables, df.expr)\n            de = de.subs(ad[0], an[0])\n            func = Lambda(tuple(an), nu / de ** ex)\n            pfd += RootSum(r, func, auto=False, quadratic=False)\n        else:\n            for root in r:\n                pfd += nf(root) / df(root) ** ex\n    return common * pfd"
        ]
    }
]