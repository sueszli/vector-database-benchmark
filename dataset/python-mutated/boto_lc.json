[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    Only load if boto is available.\n    \"\"\"\n    if 'boto_asg.exists' in __salt__:\n        return 'boto_lc'\n    return (False, 'boto_asg module could not be loaded')",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    Only load if boto is available.\\n    '\n    if 'boto_asg.exists' in __salt__:\n        return 'boto_lc'\n    return (False, 'boto_asg module could not be loaded')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Only load if boto is available.\\n    '\n    if 'boto_asg.exists' in __salt__:\n        return 'boto_lc'\n    return (False, 'boto_asg module could not be loaded')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Only load if boto is available.\\n    '\n    if 'boto_asg.exists' in __salt__:\n        return 'boto_lc'\n    return (False, 'boto_asg module could not be loaded')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Only load if boto is available.\\n    '\n    if 'boto_asg.exists' in __salt__:\n        return 'boto_lc'\n    return (False, 'boto_asg module could not be loaded')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Only load if boto is available.\\n    '\n    if 'boto_asg.exists' in __salt__:\n        return 'boto_lc'\n    return (False, 'boto_asg module could not be loaded')"
        ]
    },
    {
        "func_name": "present",
        "original": "def present(name, image_id, key_name=None, vpc_id=None, vpc_name=None, security_groups=None, user_data=None, cloud_init=None, instance_type='m1.small', kernel_id=None, ramdisk_id=None, block_device_mappings=None, delete_on_termination=None, instance_monitoring=False, spot_price=None, instance_profile_name=None, ebs_optimized=False, associate_public_ip_address=None, region=None, key=None, keyid=None, profile=None):\n    \"\"\"\n    Ensure the launch configuration exists.\n\n    name\n        Name of the launch configuration.\n\n    image_id\n        AMI to use for instances. AMI must exist or creation of the launch\n        configuration will fail.\n\n    key_name\n        Name of the EC2 key pair to use for instances. Key must exist or\n        creation of the launch configuration will fail.\n\n    vpc_id\n        The VPC id where the security groups are defined. Only necessary when\n        using named security groups that exist outside of the default VPC.\n        Mutually exclusive with vpc_name.\n\n    vpc_name\n        Name of the VPC where the security groups are defined. Only Necessary\n        when using named security groups that exist outside of the default VPC.\n        Mutually exclusive with vpc_id.\n\n    security_groups\n        List of Names or security group id\u2019s of the security groups with which\n        to associate the EC2 instances or VPC instances, respectively. Security\n        groups must exist, or creation of the launch configuration will fail.\n\n    user_data\n        The user data available to launched EC2 instances.\n\n    cloud_init\n        A dict of cloud_init configuration. Currently supported keys:\n        boothooks, scripts and cloud-config.\n        Mutually exclusive with user_data.\n\n    instance_type\n        The instance type. ex: m1.small.\n\n    kernel_id\n        The kernel id for the instance.\n\n    ramdisk_id\n        The RAM disk ID for the instance.\n\n    block_device_mappings\n        A dict of block device mappings that contains a dict\n        with volume_type, delete_on_termination, iops, size, encrypted,\n        snapshot_id.\n\n        volume_type\n            Indicates what volume type to use. Valid values are standard, io1, gp2.\n            Default is standard.\n\n        delete_on_termination\n            Whether the volume should be explicitly marked for deletion when its instance is\n            terminated (True), or left around (False).  If not provided, or None is explicitly passed,\n            the default AWS behaviour is used, which is True for ROOT volumes of instances, and\n            False for all others.\n\n        iops\n            For Provisioned IOPS (SSD) volumes only. The number of I/O operations per\n            second (IOPS) to provision for the volume.\n\n        size\n            Desired volume size (in GiB).\n\n        encrypted\n            Indicates whether the volume should be encrypted. Encrypted EBS volumes must\n            be attached to instances that support Amazon EBS encryption. Volumes that are\n            created from encrypted snapshots are automatically encrypted. There is no way\n            to create an encrypted volume from an unencrypted snapshot or an unencrypted\n            volume from an encrypted snapshot.\n\n    instance_monitoring\n        Whether instances in group are launched with detailed monitoring.\n\n    spot_price\n        The spot price you are bidding. Only applies if you are building an\n        autoscaling group with spot instances.\n\n    instance_profile_name\n        The name or the Amazon Resource Name (ARN) of the instance profile\n        associated with the IAM role for the instance. Instance profile must\n        exist or the creation of the launch configuration will fail.\n\n    ebs_optimized\n        Specifies whether the instance is optimized for EBS I/O (true) or not\n        (false).\n\n    associate_public_ip_address\n        Used for Auto Scaling groups that launch instances into an Amazon\n        Virtual Private Cloud. Specifies whether to assign a public IP address\n        to each instance launched in a Amazon VPC.\n\n    region\n        The region to connect to.\n\n    key\n        Secret key to be used.\n\n    keyid\n        Access key to be used.\n\n    profile\n        A dict with region, key and keyid, or a pillar key (string)\n        that contains a dict with region, key and keyid.\n    \"\"\"\n    if user_data and cloud_init:\n        raise SaltInvocationError('user_data and cloud_init are mutually exclusive options.')\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    exists = __salt__['boto_asg.launch_configuration_exists'](name, region=region, key=key, keyid=keyid, profile=profile)\n    if not exists:\n        if __opts__['test']:\n            msg = 'Launch configuration set to be created.'\n            ret['comment'] = msg\n            ret['result'] = None\n            return ret\n        if cloud_init:\n            user_data = __salt__['boto_asg.get_cloud_init_mime'](cloud_init)\n        created = __salt__['boto_asg.create_launch_configuration'](name, image_id, key_name=key_name, vpc_id=vpc_id, vpc_name=vpc_name, security_groups=security_groups, user_data=user_data, instance_type=instance_type, kernel_id=kernel_id, ramdisk_id=ramdisk_id, block_device_mappings=block_device_mappings, delete_on_termination=delete_on_termination, instance_monitoring=instance_monitoring, spot_price=spot_price, instance_profile_name=instance_profile_name, ebs_optimized=ebs_optimized, associate_public_ip_address=associate_public_ip_address, region=region, key=key, keyid=keyid, profile=profile)\n        if created:\n            ret['changes']['old'] = None\n            ret['changes']['new'] = name\n        else:\n            ret['result'] = False\n            ret['comment'] = 'Failed to create launch configuration.'\n    else:\n        ret['comment'] = 'Launch configuration present.'\n    return ret",
        "mutated": [
            "def present(name, image_id, key_name=None, vpc_id=None, vpc_name=None, security_groups=None, user_data=None, cloud_init=None, instance_type='m1.small', kernel_id=None, ramdisk_id=None, block_device_mappings=None, delete_on_termination=None, instance_monitoring=False, spot_price=None, instance_profile_name=None, ebs_optimized=False, associate_public_ip_address=None, region=None, key=None, keyid=None, profile=None):\n    if False:\n        i = 10\n    '\\n    Ensure the launch configuration exists.\\n\\n    name\\n        Name of the launch configuration.\\n\\n    image_id\\n        AMI to use for instances. AMI must exist or creation of the launch\\n        configuration will fail.\\n\\n    key_name\\n        Name of the EC2 key pair to use for instances. Key must exist or\\n        creation of the launch configuration will fail.\\n\\n    vpc_id\\n        The VPC id where the security groups are defined. Only necessary when\\n        using named security groups that exist outside of the default VPC.\\n        Mutually exclusive with vpc_name.\\n\\n    vpc_name\\n        Name of the VPC where the security groups are defined. Only Necessary\\n        when using named security groups that exist outside of the default VPC.\\n        Mutually exclusive with vpc_id.\\n\\n    security_groups\\n        List of Names or security group id\u2019s of the security groups with which\\n        to associate the EC2 instances or VPC instances, respectively. Security\\n        groups must exist, or creation of the launch configuration will fail.\\n\\n    user_data\\n        The user data available to launched EC2 instances.\\n\\n    cloud_init\\n        A dict of cloud_init configuration. Currently supported keys:\\n        boothooks, scripts and cloud-config.\\n        Mutually exclusive with user_data.\\n\\n    instance_type\\n        The instance type. ex: m1.small.\\n\\n    kernel_id\\n        The kernel id for the instance.\\n\\n    ramdisk_id\\n        The RAM disk ID for the instance.\\n\\n    block_device_mappings\\n        A dict of block device mappings that contains a dict\\n        with volume_type, delete_on_termination, iops, size, encrypted,\\n        snapshot_id.\\n\\n        volume_type\\n            Indicates what volume type to use. Valid values are standard, io1, gp2.\\n            Default is standard.\\n\\n        delete_on_termination\\n            Whether the volume should be explicitly marked for deletion when its instance is\\n            terminated (True), or left around (False).  If not provided, or None is explicitly passed,\\n            the default AWS behaviour is used, which is True for ROOT volumes of instances, and\\n            False for all others.\\n\\n        iops\\n            For Provisioned IOPS (SSD) volumes only. The number of I/O operations per\\n            second (IOPS) to provision for the volume.\\n\\n        size\\n            Desired volume size (in GiB).\\n\\n        encrypted\\n            Indicates whether the volume should be encrypted. Encrypted EBS volumes must\\n            be attached to instances that support Amazon EBS encryption. Volumes that are\\n            created from encrypted snapshots are automatically encrypted. There is no way\\n            to create an encrypted volume from an unencrypted snapshot or an unencrypted\\n            volume from an encrypted snapshot.\\n\\n    instance_monitoring\\n        Whether instances in group are launched with detailed monitoring.\\n\\n    spot_price\\n        The spot price you are bidding. Only applies if you are building an\\n        autoscaling group with spot instances.\\n\\n    instance_profile_name\\n        The name or the Amazon Resource Name (ARN) of the instance profile\\n        associated with the IAM role for the instance. Instance profile must\\n        exist or the creation of the launch configuration will fail.\\n\\n    ebs_optimized\\n        Specifies whether the instance is optimized for EBS I/O (true) or not\\n        (false).\\n\\n    associate_public_ip_address\\n        Used for Auto Scaling groups that launch instances into an Amazon\\n        Virtual Private Cloud. Specifies whether to assign a public IP address\\n        to each instance launched in a Amazon VPC.\\n\\n    region\\n        The region to connect to.\\n\\n    key\\n        Secret key to be used.\\n\\n    keyid\\n        Access key to be used.\\n\\n    profile\\n        A dict with region, key and keyid, or a pillar key (string)\\n        that contains a dict with region, key and keyid.\\n    '\n    if user_data and cloud_init:\n        raise SaltInvocationError('user_data and cloud_init are mutually exclusive options.')\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    exists = __salt__['boto_asg.launch_configuration_exists'](name, region=region, key=key, keyid=keyid, profile=profile)\n    if not exists:\n        if __opts__['test']:\n            msg = 'Launch configuration set to be created.'\n            ret['comment'] = msg\n            ret['result'] = None\n            return ret\n        if cloud_init:\n            user_data = __salt__['boto_asg.get_cloud_init_mime'](cloud_init)\n        created = __salt__['boto_asg.create_launch_configuration'](name, image_id, key_name=key_name, vpc_id=vpc_id, vpc_name=vpc_name, security_groups=security_groups, user_data=user_data, instance_type=instance_type, kernel_id=kernel_id, ramdisk_id=ramdisk_id, block_device_mappings=block_device_mappings, delete_on_termination=delete_on_termination, instance_monitoring=instance_monitoring, spot_price=spot_price, instance_profile_name=instance_profile_name, ebs_optimized=ebs_optimized, associate_public_ip_address=associate_public_ip_address, region=region, key=key, keyid=keyid, profile=profile)\n        if created:\n            ret['changes']['old'] = None\n            ret['changes']['new'] = name\n        else:\n            ret['result'] = False\n            ret['comment'] = 'Failed to create launch configuration.'\n    else:\n        ret['comment'] = 'Launch configuration present.'\n    return ret",
            "def present(name, image_id, key_name=None, vpc_id=None, vpc_name=None, security_groups=None, user_data=None, cloud_init=None, instance_type='m1.small', kernel_id=None, ramdisk_id=None, block_device_mappings=None, delete_on_termination=None, instance_monitoring=False, spot_price=None, instance_profile_name=None, ebs_optimized=False, associate_public_ip_address=None, region=None, key=None, keyid=None, profile=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Ensure the launch configuration exists.\\n\\n    name\\n        Name of the launch configuration.\\n\\n    image_id\\n        AMI to use for instances. AMI must exist or creation of the launch\\n        configuration will fail.\\n\\n    key_name\\n        Name of the EC2 key pair to use for instances. Key must exist or\\n        creation of the launch configuration will fail.\\n\\n    vpc_id\\n        The VPC id where the security groups are defined. Only necessary when\\n        using named security groups that exist outside of the default VPC.\\n        Mutually exclusive with vpc_name.\\n\\n    vpc_name\\n        Name of the VPC where the security groups are defined. Only Necessary\\n        when using named security groups that exist outside of the default VPC.\\n        Mutually exclusive with vpc_id.\\n\\n    security_groups\\n        List of Names or security group id\u2019s of the security groups with which\\n        to associate the EC2 instances or VPC instances, respectively. Security\\n        groups must exist, or creation of the launch configuration will fail.\\n\\n    user_data\\n        The user data available to launched EC2 instances.\\n\\n    cloud_init\\n        A dict of cloud_init configuration. Currently supported keys:\\n        boothooks, scripts and cloud-config.\\n        Mutually exclusive with user_data.\\n\\n    instance_type\\n        The instance type. ex: m1.small.\\n\\n    kernel_id\\n        The kernel id for the instance.\\n\\n    ramdisk_id\\n        The RAM disk ID for the instance.\\n\\n    block_device_mappings\\n        A dict of block device mappings that contains a dict\\n        with volume_type, delete_on_termination, iops, size, encrypted,\\n        snapshot_id.\\n\\n        volume_type\\n            Indicates what volume type to use. Valid values are standard, io1, gp2.\\n            Default is standard.\\n\\n        delete_on_termination\\n            Whether the volume should be explicitly marked for deletion when its instance is\\n            terminated (True), or left around (False).  If not provided, or None is explicitly passed,\\n            the default AWS behaviour is used, which is True for ROOT volumes of instances, and\\n            False for all others.\\n\\n        iops\\n            For Provisioned IOPS (SSD) volumes only. The number of I/O operations per\\n            second (IOPS) to provision for the volume.\\n\\n        size\\n            Desired volume size (in GiB).\\n\\n        encrypted\\n            Indicates whether the volume should be encrypted. Encrypted EBS volumes must\\n            be attached to instances that support Amazon EBS encryption. Volumes that are\\n            created from encrypted snapshots are automatically encrypted. There is no way\\n            to create an encrypted volume from an unencrypted snapshot or an unencrypted\\n            volume from an encrypted snapshot.\\n\\n    instance_monitoring\\n        Whether instances in group are launched with detailed monitoring.\\n\\n    spot_price\\n        The spot price you are bidding. Only applies if you are building an\\n        autoscaling group with spot instances.\\n\\n    instance_profile_name\\n        The name or the Amazon Resource Name (ARN) of the instance profile\\n        associated with the IAM role for the instance. Instance profile must\\n        exist or the creation of the launch configuration will fail.\\n\\n    ebs_optimized\\n        Specifies whether the instance is optimized for EBS I/O (true) or not\\n        (false).\\n\\n    associate_public_ip_address\\n        Used for Auto Scaling groups that launch instances into an Amazon\\n        Virtual Private Cloud. Specifies whether to assign a public IP address\\n        to each instance launched in a Amazon VPC.\\n\\n    region\\n        The region to connect to.\\n\\n    key\\n        Secret key to be used.\\n\\n    keyid\\n        Access key to be used.\\n\\n    profile\\n        A dict with region, key and keyid, or a pillar key (string)\\n        that contains a dict with region, key and keyid.\\n    '\n    if user_data and cloud_init:\n        raise SaltInvocationError('user_data and cloud_init are mutually exclusive options.')\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    exists = __salt__['boto_asg.launch_configuration_exists'](name, region=region, key=key, keyid=keyid, profile=profile)\n    if not exists:\n        if __opts__['test']:\n            msg = 'Launch configuration set to be created.'\n            ret['comment'] = msg\n            ret['result'] = None\n            return ret\n        if cloud_init:\n            user_data = __salt__['boto_asg.get_cloud_init_mime'](cloud_init)\n        created = __salt__['boto_asg.create_launch_configuration'](name, image_id, key_name=key_name, vpc_id=vpc_id, vpc_name=vpc_name, security_groups=security_groups, user_data=user_data, instance_type=instance_type, kernel_id=kernel_id, ramdisk_id=ramdisk_id, block_device_mappings=block_device_mappings, delete_on_termination=delete_on_termination, instance_monitoring=instance_monitoring, spot_price=spot_price, instance_profile_name=instance_profile_name, ebs_optimized=ebs_optimized, associate_public_ip_address=associate_public_ip_address, region=region, key=key, keyid=keyid, profile=profile)\n        if created:\n            ret['changes']['old'] = None\n            ret['changes']['new'] = name\n        else:\n            ret['result'] = False\n            ret['comment'] = 'Failed to create launch configuration.'\n    else:\n        ret['comment'] = 'Launch configuration present.'\n    return ret",
            "def present(name, image_id, key_name=None, vpc_id=None, vpc_name=None, security_groups=None, user_data=None, cloud_init=None, instance_type='m1.small', kernel_id=None, ramdisk_id=None, block_device_mappings=None, delete_on_termination=None, instance_monitoring=False, spot_price=None, instance_profile_name=None, ebs_optimized=False, associate_public_ip_address=None, region=None, key=None, keyid=None, profile=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Ensure the launch configuration exists.\\n\\n    name\\n        Name of the launch configuration.\\n\\n    image_id\\n        AMI to use for instances. AMI must exist or creation of the launch\\n        configuration will fail.\\n\\n    key_name\\n        Name of the EC2 key pair to use for instances. Key must exist or\\n        creation of the launch configuration will fail.\\n\\n    vpc_id\\n        The VPC id where the security groups are defined. Only necessary when\\n        using named security groups that exist outside of the default VPC.\\n        Mutually exclusive with vpc_name.\\n\\n    vpc_name\\n        Name of the VPC where the security groups are defined. Only Necessary\\n        when using named security groups that exist outside of the default VPC.\\n        Mutually exclusive with vpc_id.\\n\\n    security_groups\\n        List of Names or security group id\u2019s of the security groups with which\\n        to associate the EC2 instances or VPC instances, respectively. Security\\n        groups must exist, or creation of the launch configuration will fail.\\n\\n    user_data\\n        The user data available to launched EC2 instances.\\n\\n    cloud_init\\n        A dict of cloud_init configuration. Currently supported keys:\\n        boothooks, scripts and cloud-config.\\n        Mutually exclusive with user_data.\\n\\n    instance_type\\n        The instance type. ex: m1.small.\\n\\n    kernel_id\\n        The kernel id for the instance.\\n\\n    ramdisk_id\\n        The RAM disk ID for the instance.\\n\\n    block_device_mappings\\n        A dict of block device mappings that contains a dict\\n        with volume_type, delete_on_termination, iops, size, encrypted,\\n        snapshot_id.\\n\\n        volume_type\\n            Indicates what volume type to use. Valid values are standard, io1, gp2.\\n            Default is standard.\\n\\n        delete_on_termination\\n            Whether the volume should be explicitly marked for deletion when its instance is\\n            terminated (True), or left around (False).  If not provided, or None is explicitly passed,\\n            the default AWS behaviour is used, which is True for ROOT volumes of instances, and\\n            False for all others.\\n\\n        iops\\n            For Provisioned IOPS (SSD) volumes only. The number of I/O operations per\\n            second (IOPS) to provision for the volume.\\n\\n        size\\n            Desired volume size (in GiB).\\n\\n        encrypted\\n            Indicates whether the volume should be encrypted. Encrypted EBS volumes must\\n            be attached to instances that support Amazon EBS encryption. Volumes that are\\n            created from encrypted snapshots are automatically encrypted. There is no way\\n            to create an encrypted volume from an unencrypted snapshot or an unencrypted\\n            volume from an encrypted snapshot.\\n\\n    instance_monitoring\\n        Whether instances in group are launched with detailed monitoring.\\n\\n    spot_price\\n        The spot price you are bidding. Only applies if you are building an\\n        autoscaling group with spot instances.\\n\\n    instance_profile_name\\n        The name or the Amazon Resource Name (ARN) of the instance profile\\n        associated with the IAM role for the instance. Instance profile must\\n        exist or the creation of the launch configuration will fail.\\n\\n    ebs_optimized\\n        Specifies whether the instance is optimized for EBS I/O (true) or not\\n        (false).\\n\\n    associate_public_ip_address\\n        Used for Auto Scaling groups that launch instances into an Amazon\\n        Virtual Private Cloud. Specifies whether to assign a public IP address\\n        to each instance launched in a Amazon VPC.\\n\\n    region\\n        The region to connect to.\\n\\n    key\\n        Secret key to be used.\\n\\n    keyid\\n        Access key to be used.\\n\\n    profile\\n        A dict with region, key and keyid, or a pillar key (string)\\n        that contains a dict with region, key and keyid.\\n    '\n    if user_data and cloud_init:\n        raise SaltInvocationError('user_data and cloud_init are mutually exclusive options.')\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    exists = __salt__['boto_asg.launch_configuration_exists'](name, region=region, key=key, keyid=keyid, profile=profile)\n    if not exists:\n        if __opts__['test']:\n            msg = 'Launch configuration set to be created.'\n            ret['comment'] = msg\n            ret['result'] = None\n            return ret\n        if cloud_init:\n            user_data = __salt__['boto_asg.get_cloud_init_mime'](cloud_init)\n        created = __salt__['boto_asg.create_launch_configuration'](name, image_id, key_name=key_name, vpc_id=vpc_id, vpc_name=vpc_name, security_groups=security_groups, user_data=user_data, instance_type=instance_type, kernel_id=kernel_id, ramdisk_id=ramdisk_id, block_device_mappings=block_device_mappings, delete_on_termination=delete_on_termination, instance_monitoring=instance_monitoring, spot_price=spot_price, instance_profile_name=instance_profile_name, ebs_optimized=ebs_optimized, associate_public_ip_address=associate_public_ip_address, region=region, key=key, keyid=keyid, profile=profile)\n        if created:\n            ret['changes']['old'] = None\n            ret['changes']['new'] = name\n        else:\n            ret['result'] = False\n            ret['comment'] = 'Failed to create launch configuration.'\n    else:\n        ret['comment'] = 'Launch configuration present.'\n    return ret",
            "def present(name, image_id, key_name=None, vpc_id=None, vpc_name=None, security_groups=None, user_data=None, cloud_init=None, instance_type='m1.small', kernel_id=None, ramdisk_id=None, block_device_mappings=None, delete_on_termination=None, instance_monitoring=False, spot_price=None, instance_profile_name=None, ebs_optimized=False, associate_public_ip_address=None, region=None, key=None, keyid=None, profile=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Ensure the launch configuration exists.\\n\\n    name\\n        Name of the launch configuration.\\n\\n    image_id\\n        AMI to use for instances. AMI must exist or creation of the launch\\n        configuration will fail.\\n\\n    key_name\\n        Name of the EC2 key pair to use for instances. Key must exist or\\n        creation of the launch configuration will fail.\\n\\n    vpc_id\\n        The VPC id where the security groups are defined. Only necessary when\\n        using named security groups that exist outside of the default VPC.\\n        Mutually exclusive with vpc_name.\\n\\n    vpc_name\\n        Name of the VPC where the security groups are defined. Only Necessary\\n        when using named security groups that exist outside of the default VPC.\\n        Mutually exclusive with vpc_id.\\n\\n    security_groups\\n        List of Names or security group id\u2019s of the security groups with which\\n        to associate the EC2 instances or VPC instances, respectively. Security\\n        groups must exist, or creation of the launch configuration will fail.\\n\\n    user_data\\n        The user data available to launched EC2 instances.\\n\\n    cloud_init\\n        A dict of cloud_init configuration. Currently supported keys:\\n        boothooks, scripts and cloud-config.\\n        Mutually exclusive with user_data.\\n\\n    instance_type\\n        The instance type. ex: m1.small.\\n\\n    kernel_id\\n        The kernel id for the instance.\\n\\n    ramdisk_id\\n        The RAM disk ID for the instance.\\n\\n    block_device_mappings\\n        A dict of block device mappings that contains a dict\\n        with volume_type, delete_on_termination, iops, size, encrypted,\\n        snapshot_id.\\n\\n        volume_type\\n            Indicates what volume type to use. Valid values are standard, io1, gp2.\\n            Default is standard.\\n\\n        delete_on_termination\\n            Whether the volume should be explicitly marked for deletion when its instance is\\n            terminated (True), or left around (False).  If not provided, or None is explicitly passed,\\n            the default AWS behaviour is used, which is True for ROOT volumes of instances, and\\n            False for all others.\\n\\n        iops\\n            For Provisioned IOPS (SSD) volumes only. The number of I/O operations per\\n            second (IOPS) to provision for the volume.\\n\\n        size\\n            Desired volume size (in GiB).\\n\\n        encrypted\\n            Indicates whether the volume should be encrypted. Encrypted EBS volumes must\\n            be attached to instances that support Amazon EBS encryption. Volumes that are\\n            created from encrypted snapshots are automatically encrypted. There is no way\\n            to create an encrypted volume from an unencrypted snapshot or an unencrypted\\n            volume from an encrypted snapshot.\\n\\n    instance_monitoring\\n        Whether instances in group are launched with detailed monitoring.\\n\\n    spot_price\\n        The spot price you are bidding. Only applies if you are building an\\n        autoscaling group with spot instances.\\n\\n    instance_profile_name\\n        The name or the Amazon Resource Name (ARN) of the instance profile\\n        associated with the IAM role for the instance. Instance profile must\\n        exist or the creation of the launch configuration will fail.\\n\\n    ebs_optimized\\n        Specifies whether the instance is optimized for EBS I/O (true) or not\\n        (false).\\n\\n    associate_public_ip_address\\n        Used for Auto Scaling groups that launch instances into an Amazon\\n        Virtual Private Cloud. Specifies whether to assign a public IP address\\n        to each instance launched in a Amazon VPC.\\n\\n    region\\n        The region to connect to.\\n\\n    key\\n        Secret key to be used.\\n\\n    keyid\\n        Access key to be used.\\n\\n    profile\\n        A dict with region, key and keyid, or a pillar key (string)\\n        that contains a dict with region, key and keyid.\\n    '\n    if user_data and cloud_init:\n        raise SaltInvocationError('user_data and cloud_init are mutually exclusive options.')\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    exists = __salt__['boto_asg.launch_configuration_exists'](name, region=region, key=key, keyid=keyid, profile=profile)\n    if not exists:\n        if __opts__['test']:\n            msg = 'Launch configuration set to be created.'\n            ret['comment'] = msg\n            ret['result'] = None\n            return ret\n        if cloud_init:\n            user_data = __salt__['boto_asg.get_cloud_init_mime'](cloud_init)\n        created = __salt__['boto_asg.create_launch_configuration'](name, image_id, key_name=key_name, vpc_id=vpc_id, vpc_name=vpc_name, security_groups=security_groups, user_data=user_data, instance_type=instance_type, kernel_id=kernel_id, ramdisk_id=ramdisk_id, block_device_mappings=block_device_mappings, delete_on_termination=delete_on_termination, instance_monitoring=instance_monitoring, spot_price=spot_price, instance_profile_name=instance_profile_name, ebs_optimized=ebs_optimized, associate_public_ip_address=associate_public_ip_address, region=region, key=key, keyid=keyid, profile=profile)\n        if created:\n            ret['changes']['old'] = None\n            ret['changes']['new'] = name\n        else:\n            ret['result'] = False\n            ret['comment'] = 'Failed to create launch configuration.'\n    else:\n        ret['comment'] = 'Launch configuration present.'\n    return ret",
            "def present(name, image_id, key_name=None, vpc_id=None, vpc_name=None, security_groups=None, user_data=None, cloud_init=None, instance_type='m1.small', kernel_id=None, ramdisk_id=None, block_device_mappings=None, delete_on_termination=None, instance_monitoring=False, spot_price=None, instance_profile_name=None, ebs_optimized=False, associate_public_ip_address=None, region=None, key=None, keyid=None, profile=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Ensure the launch configuration exists.\\n\\n    name\\n        Name of the launch configuration.\\n\\n    image_id\\n        AMI to use for instances. AMI must exist or creation of the launch\\n        configuration will fail.\\n\\n    key_name\\n        Name of the EC2 key pair to use for instances. Key must exist or\\n        creation of the launch configuration will fail.\\n\\n    vpc_id\\n        The VPC id where the security groups are defined. Only necessary when\\n        using named security groups that exist outside of the default VPC.\\n        Mutually exclusive with vpc_name.\\n\\n    vpc_name\\n        Name of the VPC where the security groups are defined. Only Necessary\\n        when using named security groups that exist outside of the default VPC.\\n        Mutually exclusive with vpc_id.\\n\\n    security_groups\\n        List of Names or security group id\u2019s of the security groups with which\\n        to associate the EC2 instances or VPC instances, respectively. Security\\n        groups must exist, or creation of the launch configuration will fail.\\n\\n    user_data\\n        The user data available to launched EC2 instances.\\n\\n    cloud_init\\n        A dict of cloud_init configuration. Currently supported keys:\\n        boothooks, scripts and cloud-config.\\n        Mutually exclusive with user_data.\\n\\n    instance_type\\n        The instance type. ex: m1.small.\\n\\n    kernel_id\\n        The kernel id for the instance.\\n\\n    ramdisk_id\\n        The RAM disk ID for the instance.\\n\\n    block_device_mappings\\n        A dict of block device mappings that contains a dict\\n        with volume_type, delete_on_termination, iops, size, encrypted,\\n        snapshot_id.\\n\\n        volume_type\\n            Indicates what volume type to use. Valid values are standard, io1, gp2.\\n            Default is standard.\\n\\n        delete_on_termination\\n            Whether the volume should be explicitly marked for deletion when its instance is\\n            terminated (True), or left around (False).  If not provided, or None is explicitly passed,\\n            the default AWS behaviour is used, which is True for ROOT volumes of instances, and\\n            False for all others.\\n\\n        iops\\n            For Provisioned IOPS (SSD) volumes only. The number of I/O operations per\\n            second (IOPS) to provision for the volume.\\n\\n        size\\n            Desired volume size (in GiB).\\n\\n        encrypted\\n            Indicates whether the volume should be encrypted. Encrypted EBS volumes must\\n            be attached to instances that support Amazon EBS encryption. Volumes that are\\n            created from encrypted snapshots are automatically encrypted. There is no way\\n            to create an encrypted volume from an unencrypted snapshot or an unencrypted\\n            volume from an encrypted snapshot.\\n\\n    instance_monitoring\\n        Whether instances in group are launched with detailed monitoring.\\n\\n    spot_price\\n        The spot price you are bidding. Only applies if you are building an\\n        autoscaling group with spot instances.\\n\\n    instance_profile_name\\n        The name or the Amazon Resource Name (ARN) of the instance profile\\n        associated with the IAM role for the instance. Instance profile must\\n        exist or the creation of the launch configuration will fail.\\n\\n    ebs_optimized\\n        Specifies whether the instance is optimized for EBS I/O (true) or not\\n        (false).\\n\\n    associate_public_ip_address\\n        Used for Auto Scaling groups that launch instances into an Amazon\\n        Virtual Private Cloud. Specifies whether to assign a public IP address\\n        to each instance launched in a Amazon VPC.\\n\\n    region\\n        The region to connect to.\\n\\n    key\\n        Secret key to be used.\\n\\n    keyid\\n        Access key to be used.\\n\\n    profile\\n        A dict with region, key and keyid, or a pillar key (string)\\n        that contains a dict with region, key and keyid.\\n    '\n    if user_data and cloud_init:\n        raise SaltInvocationError('user_data and cloud_init are mutually exclusive options.')\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    exists = __salt__['boto_asg.launch_configuration_exists'](name, region=region, key=key, keyid=keyid, profile=profile)\n    if not exists:\n        if __opts__['test']:\n            msg = 'Launch configuration set to be created.'\n            ret['comment'] = msg\n            ret['result'] = None\n            return ret\n        if cloud_init:\n            user_data = __salt__['boto_asg.get_cloud_init_mime'](cloud_init)\n        created = __salt__['boto_asg.create_launch_configuration'](name, image_id, key_name=key_name, vpc_id=vpc_id, vpc_name=vpc_name, security_groups=security_groups, user_data=user_data, instance_type=instance_type, kernel_id=kernel_id, ramdisk_id=ramdisk_id, block_device_mappings=block_device_mappings, delete_on_termination=delete_on_termination, instance_monitoring=instance_monitoring, spot_price=spot_price, instance_profile_name=instance_profile_name, ebs_optimized=ebs_optimized, associate_public_ip_address=associate_public_ip_address, region=region, key=key, keyid=keyid, profile=profile)\n        if created:\n            ret['changes']['old'] = None\n            ret['changes']['new'] = name\n        else:\n            ret['result'] = False\n            ret['comment'] = 'Failed to create launch configuration.'\n    else:\n        ret['comment'] = 'Launch configuration present.'\n    return ret"
        ]
    },
    {
        "func_name": "absent",
        "original": "def absent(name, region=None, key=None, keyid=None, profile=None):\n    \"\"\"\n    Ensure the named launch configuration is deleted.\n\n    name\n        Name of the launch configuration.\n\n    region\n        The region to connect to.\n\n    key\n        Secret key to be used.\n\n    keyid\n        Access key to be used.\n\n    profile\n        A dict with region, key and keyid, or a pillar key (string)\n        that contains a dict with region, key and keyid.\n    \"\"\"\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    exists = __salt__['boto_asg.launch_configuration_exists'](name, region=region, key=key, keyid=keyid, profile=profile)\n    if exists:\n        if __opts__['test']:\n            ret['comment'] = 'Launch configuration set to be deleted.'\n            ret['result'] = None\n            return ret\n        deleted = __salt__['boto_asg.delete_launch_configuration'](name, region=region, key=key, keyid=keyid, profile=profile)\n        if deleted:\n            ret['changes']['old'] = name\n            ret['changes']['new'] = None\n            ret['comment'] = 'Deleted launch configuration.'\n        else:\n            ret['result'] = False\n            ret['comment'] = 'Failed to delete launch configuration.'\n    else:\n        ret['comment'] = 'Launch configuration does not exist.'\n    return ret",
        "mutated": [
            "def absent(name, region=None, key=None, keyid=None, profile=None):\n    if False:\n        i = 10\n    '\\n    Ensure the named launch configuration is deleted.\\n\\n    name\\n        Name of the launch configuration.\\n\\n    region\\n        The region to connect to.\\n\\n    key\\n        Secret key to be used.\\n\\n    keyid\\n        Access key to be used.\\n\\n    profile\\n        A dict with region, key and keyid, or a pillar key (string)\\n        that contains a dict with region, key and keyid.\\n    '\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    exists = __salt__['boto_asg.launch_configuration_exists'](name, region=region, key=key, keyid=keyid, profile=profile)\n    if exists:\n        if __opts__['test']:\n            ret['comment'] = 'Launch configuration set to be deleted.'\n            ret['result'] = None\n            return ret\n        deleted = __salt__['boto_asg.delete_launch_configuration'](name, region=region, key=key, keyid=keyid, profile=profile)\n        if deleted:\n            ret['changes']['old'] = name\n            ret['changes']['new'] = None\n            ret['comment'] = 'Deleted launch configuration.'\n        else:\n            ret['result'] = False\n            ret['comment'] = 'Failed to delete launch configuration.'\n    else:\n        ret['comment'] = 'Launch configuration does not exist.'\n    return ret",
            "def absent(name, region=None, key=None, keyid=None, profile=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Ensure the named launch configuration is deleted.\\n\\n    name\\n        Name of the launch configuration.\\n\\n    region\\n        The region to connect to.\\n\\n    key\\n        Secret key to be used.\\n\\n    keyid\\n        Access key to be used.\\n\\n    profile\\n        A dict with region, key and keyid, or a pillar key (string)\\n        that contains a dict with region, key and keyid.\\n    '\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    exists = __salt__['boto_asg.launch_configuration_exists'](name, region=region, key=key, keyid=keyid, profile=profile)\n    if exists:\n        if __opts__['test']:\n            ret['comment'] = 'Launch configuration set to be deleted.'\n            ret['result'] = None\n            return ret\n        deleted = __salt__['boto_asg.delete_launch_configuration'](name, region=region, key=key, keyid=keyid, profile=profile)\n        if deleted:\n            ret['changes']['old'] = name\n            ret['changes']['new'] = None\n            ret['comment'] = 'Deleted launch configuration.'\n        else:\n            ret['result'] = False\n            ret['comment'] = 'Failed to delete launch configuration.'\n    else:\n        ret['comment'] = 'Launch configuration does not exist.'\n    return ret",
            "def absent(name, region=None, key=None, keyid=None, profile=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Ensure the named launch configuration is deleted.\\n\\n    name\\n        Name of the launch configuration.\\n\\n    region\\n        The region to connect to.\\n\\n    key\\n        Secret key to be used.\\n\\n    keyid\\n        Access key to be used.\\n\\n    profile\\n        A dict with region, key and keyid, or a pillar key (string)\\n        that contains a dict with region, key and keyid.\\n    '\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    exists = __salt__['boto_asg.launch_configuration_exists'](name, region=region, key=key, keyid=keyid, profile=profile)\n    if exists:\n        if __opts__['test']:\n            ret['comment'] = 'Launch configuration set to be deleted.'\n            ret['result'] = None\n            return ret\n        deleted = __salt__['boto_asg.delete_launch_configuration'](name, region=region, key=key, keyid=keyid, profile=profile)\n        if deleted:\n            ret['changes']['old'] = name\n            ret['changes']['new'] = None\n            ret['comment'] = 'Deleted launch configuration.'\n        else:\n            ret['result'] = False\n            ret['comment'] = 'Failed to delete launch configuration.'\n    else:\n        ret['comment'] = 'Launch configuration does not exist.'\n    return ret",
            "def absent(name, region=None, key=None, keyid=None, profile=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Ensure the named launch configuration is deleted.\\n\\n    name\\n        Name of the launch configuration.\\n\\n    region\\n        The region to connect to.\\n\\n    key\\n        Secret key to be used.\\n\\n    keyid\\n        Access key to be used.\\n\\n    profile\\n        A dict with region, key and keyid, or a pillar key (string)\\n        that contains a dict with region, key and keyid.\\n    '\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    exists = __salt__['boto_asg.launch_configuration_exists'](name, region=region, key=key, keyid=keyid, profile=profile)\n    if exists:\n        if __opts__['test']:\n            ret['comment'] = 'Launch configuration set to be deleted.'\n            ret['result'] = None\n            return ret\n        deleted = __salt__['boto_asg.delete_launch_configuration'](name, region=region, key=key, keyid=keyid, profile=profile)\n        if deleted:\n            ret['changes']['old'] = name\n            ret['changes']['new'] = None\n            ret['comment'] = 'Deleted launch configuration.'\n        else:\n            ret['result'] = False\n            ret['comment'] = 'Failed to delete launch configuration.'\n    else:\n        ret['comment'] = 'Launch configuration does not exist.'\n    return ret",
            "def absent(name, region=None, key=None, keyid=None, profile=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Ensure the named launch configuration is deleted.\\n\\n    name\\n        Name of the launch configuration.\\n\\n    region\\n        The region to connect to.\\n\\n    key\\n        Secret key to be used.\\n\\n    keyid\\n        Access key to be used.\\n\\n    profile\\n        A dict with region, key and keyid, or a pillar key (string)\\n        that contains a dict with region, key and keyid.\\n    '\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    exists = __salt__['boto_asg.launch_configuration_exists'](name, region=region, key=key, keyid=keyid, profile=profile)\n    if exists:\n        if __opts__['test']:\n            ret['comment'] = 'Launch configuration set to be deleted.'\n            ret['result'] = None\n            return ret\n        deleted = __salt__['boto_asg.delete_launch_configuration'](name, region=region, key=key, keyid=keyid, profile=profile)\n        if deleted:\n            ret['changes']['old'] = name\n            ret['changes']['new'] = None\n            ret['comment'] = 'Deleted launch configuration.'\n        else:\n            ret['result'] = False\n            ret['comment'] = 'Failed to delete launch configuration.'\n    else:\n        ret['comment'] = 'Launch configuration does not exist.'\n    return ret"
        ]
    }
]