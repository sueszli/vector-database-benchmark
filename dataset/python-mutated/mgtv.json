[
    {
        "func_name": "_real_extract",
        "original": "def _real_extract(self, url):\n    video_id = self._match_id(url)\n    tk2 = base64.urlsafe_b64encode(f'did={str(uuid.uuid4())}|pno=1030|ver=0.3.0301|clit={int(time.time())}'.encode())[::-1]\n    try:\n        api_data = self._download_json('https://pcweb.api.mgtv.com/player/video', video_id, query={'tk2': tk2, 'video_id': video_id, 'type': 'pch5'}, headers=self.geo_verification_headers())['data']\n    except ExtractorError as e:\n        if isinstance(e.cause, HTTPError) and e.cause.status == 401:\n            error = self._parse_json(e.cause.response.read().decode(), None)\n            if error.get('code') == 40005:\n                self.raise_geo_restricted(countries=self._GEO_COUNTRIES)\n            raise ExtractorError(error['msg'], expected=True)\n        raise\n    stream_data = self._download_json('https://pcweb.api.mgtv.com/player/getSource', video_id, query={'tk2': tk2, 'pm2': api_data['atc']['pm2'], 'video_id': video_id, 'type': 'pch5', 'src': 'intelmgtv'}, headers=self.geo_verification_headers())['data']\n    stream_domain = traverse_obj(stream_data, ('stream_domain', ..., {url_or_none}), get_all=False)\n    formats = []\n    for (idx, stream) in enumerate(traverse_obj(stream_data, ('stream', lambda _, v: v['url']))):\n        stream_name = traverse_obj(stream, 'name', 'standardName', 'barName', expected_type=str)\n        resolution = traverse_obj(self._RESOLUTIONS, (stream_name, 1 if stream.get('scale') == '16:9' else 0))\n        format_url = traverse_obj(self._download_json(urljoin(stream_domain, stream['url']), video_id, fatal=False, note=f'Downloading video info for format {resolution or stream_name}'), ('info', {url_or_none}))\n        if not format_url:\n            continue\n        tbr = int_or_none(stream.get('filebitrate') or self._search_regex('_(\\\\d+)_mp4/', format_url, 'tbr', default=None))\n        formats.append({'format_id': str(tbr or idx), 'url': format_url, 'ext': 'mp4', 'tbr': tbr, 'vcodec': stream.get('videoFormat'), 'acodec': stream.get('audioFormat'), **parse_resolution(resolution), 'protocol': 'm3u8_native', 'http_headers': {'Referer': url}, 'format_note': stream_name})\n    return {'id': video_id, 'formats': formats, **traverse_obj(api_data, ('info', {'title': ('title', {str.strip}), 'description': ('desc', {str}), 'duration': ('duration', {int_or_none}), 'thumbnail': ('thumb', {url_or_none})})), 'subtitles': self.extract_subtitles(video_id, stream_domain)}",
        "mutated": [
            "def _real_extract(self, url):\n    if False:\n        i = 10\n    video_id = self._match_id(url)\n    tk2 = base64.urlsafe_b64encode(f'did={str(uuid.uuid4())}|pno=1030|ver=0.3.0301|clit={int(time.time())}'.encode())[::-1]\n    try:\n        api_data = self._download_json('https://pcweb.api.mgtv.com/player/video', video_id, query={'tk2': tk2, 'video_id': video_id, 'type': 'pch5'}, headers=self.geo_verification_headers())['data']\n    except ExtractorError as e:\n        if isinstance(e.cause, HTTPError) and e.cause.status == 401:\n            error = self._parse_json(e.cause.response.read().decode(), None)\n            if error.get('code') == 40005:\n                self.raise_geo_restricted(countries=self._GEO_COUNTRIES)\n            raise ExtractorError(error['msg'], expected=True)\n        raise\n    stream_data = self._download_json('https://pcweb.api.mgtv.com/player/getSource', video_id, query={'tk2': tk2, 'pm2': api_data['atc']['pm2'], 'video_id': video_id, 'type': 'pch5', 'src': 'intelmgtv'}, headers=self.geo_verification_headers())['data']\n    stream_domain = traverse_obj(stream_data, ('stream_domain', ..., {url_or_none}), get_all=False)\n    formats = []\n    for (idx, stream) in enumerate(traverse_obj(stream_data, ('stream', lambda _, v: v['url']))):\n        stream_name = traverse_obj(stream, 'name', 'standardName', 'barName', expected_type=str)\n        resolution = traverse_obj(self._RESOLUTIONS, (stream_name, 1 if stream.get('scale') == '16:9' else 0))\n        format_url = traverse_obj(self._download_json(urljoin(stream_domain, stream['url']), video_id, fatal=False, note=f'Downloading video info for format {resolution or stream_name}'), ('info', {url_or_none}))\n        if not format_url:\n            continue\n        tbr = int_or_none(stream.get('filebitrate') or self._search_regex('_(\\\\d+)_mp4/', format_url, 'tbr', default=None))\n        formats.append({'format_id': str(tbr or idx), 'url': format_url, 'ext': 'mp4', 'tbr': tbr, 'vcodec': stream.get('videoFormat'), 'acodec': stream.get('audioFormat'), **parse_resolution(resolution), 'protocol': 'm3u8_native', 'http_headers': {'Referer': url}, 'format_note': stream_name})\n    return {'id': video_id, 'formats': formats, **traverse_obj(api_data, ('info', {'title': ('title', {str.strip}), 'description': ('desc', {str}), 'duration': ('duration', {int_or_none}), 'thumbnail': ('thumb', {url_or_none})})), 'subtitles': self.extract_subtitles(video_id, stream_domain)}",
            "def _real_extract(self, url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    video_id = self._match_id(url)\n    tk2 = base64.urlsafe_b64encode(f'did={str(uuid.uuid4())}|pno=1030|ver=0.3.0301|clit={int(time.time())}'.encode())[::-1]\n    try:\n        api_data = self._download_json('https://pcweb.api.mgtv.com/player/video', video_id, query={'tk2': tk2, 'video_id': video_id, 'type': 'pch5'}, headers=self.geo_verification_headers())['data']\n    except ExtractorError as e:\n        if isinstance(e.cause, HTTPError) and e.cause.status == 401:\n            error = self._parse_json(e.cause.response.read().decode(), None)\n            if error.get('code') == 40005:\n                self.raise_geo_restricted(countries=self._GEO_COUNTRIES)\n            raise ExtractorError(error['msg'], expected=True)\n        raise\n    stream_data = self._download_json('https://pcweb.api.mgtv.com/player/getSource', video_id, query={'tk2': tk2, 'pm2': api_data['atc']['pm2'], 'video_id': video_id, 'type': 'pch5', 'src': 'intelmgtv'}, headers=self.geo_verification_headers())['data']\n    stream_domain = traverse_obj(stream_data, ('stream_domain', ..., {url_or_none}), get_all=False)\n    formats = []\n    for (idx, stream) in enumerate(traverse_obj(stream_data, ('stream', lambda _, v: v['url']))):\n        stream_name = traverse_obj(stream, 'name', 'standardName', 'barName', expected_type=str)\n        resolution = traverse_obj(self._RESOLUTIONS, (stream_name, 1 if stream.get('scale') == '16:9' else 0))\n        format_url = traverse_obj(self._download_json(urljoin(stream_domain, stream['url']), video_id, fatal=False, note=f'Downloading video info for format {resolution or stream_name}'), ('info', {url_or_none}))\n        if not format_url:\n            continue\n        tbr = int_or_none(stream.get('filebitrate') or self._search_regex('_(\\\\d+)_mp4/', format_url, 'tbr', default=None))\n        formats.append({'format_id': str(tbr or idx), 'url': format_url, 'ext': 'mp4', 'tbr': tbr, 'vcodec': stream.get('videoFormat'), 'acodec': stream.get('audioFormat'), **parse_resolution(resolution), 'protocol': 'm3u8_native', 'http_headers': {'Referer': url}, 'format_note': stream_name})\n    return {'id': video_id, 'formats': formats, **traverse_obj(api_data, ('info', {'title': ('title', {str.strip}), 'description': ('desc', {str}), 'duration': ('duration', {int_or_none}), 'thumbnail': ('thumb', {url_or_none})})), 'subtitles': self.extract_subtitles(video_id, stream_domain)}",
            "def _real_extract(self, url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    video_id = self._match_id(url)\n    tk2 = base64.urlsafe_b64encode(f'did={str(uuid.uuid4())}|pno=1030|ver=0.3.0301|clit={int(time.time())}'.encode())[::-1]\n    try:\n        api_data = self._download_json('https://pcweb.api.mgtv.com/player/video', video_id, query={'tk2': tk2, 'video_id': video_id, 'type': 'pch5'}, headers=self.geo_verification_headers())['data']\n    except ExtractorError as e:\n        if isinstance(e.cause, HTTPError) and e.cause.status == 401:\n            error = self._parse_json(e.cause.response.read().decode(), None)\n            if error.get('code') == 40005:\n                self.raise_geo_restricted(countries=self._GEO_COUNTRIES)\n            raise ExtractorError(error['msg'], expected=True)\n        raise\n    stream_data = self._download_json('https://pcweb.api.mgtv.com/player/getSource', video_id, query={'tk2': tk2, 'pm2': api_data['atc']['pm2'], 'video_id': video_id, 'type': 'pch5', 'src': 'intelmgtv'}, headers=self.geo_verification_headers())['data']\n    stream_domain = traverse_obj(stream_data, ('stream_domain', ..., {url_or_none}), get_all=False)\n    formats = []\n    for (idx, stream) in enumerate(traverse_obj(stream_data, ('stream', lambda _, v: v['url']))):\n        stream_name = traverse_obj(stream, 'name', 'standardName', 'barName', expected_type=str)\n        resolution = traverse_obj(self._RESOLUTIONS, (stream_name, 1 if stream.get('scale') == '16:9' else 0))\n        format_url = traverse_obj(self._download_json(urljoin(stream_domain, stream['url']), video_id, fatal=False, note=f'Downloading video info for format {resolution or stream_name}'), ('info', {url_or_none}))\n        if not format_url:\n            continue\n        tbr = int_or_none(stream.get('filebitrate') or self._search_regex('_(\\\\d+)_mp4/', format_url, 'tbr', default=None))\n        formats.append({'format_id': str(tbr or idx), 'url': format_url, 'ext': 'mp4', 'tbr': tbr, 'vcodec': stream.get('videoFormat'), 'acodec': stream.get('audioFormat'), **parse_resolution(resolution), 'protocol': 'm3u8_native', 'http_headers': {'Referer': url}, 'format_note': stream_name})\n    return {'id': video_id, 'formats': formats, **traverse_obj(api_data, ('info', {'title': ('title', {str.strip}), 'description': ('desc', {str}), 'duration': ('duration', {int_or_none}), 'thumbnail': ('thumb', {url_or_none})})), 'subtitles': self.extract_subtitles(video_id, stream_domain)}",
            "def _real_extract(self, url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    video_id = self._match_id(url)\n    tk2 = base64.urlsafe_b64encode(f'did={str(uuid.uuid4())}|pno=1030|ver=0.3.0301|clit={int(time.time())}'.encode())[::-1]\n    try:\n        api_data = self._download_json('https://pcweb.api.mgtv.com/player/video', video_id, query={'tk2': tk2, 'video_id': video_id, 'type': 'pch5'}, headers=self.geo_verification_headers())['data']\n    except ExtractorError as e:\n        if isinstance(e.cause, HTTPError) and e.cause.status == 401:\n            error = self._parse_json(e.cause.response.read().decode(), None)\n            if error.get('code') == 40005:\n                self.raise_geo_restricted(countries=self._GEO_COUNTRIES)\n            raise ExtractorError(error['msg'], expected=True)\n        raise\n    stream_data = self._download_json('https://pcweb.api.mgtv.com/player/getSource', video_id, query={'tk2': tk2, 'pm2': api_data['atc']['pm2'], 'video_id': video_id, 'type': 'pch5', 'src': 'intelmgtv'}, headers=self.geo_verification_headers())['data']\n    stream_domain = traverse_obj(stream_data, ('stream_domain', ..., {url_or_none}), get_all=False)\n    formats = []\n    for (idx, stream) in enumerate(traverse_obj(stream_data, ('stream', lambda _, v: v['url']))):\n        stream_name = traverse_obj(stream, 'name', 'standardName', 'barName', expected_type=str)\n        resolution = traverse_obj(self._RESOLUTIONS, (stream_name, 1 if stream.get('scale') == '16:9' else 0))\n        format_url = traverse_obj(self._download_json(urljoin(stream_domain, stream['url']), video_id, fatal=False, note=f'Downloading video info for format {resolution or stream_name}'), ('info', {url_or_none}))\n        if not format_url:\n            continue\n        tbr = int_or_none(stream.get('filebitrate') or self._search_regex('_(\\\\d+)_mp4/', format_url, 'tbr', default=None))\n        formats.append({'format_id': str(tbr or idx), 'url': format_url, 'ext': 'mp4', 'tbr': tbr, 'vcodec': stream.get('videoFormat'), 'acodec': stream.get('audioFormat'), **parse_resolution(resolution), 'protocol': 'm3u8_native', 'http_headers': {'Referer': url}, 'format_note': stream_name})\n    return {'id': video_id, 'formats': formats, **traverse_obj(api_data, ('info', {'title': ('title', {str.strip}), 'description': ('desc', {str}), 'duration': ('duration', {int_or_none}), 'thumbnail': ('thumb', {url_or_none})})), 'subtitles': self.extract_subtitles(video_id, stream_domain)}",
            "def _real_extract(self, url):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    video_id = self._match_id(url)\n    tk2 = base64.urlsafe_b64encode(f'did={str(uuid.uuid4())}|pno=1030|ver=0.3.0301|clit={int(time.time())}'.encode())[::-1]\n    try:\n        api_data = self._download_json('https://pcweb.api.mgtv.com/player/video', video_id, query={'tk2': tk2, 'video_id': video_id, 'type': 'pch5'}, headers=self.geo_verification_headers())['data']\n    except ExtractorError as e:\n        if isinstance(e.cause, HTTPError) and e.cause.status == 401:\n            error = self._parse_json(e.cause.response.read().decode(), None)\n            if error.get('code') == 40005:\n                self.raise_geo_restricted(countries=self._GEO_COUNTRIES)\n            raise ExtractorError(error['msg'], expected=True)\n        raise\n    stream_data = self._download_json('https://pcweb.api.mgtv.com/player/getSource', video_id, query={'tk2': tk2, 'pm2': api_data['atc']['pm2'], 'video_id': video_id, 'type': 'pch5', 'src': 'intelmgtv'}, headers=self.geo_verification_headers())['data']\n    stream_domain = traverse_obj(stream_data, ('stream_domain', ..., {url_or_none}), get_all=False)\n    formats = []\n    for (idx, stream) in enumerate(traverse_obj(stream_data, ('stream', lambda _, v: v['url']))):\n        stream_name = traverse_obj(stream, 'name', 'standardName', 'barName', expected_type=str)\n        resolution = traverse_obj(self._RESOLUTIONS, (stream_name, 1 if stream.get('scale') == '16:9' else 0))\n        format_url = traverse_obj(self._download_json(urljoin(stream_domain, stream['url']), video_id, fatal=False, note=f'Downloading video info for format {resolution or stream_name}'), ('info', {url_or_none}))\n        if not format_url:\n            continue\n        tbr = int_or_none(stream.get('filebitrate') or self._search_regex('_(\\\\d+)_mp4/', format_url, 'tbr', default=None))\n        formats.append({'format_id': str(tbr or idx), 'url': format_url, 'ext': 'mp4', 'tbr': tbr, 'vcodec': stream.get('videoFormat'), 'acodec': stream.get('audioFormat'), **parse_resolution(resolution), 'protocol': 'm3u8_native', 'http_headers': {'Referer': url}, 'format_note': stream_name})\n    return {'id': video_id, 'formats': formats, **traverse_obj(api_data, ('info', {'title': ('title', {str.strip}), 'description': ('desc', {str}), 'duration': ('duration', {int_or_none}), 'thumbnail': ('thumb', {url_or_none})})), 'subtitles': self.extract_subtitles(video_id, stream_domain)}"
        ]
    },
    {
        "func_name": "_get_subtitles",
        "original": "def _get_subtitles(self, video_id, domain):\n    info = self._download_json(f'https://pcweb.api.mgtv.com/video/title?videoId={video_id}', video_id, fatal=False) or {}\n    subtitles = {}\n    for sub in try_get(info, lambda x: x['data']['title']) or []:\n        url_sub = sub.get('url')\n        if not url_sub:\n            continue\n        locale = sub.get('captionSimpleName') or 'en'\n        sub = self._download_json(f'{domain}{url_sub}', video_id, fatal=False, note=f\"Download subtitle for locale {sub.get('name')} ({locale})\") or {}\n        sub_url = url_or_none(sub.get('info'))\n        if not sub_url:\n            continue\n        subtitles.setdefault(locale.lower(), []).append({'url': sub_url, 'name': sub.get('name'), 'ext': 'srt'})\n    return subtitles",
        "mutated": [
            "def _get_subtitles(self, video_id, domain):\n    if False:\n        i = 10\n    info = self._download_json(f'https://pcweb.api.mgtv.com/video/title?videoId={video_id}', video_id, fatal=False) or {}\n    subtitles = {}\n    for sub in try_get(info, lambda x: x['data']['title']) or []:\n        url_sub = sub.get('url')\n        if not url_sub:\n            continue\n        locale = sub.get('captionSimpleName') or 'en'\n        sub = self._download_json(f'{domain}{url_sub}', video_id, fatal=False, note=f\"Download subtitle for locale {sub.get('name')} ({locale})\") or {}\n        sub_url = url_or_none(sub.get('info'))\n        if not sub_url:\n            continue\n        subtitles.setdefault(locale.lower(), []).append({'url': sub_url, 'name': sub.get('name'), 'ext': 'srt'})\n    return subtitles",
            "def _get_subtitles(self, video_id, domain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    info = self._download_json(f'https://pcweb.api.mgtv.com/video/title?videoId={video_id}', video_id, fatal=False) or {}\n    subtitles = {}\n    for sub in try_get(info, lambda x: x['data']['title']) or []:\n        url_sub = sub.get('url')\n        if not url_sub:\n            continue\n        locale = sub.get('captionSimpleName') or 'en'\n        sub = self._download_json(f'{domain}{url_sub}', video_id, fatal=False, note=f\"Download subtitle for locale {sub.get('name')} ({locale})\") or {}\n        sub_url = url_or_none(sub.get('info'))\n        if not sub_url:\n            continue\n        subtitles.setdefault(locale.lower(), []).append({'url': sub_url, 'name': sub.get('name'), 'ext': 'srt'})\n    return subtitles",
            "def _get_subtitles(self, video_id, domain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    info = self._download_json(f'https://pcweb.api.mgtv.com/video/title?videoId={video_id}', video_id, fatal=False) or {}\n    subtitles = {}\n    for sub in try_get(info, lambda x: x['data']['title']) or []:\n        url_sub = sub.get('url')\n        if not url_sub:\n            continue\n        locale = sub.get('captionSimpleName') or 'en'\n        sub = self._download_json(f'{domain}{url_sub}', video_id, fatal=False, note=f\"Download subtitle for locale {sub.get('name')} ({locale})\") or {}\n        sub_url = url_or_none(sub.get('info'))\n        if not sub_url:\n            continue\n        subtitles.setdefault(locale.lower(), []).append({'url': sub_url, 'name': sub.get('name'), 'ext': 'srt'})\n    return subtitles",
            "def _get_subtitles(self, video_id, domain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    info = self._download_json(f'https://pcweb.api.mgtv.com/video/title?videoId={video_id}', video_id, fatal=False) or {}\n    subtitles = {}\n    for sub in try_get(info, lambda x: x['data']['title']) or []:\n        url_sub = sub.get('url')\n        if not url_sub:\n            continue\n        locale = sub.get('captionSimpleName') or 'en'\n        sub = self._download_json(f'{domain}{url_sub}', video_id, fatal=False, note=f\"Download subtitle for locale {sub.get('name')} ({locale})\") or {}\n        sub_url = url_or_none(sub.get('info'))\n        if not sub_url:\n            continue\n        subtitles.setdefault(locale.lower(), []).append({'url': sub_url, 'name': sub.get('name'), 'ext': 'srt'})\n    return subtitles",
            "def _get_subtitles(self, video_id, domain):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    info = self._download_json(f'https://pcweb.api.mgtv.com/video/title?videoId={video_id}', video_id, fatal=False) or {}\n    subtitles = {}\n    for sub in try_get(info, lambda x: x['data']['title']) or []:\n        url_sub = sub.get('url')\n        if not url_sub:\n            continue\n        locale = sub.get('captionSimpleName') or 'en'\n        sub = self._download_json(f'{domain}{url_sub}', video_id, fatal=False, note=f\"Download subtitle for locale {sub.get('name')} ({locale})\") or {}\n        sub_url = url_or_none(sub.get('info'))\n        if not sub_url:\n            continue\n        subtitles.setdefault(locale.lower(), []).append({'url': sub_url, 'name': sub.get('name'), 'ext': 'srt'})\n    return subtitles"
        ]
    }
]