[
    {
        "func_name": "pade",
        "original": "def pade(an, m, n=None):\n    \"\"\"\n    Return Pade approximation to a polynomial as the ratio of two polynomials.\n\n    Parameters\n    ----------\n    an : (N,) array_like\n        Taylor series coefficients.\n    m : int\n        The order of the returned approximating polynomial `q`.\n    n : int, optional\n        The order of the returned approximating polynomial `p`. By default,\n        the order is ``len(an)-1-m``.\n\n    Returns\n    -------\n    p, q : Polynomial class\n        The Pade approximation of the polynomial defined by `an` is\n        ``p(x)/q(x)``.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from scipy.interpolate import pade\n    >>> e_exp = [1.0, 1.0, 1.0/2.0, 1.0/6.0, 1.0/24.0, 1.0/120.0]\n    >>> p, q = pade(e_exp, 2)\n\n    >>> e_exp.reverse()\n    >>> e_poly = np.poly1d(e_exp)\n\n    Compare ``e_poly(x)`` and the Pade approximation ``p(x)/q(x)``\n\n    >>> e_poly(1)\n    2.7166666666666668\n\n    >>> p(1)/q(1)\n    2.7179487179487181\n\n    \"\"\"\n    an = asarray(an)\n    if n is None:\n        n = len(an) - 1 - m\n        if n < 0:\n            raise ValueError('Order of q <m> must be smaller than len(an)-1.')\n    if n < 0:\n        raise ValueError('Order of p <n> must be greater than 0.')\n    N = m + n\n    if N > len(an) - 1:\n        raise ValueError('Order of q+p <m+n> must be smaller than len(an).')\n    an = an[:N + 1]\n    Akj = eye(N + 1, n + 1, dtype=an.dtype)\n    Bkj = zeros((N + 1, m), dtype=an.dtype)\n    for row in range(1, m + 1):\n        Bkj[row, :row] = -an[:row][::-1]\n    for row in range(m + 1, N + 1):\n        Bkj[row, :] = -an[row - m:row][::-1]\n    C = hstack((Akj, Bkj))\n    pq = linalg.solve(C, an)\n    p = pq[:n + 1]\n    q = r_[1.0, pq[n + 1:]]\n    return (poly1d(p[::-1]), poly1d(q[::-1]))",
        "mutated": [
            "def pade(an, m, n=None):\n    if False:\n        i = 10\n    '\\n    Return Pade approximation to a polynomial as the ratio of two polynomials.\\n\\n    Parameters\\n    ----------\\n    an : (N,) array_like\\n        Taylor series coefficients.\\n    m : int\\n        The order of the returned approximating polynomial `q`.\\n    n : int, optional\\n        The order of the returned approximating polynomial `p`. By default,\\n        the order is ``len(an)-1-m``.\\n\\n    Returns\\n    -------\\n    p, q : Polynomial class\\n        The Pade approximation of the polynomial defined by `an` is\\n        ``p(x)/q(x)``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.interpolate import pade\\n    >>> e_exp = [1.0, 1.0, 1.0/2.0, 1.0/6.0, 1.0/24.0, 1.0/120.0]\\n    >>> p, q = pade(e_exp, 2)\\n\\n    >>> e_exp.reverse()\\n    >>> e_poly = np.poly1d(e_exp)\\n\\n    Compare ``e_poly(x)`` and the Pade approximation ``p(x)/q(x)``\\n\\n    >>> e_poly(1)\\n    2.7166666666666668\\n\\n    >>> p(1)/q(1)\\n    2.7179487179487181\\n\\n    '\n    an = asarray(an)\n    if n is None:\n        n = len(an) - 1 - m\n        if n < 0:\n            raise ValueError('Order of q <m> must be smaller than len(an)-1.')\n    if n < 0:\n        raise ValueError('Order of p <n> must be greater than 0.')\n    N = m + n\n    if N > len(an) - 1:\n        raise ValueError('Order of q+p <m+n> must be smaller than len(an).')\n    an = an[:N + 1]\n    Akj = eye(N + 1, n + 1, dtype=an.dtype)\n    Bkj = zeros((N + 1, m), dtype=an.dtype)\n    for row in range(1, m + 1):\n        Bkj[row, :row] = -an[:row][::-1]\n    for row in range(m + 1, N + 1):\n        Bkj[row, :] = -an[row - m:row][::-1]\n    C = hstack((Akj, Bkj))\n    pq = linalg.solve(C, an)\n    p = pq[:n + 1]\n    q = r_[1.0, pq[n + 1:]]\n    return (poly1d(p[::-1]), poly1d(q[::-1]))",
            "def pade(an, m, n=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return Pade approximation to a polynomial as the ratio of two polynomials.\\n\\n    Parameters\\n    ----------\\n    an : (N,) array_like\\n        Taylor series coefficients.\\n    m : int\\n        The order of the returned approximating polynomial `q`.\\n    n : int, optional\\n        The order of the returned approximating polynomial `p`. By default,\\n        the order is ``len(an)-1-m``.\\n\\n    Returns\\n    -------\\n    p, q : Polynomial class\\n        The Pade approximation of the polynomial defined by `an` is\\n        ``p(x)/q(x)``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.interpolate import pade\\n    >>> e_exp = [1.0, 1.0, 1.0/2.0, 1.0/6.0, 1.0/24.0, 1.0/120.0]\\n    >>> p, q = pade(e_exp, 2)\\n\\n    >>> e_exp.reverse()\\n    >>> e_poly = np.poly1d(e_exp)\\n\\n    Compare ``e_poly(x)`` and the Pade approximation ``p(x)/q(x)``\\n\\n    >>> e_poly(1)\\n    2.7166666666666668\\n\\n    >>> p(1)/q(1)\\n    2.7179487179487181\\n\\n    '\n    an = asarray(an)\n    if n is None:\n        n = len(an) - 1 - m\n        if n < 0:\n            raise ValueError('Order of q <m> must be smaller than len(an)-1.')\n    if n < 0:\n        raise ValueError('Order of p <n> must be greater than 0.')\n    N = m + n\n    if N > len(an) - 1:\n        raise ValueError('Order of q+p <m+n> must be smaller than len(an).')\n    an = an[:N + 1]\n    Akj = eye(N + 1, n + 1, dtype=an.dtype)\n    Bkj = zeros((N + 1, m), dtype=an.dtype)\n    for row in range(1, m + 1):\n        Bkj[row, :row] = -an[:row][::-1]\n    for row in range(m + 1, N + 1):\n        Bkj[row, :] = -an[row - m:row][::-1]\n    C = hstack((Akj, Bkj))\n    pq = linalg.solve(C, an)\n    p = pq[:n + 1]\n    q = r_[1.0, pq[n + 1:]]\n    return (poly1d(p[::-1]), poly1d(q[::-1]))",
            "def pade(an, m, n=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return Pade approximation to a polynomial as the ratio of two polynomials.\\n\\n    Parameters\\n    ----------\\n    an : (N,) array_like\\n        Taylor series coefficients.\\n    m : int\\n        The order of the returned approximating polynomial `q`.\\n    n : int, optional\\n        The order of the returned approximating polynomial `p`. By default,\\n        the order is ``len(an)-1-m``.\\n\\n    Returns\\n    -------\\n    p, q : Polynomial class\\n        The Pade approximation of the polynomial defined by `an` is\\n        ``p(x)/q(x)``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.interpolate import pade\\n    >>> e_exp = [1.0, 1.0, 1.0/2.0, 1.0/6.0, 1.0/24.0, 1.0/120.0]\\n    >>> p, q = pade(e_exp, 2)\\n\\n    >>> e_exp.reverse()\\n    >>> e_poly = np.poly1d(e_exp)\\n\\n    Compare ``e_poly(x)`` and the Pade approximation ``p(x)/q(x)``\\n\\n    >>> e_poly(1)\\n    2.7166666666666668\\n\\n    >>> p(1)/q(1)\\n    2.7179487179487181\\n\\n    '\n    an = asarray(an)\n    if n is None:\n        n = len(an) - 1 - m\n        if n < 0:\n            raise ValueError('Order of q <m> must be smaller than len(an)-1.')\n    if n < 0:\n        raise ValueError('Order of p <n> must be greater than 0.')\n    N = m + n\n    if N > len(an) - 1:\n        raise ValueError('Order of q+p <m+n> must be smaller than len(an).')\n    an = an[:N + 1]\n    Akj = eye(N + 1, n + 1, dtype=an.dtype)\n    Bkj = zeros((N + 1, m), dtype=an.dtype)\n    for row in range(1, m + 1):\n        Bkj[row, :row] = -an[:row][::-1]\n    for row in range(m + 1, N + 1):\n        Bkj[row, :] = -an[row - m:row][::-1]\n    C = hstack((Akj, Bkj))\n    pq = linalg.solve(C, an)\n    p = pq[:n + 1]\n    q = r_[1.0, pq[n + 1:]]\n    return (poly1d(p[::-1]), poly1d(q[::-1]))",
            "def pade(an, m, n=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return Pade approximation to a polynomial as the ratio of two polynomials.\\n\\n    Parameters\\n    ----------\\n    an : (N,) array_like\\n        Taylor series coefficients.\\n    m : int\\n        The order of the returned approximating polynomial `q`.\\n    n : int, optional\\n        The order of the returned approximating polynomial `p`. By default,\\n        the order is ``len(an)-1-m``.\\n\\n    Returns\\n    -------\\n    p, q : Polynomial class\\n        The Pade approximation of the polynomial defined by `an` is\\n        ``p(x)/q(x)``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.interpolate import pade\\n    >>> e_exp = [1.0, 1.0, 1.0/2.0, 1.0/6.0, 1.0/24.0, 1.0/120.0]\\n    >>> p, q = pade(e_exp, 2)\\n\\n    >>> e_exp.reverse()\\n    >>> e_poly = np.poly1d(e_exp)\\n\\n    Compare ``e_poly(x)`` and the Pade approximation ``p(x)/q(x)``\\n\\n    >>> e_poly(1)\\n    2.7166666666666668\\n\\n    >>> p(1)/q(1)\\n    2.7179487179487181\\n\\n    '\n    an = asarray(an)\n    if n is None:\n        n = len(an) - 1 - m\n        if n < 0:\n            raise ValueError('Order of q <m> must be smaller than len(an)-1.')\n    if n < 0:\n        raise ValueError('Order of p <n> must be greater than 0.')\n    N = m + n\n    if N > len(an) - 1:\n        raise ValueError('Order of q+p <m+n> must be smaller than len(an).')\n    an = an[:N + 1]\n    Akj = eye(N + 1, n + 1, dtype=an.dtype)\n    Bkj = zeros((N + 1, m), dtype=an.dtype)\n    for row in range(1, m + 1):\n        Bkj[row, :row] = -an[:row][::-1]\n    for row in range(m + 1, N + 1):\n        Bkj[row, :] = -an[row - m:row][::-1]\n    C = hstack((Akj, Bkj))\n    pq = linalg.solve(C, an)\n    p = pq[:n + 1]\n    q = r_[1.0, pq[n + 1:]]\n    return (poly1d(p[::-1]), poly1d(q[::-1]))",
            "def pade(an, m, n=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return Pade approximation to a polynomial as the ratio of two polynomials.\\n\\n    Parameters\\n    ----------\\n    an : (N,) array_like\\n        Taylor series coefficients.\\n    m : int\\n        The order of the returned approximating polynomial `q`.\\n    n : int, optional\\n        The order of the returned approximating polynomial `p`. By default,\\n        the order is ``len(an)-1-m``.\\n\\n    Returns\\n    -------\\n    p, q : Polynomial class\\n        The Pade approximation of the polynomial defined by `an` is\\n        ``p(x)/q(x)``.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from scipy.interpolate import pade\\n    >>> e_exp = [1.0, 1.0, 1.0/2.0, 1.0/6.0, 1.0/24.0, 1.0/120.0]\\n    >>> p, q = pade(e_exp, 2)\\n\\n    >>> e_exp.reverse()\\n    >>> e_poly = np.poly1d(e_exp)\\n\\n    Compare ``e_poly(x)`` and the Pade approximation ``p(x)/q(x)``\\n\\n    >>> e_poly(1)\\n    2.7166666666666668\\n\\n    >>> p(1)/q(1)\\n    2.7179487179487181\\n\\n    '\n    an = asarray(an)\n    if n is None:\n        n = len(an) - 1 - m\n        if n < 0:\n            raise ValueError('Order of q <m> must be smaller than len(an)-1.')\n    if n < 0:\n        raise ValueError('Order of p <n> must be greater than 0.')\n    N = m + n\n    if N > len(an) - 1:\n        raise ValueError('Order of q+p <m+n> must be smaller than len(an).')\n    an = an[:N + 1]\n    Akj = eye(N + 1, n + 1, dtype=an.dtype)\n    Bkj = zeros((N + 1, m), dtype=an.dtype)\n    for row in range(1, m + 1):\n        Bkj[row, :row] = -an[:row][::-1]\n    for row in range(m + 1, N + 1):\n        Bkj[row, :] = -an[row - m:row][::-1]\n    C = hstack((Akj, Bkj))\n    pq = linalg.solve(C, an)\n    p = pq[:n + 1]\n    q = r_[1.0, pq[n + 1:]]\n    return (poly1d(p[::-1]), poly1d(q[::-1]))"
        ]
    }
]