[
    {
        "func_name": "factory",
        "original": "@kinded\ndef factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _FirstType, _UpdatedType]:\n    return container.modify_env(function)",
        "mutated": [
            "@kinded\ndef factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _FirstType, _UpdatedType]:\n    if False:\n        i = 10\n    return container.modify_env(function)",
            "@kinded\ndef factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _FirstType, _UpdatedType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return container.modify_env(function)",
            "@kinded\ndef factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _FirstType, _UpdatedType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return container.modify_env(function)",
            "@kinded\ndef factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _FirstType, _UpdatedType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return container.modify_env(function)",
            "@kinded\ndef factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _FirstType, _UpdatedType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return container.modify_env(function)"
        ]
    },
    {
        "func_name": "modify_env2",
        "original": "def modify_env2(function: Callable[[_UpdatedType], _SecondType]) -> Kinded[Callable[[Kind2[_Reader2Kind, _FirstType, _SecondType]], Kind2[_Reader2Kind, _FirstType, _UpdatedType]]]:\n    \"\"\"\n    Modifies the second type argument of a ``ReaderLike2``.\n\n    In other words, it modifies the function's\n    signature from:\n    ``a -> b``\n    to:\n    ``Container[x, a] -> Container[x, b]``\n\n    .. code:: python\n\n      >>> from returns.pointfree import modify_env2\n      >>> from returns.context import RequiresContext\n\n      >>> def multiply(arg: int) -> RequiresContext[int, int]:\n      ...     return RequiresContext(lambda deps: arg * deps)\n\n      >>> assert modify_env2(int)(multiply(3))('4') == 12\n\n    Note, that this function works with only ``Kind2`` containers\n    with ``.modify_env`` method.\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike2`\n    for more info.\n\n    \"\"\"\n\n    @kinded\n    def factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _FirstType, _UpdatedType]:\n        return container.modify_env(function)\n    return factory",
        "mutated": [
            "def modify_env2(function: Callable[[_UpdatedType], _SecondType]) -> Kinded[Callable[[Kind2[_Reader2Kind, _FirstType, _SecondType]], Kind2[_Reader2Kind, _FirstType, _UpdatedType]]]:\n    if False:\n        i = 10\n    \"\\n    Modifies the second type argument of a ``ReaderLike2``.\\n\\n    In other words, it modifies the function's\\n    signature from:\\n    ``a -> b``\\n    to:\\n    ``Container[x, a] -> Container[x, b]``\\n\\n    .. code:: python\\n\\n      >>> from returns.pointfree import modify_env2\\n      >>> from returns.context import RequiresContext\\n\\n      >>> def multiply(arg: int) -> RequiresContext[int, int]:\\n      ...     return RequiresContext(lambda deps: arg * deps)\\n\\n      >>> assert modify_env2(int)(multiply(3))('4') == 12\\n\\n    Note, that this function works with only ``Kind2`` containers\\n    with ``.modify_env`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike2`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _FirstType, _UpdatedType]:\n        return container.modify_env(function)\n    return factory",
            "def modify_env2(function: Callable[[_UpdatedType], _SecondType]) -> Kinded[Callable[[Kind2[_Reader2Kind, _FirstType, _SecondType]], Kind2[_Reader2Kind, _FirstType, _UpdatedType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Modifies the second type argument of a ``ReaderLike2``.\\n\\n    In other words, it modifies the function's\\n    signature from:\\n    ``a -> b``\\n    to:\\n    ``Container[x, a] -> Container[x, b]``\\n\\n    .. code:: python\\n\\n      >>> from returns.pointfree import modify_env2\\n      >>> from returns.context import RequiresContext\\n\\n      >>> def multiply(arg: int) -> RequiresContext[int, int]:\\n      ...     return RequiresContext(lambda deps: arg * deps)\\n\\n      >>> assert modify_env2(int)(multiply(3))('4') == 12\\n\\n    Note, that this function works with only ``Kind2`` containers\\n    with ``.modify_env`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike2`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _FirstType, _UpdatedType]:\n        return container.modify_env(function)\n    return factory",
            "def modify_env2(function: Callable[[_UpdatedType], _SecondType]) -> Kinded[Callable[[Kind2[_Reader2Kind, _FirstType, _SecondType]], Kind2[_Reader2Kind, _FirstType, _UpdatedType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Modifies the second type argument of a ``ReaderLike2``.\\n\\n    In other words, it modifies the function's\\n    signature from:\\n    ``a -> b``\\n    to:\\n    ``Container[x, a] -> Container[x, b]``\\n\\n    .. code:: python\\n\\n      >>> from returns.pointfree import modify_env2\\n      >>> from returns.context import RequiresContext\\n\\n      >>> def multiply(arg: int) -> RequiresContext[int, int]:\\n      ...     return RequiresContext(lambda deps: arg * deps)\\n\\n      >>> assert modify_env2(int)(multiply(3))('4') == 12\\n\\n    Note, that this function works with only ``Kind2`` containers\\n    with ``.modify_env`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike2`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _FirstType, _UpdatedType]:\n        return container.modify_env(function)\n    return factory",
            "def modify_env2(function: Callable[[_UpdatedType], _SecondType]) -> Kinded[Callable[[Kind2[_Reader2Kind, _FirstType, _SecondType]], Kind2[_Reader2Kind, _FirstType, _UpdatedType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Modifies the second type argument of a ``ReaderLike2``.\\n\\n    In other words, it modifies the function's\\n    signature from:\\n    ``a -> b``\\n    to:\\n    ``Container[x, a] -> Container[x, b]``\\n\\n    .. code:: python\\n\\n      >>> from returns.pointfree import modify_env2\\n      >>> from returns.context import RequiresContext\\n\\n      >>> def multiply(arg: int) -> RequiresContext[int, int]:\\n      ...     return RequiresContext(lambda deps: arg * deps)\\n\\n      >>> assert modify_env2(int)(multiply(3))('4') == 12\\n\\n    Note, that this function works with only ``Kind2`` containers\\n    with ``.modify_env`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike2`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _FirstType, _UpdatedType]:\n        return container.modify_env(function)\n    return factory",
            "def modify_env2(function: Callable[[_UpdatedType], _SecondType]) -> Kinded[Callable[[Kind2[_Reader2Kind, _FirstType, _SecondType]], Kind2[_Reader2Kind, _FirstType, _UpdatedType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Modifies the second type argument of a ``ReaderLike2``.\\n\\n    In other words, it modifies the function's\\n    signature from:\\n    ``a -> b``\\n    to:\\n    ``Container[x, a] -> Container[x, b]``\\n\\n    .. code:: python\\n\\n      >>> from returns.pointfree import modify_env2\\n      >>> from returns.context import RequiresContext\\n\\n      >>> def multiply(arg: int) -> RequiresContext[int, int]:\\n      ...     return RequiresContext(lambda deps: arg * deps)\\n\\n      >>> assert modify_env2(int)(multiply(3))('4') == 12\\n\\n    Note, that this function works with only ``Kind2`` containers\\n    with ``.modify_env`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike2`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _FirstType, _UpdatedType]:\n        return container.modify_env(function)\n    return factory"
        ]
    },
    {
        "func_name": "factory",
        "original": "@kinded\ndef factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]:\n    return container.modify_env(function)",
        "mutated": [
            "@kinded\ndef factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]:\n    if False:\n        i = 10\n    return container.modify_env(function)",
            "@kinded\ndef factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return container.modify_env(function)",
            "@kinded\ndef factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return container.modify_env(function)",
            "@kinded\ndef factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return container.modify_env(function)",
            "@kinded\ndef factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return container.modify_env(function)"
        ]
    },
    {
        "func_name": "modify_env3",
        "original": "def modify_env3(function: Callable[[_UpdatedType], _ThirdType]) -> Kinded[Callable[[Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]], Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]]]:\n    \"\"\"\n    Modifies the third type argument of a ``ReaderLike3``.\n\n    In other words, it modifies the function's\n    signature from: ``a -> b``\n    to: ``Container[x, a] -> Container[x, b]``\n\n    .. code:: python\n\n      >>> from returns.pointfree import modify_env\n      >>> from returns.context import RequiresContextResultE\n      >>> from returns.result import Success, safe\n\n      >>> def divide(arg: int) -> RequiresContextResultE[float, int]:\n      ...     return RequiresContextResultE(safe(lambda deps: arg / deps))\n\n      >>> assert modify_env(int)(divide(3))('2') == Success(1.5)\n      >>> assert modify_env(int)(divide(3))('0').failure()\n\n    Note, that this function works with only ``Kind3`` containers\n    with ``.modify_env`` method.\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike3`\n    for more info.\n\n    \"\"\"\n\n    @kinded\n    def factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]:\n        return container.modify_env(function)\n    return factory",
        "mutated": [
            "def modify_env3(function: Callable[[_UpdatedType], _ThirdType]) -> Kinded[Callable[[Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]], Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]]]:\n    if False:\n        i = 10\n    \"\\n    Modifies the third type argument of a ``ReaderLike3``.\\n\\n    In other words, it modifies the function's\\n    signature from: ``a -> b``\\n    to: ``Container[x, a] -> Container[x, b]``\\n\\n    .. code:: python\\n\\n      >>> from returns.pointfree import modify_env\\n      >>> from returns.context import RequiresContextResultE\\n      >>> from returns.result import Success, safe\\n\\n      >>> def divide(arg: int) -> RequiresContextResultE[float, int]:\\n      ...     return RequiresContextResultE(safe(lambda deps: arg / deps))\\n\\n      >>> assert modify_env(int)(divide(3))('2') == Success(1.5)\\n      >>> assert modify_env(int)(divide(3))('0').failure()\\n\\n    Note, that this function works with only ``Kind3`` containers\\n    with ``.modify_env`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike3`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]:\n        return container.modify_env(function)\n    return factory",
            "def modify_env3(function: Callable[[_UpdatedType], _ThirdType]) -> Kinded[Callable[[Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]], Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Modifies the third type argument of a ``ReaderLike3``.\\n\\n    In other words, it modifies the function's\\n    signature from: ``a -> b``\\n    to: ``Container[x, a] -> Container[x, b]``\\n\\n    .. code:: python\\n\\n      >>> from returns.pointfree import modify_env\\n      >>> from returns.context import RequiresContextResultE\\n      >>> from returns.result import Success, safe\\n\\n      >>> def divide(arg: int) -> RequiresContextResultE[float, int]:\\n      ...     return RequiresContextResultE(safe(lambda deps: arg / deps))\\n\\n      >>> assert modify_env(int)(divide(3))('2') == Success(1.5)\\n      >>> assert modify_env(int)(divide(3))('0').failure()\\n\\n    Note, that this function works with only ``Kind3`` containers\\n    with ``.modify_env`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike3`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]:\n        return container.modify_env(function)\n    return factory",
            "def modify_env3(function: Callable[[_UpdatedType], _ThirdType]) -> Kinded[Callable[[Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]], Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Modifies the third type argument of a ``ReaderLike3``.\\n\\n    In other words, it modifies the function's\\n    signature from: ``a -> b``\\n    to: ``Container[x, a] -> Container[x, b]``\\n\\n    .. code:: python\\n\\n      >>> from returns.pointfree import modify_env\\n      >>> from returns.context import RequiresContextResultE\\n      >>> from returns.result import Success, safe\\n\\n      >>> def divide(arg: int) -> RequiresContextResultE[float, int]:\\n      ...     return RequiresContextResultE(safe(lambda deps: arg / deps))\\n\\n      >>> assert modify_env(int)(divide(3))('2') == Success(1.5)\\n      >>> assert modify_env(int)(divide(3))('0').failure()\\n\\n    Note, that this function works with only ``Kind3`` containers\\n    with ``.modify_env`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike3`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]:\n        return container.modify_env(function)\n    return factory",
            "def modify_env3(function: Callable[[_UpdatedType], _ThirdType]) -> Kinded[Callable[[Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]], Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Modifies the third type argument of a ``ReaderLike3``.\\n\\n    In other words, it modifies the function's\\n    signature from: ``a -> b``\\n    to: ``Container[x, a] -> Container[x, b]``\\n\\n    .. code:: python\\n\\n      >>> from returns.pointfree import modify_env\\n      >>> from returns.context import RequiresContextResultE\\n      >>> from returns.result import Success, safe\\n\\n      >>> def divide(arg: int) -> RequiresContextResultE[float, int]:\\n      ...     return RequiresContextResultE(safe(lambda deps: arg / deps))\\n\\n      >>> assert modify_env(int)(divide(3))('2') == Success(1.5)\\n      >>> assert modify_env(int)(divide(3))('0').failure()\\n\\n    Note, that this function works with only ``Kind3`` containers\\n    with ``.modify_env`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike3`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]:\n        return container.modify_env(function)\n    return factory",
            "def modify_env3(function: Callable[[_UpdatedType], _ThirdType]) -> Kinded[Callable[[Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]], Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Modifies the third type argument of a ``ReaderLike3``.\\n\\n    In other words, it modifies the function's\\n    signature from: ``a -> b``\\n    to: ``Container[x, a] -> Container[x, b]``\\n\\n    .. code:: python\\n\\n      >>> from returns.pointfree import modify_env\\n      >>> from returns.context import RequiresContextResultE\\n      >>> from returns.result import Success, safe\\n\\n      >>> def divide(arg: int) -> RequiresContextResultE[float, int]:\\n      ...     return RequiresContextResultE(safe(lambda deps: arg / deps))\\n\\n      >>> assert modify_env(int)(divide(3))('2') == Success(1.5)\\n      >>> assert modify_env(int)(divide(3))('0').failure()\\n\\n    Note, that this function works with only ``Kind3`` containers\\n    with ``.modify_env`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike3`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _FirstType, _SecondType, _UpdatedType]:\n        return container.modify_env(function)\n    return factory"
        ]
    }
]