[
    {
        "func_name": "get_layer",
        "original": "def get_layer(layer):\n    \"\"\"Helper for getting layer output Tensor in model Graph.\n\n  Args:\n   layer: string, layer name\n\n  Returns:\n    Tensor for that layer.\n  \"\"\"\n    graph = tf.get_default_graph()\n    return graph.get_tensor_by_name('import/%s:0' % layer)",
        "mutated": [
            "def get_layer(layer):\n    if False:\n        i = 10\n    'Helper for getting layer output Tensor in model Graph.\\n\\n  Args:\\n   layer: string, layer name\\n\\n  Returns:\\n    Tensor for that layer.\\n  '\n    graph = tf.get_default_graph()\n    return graph.get_tensor_by_name('import/%s:0' % layer)",
            "def get_layer(layer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Helper for getting layer output Tensor in model Graph.\\n\\n  Args:\\n   layer: string, layer name\\n\\n  Returns:\\n    Tensor for that layer.\\n  '\n    graph = tf.get_default_graph()\n    return graph.get_tensor_by_name('import/%s:0' % layer)",
            "def get_layer(layer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Helper for getting layer output Tensor in model Graph.\\n\\n  Args:\\n   layer: string, layer name\\n\\n  Returns:\\n    Tensor for that layer.\\n  '\n    graph = tf.get_default_graph()\n    return graph.get_tensor_by_name('import/%s:0' % layer)",
            "def get_layer(layer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Helper for getting layer output Tensor in model Graph.\\n\\n  Args:\\n   layer: string, layer name\\n\\n  Returns:\\n    Tensor for that layer.\\n  '\n    graph = tf.get_default_graph()\n    return graph.get_tensor_by_name('import/%s:0' % layer)",
            "def get_layer(layer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Helper for getting layer output Tensor in model Graph.\\n\\n  Args:\\n   layer: string, layer name\\n\\n  Returns:\\n    Tensor for that layer.\\n  '\n    graph = tf.get_default_graph()\n    return graph.get_tensor_by_name('import/%s:0' % layer)"
        ]
    },
    {
        "func_name": "maybe_download",
        "original": "def maybe_download(data_dir):\n    \"\"\"Maybe download pretrained Inception network.\n\n  Args:\n    data_dir: string, path to data\n  \"\"\"\n    url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception5h.zip'\n    basename = 'inception5h.zip'\n    local_file = tf.contrib.learn.python.learn.datasets.base.maybe_download(basename, data_dir, url)\n    print('Extracting', local_file)\n    zip_ref = zipfile.ZipFile(local_file, 'r')\n    zip_ref.extractall(FLAGS.data_dir)\n    zip_ref.close()",
        "mutated": [
            "def maybe_download(data_dir):\n    if False:\n        i = 10\n    'Maybe download pretrained Inception network.\\n\\n  Args:\\n    data_dir: string, path to data\\n  '\n    url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception5h.zip'\n    basename = 'inception5h.zip'\n    local_file = tf.contrib.learn.python.learn.datasets.base.maybe_download(basename, data_dir, url)\n    print('Extracting', local_file)\n    zip_ref = zipfile.ZipFile(local_file, 'r')\n    zip_ref.extractall(FLAGS.data_dir)\n    zip_ref.close()",
            "def maybe_download(data_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Maybe download pretrained Inception network.\\n\\n  Args:\\n    data_dir: string, path to data\\n  '\n    url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception5h.zip'\n    basename = 'inception5h.zip'\n    local_file = tf.contrib.learn.python.learn.datasets.base.maybe_download(basename, data_dir, url)\n    print('Extracting', local_file)\n    zip_ref = zipfile.ZipFile(local_file, 'r')\n    zip_ref.extractall(FLAGS.data_dir)\n    zip_ref.close()",
            "def maybe_download(data_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Maybe download pretrained Inception network.\\n\\n  Args:\\n    data_dir: string, path to data\\n  '\n    url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception5h.zip'\n    basename = 'inception5h.zip'\n    local_file = tf.contrib.learn.python.learn.datasets.base.maybe_download(basename, data_dir, url)\n    print('Extracting', local_file)\n    zip_ref = zipfile.ZipFile(local_file, 'r')\n    zip_ref.extractall(FLAGS.data_dir)\n    zip_ref.close()",
            "def maybe_download(data_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Maybe download pretrained Inception network.\\n\\n  Args:\\n    data_dir: string, path to data\\n  '\n    url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception5h.zip'\n    basename = 'inception5h.zip'\n    local_file = tf.contrib.learn.python.learn.datasets.base.maybe_download(basename, data_dir, url)\n    print('Extracting', local_file)\n    zip_ref = zipfile.ZipFile(local_file, 'r')\n    zip_ref.extractall(FLAGS.data_dir)\n    zip_ref.close()",
            "def maybe_download(data_dir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Maybe download pretrained Inception network.\\n\\n  Args:\\n    data_dir: string, path to data\\n  '\n    url = 'https://storage.googleapis.com/download.tensorflow.org/models/inception5h.zip'\n    basename = 'inception5h.zip'\n    local_file = tf.contrib.learn.python.learn.datasets.base.maybe_download(basename, data_dir, url)\n    print('Extracting', local_file)\n    zip_ref = zipfile.ZipFile(local_file, 'r')\n    zip_ref.extractall(FLAGS.data_dir)\n    zip_ref.close()"
        ]
    },
    {
        "func_name": "normalize_image",
        "original": "def normalize_image(image):\n    \"\"\"Stretch the range and prepare the image for saving as a JPEG.\n\n  Args:\n    image: numpy array\n\n  Returns:\n    numpy array of image in uint8\n  \"\"\"\n    image = np.clip(image, 0, 1)\n    image = np.uint8(image * 255)\n    return image",
        "mutated": [
            "def normalize_image(image):\n    if False:\n        i = 10\n    'Stretch the range and prepare the image for saving as a JPEG.\\n\\n  Args:\\n    image: numpy array\\n\\n  Returns:\\n    numpy array of image in uint8\\n  '\n    image = np.clip(image, 0, 1)\n    image = np.uint8(image * 255)\n    return image",
            "def normalize_image(image):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Stretch the range and prepare the image for saving as a JPEG.\\n\\n  Args:\\n    image: numpy array\\n\\n  Returns:\\n    numpy array of image in uint8\\n  '\n    image = np.clip(image, 0, 1)\n    image = np.uint8(image * 255)\n    return image",
            "def normalize_image(image):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Stretch the range and prepare the image for saving as a JPEG.\\n\\n  Args:\\n    image: numpy array\\n\\n  Returns:\\n    numpy array of image in uint8\\n  '\n    image = np.clip(image, 0, 1)\n    image = np.uint8(image * 255)\n    return image",
            "def normalize_image(image):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Stretch the range and prepare the image for saving as a JPEG.\\n\\n  Args:\\n    image: numpy array\\n\\n  Returns:\\n    numpy array of image in uint8\\n  '\n    image = np.clip(image, 0, 1)\n    image = np.uint8(image * 255)\n    return image",
            "def normalize_image(image):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Stretch the range and prepare the image for saving as a JPEG.\\n\\n  Args:\\n    image: numpy array\\n\\n  Returns:\\n    numpy array of image in uint8\\n  '\n    image = np.clip(image, 0, 1)\n    image = np.uint8(image * 255)\n    return image"
        ]
    },
    {
        "func_name": "save_jpeg",
        "original": "def save_jpeg(jpeg_file, image):\n    pil_image = PIL.Image.fromarray(image)\n    pil_image.save(jpeg_file)\n    print('Saved to file: ', jpeg_file)",
        "mutated": [
            "def save_jpeg(jpeg_file, image):\n    if False:\n        i = 10\n    pil_image = PIL.Image.fromarray(image)\n    pil_image.save(jpeg_file)\n    print('Saved to file: ', jpeg_file)",
            "def save_jpeg(jpeg_file, image):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pil_image = PIL.Image.fromarray(image)\n    pil_image.save(jpeg_file)\n    print('Saved to file: ', jpeg_file)",
            "def save_jpeg(jpeg_file, image):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pil_image = PIL.Image.fromarray(image)\n    pil_image.save(jpeg_file)\n    print('Saved to file: ', jpeg_file)",
            "def save_jpeg(jpeg_file, image):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pil_image = PIL.Image.fromarray(image)\n    pil_image.save(jpeg_file)\n    print('Saved to file: ', jpeg_file)",
            "def save_jpeg(jpeg_file, image):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pil_image = PIL.Image.fromarray(image)\n    pil_image.save(jpeg_file)\n    print('Saved to file: ', jpeg_file)"
        ]
    },
    {
        "func_name": "main",
        "original": "def main(unused_argv):\n    maybe_download(FLAGS.data_dir)\n    model_fn = os.path.join(FLAGS.data_dir, 'tensorflow_inception_graph.pb')\n    with tf.gfile.FastGFile(model_fn, 'rb') as f:\n        graph_def = tf.GraphDef()\n        graph_def.ParseFromString(f.read())\n    with tf.Graph().as_default():\n        input_image = tf.placeholder(np.float32, name='input')\n        pixel_mean = 117.0\n        input_preprocessed = tf.expand_dims(input_image - pixel_mean, 0)\n        tf.import_graph_def(graph_def, {'input': input_preprocessed})\n        graph = tf.get_default_graph()\n        layers = [op.name for op in graph.get_operations() if op.type == 'Conv2D' and 'import/' in op.name]\n        feature_nums = [int(graph.get_tensor_by_name(name + ':0').get_shape()[-1]) for name in layers]\n        print('Number of layers', len(layers))\n        print('Number of features:', sum(feature_nums))\n        layer = 'mixed4d_3x3_bottleneck_pre_relu'\n        channel = 139\n        layer_channel = get_layer(layer)[:, :, :, channel]\n        print('layer %s, channel %d: %s' % (layer, channel, layer_channel))\n        score = tf.reduce_mean(layer_channel)\n        input_gradient = tf.gradients(score, input_image)[0]\n        noise_image = np.random.uniform(size=(224, 224, 3)) + 100.0\n        image = noise_image.copy()\n    stddev = 0.1\n    image = (image - image.mean()) / max(image.std(), 0.0001) * stddev + 0.5\n    image = normalize_image(image)\n    save_jpeg(FLAGS.jpeg_file, image)",
        "mutated": [
            "def main(unused_argv):\n    if False:\n        i = 10\n    maybe_download(FLAGS.data_dir)\n    model_fn = os.path.join(FLAGS.data_dir, 'tensorflow_inception_graph.pb')\n    with tf.gfile.FastGFile(model_fn, 'rb') as f:\n        graph_def = tf.GraphDef()\n        graph_def.ParseFromString(f.read())\n    with tf.Graph().as_default():\n        input_image = tf.placeholder(np.float32, name='input')\n        pixel_mean = 117.0\n        input_preprocessed = tf.expand_dims(input_image - pixel_mean, 0)\n        tf.import_graph_def(graph_def, {'input': input_preprocessed})\n        graph = tf.get_default_graph()\n        layers = [op.name for op in graph.get_operations() if op.type == 'Conv2D' and 'import/' in op.name]\n        feature_nums = [int(graph.get_tensor_by_name(name + ':0').get_shape()[-1]) for name in layers]\n        print('Number of layers', len(layers))\n        print('Number of features:', sum(feature_nums))\n        layer = 'mixed4d_3x3_bottleneck_pre_relu'\n        channel = 139\n        layer_channel = get_layer(layer)[:, :, :, channel]\n        print('layer %s, channel %d: %s' % (layer, channel, layer_channel))\n        score = tf.reduce_mean(layer_channel)\n        input_gradient = tf.gradients(score, input_image)[0]\n        noise_image = np.random.uniform(size=(224, 224, 3)) + 100.0\n        image = noise_image.copy()\n    stddev = 0.1\n    image = (image - image.mean()) / max(image.std(), 0.0001) * stddev + 0.5\n    image = normalize_image(image)\n    save_jpeg(FLAGS.jpeg_file, image)",
            "def main(unused_argv):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    maybe_download(FLAGS.data_dir)\n    model_fn = os.path.join(FLAGS.data_dir, 'tensorflow_inception_graph.pb')\n    with tf.gfile.FastGFile(model_fn, 'rb') as f:\n        graph_def = tf.GraphDef()\n        graph_def.ParseFromString(f.read())\n    with tf.Graph().as_default():\n        input_image = tf.placeholder(np.float32, name='input')\n        pixel_mean = 117.0\n        input_preprocessed = tf.expand_dims(input_image - pixel_mean, 0)\n        tf.import_graph_def(graph_def, {'input': input_preprocessed})\n        graph = tf.get_default_graph()\n        layers = [op.name for op in graph.get_operations() if op.type == 'Conv2D' and 'import/' in op.name]\n        feature_nums = [int(graph.get_tensor_by_name(name + ':0').get_shape()[-1]) for name in layers]\n        print('Number of layers', len(layers))\n        print('Number of features:', sum(feature_nums))\n        layer = 'mixed4d_3x3_bottleneck_pre_relu'\n        channel = 139\n        layer_channel = get_layer(layer)[:, :, :, channel]\n        print('layer %s, channel %d: %s' % (layer, channel, layer_channel))\n        score = tf.reduce_mean(layer_channel)\n        input_gradient = tf.gradients(score, input_image)[0]\n        noise_image = np.random.uniform(size=(224, 224, 3)) + 100.0\n        image = noise_image.copy()\n    stddev = 0.1\n    image = (image - image.mean()) / max(image.std(), 0.0001) * stddev + 0.5\n    image = normalize_image(image)\n    save_jpeg(FLAGS.jpeg_file, image)",
            "def main(unused_argv):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    maybe_download(FLAGS.data_dir)\n    model_fn = os.path.join(FLAGS.data_dir, 'tensorflow_inception_graph.pb')\n    with tf.gfile.FastGFile(model_fn, 'rb') as f:\n        graph_def = tf.GraphDef()\n        graph_def.ParseFromString(f.read())\n    with tf.Graph().as_default():\n        input_image = tf.placeholder(np.float32, name='input')\n        pixel_mean = 117.0\n        input_preprocessed = tf.expand_dims(input_image - pixel_mean, 0)\n        tf.import_graph_def(graph_def, {'input': input_preprocessed})\n        graph = tf.get_default_graph()\n        layers = [op.name for op in graph.get_operations() if op.type == 'Conv2D' and 'import/' in op.name]\n        feature_nums = [int(graph.get_tensor_by_name(name + ':0').get_shape()[-1]) for name in layers]\n        print('Number of layers', len(layers))\n        print('Number of features:', sum(feature_nums))\n        layer = 'mixed4d_3x3_bottleneck_pre_relu'\n        channel = 139\n        layer_channel = get_layer(layer)[:, :, :, channel]\n        print('layer %s, channel %d: %s' % (layer, channel, layer_channel))\n        score = tf.reduce_mean(layer_channel)\n        input_gradient = tf.gradients(score, input_image)[0]\n        noise_image = np.random.uniform(size=(224, 224, 3)) + 100.0\n        image = noise_image.copy()\n    stddev = 0.1\n    image = (image - image.mean()) / max(image.std(), 0.0001) * stddev + 0.5\n    image = normalize_image(image)\n    save_jpeg(FLAGS.jpeg_file, image)",
            "def main(unused_argv):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    maybe_download(FLAGS.data_dir)\n    model_fn = os.path.join(FLAGS.data_dir, 'tensorflow_inception_graph.pb')\n    with tf.gfile.FastGFile(model_fn, 'rb') as f:\n        graph_def = tf.GraphDef()\n        graph_def.ParseFromString(f.read())\n    with tf.Graph().as_default():\n        input_image = tf.placeholder(np.float32, name='input')\n        pixel_mean = 117.0\n        input_preprocessed = tf.expand_dims(input_image - pixel_mean, 0)\n        tf.import_graph_def(graph_def, {'input': input_preprocessed})\n        graph = tf.get_default_graph()\n        layers = [op.name for op in graph.get_operations() if op.type == 'Conv2D' and 'import/' in op.name]\n        feature_nums = [int(graph.get_tensor_by_name(name + ':0').get_shape()[-1]) for name in layers]\n        print('Number of layers', len(layers))\n        print('Number of features:', sum(feature_nums))\n        layer = 'mixed4d_3x3_bottleneck_pre_relu'\n        channel = 139\n        layer_channel = get_layer(layer)[:, :, :, channel]\n        print('layer %s, channel %d: %s' % (layer, channel, layer_channel))\n        score = tf.reduce_mean(layer_channel)\n        input_gradient = tf.gradients(score, input_image)[0]\n        noise_image = np.random.uniform(size=(224, 224, 3)) + 100.0\n        image = noise_image.copy()\n    stddev = 0.1\n    image = (image - image.mean()) / max(image.std(), 0.0001) * stddev + 0.5\n    image = normalize_image(image)\n    save_jpeg(FLAGS.jpeg_file, image)",
            "def main(unused_argv):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    maybe_download(FLAGS.data_dir)\n    model_fn = os.path.join(FLAGS.data_dir, 'tensorflow_inception_graph.pb')\n    with tf.gfile.FastGFile(model_fn, 'rb') as f:\n        graph_def = tf.GraphDef()\n        graph_def.ParseFromString(f.read())\n    with tf.Graph().as_default():\n        input_image = tf.placeholder(np.float32, name='input')\n        pixel_mean = 117.0\n        input_preprocessed = tf.expand_dims(input_image - pixel_mean, 0)\n        tf.import_graph_def(graph_def, {'input': input_preprocessed})\n        graph = tf.get_default_graph()\n        layers = [op.name for op in graph.get_operations() if op.type == 'Conv2D' and 'import/' in op.name]\n        feature_nums = [int(graph.get_tensor_by_name(name + ':0').get_shape()[-1]) for name in layers]\n        print('Number of layers', len(layers))\n        print('Number of features:', sum(feature_nums))\n        layer = 'mixed4d_3x3_bottleneck_pre_relu'\n        channel = 139\n        layer_channel = get_layer(layer)[:, :, :, channel]\n        print('layer %s, channel %d: %s' % (layer, channel, layer_channel))\n        score = tf.reduce_mean(layer_channel)\n        input_gradient = tf.gradients(score, input_image)[0]\n        noise_image = np.random.uniform(size=(224, 224, 3)) + 100.0\n        image = noise_image.copy()\n    stddev = 0.1\n    image = (image - image.mean()) / max(image.std(), 0.0001) * stddev + 0.5\n    image = normalize_image(image)\n    save_jpeg(FLAGS.jpeg_file, image)"
        ]
    }
]