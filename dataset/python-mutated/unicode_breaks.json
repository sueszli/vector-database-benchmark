[
    {
        "func_name": "where",
        "original": "def where():\n    nonlocal groups\n    if any(groups):\n        print('\\n'.join((g for g in groups if g)))\n    groups = [None, None]",
        "mutated": [
            "def where():\n    if False:\n        i = 10\n    nonlocal groups\n    if any(groups):\n        print('\\n'.join((g for g in groups if g)))\n    groups = [None, None]",
            "def where():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nonlocal groups\n    if any(groups):\n        print('\\n'.join((g for g in groups if g)))\n    groups = [None, None]",
            "def where():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nonlocal groups\n    if any(groups):\n        print('\\n'.join((g for g in groups if g)))\n    groups = [None, None]",
            "def where():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nonlocal groups\n    if any(groups):\n        print('\\n'.join((g for g in groups if g)))\n    groups = [None, None]",
            "def where():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nonlocal groups\n    if any(groups):\n        print('\\n'.join((g for g in groups if g)))\n    groups = [None, None]"
        ]
    },
    {
        "func_name": "expect",
        "original": "def expect(*chars):\n    nonlocal errors, total\n    text = ''.join(chars)\n    actual = split_graphemes(text)\n    error = actual != chars\n    total += 1\n    errors += error\n    if error or show_all:\n        where()\n        codes = '|'.join(((GREEN if a == c else RED)(' '.join((hex(ord(c)).replace('0x', '') for c in a)) if a else '-') for (a, c) in zip_longest(actual, chars)))\n        small_name = name.replace(' skin tone', '').replace(' hair', '')\n        small_status = ''.join((x[0] for x in status.split('-')))\n        (a_len, c_len) = (len(actual), len(chars))\n        size = f'{GREEN(a_len)} ==' if a_len == c_len else f'{RED(a_len)} !='\n        print(f\" {char}   {text.replace(char, 'X'):>3}: {size} {c_len} -> |{codes}| {ORANGE(small_status)} {small_name}\")",
        "mutated": [
            "def expect(*chars):\n    if False:\n        i = 10\n    nonlocal errors, total\n    text = ''.join(chars)\n    actual = split_graphemes(text)\n    error = actual != chars\n    total += 1\n    errors += error\n    if error or show_all:\n        where()\n        codes = '|'.join(((GREEN if a == c else RED)(' '.join((hex(ord(c)).replace('0x', '') for c in a)) if a else '-') for (a, c) in zip_longest(actual, chars)))\n        small_name = name.replace(' skin tone', '').replace(' hair', '')\n        small_status = ''.join((x[0] for x in status.split('-')))\n        (a_len, c_len) = (len(actual), len(chars))\n        size = f'{GREEN(a_len)} ==' if a_len == c_len else f'{RED(a_len)} !='\n        print(f\" {char}   {text.replace(char, 'X'):>3}: {size} {c_len} -> |{codes}| {ORANGE(small_status)} {small_name}\")",
            "def expect(*chars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nonlocal errors, total\n    text = ''.join(chars)\n    actual = split_graphemes(text)\n    error = actual != chars\n    total += 1\n    errors += error\n    if error or show_all:\n        where()\n        codes = '|'.join(((GREEN if a == c else RED)(' '.join((hex(ord(c)).replace('0x', '') for c in a)) if a else '-') for (a, c) in zip_longest(actual, chars)))\n        small_name = name.replace(' skin tone', '').replace(' hair', '')\n        small_status = ''.join((x[0] for x in status.split('-')))\n        (a_len, c_len) = (len(actual), len(chars))\n        size = f'{GREEN(a_len)} ==' if a_len == c_len else f'{RED(a_len)} !='\n        print(f\" {char}   {text.replace(char, 'X'):>3}: {size} {c_len} -> |{codes}| {ORANGE(small_status)} {small_name}\")",
            "def expect(*chars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nonlocal errors, total\n    text = ''.join(chars)\n    actual = split_graphemes(text)\n    error = actual != chars\n    total += 1\n    errors += error\n    if error or show_all:\n        where()\n        codes = '|'.join(((GREEN if a == c else RED)(' '.join((hex(ord(c)).replace('0x', '') for c in a)) if a else '-') for (a, c) in zip_longest(actual, chars)))\n        small_name = name.replace(' skin tone', '').replace(' hair', '')\n        small_status = ''.join((x[0] for x in status.split('-')))\n        (a_len, c_len) = (len(actual), len(chars))\n        size = f'{GREEN(a_len)} ==' if a_len == c_len else f'{RED(a_len)} !='\n        print(f\" {char}   {text.replace(char, 'X'):>3}: {size} {c_len} -> |{codes}| {ORANGE(small_status)} {small_name}\")",
            "def expect(*chars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nonlocal errors, total\n    text = ''.join(chars)\n    actual = split_graphemes(text)\n    error = actual != chars\n    total += 1\n    errors += error\n    if error or show_all:\n        where()\n        codes = '|'.join(((GREEN if a == c else RED)(' '.join((hex(ord(c)).replace('0x', '') for c in a)) if a else '-') for (a, c) in zip_longest(actual, chars)))\n        small_name = name.replace(' skin tone', '').replace(' hair', '')\n        small_status = ''.join((x[0] for x in status.split('-')))\n        (a_len, c_len) = (len(actual), len(chars))\n        size = f'{GREEN(a_len)} ==' if a_len == c_len else f'{RED(a_len)} !='\n        print(f\" {char}   {text.replace(char, 'X'):>3}: {size} {c_len} -> |{codes}| {ORANGE(small_status)} {small_name}\")",
            "def expect(*chars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nonlocal errors, total\n    text = ''.join(chars)\n    actual = split_graphemes(text)\n    error = actual != chars\n    total += 1\n    errors += error\n    if error or show_all:\n        where()\n        codes = '|'.join(((GREEN if a == c else RED)(' '.join((hex(ord(c)).replace('0x', '') for c in a)) if a else '-') for (a, c) in zip_longest(actual, chars)))\n        small_name = name.replace(' skin tone', '').replace(' hair', '')\n        small_status = ''.join((x[0] for x in status.split('-')))\n        (a_len, c_len) = (len(actual), len(chars))\n        size = f'{GREEN(a_len)} ==' if a_len == c_len else f'{RED(a_len)} !='\n        print(f\" {char}   {text.replace(char, 'X'):>3}: {size} {c_len} -> |{codes}| {ORANGE(small_status)} {small_name}\")"
        ]
    },
    {
        "func_name": "validate_unicode_breaks",
        "original": "def validate_unicode_breaks(uver=None, show_all=False, cache=True):\n    latest = f'{CACHE}/latest'\n    if not uver and cache and os.path.exists(latest):\n        with open(latest) as f:\n            uver = f.read()\n        print('using version \"latest\" as:', uver)\n    file = f'{CACHE}/emoji-test_{uver}.txt'\n    if cache and os.path.exists(file):\n        print('loading cached:', file)\n        with open(file) as f:\n            data = f.read()\n    else:\n        url = f\"https://www.unicode.org/Public/emoji/{uver or 'latest'}/emoji-test.txt\"\n        print('downloading:', url)\n        try:\n            req = urllib.request.urlopen(url)\n        except OSError as e:\n            print(RED('Download error:'), e)\n            return\n        os.makedirs(os.path.dirname(file), exist_ok=True)\n        if not uver:\n            new_url = req.geturl()\n            uver = new_url.split('/')[5]\n            print('saving version \"latest\" as:', uver)\n            with open(latest, 'w') as f:\n                f.write(uver)\n            file = f'{CACHE}/emoji-test_{uver}.txt'\n        print('saving:', file)\n        data = req.read().decode('utf8')\n        with open(file, 'w') as f:\n            f.write(data)\n\n    def where():\n        nonlocal groups\n        if any(groups):\n            print('\\n'.join((g for g in groups if g)))\n        groups = [None, None]\n\n    def expect(*chars):\n        nonlocal errors, total\n        text = ''.join(chars)\n        actual = split_graphemes(text)\n        error = actual != chars\n        total += 1\n        errors += error\n        if error or show_all:\n            where()\n            codes = '|'.join(((GREEN if a == c else RED)(' '.join((hex(ord(c)).replace('0x', '') for c in a)) if a else '-') for (a, c) in zip_longest(actual, chars)))\n            small_name = name.replace(' skin tone', '').replace(' hair', '')\n            small_status = ''.join((x[0] for x in status.split('-')))\n            (a_len, c_len) = (len(actual), len(chars))\n            size = f'{GREEN(a_len)} ==' if a_len == c_len else f'{RED(a_len)} !='\n            print(f\" {char}   {text.replace(char, 'X'):>3}: {size} {c_len} -> |{codes}| {ORANGE(small_status)} {small_name}\")\n    (groups, total, errors) = ([None, None], 0, 0)\n    for line in filter(None, data.splitlines()):\n        if line.startswith('#'):\n            if line.startswith('# group:'):\n                groups[0] = line.split()[-1]\n            elif line.startswith('# subgroup:'):\n                groups[1] = f'  - {line.split()[-1]}'\n            continue\n        (p1, p2) = (p.split() for p in line.split(';'))\n        (status, name) = (p2[0], ' '.join(p2[4:]))\n        char = ''.join((chr(int(x, 16)) for x in p1))\n        expect(char)\n        expect(char, char)\n        expect('a', char, 'a')\n        expect('a', 'a', char)\n        expect(char, 'a', 'a')\n    print(f'\\nerrors   : {errors / total:6.2%} [{errors}/{total}]')\n    print(f'successes: {1 - errors / total:6.2%} [{total - errors}/{total}]')",
        "mutated": [
            "def validate_unicode_breaks(uver=None, show_all=False, cache=True):\n    if False:\n        i = 10\n    latest = f'{CACHE}/latest'\n    if not uver and cache and os.path.exists(latest):\n        with open(latest) as f:\n            uver = f.read()\n        print('using version \"latest\" as:', uver)\n    file = f'{CACHE}/emoji-test_{uver}.txt'\n    if cache and os.path.exists(file):\n        print('loading cached:', file)\n        with open(file) as f:\n            data = f.read()\n    else:\n        url = f\"https://www.unicode.org/Public/emoji/{uver or 'latest'}/emoji-test.txt\"\n        print('downloading:', url)\n        try:\n            req = urllib.request.urlopen(url)\n        except OSError as e:\n            print(RED('Download error:'), e)\n            return\n        os.makedirs(os.path.dirname(file), exist_ok=True)\n        if not uver:\n            new_url = req.geturl()\n            uver = new_url.split('/')[5]\n            print('saving version \"latest\" as:', uver)\n            with open(latest, 'w') as f:\n                f.write(uver)\n            file = f'{CACHE}/emoji-test_{uver}.txt'\n        print('saving:', file)\n        data = req.read().decode('utf8')\n        with open(file, 'w') as f:\n            f.write(data)\n\n    def where():\n        nonlocal groups\n        if any(groups):\n            print('\\n'.join((g for g in groups if g)))\n        groups = [None, None]\n\n    def expect(*chars):\n        nonlocal errors, total\n        text = ''.join(chars)\n        actual = split_graphemes(text)\n        error = actual != chars\n        total += 1\n        errors += error\n        if error or show_all:\n            where()\n            codes = '|'.join(((GREEN if a == c else RED)(' '.join((hex(ord(c)).replace('0x', '') for c in a)) if a else '-') for (a, c) in zip_longest(actual, chars)))\n            small_name = name.replace(' skin tone', '').replace(' hair', '')\n            small_status = ''.join((x[0] for x in status.split('-')))\n            (a_len, c_len) = (len(actual), len(chars))\n            size = f'{GREEN(a_len)} ==' if a_len == c_len else f'{RED(a_len)} !='\n            print(f\" {char}   {text.replace(char, 'X'):>3}: {size} {c_len} -> |{codes}| {ORANGE(small_status)} {small_name}\")\n    (groups, total, errors) = ([None, None], 0, 0)\n    for line in filter(None, data.splitlines()):\n        if line.startswith('#'):\n            if line.startswith('# group:'):\n                groups[0] = line.split()[-1]\n            elif line.startswith('# subgroup:'):\n                groups[1] = f'  - {line.split()[-1]}'\n            continue\n        (p1, p2) = (p.split() for p in line.split(';'))\n        (status, name) = (p2[0], ' '.join(p2[4:]))\n        char = ''.join((chr(int(x, 16)) for x in p1))\n        expect(char)\n        expect(char, char)\n        expect('a', char, 'a')\n        expect('a', 'a', char)\n        expect(char, 'a', 'a')\n    print(f'\\nerrors   : {errors / total:6.2%} [{errors}/{total}]')\n    print(f'successes: {1 - errors / total:6.2%} [{total - errors}/{total}]')",
            "def validate_unicode_breaks(uver=None, show_all=False, cache=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    latest = f'{CACHE}/latest'\n    if not uver and cache and os.path.exists(latest):\n        with open(latest) as f:\n            uver = f.read()\n        print('using version \"latest\" as:', uver)\n    file = f'{CACHE}/emoji-test_{uver}.txt'\n    if cache and os.path.exists(file):\n        print('loading cached:', file)\n        with open(file) as f:\n            data = f.read()\n    else:\n        url = f\"https://www.unicode.org/Public/emoji/{uver or 'latest'}/emoji-test.txt\"\n        print('downloading:', url)\n        try:\n            req = urllib.request.urlopen(url)\n        except OSError as e:\n            print(RED('Download error:'), e)\n            return\n        os.makedirs(os.path.dirname(file), exist_ok=True)\n        if not uver:\n            new_url = req.geturl()\n            uver = new_url.split('/')[5]\n            print('saving version \"latest\" as:', uver)\n            with open(latest, 'w') as f:\n                f.write(uver)\n            file = f'{CACHE}/emoji-test_{uver}.txt'\n        print('saving:', file)\n        data = req.read().decode('utf8')\n        with open(file, 'w') as f:\n            f.write(data)\n\n    def where():\n        nonlocal groups\n        if any(groups):\n            print('\\n'.join((g for g in groups if g)))\n        groups = [None, None]\n\n    def expect(*chars):\n        nonlocal errors, total\n        text = ''.join(chars)\n        actual = split_graphemes(text)\n        error = actual != chars\n        total += 1\n        errors += error\n        if error or show_all:\n            where()\n            codes = '|'.join(((GREEN if a == c else RED)(' '.join((hex(ord(c)).replace('0x', '') for c in a)) if a else '-') for (a, c) in zip_longest(actual, chars)))\n            small_name = name.replace(' skin tone', '').replace(' hair', '')\n            small_status = ''.join((x[0] for x in status.split('-')))\n            (a_len, c_len) = (len(actual), len(chars))\n            size = f'{GREEN(a_len)} ==' if a_len == c_len else f'{RED(a_len)} !='\n            print(f\" {char}   {text.replace(char, 'X'):>3}: {size} {c_len} -> |{codes}| {ORANGE(small_status)} {small_name}\")\n    (groups, total, errors) = ([None, None], 0, 0)\n    for line in filter(None, data.splitlines()):\n        if line.startswith('#'):\n            if line.startswith('# group:'):\n                groups[0] = line.split()[-1]\n            elif line.startswith('# subgroup:'):\n                groups[1] = f'  - {line.split()[-1]}'\n            continue\n        (p1, p2) = (p.split() for p in line.split(';'))\n        (status, name) = (p2[0], ' '.join(p2[4:]))\n        char = ''.join((chr(int(x, 16)) for x in p1))\n        expect(char)\n        expect(char, char)\n        expect('a', char, 'a')\n        expect('a', 'a', char)\n        expect(char, 'a', 'a')\n    print(f'\\nerrors   : {errors / total:6.2%} [{errors}/{total}]')\n    print(f'successes: {1 - errors / total:6.2%} [{total - errors}/{total}]')",
            "def validate_unicode_breaks(uver=None, show_all=False, cache=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    latest = f'{CACHE}/latest'\n    if not uver and cache and os.path.exists(latest):\n        with open(latest) as f:\n            uver = f.read()\n        print('using version \"latest\" as:', uver)\n    file = f'{CACHE}/emoji-test_{uver}.txt'\n    if cache and os.path.exists(file):\n        print('loading cached:', file)\n        with open(file) as f:\n            data = f.read()\n    else:\n        url = f\"https://www.unicode.org/Public/emoji/{uver or 'latest'}/emoji-test.txt\"\n        print('downloading:', url)\n        try:\n            req = urllib.request.urlopen(url)\n        except OSError as e:\n            print(RED('Download error:'), e)\n            return\n        os.makedirs(os.path.dirname(file), exist_ok=True)\n        if not uver:\n            new_url = req.geturl()\n            uver = new_url.split('/')[5]\n            print('saving version \"latest\" as:', uver)\n            with open(latest, 'w') as f:\n                f.write(uver)\n            file = f'{CACHE}/emoji-test_{uver}.txt'\n        print('saving:', file)\n        data = req.read().decode('utf8')\n        with open(file, 'w') as f:\n            f.write(data)\n\n    def where():\n        nonlocal groups\n        if any(groups):\n            print('\\n'.join((g for g in groups if g)))\n        groups = [None, None]\n\n    def expect(*chars):\n        nonlocal errors, total\n        text = ''.join(chars)\n        actual = split_graphemes(text)\n        error = actual != chars\n        total += 1\n        errors += error\n        if error or show_all:\n            where()\n            codes = '|'.join(((GREEN if a == c else RED)(' '.join((hex(ord(c)).replace('0x', '') for c in a)) if a else '-') for (a, c) in zip_longest(actual, chars)))\n            small_name = name.replace(' skin tone', '').replace(' hair', '')\n            small_status = ''.join((x[0] for x in status.split('-')))\n            (a_len, c_len) = (len(actual), len(chars))\n            size = f'{GREEN(a_len)} ==' if a_len == c_len else f'{RED(a_len)} !='\n            print(f\" {char}   {text.replace(char, 'X'):>3}: {size} {c_len} -> |{codes}| {ORANGE(small_status)} {small_name}\")\n    (groups, total, errors) = ([None, None], 0, 0)\n    for line in filter(None, data.splitlines()):\n        if line.startswith('#'):\n            if line.startswith('# group:'):\n                groups[0] = line.split()[-1]\n            elif line.startswith('# subgroup:'):\n                groups[1] = f'  - {line.split()[-1]}'\n            continue\n        (p1, p2) = (p.split() for p in line.split(';'))\n        (status, name) = (p2[0], ' '.join(p2[4:]))\n        char = ''.join((chr(int(x, 16)) for x in p1))\n        expect(char)\n        expect(char, char)\n        expect('a', char, 'a')\n        expect('a', 'a', char)\n        expect(char, 'a', 'a')\n    print(f'\\nerrors   : {errors / total:6.2%} [{errors}/{total}]')\n    print(f'successes: {1 - errors / total:6.2%} [{total - errors}/{total}]')",
            "def validate_unicode_breaks(uver=None, show_all=False, cache=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    latest = f'{CACHE}/latest'\n    if not uver and cache and os.path.exists(latest):\n        with open(latest) as f:\n            uver = f.read()\n        print('using version \"latest\" as:', uver)\n    file = f'{CACHE}/emoji-test_{uver}.txt'\n    if cache and os.path.exists(file):\n        print('loading cached:', file)\n        with open(file) as f:\n            data = f.read()\n    else:\n        url = f\"https://www.unicode.org/Public/emoji/{uver or 'latest'}/emoji-test.txt\"\n        print('downloading:', url)\n        try:\n            req = urllib.request.urlopen(url)\n        except OSError as e:\n            print(RED('Download error:'), e)\n            return\n        os.makedirs(os.path.dirname(file), exist_ok=True)\n        if not uver:\n            new_url = req.geturl()\n            uver = new_url.split('/')[5]\n            print('saving version \"latest\" as:', uver)\n            with open(latest, 'w') as f:\n                f.write(uver)\n            file = f'{CACHE}/emoji-test_{uver}.txt'\n        print('saving:', file)\n        data = req.read().decode('utf8')\n        with open(file, 'w') as f:\n            f.write(data)\n\n    def where():\n        nonlocal groups\n        if any(groups):\n            print('\\n'.join((g for g in groups if g)))\n        groups = [None, None]\n\n    def expect(*chars):\n        nonlocal errors, total\n        text = ''.join(chars)\n        actual = split_graphemes(text)\n        error = actual != chars\n        total += 1\n        errors += error\n        if error or show_all:\n            where()\n            codes = '|'.join(((GREEN if a == c else RED)(' '.join((hex(ord(c)).replace('0x', '') for c in a)) if a else '-') for (a, c) in zip_longest(actual, chars)))\n            small_name = name.replace(' skin tone', '').replace(' hair', '')\n            small_status = ''.join((x[0] for x in status.split('-')))\n            (a_len, c_len) = (len(actual), len(chars))\n            size = f'{GREEN(a_len)} ==' if a_len == c_len else f'{RED(a_len)} !='\n            print(f\" {char}   {text.replace(char, 'X'):>3}: {size} {c_len} -> |{codes}| {ORANGE(small_status)} {small_name}\")\n    (groups, total, errors) = ([None, None], 0, 0)\n    for line in filter(None, data.splitlines()):\n        if line.startswith('#'):\n            if line.startswith('# group:'):\n                groups[0] = line.split()[-1]\n            elif line.startswith('# subgroup:'):\n                groups[1] = f'  - {line.split()[-1]}'\n            continue\n        (p1, p2) = (p.split() for p in line.split(';'))\n        (status, name) = (p2[0], ' '.join(p2[4:]))\n        char = ''.join((chr(int(x, 16)) for x in p1))\n        expect(char)\n        expect(char, char)\n        expect('a', char, 'a')\n        expect('a', 'a', char)\n        expect(char, 'a', 'a')\n    print(f'\\nerrors   : {errors / total:6.2%} [{errors}/{total}]')\n    print(f'successes: {1 - errors / total:6.2%} [{total - errors}/{total}]')",
            "def validate_unicode_breaks(uver=None, show_all=False, cache=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    latest = f'{CACHE}/latest'\n    if not uver and cache and os.path.exists(latest):\n        with open(latest) as f:\n            uver = f.read()\n        print('using version \"latest\" as:', uver)\n    file = f'{CACHE}/emoji-test_{uver}.txt'\n    if cache and os.path.exists(file):\n        print('loading cached:', file)\n        with open(file) as f:\n            data = f.read()\n    else:\n        url = f\"https://www.unicode.org/Public/emoji/{uver or 'latest'}/emoji-test.txt\"\n        print('downloading:', url)\n        try:\n            req = urllib.request.urlopen(url)\n        except OSError as e:\n            print(RED('Download error:'), e)\n            return\n        os.makedirs(os.path.dirname(file), exist_ok=True)\n        if not uver:\n            new_url = req.geturl()\n            uver = new_url.split('/')[5]\n            print('saving version \"latest\" as:', uver)\n            with open(latest, 'w') as f:\n                f.write(uver)\n            file = f'{CACHE}/emoji-test_{uver}.txt'\n        print('saving:', file)\n        data = req.read().decode('utf8')\n        with open(file, 'w') as f:\n            f.write(data)\n\n    def where():\n        nonlocal groups\n        if any(groups):\n            print('\\n'.join((g for g in groups if g)))\n        groups = [None, None]\n\n    def expect(*chars):\n        nonlocal errors, total\n        text = ''.join(chars)\n        actual = split_graphemes(text)\n        error = actual != chars\n        total += 1\n        errors += error\n        if error or show_all:\n            where()\n            codes = '|'.join(((GREEN if a == c else RED)(' '.join((hex(ord(c)).replace('0x', '') for c in a)) if a else '-') for (a, c) in zip_longest(actual, chars)))\n            small_name = name.replace(' skin tone', '').replace(' hair', '')\n            small_status = ''.join((x[0] for x in status.split('-')))\n            (a_len, c_len) = (len(actual), len(chars))\n            size = f'{GREEN(a_len)} ==' if a_len == c_len else f'{RED(a_len)} !='\n            print(f\" {char}   {text.replace(char, 'X'):>3}: {size} {c_len} -> |{codes}| {ORANGE(small_status)} {small_name}\")\n    (groups, total, errors) = ([None, None], 0, 0)\n    for line in filter(None, data.splitlines()):\n        if line.startswith('#'):\n            if line.startswith('# group:'):\n                groups[0] = line.split()[-1]\n            elif line.startswith('# subgroup:'):\n                groups[1] = f'  - {line.split()[-1]}'\n            continue\n        (p1, p2) = (p.split() for p in line.split(';'))\n        (status, name) = (p2[0], ' '.join(p2[4:]))\n        char = ''.join((chr(int(x, 16)) for x in p1))\n        expect(char)\n        expect(char, char)\n        expect('a', char, 'a')\n        expect('a', 'a', char)\n        expect(char, 'a', 'a')\n    print(f'\\nerrors   : {errors / total:6.2%} [{errors}/{total}]')\n    print(f'successes: {1 - errors / total:6.2%} [{total - errors}/{total}]')"
        ]
    },
    {
        "func_name": "find_groups",
        "original": "def find_groups(data, max_diff):\n    \"\"\"Group some numbers with a maximum difference between them.\n    I've used to try to fix the current grapheme break error.\n\n    Using version unicode 13.1:\n        Component\n          - skin-tone\n         \ud83c\udffb    XX: 1 != 2 -> |1f3fb 1f3fb|-| c light\n         \ud83c\udffb   aXa: 2 != 3 -> |61 1f3fb|61|-| c light\n         \ud83c\udffb   aaX: 2 != 3 -> |61|61 1f3fb|-| c light\n         \ud83c\udffc    XX: 1 != 2 -> |1f3fc 1f3fc|-| c medium-light\n         \ud83c\udffc   aXa: 2 != 3 -> |61 1f3fc|61|-| c medium-light\n         \ud83c\udffc   aaX: 2 != 3 -> |61|61 1f3fc|-| c medium-light\n         \ud83c\udffd    XX: 1 != 2 -> |1f3fd 1f3fd|-| c medium\n         \ud83c\udffd   aXa: 2 != 3 -> |61 1f3fd|61|-| c medium\n         \ud83c\udffd   aaX: 2 != 3 -> |61|61 1f3fd|-| c medium\n         \ud83c\udffe    XX: 1 != 2 -> |1f3fe 1f3fe|-| c medium-dark\n         \ud83c\udffe   aXa: 2 != 3 -> |61 1f3fe|61|-| c medium-dark\n         \ud83c\udffe   aaX: 2 != 3 -> |61|61 1f3fe|-| c medium-dark\n         \ud83c\udfff    XX: 1 != 2 -> |1f3ff 1f3ff|-| c dark\n         \ud83c\udfff   aXa: 2 != 3 -> |61 1f3ff|61|-| c dark\n         \ud83c\udfff   aaX: 2 != 3 -> |61|61 1f3ff|-| c dark\n\n    The codepoints that do accept a skin tone are:\n    0x0261D, 0x026F9, 0x0270A, 0x0270B, 0x0270C, 0x0270D, 0x1F385, 0x1F3C2, 0x1F3C3, 0x1F3C4,\n    0x1F3C7, 0x1F3CA, 0x1F3CB, 0x1F3CC, 0x1F442, 0x1F443, 0x1F446, 0x1F447, 0x1F448, 0x1F449,\n    0x1F44A, 0x1F44B, 0x1F44C, 0x1F44D, 0x1F44E, 0x1F44F, 0x1F450, 0x1F466, 0x1F467, 0x1F468,\n    0x1F469, 0x1F46B, 0x1F46C, 0x1F46D, 0x1F46E, 0x1F470, 0x1F471, 0x1F472, 0x1F473, 0x1F474,\n    0x1F475, 0x1F476, 0x1F477, 0x1F478, 0x1F47C, 0x1F481, 0x1F482, 0x1F483, 0x1F485, 0x1F486,\n    0x1F487, 0x1F4AA, 0x1F574, 0x1F575, 0x1F57A, 0x1F590, 0x1F595, 0x1F596, 0x1F645, 0x1F646,\n    0x1F647, 0x1F64B, 0x1F64C, 0x1F64D, 0x1F64E, 0x1F64F, 0x1F6A3, 0x1F6B4, 0x1F6B5, 0x1F6B6,\n    0x1F6C0, 0x1F6CC, 0x1F90C, 0x1F90F, 0x1F918, 0x1F919, 0x1F91A, 0x1F91B, 0x1F91C, 0x1F91E,\n    0x1F91F, 0x1F926, 0x1F930, 0x1F931, 0x1F932, 0x1F933, 0x1F934, 0x1F935, 0x1F936, 0x1F937,\n    0x1F938, 0x1F939, 0x1F93D, 0x1F93E, 0x1F977, 0x1F9B5, 0x1F9B6, 0x1F9B8, 0x1F9B9, 0x1F9BB,\n    0x1F9CD, 0x1F9CE, 0x1F9CF, 0x1F9D1, 0x1F9D2, 0x1F9D3, 0x1F9D4, 0x1F9D5, 0x1F9D6, 0x1F9D7,\n    0x1F9D8, 0x1F9D9, 0x1F9DA, 0x1F9DB, 0x1F9DC, 0x1F9DD\n\n    \"\"\"\n    it = iter(sorted(data))\n    last_item = next(it)\n    current_group = [last_item]\n    result = [current_group]\n    for i in it:\n        if i - last_item > max_diff:\n            current_group = []\n            result.append(current_group)\n        current_group.append(i)\n        last_item = i\n    print('\\n'.join((f'{len(g)}:|' + ' '.join((hex(x).replace('0x', '') for x in g)) + '|' for g in result)))",
        "mutated": [
            "def find_groups(data, max_diff):\n    if False:\n        i = 10\n    \"Group some numbers with a maximum difference between them.\\n    I've used to try to fix the current grapheme break error.\\n\\n    Using version unicode 13.1:\\n        Component\\n          - skin-tone\\n         \ud83c\udffb    XX: 1 != 2 -> |1f3fb 1f3fb|-| c light\\n         \ud83c\udffb   aXa: 2 != 3 -> |61 1f3fb|61|-| c light\\n         \ud83c\udffb   aaX: 2 != 3 -> |61|61 1f3fb|-| c light\\n         \ud83c\udffc    XX: 1 != 2 -> |1f3fc 1f3fc|-| c medium-light\\n         \ud83c\udffc   aXa: 2 != 3 -> |61 1f3fc|61|-| c medium-light\\n         \ud83c\udffc   aaX: 2 != 3 -> |61|61 1f3fc|-| c medium-light\\n         \ud83c\udffd    XX: 1 != 2 -> |1f3fd 1f3fd|-| c medium\\n         \ud83c\udffd   aXa: 2 != 3 -> |61 1f3fd|61|-| c medium\\n         \ud83c\udffd   aaX: 2 != 3 -> |61|61 1f3fd|-| c medium\\n         \ud83c\udffe    XX: 1 != 2 -> |1f3fe 1f3fe|-| c medium-dark\\n         \ud83c\udffe   aXa: 2 != 3 -> |61 1f3fe|61|-| c medium-dark\\n         \ud83c\udffe   aaX: 2 != 3 -> |61|61 1f3fe|-| c medium-dark\\n         \ud83c\udfff    XX: 1 != 2 -> |1f3ff 1f3ff|-| c dark\\n         \ud83c\udfff   aXa: 2 != 3 -> |61 1f3ff|61|-| c dark\\n         \ud83c\udfff   aaX: 2 != 3 -> |61|61 1f3ff|-| c dark\\n\\n    The codepoints that do accept a skin tone are:\\n    0x0261D, 0x026F9, 0x0270A, 0x0270B, 0x0270C, 0x0270D, 0x1F385, 0x1F3C2, 0x1F3C3, 0x1F3C4,\\n    0x1F3C7, 0x1F3CA, 0x1F3CB, 0x1F3CC, 0x1F442, 0x1F443, 0x1F446, 0x1F447, 0x1F448, 0x1F449,\\n    0x1F44A, 0x1F44B, 0x1F44C, 0x1F44D, 0x1F44E, 0x1F44F, 0x1F450, 0x1F466, 0x1F467, 0x1F468,\\n    0x1F469, 0x1F46B, 0x1F46C, 0x1F46D, 0x1F46E, 0x1F470, 0x1F471, 0x1F472, 0x1F473, 0x1F474,\\n    0x1F475, 0x1F476, 0x1F477, 0x1F478, 0x1F47C, 0x1F481, 0x1F482, 0x1F483, 0x1F485, 0x1F486,\\n    0x1F487, 0x1F4AA, 0x1F574, 0x1F575, 0x1F57A, 0x1F590, 0x1F595, 0x1F596, 0x1F645, 0x1F646,\\n    0x1F647, 0x1F64B, 0x1F64C, 0x1F64D, 0x1F64E, 0x1F64F, 0x1F6A3, 0x1F6B4, 0x1F6B5, 0x1F6B6,\\n    0x1F6C0, 0x1F6CC, 0x1F90C, 0x1F90F, 0x1F918, 0x1F919, 0x1F91A, 0x1F91B, 0x1F91C, 0x1F91E,\\n    0x1F91F, 0x1F926, 0x1F930, 0x1F931, 0x1F932, 0x1F933, 0x1F934, 0x1F935, 0x1F936, 0x1F937,\\n    0x1F938, 0x1F939, 0x1F93D, 0x1F93E, 0x1F977, 0x1F9B5, 0x1F9B6, 0x1F9B8, 0x1F9B9, 0x1F9BB,\\n    0x1F9CD, 0x1F9CE, 0x1F9CF, 0x1F9D1, 0x1F9D2, 0x1F9D3, 0x1F9D4, 0x1F9D5, 0x1F9D6, 0x1F9D7,\\n    0x1F9D8, 0x1F9D9, 0x1F9DA, 0x1F9DB, 0x1F9DC, 0x1F9DD\\n\\n    \"\n    it = iter(sorted(data))\n    last_item = next(it)\n    current_group = [last_item]\n    result = [current_group]\n    for i in it:\n        if i - last_item > max_diff:\n            current_group = []\n            result.append(current_group)\n        current_group.append(i)\n        last_item = i\n    print('\\n'.join((f'{len(g)}:|' + ' '.join((hex(x).replace('0x', '') for x in g)) + '|' for g in result)))",
            "def find_groups(data, max_diff):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Group some numbers with a maximum difference between them.\\n    I've used to try to fix the current grapheme break error.\\n\\n    Using version unicode 13.1:\\n        Component\\n          - skin-tone\\n         \ud83c\udffb    XX: 1 != 2 -> |1f3fb 1f3fb|-| c light\\n         \ud83c\udffb   aXa: 2 != 3 -> |61 1f3fb|61|-| c light\\n         \ud83c\udffb   aaX: 2 != 3 -> |61|61 1f3fb|-| c light\\n         \ud83c\udffc    XX: 1 != 2 -> |1f3fc 1f3fc|-| c medium-light\\n         \ud83c\udffc   aXa: 2 != 3 -> |61 1f3fc|61|-| c medium-light\\n         \ud83c\udffc   aaX: 2 != 3 -> |61|61 1f3fc|-| c medium-light\\n         \ud83c\udffd    XX: 1 != 2 -> |1f3fd 1f3fd|-| c medium\\n         \ud83c\udffd   aXa: 2 != 3 -> |61 1f3fd|61|-| c medium\\n         \ud83c\udffd   aaX: 2 != 3 -> |61|61 1f3fd|-| c medium\\n         \ud83c\udffe    XX: 1 != 2 -> |1f3fe 1f3fe|-| c medium-dark\\n         \ud83c\udffe   aXa: 2 != 3 -> |61 1f3fe|61|-| c medium-dark\\n         \ud83c\udffe   aaX: 2 != 3 -> |61|61 1f3fe|-| c medium-dark\\n         \ud83c\udfff    XX: 1 != 2 -> |1f3ff 1f3ff|-| c dark\\n         \ud83c\udfff   aXa: 2 != 3 -> |61 1f3ff|61|-| c dark\\n         \ud83c\udfff   aaX: 2 != 3 -> |61|61 1f3ff|-| c dark\\n\\n    The codepoints that do accept a skin tone are:\\n    0x0261D, 0x026F9, 0x0270A, 0x0270B, 0x0270C, 0x0270D, 0x1F385, 0x1F3C2, 0x1F3C3, 0x1F3C4,\\n    0x1F3C7, 0x1F3CA, 0x1F3CB, 0x1F3CC, 0x1F442, 0x1F443, 0x1F446, 0x1F447, 0x1F448, 0x1F449,\\n    0x1F44A, 0x1F44B, 0x1F44C, 0x1F44D, 0x1F44E, 0x1F44F, 0x1F450, 0x1F466, 0x1F467, 0x1F468,\\n    0x1F469, 0x1F46B, 0x1F46C, 0x1F46D, 0x1F46E, 0x1F470, 0x1F471, 0x1F472, 0x1F473, 0x1F474,\\n    0x1F475, 0x1F476, 0x1F477, 0x1F478, 0x1F47C, 0x1F481, 0x1F482, 0x1F483, 0x1F485, 0x1F486,\\n    0x1F487, 0x1F4AA, 0x1F574, 0x1F575, 0x1F57A, 0x1F590, 0x1F595, 0x1F596, 0x1F645, 0x1F646,\\n    0x1F647, 0x1F64B, 0x1F64C, 0x1F64D, 0x1F64E, 0x1F64F, 0x1F6A3, 0x1F6B4, 0x1F6B5, 0x1F6B6,\\n    0x1F6C0, 0x1F6CC, 0x1F90C, 0x1F90F, 0x1F918, 0x1F919, 0x1F91A, 0x1F91B, 0x1F91C, 0x1F91E,\\n    0x1F91F, 0x1F926, 0x1F930, 0x1F931, 0x1F932, 0x1F933, 0x1F934, 0x1F935, 0x1F936, 0x1F937,\\n    0x1F938, 0x1F939, 0x1F93D, 0x1F93E, 0x1F977, 0x1F9B5, 0x1F9B6, 0x1F9B8, 0x1F9B9, 0x1F9BB,\\n    0x1F9CD, 0x1F9CE, 0x1F9CF, 0x1F9D1, 0x1F9D2, 0x1F9D3, 0x1F9D4, 0x1F9D5, 0x1F9D6, 0x1F9D7,\\n    0x1F9D8, 0x1F9D9, 0x1F9DA, 0x1F9DB, 0x1F9DC, 0x1F9DD\\n\\n    \"\n    it = iter(sorted(data))\n    last_item = next(it)\n    current_group = [last_item]\n    result = [current_group]\n    for i in it:\n        if i - last_item > max_diff:\n            current_group = []\n            result.append(current_group)\n        current_group.append(i)\n        last_item = i\n    print('\\n'.join((f'{len(g)}:|' + ' '.join((hex(x).replace('0x', '') for x in g)) + '|' for g in result)))",
            "def find_groups(data, max_diff):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Group some numbers with a maximum difference between them.\\n    I've used to try to fix the current grapheme break error.\\n\\n    Using version unicode 13.1:\\n        Component\\n          - skin-tone\\n         \ud83c\udffb    XX: 1 != 2 -> |1f3fb 1f3fb|-| c light\\n         \ud83c\udffb   aXa: 2 != 3 -> |61 1f3fb|61|-| c light\\n         \ud83c\udffb   aaX: 2 != 3 -> |61|61 1f3fb|-| c light\\n         \ud83c\udffc    XX: 1 != 2 -> |1f3fc 1f3fc|-| c medium-light\\n         \ud83c\udffc   aXa: 2 != 3 -> |61 1f3fc|61|-| c medium-light\\n         \ud83c\udffc   aaX: 2 != 3 -> |61|61 1f3fc|-| c medium-light\\n         \ud83c\udffd    XX: 1 != 2 -> |1f3fd 1f3fd|-| c medium\\n         \ud83c\udffd   aXa: 2 != 3 -> |61 1f3fd|61|-| c medium\\n         \ud83c\udffd   aaX: 2 != 3 -> |61|61 1f3fd|-| c medium\\n         \ud83c\udffe    XX: 1 != 2 -> |1f3fe 1f3fe|-| c medium-dark\\n         \ud83c\udffe   aXa: 2 != 3 -> |61 1f3fe|61|-| c medium-dark\\n         \ud83c\udffe   aaX: 2 != 3 -> |61|61 1f3fe|-| c medium-dark\\n         \ud83c\udfff    XX: 1 != 2 -> |1f3ff 1f3ff|-| c dark\\n         \ud83c\udfff   aXa: 2 != 3 -> |61 1f3ff|61|-| c dark\\n         \ud83c\udfff   aaX: 2 != 3 -> |61|61 1f3ff|-| c dark\\n\\n    The codepoints that do accept a skin tone are:\\n    0x0261D, 0x026F9, 0x0270A, 0x0270B, 0x0270C, 0x0270D, 0x1F385, 0x1F3C2, 0x1F3C3, 0x1F3C4,\\n    0x1F3C7, 0x1F3CA, 0x1F3CB, 0x1F3CC, 0x1F442, 0x1F443, 0x1F446, 0x1F447, 0x1F448, 0x1F449,\\n    0x1F44A, 0x1F44B, 0x1F44C, 0x1F44D, 0x1F44E, 0x1F44F, 0x1F450, 0x1F466, 0x1F467, 0x1F468,\\n    0x1F469, 0x1F46B, 0x1F46C, 0x1F46D, 0x1F46E, 0x1F470, 0x1F471, 0x1F472, 0x1F473, 0x1F474,\\n    0x1F475, 0x1F476, 0x1F477, 0x1F478, 0x1F47C, 0x1F481, 0x1F482, 0x1F483, 0x1F485, 0x1F486,\\n    0x1F487, 0x1F4AA, 0x1F574, 0x1F575, 0x1F57A, 0x1F590, 0x1F595, 0x1F596, 0x1F645, 0x1F646,\\n    0x1F647, 0x1F64B, 0x1F64C, 0x1F64D, 0x1F64E, 0x1F64F, 0x1F6A3, 0x1F6B4, 0x1F6B5, 0x1F6B6,\\n    0x1F6C0, 0x1F6CC, 0x1F90C, 0x1F90F, 0x1F918, 0x1F919, 0x1F91A, 0x1F91B, 0x1F91C, 0x1F91E,\\n    0x1F91F, 0x1F926, 0x1F930, 0x1F931, 0x1F932, 0x1F933, 0x1F934, 0x1F935, 0x1F936, 0x1F937,\\n    0x1F938, 0x1F939, 0x1F93D, 0x1F93E, 0x1F977, 0x1F9B5, 0x1F9B6, 0x1F9B8, 0x1F9B9, 0x1F9BB,\\n    0x1F9CD, 0x1F9CE, 0x1F9CF, 0x1F9D1, 0x1F9D2, 0x1F9D3, 0x1F9D4, 0x1F9D5, 0x1F9D6, 0x1F9D7,\\n    0x1F9D8, 0x1F9D9, 0x1F9DA, 0x1F9DB, 0x1F9DC, 0x1F9DD\\n\\n    \"\n    it = iter(sorted(data))\n    last_item = next(it)\n    current_group = [last_item]\n    result = [current_group]\n    for i in it:\n        if i - last_item > max_diff:\n            current_group = []\n            result.append(current_group)\n        current_group.append(i)\n        last_item = i\n    print('\\n'.join((f'{len(g)}:|' + ' '.join((hex(x).replace('0x', '') for x in g)) + '|' for g in result)))",
            "def find_groups(data, max_diff):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Group some numbers with a maximum difference between them.\\n    I've used to try to fix the current grapheme break error.\\n\\n    Using version unicode 13.1:\\n        Component\\n          - skin-tone\\n         \ud83c\udffb    XX: 1 != 2 -> |1f3fb 1f3fb|-| c light\\n         \ud83c\udffb   aXa: 2 != 3 -> |61 1f3fb|61|-| c light\\n         \ud83c\udffb   aaX: 2 != 3 -> |61|61 1f3fb|-| c light\\n         \ud83c\udffc    XX: 1 != 2 -> |1f3fc 1f3fc|-| c medium-light\\n         \ud83c\udffc   aXa: 2 != 3 -> |61 1f3fc|61|-| c medium-light\\n         \ud83c\udffc   aaX: 2 != 3 -> |61|61 1f3fc|-| c medium-light\\n         \ud83c\udffd    XX: 1 != 2 -> |1f3fd 1f3fd|-| c medium\\n         \ud83c\udffd   aXa: 2 != 3 -> |61 1f3fd|61|-| c medium\\n         \ud83c\udffd   aaX: 2 != 3 -> |61|61 1f3fd|-| c medium\\n         \ud83c\udffe    XX: 1 != 2 -> |1f3fe 1f3fe|-| c medium-dark\\n         \ud83c\udffe   aXa: 2 != 3 -> |61 1f3fe|61|-| c medium-dark\\n         \ud83c\udffe   aaX: 2 != 3 -> |61|61 1f3fe|-| c medium-dark\\n         \ud83c\udfff    XX: 1 != 2 -> |1f3ff 1f3ff|-| c dark\\n         \ud83c\udfff   aXa: 2 != 3 -> |61 1f3ff|61|-| c dark\\n         \ud83c\udfff   aaX: 2 != 3 -> |61|61 1f3ff|-| c dark\\n\\n    The codepoints that do accept a skin tone are:\\n    0x0261D, 0x026F9, 0x0270A, 0x0270B, 0x0270C, 0x0270D, 0x1F385, 0x1F3C2, 0x1F3C3, 0x1F3C4,\\n    0x1F3C7, 0x1F3CA, 0x1F3CB, 0x1F3CC, 0x1F442, 0x1F443, 0x1F446, 0x1F447, 0x1F448, 0x1F449,\\n    0x1F44A, 0x1F44B, 0x1F44C, 0x1F44D, 0x1F44E, 0x1F44F, 0x1F450, 0x1F466, 0x1F467, 0x1F468,\\n    0x1F469, 0x1F46B, 0x1F46C, 0x1F46D, 0x1F46E, 0x1F470, 0x1F471, 0x1F472, 0x1F473, 0x1F474,\\n    0x1F475, 0x1F476, 0x1F477, 0x1F478, 0x1F47C, 0x1F481, 0x1F482, 0x1F483, 0x1F485, 0x1F486,\\n    0x1F487, 0x1F4AA, 0x1F574, 0x1F575, 0x1F57A, 0x1F590, 0x1F595, 0x1F596, 0x1F645, 0x1F646,\\n    0x1F647, 0x1F64B, 0x1F64C, 0x1F64D, 0x1F64E, 0x1F64F, 0x1F6A3, 0x1F6B4, 0x1F6B5, 0x1F6B6,\\n    0x1F6C0, 0x1F6CC, 0x1F90C, 0x1F90F, 0x1F918, 0x1F919, 0x1F91A, 0x1F91B, 0x1F91C, 0x1F91E,\\n    0x1F91F, 0x1F926, 0x1F930, 0x1F931, 0x1F932, 0x1F933, 0x1F934, 0x1F935, 0x1F936, 0x1F937,\\n    0x1F938, 0x1F939, 0x1F93D, 0x1F93E, 0x1F977, 0x1F9B5, 0x1F9B6, 0x1F9B8, 0x1F9B9, 0x1F9BB,\\n    0x1F9CD, 0x1F9CE, 0x1F9CF, 0x1F9D1, 0x1F9D2, 0x1F9D3, 0x1F9D4, 0x1F9D5, 0x1F9D6, 0x1F9D7,\\n    0x1F9D8, 0x1F9D9, 0x1F9DA, 0x1F9DB, 0x1F9DC, 0x1F9DD\\n\\n    \"\n    it = iter(sorted(data))\n    last_item = next(it)\n    current_group = [last_item]\n    result = [current_group]\n    for i in it:\n        if i - last_item > max_diff:\n            current_group = []\n            result.append(current_group)\n        current_group.append(i)\n        last_item = i\n    print('\\n'.join((f'{len(g)}:|' + ' '.join((hex(x).replace('0x', '') for x in g)) + '|' for g in result)))",
            "def find_groups(data, max_diff):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Group some numbers with a maximum difference between them.\\n    I've used to try to fix the current grapheme break error.\\n\\n    Using version unicode 13.1:\\n        Component\\n          - skin-tone\\n         \ud83c\udffb    XX: 1 != 2 -> |1f3fb 1f3fb|-| c light\\n         \ud83c\udffb   aXa: 2 != 3 -> |61 1f3fb|61|-| c light\\n         \ud83c\udffb   aaX: 2 != 3 -> |61|61 1f3fb|-| c light\\n         \ud83c\udffc    XX: 1 != 2 -> |1f3fc 1f3fc|-| c medium-light\\n         \ud83c\udffc   aXa: 2 != 3 -> |61 1f3fc|61|-| c medium-light\\n         \ud83c\udffc   aaX: 2 != 3 -> |61|61 1f3fc|-| c medium-light\\n         \ud83c\udffd    XX: 1 != 2 -> |1f3fd 1f3fd|-| c medium\\n         \ud83c\udffd   aXa: 2 != 3 -> |61 1f3fd|61|-| c medium\\n         \ud83c\udffd   aaX: 2 != 3 -> |61|61 1f3fd|-| c medium\\n         \ud83c\udffe    XX: 1 != 2 -> |1f3fe 1f3fe|-| c medium-dark\\n         \ud83c\udffe   aXa: 2 != 3 -> |61 1f3fe|61|-| c medium-dark\\n         \ud83c\udffe   aaX: 2 != 3 -> |61|61 1f3fe|-| c medium-dark\\n         \ud83c\udfff    XX: 1 != 2 -> |1f3ff 1f3ff|-| c dark\\n         \ud83c\udfff   aXa: 2 != 3 -> |61 1f3ff|61|-| c dark\\n         \ud83c\udfff   aaX: 2 != 3 -> |61|61 1f3ff|-| c dark\\n\\n    The codepoints that do accept a skin tone are:\\n    0x0261D, 0x026F9, 0x0270A, 0x0270B, 0x0270C, 0x0270D, 0x1F385, 0x1F3C2, 0x1F3C3, 0x1F3C4,\\n    0x1F3C7, 0x1F3CA, 0x1F3CB, 0x1F3CC, 0x1F442, 0x1F443, 0x1F446, 0x1F447, 0x1F448, 0x1F449,\\n    0x1F44A, 0x1F44B, 0x1F44C, 0x1F44D, 0x1F44E, 0x1F44F, 0x1F450, 0x1F466, 0x1F467, 0x1F468,\\n    0x1F469, 0x1F46B, 0x1F46C, 0x1F46D, 0x1F46E, 0x1F470, 0x1F471, 0x1F472, 0x1F473, 0x1F474,\\n    0x1F475, 0x1F476, 0x1F477, 0x1F478, 0x1F47C, 0x1F481, 0x1F482, 0x1F483, 0x1F485, 0x1F486,\\n    0x1F487, 0x1F4AA, 0x1F574, 0x1F575, 0x1F57A, 0x1F590, 0x1F595, 0x1F596, 0x1F645, 0x1F646,\\n    0x1F647, 0x1F64B, 0x1F64C, 0x1F64D, 0x1F64E, 0x1F64F, 0x1F6A3, 0x1F6B4, 0x1F6B5, 0x1F6B6,\\n    0x1F6C0, 0x1F6CC, 0x1F90C, 0x1F90F, 0x1F918, 0x1F919, 0x1F91A, 0x1F91B, 0x1F91C, 0x1F91E,\\n    0x1F91F, 0x1F926, 0x1F930, 0x1F931, 0x1F932, 0x1F933, 0x1F934, 0x1F935, 0x1F936, 0x1F937,\\n    0x1F938, 0x1F939, 0x1F93D, 0x1F93E, 0x1F977, 0x1F9B5, 0x1F9B6, 0x1F9B8, 0x1F9B9, 0x1F9BB,\\n    0x1F9CD, 0x1F9CE, 0x1F9CF, 0x1F9D1, 0x1F9D2, 0x1F9D3, 0x1F9D4, 0x1F9D5, 0x1F9D6, 0x1F9D7,\\n    0x1F9D8, 0x1F9D9, 0x1F9DA, 0x1F9DB, 0x1F9DC, 0x1F9DD\\n\\n    \"\n    it = iter(sorted(data))\n    last_item = next(it)\n    current_group = [last_item]\n    result = [current_group]\n    for i in it:\n        if i - last_item > max_diff:\n            current_group = []\n            result.append(current_group)\n        current_group.append(i)\n        last_item = i\n    print('\\n'.join((f'{len(g)}:|' + ' '.join((hex(x).replace('0x', '') for x in g)) + '|' for g in result)))"
        ]
    }
]