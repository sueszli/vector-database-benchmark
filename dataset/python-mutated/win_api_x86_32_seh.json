[
    {
        "func_name": "build_teb",
        "original": "def build_teb(jitter, teb_address):\n    \"\"\"\n    Build TEB information using following structure:\n\n    @jitter: jitter instance\n    @teb_address: the TEB address\n    \"\"\"\n    jitter.vm.add_memory_page(teb_address, PAGE_READ | PAGE_WRITE, b'\\x00' * NT_TIB.get_offset('StackBase'), 'TEB.NtTib.ExceptionList')\n    jitter.vm.add_memory_page(teb_address + NT_TIB.get_offset('Self'), PAGE_READ | PAGE_WRITE, b'\\x00' * (NT_TIB.sizeof() - NT_TIB.get_offset('Self')), 'TEB.NtTib.Self')\n    jitter.vm.add_memory_page(teb_address + TEB.get_offset('ProcessEnvironmentBlock'), PAGE_READ | PAGE_WRITE, b'\\x00' * (TEB.get_offset('LastErrorValue') - TEB.get_offset('ProcessEnvironmentBlock')), 'TEB.ProcessEnvironmentBlock')\n    Teb = TEB(jitter.vm, teb_address)\n    Teb.NtTib.ExceptionList = DEFAULT_SEH\n    Teb.NtTib.Self = teb_address\n    Teb.ProcessEnvironmentBlock = peb_address",
        "mutated": [
            "def build_teb(jitter, teb_address):\n    if False:\n        i = 10\n    '\\n    Build TEB information using following structure:\\n\\n    @jitter: jitter instance\\n    @teb_address: the TEB address\\n    '\n    jitter.vm.add_memory_page(teb_address, PAGE_READ | PAGE_WRITE, b'\\x00' * NT_TIB.get_offset('StackBase'), 'TEB.NtTib.ExceptionList')\n    jitter.vm.add_memory_page(teb_address + NT_TIB.get_offset('Self'), PAGE_READ | PAGE_WRITE, b'\\x00' * (NT_TIB.sizeof() - NT_TIB.get_offset('Self')), 'TEB.NtTib.Self')\n    jitter.vm.add_memory_page(teb_address + TEB.get_offset('ProcessEnvironmentBlock'), PAGE_READ | PAGE_WRITE, b'\\x00' * (TEB.get_offset('LastErrorValue') - TEB.get_offset('ProcessEnvironmentBlock')), 'TEB.ProcessEnvironmentBlock')\n    Teb = TEB(jitter.vm, teb_address)\n    Teb.NtTib.ExceptionList = DEFAULT_SEH\n    Teb.NtTib.Self = teb_address\n    Teb.ProcessEnvironmentBlock = peb_address",
            "def build_teb(jitter, teb_address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Build TEB information using following structure:\\n\\n    @jitter: jitter instance\\n    @teb_address: the TEB address\\n    '\n    jitter.vm.add_memory_page(teb_address, PAGE_READ | PAGE_WRITE, b'\\x00' * NT_TIB.get_offset('StackBase'), 'TEB.NtTib.ExceptionList')\n    jitter.vm.add_memory_page(teb_address + NT_TIB.get_offset('Self'), PAGE_READ | PAGE_WRITE, b'\\x00' * (NT_TIB.sizeof() - NT_TIB.get_offset('Self')), 'TEB.NtTib.Self')\n    jitter.vm.add_memory_page(teb_address + TEB.get_offset('ProcessEnvironmentBlock'), PAGE_READ | PAGE_WRITE, b'\\x00' * (TEB.get_offset('LastErrorValue') - TEB.get_offset('ProcessEnvironmentBlock')), 'TEB.ProcessEnvironmentBlock')\n    Teb = TEB(jitter.vm, teb_address)\n    Teb.NtTib.ExceptionList = DEFAULT_SEH\n    Teb.NtTib.Self = teb_address\n    Teb.ProcessEnvironmentBlock = peb_address",
            "def build_teb(jitter, teb_address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Build TEB information using following structure:\\n\\n    @jitter: jitter instance\\n    @teb_address: the TEB address\\n    '\n    jitter.vm.add_memory_page(teb_address, PAGE_READ | PAGE_WRITE, b'\\x00' * NT_TIB.get_offset('StackBase'), 'TEB.NtTib.ExceptionList')\n    jitter.vm.add_memory_page(teb_address + NT_TIB.get_offset('Self'), PAGE_READ | PAGE_WRITE, b'\\x00' * (NT_TIB.sizeof() - NT_TIB.get_offset('Self')), 'TEB.NtTib.Self')\n    jitter.vm.add_memory_page(teb_address + TEB.get_offset('ProcessEnvironmentBlock'), PAGE_READ | PAGE_WRITE, b'\\x00' * (TEB.get_offset('LastErrorValue') - TEB.get_offset('ProcessEnvironmentBlock')), 'TEB.ProcessEnvironmentBlock')\n    Teb = TEB(jitter.vm, teb_address)\n    Teb.NtTib.ExceptionList = DEFAULT_SEH\n    Teb.NtTib.Self = teb_address\n    Teb.ProcessEnvironmentBlock = peb_address",
            "def build_teb(jitter, teb_address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Build TEB information using following structure:\\n\\n    @jitter: jitter instance\\n    @teb_address: the TEB address\\n    '\n    jitter.vm.add_memory_page(teb_address, PAGE_READ | PAGE_WRITE, b'\\x00' * NT_TIB.get_offset('StackBase'), 'TEB.NtTib.ExceptionList')\n    jitter.vm.add_memory_page(teb_address + NT_TIB.get_offset('Self'), PAGE_READ | PAGE_WRITE, b'\\x00' * (NT_TIB.sizeof() - NT_TIB.get_offset('Self')), 'TEB.NtTib.Self')\n    jitter.vm.add_memory_page(teb_address + TEB.get_offset('ProcessEnvironmentBlock'), PAGE_READ | PAGE_WRITE, b'\\x00' * (TEB.get_offset('LastErrorValue') - TEB.get_offset('ProcessEnvironmentBlock')), 'TEB.ProcessEnvironmentBlock')\n    Teb = TEB(jitter.vm, teb_address)\n    Teb.NtTib.ExceptionList = DEFAULT_SEH\n    Teb.NtTib.Self = teb_address\n    Teb.ProcessEnvironmentBlock = peb_address",
            "def build_teb(jitter, teb_address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Build TEB information using following structure:\\n\\n    @jitter: jitter instance\\n    @teb_address: the TEB address\\n    '\n    jitter.vm.add_memory_page(teb_address, PAGE_READ | PAGE_WRITE, b'\\x00' * NT_TIB.get_offset('StackBase'), 'TEB.NtTib.ExceptionList')\n    jitter.vm.add_memory_page(teb_address + NT_TIB.get_offset('Self'), PAGE_READ | PAGE_WRITE, b'\\x00' * (NT_TIB.sizeof() - NT_TIB.get_offset('Self')), 'TEB.NtTib.Self')\n    jitter.vm.add_memory_page(teb_address + TEB.get_offset('ProcessEnvironmentBlock'), PAGE_READ | PAGE_WRITE, b'\\x00' * (TEB.get_offset('LastErrorValue') - TEB.get_offset('ProcessEnvironmentBlock')), 'TEB.ProcessEnvironmentBlock')\n    Teb = TEB(jitter.vm, teb_address)\n    Teb.NtTib.ExceptionList = DEFAULT_SEH\n    Teb.NtTib.Self = teb_address\n    Teb.ProcessEnvironmentBlock = peb_address"
        ]
    },
    {
        "func_name": "build_peb",
        "original": "def build_peb(jitter, peb_address):\n    \"\"\"\n    Build PEB information using following structure:\n\n    @jitter: jitter instance\n    @peb_address: the PEB address\n    \"\"\"\n    if main_pe:\n        (offset, length) = (8, 4)\n    else:\n        (offset, length) = (12, 0)\n    length += 4\n    jitter.vm.add_memory_page(peb_address + offset, PAGE_READ | PAGE_WRITE, b'\\x00' * length, 'PEB + 0x%x' % offset)\n    Peb = PEB(jitter.vm, peb_address)\n    if main_pe:\n        Peb.ImageBaseAddress = main_pe.NThdr.ImageBase\n    Peb.Ldr = peb_ldr_data_address",
        "mutated": [
            "def build_peb(jitter, peb_address):\n    if False:\n        i = 10\n    '\\n    Build PEB information using following structure:\\n\\n    @jitter: jitter instance\\n    @peb_address: the PEB address\\n    '\n    if main_pe:\n        (offset, length) = (8, 4)\n    else:\n        (offset, length) = (12, 0)\n    length += 4\n    jitter.vm.add_memory_page(peb_address + offset, PAGE_READ | PAGE_WRITE, b'\\x00' * length, 'PEB + 0x%x' % offset)\n    Peb = PEB(jitter.vm, peb_address)\n    if main_pe:\n        Peb.ImageBaseAddress = main_pe.NThdr.ImageBase\n    Peb.Ldr = peb_ldr_data_address",
            "def build_peb(jitter, peb_address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Build PEB information using following structure:\\n\\n    @jitter: jitter instance\\n    @peb_address: the PEB address\\n    '\n    if main_pe:\n        (offset, length) = (8, 4)\n    else:\n        (offset, length) = (12, 0)\n    length += 4\n    jitter.vm.add_memory_page(peb_address + offset, PAGE_READ | PAGE_WRITE, b'\\x00' * length, 'PEB + 0x%x' % offset)\n    Peb = PEB(jitter.vm, peb_address)\n    if main_pe:\n        Peb.ImageBaseAddress = main_pe.NThdr.ImageBase\n    Peb.Ldr = peb_ldr_data_address",
            "def build_peb(jitter, peb_address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Build PEB information using following structure:\\n\\n    @jitter: jitter instance\\n    @peb_address: the PEB address\\n    '\n    if main_pe:\n        (offset, length) = (8, 4)\n    else:\n        (offset, length) = (12, 0)\n    length += 4\n    jitter.vm.add_memory_page(peb_address + offset, PAGE_READ | PAGE_WRITE, b'\\x00' * length, 'PEB + 0x%x' % offset)\n    Peb = PEB(jitter.vm, peb_address)\n    if main_pe:\n        Peb.ImageBaseAddress = main_pe.NThdr.ImageBase\n    Peb.Ldr = peb_ldr_data_address",
            "def build_peb(jitter, peb_address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Build PEB information using following structure:\\n\\n    @jitter: jitter instance\\n    @peb_address: the PEB address\\n    '\n    if main_pe:\n        (offset, length) = (8, 4)\n    else:\n        (offset, length) = (12, 0)\n    length += 4\n    jitter.vm.add_memory_page(peb_address + offset, PAGE_READ | PAGE_WRITE, b'\\x00' * length, 'PEB + 0x%x' % offset)\n    Peb = PEB(jitter.vm, peb_address)\n    if main_pe:\n        Peb.ImageBaseAddress = main_pe.NThdr.ImageBase\n    Peb.Ldr = peb_ldr_data_address",
            "def build_peb(jitter, peb_address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Build PEB information using following structure:\\n\\n    @jitter: jitter instance\\n    @peb_address: the PEB address\\n    '\n    if main_pe:\n        (offset, length) = (8, 4)\n    else:\n        (offset, length) = (12, 0)\n    length += 4\n    jitter.vm.add_memory_page(peb_address + offset, PAGE_READ | PAGE_WRITE, b'\\x00' * length, 'PEB + 0x%x' % offset)\n    Peb = PEB(jitter.vm, peb_address)\n    if main_pe:\n        Peb.ImageBaseAddress = main_pe.NThdr.ImageBase\n    Peb.Ldr = peb_ldr_data_address"
        ]
    },
    {
        "func_name": "build_ldr_data",
        "original": "def build_ldr_data(jitter, modules_info):\n    \"\"\"\n    Build Loader information using following structure:\n\n    +0x000 Length                          : Uint4B\n    +0x004 Initialized                     : UChar\n    +0x008 SsHandle                        : Ptr32 Void\n    +0x00c InLoadOrderModuleList           : _LIST_ENTRY\n    +0x014 InMemoryOrderModuleList         : _LIST_ENTRY\n    +0x01C InInitializationOrderModuleList         : _LIST_ENTRY\n    # dummy dll base\n    +0x024 DllBase : Ptr32 Void\n\n    @jitter: jitter instance\n    @modules_info: LoadedModules instance\n\n    \"\"\"\n    offset = 12\n    addr = LDR_AD + peb_ldr_data_offset\n    ldrdata = PEB_LDR_DATA(jitter.vm, addr)\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    size = 0\n    if main_pe:\n        size += ListEntry.sizeof() * 2\n        main_addr_entry = modules_info.module2entry[main_pe]\n    if ntdll_pe:\n        size += ListEntry.sizeof()\n        ntdll_addr_entry = modules_info.module2entry[ntdll_pe]\n    jitter.vm.add_memory_page(addr + offset, PAGE_READ | PAGE_WRITE, b'\\x00' * size, 'Loader struct')\n    last_module = modules_info.module2entry[modules_info.modules[-1]]\n    if main_pe:\n        ldrdata.InLoadOrderModuleList.flink = main_addr_entry\n        ldrdata.InLoadOrderModuleList.blink = last_module\n        ldrdata.InMemoryOrderModuleList.flink = main_addr_entry + LdrDataEntry.get_type().get_offset('InMemoryOrderLinks')\n        ldrdata.InMemoryOrderModuleList.blink = last_module + LdrDataEntry.get_type().get_offset('InMemoryOrderLinks')\n    if ntdll_pe:\n        ldrdata.InInitializationOrderModuleList.flink = ntdll_addr_entry + LdrDataEntry.get_type().get_offset('InInitializationOrderLinks')\n        ldrdata.InInitializationOrderModuleList.blink = last_module + LdrDataEntry.get_type().get_offset('InInitializationOrderLinks')\n    jitter.vm.add_memory_page(peb_ldr_data_address + 36, PAGE_READ | PAGE_WRITE, pck32(0), 'Loader struct dummy dllbase')",
        "mutated": [
            "def build_ldr_data(jitter, modules_info):\n    if False:\n        i = 10\n    '\\n    Build Loader information using following structure:\\n\\n    +0x000 Length                          : Uint4B\\n    +0x004 Initialized                     : UChar\\n    +0x008 SsHandle                        : Ptr32 Void\\n    +0x00c InLoadOrderModuleList           : _LIST_ENTRY\\n    +0x014 InMemoryOrderModuleList         : _LIST_ENTRY\\n    +0x01C InInitializationOrderModuleList         : _LIST_ENTRY\\n    # dummy dll base\\n    +0x024 DllBase : Ptr32 Void\\n\\n    @jitter: jitter instance\\n    @modules_info: LoadedModules instance\\n\\n    '\n    offset = 12\n    addr = LDR_AD + peb_ldr_data_offset\n    ldrdata = PEB_LDR_DATA(jitter.vm, addr)\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    size = 0\n    if main_pe:\n        size += ListEntry.sizeof() * 2\n        main_addr_entry = modules_info.module2entry[main_pe]\n    if ntdll_pe:\n        size += ListEntry.sizeof()\n        ntdll_addr_entry = modules_info.module2entry[ntdll_pe]\n    jitter.vm.add_memory_page(addr + offset, PAGE_READ | PAGE_WRITE, b'\\x00' * size, 'Loader struct')\n    last_module = modules_info.module2entry[modules_info.modules[-1]]\n    if main_pe:\n        ldrdata.InLoadOrderModuleList.flink = main_addr_entry\n        ldrdata.InLoadOrderModuleList.blink = last_module\n        ldrdata.InMemoryOrderModuleList.flink = main_addr_entry + LdrDataEntry.get_type().get_offset('InMemoryOrderLinks')\n        ldrdata.InMemoryOrderModuleList.blink = last_module + LdrDataEntry.get_type().get_offset('InMemoryOrderLinks')\n    if ntdll_pe:\n        ldrdata.InInitializationOrderModuleList.flink = ntdll_addr_entry + LdrDataEntry.get_type().get_offset('InInitializationOrderLinks')\n        ldrdata.InInitializationOrderModuleList.blink = last_module + LdrDataEntry.get_type().get_offset('InInitializationOrderLinks')\n    jitter.vm.add_memory_page(peb_ldr_data_address + 36, PAGE_READ | PAGE_WRITE, pck32(0), 'Loader struct dummy dllbase')",
            "def build_ldr_data(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Build Loader information using following structure:\\n\\n    +0x000 Length                          : Uint4B\\n    +0x004 Initialized                     : UChar\\n    +0x008 SsHandle                        : Ptr32 Void\\n    +0x00c InLoadOrderModuleList           : _LIST_ENTRY\\n    +0x014 InMemoryOrderModuleList         : _LIST_ENTRY\\n    +0x01C InInitializationOrderModuleList         : _LIST_ENTRY\\n    # dummy dll base\\n    +0x024 DllBase : Ptr32 Void\\n\\n    @jitter: jitter instance\\n    @modules_info: LoadedModules instance\\n\\n    '\n    offset = 12\n    addr = LDR_AD + peb_ldr_data_offset\n    ldrdata = PEB_LDR_DATA(jitter.vm, addr)\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    size = 0\n    if main_pe:\n        size += ListEntry.sizeof() * 2\n        main_addr_entry = modules_info.module2entry[main_pe]\n    if ntdll_pe:\n        size += ListEntry.sizeof()\n        ntdll_addr_entry = modules_info.module2entry[ntdll_pe]\n    jitter.vm.add_memory_page(addr + offset, PAGE_READ | PAGE_WRITE, b'\\x00' * size, 'Loader struct')\n    last_module = modules_info.module2entry[modules_info.modules[-1]]\n    if main_pe:\n        ldrdata.InLoadOrderModuleList.flink = main_addr_entry\n        ldrdata.InLoadOrderModuleList.blink = last_module\n        ldrdata.InMemoryOrderModuleList.flink = main_addr_entry + LdrDataEntry.get_type().get_offset('InMemoryOrderLinks')\n        ldrdata.InMemoryOrderModuleList.blink = last_module + LdrDataEntry.get_type().get_offset('InMemoryOrderLinks')\n    if ntdll_pe:\n        ldrdata.InInitializationOrderModuleList.flink = ntdll_addr_entry + LdrDataEntry.get_type().get_offset('InInitializationOrderLinks')\n        ldrdata.InInitializationOrderModuleList.blink = last_module + LdrDataEntry.get_type().get_offset('InInitializationOrderLinks')\n    jitter.vm.add_memory_page(peb_ldr_data_address + 36, PAGE_READ | PAGE_WRITE, pck32(0), 'Loader struct dummy dllbase')",
            "def build_ldr_data(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Build Loader information using following structure:\\n\\n    +0x000 Length                          : Uint4B\\n    +0x004 Initialized                     : UChar\\n    +0x008 SsHandle                        : Ptr32 Void\\n    +0x00c InLoadOrderModuleList           : _LIST_ENTRY\\n    +0x014 InMemoryOrderModuleList         : _LIST_ENTRY\\n    +0x01C InInitializationOrderModuleList         : _LIST_ENTRY\\n    # dummy dll base\\n    +0x024 DllBase : Ptr32 Void\\n\\n    @jitter: jitter instance\\n    @modules_info: LoadedModules instance\\n\\n    '\n    offset = 12\n    addr = LDR_AD + peb_ldr_data_offset\n    ldrdata = PEB_LDR_DATA(jitter.vm, addr)\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    size = 0\n    if main_pe:\n        size += ListEntry.sizeof() * 2\n        main_addr_entry = modules_info.module2entry[main_pe]\n    if ntdll_pe:\n        size += ListEntry.sizeof()\n        ntdll_addr_entry = modules_info.module2entry[ntdll_pe]\n    jitter.vm.add_memory_page(addr + offset, PAGE_READ | PAGE_WRITE, b'\\x00' * size, 'Loader struct')\n    last_module = modules_info.module2entry[modules_info.modules[-1]]\n    if main_pe:\n        ldrdata.InLoadOrderModuleList.flink = main_addr_entry\n        ldrdata.InLoadOrderModuleList.blink = last_module\n        ldrdata.InMemoryOrderModuleList.flink = main_addr_entry + LdrDataEntry.get_type().get_offset('InMemoryOrderLinks')\n        ldrdata.InMemoryOrderModuleList.blink = last_module + LdrDataEntry.get_type().get_offset('InMemoryOrderLinks')\n    if ntdll_pe:\n        ldrdata.InInitializationOrderModuleList.flink = ntdll_addr_entry + LdrDataEntry.get_type().get_offset('InInitializationOrderLinks')\n        ldrdata.InInitializationOrderModuleList.blink = last_module + LdrDataEntry.get_type().get_offset('InInitializationOrderLinks')\n    jitter.vm.add_memory_page(peb_ldr_data_address + 36, PAGE_READ | PAGE_WRITE, pck32(0), 'Loader struct dummy dllbase')",
            "def build_ldr_data(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Build Loader information using following structure:\\n\\n    +0x000 Length                          : Uint4B\\n    +0x004 Initialized                     : UChar\\n    +0x008 SsHandle                        : Ptr32 Void\\n    +0x00c InLoadOrderModuleList           : _LIST_ENTRY\\n    +0x014 InMemoryOrderModuleList         : _LIST_ENTRY\\n    +0x01C InInitializationOrderModuleList         : _LIST_ENTRY\\n    # dummy dll base\\n    +0x024 DllBase : Ptr32 Void\\n\\n    @jitter: jitter instance\\n    @modules_info: LoadedModules instance\\n\\n    '\n    offset = 12\n    addr = LDR_AD + peb_ldr_data_offset\n    ldrdata = PEB_LDR_DATA(jitter.vm, addr)\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    size = 0\n    if main_pe:\n        size += ListEntry.sizeof() * 2\n        main_addr_entry = modules_info.module2entry[main_pe]\n    if ntdll_pe:\n        size += ListEntry.sizeof()\n        ntdll_addr_entry = modules_info.module2entry[ntdll_pe]\n    jitter.vm.add_memory_page(addr + offset, PAGE_READ | PAGE_WRITE, b'\\x00' * size, 'Loader struct')\n    last_module = modules_info.module2entry[modules_info.modules[-1]]\n    if main_pe:\n        ldrdata.InLoadOrderModuleList.flink = main_addr_entry\n        ldrdata.InLoadOrderModuleList.blink = last_module\n        ldrdata.InMemoryOrderModuleList.flink = main_addr_entry + LdrDataEntry.get_type().get_offset('InMemoryOrderLinks')\n        ldrdata.InMemoryOrderModuleList.blink = last_module + LdrDataEntry.get_type().get_offset('InMemoryOrderLinks')\n    if ntdll_pe:\n        ldrdata.InInitializationOrderModuleList.flink = ntdll_addr_entry + LdrDataEntry.get_type().get_offset('InInitializationOrderLinks')\n        ldrdata.InInitializationOrderModuleList.blink = last_module + LdrDataEntry.get_type().get_offset('InInitializationOrderLinks')\n    jitter.vm.add_memory_page(peb_ldr_data_address + 36, PAGE_READ | PAGE_WRITE, pck32(0), 'Loader struct dummy dllbase')",
            "def build_ldr_data(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Build Loader information using following structure:\\n\\n    +0x000 Length                          : Uint4B\\n    +0x004 Initialized                     : UChar\\n    +0x008 SsHandle                        : Ptr32 Void\\n    +0x00c InLoadOrderModuleList           : _LIST_ENTRY\\n    +0x014 InMemoryOrderModuleList         : _LIST_ENTRY\\n    +0x01C InInitializationOrderModuleList         : _LIST_ENTRY\\n    # dummy dll base\\n    +0x024 DllBase : Ptr32 Void\\n\\n    @jitter: jitter instance\\n    @modules_info: LoadedModules instance\\n\\n    '\n    offset = 12\n    addr = LDR_AD + peb_ldr_data_offset\n    ldrdata = PEB_LDR_DATA(jitter.vm, addr)\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    size = 0\n    if main_pe:\n        size += ListEntry.sizeof() * 2\n        main_addr_entry = modules_info.module2entry[main_pe]\n    if ntdll_pe:\n        size += ListEntry.sizeof()\n        ntdll_addr_entry = modules_info.module2entry[ntdll_pe]\n    jitter.vm.add_memory_page(addr + offset, PAGE_READ | PAGE_WRITE, b'\\x00' * size, 'Loader struct')\n    last_module = modules_info.module2entry[modules_info.modules[-1]]\n    if main_pe:\n        ldrdata.InLoadOrderModuleList.flink = main_addr_entry\n        ldrdata.InLoadOrderModuleList.blink = last_module\n        ldrdata.InMemoryOrderModuleList.flink = main_addr_entry + LdrDataEntry.get_type().get_offset('InMemoryOrderLinks')\n        ldrdata.InMemoryOrderModuleList.blink = last_module + LdrDataEntry.get_type().get_offset('InMemoryOrderLinks')\n    if ntdll_pe:\n        ldrdata.InInitializationOrderModuleList.flink = ntdll_addr_entry + LdrDataEntry.get_type().get_offset('InInitializationOrderLinks')\n        ldrdata.InInitializationOrderModuleList.blink = last_module + LdrDataEntry.get_type().get_offset('InInitializationOrderLinks')\n    jitter.vm.add_memory_page(peb_ldr_data_address + 36, PAGE_READ | PAGE_WRITE, pck32(0), 'Loader struct dummy dllbase')"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.modules = []\n    self.name2module = {}\n    self.module2entry = {}\n    self.module2name = {}",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.modules = []\n    self.name2module = {}\n    self.module2entry = {}\n    self.module2name = {}",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.modules = []\n    self.name2module = {}\n    self.module2entry = {}\n    self.module2name = {}",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.modules = []\n    self.name2module = {}\n    self.module2entry = {}\n    self.module2name = {}",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.modules = []\n    self.name2module = {}\n    self.module2entry = {}\n    self.module2name = {}",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.modules = []\n    self.name2module = {}\n    self.module2entry = {}\n    self.module2name = {}"
        ]
    },
    {
        "func_name": "add",
        "original": "def add(self, name, module, module_entry):\n    \"\"\"Track a new module\n        @name: module name (with extension)\n        @module: module object\n        @module_entry: address of the module entry\n        \"\"\"\n    self.modules.append(module)\n    self.name2module[name] = module\n    self.module2entry[module] = module_entry\n    self.module2name[module] = name",
        "mutated": [
            "def add(self, name, module, module_entry):\n    if False:\n        i = 10\n    'Track a new module\\n        @name: module name (with extension)\\n        @module: module object\\n        @module_entry: address of the module entry\\n        '\n    self.modules.append(module)\n    self.name2module[name] = module\n    self.module2entry[module] = module_entry\n    self.module2name[module] = name",
            "def add(self, name, module, module_entry):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Track a new module\\n        @name: module name (with extension)\\n        @module: module object\\n        @module_entry: address of the module entry\\n        '\n    self.modules.append(module)\n    self.name2module[name] = module\n    self.module2entry[module] = module_entry\n    self.module2name[module] = name",
            "def add(self, name, module, module_entry):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Track a new module\\n        @name: module name (with extension)\\n        @module: module object\\n        @module_entry: address of the module entry\\n        '\n    self.modules.append(module)\n    self.name2module[name] = module\n    self.module2entry[module] = module_entry\n    self.module2name[module] = name",
            "def add(self, name, module, module_entry):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Track a new module\\n        @name: module name (with extension)\\n        @module: module object\\n        @module_entry: address of the module entry\\n        '\n    self.modules.append(module)\n    self.name2module[name] = module\n    self.module2entry[module] = module_entry\n    self.module2name[module] = name",
            "def add(self, name, module, module_entry):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Track a new module\\n        @name: module name (with extension)\\n        @module: module object\\n        @module_entry: address of the module entry\\n        '\n    self.modules.append(module)\n    self.name2module[name] = module\n    self.module2entry[module] = module_entry\n    self.module2name[module] = name"
        ]
    },
    {
        "func_name": "__repr__",
        "original": "def __repr__(self):\n    return '\\n'.join((str(x) for x in viewitems(self.name2module)))",
        "mutated": [
            "def __repr__(self):\n    if False:\n        i = 10\n    return '\\n'.join((str(x) for x in viewitems(self.name2module)))",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return '\\n'.join((str(x) for x in viewitems(self.name2module)))",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return '\\n'.join((str(x) for x in viewitems(self.name2module)))",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return '\\n'.join((str(x) for x in viewitems(self.name2module)))",
            "def __repr__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return '\\n'.join((str(x) for x in viewitems(self.name2module)))"
        ]
    },
    {
        "func_name": "create_modules_chain",
        "original": "def create_modules_chain(jitter, name2module):\n    \"\"\"\n    Create the modules entries. Those modules are not linked in this function.\n\n    @jitter: jitter instance\n    @name2module: dict containing association between name and its pe instance\n    \"\"\"\n    modules_info = LoadedModules()\n    base_addr = LDR_AD + modules_list_offset\n    offset_name = 1280\n    offset_path = 1536\n    out = ''\n    for (i, (fname, pe_obj)) in enumerate(viewitems(name2module), 1):\n        if pe_obj is None:\n            log.warning('Unknown module: omitted from link list (%r)', fname)\n            continue\n        addr = base_addr + i * 4096\n        bpath = fname.replace('/', '\\\\')\n        bname_str = os.path.split(fname)[1].lower()\n        bname_unicode = bname_str.encode('utf-16le')\n        log.info('Add module %x %r', pe_obj.NThdr.ImageBase, bname_str)\n        modules_info.add(bname_str, pe_obj, addr)\n        jitter.vm.add_memory_page(addr, PAGE_READ | PAGE_WRITE, b'\\x00' * LdrDataEntry.get_offset('Flags'), 'Module info %r' % bname_str)\n        LdrEntry = LdrDataEntry(jitter.vm, addr)\n        LdrEntry.DllBase = pe_obj.NThdr.ImageBase\n        LdrEntry.EntryPoint = pe_obj.Opthdr.AddressOfEntryPoint\n        LdrEntry.SizeOfImage = pe_obj.NThdr.sizeofimage\n        LdrEntry.FullDllName.length = len(bname_unicode)\n        LdrEntry.FullDllName.maxlength = len(bname_unicode) + 2\n        LdrEntry.FullDllName.data = addr + offset_path\n        LdrEntry.BaseDllName.length = len(bname_unicode)\n        LdrEntry.BaseDllName.maxlength = len(bname_unicode) + 2\n        LdrEntry.BaseDllName.data = addr + offset_name\n        jitter.vm.add_memory_page(addr + offset_name, PAGE_READ | PAGE_WRITE, bname_unicode + b'\\x00' * 2, 'Module name %r' % bname_str)\n        if isinstance(bpath, bytes):\n            bpath = bpath.decode('utf8')\n        bpath_unicode = bpath.encode('utf-16le')\n        jitter.vm.add_memory_page(addr + offset_path, PAGE_READ | PAGE_WRITE, bpath_unicode + b'\\x00' * 2, 'Module path %r' % bname_str)\n    return modules_info",
        "mutated": [
            "def create_modules_chain(jitter, name2module):\n    if False:\n        i = 10\n    '\\n    Create the modules entries. Those modules are not linked in this function.\\n\\n    @jitter: jitter instance\\n    @name2module: dict containing association between name and its pe instance\\n    '\n    modules_info = LoadedModules()\n    base_addr = LDR_AD + modules_list_offset\n    offset_name = 1280\n    offset_path = 1536\n    out = ''\n    for (i, (fname, pe_obj)) in enumerate(viewitems(name2module), 1):\n        if pe_obj is None:\n            log.warning('Unknown module: omitted from link list (%r)', fname)\n            continue\n        addr = base_addr + i * 4096\n        bpath = fname.replace('/', '\\\\')\n        bname_str = os.path.split(fname)[1].lower()\n        bname_unicode = bname_str.encode('utf-16le')\n        log.info('Add module %x %r', pe_obj.NThdr.ImageBase, bname_str)\n        modules_info.add(bname_str, pe_obj, addr)\n        jitter.vm.add_memory_page(addr, PAGE_READ | PAGE_WRITE, b'\\x00' * LdrDataEntry.get_offset('Flags'), 'Module info %r' % bname_str)\n        LdrEntry = LdrDataEntry(jitter.vm, addr)\n        LdrEntry.DllBase = pe_obj.NThdr.ImageBase\n        LdrEntry.EntryPoint = pe_obj.Opthdr.AddressOfEntryPoint\n        LdrEntry.SizeOfImage = pe_obj.NThdr.sizeofimage\n        LdrEntry.FullDllName.length = len(bname_unicode)\n        LdrEntry.FullDllName.maxlength = len(bname_unicode) + 2\n        LdrEntry.FullDllName.data = addr + offset_path\n        LdrEntry.BaseDllName.length = len(bname_unicode)\n        LdrEntry.BaseDllName.maxlength = len(bname_unicode) + 2\n        LdrEntry.BaseDllName.data = addr + offset_name\n        jitter.vm.add_memory_page(addr + offset_name, PAGE_READ | PAGE_WRITE, bname_unicode + b'\\x00' * 2, 'Module name %r' % bname_str)\n        if isinstance(bpath, bytes):\n            bpath = bpath.decode('utf8')\n        bpath_unicode = bpath.encode('utf-16le')\n        jitter.vm.add_memory_page(addr + offset_path, PAGE_READ | PAGE_WRITE, bpath_unicode + b'\\x00' * 2, 'Module path %r' % bname_str)\n    return modules_info",
            "def create_modules_chain(jitter, name2module):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create the modules entries. Those modules are not linked in this function.\\n\\n    @jitter: jitter instance\\n    @name2module: dict containing association between name and its pe instance\\n    '\n    modules_info = LoadedModules()\n    base_addr = LDR_AD + modules_list_offset\n    offset_name = 1280\n    offset_path = 1536\n    out = ''\n    for (i, (fname, pe_obj)) in enumerate(viewitems(name2module), 1):\n        if pe_obj is None:\n            log.warning('Unknown module: omitted from link list (%r)', fname)\n            continue\n        addr = base_addr + i * 4096\n        bpath = fname.replace('/', '\\\\')\n        bname_str = os.path.split(fname)[1].lower()\n        bname_unicode = bname_str.encode('utf-16le')\n        log.info('Add module %x %r', pe_obj.NThdr.ImageBase, bname_str)\n        modules_info.add(bname_str, pe_obj, addr)\n        jitter.vm.add_memory_page(addr, PAGE_READ | PAGE_WRITE, b'\\x00' * LdrDataEntry.get_offset('Flags'), 'Module info %r' % bname_str)\n        LdrEntry = LdrDataEntry(jitter.vm, addr)\n        LdrEntry.DllBase = pe_obj.NThdr.ImageBase\n        LdrEntry.EntryPoint = pe_obj.Opthdr.AddressOfEntryPoint\n        LdrEntry.SizeOfImage = pe_obj.NThdr.sizeofimage\n        LdrEntry.FullDllName.length = len(bname_unicode)\n        LdrEntry.FullDllName.maxlength = len(bname_unicode) + 2\n        LdrEntry.FullDllName.data = addr + offset_path\n        LdrEntry.BaseDllName.length = len(bname_unicode)\n        LdrEntry.BaseDllName.maxlength = len(bname_unicode) + 2\n        LdrEntry.BaseDllName.data = addr + offset_name\n        jitter.vm.add_memory_page(addr + offset_name, PAGE_READ | PAGE_WRITE, bname_unicode + b'\\x00' * 2, 'Module name %r' % bname_str)\n        if isinstance(bpath, bytes):\n            bpath = bpath.decode('utf8')\n        bpath_unicode = bpath.encode('utf-16le')\n        jitter.vm.add_memory_page(addr + offset_path, PAGE_READ | PAGE_WRITE, bpath_unicode + b'\\x00' * 2, 'Module path %r' % bname_str)\n    return modules_info",
            "def create_modules_chain(jitter, name2module):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create the modules entries. Those modules are not linked in this function.\\n\\n    @jitter: jitter instance\\n    @name2module: dict containing association between name and its pe instance\\n    '\n    modules_info = LoadedModules()\n    base_addr = LDR_AD + modules_list_offset\n    offset_name = 1280\n    offset_path = 1536\n    out = ''\n    for (i, (fname, pe_obj)) in enumerate(viewitems(name2module), 1):\n        if pe_obj is None:\n            log.warning('Unknown module: omitted from link list (%r)', fname)\n            continue\n        addr = base_addr + i * 4096\n        bpath = fname.replace('/', '\\\\')\n        bname_str = os.path.split(fname)[1].lower()\n        bname_unicode = bname_str.encode('utf-16le')\n        log.info('Add module %x %r', pe_obj.NThdr.ImageBase, bname_str)\n        modules_info.add(bname_str, pe_obj, addr)\n        jitter.vm.add_memory_page(addr, PAGE_READ | PAGE_WRITE, b'\\x00' * LdrDataEntry.get_offset('Flags'), 'Module info %r' % bname_str)\n        LdrEntry = LdrDataEntry(jitter.vm, addr)\n        LdrEntry.DllBase = pe_obj.NThdr.ImageBase\n        LdrEntry.EntryPoint = pe_obj.Opthdr.AddressOfEntryPoint\n        LdrEntry.SizeOfImage = pe_obj.NThdr.sizeofimage\n        LdrEntry.FullDllName.length = len(bname_unicode)\n        LdrEntry.FullDllName.maxlength = len(bname_unicode) + 2\n        LdrEntry.FullDllName.data = addr + offset_path\n        LdrEntry.BaseDllName.length = len(bname_unicode)\n        LdrEntry.BaseDllName.maxlength = len(bname_unicode) + 2\n        LdrEntry.BaseDllName.data = addr + offset_name\n        jitter.vm.add_memory_page(addr + offset_name, PAGE_READ | PAGE_WRITE, bname_unicode + b'\\x00' * 2, 'Module name %r' % bname_str)\n        if isinstance(bpath, bytes):\n            bpath = bpath.decode('utf8')\n        bpath_unicode = bpath.encode('utf-16le')\n        jitter.vm.add_memory_page(addr + offset_path, PAGE_READ | PAGE_WRITE, bpath_unicode + b'\\x00' * 2, 'Module path %r' % bname_str)\n    return modules_info",
            "def create_modules_chain(jitter, name2module):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create the modules entries. Those modules are not linked in this function.\\n\\n    @jitter: jitter instance\\n    @name2module: dict containing association between name and its pe instance\\n    '\n    modules_info = LoadedModules()\n    base_addr = LDR_AD + modules_list_offset\n    offset_name = 1280\n    offset_path = 1536\n    out = ''\n    for (i, (fname, pe_obj)) in enumerate(viewitems(name2module), 1):\n        if pe_obj is None:\n            log.warning('Unknown module: omitted from link list (%r)', fname)\n            continue\n        addr = base_addr + i * 4096\n        bpath = fname.replace('/', '\\\\')\n        bname_str = os.path.split(fname)[1].lower()\n        bname_unicode = bname_str.encode('utf-16le')\n        log.info('Add module %x %r', pe_obj.NThdr.ImageBase, bname_str)\n        modules_info.add(bname_str, pe_obj, addr)\n        jitter.vm.add_memory_page(addr, PAGE_READ | PAGE_WRITE, b'\\x00' * LdrDataEntry.get_offset('Flags'), 'Module info %r' % bname_str)\n        LdrEntry = LdrDataEntry(jitter.vm, addr)\n        LdrEntry.DllBase = pe_obj.NThdr.ImageBase\n        LdrEntry.EntryPoint = pe_obj.Opthdr.AddressOfEntryPoint\n        LdrEntry.SizeOfImage = pe_obj.NThdr.sizeofimage\n        LdrEntry.FullDllName.length = len(bname_unicode)\n        LdrEntry.FullDllName.maxlength = len(bname_unicode) + 2\n        LdrEntry.FullDllName.data = addr + offset_path\n        LdrEntry.BaseDllName.length = len(bname_unicode)\n        LdrEntry.BaseDllName.maxlength = len(bname_unicode) + 2\n        LdrEntry.BaseDllName.data = addr + offset_name\n        jitter.vm.add_memory_page(addr + offset_name, PAGE_READ | PAGE_WRITE, bname_unicode + b'\\x00' * 2, 'Module name %r' % bname_str)\n        if isinstance(bpath, bytes):\n            bpath = bpath.decode('utf8')\n        bpath_unicode = bpath.encode('utf-16le')\n        jitter.vm.add_memory_page(addr + offset_path, PAGE_READ | PAGE_WRITE, bpath_unicode + b'\\x00' * 2, 'Module path %r' % bname_str)\n    return modules_info",
            "def create_modules_chain(jitter, name2module):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create the modules entries. Those modules are not linked in this function.\\n\\n    @jitter: jitter instance\\n    @name2module: dict containing association between name and its pe instance\\n    '\n    modules_info = LoadedModules()\n    base_addr = LDR_AD + modules_list_offset\n    offset_name = 1280\n    offset_path = 1536\n    out = ''\n    for (i, (fname, pe_obj)) in enumerate(viewitems(name2module), 1):\n        if pe_obj is None:\n            log.warning('Unknown module: omitted from link list (%r)', fname)\n            continue\n        addr = base_addr + i * 4096\n        bpath = fname.replace('/', '\\\\')\n        bname_str = os.path.split(fname)[1].lower()\n        bname_unicode = bname_str.encode('utf-16le')\n        log.info('Add module %x %r', pe_obj.NThdr.ImageBase, bname_str)\n        modules_info.add(bname_str, pe_obj, addr)\n        jitter.vm.add_memory_page(addr, PAGE_READ | PAGE_WRITE, b'\\x00' * LdrDataEntry.get_offset('Flags'), 'Module info %r' % bname_str)\n        LdrEntry = LdrDataEntry(jitter.vm, addr)\n        LdrEntry.DllBase = pe_obj.NThdr.ImageBase\n        LdrEntry.EntryPoint = pe_obj.Opthdr.AddressOfEntryPoint\n        LdrEntry.SizeOfImage = pe_obj.NThdr.sizeofimage\n        LdrEntry.FullDllName.length = len(bname_unicode)\n        LdrEntry.FullDllName.maxlength = len(bname_unicode) + 2\n        LdrEntry.FullDllName.data = addr + offset_path\n        LdrEntry.BaseDllName.length = len(bname_unicode)\n        LdrEntry.BaseDllName.maxlength = len(bname_unicode) + 2\n        LdrEntry.BaseDllName.data = addr + offset_name\n        jitter.vm.add_memory_page(addr + offset_name, PAGE_READ | PAGE_WRITE, bname_unicode + b'\\x00' * 2, 'Module name %r' % bname_str)\n        if isinstance(bpath, bytes):\n            bpath = bpath.decode('utf8')\n        bpath_unicode = bpath.encode('utf-16le')\n        jitter.vm.add_memory_page(addr + offset_path, PAGE_READ | PAGE_WRITE, bpath_unicode + b'\\x00' * 2, 'Module path %r' % bname_str)\n    return modules_info"
        ]
    },
    {
        "func_name": "set_link_list_entry",
        "original": "def set_link_list_entry(jitter, loaded_modules, modules_info, offset):\n    for (i, module) in enumerate(loaded_modules):\n        cur_module_entry = modules_info.module2entry[module]\n        prev_module = loaded_modules[(i - 1) % len(loaded_modules)]\n        next_module = loaded_modules[(i + 1) % len(loaded_modules)]\n        prev_module_entry = modules_info.module2entry[prev_module]\n        next_module_entry = modules_info.module2entry[next_module]\n        if i == 0:\n            prev_module_entry = peb_ldr_data_address + 12\n        if i == len(loaded_modules) - 1:\n            next_module_entry = peb_ldr_data_address + 12\n        list_entry = ListEntry(jitter.vm, cur_module_entry + offset)\n        list_entry.flink = next_module_entry + offset\n        list_entry.blink = prev_module_entry + offset",
        "mutated": [
            "def set_link_list_entry(jitter, loaded_modules, modules_info, offset):\n    if False:\n        i = 10\n    for (i, module) in enumerate(loaded_modules):\n        cur_module_entry = modules_info.module2entry[module]\n        prev_module = loaded_modules[(i - 1) % len(loaded_modules)]\n        next_module = loaded_modules[(i + 1) % len(loaded_modules)]\n        prev_module_entry = modules_info.module2entry[prev_module]\n        next_module_entry = modules_info.module2entry[next_module]\n        if i == 0:\n            prev_module_entry = peb_ldr_data_address + 12\n        if i == len(loaded_modules) - 1:\n            next_module_entry = peb_ldr_data_address + 12\n        list_entry = ListEntry(jitter.vm, cur_module_entry + offset)\n        list_entry.flink = next_module_entry + offset\n        list_entry.blink = prev_module_entry + offset",
            "def set_link_list_entry(jitter, loaded_modules, modules_info, offset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for (i, module) in enumerate(loaded_modules):\n        cur_module_entry = modules_info.module2entry[module]\n        prev_module = loaded_modules[(i - 1) % len(loaded_modules)]\n        next_module = loaded_modules[(i + 1) % len(loaded_modules)]\n        prev_module_entry = modules_info.module2entry[prev_module]\n        next_module_entry = modules_info.module2entry[next_module]\n        if i == 0:\n            prev_module_entry = peb_ldr_data_address + 12\n        if i == len(loaded_modules) - 1:\n            next_module_entry = peb_ldr_data_address + 12\n        list_entry = ListEntry(jitter.vm, cur_module_entry + offset)\n        list_entry.flink = next_module_entry + offset\n        list_entry.blink = prev_module_entry + offset",
            "def set_link_list_entry(jitter, loaded_modules, modules_info, offset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for (i, module) in enumerate(loaded_modules):\n        cur_module_entry = modules_info.module2entry[module]\n        prev_module = loaded_modules[(i - 1) % len(loaded_modules)]\n        next_module = loaded_modules[(i + 1) % len(loaded_modules)]\n        prev_module_entry = modules_info.module2entry[prev_module]\n        next_module_entry = modules_info.module2entry[next_module]\n        if i == 0:\n            prev_module_entry = peb_ldr_data_address + 12\n        if i == len(loaded_modules) - 1:\n            next_module_entry = peb_ldr_data_address + 12\n        list_entry = ListEntry(jitter.vm, cur_module_entry + offset)\n        list_entry.flink = next_module_entry + offset\n        list_entry.blink = prev_module_entry + offset",
            "def set_link_list_entry(jitter, loaded_modules, modules_info, offset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for (i, module) in enumerate(loaded_modules):\n        cur_module_entry = modules_info.module2entry[module]\n        prev_module = loaded_modules[(i - 1) % len(loaded_modules)]\n        next_module = loaded_modules[(i + 1) % len(loaded_modules)]\n        prev_module_entry = modules_info.module2entry[prev_module]\n        next_module_entry = modules_info.module2entry[next_module]\n        if i == 0:\n            prev_module_entry = peb_ldr_data_address + 12\n        if i == len(loaded_modules) - 1:\n            next_module_entry = peb_ldr_data_address + 12\n        list_entry = ListEntry(jitter.vm, cur_module_entry + offset)\n        list_entry.flink = next_module_entry + offset\n        list_entry.blink = prev_module_entry + offset",
            "def set_link_list_entry(jitter, loaded_modules, modules_info, offset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for (i, module) in enumerate(loaded_modules):\n        cur_module_entry = modules_info.module2entry[module]\n        prev_module = loaded_modules[(i - 1) % len(loaded_modules)]\n        next_module = loaded_modules[(i + 1) % len(loaded_modules)]\n        prev_module_entry = modules_info.module2entry[prev_module]\n        next_module_entry = modules_info.module2entry[next_module]\n        if i == 0:\n            prev_module_entry = peb_ldr_data_address + 12\n        if i == len(loaded_modules) - 1:\n            next_module_entry = peb_ldr_data_address + 12\n        list_entry = ListEntry(jitter.vm, cur_module_entry + offset)\n        list_entry.flink = next_module_entry + offset\n        list_entry.blink = prev_module_entry + offset"
        ]
    },
    {
        "func_name": "fix_InLoadOrderModuleList",
        "original": "def fix_InLoadOrderModuleList(jitter, modules_info):\n    \"\"\"Fix InLoadOrderModuleList double link list. First module is the main pe,\n    then ntdll, kernel32.\n\n    @jitter: the jitter instance\n    @modules_info: the LoadedModules instance\n    \"\"\"\n    log.debug('Fix InLoadOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant %r', special_modules)\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [main_pe]\n        loaded_modules[1:1] = [ntdll_pe]\n        loaded_modules[2:2] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 0)",
        "mutated": [
            "def fix_InLoadOrderModuleList(jitter, modules_info):\n    if False:\n        i = 10\n    'Fix InLoadOrderModuleList double link list. First module is the main pe,\\n    then ntdll, kernel32.\\n\\n    @jitter: the jitter instance\\n    @modules_info: the LoadedModules instance\\n    '\n    log.debug('Fix InLoadOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant %r', special_modules)\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [main_pe]\n        loaded_modules[1:1] = [ntdll_pe]\n        loaded_modules[2:2] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 0)",
            "def fix_InLoadOrderModuleList(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Fix InLoadOrderModuleList double link list. First module is the main pe,\\n    then ntdll, kernel32.\\n\\n    @jitter: the jitter instance\\n    @modules_info: the LoadedModules instance\\n    '\n    log.debug('Fix InLoadOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant %r', special_modules)\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [main_pe]\n        loaded_modules[1:1] = [ntdll_pe]\n        loaded_modules[2:2] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 0)",
            "def fix_InLoadOrderModuleList(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Fix InLoadOrderModuleList double link list. First module is the main pe,\\n    then ntdll, kernel32.\\n\\n    @jitter: the jitter instance\\n    @modules_info: the LoadedModules instance\\n    '\n    log.debug('Fix InLoadOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant %r', special_modules)\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [main_pe]\n        loaded_modules[1:1] = [ntdll_pe]\n        loaded_modules[2:2] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 0)",
            "def fix_InLoadOrderModuleList(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Fix InLoadOrderModuleList double link list. First module is the main pe,\\n    then ntdll, kernel32.\\n\\n    @jitter: the jitter instance\\n    @modules_info: the LoadedModules instance\\n    '\n    log.debug('Fix InLoadOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant %r', special_modules)\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [main_pe]\n        loaded_modules[1:1] = [ntdll_pe]\n        loaded_modules[2:2] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 0)",
            "def fix_InLoadOrderModuleList(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Fix InLoadOrderModuleList double link list. First module is the main pe,\\n    then ntdll, kernel32.\\n\\n    @jitter: the jitter instance\\n    @modules_info: the LoadedModules instance\\n    '\n    log.debug('Fix InLoadOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant %r', special_modules)\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [main_pe]\n        loaded_modules[1:1] = [ntdll_pe]\n        loaded_modules[2:2] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 0)"
        ]
    },
    {
        "func_name": "fix_InMemoryOrderModuleList",
        "original": "def fix_InMemoryOrderModuleList(jitter, modules_info):\n    \"\"\"Fix InMemoryOrderLinks double link list. First module is the main pe,\n    then ntdll, kernel32.\n\n    @jitter: the jitter instance\n    @modules_info: the LoadedModules instance\n    \"\"\"\n    log.debug('Fix InMemoryOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant')\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [main_pe]\n        loaded_modules[1:1] = [ntdll_pe]\n        loaded_modules[2:2] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 8)",
        "mutated": [
            "def fix_InMemoryOrderModuleList(jitter, modules_info):\n    if False:\n        i = 10\n    'Fix InMemoryOrderLinks double link list. First module is the main pe,\\n    then ntdll, kernel32.\\n\\n    @jitter: the jitter instance\\n    @modules_info: the LoadedModules instance\\n    '\n    log.debug('Fix InMemoryOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant')\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [main_pe]\n        loaded_modules[1:1] = [ntdll_pe]\n        loaded_modules[2:2] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 8)",
            "def fix_InMemoryOrderModuleList(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Fix InMemoryOrderLinks double link list. First module is the main pe,\\n    then ntdll, kernel32.\\n\\n    @jitter: the jitter instance\\n    @modules_info: the LoadedModules instance\\n    '\n    log.debug('Fix InMemoryOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant')\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [main_pe]\n        loaded_modules[1:1] = [ntdll_pe]\n        loaded_modules[2:2] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 8)",
            "def fix_InMemoryOrderModuleList(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Fix InMemoryOrderLinks double link list. First module is the main pe,\\n    then ntdll, kernel32.\\n\\n    @jitter: the jitter instance\\n    @modules_info: the LoadedModules instance\\n    '\n    log.debug('Fix InMemoryOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant')\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [main_pe]\n        loaded_modules[1:1] = [ntdll_pe]\n        loaded_modules[2:2] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 8)",
            "def fix_InMemoryOrderModuleList(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Fix InMemoryOrderLinks double link list. First module is the main pe,\\n    then ntdll, kernel32.\\n\\n    @jitter: the jitter instance\\n    @modules_info: the LoadedModules instance\\n    '\n    log.debug('Fix InMemoryOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant')\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [main_pe]\n        loaded_modules[1:1] = [ntdll_pe]\n        loaded_modules[2:2] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 8)",
            "def fix_InMemoryOrderModuleList(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Fix InMemoryOrderLinks double link list. First module is the main pe,\\n    then ntdll, kernel32.\\n\\n    @jitter: the jitter instance\\n    @modules_info: the LoadedModules instance\\n    '\n    log.debug('Fix InMemoryOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant')\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [main_pe]\n        loaded_modules[1:1] = [ntdll_pe]\n        loaded_modules[2:2] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 8)"
        ]
    },
    {
        "func_name": "fix_InInitializationOrderModuleList",
        "original": "def fix_InInitializationOrderModuleList(jitter, modules_info):\n    \"\"\"Fix InInitializationOrderModuleList double link list. First module is the\n    ntdll, then kernel32.\n\n    @jitter: the jitter instance\n    @modules_info: the LoadedModules instance\n\n    \"\"\"\n    log.debug('Fix InInitializationOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant')\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [ntdll_pe]\n        loaded_modules[1:1] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 16)",
        "mutated": [
            "def fix_InInitializationOrderModuleList(jitter, modules_info):\n    if False:\n        i = 10\n    'Fix InInitializationOrderModuleList double link list. First module is the\\n    ntdll, then kernel32.\\n\\n    @jitter: the jitter instance\\n    @modules_info: the LoadedModules instance\\n\\n    '\n    log.debug('Fix InInitializationOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant')\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [ntdll_pe]\n        loaded_modules[1:1] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 16)",
            "def fix_InInitializationOrderModuleList(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Fix InInitializationOrderModuleList double link list. First module is the\\n    ntdll, then kernel32.\\n\\n    @jitter: the jitter instance\\n    @modules_info: the LoadedModules instance\\n\\n    '\n    log.debug('Fix InInitializationOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant')\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [ntdll_pe]\n        loaded_modules[1:1] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 16)",
            "def fix_InInitializationOrderModuleList(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Fix InInitializationOrderModuleList double link list. First module is the\\n    ntdll, then kernel32.\\n\\n    @jitter: the jitter instance\\n    @modules_info: the LoadedModules instance\\n\\n    '\n    log.debug('Fix InInitializationOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant')\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [ntdll_pe]\n        loaded_modules[1:1] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 16)",
            "def fix_InInitializationOrderModuleList(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Fix InInitializationOrderModuleList double link list. First module is the\\n    ntdll, then kernel32.\\n\\n    @jitter: the jitter instance\\n    @modules_info: the LoadedModules instance\\n\\n    '\n    log.debug('Fix InInitializationOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant')\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [ntdll_pe]\n        loaded_modules[1:1] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 16)",
            "def fix_InInitializationOrderModuleList(jitter, modules_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Fix InInitializationOrderModuleList double link list. First module is the\\n    ntdll, then kernel32.\\n\\n    @jitter: the jitter instance\\n    @modules_info: the LoadedModules instance\\n\\n    '\n    log.debug('Fix InInitializationOrderModuleList')\n    main_pe = modules_info.name2module.get(main_pe_name, None)\n    kernel32_pe = modules_info.name2module.get('kernel32.dll', None)\n    ntdll_pe = modules_info.name2module.get('ntdll.dll', None)\n    special_modules = [main_pe, kernel32_pe, ntdll_pe]\n    if not all(special_modules):\n        log.warn('No main pe, ldr data will be unconsistant')\n        loaded_modules = modules_info.modules\n    else:\n        loaded_modules = [module for module in modules_info.modules if module not in special_modules]\n        loaded_modules[0:0] = [ntdll_pe]\n        loaded_modules[1:1] = [kernel32_pe]\n    set_link_list_entry(jitter, loaded_modules, modules_info, 16)"
        ]
    },
    {
        "func_name": "add_process_env",
        "original": "def add_process_env(jitter):\n    \"\"\"\n    Build a process environment structure\n    @jitter: jitter instance\n    \"\"\"\n    env_unicode = 'ALLUSEESPROFILE=C:\\\\Documents and Settings\\\\All Users\\x00'.encode('utf-16le')\n    env_unicode += b'\\x00' * 16\n    jitter.vm.add_memory_page(process_environment_address, PAGE_READ | PAGE_WRITE, env_unicode, 'Process environment')\n    jitter.vm.set_mem(process_environment_address, env_unicode)",
        "mutated": [
            "def add_process_env(jitter):\n    if False:\n        i = 10\n    '\\n    Build a process environment structure\\n    @jitter: jitter instance\\n    '\n    env_unicode = 'ALLUSEESPROFILE=C:\\\\Documents and Settings\\\\All Users\\x00'.encode('utf-16le')\n    env_unicode += b'\\x00' * 16\n    jitter.vm.add_memory_page(process_environment_address, PAGE_READ | PAGE_WRITE, env_unicode, 'Process environment')\n    jitter.vm.set_mem(process_environment_address, env_unicode)",
            "def add_process_env(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Build a process environment structure\\n    @jitter: jitter instance\\n    '\n    env_unicode = 'ALLUSEESPROFILE=C:\\\\Documents and Settings\\\\All Users\\x00'.encode('utf-16le')\n    env_unicode += b'\\x00' * 16\n    jitter.vm.add_memory_page(process_environment_address, PAGE_READ | PAGE_WRITE, env_unicode, 'Process environment')\n    jitter.vm.set_mem(process_environment_address, env_unicode)",
            "def add_process_env(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Build a process environment structure\\n    @jitter: jitter instance\\n    '\n    env_unicode = 'ALLUSEESPROFILE=C:\\\\Documents and Settings\\\\All Users\\x00'.encode('utf-16le')\n    env_unicode += b'\\x00' * 16\n    jitter.vm.add_memory_page(process_environment_address, PAGE_READ | PAGE_WRITE, env_unicode, 'Process environment')\n    jitter.vm.set_mem(process_environment_address, env_unicode)",
            "def add_process_env(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Build a process environment structure\\n    @jitter: jitter instance\\n    '\n    env_unicode = 'ALLUSEESPROFILE=C:\\\\Documents and Settings\\\\All Users\\x00'.encode('utf-16le')\n    env_unicode += b'\\x00' * 16\n    jitter.vm.add_memory_page(process_environment_address, PAGE_READ | PAGE_WRITE, env_unicode, 'Process environment')\n    jitter.vm.set_mem(process_environment_address, env_unicode)",
            "def add_process_env(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Build a process environment structure\\n    @jitter: jitter instance\\n    '\n    env_unicode = 'ALLUSEESPROFILE=C:\\\\Documents and Settings\\\\All Users\\x00'.encode('utf-16le')\n    env_unicode += b'\\x00' * 16\n    jitter.vm.add_memory_page(process_environment_address, PAGE_READ | PAGE_WRITE, env_unicode, 'Process environment')\n    jitter.vm.set_mem(process_environment_address, env_unicode)"
        ]
    },
    {
        "func_name": "add_process_parameters",
        "original": "def add_process_parameters(jitter):\n    \"\"\"\n    Build a process parameters structure\n    @jitter: jitter instance\n    \"\"\"\n    o = b''\n    o += pck32(4096)\n    o += b'E' * (72 - len(o))\n    o += pck32(process_environment_address)\n    jitter.vm.add_memory_page(process_parameters_address, PAGE_READ | PAGE_WRITE, o, 'Process parameters')",
        "mutated": [
            "def add_process_parameters(jitter):\n    if False:\n        i = 10\n    '\\n    Build a process parameters structure\\n    @jitter: jitter instance\\n    '\n    o = b''\n    o += pck32(4096)\n    o += b'E' * (72 - len(o))\n    o += pck32(process_environment_address)\n    jitter.vm.add_memory_page(process_parameters_address, PAGE_READ | PAGE_WRITE, o, 'Process parameters')",
            "def add_process_parameters(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Build a process parameters structure\\n    @jitter: jitter instance\\n    '\n    o = b''\n    o += pck32(4096)\n    o += b'E' * (72 - len(o))\n    o += pck32(process_environment_address)\n    jitter.vm.add_memory_page(process_parameters_address, PAGE_READ | PAGE_WRITE, o, 'Process parameters')",
            "def add_process_parameters(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Build a process parameters structure\\n    @jitter: jitter instance\\n    '\n    o = b''\n    o += pck32(4096)\n    o += b'E' * (72 - len(o))\n    o += pck32(process_environment_address)\n    jitter.vm.add_memory_page(process_parameters_address, PAGE_READ | PAGE_WRITE, o, 'Process parameters')",
            "def add_process_parameters(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Build a process parameters structure\\n    @jitter: jitter instance\\n    '\n    o = b''\n    o += pck32(4096)\n    o += b'E' * (72 - len(o))\n    o += pck32(process_environment_address)\n    jitter.vm.add_memory_page(process_parameters_address, PAGE_READ | PAGE_WRITE, o, 'Process parameters')",
            "def add_process_parameters(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Build a process parameters structure\\n    @jitter: jitter instance\\n    '\n    o = b''\n    o += pck32(4096)\n    o += b'E' * (72 - len(o))\n    o += pck32(process_environment_address)\n    jitter.vm.add_memory_page(process_parameters_address, PAGE_READ | PAGE_WRITE, o, 'Process parameters')"
        ]
    },
    {
        "func_name": "init_seh",
        "original": "def init_seh(jitter):\n    \"\"\"\n    Build the modules entries and create double links\n    @jitter: jitter instance\n    \"\"\"\n    global seh_count\n    seh_count = 0\n    tib_ad = jitter.cpu.get_segm_base(jitter.cpu.FS)\n    build_teb(jitter, tib_ad)\n    build_peb(jitter, peb_address)\n    modules_info = create_modules_chain(jitter, name2module)\n    fix_InLoadOrderModuleList(jitter, modules_info)\n    fix_InMemoryOrderModuleList(jitter, modules_info)\n    fix_InInitializationOrderModuleList(jitter, modules_info)\n    build_ldr_data(jitter, modules_info)\n    add_process_env(jitter)\n    add_process_parameters(jitter)",
        "mutated": [
            "def init_seh(jitter):\n    if False:\n        i = 10\n    '\\n    Build the modules entries and create double links\\n    @jitter: jitter instance\\n    '\n    global seh_count\n    seh_count = 0\n    tib_ad = jitter.cpu.get_segm_base(jitter.cpu.FS)\n    build_teb(jitter, tib_ad)\n    build_peb(jitter, peb_address)\n    modules_info = create_modules_chain(jitter, name2module)\n    fix_InLoadOrderModuleList(jitter, modules_info)\n    fix_InMemoryOrderModuleList(jitter, modules_info)\n    fix_InInitializationOrderModuleList(jitter, modules_info)\n    build_ldr_data(jitter, modules_info)\n    add_process_env(jitter)\n    add_process_parameters(jitter)",
            "def init_seh(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Build the modules entries and create double links\\n    @jitter: jitter instance\\n    '\n    global seh_count\n    seh_count = 0\n    tib_ad = jitter.cpu.get_segm_base(jitter.cpu.FS)\n    build_teb(jitter, tib_ad)\n    build_peb(jitter, peb_address)\n    modules_info = create_modules_chain(jitter, name2module)\n    fix_InLoadOrderModuleList(jitter, modules_info)\n    fix_InMemoryOrderModuleList(jitter, modules_info)\n    fix_InInitializationOrderModuleList(jitter, modules_info)\n    build_ldr_data(jitter, modules_info)\n    add_process_env(jitter)\n    add_process_parameters(jitter)",
            "def init_seh(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Build the modules entries and create double links\\n    @jitter: jitter instance\\n    '\n    global seh_count\n    seh_count = 0\n    tib_ad = jitter.cpu.get_segm_base(jitter.cpu.FS)\n    build_teb(jitter, tib_ad)\n    build_peb(jitter, peb_address)\n    modules_info = create_modules_chain(jitter, name2module)\n    fix_InLoadOrderModuleList(jitter, modules_info)\n    fix_InMemoryOrderModuleList(jitter, modules_info)\n    fix_InInitializationOrderModuleList(jitter, modules_info)\n    build_ldr_data(jitter, modules_info)\n    add_process_env(jitter)\n    add_process_parameters(jitter)",
            "def init_seh(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Build the modules entries and create double links\\n    @jitter: jitter instance\\n    '\n    global seh_count\n    seh_count = 0\n    tib_ad = jitter.cpu.get_segm_base(jitter.cpu.FS)\n    build_teb(jitter, tib_ad)\n    build_peb(jitter, peb_address)\n    modules_info = create_modules_chain(jitter, name2module)\n    fix_InLoadOrderModuleList(jitter, modules_info)\n    fix_InMemoryOrderModuleList(jitter, modules_info)\n    fix_InInitializationOrderModuleList(jitter, modules_info)\n    build_ldr_data(jitter, modules_info)\n    add_process_env(jitter)\n    add_process_parameters(jitter)",
            "def init_seh(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Build the modules entries and create double links\\n    @jitter: jitter instance\\n    '\n    global seh_count\n    seh_count = 0\n    tib_ad = jitter.cpu.get_segm_base(jitter.cpu.FS)\n    build_teb(jitter, tib_ad)\n    build_peb(jitter, peb_address)\n    modules_info = create_modules_chain(jitter, name2module)\n    fix_InLoadOrderModuleList(jitter, modules_info)\n    fix_InMemoryOrderModuleList(jitter, modules_info)\n    fix_InInitializationOrderModuleList(jitter, modules_info)\n    build_ldr_data(jitter, modules_info)\n    add_process_env(jitter)\n    add_process_parameters(jitter)"
        ]
    },
    {
        "func_name": "regs2ctxt",
        "original": "def regs2ctxt(jitter, context_address):\n    \"\"\"\n    Build x86_32 cpu context for exception handling\n    @jitter: jitload instance\n    \"\"\"\n    ctxt = ContextException(jitter.vm, context_address)\n    ctxt.memset(b'\\x00')\n    ctxt.dr0 = 0\n    ctxt.dr1 = 0\n    ctxt.dr2 = 0\n    ctxt.dr3 = 0\n    ctxt.dr4 = 0\n    ctxt.dr5 = 0\n    ctxt.gs = jitter.cpu.GS\n    ctxt.fs = jitter.cpu.FS\n    ctxt.es = jitter.cpu.ES\n    ctxt.ds = jitter.cpu.DS\n    ctxt.edi = jitter.cpu.EDI\n    ctxt.esi = jitter.cpu.ESI\n    ctxt.ebx = jitter.cpu.EBX\n    ctxt.edx = jitter.cpu.EDX\n    ctxt.ecx = jitter.cpu.ECX\n    ctxt.eax = jitter.cpu.EAX\n    ctxt.ebp = jitter.cpu.EBP\n    ctxt.eip = jitter.cpu.EIP\n    ctxt.cs = jitter.cpu.CS\n    ctxt.esp = jitter.cpu.ESP\n    ctxt.ss = jitter.cpu.SS",
        "mutated": [
            "def regs2ctxt(jitter, context_address):\n    if False:\n        i = 10\n    '\\n    Build x86_32 cpu context for exception handling\\n    @jitter: jitload instance\\n    '\n    ctxt = ContextException(jitter.vm, context_address)\n    ctxt.memset(b'\\x00')\n    ctxt.dr0 = 0\n    ctxt.dr1 = 0\n    ctxt.dr2 = 0\n    ctxt.dr3 = 0\n    ctxt.dr4 = 0\n    ctxt.dr5 = 0\n    ctxt.gs = jitter.cpu.GS\n    ctxt.fs = jitter.cpu.FS\n    ctxt.es = jitter.cpu.ES\n    ctxt.ds = jitter.cpu.DS\n    ctxt.edi = jitter.cpu.EDI\n    ctxt.esi = jitter.cpu.ESI\n    ctxt.ebx = jitter.cpu.EBX\n    ctxt.edx = jitter.cpu.EDX\n    ctxt.ecx = jitter.cpu.ECX\n    ctxt.eax = jitter.cpu.EAX\n    ctxt.ebp = jitter.cpu.EBP\n    ctxt.eip = jitter.cpu.EIP\n    ctxt.cs = jitter.cpu.CS\n    ctxt.esp = jitter.cpu.ESP\n    ctxt.ss = jitter.cpu.SS",
            "def regs2ctxt(jitter, context_address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Build x86_32 cpu context for exception handling\\n    @jitter: jitload instance\\n    '\n    ctxt = ContextException(jitter.vm, context_address)\n    ctxt.memset(b'\\x00')\n    ctxt.dr0 = 0\n    ctxt.dr1 = 0\n    ctxt.dr2 = 0\n    ctxt.dr3 = 0\n    ctxt.dr4 = 0\n    ctxt.dr5 = 0\n    ctxt.gs = jitter.cpu.GS\n    ctxt.fs = jitter.cpu.FS\n    ctxt.es = jitter.cpu.ES\n    ctxt.ds = jitter.cpu.DS\n    ctxt.edi = jitter.cpu.EDI\n    ctxt.esi = jitter.cpu.ESI\n    ctxt.ebx = jitter.cpu.EBX\n    ctxt.edx = jitter.cpu.EDX\n    ctxt.ecx = jitter.cpu.ECX\n    ctxt.eax = jitter.cpu.EAX\n    ctxt.ebp = jitter.cpu.EBP\n    ctxt.eip = jitter.cpu.EIP\n    ctxt.cs = jitter.cpu.CS\n    ctxt.esp = jitter.cpu.ESP\n    ctxt.ss = jitter.cpu.SS",
            "def regs2ctxt(jitter, context_address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Build x86_32 cpu context for exception handling\\n    @jitter: jitload instance\\n    '\n    ctxt = ContextException(jitter.vm, context_address)\n    ctxt.memset(b'\\x00')\n    ctxt.dr0 = 0\n    ctxt.dr1 = 0\n    ctxt.dr2 = 0\n    ctxt.dr3 = 0\n    ctxt.dr4 = 0\n    ctxt.dr5 = 0\n    ctxt.gs = jitter.cpu.GS\n    ctxt.fs = jitter.cpu.FS\n    ctxt.es = jitter.cpu.ES\n    ctxt.ds = jitter.cpu.DS\n    ctxt.edi = jitter.cpu.EDI\n    ctxt.esi = jitter.cpu.ESI\n    ctxt.ebx = jitter.cpu.EBX\n    ctxt.edx = jitter.cpu.EDX\n    ctxt.ecx = jitter.cpu.ECX\n    ctxt.eax = jitter.cpu.EAX\n    ctxt.ebp = jitter.cpu.EBP\n    ctxt.eip = jitter.cpu.EIP\n    ctxt.cs = jitter.cpu.CS\n    ctxt.esp = jitter.cpu.ESP\n    ctxt.ss = jitter.cpu.SS",
            "def regs2ctxt(jitter, context_address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Build x86_32 cpu context for exception handling\\n    @jitter: jitload instance\\n    '\n    ctxt = ContextException(jitter.vm, context_address)\n    ctxt.memset(b'\\x00')\n    ctxt.dr0 = 0\n    ctxt.dr1 = 0\n    ctxt.dr2 = 0\n    ctxt.dr3 = 0\n    ctxt.dr4 = 0\n    ctxt.dr5 = 0\n    ctxt.gs = jitter.cpu.GS\n    ctxt.fs = jitter.cpu.FS\n    ctxt.es = jitter.cpu.ES\n    ctxt.ds = jitter.cpu.DS\n    ctxt.edi = jitter.cpu.EDI\n    ctxt.esi = jitter.cpu.ESI\n    ctxt.ebx = jitter.cpu.EBX\n    ctxt.edx = jitter.cpu.EDX\n    ctxt.ecx = jitter.cpu.ECX\n    ctxt.eax = jitter.cpu.EAX\n    ctxt.ebp = jitter.cpu.EBP\n    ctxt.eip = jitter.cpu.EIP\n    ctxt.cs = jitter.cpu.CS\n    ctxt.esp = jitter.cpu.ESP\n    ctxt.ss = jitter.cpu.SS",
            "def regs2ctxt(jitter, context_address):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Build x86_32 cpu context for exception handling\\n    @jitter: jitload instance\\n    '\n    ctxt = ContextException(jitter.vm, context_address)\n    ctxt.memset(b'\\x00')\n    ctxt.dr0 = 0\n    ctxt.dr1 = 0\n    ctxt.dr2 = 0\n    ctxt.dr3 = 0\n    ctxt.dr4 = 0\n    ctxt.dr5 = 0\n    ctxt.gs = jitter.cpu.GS\n    ctxt.fs = jitter.cpu.FS\n    ctxt.es = jitter.cpu.ES\n    ctxt.ds = jitter.cpu.DS\n    ctxt.edi = jitter.cpu.EDI\n    ctxt.esi = jitter.cpu.ESI\n    ctxt.ebx = jitter.cpu.EBX\n    ctxt.edx = jitter.cpu.EDX\n    ctxt.ecx = jitter.cpu.ECX\n    ctxt.eax = jitter.cpu.EAX\n    ctxt.ebp = jitter.cpu.EBP\n    ctxt.eip = jitter.cpu.EIP\n    ctxt.cs = jitter.cpu.CS\n    ctxt.esp = jitter.cpu.ESP\n    ctxt.ss = jitter.cpu.SS"
        ]
    },
    {
        "func_name": "ctxt2regs",
        "original": "def ctxt2regs(jitter, ctxt_ptr):\n    \"\"\"\n    Restore x86_32 registers from an exception context\n    @ctxt: the serialized context\n    @jitter: jitload instance\n    \"\"\"\n    ctxt = ContextException(jitter.vm, ctxt_ptr)\n    jitter.cpu.GS = ctxt.gs\n    jitter.cpu.FS = ctxt.fs\n    jitter.cpu.ES = ctxt.es\n    jitter.cpu.DS = ctxt.ds\n    jitter.cpu.EDI = ctxt.edi\n    jitter.cpu.ESI = ctxt.esi\n    jitter.cpu.EBX = ctxt.ebx\n    jitter.cpu.EDX = ctxt.edx\n    jitter.cpu.ECX = ctxt.ecx\n    jitter.cpu.EAX = ctxt.eax\n    jitter.cpu.EBP = ctxt.ebp\n    jitter.cpu.EIP = ctxt.eip\n    jitter.cpu.CS = ctxt.cs\n    jitter.cpu.ESP = ctxt.esp\n    jitter.cpu.SS = ctxt.ss",
        "mutated": [
            "def ctxt2regs(jitter, ctxt_ptr):\n    if False:\n        i = 10\n    '\\n    Restore x86_32 registers from an exception context\\n    @ctxt: the serialized context\\n    @jitter: jitload instance\\n    '\n    ctxt = ContextException(jitter.vm, ctxt_ptr)\n    jitter.cpu.GS = ctxt.gs\n    jitter.cpu.FS = ctxt.fs\n    jitter.cpu.ES = ctxt.es\n    jitter.cpu.DS = ctxt.ds\n    jitter.cpu.EDI = ctxt.edi\n    jitter.cpu.ESI = ctxt.esi\n    jitter.cpu.EBX = ctxt.ebx\n    jitter.cpu.EDX = ctxt.edx\n    jitter.cpu.ECX = ctxt.ecx\n    jitter.cpu.EAX = ctxt.eax\n    jitter.cpu.EBP = ctxt.ebp\n    jitter.cpu.EIP = ctxt.eip\n    jitter.cpu.CS = ctxt.cs\n    jitter.cpu.ESP = ctxt.esp\n    jitter.cpu.SS = ctxt.ss",
            "def ctxt2regs(jitter, ctxt_ptr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Restore x86_32 registers from an exception context\\n    @ctxt: the serialized context\\n    @jitter: jitload instance\\n    '\n    ctxt = ContextException(jitter.vm, ctxt_ptr)\n    jitter.cpu.GS = ctxt.gs\n    jitter.cpu.FS = ctxt.fs\n    jitter.cpu.ES = ctxt.es\n    jitter.cpu.DS = ctxt.ds\n    jitter.cpu.EDI = ctxt.edi\n    jitter.cpu.ESI = ctxt.esi\n    jitter.cpu.EBX = ctxt.ebx\n    jitter.cpu.EDX = ctxt.edx\n    jitter.cpu.ECX = ctxt.ecx\n    jitter.cpu.EAX = ctxt.eax\n    jitter.cpu.EBP = ctxt.ebp\n    jitter.cpu.EIP = ctxt.eip\n    jitter.cpu.CS = ctxt.cs\n    jitter.cpu.ESP = ctxt.esp\n    jitter.cpu.SS = ctxt.ss",
            "def ctxt2regs(jitter, ctxt_ptr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Restore x86_32 registers from an exception context\\n    @ctxt: the serialized context\\n    @jitter: jitload instance\\n    '\n    ctxt = ContextException(jitter.vm, ctxt_ptr)\n    jitter.cpu.GS = ctxt.gs\n    jitter.cpu.FS = ctxt.fs\n    jitter.cpu.ES = ctxt.es\n    jitter.cpu.DS = ctxt.ds\n    jitter.cpu.EDI = ctxt.edi\n    jitter.cpu.ESI = ctxt.esi\n    jitter.cpu.EBX = ctxt.ebx\n    jitter.cpu.EDX = ctxt.edx\n    jitter.cpu.ECX = ctxt.ecx\n    jitter.cpu.EAX = ctxt.eax\n    jitter.cpu.EBP = ctxt.ebp\n    jitter.cpu.EIP = ctxt.eip\n    jitter.cpu.CS = ctxt.cs\n    jitter.cpu.ESP = ctxt.esp\n    jitter.cpu.SS = ctxt.ss",
            "def ctxt2regs(jitter, ctxt_ptr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Restore x86_32 registers from an exception context\\n    @ctxt: the serialized context\\n    @jitter: jitload instance\\n    '\n    ctxt = ContextException(jitter.vm, ctxt_ptr)\n    jitter.cpu.GS = ctxt.gs\n    jitter.cpu.FS = ctxt.fs\n    jitter.cpu.ES = ctxt.es\n    jitter.cpu.DS = ctxt.ds\n    jitter.cpu.EDI = ctxt.edi\n    jitter.cpu.ESI = ctxt.esi\n    jitter.cpu.EBX = ctxt.ebx\n    jitter.cpu.EDX = ctxt.edx\n    jitter.cpu.ECX = ctxt.ecx\n    jitter.cpu.EAX = ctxt.eax\n    jitter.cpu.EBP = ctxt.ebp\n    jitter.cpu.EIP = ctxt.eip\n    jitter.cpu.CS = ctxt.cs\n    jitter.cpu.ESP = ctxt.esp\n    jitter.cpu.SS = ctxt.ss",
            "def ctxt2regs(jitter, ctxt_ptr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Restore x86_32 registers from an exception context\\n    @ctxt: the serialized context\\n    @jitter: jitload instance\\n    '\n    ctxt = ContextException(jitter.vm, ctxt_ptr)\n    jitter.cpu.GS = ctxt.gs\n    jitter.cpu.FS = ctxt.fs\n    jitter.cpu.ES = ctxt.es\n    jitter.cpu.DS = ctxt.ds\n    jitter.cpu.EDI = ctxt.edi\n    jitter.cpu.ESI = ctxt.esi\n    jitter.cpu.EBX = ctxt.ebx\n    jitter.cpu.EDX = ctxt.edx\n    jitter.cpu.ECX = ctxt.ecx\n    jitter.cpu.EAX = ctxt.eax\n    jitter.cpu.EBP = ctxt.ebp\n    jitter.cpu.EIP = ctxt.eip\n    jitter.cpu.CS = ctxt.cs\n    jitter.cpu.ESP = ctxt.esp\n    jitter.cpu.SS = ctxt.ss"
        ]
    },
    {
        "func_name": "fake_seh_handler",
        "original": "def fake_seh_handler(jitter, except_code, previous_seh=None):\n    \"\"\"\n    Create an exception context\n    @jitter: jitter instance\n    @except_code: x86 exception code\n    @previous_seh: (optional) last SEH address when multiple SEH are used\n    \"\"\"\n    global seh_count\n    log.info('Exception at %x %r', jitter.cpu.EIP, seh_count)\n    seh_count += 1\n    new_ESP = jitter.cpu.ESP - 968\n    exception_base_address = new_ESP\n    exception_record_address = exception_base_address + 232\n    context_address = exception_base_address + 252\n    fake_seh_address = exception_base_address + 20\n    regs2ctxt(jitter, context_address)\n    jitter.cpu.ESP = new_ESP\n    tib = NT_TIB(jitter.vm, tib_address)\n    seh = tib.ExceptionList.deref\n    if previous_seh:\n        while seh.get_addr() != previous_seh:\n            seh = seh.Next.deref\n        seh = seh.Next.deref\n    log.debug('seh_ptr %x { old_seh %r eh %r} ctx_addr %x', seh.get_addr(), seh.Next, seh.Handler, context_address)\n    except_record = EXCEPTION_RECORD(jitter.vm, exception_record_address)\n    except_record.memset(b'\\x00')\n    except_record.ExceptionCode = except_code\n    except_record.ExceptionAddress = jitter.cpu.EIP\n    jitter.push_uint32_t(context_address)\n    jitter.push_uint32_t(seh.get_addr())\n    jitter.push_uint32_t(except_record.get_addr())\n    jitter.push_uint32_t(return_from_exception)\n    log.debug('Fake seh ad %x', fake_seh_address)\n    fake_seh = EXCEPTION_REGISTRATION_RECORD(jitter.vm, fake_seh_address)\n    fake_seh.Next.val = tib.ExceptionList.val\n    fake_seh.Handler = 2863311530\n    tib.ExceptionList.val = fake_seh.get_addr()\n    dump_seh(jitter)\n    jitter.vm.set_exception(0)\n    jitter.cpu.set_exception(0)\n    jitter.cpu.EBX = 0\n    log.debug('Jumping at %r', seh.Handler)\n    return seh.Handler.val",
        "mutated": [
            "def fake_seh_handler(jitter, except_code, previous_seh=None):\n    if False:\n        i = 10\n    '\\n    Create an exception context\\n    @jitter: jitter instance\\n    @except_code: x86 exception code\\n    @previous_seh: (optional) last SEH address when multiple SEH are used\\n    '\n    global seh_count\n    log.info('Exception at %x %r', jitter.cpu.EIP, seh_count)\n    seh_count += 1\n    new_ESP = jitter.cpu.ESP - 968\n    exception_base_address = new_ESP\n    exception_record_address = exception_base_address + 232\n    context_address = exception_base_address + 252\n    fake_seh_address = exception_base_address + 20\n    regs2ctxt(jitter, context_address)\n    jitter.cpu.ESP = new_ESP\n    tib = NT_TIB(jitter.vm, tib_address)\n    seh = tib.ExceptionList.deref\n    if previous_seh:\n        while seh.get_addr() != previous_seh:\n            seh = seh.Next.deref\n        seh = seh.Next.deref\n    log.debug('seh_ptr %x { old_seh %r eh %r} ctx_addr %x', seh.get_addr(), seh.Next, seh.Handler, context_address)\n    except_record = EXCEPTION_RECORD(jitter.vm, exception_record_address)\n    except_record.memset(b'\\x00')\n    except_record.ExceptionCode = except_code\n    except_record.ExceptionAddress = jitter.cpu.EIP\n    jitter.push_uint32_t(context_address)\n    jitter.push_uint32_t(seh.get_addr())\n    jitter.push_uint32_t(except_record.get_addr())\n    jitter.push_uint32_t(return_from_exception)\n    log.debug('Fake seh ad %x', fake_seh_address)\n    fake_seh = EXCEPTION_REGISTRATION_RECORD(jitter.vm, fake_seh_address)\n    fake_seh.Next.val = tib.ExceptionList.val\n    fake_seh.Handler = 2863311530\n    tib.ExceptionList.val = fake_seh.get_addr()\n    dump_seh(jitter)\n    jitter.vm.set_exception(0)\n    jitter.cpu.set_exception(0)\n    jitter.cpu.EBX = 0\n    log.debug('Jumping at %r', seh.Handler)\n    return seh.Handler.val",
            "def fake_seh_handler(jitter, except_code, previous_seh=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create an exception context\\n    @jitter: jitter instance\\n    @except_code: x86 exception code\\n    @previous_seh: (optional) last SEH address when multiple SEH are used\\n    '\n    global seh_count\n    log.info('Exception at %x %r', jitter.cpu.EIP, seh_count)\n    seh_count += 1\n    new_ESP = jitter.cpu.ESP - 968\n    exception_base_address = new_ESP\n    exception_record_address = exception_base_address + 232\n    context_address = exception_base_address + 252\n    fake_seh_address = exception_base_address + 20\n    regs2ctxt(jitter, context_address)\n    jitter.cpu.ESP = new_ESP\n    tib = NT_TIB(jitter.vm, tib_address)\n    seh = tib.ExceptionList.deref\n    if previous_seh:\n        while seh.get_addr() != previous_seh:\n            seh = seh.Next.deref\n        seh = seh.Next.deref\n    log.debug('seh_ptr %x { old_seh %r eh %r} ctx_addr %x', seh.get_addr(), seh.Next, seh.Handler, context_address)\n    except_record = EXCEPTION_RECORD(jitter.vm, exception_record_address)\n    except_record.memset(b'\\x00')\n    except_record.ExceptionCode = except_code\n    except_record.ExceptionAddress = jitter.cpu.EIP\n    jitter.push_uint32_t(context_address)\n    jitter.push_uint32_t(seh.get_addr())\n    jitter.push_uint32_t(except_record.get_addr())\n    jitter.push_uint32_t(return_from_exception)\n    log.debug('Fake seh ad %x', fake_seh_address)\n    fake_seh = EXCEPTION_REGISTRATION_RECORD(jitter.vm, fake_seh_address)\n    fake_seh.Next.val = tib.ExceptionList.val\n    fake_seh.Handler = 2863311530\n    tib.ExceptionList.val = fake_seh.get_addr()\n    dump_seh(jitter)\n    jitter.vm.set_exception(0)\n    jitter.cpu.set_exception(0)\n    jitter.cpu.EBX = 0\n    log.debug('Jumping at %r', seh.Handler)\n    return seh.Handler.val",
            "def fake_seh_handler(jitter, except_code, previous_seh=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create an exception context\\n    @jitter: jitter instance\\n    @except_code: x86 exception code\\n    @previous_seh: (optional) last SEH address when multiple SEH are used\\n    '\n    global seh_count\n    log.info('Exception at %x %r', jitter.cpu.EIP, seh_count)\n    seh_count += 1\n    new_ESP = jitter.cpu.ESP - 968\n    exception_base_address = new_ESP\n    exception_record_address = exception_base_address + 232\n    context_address = exception_base_address + 252\n    fake_seh_address = exception_base_address + 20\n    regs2ctxt(jitter, context_address)\n    jitter.cpu.ESP = new_ESP\n    tib = NT_TIB(jitter.vm, tib_address)\n    seh = tib.ExceptionList.deref\n    if previous_seh:\n        while seh.get_addr() != previous_seh:\n            seh = seh.Next.deref\n        seh = seh.Next.deref\n    log.debug('seh_ptr %x { old_seh %r eh %r} ctx_addr %x', seh.get_addr(), seh.Next, seh.Handler, context_address)\n    except_record = EXCEPTION_RECORD(jitter.vm, exception_record_address)\n    except_record.memset(b'\\x00')\n    except_record.ExceptionCode = except_code\n    except_record.ExceptionAddress = jitter.cpu.EIP\n    jitter.push_uint32_t(context_address)\n    jitter.push_uint32_t(seh.get_addr())\n    jitter.push_uint32_t(except_record.get_addr())\n    jitter.push_uint32_t(return_from_exception)\n    log.debug('Fake seh ad %x', fake_seh_address)\n    fake_seh = EXCEPTION_REGISTRATION_RECORD(jitter.vm, fake_seh_address)\n    fake_seh.Next.val = tib.ExceptionList.val\n    fake_seh.Handler = 2863311530\n    tib.ExceptionList.val = fake_seh.get_addr()\n    dump_seh(jitter)\n    jitter.vm.set_exception(0)\n    jitter.cpu.set_exception(0)\n    jitter.cpu.EBX = 0\n    log.debug('Jumping at %r', seh.Handler)\n    return seh.Handler.val",
            "def fake_seh_handler(jitter, except_code, previous_seh=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create an exception context\\n    @jitter: jitter instance\\n    @except_code: x86 exception code\\n    @previous_seh: (optional) last SEH address when multiple SEH are used\\n    '\n    global seh_count\n    log.info('Exception at %x %r', jitter.cpu.EIP, seh_count)\n    seh_count += 1\n    new_ESP = jitter.cpu.ESP - 968\n    exception_base_address = new_ESP\n    exception_record_address = exception_base_address + 232\n    context_address = exception_base_address + 252\n    fake_seh_address = exception_base_address + 20\n    regs2ctxt(jitter, context_address)\n    jitter.cpu.ESP = new_ESP\n    tib = NT_TIB(jitter.vm, tib_address)\n    seh = tib.ExceptionList.deref\n    if previous_seh:\n        while seh.get_addr() != previous_seh:\n            seh = seh.Next.deref\n        seh = seh.Next.deref\n    log.debug('seh_ptr %x { old_seh %r eh %r} ctx_addr %x', seh.get_addr(), seh.Next, seh.Handler, context_address)\n    except_record = EXCEPTION_RECORD(jitter.vm, exception_record_address)\n    except_record.memset(b'\\x00')\n    except_record.ExceptionCode = except_code\n    except_record.ExceptionAddress = jitter.cpu.EIP\n    jitter.push_uint32_t(context_address)\n    jitter.push_uint32_t(seh.get_addr())\n    jitter.push_uint32_t(except_record.get_addr())\n    jitter.push_uint32_t(return_from_exception)\n    log.debug('Fake seh ad %x', fake_seh_address)\n    fake_seh = EXCEPTION_REGISTRATION_RECORD(jitter.vm, fake_seh_address)\n    fake_seh.Next.val = tib.ExceptionList.val\n    fake_seh.Handler = 2863311530\n    tib.ExceptionList.val = fake_seh.get_addr()\n    dump_seh(jitter)\n    jitter.vm.set_exception(0)\n    jitter.cpu.set_exception(0)\n    jitter.cpu.EBX = 0\n    log.debug('Jumping at %r', seh.Handler)\n    return seh.Handler.val",
            "def fake_seh_handler(jitter, except_code, previous_seh=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create an exception context\\n    @jitter: jitter instance\\n    @except_code: x86 exception code\\n    @previous_seh: (optional) last SEH address when multiple SEH are used\\n    '\n    global seh_count\n    log.info('Exception at %x %r', jitter.cpu.EIP, seh_count)\n    seh_count += 1\n    new_ESP = jitter.cpu.ESP - 968\n    exception_base_address = new_ESP\n    exception_record_address = exception_base_address + 232\n    context_address = exception_base_address + 252\n    fake_seh_address = exception_base_address + 20\n    regs2ctxt(jitter, context_address)\n    jitter.cpu.ESP = new_ESP\n    tib = NT_TIB(jitter.vm, tib_address)\n    seh = tib.ExceptionList.deref\n    if previous_seh:\n        while seh.get_addr() != previous_seh:\n            seh = seh.Next.deref\n        seh = seh.Next.deref\n    log.debug('seh_ptr %x { old_seh %r eh %r} ctx_addr %x', seh.get_addr(), seh.Next, seh.Handler, context_address)\n    except_record = EXCEPTION_RECORD(jitter.vm, exception_record_address)\n    except_record.memset(b'\\x00')\n    except_record.ExceptionCode = except_code\n    except_record.ExceptionAddress = jitter.cpu.EIP\n    jitter.push_uint32_t(context_address)\n    jitter.push_uint32_t(seh.get_addr())\n    jitter.push_uint32_t(except_record.get_addr())\n    jitter.push_uint32_t(return_from_exception)\n    log.debug('Fake seh ad %x', fake_seh_address)\n    fake_seh = EXCEPTION_REGISTRATION_RECORD(jitter.vm, fake_seh_address)\n    fake_seh.Next.val = tib.ExceptionList.val\n    fake_seh.Handler = 2863311530\n    tib.ExceptionList.val = fake_seh.get_addr()\n    dump_seh(jitter)\n    jitter.vm.set_exception(0)\n    jitter.cpu.set_exception(0)\n    jitter.cpu.EBX = 0\n    log.debug('Jumping at %r', seh.Handler)\n    return seh.Handler.val"
        ]
    },
    {
        "func_name": "dump_seh",
        "original": "def dump_seh(jitter):\n    \"\"\"\n    Walk and dump the SEH entries\n    @jitter: jitter instance\n    \"\"\"\n    log.debug('Dump_seh. Tib_address: %x', tib_address)\n    cur_seh_ptr = NT_TIB(jitter.vm, tib_address).ExceptionList\n    loop = 0\n    while cur_seh_ptr and jitter.vm.is_mapped(cur_seh_ptr.val, len(cur_seh_ptr)):\n        if loop > MAX_SEH:\n            log.debug('Too many seh, quit')\n            return\n        err = cur_seh_ptr.deref\n        log.debug('\\t' * (loop + 1) + 'seh_ptr: %x { prev_seh: %r eh %r }', err.get_addr(), err.Next, err.Handler)\n        cur_seh_ptr = err.Next\n        loop += 1",
        "mutated": [
            "def dump_seh(jitter):\n    if False:\n        i = 10\n    '\\n    Walk and dump the SEH entries\\n    @jitter: jitter instance\\n    '\n    log.debug('Dump_seh. Tib_address: %x', tib_address)\n    cur_seh_ptr = NT_TIB(jitter.vm, tib_address).ExceptionList\n    loop = 0\n    while cur_seh_ptr and jitter.vm.is_mapped(cur_seh_ptr.val, len(cur_seh_ptr)):\n        if loop > MAX_SEH:\n            log.debug('Too many seh, quit')\n            return\n        err = cur_seh_ptr.deref\n        log.debug('\\t' * (loop + 1) + 'seh_ptr: %x { prev_seh: %r eh %r }', err.get_addr(), err.Next, err.Handler)\n        cur_seh_ptr = err.Next\n        loop += 1",
            "def dump_seh(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Walk and dump the SEH entries\\n    @jitter: jitter instance\\n    '\n    log.debug('Dump_seh. Tib_address: %x', tib_address)\n    cur_seh_ptr = NT_TIB(jitter.vm, tib_address).ExceptionList\n    loop = 0\n    while cur_seh_ptr and jitter.vm.is_mapped(cur_seh_ptr.val, len(cur_seh_ptr)):\n        if loop > MAX_SEH:\n            log.debug('Too many seh, quit')\n            return\n        err = cur_seh_ptr.deref\n        log.debug('\\t' * (loop + 1) + 'seh_ptr: %x { prev_seh: %r eh %r }', err.get_addr(), err.Next, err.Handler)\n        cur_seh_ptr = err.Next\n        loop += 1",
            "def dump_seh(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Walk and dump the SEH entries\\n    @jitter: jitter instance\\n    '\n    log.debug('Dump_seh. Tib_address: %x', tib_address)\n    cur_seh_ptr = NT_TIB(jitter.vm, tib_address).ExceptionList\n    loop = 0\n    while cur_seh_ptr and jitter.vm.is_mapped(cur_seh_ptr.val, len(cur_seh_ptr)):\n        if loop > MAX_SEH:\n            log.debug('Too many seh, quit')\n            return\n        err = cur_seh_ptr.deref\n        log.debug('\\t' * (loop + 1) + 'seh_ptr: %x { prev_seh: %r eh %r }', err.get_addr(), err.Next, err.Handler)\n        cur_seh_ptr = err.Next\n        loop += 1",
            "def dump_seh(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Walk and dump the SEH entries\\n    @jitter: jitter instance\\n    '\n    log.debug('Dump_seh. Tib_address: %x', tib_address)\n    cur_seh_ptr = NT_TIB(jitter.vm, tib_address).ExceptionList\n    loop = 0\n    while cur_seh_ptr and jitter.vm.is_mapped(cur_seh_ptr.val, len(cur_seh_ptr)):\n        if loop > MAX_SEH:\n            log.debug('Too many seh, quit')\n            return\n        err = cur_seh_ptr.deref\n        log.debug('\\t' * (loop + 1) + 'seh_ptr: %x { prev_seh: %r eh %r }', err.get_addr(), err.Next, err.Handler)\n        cur_seh_ptr = err.Next\n        loop += 1",
            "def dump_seh(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Walk and dump the SEH entries\\n    @jitter: jitter instance\\n    '\n    log.debug('Dump_seh. Tib_address: %x', tib_address)\n    cur_seh_ptr = NT_TIB(jitter.vm, tib_address).ExceptionList\n    loop = 0\n    while cur_seh_ptr and jitter.vm.is_mapped(cur_seh_ptr.val, len(cur_seh_ptr)):\n        if loop > MAX_SEH:\n            log.debug('Too many seh, quit')\n            return\n        err = cur_seh_ptr.deref\n        log.debug('\\t' * (loop + 1) + 'seh_ptr: %x { prev_seh: %r eh %r }', err.get_addr(), err.Next, err.Handler)\n        cur_seh_ptr = err.Next\n        loop += 1"
        ]
    },
    {
        "func_name": "set_win_fs_0",
        "original": "def set_win_fs_0(jitter, fs=4):\n    \"\"\"\n    Set FS segment selector and create its corresponding segment\n    @jitter: jitter instance\n    @fs: segment selector value\n    \"\"\"\n    jitter.cpu.FS = fs\n    jitter.cpu.set_segm_base(fs, tib_address)\n    segm_to_do = set([x86_regs.FS])\n    return segm_to_do",
        "mutated": [
            "def set_win_fs_0(jitter, fs=4):\n    if False:\n        i = 10\n    '\\n    Set FS segment selector and create its corresponding segment\\n    @jitter: jitter instance\\n    @fs: segment selector value\\n    '\n    jitter.cpu.FS = fs\n    jitter.cpu.set_segm_base(fs, tib_address)\n    segm_to_do = set([x86_regs.FS])\n    return segm_to_do",
            "def set_win_fs_0(jitter, fs=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Set FS segment selector and create its corresponding segment\\n    @jitter: jitter instance\\n    @fs: segment selector value\\n    '\n    jitter.cpu.FS = fs\n    jitter.cpu.set_segm_base(fs, tib_address)\n    segm_to_do = set([x86_regs.FS])\n    return segm_to_do",
            "def set_win_fs_0(jitter, fs=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Set FS segment selector and create its corresponding segment\\n    @jitter: jitter instance\\n    @fs: segment selector value\\n    '\n    jitter.cpu.FS = fs\n    jitter.cpu.set_segm_base(fs, tib_address)\n    segm_to_do = set([x86_regs.FS])\n    return segm_to_do",
            "def set_win_fs_0(jitter, fs=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Set FS segment selector and create its corresponding segment\\n    @jitter: jitter instance\\n    @fs: segment selector value\\n    '\n    jitter.cpu.FS = fs\n    jitter.cpu.set_segm_base(fs, tib_address)\n    segm_to_do = set([x86_regs.FS])\n    return segm_to_do",
            "def set_win_fs_0(jitter, fs=4):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Set FS segment selector and create its corresponding segment\\n    @jitter: jitter instance\\n    @fs: segment selector value\\n    '\n    jitter.cpu.FS = fs\n    jitter.cpu.set_segm_base(fs, tib_address)\n    segm_to_do = set([x86_regs.FS])\n    return segm_to_do"
        ]
    },
    {
        "func_name": "return_from_seh",
        "original": "def return_from_seh(jitter):\n    \"\"\"Handle the return from an exception handler\n    @jitter: jitter instance\"\"\"\n    seh_address = jitter.vm.get_u32(jitter.cpu.ESP + 4)\n    context_address = jitter.vm.get_u32(jitter.cpu.ESP + 8)\n    log.debug('Context address: %x', context_address)\n    status = jitter.cpu.EAX\n    ctxt2regs(jitter, context_address)\n    tib = NT_TIB(jitter.vm, tib_address)\n    seh = tib.ExceptionList.deref\n    log.debug('Old seh: %x New seh: %x', seh.get_addr(), seh.Next.val)\n    tib.ExceptionList.val = seh.Next.val\n    dump_seh(jitter)\n    if status == 0:\n        log.debug('SEH continue')\n        jitter.pc = jitter.cpu.EIP\n        log.debug('Context::Eip: %x', jitter.pc)\n    elif status == 1:\n        log.debug('Delegate to the next SEH handler')\n        exception_record = EXCEPTION_RECORD(jitter.vm, context_address - 252 + 232)\n        pc = fake_seh_handler(jitter, exception_record.ExceptionCode, seh_address)\n        jitter.pc = pc\n    else:\n        raise ValueError('Valid values are ExceptionContinueExecution and ExceptionContinueSearch')\n    return True",
        "mutated": [
            "def return_from_seh(jitter):\n    if False:\n        i = 10\n    'Handle the return from an exception handler\\n    @jitter: jitter instance'\n    seh_address = jitter.vm.get_u32(jitter.cpu.ESP + 4)\n    context_address = jitter.vm.get_u32(jitter.cpu.ESP + 8)\n    log.debug('Context address: %x', context_address)\n    status = jitter.cpu.EAX\n    ctxt2regs(jitter, context_address)\n    tib = NT_TIB(jitter.vm, tib_address)\n    seh = tib.ExceptionList.deref\n    log.debug('Old seh: %x New seh: %x', seh.get_addr(), seh.Next.val)\n    tib.ExceptionList.val = seh.Next.val\n    dump_seh(jitter)\n    if status == 0:\n        log.debug('SEH continue')\n        jitter.pc = jitter.cpu.EIP\n        log.debug('Context::Eip: %x', jitter.pc)\n    elif status == 1:\n        log.debug('Delegate to the next SEH handler')\n        exception_record = EXCEPTION_RECORD(jitter.vm, context_address - 252 + 232)\n        pc = fake_seh_handler(jitter, exception_record.ExceptionCode, seh_address)\n        jitter.pc = pc\n    else:\n        raise ValueError('Valid values are ExceptionContinueExecution and ExceptionContinueSearch')\n    return True",
            "def return_from_seh(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Handle the return from an exception handler\\n    @jitter: jitter instance'\n    seh_address = jitter.vm.get_u32(jitter.cpu.ESP + 4)\n    context_address = jitter.vm.get_u32(jitter.cpu.ESP + 8)\n    log.debug('Context address: %x', context_address)\n    status = jitter.cpu.EAX\n    ctxt2regs(jitter, context_address)\n    tib = NT_TIB(jitter.vm, tib_address)\n    seh = tib.ExceptionList.deref\n    log.debug('Old seh: %x New seh: %x', seh.get_addr(), seh.Next.val)\n    tib.ExceptionList.val = seh.Next.val\n    dump_seh(jitter)\n    if status == 0:\n        log.debug('SEH continue')\n        jitter.pc = jitter.cpu.EIP\n        log.debug('Context::Eip: %x', jitter.pc)\n    elif status == 1:\n        log.debug('Delegate to the next SEH handler')\n        exception_record = EXCEPTION_RECORD(jitter.vm, context_address - 252 + 232)\n        pc = fake_seh_handler(jitter, exception_record.ExceptionCode, seh_address)\n        jitter.pc = pc\n    else:\n        raise ValueError('Valid values are ExceptionContinueExecution and ExceptionContinueSearch')\n    return True",
            "def return_from_seh(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Handle the return from an exception handler\\n    @jitter: jitter instance'\n    seh_address = jitter.vm.get_u32(jitter.cpu.ESP + 4)\n    context_address = jitter.vm.get_u32(jitter.cpu.ESP + 8)\n    log.debug('Context address: %x', context_address)\n    status = jitter.cpu.EAX\n    ctxt2regs(jitter, context_address)\n    tib = NT_TIB(jitter.vm, tib_address)\n    seh = tib.ExceptionList.deref\n    log.debug('Old seh: %x New seh: %x', seh.get_addr(), seh.Next.val)\n    tib.ExceptionList.val = seh.Next.val\n    dump_seh(jitter)\n    if status == 0:\n        log.debug('SEH continue')\n        jitter.pc = jitter.cpu.EIP\n        log.debug('Context::Eip: %x', jitter.pc)\n    elif status == 1:\n        log.debug('Delegate to the next SEH handler')\n        exception_record = EXCEPTION_RECORD(jitter.vm, context_address - 252 + 232)\n        pc = fake_seh_handler(jitter, exception_record.ExceptionCode, seh_address)\n        jitter.pc = pc\n    else:\n        raise ValueError('Valid values are ExceptionContinueExecution and ExceptionContinueSearch')\n    return True",
            "def return_from_seh(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Handle the return from an exception handler\\n    @jitter: jitter instance'\n    seh_address = jitter.vm.get_u32(jitter.cpu.ESP + 4)\n    context_address = jitter.vm.get_u32(jitter.cpu.ESP + 8)\n    log.debug('Context address: %x', context_address)\n    status = jitter.cpu.EAX\n    ctxt2regs(jitter, context_address)\n    tib = NT_TIB(jitter.vm, tib_address)\n    seh = tib.ExceptionList.deref\n    log.debug('Old seh: %x New seh: %x', seh.get_addr(), seh.Next.val)\n    tib.ExceptionList.val = seh.Next.val\n    dump_seh(jitter)\n    if status == 0:\n        log.debug('SEH continue')\n        jitter.pc = jitter.cpu.EIP\n        log.debug('Context::Eip: %x', jitter.pc)\n    elif status == 1:\n        log.debug('Delegate to the next SEH handler')\n        exception_record = EXCEPTION_RECORD(jitter.vm, context_address - 252 + 232)\n        pc = fake_seh_handler(jitter, exception_record.ExceptionCode, seh_address)\n        jitter.pc = pc\n    else:\n        raise ValueError('Valid values are ExceptionContinueExecution and ExceptionContinueSearch')\n    return True",
            "def return_from_seh(jitter):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Handle the return from an exception handler\\n    @jitter: jitter instance'\n    seh_address = jitter.vm.get_u32(jitter.cpu.ESP + 4)\n    context_address = jitter.vm.get_u32(jitter.cpu.ESP + 8)\n    log.debug('Context address: %x', context_address)\n    status = jitter.cpu.EAX\n    ctxt2regs(jitter, context_address)\n    tib = NT_TIB(jitter.vm, tib_address)\n    seh = tib.ExceptionList.deref\n    log.debug('Old seh: %x New seh: %x', seh.get_addr(), seh.Next.val)\n    tib.ExceptionList.val = seh.Next.val\n    dump_seh(jitter)\n    if status == 0:\n        log.debug('SEH continue')\n        jitter.pc = jitter.cpu.EIP\n        log.debug('Context::Eip: %x', jitter.pc)\n    elif status == 1:\n        log.debug('Delegate to the next SEH handler')\n        exception_record = EXCEPTION_RECORD(jitter.vm, context_address - 252 + 232)\n        pc = fake_seh_handler(jitter, exception_record.ExceptionCode, seh_address)\n        jitter.pc = pc\n    else:\n        raise ValueError('Valid values are ExceptionContinueExecution and ExceptionContinueSearch')\n    return True"
        ]
    }
]